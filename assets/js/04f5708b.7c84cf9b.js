"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[9862],{23:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return d},default:function(){return h}});var a=n(3117),o=n(102),s=(n(7294),n(3905)),r=n(3052),i=["components"],c={id:"side-effects",title:"Side Effects"},l=void 0,u={unversionedId:"walkthrough/side-effects",id:"walkthrough/side-effects",isDocsHomePage:!1,title:"Side Effects",description:"Zedux stores do not have middleware. Read more on that in the Redux comparison. Basic side effects like logging and state persistence can be done by hooking into a store's side effects layer.",source:"@site/docs/walkthrough/side-effects.mdx",sourceDirName:"walkthrough",slug:"/walkthrough/side-effects",permalink:"/zedux/docs/walkthrough/side-effects",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/walkthrough/side-effects.mdx",tags:[],version:"current",frontMatter:{id:"side-effects",title:"Side Effects"},sidebar:"react",previous:{title:"Stores",permalink:"/zedux/docs/walkthrough/stores"},next:{title:"State Machines",permalink:"/zedux/docs/walkthrough/state-machines"}},d=[{value:"<code>injectEffect()</code>",id:"injecteffect",children:[],level:2},{value:"Effects Subscribers",id:"effects-subscribers",children:[],level:2},{value:"WhenBuilder",id:"whenbuilder",children:[{value:"<code>.receivesAction()</code>",id:"receivesaction",children:[{value:"<code>.setState()</code>",id:"setstate",children:[],level:4}],level:3},{value:"<code>.stateChanges()</code>",id:"statechanges",children:[],level:3},{value:"<code>.stateMatches()</code>",id:"statematches",children:[],level:3},{value:"Chaining",id:"chaining",children:[],level:3},{value:"Cleanup",id:"cleanup",children:[],level:3}],level:2},{value:"A Note On Store Actions",id:"a-note-on-store-actions",children:[],level:2},{value:"Observables",id:"observables",children:[],level:2},{value:"Recap",id:"recap",children:[],level:2},{value:"Next Steps",id:"next-steps",children:[],level:2}],p={toc:d};function h(e){var t=e.components,n=(0,o.Z)(e,i);return(0,s.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Zedux stores do not have middleware. Read more on that in the ",(0,s.kt)("a",{parentName:"p",href:"../about/redux-comparison"},"Redux comparison"),". Basic side effects like logging and state persistence can be done by hooking into a store's side effects layer."),(0,s.kt)("p",null,"In general, side effects should be colocated with the state that triggers them and that they act upon. This is exactly what we do in React thanks to hooks. In Zedux, we can use injectors:"),(0,s.kt)("h2",{id:"injecteffect"},(0,s.kt)("inlineCode",{parentName:"h2"},"injectEffect()")),(0,s.kt)("p",null,"Your primary weapon for running side effects in atoms. This works just like React's ",(0,s.kt)("a",{parentName:"p",href:"https://reactjs.org/docs/hooks-reference.html#useeffect"},(0,s.kt)("inlineCode",{parentName:"a"},"useEffect()")),"."),(0,s.kt)(r.u,{resultVar:"Alert",mdxType:"LiveEditor"},"\nconst alertAtom = atom('alert', () => {\n  const store = injectStore(0, true) // true subscribes to the store\n\n  injectEffect(() => {\n    const state = store.getState()\n\n    if (state === 0) return\n\n    alert('Hey! You changed the state to ' + state)\n  }, [store.getState()])\n\n  return store // remember to return the store\n})\n\nfunction Alert() {\n  const [, setState] = useAtomState(alertAtom)\n\n  return (\n    <button onClick={() => setState(state => state + 1)}>Show Alert</button>\n  )\n}\n"),(0,s.kt)("h2",{id:"effects-subscribers"},"Effects Subscribers"),(0,s.kt)("p",null,"Stores can be given an effects subscriber:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"function App() {\n  const { store } = useAtomInstance(myAtom)\n\n  useEffect(() => {\n    const subscription = store.subscribe({\n      effects: ({ action, newState, oldState }) => {\n        console.log('running effect', { action, newState, oldState })\n      }\n    })\n\n    return () => subscription.unsubscribe()\n  }, [store])\n  ...\n}\n")),(0,s.kt)("p",null,"See the full effect subscriber definition ",(0,s.kt)("a",{parentName:"p",href:"/not-done"},"here"),". Effects subscribers are simple and powerful. But you shouldn't need to rig them up manually. Zedux exposes a high-level API that does this for you:"),(0,s.kt)("h2",{id:"whenbuilder"},"WhenBuilder"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"when()")," is a declarative and simple way to hook into stores. It has several methods for tying into certain events and status updates in stores."),(0,s.kt)("h3",{id:"receivesaction"},(0,s.kt)("inlineCode",{parentName:"h3"},".receivesAction()")),(0,s.kt)("p",null,"Calls an effect handler every time the store receives an action."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { useAtomInstance, when } from '@zedux/react'\n\nfunction App() {\n  const { store } = useAtomInstance(myAtom)\n\n  useEffect(() => {\n    // highlight-next-line\n    const { subscription } = when(store).receivesAction(\n      ({ action, newState, oldState }) => {\n        console.log('store received action', { action, newState, oldState })\n      }\n    )\n\n    return () => subscription.unsubscribe()\n  }, [store])\n  ...\n}\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},".receivesAction()")," can be given a specific actor or action type:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { createActor, when } from '@zedux/react'\n\nconst login = createActor('login')\nwhen(myStore).receivesAction(login, doStuffOnLogin)\n")),(0,s.kt)("p",null,"In this way, stores can easily be consumed as streams of actions."),(0,s.kt)("h4",{id:"setstate"},(0,s.kt)("inlineCode",{parentName:"h4"},".setState()")),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"store.setState()")," is called, Zedux translates that into a dispatch of the special ",(0,s.kt)("inlineCode",{parentName:"p"},"HYDRATE")," action. To listen to only this action, import the ",(0,s.kt)("inlineCode",{parentName:"p"},"actionTypes")," object and use the ",(0,s.kt)("inlineCode",{parentName:"p"},".HYDRATE")," property:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { actionTypes, when } from '@zedux/react'\n\nwhen(store).receivesAction(actionTypes.HYDRATE, handleSetState)\n")),(0,s.kt)("h3",{id:"statechanges"},(0,s.kt)("inlineCode",{parentName:"h3"},".stateChanges()")),(0,s.kt)("p",null,"Calls an effect handler every time the store's state changes in response to an action (which includes every time ",(0,s.kt)("inlineCode",{parentName:"p"},".setState()")," is called)."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"when(myStore).stateChanges(({ action, newState, oldState }) => {\n  console.log('store state changed', { action, newState, oldState })\n})\n")),(0,s.kt)("h3",{id:"statematches"},(0,s.kt)("inlineCode",{parentName:"h3"},".stateMatches()")),(0,s.kt)("p",null,"Calls an effect handler every time the store's state updates to match the passed predicate. Does not call the handler if the previous state also matched the predicate."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const counterStore = createStore(null, 0)\n\nwhen(counterStore).stateMatches(\n  num => num > 1,\n  ({ newState, oldState }) => {\n    console.log('triggered!', { newState, oldState })\n  }\n)\n\ncounterStore.setState(1)\ncounterStore.setState(2) // triggered! { newState: 2, oldState: 1 }\ncounterStore.setState(3)\ncounterStore.setState(0)\ncounterStore.setState(4) // triggered! { newState: 4, oldState: 0 }\n")),(0,s.kt)("p",null,"To perform a side effect on every action or every state change while the predicate is matched, regardless of previous state, use ",(0,s.kt)("inlineCode",{parentName:"p"},".receivesAction()")," or ",(0,s.kt)("inlineCode",{parentName:"p"},".stateChanges()")," with a normal if statement:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"when(counterStore).receivesAction(({ newState, oldState }) => {\n  if (newState > 1) {\n    console.log('triggered!', { newState, oldState })\n  }\n})\n\ncounterStore.setState(1)\ncounterStore.setState(2) // triggered! { newState: 2, oldState: 1 }\ncounterStore.setState(3) // triggered! { newState: 3, oldState: 2 }\ncounterStore.setState(0)\ncounterStore.setState(4) // triggered! { newState: 4, oldState: 0 }\n")),(0,s.kt)("h3",{id:"chaining"},"Chaining"),(0,s.kt)("p",null,"Multiple handlers can be chained together."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"when(myStore).receivesAction(logAction).stateChanges(persistStateChange)\n\n// Or\nconst whenMyStore = when(myStore)\n\nwhenMyStore.receivesAction(logAction)\nwhenMyStore.stateChanges(persistStateChange)\n")),(0,s.kt)("h3",{id:"cleanup"},"Cleanup"),(0,s.kt)("p",null,"As with all subscriptions, it's important to clean up effects subscribers when their context is destroyed (e.g. the component is unmounted or the atom instance is destroyed)."),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"when()")," builders have a ",(0,s.kt)("inlineCode",{parentName:"p"},"subscription")," property, which is a reference to the store subscription created by the ",(0,s.kt)("inlineCode",{parentName:"p"},"when()")," call. Remember to call ",(0,s.kt)("inlineCode",{parentName:"p"},"subscription.unsubscribe()")," in ",(0,s.kt)("inlineCode",{parentName:"p"},"useEffect")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"injectEffect"),":"),(0,s.kt)(r.u,{resultVar:"Button",mdxType:"LiveEditor"},"\nconst triggerAlert = createActor('triggerAlert')\n\nconst buttonPressAtom = atom('buttonPress', () => {\n  const store = injectStore()\n\n  injectEffect(() => {\n    const { subscription } = when(store).receivesAction(\n      triggerAlert,\n      () => alert('consider it done')\n    )\n\n    return () => subscription.unsubscribe()\n  }, [store])\n\n  return store\n})\n\nfunction Button() {\n  const { dispatch } = useAtomInstance(buttonPressAtom)\n\n  return (\n    <button onClick={() => dispatch(triggerAlert())}>Do It</button>\n  )\n}\n"),(0,s.kt)("p",null,"For the full API, see ",(0,s.kt)("a",{parentName:"p",href:"/not-done"},(0,s.kt)("inlineCode",{parentName:"a"},"when()")),"."),(0,s.kt)("h2",{id:"a-note-on-store-actions"},"A Note On Store Actions"),(0,s.kt)("p",null,'Zedux\' store composition model works by making actions themselves composable objects called ActionChains. The ActionChain contains needed metadata for Zedux to perform its store composition magic. ActionChains consist of any number of "meta nodes" with the wrapped action being the last node in the chain.'),(0,s.kt)("p",null,"We'll go over the specifics of Zedux' store composition model in ",(0,s.kt)("a",{parentName:"p",href:"/not-done"},"the store composition guide"),". For now you just need to know that, depending on your store setup, you may see these ActionChain objects as the ",(0,s.kt)("inlineCode",{parentName:"p"},"action")," property in your effects handlers. Zedux doesn't unwrap the action because sometimes you will need to observe the metadata the action is wrapped in."),(0,s.kt)("p",null,"If you don't care about the metadata, you can get the wrapped action with ",(0,s.kt)("inlineCode",{parentName:"p"},"removeAllMeta")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { removeAllMeta, when } from '@zedux/react'\n\nwhen(store).receivesAction(({ action }) => {\n  const unwrappedAction = removeAllMeta(action)\n\n  switch (unwrappedAction.type) { ... }\n})\n\nstore.subscribe((newState, oldState, actionChain) => {\n  const action = removeAllMeta(actionChain)\n})\n")),(0,s.kt)("h2",{id:"observables"},"Observables"),(0,s.kt)("p",null,"Zedux stores are a type of observable. However, Zedux doesn't have any built-in helpers (currently) for integrating with observable libraries such as ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/ReactiveX/rxjs"},"RxJS"),". But Zedux' extreme flexibility makes working with observables easy."),(0,s.kt)("p",null,"For example, any atom's value can be an observable:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { atom } from '@zedux/react'\nimport { of } from 'rxjs'\n\nconst observableValue = atom('observableValue', of('hello, world'))\n")),(0,s.kt)("p",null,"This can be useful for taking advantage of Zedux' caching abilities to share observable references."),(0,s.kt)("p",null,"You can export an observable from any atom:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { api, atom, injectMemo } from '@zedux/react'\nimport { from } from 'rxjs'\n\nconst usersStreamAtom = atom('usersStream', () => {\n  const users$ = injectMemo(() => from(streamUsers()), [])\n\n  return api().setExports({\n    users$,\n  })\n})\n")),(0,s.kt)("p",null,"Handling observable subscriptions is easy with ",(0,s.kt)("inlineCode",{parentName:"p"},"injectEffect()"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { atom, injectAtomValue, injectEffect, injectStore } from '@zedux/react'\n\nconst userAtom = atom('user', () => {\n  const user$ = injectAtomValue(userStreamAtom)\n  const store = injectStore(null)\n\n  injectEffect(() => {\n    const subscription = user$.subscribe(val => store.setState(val))\n\n    return () => subscription.unsubscribe()\n  }, [user$])\n\n  return store\n})\n")),(0,s.kt)("h2",{id:"recap"},"Recap"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"injectEffect()")," is your main tool for binding side effects to an atom."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"when(store).receivesAction()")," runs a side effect on every action."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"when(store).stateChanges()")," runs a side effect on every state change."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"when(store).stateMatches()")," runs a side effect when the store's new state passes the predicate function, but the old state did not."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"when(store).machine().enters()")," runs a side effect when a state machine in the store enters a state."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"when(store).machine().leaves()")," runs a side effect when a state machine in the store leaves a state."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"when(store).subscription.unsubscribe()")," cleans up the subscription."),(0,s.kt)("li",{parentName:"ul"},"Zedux' flexible paradigm allows you to use any tools for managing asynchrony or any kind of side effects, such as RxJS streams or JavaScript generators.")),(0,s.kt)("h2",{id:"next-steps"},"Next Steps"),(0,s.kt)("p",null,"We've learned a lot about stores at this point. It's about time we take a closer look at one of their most useful features - ",(0,s.kt)("a",{parentName:"p",href:"state-machines"},"state machines"),"."))}h.isMDXComponent=!0}}]);