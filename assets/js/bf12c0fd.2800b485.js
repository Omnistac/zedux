"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[6866],{5782:function(t,e,n){n.r(e),n.d(e,{frontMatter:function(){return r},contentTitle:function(){return i},metadata:function(){return c},toc:function(){return m},default:function(){return d}});var a=n(3117),o=n(102),s=(n(7294),n(3905)),l=(n(3052),["components"]),r={id:"local-atoms",title:"Local Atoms"},i=void 0,c={unversionedId:"walkthrough/local-atoms",id:"walkthrough/local-atoms",isDocsHomePage:!1,title:"Local Atoms",description:"Local atoms are a very unique concept. Their primary use is very similar to React context's.",source:"@site/docs/walkthrough/local-atoms.mdx",sourceDirName:"walkthrough",slug:"/walkthrough/local-atoms",permalink:"/zedux/docs/walkthrough/local-atoms",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/walkthrough/local-atoms.mdx",tags:[],version:"current",frontMatter:{id:"local-atoms",title:"Local Atoms"}},m=[{value:"Comparison to Standard Atoms",id:"comparison-to-standard-atoms",children:[{value:"Instantiation",id:"instantiation",children:[],level:3},{value:"Parameters",id:"parameters",children:[],level:3},{value:"Hooks",id:"hooks",children:[],level:3},{value:"Destruction",id:"destruction",children:[],level:3}],level:2},{value:"Comparison to React Context",id:"comparison-to-react-context",children:[{value:"DI",id:"di",children:[],level:3},{value:"Example",id:"example",children:[],level:3}],level:2}],u={toc:m};function d(t){var e=t.components,n=(0,o.Z)(t,l);return(0,s.kt)("wrapper",(0,a.Z)({},u,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Local atoms are a very unique concept. Their primary use is very similar to React context's."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import { localAtom } from '@zedux/react'\n\nconst myLocalAtom = localAtom(\n  'myLocal',\n  'I am like React context but with Zedux superpowers'\n)\n")),(0,s.kt)("p",null,"Local atoms are a completely different atom type from standard atoms. Their API is different, though it tries to appear similar to the standard atom API."),(0,s.kt)("h2",{id:"comparison-to-standard-atoms"},"Comparison to Standard Atoms"),(0,s.kt)("h3",{id:"instantiation"},"Instantiation"),(0,s.kt)("p",null,"Unlike standard atoms, Local atoms are instantiated every time you call ",(0,s.kt)("inlineCode",{parentName:"p"},".useInstance()"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"function App() {\n  const instanceOne = myLocalAtom.useInstance()\n  const instanceTwo = myLocalAtom.useInstance() // a different instance!\n  ...\n}\n")),(0,s.kt)("h3",{id:"parameters"},"Parameters"),(0,s.kt)("p",null,"With local atoms, ",(0,s.kt)("inlineCode",{parentName:"p"},".useInstance()")," is the only hook that accepts parameters - because it's the only hook that triggers atom instantiation. Unlike standard atoms, passing the same parameters will always create a new instance."),(0,s.kt)("p",null,"No other local atom hooks accept parameters."),(0,s.kt)("h3",{id:"hooks"},"Hooks"),(0,s.kt)("p",null,"Local atoms have many of the same hooks as standard atoms. But all hooks are all slightly different from their standard atom counterparts."),(0,s.kt)("p",null,"All other local atom hooks are aliases for ",(0,s.kt)("inlineCode",{parentName:"p"},".useConsumer().use<hook name here>()"),". They expect an instance to be provided over React. They do not accept parameters."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const loginFormAtom = atom('loginForm', () => ({\n  email: '',\n  password: ''\n}))\n\nfunction LoginForm() {\n  const loginForm = loginFormAtom.useInstance()\n\n  return (\n    // highlight-next-line\n    <loginForm.Provider>\n      <Email />\n      <Password />\n    </loginForm.Provider>\n  )\n}\n\nfunction Email() {\n  // A shorthand for `loginForm.useConsumer().useState()`:\n  // highlight-next-line\n  const [{ email }, setState] = loginFormAtom.useState()\n  ...\n}\n\nfunction Password() {\n  // (same as above)\n  // highlight-next-line\n  const [{ password }, setPassword] = loginFormAtom.useState()\n  ...\n}\n")),(0,s.kt)("p",null,"Local atoms only have one injector - ",(0,s.kt)("inlineCode",{parentName:"p"},".injectInstance()"),". The instance returned has all the normal instance injectors. While this works and it's fine to use, local atoms aren't really intended for use in other atoms."),(0,s.kt)("h3",{id:"destruction"},"Destruction"),(0,s.kt)("p",null,"Local atoms are always cleaned up when they're no longer in use. This can't be configured (local atoms don't take a ",(0,s.kt)("inlineCode",{parentName:"p"},"ttl"),")."),(0,s.kt)("p",null,"In most cases, this means that when the component or atom that created the local atom instance is unmounted or destroyed, the local atom instance will also be destroyed. Since this is similar to how React context providers work, this is usually what you want."),(0,s.kt)("h2",{id:"comparison-to-react-context"},"Comparison to React Context"),(0,s.kt)("p",null,"Local atoms use React context under the hood. But they don't use it for state management, they use it for dependency injection."),(0,s.kt)("h3",{id:"di"},"DI"),(0,s.kt)("p",null,"Remember that atoms use observable/subscription-model stores internally. React context's role is merely to pass the stores themselves down through the component tree. It doesn't pass state directly."),(0,s.kt)("p",null,"Local atoms don't trigger unnecessary rerenders, unlike raw React context."),(0,s.kt)("h3",{id:"example"},"Example"),(0,s.kt)("p",null,"Each local atom instance is essentially bound to a React component. The instance will be automatically cleaned up when the component that called ",(0,s.kt)("inlineCode",{parentName:"p"},".useInstance()")," unmounts."),(0,s.kt)("p",null,"This mimics the typical flow of React context, where you manage state in a parent component and provide that to children via a context Provider's ",(0,s.kt)("inlineCode",{parentName:"p"},"value")," prop:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const myContext = createContext({ setState: noop, state: 'default value' })\n\nfunction Parent() {\n  // this state will die when this component unmounts\n  const [state, setState] = useState('some state')\n\n  return (\n    <myContext.Provider value={{ setState, state }}>\n      <Child />\n    </myContext.Provider>\n  )\n}\n\nfunction Child() {\n  const { state } = useContext(myContext)\n}\n")),(0,s.kt)("p",null,"If you know much about React context, the above code snippet should have triggered several alarms for you. Plenty has already been written about the caveats of React context and circumventing them, so we won't go into that here."),(0,s.kt)("p",null,"But let's look at an equivalent example using local atoms:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"const myLocalAtom = localAtom('myLocal', 'default value')\n\nfunction Parent() {\n  // this atom will die when this component unmounts\n  const instance = myLocalAtom.useInstance()\n\n  return (\n    <instance.Provider>\n      <Child />\n    </instance.Provider>\n  )\n}\n\nfunction Child() {\n  const state = myLocalAtom.useValue()\n}\n")))}d.isMDXComponent=!0}}]);