"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[1431],{216:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "assets": function() { return /* binding */ assets; },\n/* harmony export */   "contentTitle": function() { return /* binding */ contentTitle; },\n/* harmony export */   "default": function() { return /* binding */ MDXContent; },\n/* harmony export */   "frontMatter": function() { return /* binding */ frontMatter; },\n/* harmony export */   "metadata": function() { return /* binding */ metadata; },\n/* harmony export */   "toc": function() { return /* binding */ toc; }\n/* harmony export */ });\n/* harmony import */ var _Users_joshuaclaunch_code_oss_zedux_docs_node_modules_babel_runtime_helpers_esm_extends_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7462);\n/* harmony import */ var _Users_joshuaclaunch_code_oss_zedux_docs_node_modules_babel_runtime_helpers_esm_objectWithoutPropertiesLoose_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3366);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7294);\n/* harmony import */ var _mdx_js_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3905);\nvar _excluded=["components"];/* @jsxRuntime classic */ /* @jsx mdx */ /* @jsxFrag React.Fragment */var frontMatter={id:\'more-patterns\',title:\'More Patterns\'};var contentTitle=undefined;var metadata={"unversionedId":"advanced/more-patterns","id":"advanced/more-patterns","title":"More Patterns","description":"Circular Dependencies","source":"@site/docs/advanced/more-patterns.mdx","sourceDirName":"advanced","slug":"/advanced/more-patterns","permalink":"/zedux/docs/advanced/more-patterns","draft":false,"editUrl":"https://github.com/Omnistac/zedux/tree/master/docs/advanced/more-patterns.mdx","tags":[],"version":"current","frontMatter":{"id":"more-patterns","title":"More Patterns"},"sidebar":"react","previous":{"title":"Complex Params","permalink":"/zedux/docs/advanced/complex-params"},"next":{"title":"Persistence","permalink":"/zedux/docs/advanced/persistence"}};var assets={};var toc=[{value:\'Circular Dependencies\',id:\'circular-dependencies\',level:2},{value:\'Atom Factories\',id:\'atom-factories\',level:2},{value:\'Atom Instance Factories\',id:\'atom-instance-factories\',level:2},{value:\'Recursive Atoms\',id:\'recursive-atoms\',level:2},{value:\'Params Are Constant\',id:\'params-are-constant\',level:2},{value:\'Updating other atoms during evaluation\',id:\'updating-other-atoms-during-evaluation\',level:2}];var layoutProps={toc:toc};var MDXLayout="wrapper";function MDXContent(_ref){var components=_ref.components,props=(0,_Users_joshuaclaunch_code_oss_zedux_docs_node_modules_babel_runtime_helpers_esm_objectWithoutPropertiesLoose_js__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .Z)(_ref,_excluded);return (0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)(MDXLayout,(0,_Users_joshuaclaunch_code_oss_zedux_docs_node_modules_babel_runtime_helpers_esm_extends_js__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .Z)({},layoutProps,props,{components:components,mdxType:"MDXLayout"}),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("h2",{"id":"circular-dependencies"},"Circular Dependencies"),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"It is always possible to design an atom graph without any circular dependencies. That said, sometimes it can be very hard to do so - requirements change, the new guy comes in, or sometimes the state is just very complex."),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"Zedux\'s atomic model can\'t support circular dependencies ... or can it?"),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"Alright, strictly speaking, direct circular dependencies are not allowed:"),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("pre",null,(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("code",{parentName:"pre","className":"language-ts"},"const atomA = atom(\'a\', () => {\\n  injectAtomValue(atomB)\\n})\\n\\nconst atomB = atom(\'b\', () => {\\n  injectAtomValue(atomA) // <- circular dep! This will always break everything\\n})\\n")),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"But there are some workarounds. The basic idea for all of them is: Only make one dependency, e.g. ",(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("inlineCode",{parentName:"p"},"a -> b")," (a depends on b). Load the other atom when needed, e.g. ",(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("inlineCode",{parentName:"p"},"get(atomA)")," in a ",(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("inlineCode",{parentName:"p"},"b")," callback or effect."),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("pre",null,(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("code",{parentName:"pre","className":"language-ts"},"import {\\n  api,\\n  atom,\\n  injectAtomGetters,\\n  injectAtomInstance,\\n  injectStore,\\n} from \'@zedux/react\'\\n\\nconst connectionAtom = atom(\'connection\', () => {\\n  const { getInstance } = injectAtomGetters()\\n\\n  // instead of registering a dependency on loginAtom like this:\\n  // const { login } = getInstance(loginAtom).exports\\n  // get the instance right when it\'s needed (inside an exported callback):\\n  // highlight-next-line\\n  const logout = () => getInstance(loginAtom).exports.reset()\\n\\n  const post = (url: string, data: any) =>\\n    fetch(url, { body: JSON.stringify(data), method: \'POST\' }).then(data =>\\n      data.json()\\n    )\\n\\n  return api().setExports({ logout, post })\\n})\\n\\nconst loginAtom = atom(\'login\', () => {\\n  // highlight-next-line\\n  const { post } = injectAtomInstance(connectionAtom).exports\\n  const store = injectStore({ email: \'\', password: \'\' })\\n\\n  const reset = () => store.setState({ email: \'\', password: \'\' })\\n  const setEmail = (email: string) => store.setStateDeep({ email })\\n  const setPassword = (password: string) => store.setStateDeep({ password })\\n  const submit = () => post(\'/login\', store.getState())\\n\\n  return api(store).setExports({ reset, setEmail, setPassword, submit })\\n})\\n")),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"(Note that the better solution here is to move the ",(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("inlineCode",{parentName:"p"},"logout")," function somewhere else - e.g. inside ",(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("inlineCode",{parentName:"p"},"loginAtom")," - completely avoiding the circular dependency in the first place)."),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"Another possible solution is to pass a ",(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("a",{parentName:"p","href":"../api/factories/createInjector#partial-instance"},"partial instance")," as a ",(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("a",{parentName:"p","href":"../walkthrough/the-graph#instances-as-params"},"param")," to the other atom (yes, a partial instance is supported just like a normal instance). This would work as long as the \\"child\\" atom doesn\'t register any kind of graph dependency on the received \\"parent\\" atom instance."),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("admonition",{"title":"important","type":"info"},(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",{parentName:"admonition"},"You may be tempted to use manual graphing to create a real dependency asynchronously. This is not supported. Zedux\'s graph is acyclic, meaning circular dependencies break everything no matter how they\'re created. It is possible to change that, but we don\'t want to for performance reasons.")),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("h2",{"id":"atom-factories"},"Atom Factories"),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"A common pattern is creating a helper function to create pre-configured atoms:"),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("pre",null,(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("code",{parentName:"pre","className":"language-ts"},"const mapAtom = <State extends Map<any, any>, Params extends any[]>(\\n  key: string,\\n  stateFactory: (...params: Params) => State | Store<State> | AtomApi<State>,\\n  config?: AtomConfig<State>\\n) => {\\n  return atom(key, stateFactory, {\\n    ...config,\\n    dehydrate: map => Object.fromEntries(map.entries()),\\n    hydrate: obj => new Map(Object.entries(obj)),\\n  })\\n}\\n\\nconst exampleMapAtom = mapAtom(\'example\', () => new Map())\\n")),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"Beyond simple config, this can be used to gain more control over types. For example, it isn\'t possible to change an atom instance\'s inferred state type based on params. Every instance of an atom is expected to have the same state type."),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"While you can use a TypeScript union, and that works well enough, you can also use an atom factory to create completely different atom templates. Of course, this approach might require manual param serializing (",(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("a",{parentName:"p","href":"../api/classes/AtomTemplate#getinstanceid"},(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("inlineCode",{parentName:"a"},"atom.getInstanceId()"))," to the rescue!) and potentially lots of manual typing to create the properly-typed atoms. But it ",(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("em",{parentName:"p"},"could")," be worth it."),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("h2",{"id":"atom-instance-factories"},"Atom Instance Factories"),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"Zedux creates atom instances dynamically whenever they\'re first used. This is very convenient but takes some control out of your hands. Pro Tip: You can use Atom Selectors to get that control back."),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"Remember that Atom Selectors can return absolutely anything. Well, that means they can also return atom instances. Also remember that atoms can export anything. Well, that means they can also export something that indicates if the atom instance was just created or is missing some ref value or ... anything!"),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("pre",null,(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("code",{parentName:"pre","className":"language-ts"},"const formFieldAtom = atom(\'formField\', (fieldName: string) => {\\n  const store = injectStore(\'\')\\n  const isValidRef = injectRef()\\n\\n  return api(store).setExports({ isValidRef })\\n})\\n\\nconst getFormFieldInstance = (\\n  { getInstance }: AtomGetters,\\n  fieldName: string,\\n  isValid: (val: string) => boolean\\n) => {\\n  const instance = getInstance(formFieldAtom, [fieldName])\\n\\n  // if the formField doesn\'t have its validator set yet, set it\\n  if (!instance.exports.isValidRef) {\\n    instance.exports.isValidRef.current = isValid\\n  }\\n\\n  return instance\\n}\\n\\nfunction Form() {\\n  // now instead of `useAtomInstance(formFieldAtom, \'email\')`, do:\\n  const emailFieldInstance = useAtomSelector(\\n    getFormFieldInstance,\\n    \'email\',\\n    isValidEmail\\n  )\\n\\n  // and instead of `useAtomInstance(formFieldAtom, \'password\')`, do:\\n  const passwordFieldInstance = useAtomSelector(\\n    getFormFieldInstance,\\n    \'password\',\\n    isValidPassword\\n  )\\n  ...\\n}\\n")),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"(Note that this is a contrived example. There are certainly better ways to do per-field form validation)."),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("h2",{"id":"recursive-atoms"},"Recursive Atoms"),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"Zedux doesn\'t directly have a concept of \\"recursive atoms\\" or \\"atoms-in-atoms\\". However, Zedux\'s APIs are so powerful that setting up recursive atoms is easy. Here\'s just one of many ways to go about it:"),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("pre",null,(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("code",{parentName:"pre","className":"language-tsx","metastring":"live ecosystemId=more-patterns/recursive-atoms resultVar=App","live":true,"ecosystemId":"more-patterns/recursive-atoms","resultVar":"App"},"const idGeneratorAtom = atom(\'idGenerator\', () =>\\n  api().setExports({ idCounter: injectRef(0) })\\n)\\n\\nconst nodeAtom = atom(\'node\', (id: number) => {\\n  const idGenerator = injectAtomInstance(idGeneratorAtom)\\n\\n  const store = injectStore({\\n    children: [],\\n    id,\\n  })\\n\\n  const addChild = () => {\\n    store.setStateDeep(state => ({\\n      children: [...state.children, idGenerator.exports.idCounter.current++],\\n    }))\\n  }\\n\\n  const removeChild = (targetId: number) => {\\n    store.setStateDeep(state => ({\\n      children: state.children.filter(childId => childId !== targetId),\\n    }))\\n  }\\n\\n  return api(store).setExports({ addChild, removeChild })\\n})\\n\\nfunction Node({\\n  id,\\n  onDelete,\\n}: {\\n  id: number\\n  onDelete?: (id: number) => void\\n}) {\\n  const [{ children }, { addChild, removeChild }] = useAtomState(nodeAtom, [id])\\n\\n  return (\\n    <div>\\n      <div>\\n        Node Id: {id} {onDelete && <button onClick={onDelete}>Delete</button>}\\n      </div>\\n      <ul>\\n        {children.map(id => (\\n          <li key={id}>\\n            <Node id={id} onDelete={() => removeChild(id)} />\\n          </li>\\n        ))}\\n        <li>\\n          <button onClick={addChild}>+ Add Child</button>\\n        </li>\\n      </ul>\\n    </div>\\n  )\\n}\\n\\nfunction App() {\\n  const idGenerator = useAtomInstance(idGeneratorAtom)\\n  const rootId = useMemo(() => idGenerator.exports.idCounter.current++, [])\\n\\n  return <Node id={rootId} />\\n}\\n")),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("h2",{"id":"params-are-constant"},"Params Are Constant"),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"Since Zedux creates a different atom instance if it detects different atom params, params are essentially constant; the params received by an atom instance can never change for the entire lifetime of that instance."),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"This means you ",(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("em",{parentName:"p"},"can")," conditionally add/remove injectors based on params. We definitely don\'t recommend doing this, especially if you\'re new to Zedux. But we have found some situations where it\'s convenient."),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"It also means that you don\'t need to pass params as deps to ",(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("inlineCode",{parentName:"p"},"injectMemo()"),", ",(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("inlineCode",{parentName:"p"},"injectEffect()"),", ",(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("inlineCode",{parentName:"p"},"injectCallback()"),", ",(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("inlineCode",{parentName:"p"},"injectPromise()"),", and similar injectors."),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("pre",null,(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("code",{parentName:"pre","className":"language-ts"},"const requestAtom = atom(\'request\', (endpoint: string) => {\\n  let prefix = \'\'\\n\\n  if (!endpoint.startsWith(\'http\')) {\\n    prefix = injectAtomValue(protocolAtom) // technically fine\\n  }\\n\\n  injectEffect(() => {\\n    fetch(`${prefix}${endpoint}`).then(...)\\n  }, [prefix]) // <- don\'t need to pass endpoint\\n})\\n")),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("h2",{"id":"updating-other-atoms-during-evaluation"},"Updating other atoms during evaluation"),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("p",null,"There shouldn\'t be a need for this, but it is actually fine to update other atom instances during atom evaluation ",(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("strong",{parentName:"p"},"if")," this is not the first evaluation:"),(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("pre",null,(0,_mdx_js_react__WEBPACK_IMPORTED_MODULE_1__/* .mdx */ .kt)("code",{parentName:"pre","className":"language-ts"},"const rogueAtom = atom(\'rogue\', () => {\\n  const reasons = injectWhy()\\n  const victimInstance = injectAtomInstance(victimAtom)\\n\\n  victimInstance.setState(\'sadness\') // <- Bad! Don\'t do this\\n\\n  // use injectWhy to determine if this is the initial evaluation (reasons is\\n  // empty if it is):\\n  if (reasons.length) {\\n    victimInstance.setState(\'mwahahaha\') // <- fine... but still probably don\'t\\n  }\\n  ...\\n})\\n")));};MDXContent.isMDXComponent=true;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SSxVQUFVLENBQUMsR0FBRyxRQUFhLDhMQUFrTSxDQUN2UCxxSUFBbUUsMkVBQVksVUFBVSxDQUFDLEdBQUcsaUJBQThCLE1BQU0sMkVBQVksVUFBVSxDQUFDLEdBQUcsbUJBQWdDLE1BQU0sMkVBQVksVUFBVSxDQUFDLEdBQUcscUJBQWtDLE1BQU0sMkVBQVksVUFBVSxDQUFDLEdBQUcsb0JBQWlDLDRCQUFnQyxDQUM5Vix3RUFBSyxxRUFBTSxVQUFVLENBQUMsS0FBSyxDQUN2QixXQUFXLENBQUUsYUFBYSxnVUFZekIsQ0FBTSxDQUNYLG1FQUNFLElBQUksQ0FBRSx3Q0FBd0MsMkNBQ0UsQ0FDbEQsMkxBQXlILHVFQUFRLFVBQVUsQ0FBQyxHQUFHLE9BQWdCLHNDQUEwQyxDQUN6TSx3RUFBSyxxRUFBTSxVQUFVLENBQUMsS0FBSyxDQUN2QixXQUFXLENBQUUsYUFBYSx5YUFjekIsQ0FBTSxDQUNDLENBQ2hCLENBQ0EsQ0FDQUQsVUFBVSxDQUFDRyxjQUFjLENBQUcsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi9kb2NzL2FkdmFuY2VkL21vcmUtcGF0dGVybnMubWR4PzcyMjYiXSwic291cmNlc0NvbnRlbnQiOlsiXG5cbi8qIEBqc3hSdW50aW1lIGNsYXNzaWMgKi9cbi8qIEBqc3ggbWR4ICovXG4vKiBAanN4RnJhZyBSZWFjdC5GcmFnbWVudCAqL1xuXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgbWR4IH0gZnJvbSAnQG1keC1qcy9yZWFjdCc7XG5cblxuZXhwb3J0IGNvbnN0IGZyb250TWF0dGVyID0ge1xuXHRpZDogJ21vcmUtcGF0dGVybnMnLFxuXHR0aXRsZTogJ01vcmUgUGF0dGVybnMnXG59O1xuZXhwb3J0IGNvbnN0IGNvbnRlbnRUaXRsZSA9IHVuZGVmaW5lZDtcbmV4cG9ydCBjb25zdCBtZXRhZGF0YSA9IHtcbiAgXCJ1bnZlcnNpb25lZElkXCI6IFwiYWR2YW5jZWQvbW9yZS1wYXR0ZXJuc1wiLFxuICBcImlkXCI6IFwiYWR2YW5jZWQvbW9yZS1wYXR0ZXJuc1wiLFxuICBcInRpdGxlXCI6IFwiTW9yZSBQYXR0ZXJuc1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiQ2lyY3VsYXIgRGVwZW5kZW5jaWVzXCIsXG4gIFwic291cmNlXCI6IFwiQHNpdGUvZG9jcy9hZHZhbmNlZC9tb3JlLXBhdHRlcm5zLm1keFwiLFxuICBcInNvdXJjZURpck5hbWVcIjogXCJhZHZhbmNlZFwiLFxuICBcInNsdWdcIjogXCIvYWR2YW5jZWQvbW9yZS1wYXR0ZXJuc1wiLFxuICBcInBlcm1hbGlua1wiOiBcIi96ZWR1eC9kb2NzL2FkdmFuY2VkL21vcmUtcGF0dGVybnNcIixcbiAgXCJkcmFmdFwiOiBmYWxzZSxcbiAgXCJlZGl0VXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL09tbmlzdGFjL3plZHV4L3RyZWUvbWFzdGVyL2RvY3MvYWR2YW5jZWQvbW9yZS1wYXR0ZXJucy5tZHhcIixcbiAgXCJ0YWdzXCI6IFtdLFxuICBcInZlcnNpb25cIjogXCJjdXJyZW50XCIsXG4gIFwiZnJvbnRNYXR0ZXJcIjoge1xuICAgIFwiaWRcIjogXCJtb3JlLXBhdHRlcm5zXCIsXG4gICAgXCJ0aXRsZVwiOiBcIk1vcmUgUGF0dGVybnNcIlxuICB9LFxuICBcInNpZGViYXJcIjogXCJyZWFjdFwiLFxuICBcInByZXZpb3VzXCI6IHtcbiAgICBcInRpdGxlXCI6IFwiQ29tcGxleCBQYXJhbXNcIixcbiAgICBcInBlcm1hbGlua1wiOiBcIi96ZWR1eC9kb2NzL2FkdmFuY2VkL2NvbXBsZXgtcGFyYW1zXCJcbiAgfSxcbiAgXCJuZXh0XCI6IHtcbiAgICBcInRpdGxlXCI6IFwiUGVyc2lzdGVuY2VcIixcbiAgICBcInBlcm1hbGlua1wiOiBcIi96ZWR1eC9kb2NzL2FkdmFuY2VkL3BlcnNpc3RlbmNlXCJcbiAgfVxufTtcbmV4cG9ydCBjb25zdCBhc3NldHMgPSB7XG5cbn07XG5cblxuZXhwb3J0IGNvbnN0IHRvYyA9IFt7XG4gIHZhbHVlOiAnQ2lyY3VsYXIgRGVwZW5kZW5jaWVzJyxcbiAgaWQ6ICdjaXJjdWxhci1kZXBlbmRlbmNpZXMnLFxuICBsZXZlbDogMlxufSwge1xuICB2YWx1ZTogJ0F0b20gRmFjdG9yaWVzJyxcbiAgaWQ6ICdhdG9tLWZhY3RvcmllcycsXG4gIGxldmVsOiAyXG59LCB7XG4gIHZhbHVlOiAnQXRvbSBJbnN0YW5jZSBGYWN0b3JpZXMnLFxuICBpZDogJ2F0b20taW5zdGFuY2UtZmFjdG9yaWVzJyxcbiAgbGV2ZWw6IDJcbn0sIHtcbiAgdmFsdWU6ICdSZWN1cnNpdmUgQXRvbXMnLFxuICBpZDogJ3JlY3Vyc2l2ZS1hdG9tcycsXG4gIGxldmVsOiAyXG59LCB7XG4gIHZhbHVlOiAnUGFyYW1zIEFyZSBDb25zdGFudCcsXG4gIGlkOiAncGFyYW1zLWFyZS1jb25zdGFudCcsXG4gIGxldmVsOiAyXG59LCB7XG4gIHZhbHVlOiAnVXBkYXRpbmcgb3RoZXIgYXRvbXMgZHVyaW5nIGV2YWx1YXRpb24nLFxuICBpZDogJ3VwZGF0aW5nLW90aGVyLWF0b21zLWR1cmluZy1ldmFsdWF0aW9uJyxcbiAgbGV2ZWw6IDJcbn1dO1xuXG5jb25zdCBsYXlvdXRQcm9wcyA9IHtcbiAgdG9jXG59O1xuY29uc3QgTURYTGF5b3V0ID0gXCJ3cmFwcGVyXCJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1EWENvbnRlbnQoe1xuICBjb21wb25lbnRzLFxuICAuLi5wcm9wc1xufSkge1xuICByZXR1cm4gPE1EWExheW91dCB7Li4ubGF5b3V0UHJvcHN9IHsuLi5wcm9wc30gY29tcG9uZW50cz17Y29tcG9uZW50c30gbWR4VHlwZT1cIk1EWExheW91dFwiPlxuXG4gICAgPGgyIHsuLi57XG4gICAgICBcImlkXCI6IFwiY2lyY3VsYXItZGVwZW5kZW5jaWVzXCJcbiAgICB9fT57YENpcmN1bGFyIERlcGVuZGVuY2llc2B9PC9oMj5cbiAgICA8cD57YEl0IGlzIGFsd2F5cyBwb3NzaWJsZSB0byBkZXNpZ24gYW4gYXRvbSBncmFwaCB3aXRob3V0IGFueSBjaXJjdWxhciBkZXBlbmRlbmNpZXMuIFRoYXQgc2FpZCwgc29tZXRpbWVzIGl0IGNhbiBiZSB2ZXJ5IGhhcmQgdG8gZG8gc28gLSByZXF1aXJlbWVudHMgY2hhbmdlLCB0aGUgbmV3IGd1eSBjb21lcyBpbiwgb3Igc29tZXRpbWVzIHRoZSBzdGF0ZSBpcyBqdXN0IHZlcnkgY29tcGxleC5gfTwvcD5cbiAgICA8cD57YFplZHV4J3MgYXRvbWljIG1vZGVsIGNhbid0IHN1cHBvcnQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIC4uLiBvciBjYW4gaXQ/YH08L3A+XG4gICAgPHA+e2BBbHJpZ2h0LCBzdHJpY3RseSBzcGVha2luZywgZGlyZWN0IGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhcmUgbm90IGFsbG93ZWQ6YH08L3A+XG4gICAgPHByZT48Y29kZSBwYXJlbnROYW1lPVwicHJlXCIgey4uLntcbiAgICAgICAgXCJjbGFzc05hbWVcIjogXCJsYW5ndWFnZS10c1wiXG4gICAgICB9fT57YGNvbnN0IGF0b21BID0gYXRvbSgnYScsICgpID0+IHtcbiAgaW5qZWN0QXRvbVZhbHVlKGF0b21CKVxufSlcblxuY29uc3QgYXRvbUIgPSBhdG9tKCdiJywgKCkgPT4ge1xuICBpbmplY3RBdG9tVmFsdWUoYXRvbUEpIC8vIDwtIGNpcmN1bGFyIGRlcCEgVGhpcyB3aWxsIGFsd2F5cyBicmVhayBldmVyeXRoaW5nXG59KVxuYH08L2NvZGU+PC9wcmU+XG4gICAgPHA+e2BCdXQgdGhlcmUgYXJlIHNvbWUgd29ya2Fyb3VuZHMuIFRoZSBiYXNpYyBpZGVhIGZvciBhbGwgb2YgdGhlbSBpczogT25seSBtYWtlIG9uZSBkZXBlbmRlbmN5LCBlLmcuIGB9PGlubGluZUNvZGUgcGFyZW50TmFtZT1cInBcIj57YGEgLT4gYmB9PC9pbmxpbmVDb2RlPntgIChhIGRlcGVuZHMgb24gYikuIExvYWQgdGhlIG90aGVyIGF0b20gd2hlbiBuZWVkZWQsIGUuZy4gYH08aW5saW5lQ29kZSBwYXJlbnROYW1lPVwicFwiPntgZ2V0KGF0b21BKWB9PC9pbmxpbmVDb2RlPntgIGluIGEgYH08aW5saW5lQ29kZSBwYXJlbnROYW1lPVwicFwiPntgYmB9PC9pbmxpbmVDb2RlPntgIGNhbGxiYWNrIG9yIGVmZmVjdC5gfTwvcD5cbiAgICA8cHJlPjxjb2RlIHBhcmVudE5hbWU9XCJwcmVcIiB7Li4ue1xuICAgICAgICBcImNsYXNzTmFtZVwiOiBcImxhbmd1YWdlLXRzXCJcbiAgICAgIH19PntgaW1wb3J0IHtcbiAgYXBpLFxuICBhdG9tLFxuICBpbmplY3RBdG9tR2V0dGVycyxcbiAgaW5qZWN0QXRvbUluc3RhbmNlLFxuICBpbmplY3RTdG9yZSxcbn0gZnJvbSAnQHplZHV4L3JlYWN0J1xuXG5jb25zdCBjb25uZWN0aW9uQXRvbSA9IGF0b20oJ2Nvbm5lY3Rpb24nLCAoKSA9PiB7XG4gIGNvbnN0IHsgZ2V0SW5zdGFuY2UgfSA9IGluamVjdEF0b21HZXR0ZXJzKClcblxuICAvLyBpbnN0ZWFkIG9mIHJlZ2lzdGVyaW5nIGEgZGVwZW5kZW5jeSBvbiBsb2dpbkF0b20gbGlrZSB0aGlzOlxuICAvLyBjb25zdCB7IGxvZ2luIH0gPSBnZXRJbnN0YW5jZShsb2dpbkF0b20pLmV4cG9ydHNcbiAgLy8gZ2V0IHRoZSBpbnN0YW5jZSByaWdodCB3aGVuIGl0J3MgbmVlZGVkIChpbnNpZGUgYW4gZXhwb3J0ZWQgY2FsbGJhY2spOlxuICAvLyBoaWdobGlnaHQtbmV4dC1saW5lXG4gIGNvbnN0IGxvZ291dCA9ICgpID0+IGdldEluc3RhbmNlKGxvZ2luQXRvbSkuZXhwb3J0cy5yZXNldCgpXG5cbiAgY29uc3QgcG9zdCA9ICh1cmw6IHN0cmluZywgZGF0YTogYW55KSA9PlxuICAgIGZldGNoKHVybCwgeyBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSwgbWV0aG9kOiAnUE9TVCcgfSkudGhlbihkYXRhID0+XG4gICAgICBkYXRhLmpzb24oKVxuICAgIClcblxuICByZXR1cm4gYXBpKCkuc2V0RXhwb3J0cyh7IGxvZ291dCwgcG9zdCB9KVxufSlcblxuY29uc3QgbG9naW5BdG9tID0gYXRvbSgnbG9naW4nLCAoKSA9PiB7XG4gIC8vIGhpZ2hsaWdodC1uZXh0LWxpbmVcbiAgY29uc3QgeyBwb3N0IH0gPSBpbmplY3RBdG9tSW5zdGFuY2UoY29ubmVjdGlvbkF0b20pLmV4cG9ydHNcbiAgY29uc3Qgc3RvcmUgPSBpbmplY3RTdG9yZSh7IGVtYWlsOiAnJywgcGFzc3dvcmQ6ICcnIH0pXG5cbiAgY29uc3QgcmVzZXQgPSAoKSA9PiBzdG9yZS5zZXRTdGF0ZSh7IGVtYWlsOiAnJywgcGFzc3dvcmQ6ICcnIH0pXG4gIGNvbnN0IHNldEVtYWlsID0gKGVtYWlsOiBzdHJpbmcpID0+IHN0b3JlLnNldFN0YXRlRGVlcCh7IGVtYWlsIH0pXG4gIGNvbnN0IHNldFBhc3N3b3JkID0gKHBhc3N3b3JkOiBzdHJpbmcpID0+IHN0b3JlLnNldFN0YXRlRGVlcCh7IHBhc3N3b3JkIH0pXG4gIGNvbnN0IHN1Ym1pdCA9ICgpID0+IHBvc3QoJy9sb2dpbicsIHN0b3JlLmdldFN0YXRlKCkpXG5cbiAgcmV0dXJuIGFwaShzdG9yZSkuc2V0RXhwb3J0cyh7IHJlc2V0LCBzZXRFbWFpbCwgc2V0UGFzc3dvcmQsIHN1Ym1pdCB9KVxufSlcbmB9PC9jb2RlPjwvcHJlPlxuICAgIDxwPntgKE5vdGUgdGhhdCB0aGUgYmV0dGVyIHNvbHV0aW9uIGhlcmUgaXMgdG8gbW92ZSB0aGUgYH08aW5saW5lQ29kZSBwYXJlbnROYW1lPVwicFwiPntgbG9nb3V0YH08L2lubGluZUNvZGU+e2AgZnVuY3Rpb24gc29tZXdoZXJlIGVsc2UgLSBlLmcuIGluc2lkZSBgfTxpbmxpbmVDb2RlIHBhcmVudE5hbWU9XCJwXCI+e2Bsb2dpbkF0b21gfTwvaW5saW5lQ29kZT57YCAtIGNvbXBsZXRlbHkgYXZvaWRpbmcgdGhlIGNpcmN1bGFyIGRlcGVuZGVuY3kgaW4gdGhlIGZpcnN0IHBsYWNlKS5gfTwvcD5cbiAgICA8cD57YEFub3RoZXIgcG9zc2libGUgc29sdXRpb24gaXMgdG8gcGFzcyBhIGB9PGEgcGFyZW50TmFtZT1cInBcIiB7Li4ue1xuICAgICAgICBcImhyZWZcIjogXCIuLi9hcGkvZmFjdG9yaWVzL2NyZWF0ZUluamVjdG9yI3BhcnRpYWwtaW5zdGFuY2VcIlxuICAgICAgfX0+e2BwYXJ0aWFsIGluc3RhbmNlYH08L2E+e2AgYXMgYSBgfTxhIHBhcmVudE5hbWU9XCJwXCIgey4uLntcbiAgICAgICAgXCJocmVmXCI6IFwiLi4vd2Fsa3Rocm91Z2gvdGhlLWdyYXBoI2luc3RhbmNlcy1hcy1wYXJhbXNcIlxuICAgICAgfX0+e2BwYXJhbWB9PC9hPntgIHRvIHRoZSBvdGhlciBhdG9tICh5ZXMsIGEgcGFydGlhbCBpbnN0YW5jZSBpcyBzdXBwb3J0ZWQganVzdCBsaWtlIGEgbm9ybWFsIGluc3RhbmNlKS4gVGhpcyB3b3VsZCB3b3JrIGFzIGxvbmcgYXMgdGhlIFwiY2hpbGRcIiBhdG9tIGRvZXNuJ3QgcmVnaXN0ZXIgYW55IGtpbmQgb2YgZ3JhcGggZGVwZW5kZW5jeSBvbiB0aGUgcmVjZWl2ZWQgXCJwYXJlbnRcIiBhdG9tIGluc3RhbmNlLmB9PC9wPlxuICAgIDxhZG1vbml0aW9uIHsuLi57XG4gICAgICBcInRpdGxlXCI6IFwiaW1wb3J0YW50XCIsXG4gICAgICBcInR5cGVcIjogXCJpbmZvXCJcbiAgICB9fT48cCBwYXJlbnROYW1lPVwiYWRtb25pdGlvblwiPntgWW91IG1heSBiZSB0ZW1wdGVkIHRvIHVzZSBtYW51YWwgZ3JhcGhpbmcgdG8gY3JlYXRlIGEgcmVhbCBkZXBlbmRlbmN5IGFzeW5jaHJvbm91c2x5LiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIFplZHV4J3MgZ3JhcGggaXMgYWN5Y2xpYywgbWVhbmluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYnJlYWsgZXZlcnl0aGluZyBubyBtYXR0ZXIgaG93IHRoZXkncmUgY3JlYXRlZC4gSXQgaXMgcG9zc2libGUgdG8gY2hhbmdlIHRoYXQsIGJ1dCB3ZSBkb24ndCB3YW50IHRvIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLmB9PC9wPjwvYWRtb25pdGlvbj5cbiAgICA8aDIgey4uLntcbiAgICAgIFwiaWRcIjogXCJhdG9tLWZhY3Rvcmllc1wiXG4gICAgfX0+e2BBdG9tIEZhY3Rvcmllc2B9PC9oMj5cbiAgICA8cD57YEEgY29tbW9uIHBhdHRlcm4gaXMgY3JlYXRpbmcgYSBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIHByZS1jb25maWd1cmVkIGF0b21zOmB9PC9wPlxuICAgIDxwcmU+PGNvZGUgcGFyZW50TmFtZT1cInByZVwiIHsuLi57XG4gICAgICAgIFwiY2xhc3NOYW1lXCI6IFwibGFuZ3VhZ2UtdHNcIlxuICAgICAgfX0+e2Bjb25zdCBtYXBBdG9tID0gPFN0YXRlIGV4dGVuZHMgTWFwPGFueSwgYW55PiwgUGFyYW1zIGV4dGVuZHMgYW55W10+KFxuICBrZXk6IHN0cmluZyxcbiAgc3RhdGVGYWN0b3J5OiAoLi4ucGFyYW1zOiBQYXJhbXMpID0+IFN0YXRlIHwgU3RvcmU8U3RhdGU+IHwgQXRvbUFwaTxTdGF0ZT4sXG4gIGNvbmZpZz86IEF0b21Db25maWc8U3RhdGU+XG4pID0+IHtcbiAgcmV0dXJuIGF0b20oa2V5LCBzdGF0ZUZhY3RvcnksIHtcbiAgICAuLi5jb25maWcsXG4gICAgZGVoeWRyYXRlOiBtYXAgPT4gT2JqZWN0LmZyb21FbnRyaWVzKG1hcC5lbnRyaWVzKCkpLFxuICAgIGh5ZHJhdGU6IG9iaiA9PiBuZXcgTWFwKE9iamVjdC5lbnRyaWVzKG9iaikpLFxuICB9KVxufVxuXG5jb25zdCBleGFtcGxlTWFwQXRvbSA9IG1hcEF0b20oJ2V4YW1wbGUnLCAoKSA9PiBuZXcgTWFwKCkpXG5gfTwvY29kZT48L3ByZT5cbiAgICA8cD57YEJleW9uZCBzaW1wbGUgY29uZmlnLCB0aGlzIGNhbiBiZSB1c2VkIHRvIGdhaW4gbW9yZSBjb250cm9sIG92ZXIgdHlwZXMuIEZvciBleGFtcGxlLCBpdCBpc24ndCBwb3NzaWJsZSB0byBjaGFuZ2UgYW4gYXRvbSBpbnN0YW5jZSdzIGluZmVycmVkIHN0YXRlIHR5cGUgYmFzZWQgb24gcGFyYW1zLiBFdmVyeSBpbnN0YW5jZSBvZiBhbiBhdG9tIGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIHNhbWUgc3RhdGUgdHlwZS5gfTwvcD5cbiAgICA8cD57YFdoaWxlIHlvdSBjYW4gdXNlIGEgVHlwZVNjcmlwdCB1bmlvbiwgYW5kIHRoYXQgd29ya3Mgd2VsbCBlbm91Z2gsIHlvdSBjYW4gYWxzbyB1c2UgYW4gYXRvbSBmYWN0b3J5IHRvIGNyZWF0ZSBjb21wbGV0ZWx5IGRpZmZlcmVudCBhdG9tIHRlbXBsYXRlcy4gT2YgY291cnNlLCB0aGlzIGFwcHJvYWNoIG1pZ2h0IHJlcXVpcmUgbWFudWFsIHBhcmFtIHNlcmlhbGl6aW5nIChgfTxhIHBhcmVudE5hbWU9XCJwXCIgey4uLntcbiAgICAgICAgXCJocmVmXCI6IFwiLi4vYXBpL2NsYXNzZXMvQXRvbVRlbXBsYXRlI2dldGluc3RhbmNlaWRcIlxuICAgICAgfX0+PGlubGluZUNvZGUgcGFyZW50TmFtZT1cImFcIj57YGF0b20uZ2V0SW5zdGFuY2VJZCgpYH08L2lubGluZUNvZGU+PC9hPntgIHRvIHRoZSByZXNjdWUhKSBhbmQgcG90ZW50aWFsbHkgbG90cyBvZiBtYW51YWwgdHlwaW5nIHRvIGNyZWF0ZSB0aGUgcHJvcGVybHktdHlwZWQgYXRvbXMuIEJ1dCBpdCBgfTxlbSBwYXJlbnROYW1lPVwicFwiPntgY291bGRgfTwvZW0+e2AgYmUgd29ydGggaXQuYH08L3A+XG4gICAgPGgyIHsuLi57XG4gICAgICBcImlkXCI6IFwiYXRvbS1pbnN0YW5jZS1mYWN0b3JpZXNcIlxuICAgIH19PntgQXRvbSBJbnN0YW5jZSBGYWN0b3JpZXNgfTwvaDI+XG4gICAgPHA+e2BaZWR1eCBjcmVhdGVzIGF0b20gaW5zdGFuY2VzIGR5bmFtaWNhbGx5IHdoZW5ldmVyIHRoZXkncmUgZmlyc3QgdXNlZC4gVGhpcyBpcyB2ZXJ5IGNvbnZlbmllbnQgYnV0IHRha2VzIHNvbWUgY29udHJvbCBvdXQgb2YgeW91ciBoYW5kcy4gUHJvIFRpcDogWW91IGNhbiB1c2UgQXRvbSBTZWxlY3RvcnMgdG8gZ2V0IHRoYXQgY29udHJvbCBiYWNrLmB9PC9wPlxuICAgIDxwPntgUmVtZW1iZXIgdGhhdCBBdG9tIFNlbGVjdG9ycyBjYW4gcmV0dXJuIGFic29sdXRlbHkgYW55dGhpbmcuIFdlbGwsIHRoYXQgbWVhbnMgdGhleSBjYW4gYWxzbyByZXR1cm4gYXRvbSBpbnN0YW5jZXMuIEFsc28gcmVtZW1iZXIgdGhhdCBhdG9tcyBjYW4gZXhwb3J0IGFueXRoaW5nLiBXZWxsLCB0aGF0IG1lYW5zIHRoZXkgY2FuIGFsc28gZXhwb3J0IHNvbWV0aGluZyB0aGF0IGluZGljYXRlcyBpZiB0aGUgYXRvbSBpbnN0YW5jZSB3YXMganVzdCBjcmVhdGVkIG9yIGlzIG1pc3Npbmcgc29tZSByZWYgdmFsdWUgb3IgLi4uIGFueXRoaW5nIWB9PC9wPlxuICAgIDxwcmU+PGNvZGUgcGFyZW50TmFtZT1cInByZVwiIHsuLi57XG4gICAgICAgIFwiY2xhc3NOYW1lXCI6IFwibGFuZ3VhZ2UtdHNcIlxuICAgICAgfX0+e2Bjb25zdCBmb3JtRmllbGRBdG9tID0gYXRvbSgnZm9ybUZpZWxkJywgKGZpZWxkTmFtZTogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0gaW5qZWN0U3RvcmUoJycpXG4gIGNvbnN0IGlzVmFsaWRSZWYgPSBpbmplY3RSZWYoKVxuXG4gIHJldHVybiBhcGkoc3RvcmUpLnNldEV4cG9ydHMoeyBpc1ZhbGlkUmVmIH0pXG59KVxuXG5jb25zdCBnZXRGb3JtRmllbGRJbnN0YW5jZSA9IChcbiAgeyBnZXRJbnN0YW5jZSB9OiBBdG9tR2V0dGVycyxcbiAgZmllbGROYW1lOiBzdHJpbmcsXG4gIGlzVmFsaWQ6ICh2YWw6IHN0cmluZykgPT4gYm9vbGVhblxuKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlID0gZ2V0SW5zdGFuY2UoZm9ybUZpZWxkQXRvbSwgW2ZpZWxkTmFtZV0pXG5cbiAgLy8gaWYgdGhlIGZvcm1GaWVsZCBkb2Vzbid0IGhhdmUgaXRzIHZhbGlkYXRvciBzZXQgeWV0LCBzZXQgaXRcbiAgaWYgKCFpbnN0YW5jZS5leHBvcnRzLmlzVmFsaWRSZWYpIHtcbiAgICBpbnN0YW5jZS5leHBvcnRzLmlzVmFsaWRSZWYuY3VycmVudCA9IGlzVmFsaWRcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZVxufVxuXG5mdW5jdGlvbiBGb3JtKCkge1xuICAvLyBub3cgaW5zdGVhZCBvZiBcXGB1c2VBdG9tSW5zdGFuY2UoZm9ybUZpZWxkQXRvbSwgJ2VtYWlsJylcXGAsIGRvOlxuICBjb25zdCBlbWFpbEZpZWxkSW5zdGFuY2UgPSB1c2VBdG9tU2VsZWN0b3IoXG4gICAgZ2V0Rm9ybUZpZWxkSW5zdGFuY2UsXG4gICAgJ2VtYWlsJyxcbiAgICBpc1ZhbGlkRW1haWxcbiAgKVxuXG4gIC8vIGFuZCBpbnN0ZWFkIG9mIFxcYHVzZUF0b21JbnN0YW5jZShmb3JtRmllbGRBdG9tLCAncGFzc3dvcmQnKVxcYCwgZG86XG4gIGNvbnN0IHBhc3N3b3JkRmllbGRJbnN0YW5jZSA9IHVzZUF0b21TZWxlY3RvcihcbiAgICBnZXRGb3JtRmllbGRJbnN0YW5jZSxcbiAgICAncGFzc3dvcmQnLFxuICAgIGlzVmFsaWRQYXNzd29yZFxuICApXG4gIC4uLlxufVxuYH08L2NvZGU+PC9wcmU+XG4gICAgPHA+e2AoTm90ZSB0aGF0IHRoaXMgaXMgYSBjb250cml2ZWQgZXhhbXBsZS4gVGhlcmUgYXJlIGNlcnRhaW5seSBiZXR0ZXIgd2F5cyB0byBkbyBwZXItZmllbGQgZm9ybSB2YWxpZGF0aW9uKS5gfTwvcD5cbiAgICA8aDIgey4uLntcbiAgICAgIFwiaWRcIjogXCJyZWN1cnNpdmUtYXRvbXNcIlxuICAgIH19PntgUmVjdXJzaXZlIEF0b21zYH08L2gyPlxuICAgIDxwPntgWmVkdXggZG9lc24ndCBkaXJlY3RseSBoYXZlIGEgY29uY2VwdCBvZiBcInJlY3Vyc2l2ZSBhdG9tc1wiIG9yIFwiYXRvbXMtaW4tYXRvbXNcIi4gSG93ZXZlciwgWmVkdXgncyBBUElzIGFyZSBzbyBwb3dlcmZ1bCB0aGF0IHNldHRpbmcgdXAgcmVjdXJzaXZlIGF0b21zIGlzIGVhc3kuIEhlcmUncyBqdXN0IG9uZSBvZiBtYW55IHdheXMgdG8gZ28gYWJvdXQgaXQ6YH08L3A+XG4gICAgPHByZT48Y29kZSBwYXJlbnROYW1lPVwicHJlXCIgey4uLntcbiAgICAgICAgXCJjbGFzc05hbWVcIjogXCJsYW5ndWFnZS10c3hcIixcbiAgICAgICAgXCJtZXRhc3RyaW5nXCI6IFwibGl2ZSBlY29zeXN0ZW1JZD1tb3JlLXBhdHRlcm5zL3JlY3Vyc2l2ZS1hdG9tcyByZXN1bHRWYXI9QXBwXCIsXG4gICAgICAgIFwibGl2ZVwiOiB0cnVlLFxuICAgICAgICBcImVjb3N5c3RlbUlkXCI6IFwibW9yZS1wYXR0ZXJucy9yZWN1cnNpdmUtYXRvbXNcIixcbiAgICAgICAgXCJyZXN1bHRWYXJcIjogXCJBcHBcIlxuICAgICAgfX0+e2Bjb25zdCBpZEdlbmVyYXRvckF0b20gPSBhdG9tKCdpZEdlbmVyYXRvcicsICgpID0+XG4gIGFwaSgpLnNldEV4cG9ydHMoeyBpZENvdW50ZXI6IGluamVjdFJlZigwKSB9KVxuKVxuXG5jb25zdCBub2RlQXRvbSA9IGF0b20oJ25vZGUnLCAoaWQ6IG51bWJlcikgPT4ge1xuICBjb25zdCBpZEdlbmVyYXRvciA9IGluamVjdEF0b21JbnN0YW5jZShpZEdlbmVyYXRvckF0b20pXG5cbiAgY29uc3Qgc3RvcmUgPSBpbmplY3RTdG9yZSh7XG4gICAgY2hpbGRyZW46IFtdLFxuICAgIGlkLFxuICB9KVxuXG4gIGNvbnN0IGFkZENoaWxkID0gKCkgPT4ge1xuICAgIHN0b3JlLnNldFN0YXRlRGVlcChzdGF0ZSA9PiAoe1xuICAgICAgY2hpbGRyZW46IFsuLi5zdGF0ZS5jaGlsZHJlbiwgaWRHZW5lcmF0b3IuZXhwb3J0cy5pZENvdW50ZXIuY3VycmVudCsrXSxcbiAgICB9KSlcbiAgfVxuXG4gIGNvbnN0IHJlbW92ZUNoaWxkID0gKHRhcmdldElkOiBudW1iZXIpID0+IHtcbiAgICBzdG9yZS5zZXRTdGF0ZURlZXAoc3RhdGUgPT4gKHtcbiAgICAgIGNoaWxkcmVuOiBzdGF0ZS5jaGlsZHJlbi5maWx0ZXIoY2hpbGRJZCA9PiBjaGlsZElkICE9PSB0YXJnZXRJZCksXG4gICAgfSkpXG4gIH1cblxuICByZXR1cm4gYXBpKHN0b3JlKS5zZXRFeHBvcnRzKHsgYWRkQ2hpbGQsIHJlbW92ZUNoaWxkIH0pXG59KVxuXG5mdW5jdGlvbiBOb2RlKHtcbiAgaWQsXG4gIG9uRGVsZXRlLFxufToge1xuICBpZDogbnVtYmVyXG4gIG9uRGVsZXRlPzogKGlkOiBudW1iZXIpID0+IHZvaWRcbn0pIHtcbiAgY29uc3QgW3sgY2hpbGRyZW4gfSwgeyBhZGRDaGlsZCwgcmVtb3ZlQ2hpbGQgfV0gPSB1c2VBdG9tU3RhdGUobm9kZUF0b20sIFtpZF0pXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2PlxuICAgICAgPGRpdj5cbiAgICAgICAgTm9kZSBJZDoge2lkfSB7b25EZWxldGUgJiYgPGJ1dHRvbiBvbkNsaWNrPXtvbkRlbGV0ZX0+RGVsZXRlPC9idXR0b24+fVxuICAgICAgPC9kaXY+XG4gICAgICA8dWw+XG4gICAgICAgIHtjaGlsZHJlbi5tYXAoaWQgPT4gKFxuICAgICAgICAgIDxsaSBrZXk9e2lkfT5cbiAgICAgICAgICAgIDxOb2RlIGlkPXtpZH0gb25EZWxldGU9eygpID0+IHJlbW92ZUNoaWxkKGlkKX0gLz5cbiAgICAgICAgICA8L2xpPlxuICAgICAgICApKX1cbiAgICAgICAgPGxpPlxuICAgICAgICAgIDxidXR0b24gb25DbGljaz17YWRkQ2hpbGR9PisgQWRkIENoaWxkPC9idXR0b24+XG4gICAgICAgIDwvbGk+XG4gICAgICA8L3VsPlxuICAgIDwvZGl2PlxuICApXG59XG5cbmZ1bmN0aW9uIEFwcCgpIHtcbiAgY29uc3QgaWRHZW5lcmF0b3IgPSB1c2VBdG9tSW5zdGFuY2UoaWRHZW5lcmF0b3JBdG9tKVxuICBjb25zdCByb290SWQgPSB1c2VNZW1vKCgpID0+IGlkR2VuZXJhdG9yLmV4cG9ydHMuaWRDb3VudGVyLmN1cnJlbnQrKywgW10pXG5cbiAgcmV0dXJuIDxOb2RlIGlkPXtyb290SWR9IC8+XG59XG5gfTwvY29kZT48L3ByZT5cbiAgICA8aDIgey4uLntcbiAgICAgIFwiaWRcIjogXCJwYXJhbXMtYXJlLWNvbnN0YW50XCJcbiAgICB9fT57YFBhcmFtcyBBcmUgQ29uc3RhbnRgfTwvaDI+XG4gICAgPHA+e2BTaW5jZSBaZWR1eCBjcmVhdGVzIGEgZGlmZmVyZW50IGF0b20gaW5zdGFuY2UgaWYgaXQgZGV0ZWN0cyBkaWZmZXJlbnQgYXRvbSBwYXJhbXMsIHBhcmFtcyBhcmUgZXNzZW50aWFsbHkgY29uc3RhbnQ7IHRoZSBwYXJhbXMgcmVjZWl2ZWQgYnkgYW4gYXRvbSBpbnN0YW5jZSBjYW4gbmV2ZXIgY2hhbmdlIGZvciB0aGUgZW50aXJlIGxpZmV0aW1lIG9mIHRoYXQgaW5zdGFuY2UuYH08L3A+XG4gICAgPHA+e2BUaGlzIG1lYW5zIHlvdSBgfTxlbSBwYXJlbnROYW1lPVwicFwiPntgY2FuYH08L2VtPntgIGNvbmRpdGlvbmFsbHkgYWRkL3JlbW92ZSBpbmplY3RvcnMgYmFzZWQgb24gcGFyYW1zLiBXZSBkZWZpbml0ZWx5IGRvbid0IHJlY29tbWVuZCBkb2luZyB0aGlzLCBlc3BlY2lhbGx5IGlmIHlvdSdyZSBuZXcgdG8gWmVkdXguIEJ1dCB3ZSBoYXZlIGZvdW5kIHNvbWUgc2l0dWF0aW9ucyB3aGVyZSBpdCdzIGNvbnZlbmllbnQuYH08L3A+XG4gICAgPHA+e2BJdCBhbHNvIG1lYW5zIHRoYXQgeW91IGRvbid0IG5lZWQgdG8gcGFzcyBwYXJhbXMgYXMgZGVwcyB0byBgfTxpbmxpbmVDb2RlIHBhcmVudE5hbWU9XCJwXCI+e2BpbmplY3RNZW1vKClgfTwvaW5saW5lQ29kZT57YCwgYH08aW5saW5lQ29kZSBwYXJlbnROYW1lPVwicFwiPntgaW5qZWN0RWZmZWN0KClgfTwvaW5saW5lQ29kZT57YCwgYH08aW5saW5lQ29kZSBwYXJlbnROYW1lPVwicFwiPntgaW5qZWN0Q2FsbGJhY2soKWB9PC9pbmxpbmVDb2RlPntgLCBgfTxpbmxpbmVDb2RlIHBhcmVudE5hbWU9XCJwXCI+e2BpbmplY3RQcm9taXNlKClgfTwvaW5saW5lQ29kZT57YCwgYW5kIHNpbWlsYXIgaW5qZWN0b3JzLmB9PC9wPlxuICAgIDxwcmU+PGNvZGUgcGFyZW50TmFtZT1cInByZVwiIHsuLi57XG4gICAgICAgIFwiY2xhc3NOYW1lXCI6IFwibGFuZ3VhZ2UtdHNcIlxuICAgICAgfX0+e2Bjb25zdCByZXF1ZXN0QXRvbSA9IGF0b20oJ3JlcXVlc3QnLCAoZW5kcG9pbnQ6IHN0cmluZykgPT4ge1xuICBsZXQgcHJlZml4ID0gJydcblxuICBpZiAoIWVuZHBvaW50LnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgIHByZWZpeCA9IGluamVjdEF0b21WYWx1ZShwcm90b2NvbEF0b20pIC8vIHRlY2huaWNhbGx5IGZpbmVcbiAgfVxuXG4gIGluamVjdEVmZmVjdCgoKSA9PiB7XG4gICAgZmV0Y2goXFxgXFwke3ByZWZpeH1cXCR7ZW5kcG9pbnR9XFxgKS50aGVuKC4uLilcbiAgfSwgW3ByZWZpeF0pIC8vIDwtIGRvbid0IG5lZWQgdG8gcGFzcyBlbmRwb2ludFxufSlcbmB9PC9jb2RlPjwvcHJlPlxuICAgIDxoMiB7Li4ue1xuICAgICAgXCJpZFwiOiBcInVwZGF0aW5nLW90aGVyLWF0b21zLWR1cmluZy1ldmFsdWF0aW9uXCJcbiAgICB9fT57YFVwZGF0aW5nIG90aGVyIGF0b21zIGR1cmluZyBldmFsdWF0aW9uYH08L2gyPlxuICAgIDxwPntgVGhlcmUgc2hvdWxkbid0IGJlIGEgbmVlZCBmb3IgdGhpcywgYnV0IGl0IGlzIGFjdHVhbGx5IGZpbmUgdG8gdXBkYXRlIG90aGVyIGF0b20gaW5zdGFuY2VzIGR1cmluZyBhdG9tIGV2YWx1YXRpb24gYH08c3Ryb25nIHBhcmVudE5hbWU9XCJwXCI+e2BpZmB9PC9zdHJvbmc+e2AgdGhpcyBpcyBub3QgdGhlIGZpcnN0IGV2YWx1YXRpb246YH08L3A+XG4gICAgPHByZT48Y29kZSBwYXJlbnROYW1lPVwicHJlXCIgey4uLntcbiAgICAgICAgXCJjbGFzc05hbWVcIjogXCJsYW5ndWFnZS10c1wiXG4gICAgICB9fT57YGNvbnN0IHJvZ3VlQXRvbSA9IGF0b20oJ3JvZ3VlJywgKCkgPT4ge1xuICBjb25zdCByZWFzb25zID0gaW5qZWN0V2h5KClcbiAgY29uc3QgdmljdGltSW5zdGFuY2UgPSBpbmplY3RBdG9tSW5zdGFuY2UodmljdGltQXRvbSlcblxuICB2aWN0aW1JbnN0YW5jZS5zZXRTdGF0ZSgnc2FkbmVzcycpIC8vIDwtIEJhZCEgRG9uJ3QgZG8gdGhpc1xuXG4gIC8vIHVzZSBpbmplY3RXaHkgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgaXMgdGhlIGluaXRpYWwgZXZhbHVhdGlvbiAocmVhc29ucyBpc1xuICAvLyBlbXB0eSBpZiBpdCBpcyk6XG4gIGlmIChyZWFzb25zLmxlbmd0aCkge1xuICAgIHZpY3RpbUluc3RhbmNlLnNldFN0YXRlKCdtd2FoYWhhaGEnKSAvLyA8LSBmaW5lLi4uIGJ1dCBzdGlsbCBwcm9iYWJseSBkb24ndFxuICB9XG4gIC4uLlxufSlcbmB9PC9jb2RlPjwvcHJlPlxuICAgIDwvTURYTGF5b3V0Pjtcbn1cbjtcbk1EWENvbnRlbnQuaXNNRFhDb21wb25lbnQgPSB0cnVlO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwibWR4IiwiZnJvbnRNYXR0ZXIiLCJpZCIsInRpdGxlIiwiY29udGVudFRpdGxlIiwidW5kZWZpbmVkIiwibWV0YWRhdGEiLCJhc3NldHMiLCJ0b2MiLCJ2YWx1ZSIsImxldmVsIiwibGF5b3V0UHJvcHMiLCJNRFhMYXlvdXQiLCJNRFhDb250ZW50IiwiY29tcG9uZW50cyIsInByb3BzIiwiaXNNRFhDb21wb25lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///216\n')}}]);