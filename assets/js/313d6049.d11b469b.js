"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[4024],{7637:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return d},default:function(){return p}});var n=a(3117),r=a(102),s=(a(7294),a(3905)),o=["components"],i={id:"stores",title:"Stores"},l=void 0,c={unversionedId:"walkthrough/stores",id:"walkthrough/stores",isDocsHomePage:!1,title:"Stores",description:"Stores are the heart of Zedux. Zedux uses a unique and unprecedented composable store model. These stores are light-weight, powerful, and fast.",source:"@site/docs/walkthrough/stores.mdx",sourceDirName:"walkthrough",slug:"/walkthrough/stores",permalink:"/zedux/docs/walkthrough/stores",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/walkthrough/stores.mdx",tags:[],version:"current",frontMatter:{id:"stores",title:"Stores"},sidebar:"react",previous:{title:"Selectors",permalink:"/zedux/docs/walkthrough/selectors"},next:{title:"Side Effects",permalink:"/zedux/docs/walkthrough/side-effects"}},d=[{value:"Zero Config",id:"zero-config",children:[],level:2},{value:"Reducer Hierarchy",id:"reducer-hierarchy",children:[],level:2},{value:"Hydration",id:"hydration",children:[],level:2},{value:"Reducer Splitting",id:"reducer-splitting",children:[],level:2},{value:"Store Composition",id:"store-composition",children:[],level:2},{value:"Subscribing",id:"subscribing",children:[{value:"Normal Subscribers",id:"normal-subscribers",children:[],level:3},{value:"Error Subscribers",id:"error-subscribers",children:[],level:3},{value:"Effects Subscribers",id:"effects-subscribers",children:[],level:3},{value:"Combined Subscribers",id:"combined-subscribers",children:[],level:3}],level:2},{value:"Stores in Atoms",id:"stores-in-atoms",children:[{value:"<code>injectStore</code>",id:"injectstore",children:[{value:"Creating a reducer-driven store",id:"creating-a-reducer-driven-store",children:[],level:4},{value:"Composing stores",id:"composing-stores",children:[],level:4},{value:"Mixing stores and reducers",id:"mixing-stores-and-reducers",children:[],level:4}],level:3},{value:"Setting state during evaluation",id:"setting-state-during-evaluation",children:[],level:3},{value:"Wrapper Atoms",id:"wrapper-atoms",children:[],level:3},{value:"Composed Atoms",id:"composed-atoms",children:[],level:3}],level:2},{value:"Recap",id:"recap",children:[],level:2},{value:"Next Steps",id:"next-steps",children:[],level:2}],u={toc:d};function p(e){var t=e.components,a=(0,r.Z)(e,o);return(0,s.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Stores are the heart of Zedux. Zedux uses a unique and unprecedented composable store model. These stores are light-weight, powerful, and fast."),(0,s.kt)("h2",{id:"zero-config"},"Zero Config"),(0,s.kt)("p",null,"The Zedux store's mantra is \"opinionated but configurable\". Config is optional. This means you don't have to set up a reducer hierarchy with action creators for every single store. Zero config stores are the most common in Zedux due to their simplicity."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { createStore } from '@zedux/react'\n\nconst easySauceStore = createStore()\n")),(0,s.kt)("p",null,"That's it! Updating state is usually done with ",(0,s.kt)("inlineCode",{parentName:"p"},".setState()"),", which works like React's state setters:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"easySauceStore.setState(true) // set state straight-up\neasySauceStore.setState(currentState => !currentState) // function syntax\n\neasySauceStore.getState() // false\n")),(0,s.kt)("h2",{id:"reducer-hierarchy"},"Reducer Hierarchy"),(0,s.kt)("p",null,"Zedux stores can be configured with Redux-style reducer hierarchies. Of course, Zedux provides high-level methods for action and reducer creation:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { createActor, createReducer, createStore } from '@zedux/react'\n\nconst addTodo = createActor<Todo>('addTodo')\nconst removeTodo = createActor<number>('removeTodo')\n\nconst reducer = createReducer([])\n  .reduce(addTodo, (state, todo) => [...state, todo])\n  .reduce(removeTodo, (state, id) => state.filter(todo => todo.id !== id))\n\nconst store = createStore(reducer)\n")),(0,s.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"These high-level APIs are optional. You can of course use old-school switch statements and string constants if you wish, or any other means of creating reducers and actions."))),(0,s.kt)("p",null,"Updating the state of reducer-driven stores is usually done with ",(0,s.kt)("inlineCode",{parentName:"p"},".dispatch()"),". Just like Redux. Zedux actions must have a string ",(0,s.kt)("inlineCode",{parentName:"p"},"type")," property and can have optional ",(0,s.kt)("inlineCode",{parentName:"p"},"payload")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"meta")," properties."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"store.dispatch(addTodo({ id: 1, isDone: false, text: 'Be Awesome' }))\n\nstore.getState()\n// [{ id: 1, isDone: false, text: 'Be Awesome' }]\n")),(0,s.kt)("h2",{id:"hydration"},"Hydration"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"createStore()")," takes an optional second argument - ",(0,s.kt)("inlineCode",{parentName:"p"},"initialState"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const store = createStore(null, 'initial state')\n")),(0,s.kt)("p",null,"For zero config stores, pass ",(0,s.kt)("inlineCode",{parentName:"p"},"null")," as the reducer hierarchy. You can also hydrate a store's state with ",(0,s.kt)("inlineCode",{parentName:"p"},".setState()"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"store.setState('initial state')\n")),(0,s.kt)("h2",{id:"reducer-splitting"},"Reducer Splitting"),(0,s.kt)("p",null,"The first argument to ",(0,s.kt)("inlineCode",{parentName:"p"},"createStore()")," doesn't have to be a reducer. It can be a reducer, another store (yep), or an object mapping keys to reducers or stores or objects mapping keys to reducers or ... yeah, it's recursive. It's called a hierarchy descriptor."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"type Branch<T = any> = {\n  [K in keyof T]: HierarchyDescriptor<T[K]>\n}\n\ntype HierarchyDescriptor<State = any> =\n  | Branch<State>\n  | Store<State>\n  | Reducer<State>\n  | null\n")),(0,s.kt)("p",null,'Passing an object ("branch") containing multiple reducers will automatically create a "branch" reducer. This is similar to Redux\' ',(0,s.kt)("a",{parentName:"p",href:"https://redux.js.org/api/combinereducers"},(0,s.kt)("inlineCode",{parentName:"a"},"combineReducers()")),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const complexStore = createStore({\n  entities: {\n    posts: postsReducer,\n    users: usersReducer,\n  },\n  forms: formsStore,\n})\n\ncomplexStore.getState()\n/*\n{\n  entities: {\n    posts: <postsReducer initial state>,\n    users: <usersReducer initial state>\n  },\n  forms: <formsReducer initial state>\n}\n*/\n")),(0,s.kt)("h2",{id:"store-composition"},"Store Composition"),(0,s.kt)("p",null,"Zedux stores are composable. This means that a store can control part or all of the state of another store. This is an extremely unique and powerful feature that sets Zedux apart from other state management tools."),(0,s.kt)("p",null,"What does store composition look like? Well quite simply:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { createStore } from '@zedux/react'\n\nconst childStore = createStore()\nconst parentStore = createStore(childStore)\n")),(0,s.kt)("p",null,"Easy, right? The ",(0,s.kt)("inlineCode",{parentName:"p"},"parentStore"),"'s state is now controlled by ",(0,s.kt)("inlineCode",{parentName:"p"},"childStore"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"childStore.setState('initial value')\nparentStore.getState() // 'initial value'\n\nparentStore.setState('a new value')\nchildStore.getState() // 'a new value'\n")),(0,s.kt)("p",null,"When we set the child store's state, that change propagated to the parent store."),(0,s.kt)("p",null,"When we set the parent store's state, the parent store recognized that the relevant state was controlled by a child store and ",(0,s.kt)("a",{parentName:"p",href:"/not-done"},"delegated")," that action to the child store. The child store then updated its state and propagated that change back up to the parent store."),(0,s.kt)("p",null,"Now what can you do with that?"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { createStore } from '@zedux/react'\n\nconst rootStore = createStore()\nconst todosStore = createStore(null, [])\nconst toNotDosStore = createStore(null, [])\n\n// The composition magic! Since we already created the store, we can use\n// `.use()` to update its hierarchy\nrootStore.use({\n  todos: todosStore,\n  toNotDos: toNotDosStore,\n})\n\ntoNotDos.setState(state => [...state, 'be layzee'])\ntoNotDos.getState() // ['be layzee']\nrootStore.getState()\n// {\n//   todos: [],\n//   toNotDos: ['be layzee']\n// }\n")),(0,s.kt)("p",null,"This composable store model makes many complex concepts trivial: Higher-Order Stores, code splitting, component-bound stores that attach to a root store on mount. All while maintaining time-traversable state and replayable actions."),(0,s.kt)("p",null,"Treating the store as the basic building block of application state simplifies state management and increases modularity. The Zedux store is an autonomous unit that can simultaneously handle a sub-module's internal workings and present a standardized api to consumers."),(0,s.kt)("p",null,"With Zedux stores handling the internal state of all modals, forms, widgets, routing, etc, it becomes trivial to compose these modules together - e.g. to dispatch actions to all or several of them or to implement undo/redo, persistence, or logging for the entire application."),(0,s.kt)("p",null,"Composition is powerful. Check out the ",(0,s.kt)("a",{parentName:"p",href:"/not-done"},"store composition guide")," to learn the particulars of Zedux' store composition model."),(0,s.kt)("h2",{id:"subscribing"},"Subscribing"),(0,s.kt)("p",null,"You can register several types of subscribers using ",(0,s.kt)("inlineCode",{parentName:"p"},".subscribe()"),"."),(0,s.kt)("h3",{id:"normal-subscribers"},"Normal Subscribers"),(0,s.kt)("p",null,"These subscribers will be called on every state change."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const subscription = myStore.subscribe((newState, oldState) => {\n  console.log('store went from', oldState, 'to', newState)\n})\n")),(0,s.kt)("p",null,"Normal subscribers receive the new state, the old state, and the action responsible for the update as arguments."),(0,s.kt)("p",null,"The returned subscription object has a single property - ",(0,s.kt)("inlineCode",{parentName:"p"},"unsubscribe()"),". Be sure to call this in ",(0,s.kt)("inlineCode",{parentName:"p"},"useEffect()")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"injectEffect()")," cleanup:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"useEffect(() => {\n  const subscription = myStore.subscribe(mySubscriber)\n  return () => subscription.unsubscribe()\n}, [myStore])\n")),(0,s.kt)("h3",{id:"error-subscribers"},"Error Subscribers"),(0,s.kt)("p",null,"These subscribers will be called if a dispatched action ever raises an error."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"myStore.subscribe({\n  error: err => console.log('caught error!', err),\n})\n")),(0,s.kt)("h3",{id:"effects-subscribers"},"Effects Subscribers"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"myStore.subscribe({\n  effects: ({ action, effect, error, newState, oldState, store }) => ...\n})\n")),(0,s.kt)("p",null,"These effects subscribers can kick off all kinds of side effects, including observables, generators, or other async flows. Dev X features and app monitoring should make heavy use of effects subscribers."),(0,s.kt)("h3",{id:"combined-subscribers"},"Combined Subscribers"),(0,s.kt)("p",null,"Any combination of these subscriber types can be added in one subscription:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"myStore.subscribe({\n  effects: myEffectsSubscriber,\n  error: myErrorSubscriber,\n  next: myNextSubscriber, // a normal subscriber\n})\n")),(0,s.kt)("h2",{id:"stores-in-atoms"},"Stores in Atoms"),(0,s.kt)("p",null,"Atoms create their own stores by default every time an instance is created. However, sometimes you need access to the instance's store during evaluation. Zedux provides several injectors that can be used to create a store in an evaluator."),(0,s.kt)("div",{className:"admonition admonition-important alert alert--info"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"important")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"When you create your own store, make sure you return it from the evaluator function. This tells Zedux to use the store you created instead of creating a default one."))),(0,s.kt)("h3",{id:"injectstore"},(0,s.kt)("inlineCode",{parentName:"h3"},"injectStore")),(0,s.kt)("p",null,"We covered some basic usage of this injector in ",(0,s.kt)("a",{parentName:"p",href:"creating-atoms"},"the creating atoms walkthrough"),". But now that we understand stores, we can look at some more advanced patterns."),(0,s.kt)("h4",{id:"creating-a-reducer-driven-store"},"Creating a reducer-driven store"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const store = injectStore(() => createStore(rootReducer))\n")),(0,s.kt)("h4",{id:"composing-stores"},"Composing stores"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const storeA = injectStore('a')\nconst storeB = injectStore('b')\nconst store = injectStore(() => createStore({ a: storeA, b: storeB }))\n")),(0,s.kt)("h4",{id:"mixing-stores-and-reducers"},"Mixing stores and reducers"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const store = injectStore(() =>\n  createStore({\n    a: myStore,\n    b: myReducer,\n  })\n)\n")),(0,s.kt)("h3",{id:"setting-state-during-evaluation"},"Setting state during evaluation"),(0,s.kt)("p",null,"You can set a store's state during atom evaluation."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// injectStore doesn't subscribe by default...\nconst store = injectStore('initial state')\nconst otherVal = injectAtomValue(otherAtom)\nstore.setState(deriveStuffFrom(otherVal)) // ...so this is fine\n")),(0,s.kt)("p",null,"Now you may be thinking, what happens if this atom instance does subscribe to its store? Wouldn't this would cause a reevaluation loop?"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const store = injectStore('initial state', true) // pass true to subscribe\nconst otherVal = injectAtomValue(otherAtom)\nstore.setState(deriveStuffFrom(otherVal)) // surely bad! .. Right?\n")),(0,s.kt)("p",null,"Turns out, this is also fine! ",(0,s.kt)("inlineCode",{parentName:"p"},"injectStore")," detects if the store's state is updated while its atom instance is being evaluated and doesn't trigger a new evaluation. This means, however, that you may need to be conscious of when you set state:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const store = injectStore('initial state', true)\n\n// store's state hasn't been updated yet!\ninjectEffect(someSideEffect, [store.getState()])\n\n// won't trigger the above effect (which is fine if that's what we want)\nstore.setState(injectSomeDerivation())\n")),(0,s.kt)("p",null,"Since ",(0,s.kt)("inlineCode",{parentName:"p"},"store.setState()")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"store.dispatch()")," return the new state, we could rewrite the above example to make use of this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const store = injectStore('initial state', true)\nconst newstate = store.setState(injectSomeDerivation()) // update synchronously\n\n// pass this newState as the dep, instead of store.getState()\ninjectEffect(someSideEffect, [newState])\n")),(0,s.kt)("p",null,"Sometimes you will encounter an asynchronous evaluation loop, e.g. with ",(0,s.kt)("inlineCode",{parentName:"p"},"injectEffect"),", where an effect needs to set the store's state but then the effect also reruns every time the state changes."),(0,s.kt)("p",null,"Since the above only applies during synchronus evaluation, these situations require something special. It may be possible in some cases to fix this by narrowing your effect's dependency so that only a piece of state causes the effect to rerun. Or you may be able to reorganize your state so that the effect updates a separate store than the one it depends on."),(0,s.kt)("p",null,"If all else fails, we can pass ",(0,s.kt)("a",{parentName:"p",href:"../api/constants/metaTypes#skip_evaluation"},(0,s.kt)("inlineCode",{parentName:"a"},"metaTypes.SKIP_EVALUATION"))," as an action's ",(0,s.kt)("inlineCode",{parentName:"p"},"meta")," property to prevent Zedux from reevaluating this atom on this particular state change."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { metaTypes } from '@zedux/react'\n\nmyStore.dispatch({ type: 'my-action-type', meta: metaTypes.SKIP_EVALUATION })\n\n// metadata can be passed as the second param to .setState():\nmyStore.setState(newState, metaTypes.SKIP_EVALUATION)\n")),(0,s.kt)("h3",{id:"wrapper-atoms"},"Wrapper Atoms"),(0,s.kt)("p",null,"Sometimes we'll have an atom that doesn't hold any state itself, but may wrap some functionality around another atom. There is no rule that says an atom instance can't reuse another atom instance's store."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const wrappedInstance = injectAtomInstance(wrappedAtom)\n\nreturn api(wrappedInstance.store).setExports({ ... })\n")),(0,s.kt)("h3",{id:"composed-atoms"},"Composed Atoms"),(0,s.kt)("p",null,"An atom can create a store composed of the stores of other atoms."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const instanceA = injectAtomInstance(atomA)\nconst instanceB = injectAtomInstance(atomB)\nconst store = injectStore(() =>\n  createStore({\n    a: instanceA.store,\n    b: instanceB.store,\n  })\n)\n")),(0,s.kt)("p",null,"Use this approach sparingly, as this bypasses Zedux' internal graph algorithm. For simple use cases, this should be fine. Eventually, the work-in-progress molecules feature will be the recommended way to compose stores together from multiple atom instances."),(0,s.kt)("h2",{id:"recap"},"Recap"),(0,s.kt)("p",null,"Stores are the backbone of Zedux. They're composable state containers that promote isolation and modularity, manage side effects, and work well in feature-based, micro-frontend, or otherwise code-split architectures. Learning to use stores effectively is the key to unlocking Zedux' power."),(0,s.kt)("h2",{id:"next-steps"},"Next Steps"),(0,s.kt)("p",null,"Now that we know a bit about creating and subscribing to stores, we can learn how to hook into stores to run ",(0,s.kt)("a",{parentName:"p",href:"side-effects"},"side effects"),"."))}p.isMDXComponent=!0}}]);