"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[3145],{8101:function(e,t,s){s.r(t),s.d(t,{frontMatter:function(){return c},contentTitle:function(){return l},metadata:function(){return m},toc:function(){return d},default:function(){return u}});var o=s(3117),n=s(102),a=(s(7294),s(3905)),i=s(3052),r=["components"],c={id:"ecosystems",title:"Ecosystems"},l=void 0,m={unversionedId:"walkthrough/ecosystems",id:"walkthrough/ecosystems",isDocsHomePage:!1,title:"Ecosystems",description:"All atoms live in an atom ecosystem. An ecosystem is like an isolated group of atoms. Atoms in an ecosystem can interact with each other, but are unaware of atoms in other ecosystems.",source:"@site/docs/walkthrough/ecosystems.mdx",sourceDirName:"walkthrough",slug:"/walkthrough/ecosystems",permalink:"/zedux/docs/walkthrough/ecosystems",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/walkthrough/ecosystems.mdx",tags:[],version:"current",frontMatter:{id:"ecosystems",title:"Ecosystems"},sidebar:"react",previous:{title:"Using Atoms",permalink:"/zedux/docs/walkthrough/using-atoms"},next:{title:"Dependency Injection",permalink:"/zedux/docs/walkthrough/dependency-injection"}},d=[{value:"Global",id:"global",children:[],level:3},{value:"Custom",id:"custom",children:[{value:"<code>EcosystemProvider</code>",id:"ecosystemprovider",children:[],level:4},{value:"<code>ecosystem()</code>",id:"ecosystem",children:[],level:4}],level:3},{value:"Configuring Ecosystems",id:"configuring-ecosystems",children:[{value:"<code>overrides</code>",id:"overrides",children:[],level:3},{value:"<code>preload</code>",id:"preload",children:[],level:3}],level:2},{value:"Ecosystem Design Patterns",id:"ecosystem-design-patterns",children:[{value:"Single Ecosystem",id:"single-ecosystem",children:[],level:3},{value:"Global Only",id:"global-only",children:[],level:3},{value:"Mixed",id:"mixed",children:[],level:3}],level:2},{value:"A Note On Params",id:"a-note-on-params",children:[],level:2},{value:"Using the Ecosystem",id:"using-the-ecosystem",children:[{value:"Getting It",id:"getting-it",children:[],level:3}],level:2},{value:"Recap",id:"recap",children:[],level:2},{value:"Next Steps",id:"next-steps",children:[],level:2}],p={toc:d};function u(e){var t=e.components,c=(0,n.Z)(e,r);return(0,a.kt)("wrapper",(0,o.Z)({},p,c,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"All atoms live in an atom ecosystem. An ecosystem is like an isolated group of atoms. Atoms in an ecosystem can interact with each other, but are unaware of atoms in other ecosystems."),(0,a.kt)("p",null,"There are 2 types of ecosystems:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Global"),(0,a.kt)("li",{parentName:"ul"},"Custom")),(0,a.kt)("h3",{id:"global"},"Global"),(0,a.kt)("p",null,"There is exactly one global atom ecosystem. You don't need to create it; it is created automatically if you don't create an ecosystem."),(0,a.kt)("p",null,"Zedux is designed to allow an app to use only the global ecosystem. And for small apps and simple examples, that's fine. However, this approach can only get you so far. The global ecosystem is not configurable. Thus it lacks some advanced features like ",(0,a.kt)("a",{parentName:"p",href:"dependency-injection"},"dependency injection")," and ",(0,a.kt)("a",{parentName:"p",href:"/not-done"},"preloading"),". The global ecosystem can also be unruly in tests, since it requires manual cleanup."),(0,a.kt)("h3",{id:"custom"},"Custom"),(0,a.kt)("p",null,"There are 2 ways to create custom ecosystems"),(0,a.kt)("h4",{id:"ecosystemprovider"},(0,a.kt)("inlineCode",{parentName:"h4"},"EcosystemProvider")),(0,a.kt)("p",null,"The simplest way to create an ecosystem is by rendering an ",(0,a.kt)("a",{parentName:"p",href:"../api/components/EcosystemProvider"},"EcosystemProvider"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import { EcosystemProvider } from '@zedux/react'\n\nfunction App() {\n  return (\n    <EcosystemProvider>\n      <Routes />\n    </EcosystemProvider>\n  )\n}\n")),(0,a.kt)("p",null,"This is similar to Recoil's ",(0,a.kt)("a",{parentName:"p",href:"https://recoiljs.org/docs/api-reference/core/RecoilRoot"},(0,a.kt)("inlineCode",{parentName:"a"},"RecoilRoot"))," or Redux' ",(0,a.kt)("a",{parentName:"p",href:"https://react-redux.js.org/api/provider"},(0,a.kt)("inlineCode",{parentName:"a"},"Provider"))," or React Query's ",(0,a.kt)("a",{parentName:"p",href:"https://react-query.tanstack.com/reference/QueryClientProvider"},(0,a.kt)("inlineCode",{parentName:"a"},"QueryClientProvider")),". In fact, it's basically a combination of all of those. And more."),(0,a.kt)("p",null,"Rendering an EcosystemProvider without passing an ecosystem prop creates a new ecosystem. When such an EcosystemProvider is unmounted, the ecosystem and all atom instances in it are destroyed."),(0,a.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"Nesting EcosystemProviders currently has no special functionality. Rendering an EcosystemProvider inside another EcosystemProvider will create a new, completely isolated ecosystem."))),(0,a.kt)("p",null,"Most apps will want to use custom ecosystems."),(0,a.kt)("h4",{id:"ecosystem"},(0,a.kt)("inlineCode",{parentName:"h4"},"ecosystem()")),(0,a.kt)("p",null,"For even more control, you can can create an ecosystem using the exported ",(0,a.kt)("inlineCode",{parentName:"p"},"ecosystem()")," factory."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import { EcosystemProvider, ecosystem } from '@zedux/react'\n\nconst rootEcosystem = ecosystem({ id: 'root' })\n\nfunction App() {\n  return (\n    <EcosystemProvider ecosystem={rootEcosystem}>\n      <Routes />\n    </EcosystemProvider>\n  )\n}\n")),(0,a.kt)("p",null,"Ecosystems created this way can be controlled outside React. This means you can preload atoms, manipulate atoms, analyze the graph, and destroy the ecosystem without ever rendering a component. This is extremely useful for testing and for isomorphic codebases."),(0,a.kt)("h2",{id:"configuring-ecosystems"},"Configuring Ecosystems"),(0,a.kt)("p",null,"Ecosystems created manually (via the ",(0,a.kt)("inlineCode",{parentName:"p"},"ecosystem()")," factory) can take configuration options."),(0,a.kt)("h3",{id:"overrides"},(0,a.kt)("inlineCode",{parentName:"h3"},"overrides")),(0,a.kt)("p",null,"A list of atoms that will override any atoms with matching keys used in this ecosystem. More on this in the ",(0,a.kt)("a",{parentName:"p",href:"dependency-injection"},"dependency injection walkthrough"),"."),(0,a.kt)("h3",{id:"preload"},(0,a.kt)("inlineCode",{parentName:"h3"},"preload")),(0,a.kt)("p",null,"A function that will run immediately - as soon as the ecosystem is created. Used to bootstrap the initial state of the app, kick off initial side effects, set up state hydration, and other startup-y things."),(0,a.kt)("p",null,"See ",(0,a.kt)("a",{parentName:"p",href:"../api/factories/ecosystem"},"the ",(0,a.kt)("inlineCode",{parentName:"a"},"ecosystem()")," API")," for more info."),(0,a.kt)("h2",{id:"ecosystem-design-patterns"},"Ecosystem Design Patterns"),(0,a.kt)("p",null,"There are 3 main design patterns around atom ecosystems. Choose the most appropriate for your app."),(0,a.kt)("h3",{id:"single-ecosystem"},"Single Ecosystem"),(0,a.kt)("p",null,(0,a.kt)("img",{src:s(9186).Z})),(0,a.kt)("p",null,"The most common. In the single ecosystem approach, you render one EcosystemProvider - creating a single custom ecosystem. The global ecosystem is not used."),(0,a.kt)("p",null,"Most apps will only need one ecosystem, though more can be created to purposefully create isolated groups of atoms. Tests will typically each create their own ecosystem to take advantage of DI and the automatic cleanup on unmount."),(0,a.kt)("p",null,"Most apps will want to make use of the powerful features of EcosystemProviders. This approach is recommended in most situations."),(0,a.kt)("h3",{id:"global-only"},"Global Only"),(0,a.kt)("p",null,(0,a.kt)("img",{src:s(6845).Z})),(0,a.kt)("p",null,"In the global only approach, all atoms live in the global ecosystem. This is done by never rendering an EcosystemProvider. If no EcosystemProvider is rendered, all atoms are added to the global ecosystem by default."),(0,a.kt)("p",null,"The global ecosystem can be nice for simplicity. Some apps don't need any of the features custom ecosystems offer. And that's fine!"),(0,a.kt)("h3",{id:"mixed"},"Mixed"),(0,a.kt)("p",null,(0,a.kt)("img",{src:s(753).Z})),(0,a.kt)("p",null,"In this approach, you create one or more custom ecosystems. You might also use some atoms outside any EcosystemProvider - utilizing the global ecosystem."),(0,a.kt)("p",null,"Use cases for this approach are very niche. Outside of testing, you probably won't find yourself using multiple ecosystems."),(0,a.kt)("h2",{id:"a-note-on-params"},"A Note On Params"),(0,a.kt)("p",null,"In the quick start, we learned that atom instances can be reused by passing the same params to certain hooks/injectors. Since atom instances live in an ecosystem, reuse can only happen inside that ecosystem."),(0,a.kt)("p",null,"In the following example, the ",(0,a.kt)("inlineCode",{parentName:"p"},"counterAtom")," doesn't take any params. But since it's used in two different ecosystems, two different instances are created."),(0,a.kt)(i.u,{resultVar:"Apps",mdxType:"LiveEditor"},"\nconst counterAtom = atom('counter', 0)\n\nfunction Counter() {\n  const [state, setState] = useAtomState(counterAtom)\n\n  return (\n    <>\n      <div>Value: {state}</div>\n      <button onClick={() => setState(state => state + 1)}>Increment</button>\n    </>\n  )\n}\n\nfunction Apps() {\n  return (\n    <>\n      <EcosystemProvider>\n        <h3>Counter 1:</h3>\n        <Counter />\n      </EcosystemProvider>\n      <EcosystemProvider>\n        <h3>Counter 2:</h3>\n        <Counter />\n      </EcosystemProvider>\n    </>\n  )\n}\n"),(0,a.kt)("h2",{id:"using-the-ecosystem"},"Using the Ecosystem"),(0,a.kt)("p",null,"The ecosystem object itself has many useful methods. You can use these to inspect the dependency graph, get the current state of all atoms, set atom overrides, and a lot more. We'll cover most of these as we go through the rest of the walkthrough. See the ",(0,a.kt)("a",{parentName:"p",href:"../api/classes/Ecosystem"},"Ecosystem class API doc")," for all the goodness."),(0,a.kt)("h3",{id:"getting-it"},"Getting It"),(0,a.kt)("p",null,"Every component below an ",(0,a.kt)("inlineCode",{parentName:"p"},"<EcosystemProvider>")," in the tree can access the ecosystem via ",(0,a.kt)("a",{parentName:"p",href:"../api/hooks/useEcosystem"},(0,a.kt)("inlineCode",{parentName:"a"},"useEcosystem()")),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import { EcosystemProvider, useEcosystem } from '@zedux/react'\n\nfunction Child() {\n  const ecosystem = useEcosystem()\n}\n\nfunction App() {\n  return (\n    <EcosystemProvider id=\"main\">\n      <Child />\n    </EcosystemProvider>\n  )\n}\n")),(0,a.kt)("p",null,"All atom instances created in an ecosystem can access the ecosystem via ",(0,a.kt)("a",{parentName:"p",href:"../api/injectors/injectEcosystem"},(0,a.kt)("inlineCode",{parentName:"a"},"injectEcosystem()")),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"import { atom, injectEcosystem } from '@zedux/react'\n\nconst myAtom = atom('my', () => {\n  const ecosystem = injectEcosystem()\n})\n")),(0,a.kt)("h2",{id:"recap"},"Recap"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"All atoms live in atom ecosystems."),(0,a.kt)("li",{parentName:"ul"},"Atom instances can only be reused in the ecosystem they were created in."),(0,a.kt)("li",{parentName:"ul"},'There is a default ("global") ecosystem, but you can create your own.'),(0,a.kt)("li",{parentName:"ul"},'Most apps will use the "Single Ecosystem Approach" - rendering a single ',(0,a.kt)("inlineCode",{parentName:"li"},"<EcosystemProvider>"),"."),(0,a.kt)("li",{parentName:"ul"},"Ecosystems can be configured with various options passed to the ",(0,a.kt)("inlineCode",{parentName:"li"},"ecosystem()")," factory or as props to ",(0,a.kt)("inlineCode",{parentName:"li"},"<EcosystemProvider>"),"."),(0,a.kt)("li",{parentName:"ul"},"The current ecosystem can be retrieved with ",(0,a.kt)("inlineCode",{parentName:"li"},"useEcosystem()")," in components and ",(0,a.kt)("inlineCode",{parentName:"li"},"injectEcosystem()")," in atoms.")),(0,a.kt)("h2",{id:"next-steps"},"Next Steps"),(0,a.kt)("p",null,"Ecosystems are capable of some pretty cool stuff. With these equipped, it's time to look at one of the coolest features of Zedux: ",(0,a.kt)("a",{parentName:"p",href:"dependency-injection"},"Dependency Injection"),"."))}u.isMDXComponent=!0},6845:function(e,t,s){t.Z=s.p+"assets/images/atom-ecosystems-global-only-e96c60cb65a0c0d5b40666a680f43961.png"},753:function(e,t,s){t.Z=s.p+"assets/images/atom-ecosystems-mixed-5ec17e7f6f96b6417a25b47bff164a14.png"},9186:function(e,t,s){t.Z=s.p+"assets/images/atom-ecosystems-single-ecosystem-0aa3e295391dfe19d815ec7ebe93dc7f.png"}}]);