"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[525],{1738:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return d},metadata:function(){return c},toc:function(){return p},default:function(){return h}});var a=n(3117),s=n(102),i=(n(7294),n(3905)),o=["components"],r={id:"glossary",title:"Glossary"},d=void 0,c={unversionedId:"api/glossary",id:"api/glossary",isDocsHomePage:!1,title:"Glossary",description:"Dynamic Graph Dependency",source:"@site/docs/api/glossary.md",sourceDirName:"api",slug:"/api/glossary",permalink:"/zedux/docs/api/glossary",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/glossary.md",tags:[],version:"current",frontMatter:{id:"glossary",title:"Glossary"},sidebar:"react",previous:{title:"Subscription",permalink:"/zedux/docs/api/types/Subscription"}},p=[{value:"Dynamic Graph Dependency",id:"dynamic-graph-dependency",children:[],level:3},{value:"Evaluator",id:"evaluator",children:[],level:3},{value:"Graph Edge",id:"graph-edge",children:[],level:3},{value:"Graph Node",id:"graph-node",children:[],level:3},{value:"Injector",id:"injector",children:[],level:3},{value:"Pseudo Action",id:"pseudo-action",children:[],level:3},{value:"Restricted Dynamic Graph Dependency",id:"restricted-dynamic-graph-dependency",children:[],level:3},{value:"Static Graph Dependency",id:"static-graph-dependency",children:[],level:3}],l={toc:p};function h(e){var t=e.components,n=(0,s.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h3",{id:"dynamic-graph-dependency"},"Dynamic Graph Dependency"),(0,i.kt)("p",null,"When one ",(0,i.kt)("a",{parentName:"p",href:"#graph-node"},"graph node")," depends on another, Zedux draws an edge between those two nodes in its internal graph algorithm."),(0,i.kt)("p",null,'A "dynamic" dependency is a dependency that will trigger updates in the dependent node when the dependency node\'s state updates. Contrast this to ',(0,i.kt)("a",{parentName:"p",href:"#static-graph-dependency"},"static dependencies"),", which do not trigger updates."),(0,i.kt)("p",null,"If the dependent is a React component, it will rerender when the dependency atom instance's state changes."),(0,i.kt)("p",null,"If the dependent is another atom instance, it will reevaluate when the dependency atom instance's state changes."),(0,i.kt)("h3",{id:"evaluator"},"Evaluator"),(0,i.kt)("p",null,"A function passed to ",(0,i.kt)("a",{parentName:"p",href:"factories/atom"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"atom()")," factory"),". This function is called to produce the initial value of the atom instance. It also runs every time an atom instance is evaluated."),(0,i.kt)("h3",{id:"graph-edge"},"Graph Edge"),(0,i.kt)("p",null,"The edges between ",(0,i.kt)("a",{parentName:"p",href:"#graph-node"},"graph nodes"),". These edges can have several properties, depending on how the edge was created and how it should behave."),(0,i.kt)("p",null,'Edges can be static or dynamic, internal or external, and async or synchronous. They can be identified by an "operation" string that helps when debugging.'),(0,i.kt)("h3",{id:"graph-node"},"Graph Node"),(0,i.kt)("p",null,"Zedux builds an internal graph to manage atom dependencies and propagate updates in an optimal way. There are two types of nodes in this graph:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"classes/AtomInstance"},"Atom instances")),(0,i.kt)("li",{parentName:"ul"},"External dependents (usually React components).")),(0,i.kt)("h3",{id:"injector"},"Injector"),(0,i.kt)("p",null,'Injectors are the "hooks" of Atoms. Zedux exports several injectors.'),(0,i.kt)("p",null,"Some injectors are React-hook equivalents, like ",(0,i.kt)("a",{parentName:"p",href:"injectors/injectEffect"},"injectEffect"),", ",(0,i.kt)("a",{parentName:"p",href:"injectors/injectMemo"},"injectMemo"),", and ",(0,i.kt)("a",{parentName:"p",href:"injectors/injectRef"},"injectRef"),"."),(0,i.kt)("p",null,"Others provide certain utilities or debugging capabilities, such as ",(0,i.kt)("a",{parentName:"p",href:"injectors/injectEcosystem"},"injectEcosystem")," and ",(0,i.kt)("a",{parentName:"p",href:"injectors/injectWhy"},"injectWhy"),"."),(0,i.kt)("p",null,"Injectors should only be used at the top level of ",(0,i.kt)("a",{parentName:"p",href:"#evaluator"},"atom evaluator functions"),". Don't use them in loops or conditional statements."),(0,i.kt)("p",null,"Injectors can be used any number of times throughout an atom evaluator. For certain one-off operations like setting an atom instance's exports or setting a suspense promise, use an ",(0,i.kt)("a",{parentName:"p",href:"classes/AtomApi"},"AtomApi"),"."),(0,i.kt)("p",null,'Like hooks, you can create custom injectors. The convention is to start all injectors with the word "inject", just like we use the word "use" with React hooks.'),(0,i.kt)("h3",{id:"pseudo-action"},"Pseudo Action"),(0,i.kt)("p",null,"An action created by Zedux to represent a state change. The key to time travel debugging is tracking all actions that modify state. But zero config stores typically use ",(0,i.kt)("a",{parentName:"p",href:"classes/Store#setstate"},(0,i.kt)("inlineCode",{parentName:"a"},".setState()"))," to update their state. Parent and child stores can also cause the state of a store to change."),(0,i.kt)("p",null,'Zedux translates all of these state updating operations into "pseudo-actions" - action objects with metadata containing all the info needed to reproduce the state change.'),(0,i.kt)("h3",{id:"restricted-dynamic-graph-dependency"},"Restricted Dynamic Graph Dependency"),(0,i.kt)("p",null,"When one ",(0,i.kt)("a",{parentName:"p",href:"#graph-node"},"graph node")," depends on another, Zedux draws an edge between those two nodes in its internal graph algorithm."),(0,i.kt)("p",null,'A "restricted dynamic" dependency is really just a ',(0,i.kt)("a",{parentName:"p",href:"#dynamic-graph-dependency"},"dynamic dependency")," that will only trigger updates in the dependent node when the dependency node's state updates and some other condition is met. This is used for selectors."),(0,i.kt)("p",null,"If the dependent is a React component, it will rerender when the dependency atom instance's state changes and the selector's result changes."),(0,i.kt)("p",null,"If the dependent is another atom instance, it will reevaluate when the dependency atom instance's state changes and the selector's result changes."),(0,i.kt)("h3",{id:"static-graph-dependency"},"Static Graph Dependency"),(0,i.kt)("p",null,"When one ",(0,i.kt)("a",{parentName:"p",href:"#graph-node"},"graph node")," depends on another, Zedux draws an edge between those two nodes in its internal graph algorithm."),(0,i.kt)("p",null,'A "static" dependency is a dependency that does not trigger updates in the dependent node when the dependency node\'s state updates. Contrast this to ',(0,i.kt)("a",{parentName:"p",href:"#dynamic-graph-dependency"},"dynamic dependencies"),", which do trigger updates."),(0,i.kt)("p",null,"While they don't trigger updates, static dependencies are still useful for informing Zedux that an atom instance is in use. Zedux won't try to clean up atom instances that still have dependents."))}h.isMDXComponent=!0}}]);