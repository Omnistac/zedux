"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[8363],{7759:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return p},default:function(){return d}});var a=n(3117),r=n(102),i=(n(7294),n(3905)),o=["components"],s={id:"SetStateInterceptor",title:"SetStateInterceptor"},c=void 0,l={unversionedId:"api/types/SetStateInterceptor",id:"api/types/SetStateInterceptor",isDocsHomePage:!1,title:"SetStateInterceptor",description:"A function that intercepts instance.setState() calls.",source:"@site/docs/api/types/SetStateInterceptor.mdx",sourceDirName:"api/types",slug:"/api/types/SetStateInterceptor",permalink:"/zedux/docs/api/types/SetStateInterceptor",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/types/SetStateInterceptor.mdx",tags:[],version:"current",frontMatter:{id:"SetStateInterceptor",title:"SetStateInterceptor"},sidebar:"react",previous:{title:"Reducer",permalink:"/zedux/docs/api/types/Reducer"},next:{title:"Settable",permalink:"/zedux/docs/api/types/Settable"}},p=[{value:"Definition",id:"definition",children:[],level:2},{value:"Example",id:"example",children:[],level:2},{value:"A Note on Ion setters",id:"a-note-on-ion-setters",children:[],level:2}],u={toc:p};function d(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"A function that intercepts ",(0,i.kt)("a",{parentName:"p",href:"../classes/AtomInstance#setstate"},(0,i.kt)("inlineCode",{parentName:"a"},"instance.setState()"))," calls."),(0,i.kt)("p",null,"These interceptors function like middleware. They will be called every time ",(0,i.kt)("inlineCode",{parentName:"p"},"instance.setState()")," is called and can cancel the state setting or reroute it."),(0,i.kt)("h2",{id:"definition"},"Definition"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"type SetStateInterceptor<State = any> = (\n  settable: Settable<State>,\n  next: (settable: Settable<State>) => State\n) => State\n")),(0,i.kt)("p",null,"Accepts a ",(0,i.kt)("a",{parentName:"p",href:"Settable"},"Settable")," and a ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," function. Must return the new state (or the current state if no change)."),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const store = injectStore()\n\nconst myApi = api(store).addSetStateInterceptor(\n  (settable, next) => {\n    const currentState = store.getState()\n    \n    // make sure you return the state!\n    if (isBad(currentState)) return currentState // cancel the state setting\n\n    // return the new state\n    return next(settable) // proceed with the state setting\n  }\n)\n")),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../classes/AtomApi"},"AtomApi")," for more info."),(0,i.kt)("h2",{id:"a-note-on-ion-setters"},"A Note on Ion setters"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"../factories/ion#set"},"Ion setters")," are very much like setState interceptors. In fact, ions use setState interceptors under the hood. But they're a little different:"),(0,i.kt)("p",null,"They are not like middleware - they don't need to be, as you'll only have one per ion. Thus they don't receive a ",(0,i.kt)("inlineCode",{parentName:"p"},"next")," parameter."),(0,i.kt)("p",null,"They also don't need to return the new state (though they can). If ",(0,i.kt)("inlineCode",{parentName:"p"},"undefined")," is returned from an ion setter, Zedux will assume no state change was made and return the current state to the ",(0,i.kt)("inlineCode",{parentName:"p"},"instance.setState()")," caller."))}d.isMDXComponent=!0}}]);