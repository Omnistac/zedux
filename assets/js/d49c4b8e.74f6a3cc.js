"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[123],{7244:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return m},default:function(){return u}});var a=n(3117),s=n(102),o=(n(7294),n(3905)),r=n(3052),i=["components"],c={id:"injectAtomState",title:"injectAtomState"},l=void 0,d={unversionedId:"api/injectors/injectAtomState",id:"api/injectors/injectAtomState",isDocsHomePage:!1,title:"injectAtomState",description:"An injector that accepts an atom and its params and registers a dynamic graph dependency on the resolved atom instance, returning a tuple of the current value and a state setter.",source:"@site/docs/api/injectors/injectAtomState.mdx",sourceDirName:"api/injectors",slug:"/api/injectors/injectAtomState",permalink:"/zedux/docs/api/injectors/injectAtomState",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/injectors/injectAtomState.mdx",tags:[],version:"current",frontMatter:{id:"injectAtomState",title:"injectAtomState"},sidebar:"react",previous:{title:"injectAtomSelector",permalink:"/zedux/docs/api/injectors/injectAtomSelector"},next:{title:"injectAtomValue",permalink:"/zedux/docs/api/injectors/injectAtomValue"}},m=[{value:"Example",id:"example",children:[],level:2},{value:"Signature",id:"signature",children:[{value:"Overloads",id:"overloads",children:[],level:3},{value:"<code>atom</code>",id:"atom",children:[],level:3},{value:"<code>params</code>",id:"params",children:[],level:3},{value:"<code>instance</code>",id:"instance",children:[],level:3}],level:2}],p={toc:m};function u(e){var t=e.components,n=(0,s.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { injectAtomState } from '@zedux/react'\n")),(0,o.kt)("p",null,"An ",(0,o.kt)("a",{parentName:"p",href:"../glossary#injector"},"injector")," that accepts an atom and its params and registers a ",(0,o.kt)("a",{parentName:"p",href:"../glossary#dynamic-graph-dependency"},"dynamic graph dependency")," on the resolved atom instance, returning a tuple of the current value and a state setter."),(0,o.kt)("p",null,"The atom instance that uses this injector will reevaluate whenever the resolved atom instance's state changes."),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)(r.u,{resultVar:"Seconds",mdxType:"LiveEditor"},"\nconst secondsAtom = atom('seconds', () => {\n  const store = injectStore(0)\n\n  injectEffect(() => {\n    const intervalId = setInterval(\n      () => store.setState(val => val + 1),\n      1000\n    )\n\n    return () => clearInterval(intervalId)\n  }, [])\n\n  return store\n})\n\nconst wrapperAtom = atom('wrapper', () => {\n  const [seconds, setSeconds] = injectAtomState(secondsAtom)\n\n  return api(seconds).setExports({\n    increment: () => setSeconds(val => val + 1)\n  })\n})\n\nfunction Seconds() {\n  const state = useAtomValue(wrapperAtom)\n  const { increment } = useAtomInstance(wrapperAtom).exports\n\n  return (\n    <>\n      <div>Seconds: {state}</div>\n      <button onClick={increment}>Increment</button>\n    </>\n  )\n}\n"),(0,o.kt)("h2",{id:"signature"},"Signature"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"injectAtomState(atom, params?) => [state, setState]\n")),(0,o.kt)("p",null,"Uses the atom + params combo to find an existing atom instance. If no instance is found, creates one. Returns a tuple of the resolved atom instance's current state and ",(0,o.kt)("a",{parentName:"p",href:"../classes/AtomInstance#setstate"},"state setter"),"."),(0,o.kt)("h3",{id:"overloads"},"Overloads"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"injectAtomState(instance) => [state, setState]\n")),(0,o.kt)("h3",{id:"atom"},(0,o.kt)("inlineCode",{parentName:"h3"},"atom")),(0,o.kt)("p",null,"Required. The ",(0,o.kt)("a",{parentName:"p",href:"../classes/Atom"},"atom")," object whose key will be used to find an existing atom instance and whose definition will be used to create an atom instance if none exist yet."),(0,o.kt)("h3",{id:"params"},(0,o.kt)("inlineCode",{parentName:"h3"},"params")),(0,o.kt)("p",null,"Optional. An array of parameters that identify this atom instance. These params will be passed to the atom's ",(0,o.kt)("a",{parentName:"p",href:"../glossary#evaluator"},"evaluator function"),"."),(0,o.kt)("p",null,"TS users will be required to pass this for atoms that take params. If you don't use TS ... just don't forget to pass them."),(0,o.kt)("h3",{id:"instance"},(0,o.kt)("inlineCode",{parentName:"h3"},"instance")),(0,o.kt)("p",null,"Required (in this overload). An ",(0,o.kt)("a",{parentName:"p",href:"../classes/AtomInstance"},"atom instance"),". Will register a dynamic dependency on the passed instance and return a tuple of the instance's current value and ",(0,o.kt)("inlineCode",{parentName:"p"},"setState")," function."))}u.isMDXComponent=!0}}]);