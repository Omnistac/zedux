"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[995],{995:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": function() { return /* binding */ Fu; },\n/* harmony export */   "uriTransformer": function() { return /* binding */ gr; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7294);\n/* harmony import */ var _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4359);\n\n\nconst ze = ["http", "https", "mailto", "tel"];\nfunction gr(n) {\n  const e = (n || "").trim(), t = e.charAt(0);\n  if (t === "#" || t === "/")\n    return e;\n  const r = e.indexOf(":");\n  if (r === -1)\n    return e;\n  let i = -1;\n  for (; ++i < ze.length; ) {\n    const l = ze[i];\n    if (r === l.length && e.slice(0, l.length).toLowerCase() === l)\n      return e;\n  }\n  return i = e.indexOf("?"), i !== -1 && r > i || (i = e.indexOf("#"), i !== -1 && r > i) ? e : "javascript:void(0)";\n}\n/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\nvar yr = function(e) {\n  return e != null && e.constructor != null && typeof e.constructor.isBuffer == "function" && e.constructor.isBuffer(e);\n};\nconst Pt = yr;\nfunction xr(n) {\n  return !n || typeof n != "object" ? "" : "position" in n || "type" in n ? Re(n.position) : "start" in n || "end" in n ? Re(n) : "line" in n || "column" in n ? he(n) : "";\n}\nfunction he(n) {\n  return _e(n && n.line) + ":" + _e(n && n.column);\n}\nfunction Re(n) {\n  return he(n && n.start) + "-" + he(n && n.end);\n}\nfunction _e(n) {\n  return n && typeof n == "number" ? n : 1;\n}\nclass cn extends Error {\n  /**\n   * Create a message for `reason` at `place` from `origin`.\n   *\n   * When an error is passed in as `reason`, the `stack` is copied.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   *\n   *   > \ud83d\udc49 **Note**: you should use markdown.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `\'my-package:my-rule\'` or `\'my-rule\'`).\n   * @returns\n   *   Instance of `VFileMessage`.\n   */\n  // To do: next major: expose `undefined` everywhere instead of `null`.\n  constructor(e, t, r) {\n    const i = [null, null];\n    let l = {\n      // @ts-expect-error: we always follows the structure of `position`.\n      start: { line: null, column: null },\n      // @ts-expect-error: "\n      end: { line: null, column: null }\n    };\n    if (super(), typeof t == "string" && (r = t, t = void 0), typeof r == "string") {\n      const o = r.indexOf(":");\n      o === -1 ? i[1] = r : (i[0] = r.slice(0, o), i[1] = r.slice(o + 1));\n    }\n    t && ("type" in t || "position" in t ? t.position && (l = t.position) : "start" in t || "end" in t ? l = t : ("line" in t || "column" in t) && (l.start = t)), this.name = xr(t) || "1:1", this.message = typeof e == "object" ? e.message : e, this.stack = "", typeof e == "object" && e.stack && (this.stack = e.stack), this.reason = this.message, this.fatal, this.line = l.start.line, this.column = l.start.column, this.position = l, this.source = i[0], this.ruleId = i[1], this.file, this.actual, this.expected, this.url, this.note;\n  }\n}\ncn.prototype.file = "";\ncn.prototype.name = "";\ncn.prototype.reason = "";\ncn.prototype.message = "";\ncn.prototype.stack = "";\ncn.prototype.fatal = null;\ncn.prototype.column = null;\ncn.prototype.line = null;\ncn.prototype.source = null;\ncn.prototype.ruleId = null;\ncn.prototype.position = null;\nconst mn = { basename: kr, dirname: br, extname: wr, join: Sr, sep: "/" };\nfunction kr(n, e) {\n  if (e !== void 0 && typeof e != "string")\n    throw new TypeError(\'"ext" argument must be a string\');\n  Hn(n);\n  let t = 0, r = -1, i = n.length, l;\n  if (e === void 0 || e.length === 0 || e.length > n.length) {\n    for (; i--; )\n      if (n.charCodeAt(i) === 47) {\n        if (l) {\n          t = i + 1;\n          break;\n        }\n      } else\n        r < 0 && (l = !0, r = i + 1);\n    return r < 0 ? "" : n.slice(t, r);\n  }\n  if (e === n)\n    return "";\n  let o = -1, u = e.length - 1;\n  for (; i--; )\n    if (n.charCodeAt(i) === 47) {\n      if (l) {\n        t = i + 1;\n        break;\n      }\n    } else\n      o < 0 && (l = !0, o = i + 1), u > -1 && (n.charCodeAt(i) === e.charCodeAt(u--) ? u < 0 && (r = i) : (u = -1, r = o));\n  return t === r ? r = o : r < 0 && (r = n.length), n.slice(t, r);\n}\nfunction br(n) {\n  if (Hn(n), n.length === 0)\n    return ".";\n  let e = -1, t = n.length, r;\n  for (; --t; )\n    if (n.charCodeAt(t) === 47) {\n      if (r) {\n        e = t;\n        break;\n      }\n    } else\n      r || (r = !0);\n  return e < 0 ? n.charCodeAt(0) === 47 ? "/" : "." : e === 1 && n.charCodeAt(0) === 47 ? "//" : n.slice(0, e);\n}\nfunction wr(n) {\n  Hn(n);\n  let e = n.length, t = -1, r = 0, i = -1, l = 0, o;\n  for (; e--; ) {\n    const u = n.charCodeAt(e);\n    if (u === 47) {\n      if (o) {\n        r = e + 1;\n        break;\n      }\n      continue;\n    }\n    t < 0 && (o = !0, t = e + 1), u === 46 ? i < 0 ? i = e : l !== 1 && (l = 1) : i > -1 && (l = -1);\n  }\n  return i < 0 || t < 0 || // We saw a non-dot character immediately before the dot.\n  l === 0 || // The (right-most) trimmed path component is exactly `..`.\n  l === 1 && i === t - 1 && i === r + 1 ? "" : n.slice(i, t);\n}\nfunction Sr(...n) {\n  let e = -1, t;\n  for (; ++e < n.length; )\n    Hn(n[e]), n[e] && (t = t === void 0 ? n[e] : t + "/" + n[e]);\n  return t === void 0 ? "." : Er(t);\n}\nfunction Er(n) {\n  Hn(n);\n  const e = n.charCodeAt(0) === 47;\n  let t = Cr(n, !e);\n  return t.length === 0 && !e && (t = "."), t.length > 0 && n.charCodeAt(n.length - 1) === 47 && (t += "/"), e ? "/" + t : t;\n}\nfunction Cr(n, e) {\n  let t = "", r = 0, i = -1, l = 0, o = -1, u, a;\n  for (; ++o <= n.length; ) {\n    if (o < n.length)\n      u = n.charCodeAt(o);\n    else {\n      if (u === 47)\n        break;\n      u = 47;\n    }\n    if (u === 47) {\n      if (!(i === o - 1 || l === 1))\n        if (i !== o - 1 && l === 2) {\n          if (t.length < 2 || r !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {\n            if (t.length > 2) {\n              if (a = t.lastIndexOf("/"), a !== t.length - 1) {\n                a < 0 ? (t = "", r = 0) : (t = t.slice(0, a), r = t.length - 1 - t.lastIndexOf("/")), i = o, l = 0;\n                continue;\n              }\n            } else if (t.length > 0) {\n              t = "", r = 0, i = o, l = 0;\n              continue;\n            }\n          }\n          e && (t = t.length > 0 ? t + "/.." : "..", r = 2);\n        } else\n          t.length > 0 ? t += "/" + n.slice(i + 1, o) : t = n.slice(i + 1, o), r = o - i - 1;\n      i = o, l = 0;\n    } else\n      u === 46 && l > -1 ? l++ : l = -1;\n  }\n  return t;\n}\nfunction Hn(n) {\n  if (typeof n != "string")\n    throw new TypeError(\n      "Path must be a string. Received " + JSON.stringify(n)\n    );\n}\nconst Ar = { cwd: Pr };\nfunction Pr() {\n  return "/";\n}\nfunction me(n) {\n  return n !== null && typeof n == "object" && // @ts-expect-error: indexable.\n  n.href && // @ts-expect-error: indexable.\n  n.origin;\n}\nfunction Fr(n) {\n  if (typeof n == "string")\n    n = new URL(n);\n  else if (!me(n)) {\n    const e = new TypeError(\n      \'The "path" argument must be of type string or an instance of URL. Received `\' + n + "`"\n    );\n    throw e.code = "ERR_INVALID_ARG_TYPE", e;\n  }\n  if (n.protocol !== "file:") {\n    const e = new TypeError("The URL must be of scheme file");\n    throw e.code = "ERR_INVALID_URL_SCHEME", e;\n  }\n  return Tr(n);\n}\nfunction Tr(n) {\n  if (n.hostname !== "") {\n    const r = new TypeError(\n      \'File URL host must be "localhost" or empty on darwin\'\n    );\n    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;\n  }\n  const e = n.pathname;\n  let t = -1;\n  for (; ++t < e.length; )\n    if (e.charCodeAt(t) === 37 && e.charCodeAt(t + 1) === 50) {\n      const r = e.charCodeAt(t + 2);\n      if (r === 70 || r === 102) {\n        const i = new TypeError(\n          "File URL path must not include encoded / characters"\n        );\n        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;\n      }\n    }\n  return decodeURIComponent(e);\n}\nconst re = ["history", "path", "basename", "stem", "extname", "dirname"];\nclass Ft {\n  /**\n   * Create a new virtual file.\n   *\n   * `options` is treated as:\n   *\n   * *   `string` or `Buffer` \u2014 `{value: options}`\n   * *   `URL` \u2014 `{path: options}`\n   * *   `VFile` \u2014 shallow copies its data over to the new file\n   * *   `object` \u2014 all fields are shallow copied over to the new file\n   *\n   * Path related fields are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * You cannot set `dirname` or `extname` without setting either `history`,\n   * `path`, `basename`, or `stem` too.\n   *\n   * @param {Compatible | null | undefined} [value]\n   *   File value.\n   * @returns\n   *   New instance.\n   */\n  constructor(e) {\n    let t;\n    e ? typeof e == "string" || Ir(e) ? t = { value: e } : me(e) ? t = { path: e } : t = e : t = {}, this.data = {}, this.messages = [], this.history = [], this.cwd = Ar.cwd(), this.value, this.stored, this.result, this.map;\n    let r = -1;\n    for (; ++r < re.length; ) {\n      const l = re[r];\n      l in t && t[l] !== void 0 && t[l] !== null && (this[l] = l === "history" ? [...t[l]] : t[l]);\n    }\n    let i;\n    for (i in t)\n      re.includes(i) || (this[i] = t[i]);\n  }\n  /**\n   * Get the full path (example: `\'~/index.min.js\'`).\n   *\n   * @returns {string}\n   */\n  get path() {\n    return this.history[this.history.length - 1];\n  }\n  /**\n   * Set the full path (example: `\'~/index.min.js\'`).\n   *\n   * Cannot be nullified.\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\n   * be turned into a path with `url.fileURLToPath`.\n   *\n   * @param {string | URL} path\n   */\n  set path(e) {\n    me(e) && (e = Fr(e)), le(e, "path"), this.path !== e && this.history.push(e);\n  }\n  /**\n   * Get the parent path (example: `\'~\'`).\n   */\n  get dirname() {\n    return typeof this.path == "string" ? mn.dirname(this.path) : void 0;\n  }\n  /**\n   * Set the parent path (example: `\'~\'`).\n   *\n   * Cannot be set if there\u2019s no `path` yet.\n   */\n  set dirname(e) {\n    Me(this.basename, "dirname"), this.path = mn.join(e || "", this.basename);\n  }\n  /**\n   * Get the basename (including extname) (example: `\'index.min.js\'`).\n   */\n  get basename() {\n    return typeof this.path == "string" ? mn.basename(this.path) : void 0;\n  }\n  /**\n   * Set basename (including extname) (`\'index.min.js\'`).\n   *\n   * Cannot contain path separators (`\'/\'` on unix, macOS, and browsers, `\'\\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set basename(e) {\n    le(e, "basename"), ie(e, "basename"), this.path = mn.join(this.dirname || "", e);\n  }\n  /**\n   * Get the extname (including dot) (example: `\'.js\'`).\n   */\n  get extname() {\n    return typeof this.path == "string" ? mn.extname(this.path) : void 0;\n  }\n  /**\n   * Set the extname (including dot) (example: `\'.js\'`).\n   *\n   * Cannot contain path separators (`\'/\'` on unix, macOS, and browsers, `\'\\\'`\n   * on windows).\n   * Cannot be set if there\u2019s no `path` yet.\n   */\n  set extname(e) {\n    if (ie(e, "extname"), Me(this.dirname, "extname"), e) {\n      if (e.charCodeAt(0) !== 46)\n        throw new Error("`extname` must start with `.`");\n      if (e.includes(".", 1))\n        throw new Error("`extname` cannot contain multiple dots");\n    }\n    this.path = mn.join(this.dirname, this.stem + (e || ""));\n  }\n  /**\n   * Get the stem (basename w/o extname) (example: `\'index.min\'`).\n   */\n  get stem() {\n    return typeof this.path == "string" ? mn.basename(this.path, this.extname) : void 0;\n  }\n  /**\n   * Set the stem (basename w/o extname) (example: `\'index.min\'`).\n   *\n   * Cannot contain path separators (`\'/\'` on unix, macOS, and browsers, `\'\\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set stem(e) {\n    le(e, "stem"), ie(e, "stem"), this.path = mn.join(this.dirname || "", e + (this.extname || ""));\n  }\n  /**\n   * Serialize the file.\n   *\n   * @param {BufferEncoding | null | undefined} [encoding=\'utf8\']\n   *   Character encoding to understand `value` as when it\u2019s a `Buffer`\n   *   (default: `\'utf8\'`).\n   * @returns {string}\n   *   Serialized file.\n   */\n  toString(e) {\n    return (this.value || "").toString(e || void 0);\n  }\n  /**\n   * Create a warning message associated with the file.\n   *\n   * Its `fatal` is set to `false` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `\'my-package:my-rule\'` or `\'my-rule\'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  message(e, t, r) {\n    const i = new cn(e, t, r);\n    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;\n  }\n  /**\n   * Create an info message associated with the file.\n   *\n   * Its `fatal` is set to `null` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `\'my-package:my-rule\'` or `\'my-rule\'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  info(e, t, r) {\n    const i = this.message(e, t, r);\n    return i.fatal = null, i;\n  }\n  /**\n   * Create a fatal error associated with the file.\n   *\n   * Its `fatal` is set to `true` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * > \ud83d\udc49 **Note**: a fatal error means that a file is no longer processable.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `\'my-package:my-rule\'` or `\'my-rule\'`).\n   * @returns {never}\n   *   Message.\n   * @throws {VFileMessage}\n   *   Message.\n   */\n  fail(e, t, r) {\n    const i = this.message(e, t, r);\n    throw i.fatal = !0, i;\n  }\n}\nfunction ie(n, e) {\n  if (n && n.includes(mn.sep))\n    throw new Error(\n      "`" + e + "` cannot be a path: did not expect `" + mn.sep + "`"\n    );\n}\nfunction le(n, e) {\n  if (!n)\n    throw new Error("`" + e + "` cannot be empty");\n}\nfunction Me(n, e) {\n  if (!n)\n    throw new Error("Setting `" + e + "` requires `path` to be set too");\n}\nfunction Ir(n) {\n  return Pt(n);\n}\nfunction Be(n) {\n  if (n)\n    throw n;\n}\nvar Yn = Object.prototype.hasOwnProperty, Tt = Object.prototype.toString, Ne = Object.defineProperty, je = Object.getOwnPropertyDescriptor, $e = function(e) {\n  return typeof Array.isArray == "function" ? Array.isArray(e) : Tt.call(e) === "[object Array]";\n}, He = function(e) {\n  if (!e || Tt.call(e) !== "[object Object]")\n    return !1;\n  var t = Yn.call(e, "constructor"), r = e.constructor && e.constructor.prototype && Yn.call(e.constructor.prototype, "isPrototypeOf");\n  if (e.constructor && !t && !r)\n    return !1;\n  var i;\n  for (i in e)\n    ;\n  return typeof i > "u" || Yn.call(e, i);\n}, Ue = function(e, t) {\n  Ne && t.name === "__proto__" ? Ne(e, t.name, {\n    enumerable: !0,\n    configurable: !0,\n    value: t.newValue,\n    writable: !0\n  }) : e[t.name] = t.newValue;\n}, Ve = function(e, t) {\n  if (t === "__proto__")\n    if (Yn.call(e, t)) {\n      if (je)\n        return je(e, t).value;\n    } else\n      return;\n  return e[t];\n}, qe = function n() {\n  var e, t, r, i, l, o, u = arguments[0], a = 1, c = arguments.length, s = !1;\n  for (typeof u == "boolean" && (s = u, u = arguments[1] || {}, a = 2), (u == null || typeof u != "object" && typeof u != "function") && (u = {}); a < c; ++a)\n    if (e = arguments[a], e != null)\n      for (t in e)\n        r = Ve(u, t), i = Ve(e, t), u !== i && (s && i && (He(i) || (l = $e(i))) ? (l ? (l = !1, o = r && $e(r) ? r : []) : o = r && He(r) ? r : {}, Ue(u, { name: t, newValue: n(s, o, i) })) : typeof i < "u" && Ue(u, { name: t, newValue: i }));\n  return u;\n};\nfunction de(n) {\n  if (typeof n != "object" || n === null)\n    return !1;\n  const e = Object.getPrototypeOf(n);\n  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n);\n}\nfunction Or() {\n  const n = [], e = { run: t, use: r };\n  return e;\n  function t(...i) {\n    let l = -1;\n    const o = i.pop();\n    if (typeof o != "function")\n      throw new TypeError("Expected function as last argument, not " + o);\n    u(null, ...i);\n    function u(a, ...c) {\n      const s = n[++l];\n      let h = -1;\n      if (a) {\n        o(a);\n        return;\n      }\n      for (; ++h < i.length; )\n        (c[h] === null || c[h] === void 0) && (c[h] = i[h]);\n      i = c, s ? Lr(s, u)(...c) : o(null, ...c);\n    }\n  }\n  function r(i) {\n    if (typeof i != "function")\n      throw new TypeError(\n        "Expected `middelware` to be a function, not " + i\n      );\n    return n.push(i), e;\n  }\n}\nfunction Lr(n, e) {\n  let t;\n  return r;\n  function r(...o) {\n    const u = n.length > o.length;\n    let a;\n    u && o.push(i);\n    try {\n      a = n.apply(this, o);\n    } catch (c) {\n      const s = (\n        /** @type {Error} */\n        c\n      );\n      if (u && t)\n        throw s;\n      return i(s);\n    }\n    u || (a instanceof Promise ? a.then(l, i) : a instanceof Error ? i(a) : l(a));\n  }\n  function i(o, ...u) {\n    t || (t = !0, e(o, ...u));\n  }\n  function l(o) {\n    i(null, o);\n  }\n}\nconst Dr = Ot().freeze(), It = {}.hasOwnProperty;\nfunction Ot() {\n  const n = Or(), e = [];\n  let t = {}, r, i = -1;\n  return l.data = o, l.Parser = void 0, l.Compiler = void 0, l.freeze = u, l.attachers = e, l.use = a, l.parse = c, l.stringify = s, l.run = h, l.runSync = g, l.process = d, l.processSync = m, l;\n  function l() {\n    const y = Ot();\n    let x = -1;\n    for (; ++x < e.length; )\n      y.use(...e[x]);\n    return y.data(qe(!0, {}, t)), y;\n  }\n  function o(y, x) {\n    return typeof y == "string" ? arguments.length === 2 ? (ae("data", r), t[y] = x, l) : It.call(t, y) && t[y] || null : y ? (ae("data", r), t = y, l) : t;\n  }\n  function u() {\n    if (r)\n      return l;\n    for (; ++i < e.length; ) {\n      const [y, ...x] = e[i];\n      if (x[0] === !1)\n        continue;\n      x[0] === !0 && (x[0] = void 0);\n      const w = y.call(l, ...x);\n      typeof w == "function" && n.use(w);\n    }\n    return r = !0, i = Number.POSITIVE_INFINITY, l;\n  }\n  function a(y, ...x) {\n    let w;\n    if (ae("use", r), y != null)\n      if (typeof y == "function")\n        T(y, ...x);\n      else if (typeof y == "object")\n        Array.isArray(y) ? _(y) : A(y);\n      else\n        throw new TypeError("Expected usable value, not `" + y + "`");\n    return w && (t.settings = Object.assign(t.settings || {}, w)), l;\n    function v(b) {\n      if (typeof b == "function")\n        T(b);\n      else if (typeof b == "object")\n        if (Array.isArray(b)) {\n          const [I, ...R] = b;\n          T(I, ...R);\n        } else\n          A(b);\n      else\n        throw new TypeError("Expected usable value, not `" + b + "`");\n    }\n    function A(b) {\n      _(b.plugins), b.settings && (w = Object.assign(w || {}, b.settings));\n    }\n    function _(b) {\n      let I = -1;\n      if (b != null)\n        if (Array.isArray(b))\n          for (; ++I < b.length; ) {\n            const R = b[I];\n            v(R);\n          }\n        else\n          throw new TypeError("Expected a list of plugins, not `" + b + "`");\n    }\n    function T(b, I) {\n      let R = -1, M;\n      for (; ++R < e.length; )\n        if (e[R][0] === b) {\n          M = e[R];\n          break;\n        }\n      M ? (de(M[1]) && de(I) && (I = qe(!0, M[1], I)), M[1] = I) : e.push([...arguments]);\n    }\n  }\n  function c(y) {\n    l.freeze();\n    const x = jn(y), w = l.Parser;\n    return oe("parse", w), We(w, "parse") ? new w(String(x), x).parse() : w(String(x), x);\n  }\n  function s(y, x) {\n    l.freeze();\n    const w = jn(x), v = l.Compiler;\n    return ue("stringify", v), Ye(y), We(v, "compile") ? new v(y, w).compile() : v(y, w);\n  }\n  function h(y, x, w) {\n    if (Ye(y), l.freeze(), !w && typeof x == "function" && (w = x, x = void 0), !w)\n      return new Promise(v);\n    v(null, w);\n    function v(A, _) {\n      n.run(y, jn(x), T);\n      function T(b, I, R) {\n        I = I || y, b ? _(b) : A ? A(I) : w(null, I, R);\n      }\n    }\n  }\n  function g(y, x) {\n    let w, v;\n    return l.run(y, x, A), Qe("runSync", "run", v), w;\n    function A(_, T) {\n      Be(_), w = T, v = !0;\n    }\n  }\n  function d(y, x) {\n    if (l.freeze(), oe("process", l.Parser), ue("process", l.Compiler), !x)\n      return new Promise(w);\n    w(null, x);\n    function w(v, A) {\n      const _ = jn(y);\n      l.run(l.parse(_), _, (b, I, R) => {\n        if (b || !I || !R)\n          T(b);\n        else {\n          const M = l.stringify(I, R);\n          M == null || (Rr(M) ? R.value = M : R.result = M), T(b, R);\n        }\n      });\n      function T(b, I) {\n        b || !I ? A(b) : v ? v(I) : x(null, I);\n      }\n    }\n  }\n  function m(y) {\n    let x;\n    l.freeze(), oe("processSync", l.Parser), ue("processSync", l.Compiler);\n    const w = jn(y);\n    return l.process(w, v), Qe("processSync", "process", x), w;\n    function v(A) {\n      x = !0, Be(A);\n    }\n  }\n}\nfunction We(n, e) {\n  return typeof n == "function" && // Prototypes do exist.\n  // type-coverage:ignore-next-line\n  n.prototype && // A function with keys in its prototype is probably a constructor.\n  // Classes\u2019 prototype methods are not enumerable, so we check if some value\n  // exists in the prototype.\n  // type-coverage:ignore-next-line\n  (vr(n.prototype) || e in n.prototype);\n}\nfunction vr(n) {\n  let e;\n  for (e in n)\n    if (It.call(n, e))\n      return !0;\n  return !1;\n}\nfunction oe(n, e) {\n  if (typeof e != "function")\n    throw new TypeError("Cannot `" + n + "` without `Parser`");\n}\nfunction ue(n, e) {\n  if (typeof e != "function")\n    throw new TypeError("Cannot `" + n + "` without `Compiler`");\n}\nfunction ae(n, e) {\n  if (e)\n    throw new Error(\n      "Cannot call `" + n + "` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."\n    );\n}\nfunction Ye(n) {\n  if (!de(n) || typeof n.type != "string")\n    throw new TypeError("Expected node, got `" + n + "`");\n}\nfunction Qe(n, e, t) {\n  if (!t)\n    throw new Error(\n      "`" + n + "` finished async. Use `" + e + "` instead"\n    );\n}\nfunction jn(n) {\n  return zr(n) ? n : new Ft(n);\n}\nfunction zr(n) {\n  return !!(n && typeof n == "object" && "message" in n && "messages" in n);\n}\nfunction Rr(n) {\n  return typeof n == "string" || Pt(n);\n}\nfunction _r(n, e) {\n  const t = (e || {}).includeImageAlt;\n  return Lt(\n    n,\n    typeof t == "boolean" ? t : !0\n  );\n}\nfunction Lt(n, e) {\n  return Mr(n) && ("value" in n && n.value || e && "alt" in n && n.alt || "children" in n && Xe(n.children, e)) || Array.isArray(n) && Xe(n, e) || "";\n}\nfunction Xe(n, e) {\n  const t = [];\n  let r = -1;\n  for (; ++r < n.length; )\n    t[r] = Lt(n[r], e);\n  return t.join("");\n}\nfunction Mr(n) {\n  return !!(n && typeof n == "object");\n}\nfunction gn(n, e, t, r) {\n  const i = n.length;\n  let l = 0, o;\n  if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, t = t > 0 ? t : 0, r.length < 1e4)\n    o = Array.from(r), o.unshift(e, t), [].splice.apply(n, o);\n  else\n    for (t && [].splice.apply(n, [e, t]); l < r.length; )\n      o = r.slice(l, l + 1e4), o.unshift(e, 0), [].splice.apply(n, o), l += 1e4, e += 1e4;\n}\nfunction an(n, e) {\n  return n.length > 0 ? (gn(n, n.length, 0, e), n) : e;\n}\nconst Ke = {}.hasOwnProperty;\nfunction Br(n) {\n  const e = {};\n  let t = -1;\n  for (; ++t < n.length; )\n    Nr(e, n[t]);\n  return e;\n}\nfunction Nr(n, e) {\n  let t;\n  for (t in e) {\n    const i = (Ke.call(n, t) ? n[t] : void 0) || (n[t] = {}), l = e[t];\n    let o;\n    for (o in l) {\n      Ke.call(i, o) || (i[o] = []);\n      const u = l[o];\n      jr(\n        // @ts-expect-error Looks like a list.\n        i[o],\n        Array.isArray(u) ? u : u ? [u] : []\n      );\n    }\n  }\n}\nfunction jr(n, e) {\n  let t = -1;\n  const r = [];\n  for (; ++t < e.length; )\n    (e[t].add === "after" ? n : r).push(e[t]);\n  gn(n, 0, 0, r);\n}\nconst $r = /[!-/:-@[-`{-~\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/, dn = An(/[A-Za-z]/), ge = An(/\\d/), Hr = An(/[\\dA-Fa-f]/), on = An(/[\\dA-Za-z]/), Ur = An(/[!-/:-@[-`{-~]/), Ge = An(/[#-\'*+\\--9=?A-Z^-~]/);\nfunction ye(n) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    n !== null && (n < 32 || n === 127)\n  );\n}\nfunction sn(n) {\n  return n !== null && (n < 0 || n === 32);\n}\nfunction L(n) {\n  return n !== null && n < -2;\n}\nfunction G(n) {\n  return n === -2 || n === -1 || n === 32;\n}\nconst Vr = An(/\\s/), qr = An($r);\nfunction An(n) {\n  return e;\n  function e(t) {\n    return t !== null && n.test(String.fromCharCode(t));\n  }\n}\nfunction U(n, e, t, r) {\n  const i = r ? r - 1 : Number.POSITIVE_INFINITY;\n  let l = 0;\n  return o;\n  function o(a) {\n    return G(a) ? (n.enter(t), u(a)) : e(a);\n  }\n  function u(a) {\n    return G(a) && l++ < i ? (n.consume(a), u) : (n.exit(t), e(a));\n  }\n}\nconst Wr = {\n  tokenize: Yr\n};\nfunction Yr(n) {\n  const e = n.attempt(\n    this.parser.constructs.contentInitial,\n    r,\n    i\n  );\n  let t;\n  return e;\n  function r(u) {\n    if (u === null) {\n      n.consume(u);\n      return;\n    }\n    return n.enter("lineEnding"), n.consume(u), n.exit("lineEnding"), U(n, e, "linePrefix");\n  }\n  function i(u) {\n    return n.enter("paragraph"), l(u);\n  }\n  function l(u) {\n    const a = n.enter("chunkText", {\n      contentType: "text",\n      previous: t\n    });\n    return t && (t.next = a), t = a, o(u);\n  }\n  function o(u) {\n    if (u === null) {\n      n.exit("chunkText"), n.exit("paragraph"), n.consume(u);\n      return;\n    }\n    return L(u) ? (n.consume(u), n.exit("chunkText"), l) : (n.consume(u), o);\n  }\n}\nconst Qr = {\n  tokenize: Xr\n}, Ze = {\n  tokenize: Kr\n};\nfunction Xr(n) {\n  const e = this, t = [];\n  let r = 0, i, l, o;\n  return u;\n  function u(A) {\n    if (r < t.length) {\n      const _ = t[r];\n      return e.containerState = _[1], n.attempt(\n        _[0].continuation,\n        a,\n        c\n      )(A);\n    }\n    return c(A);\n  }\n  function a(A) {\n    if (r++, e.containerState._closeFlow) {\n      e.containerState._closeFlow = void 0, i && v();\n      const _ = e.events.length;\n      let T = _, b;\n      for (; T--; )\n        if (e.events[T][0] === "exit" && e.events[T][1].type === "chunkFlow") {\n          b = e.events[T][1].end;\n          break;\n        }\n      w(r);\n      let I = _;\n      for (; I < e.events.length; )\n        e.events[I][1].end = Object.assign({}, b), I++;\n      return gn(\n        e.events,\n        T + 1,\n        0,\n        e.events.slice(_)\n      ), e.events.length = I, c(A);\n    }\n    return u(A);\n  }\n  function c(A) {\n    if (r === t.length) {\n      if (!i)\n        return g(A);\n      if (i.currentConstruct && i.currentConstruct.concrete)\n        return m(A);\n      e.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);\n    }\n    return e.containerState = {}, n.check(\n      Ze,\n      s,\n      h\n    )(A);\n  }\n  function s(A) {\n    return i && v(), w(r), g(A);\n  }\n  function h(A) {\n    return e.parser.lazy[e.now().line] = r !== t.length, o = e.now().offset, m(A);\n  }\n  function g(A) {\n    return e.containerState = {}, n.attempt(\n      Ze,\n      d,\n      m\n    )(A);\n  }\n  function d(A) {\n    return r++, t.push([e.currentConstruct, e.containerState]), g(A);\n  }\n  function m(A) {\n    if (A === null) {\n      i && v(), w(0), n.consume(A);\n      return;\n    }\n    return i = i || e.parser.flow(e.now()), n.enter("chunkFlow", {\n      contentType: "flow",\n      previous: l,\n      _tokenizer: i\n    }), y(A);\n  }\n  function y(A) {\n    if (A === null) {\n      x(n.exit("chunkFlow"), !0), w(0), n.consume(A);\n      return;\n    }\n    return L(A) ? (n.consume(A), x(n.exit("chunkFlow")), r = 0, e.interrupt = void 0, u) : (n.consume(A), y);\n  }\n  function x(A, _) {\n    const T = e.sliceStream(A);\n    if (_ && T.push(null), A.previous = l, l && (l.next = A), l = A, i.defineSkip(A.start), i.write(T), e.parser.lazy[A.start.line]) {\n      let b = i.events.length;\n      for (; b--; )\n        if (\n          // The token starts before the line ending\u2026\n          i.events[b][1].start.offset < o && // \u2026and either is not ended yet\u2026\n          (!i.events[b][1].end || // \u2026or ends after it.\n          i.events[b][1].end.offset > o)\n        )\n          return;\n      const I = e.events.length;\n      let R = I, M, X;\n      for (; R--; )\n        if (e.events[R][0] === "exit" && e.events[R][1].type === "chunkFlow") {\n          if (M) {\n            X = e.events[R][1].end;\n            break;\n          }\n          M = !0;\n        }\n      for (w(r), b = I; b < e.events.length; )\n        e.events[b][1].end = Object.assign({}, X), b++;\n      gn(\n        e.events,\n        R + 1,\n        0,\n        e.events.slice(I)\n      ), e.events.length = b;\n    }\n  }\n  function w(A) {\n    let _ = t.length;\n    for (; _-- > A; ) {\n      const T = t[_];\n      e.containerState = T[1], T[0].exit.call(e, n);\n    }\n    t.length = A;\n  }\n  function v() {\n    i.write([null]), l = void 0, i = void 0, e.containerState._closeFlow = void 0;\n  }\n}\nfunction Kr(n, e, t) {\n  return U(\n    n,\n    n.attempt(this.parser.constructs.document, e, t),\n    "linePrefix",\n    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4\n  );\n}\nfunction Je(n) {\n  if (n === null || sn(n) || Vr(n))\n    return 1;\n  if (qr(n))\n    return 2;\n}\nfunction Ce(n, e, t) {\n  const r = [];\n  let i = -1;\n  for (; ++i < n.length; ) {\n    const l = n[i].resolveAll;\n    l && !r.includes(l) && (e = l(e, t), r.push(l));\n  }\n  return e;\n}\nconst xe = {\n  name: "attention",\n  tokenize: Zr,\n  resolveAll: Gr\n};\nfunction Gr(n, e) {\n  let t = -1, r, i, l, o, u, a, c, s;\n  for (; ++t < n.length; )\n    if (n[t][0] === "enter" && n[t][1].type === "attentionSequence" && n[t][1]._close) {\n      for (r = t; r--; )\n        if (n[r][0] === "exit" && n[r][1].type === "attentionSequence" && n[r][1]._open && // If the markers are the same:\n        e.sliceSerialize(n[r][1]).charCodeAt(0) === e.sliceSerialize(n[t][1]).charCodeAt(0)) {\n          if ((n[r][1]._close || n[t][1]._open) && (n[t][1].end.offset - n[t][1].start.offset) % 3 && !((n[r][1].end.offset - n[r][1].start.offset + n[t][1].end.offset - n[t][1].start.offset) % 3))\n            continue;\n          a = n[r][1].end.offset - n[r][1].start.offset > 1 && n[t][1].end.offset - n[t][1].start.offset > 1 ? 2 : 1;\n          const h = Object.assign({}, n[r][1].end), g = Object.assign({}, n[t][1].start);\n          nt(h, -a), nt(g, a), o = {\n            type: a > 1 ? "strongSequence" : "emphasisSequence",\n            start: h,\n            end: Object.assign({}, n[r][1].end)\n          }, u = {\n            type: a > 1 ? "strongSequence" : "emphasisSequence",\n            start: Object.assign({}, n[t][1].start),\n            end: g\n          }, l = {\n            type: a > 1 ? "strongText" : "emphasisText",\n            start: Object.assign({}, n[r][1].end),\n            end: Object.assign({}, n[t][1].start)\n          }, i = {\n            type: a > 1 ? "strong" : "emphasis",\n            start: Object.assign({}, o.start),\n            end: Object.assign({}, u.end)\n          }, n[r][1].end = Object.assign({}, o.start), n[t][1].start = Object.assign({}, u.end), c = [], n[r][1].end.offset - n[r][1].start.offset && (c = an(c, [\n            ["enter", n[r][1], e],\n            ["exit", n[r][1], e]\n          ])), c = an(c, [\n            ["enter", i, e],\n            ["enter", o, e],\n            ["exit", o, e],\n            ["enter", l, e]\n          ]), c = an(\n            c,\n            Ce(\n              e.parser.constructs.insideSpan.null,\n              n.slice(r + 1, t),\n              e\n            )\n          ), c = an(c, [\n            ["exit", l, e],\n            ["enter", u, e],\n            ["exit", u, e],\n            ["exit", i, e]\n          ]), n[t][1].end.offset - n[t][1].start.offset ? (s = 2, c = an(c, [\n            ["enter", n[t][1], e],\n            ["exit", n[t][1], e]\n          ])) : s = 0, gn(n, r - 1, t - r + 3, c), t = r + c.length - s - 2;\n          break;\n        }\n    }\n  for (t = -1; ++t < n.length; )\n    n[t][1].type === "attentionSequence" && (n[t][1].type = "data");\n  return n;\n}\nfunction Zr(n, e) {\n  const t = this.parser.constructs.attentionMarkers.null, r = this.previous, i = Je(r);\n  let l;\n  return o;\n  function o(a) {\n    return n.enter("attentionSequence"), l = a, u(a);\n  }\n  function u(a) {\n    if (a === l)\n      return n.consume(a), u;\n    const c = n.exit("attentionSequence"), s = Je(a), h = !s || s === 2 && i || t.includes(a), g = !i || i === 2 && s || t.includes(r);\n    return c._open = !!(l === 42 ? h : h && (i || !g)), c._close = !!(l === 42 ? g : g && (s || !h)), e(a);\n  }\n}\nfunction nt(n, e) {\n  n.column += e, n.offset += e, n._bufferIndex += e;\n}\nconst Jr = {\n  name: "autolink",\n  tokenize: ni\n};\nfunction ni(n, e, t) {\n  let r = 1;\n  return i;\n  function i(m) {\n    return n.enter("autolink"), n.enter("autolinkMarker"), n.consume(m), n.exit("autolinkMarker"), n.enter("autolinkProtocol"), l;\n  }\n  function l(m) {\n    return dn(m) ? (n.consume(m), o) : Ge(m) ? c(m) : t(m);\n  }\n  function o(m) {\n    return m === 43 || m === 45 || m === 46 || on(m) ? u(m) : c(m);\n  }\n  function u(m) {\n    return m === 58 ? (n.consume(m), a) : (m === 43 || m === 45 || m === 46 || on(m)) && r++ < 32 ? (n.consume(m), u) : c(m);\n  }\n  function a(m) {\n    return m === 62 ? (n.exit("autolinkProtocol"), d(m)) : m === null || m === 32 || m === 60 || ye(m) ? t(m) : (n.consume(m), a);\n  }\n  function c(m) {\n    return m === 64 ? (n.consume(m), r = 0, s) : Ge(m) ? (n.consume(m), c) : t(m);\n  }\n  function s(m) {\n    return on(m) ? h(m) : t(m);\n  }\n  function h(m) {\n    return m === 46 ? (n.consume(m), r = 0, s) : m === 62 ? (n.exit("autolinkProtocol").type = "autolinkEmail", d(m)) : g(m);\n  }\n  function g(m) {\n    return (m === 45 || on(m)) && r++ < 63 ? (n.consume(m), m === 45 ? g : h) : t(m);\n  }\n  function d(m) {\n    return n.enter("autolinkMarker"), n.consume(m), n.exit("autolinkMarker"), n.exit("autolink"), e;\n  }\n}\nconst Zn = {\n  tokenize: ei,\n  partial: !0\n};\nfunction ei(n, e, t) {\n  return U(n, r, "linePrefix");\n  function r(i) {\n    return i === null || L(i) ? e(i) : t(i);\n  }\n}\nconst Dt = {\n  name: "blockQuote",\n  tokenize: ti,\n  continuation: {\n    tokenize: ri\n  },\n  exit: ii\n};\nfunction ti(n, e, t) {\n  const r = this;\n  return i;\n  function i(o) {\n    if (o === 62) {\n      const u = r.containerState;\n      return u.open || (n.enter("blockQuote", {\n        _container: !0\n      }), u.open = !0), n.enter("blockQuotePrefix"), n.enter("blockQuoteMarker"), n.consume(o), n.exit("blockQuoteMarker"), l;\n    }\n    return t(o);\n  }\n  function l(o) {\n    return G(o) ? (n.enter("blockQuotePrefixWhitespace"), n.consume(o), n.exit("blockQuotePrefixWhitespace"), n.exit("blockQuotePrefix"), e) : (n.exit("blockQuotePrefix"), e(o));\n  }\n}\nfunction ri(n, e, t) {\n  return U(\n    n,\n    n.attempt(Dt, e, t),\n    "linePrefix",\n    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4\n  );\n}\nfunction ii(n) {\n  n.exit("blockQuote");\n}\nconst vt = {\n  name: "characterEscape",\n  tokenize: li\n};\nfunction li(n, e, t) {\n  return r;\n  function r(l) {\n    return n.enter("characterEscape"), n.enter("escapeMarker"), n.consume(l), n.exit("escapeMarker"), i;\n  }\n  function i(l) {\n    return Ur(l) ? (n.enter("characterEscapeValue"), n.consume(l), n.exit("characterEscapeValue"), n.exit("characterEscape"), e) : t(l);\n  }\n}\nconst et = document.createElement("i");\nfunction Ae(n) {\n  const e = "&" + n + ";";\n  et.innerHTML = e;\n  const t = et.textContent;\n  return t.charCodeAt(t.length - 1) === 59 && n !== "semi" || t === e ? !1 : t;\n}\nconst zt = {\n  name: "characterReference",\n  tokenize: oi\n};\nfunction oi(n, e, t) {\n  const r = this;\n  let i = 0, l, o;\n  return u;\n  function u(h) {\n    return n.enter("characterReference"), n.enter("characterReferenceMarker"), n.consume(h), n.exit("characterReferenceMarker"), a;\n  }\n  function a(h) {\n    return h === 35 ? (n.enter("characterReferenceMarkerNumeric"), n.consume(h), n.exit("characterReferenceMarkerNumeric"), c) : (n.enter("characterReferenceValue"), l = 31, o = on, s(h));\n  }\n  function c(h) {\n    return h === 88 || h === 120 ? (n.enter("characterReferenceMarkerHexadecimal"), n.consume(h), n.exit("characterReferenceMarkerHexadecimal"), n.enter("characterReferenceValue"), l = 6, o = Hr, s) : (n.enter("characterReferenceValue"), l = 7, o = ge, s(h));\n  }\n  function s(h) {\n    let g;\n    return h === 59 && i ? (g = n.exit("characterReferenceValue"), o === on && !Ae(r.sliceSerialize(g)) ? t(h) : (n.enter("characterReferenceMarker"), n.consume(h), n.exit("characterReferenceMarker"), n.exit("characterReference"), e)) : o(h) && i++ < l ? (n.consume(h), s) : t(h);\n  }\n}\nconst tt = {\n  name: "codeFenced",\n  tokenize: ui,\n  concrete: !0\n};\nfunction ui(n, e, t) {\n  const r = this, i = {\n    tokenize: T,\n    partial: !0\n  }, l = {\n    tokenize: _,\n    partial: !0\n  }, o = this.events[this.events.length - 1], u = o && o[1].type === "linePrefix" ? o[2].sliceSerialize(o[1], !0).length : 0;\n  let a = 0, c;\n  return s;\n  function s(b) {\n    return n.enter("codeFenced"), n.enter("codeFencedFence"), n.enter("codeFencedFenceSequence"), c = b, h(b);\n  }\n  function h(b) {\n    return b === c ? (n.consume(b), a++, h) : (n.exit("codeFencedFenceSequence"), a < 3 ? t(b) : U(n, g, "whitespace")(b));\n  }\n  function g(b) {\n    return b === null || L(b) ? x(b) : (n.enter("codeFencedFenceInfo"), n.enter("chunkString", {\n      contentType: "string"\n    }), d(b));\n  }\n  function d(b) {\n    return b === null || sn(b) ? (n.exit("chunkString"), n.exit("codeFencedFenceInfo"), U(n, m, "whitespace")(b)) : b === 96 && b === c ? t(b) : (n.consume(b), d);\n  }\n  function m(b) {\n    return b === null || L(b) ? x(b) : (n.enter("codeFencedFenceMeta"), n.enter("chunkString", {\n      contentType: "string"\n    }), y(b));\n  }\n  function y(b) {\n    return b === null || L(b) ? (n.exit("chunkString"), n.exit("codeFencedFenceMeta"), x(b)) : b === 96 && b === c ? t(b) : (n.consume(b), y);\n  }\n  function x(b) {\n    return n.exit("codeFencedFence"), r.interrupt ? e(b) : w(b);\n  }\n  function w(b) {\n    return b === null ? A(b) : L(b) ? n.attempt(\n      l,\n      n.attempt(\n        i,\n        A,\n        u ? U(\n          n,\n          w,\n          "linePrefix",\n          u + 1\n        ) : w\n      ),\n      A\n    )(b) : (n.enter("codeFlowValue"), v(b));\n  }\n  function v(b) {\n    return b === null || L(b) ? (n.exit("codeFlowValue"), w(b)) : (n.consume(b), v);\n  }\n  function A(b) {\n    return n.exit("codeFenced"), e(b);\n  }\n  function _(b, I, R) {\n    const M = this;\n    return X;\n    function X(F) {\n      return b.enter("lineEnding"), b.consume(F), b.exit("lineEnding"), C;\n    }\n    function C(F) {\n      return M.parser.lazy[M.now().line] ? R(F) : I(F);\n    }\n  }\n  function T(b, I, R) {\n    let M = 0;\n    return U(\n      b,\n      X,\n      "linePrefix",\n      this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4\n    );\n    function X(B) {\n      return b.enter("codeFencedFence"), b.enter("codeFencedFenceSequence"), C(B);\n    }\n    function C(B) {\n      return B === c ? (b.consume(B), M++, C) : M < a ? R(B) : (b.exit("codeFencedFenceSequence"), U(b, F, "whitespace")(B));\n    }\n    function F(B) {\n      return B === null || L(B) ? (b.exit("codeFencedFence"), I(B)) : R(B);\n    }\n  }\n}\nconst se = {\n  name: "codeIndented",\n  tokenize: si\n}, ai = {\n  tokenize: ci,\n  partial: !0\n};\nfunction si(n, e, t) {\n  const r = this;\n  return i;\n  function i(c) {\n    return n.enter("codeIndented"), U(n, l, "linePrefix", 4 + 1)(c);\n  }\n  function l(c) {\n    const s = r.events[r.events.length - 1];\n    return s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? o(c) : t(c);\n  }\n  function o(c) {\n    return c === null ? a(c) : L(c) ? n.attempt(ai, o, a)(c) : (n.enter("codeFlowValue"), u(c));\n  }\n  function u(c) {\n    return c === null || L(c) ? (n.exit("codeFlowValue"), o(c)) : (n.consume(c), u);\n  }\n  function a(c) {\n    return n.exit("codeIndented"), e(c);\n  }\n}\nfunction ci(n, e, t) {\n  const r = this;\n  return i;\n  function i(o) {\n    return r.parser.lazy[r.now().line] ? t(o) : L(o) ? (n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), i) : U(n, l, "linePrefix", 4 + 1)(o);\n  }\n  function l(o) {\n    const u = r.events[r.events.length - 1];\n    return u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? e(o) : L(o) ? i(o) : t(o);\n  }\n}\nconst pi = {\n  name: "codeText",\n  tokenize: mi,\n  resolve: fi,\n  previous: hi\n};\nfunction fi(n) {\n  let e = n.length - 4, t = 3, r, i;\n  if ((n[t][1].type === "lineEnding" || n[t][1].type === "space") && (n[e][1].type === "lineEnding" || n[e][1].type === "space")) {\n    for (r = t; ++r < e; )\n      if (n[r][1].type === "codeTextData") {\n        n[t][1].type = "codeTextPadding", n[e][1].type = "codeTextPadding", t += 2, e -= 2;\n        break;\n      }\n  }\n  for (r = t - 1, e++; ++r <= e; )\n    i === void 0 ? r !== e && n[r][1].type !== "lineEnding" && (i = r) : (r === e || n[r][1].type === "lineEnding") && (n[i][1].type = "codeTextData", r !== i + 2 && (n[i][1].end = n[r - 1][1].end, n.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0);\n  return n;\n}\nfunction hi(n) {\n  return n !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";\n}\nfunction mi(n, e, t) {\n  let r = 0, i, l;\n  return o;\n  function o(h) {\n    return n.enter("codeText"), n.enter("codeTextSequence"), u(h);\n  }\n  function u(h) {\n    return h === 96 ? (n.consume(h), r++, u) : (n.exit("codeTextSequence"), a(h));\n  }\n  function a(h) {\n    return h === null ? t(h) : h === 96 ? (l = n.enter("codeTextSequence"), i = 0, s(h)) : h === 32 ? (n.enter("space"), n.consume(h), n.exit("space"), a) : L(h) ? (n.enter("lineEnding"), n.consume(h), n.exit("lineEnding"), a) : (n.enter("codeTextData"), c(h));\n  }\n  function c(h) {\n    return h === null || h === 32 || h === 96 || L(h) ? (n.exit("codeTextData"), a(h)) : (n.consume(h), c);\n  }\n  function s(h) {\n    return h === 96 ? (n.consume(h), i++, s) : i === r ? (n.exit("codeTextSequence"), n.exit("codeText"), e(h)) : (l.type = "codeTextData", c(h));\n  }\n}\nfunction Rt(n) {\n  const e = {};\n  let t = -1, r, i, l, o, u, a, c;\n  for (; ++t < n.length; ) {\n    for (; t in e; )\n      t = e[t];\n    if (r = n[t], t && r[1].type === "chunkFlow" && n[t - 1][1].type === "listItemPrefix" && (a = r[1]._tokenizer.events, l = 0, l < a.length && a[l][1].type === "lineEndingBlank" && (l += 2), l < a.length && a[l][1].type === "content"))\n      for (; ++l < a.length && a[l][1].type !== "content"; )\n        a[l][1].type === "chunkText" && (a[l][1]._isInFirstContentOfListItem = !0, l++);\n    if (r[0] === "enter")\n      r[1].contentType && (Object.assign(e, di(n, t)), t = e[t], c = !0);\n    else if (r[1]._container) {\n      for (l = t, i = void 0; l-- && (o = n[l], o[1].type === "lineEnding" || o[1].type === "lineEndingBlank"); )\n        o[0] === "enter" && (i && (n[i][1].type = "lineEndingBlank"), o[1].type = "lineEnding", i = l);\n      i && (r[1].end = Object.assign({}, n[i][1].start), u = n.slice(i, t), u.unshift(r), gn(n, i, t - i + 1, u));\n    }\n  }\n  return !c;\n}\nfunction di(n, e) {\n  const t = n[e][1], r = n[e][2];\n  let i = e - 1;\n  const l = [], o = t._tokenizer || r.parser[t.contentType](t.start), u = o.events, a = [], c = {};\n  let s, h, g = -1, d = t, m = 0, y = 0;\n  const x = [y];\n  for (; d; ) {\n    for (; n[++i][1] !== d; )\n      ;\n    l.push(i), d._tokenizer || (s = r.sliceStream(d), d.next || s.push(null), h && o.defineSkip(d.start), d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(s), d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), h = d, d = d.next;\n  }\n  for (d = t; ++g < u.length; )\n    // Find a void token that includes a break.\n    u[g][0] === "exit" && u[g - 1][0] === "enter" && u[g][1].type === u[g - 1][1].type && u[g][1].start.line !== u[g][1].end.line && (y = g + 1, x.push(y), d._tokenizer = void 0, d.previous = void 0, d = d.next);\n  for (o.events = [], d ? (d._tokenizer = void 0, d.previous = void 0) : x.pop(), g = x.length; g--; ) {\n    const w = u.slice(x[g], x[g + 1]), v = l.pop();\n    a.unshift([v, v + w.length - 1]), gn(n, v, 2, w);\n  }\n  for (g = -1; ++g < a.length; )\n    c[m + a[g][0]] = m + a[g][1], m += a[g][1] - a[g][0] - 1;\n  return c;\n}\nconst gi = {\n  tokenize: ki,\n  resolve: xi\n}, yi = {\n  tokenize: bi,\n  partial: !0\n};\nfunction xi(n) {\n  return Rt(n), n;\n}\nfunction ki(n, e) {\n  let t;\n  return r;\n  function r(u) {\n    return n.enter("content"), t = n.enter("chunkContent", {\n      contentType: "content"\n    }), i(u);\n  }\n  function i(u) {\n    return u === null ? l(u) : L(u) ? n.check(\n      yi,\n      o,\n      l\n    )(u) : (n.consume(u), i);\n  }\n  function l(u) {\n    return n.exit("chunkContent"), n.exit("content"), e(u);\n  }\n  function o(u) {\n    return n.consume(u), n.exit("chunkContent"), t.next = n.enter("chunkContent", {\n      contentType: "content",\n      previous: t\n    }), t = t.next, i;\n  }\n}\nfunction bi(n, e, t) {\n  const r = this;\n  return i;\n  function i(o) {\n    return n.exit("chunkContent"), n.enter("lineEnding"), n.consume(o), n.exit("lineEnding"), U(n, l, "linePrefix");\n  }\n  function l(o) {\n    if (o === null || L(o))\n      return t(o);\n    const u = r.events[r.events.length - 1];\n    return !r.parser.constructs.disable.null.includes("codeIndented") && u && u[1].type === "linePrefix" && u[2].sliceSerialize(u[1], !0).length >= 4 ? e(o) : n.interrupt(r.parser.constructs.flow, t, e)(o);\n  }\n}\nfunction _t(n, e, t, r, i, l, o, u, a) {\n  const c = a || Number.POSITIVE_INFINITY;\n  let s = 0;\n  return h;\n  function h(w) {\n    return w === 60 ? (n.enter(r), n.enter(i), n.enter(l), n.consume(w), n.exit(l), g) : w === null || w === 41 || ye(w) ? t(w) : (n.enter(r), n.enter(o), n.enter(u), n.enter("chunkString", {\n      contentType: "string"\n    }), y(w));\n  }\n  function g(w) {\n    return w === 62 ? (n.enter(l), n.consume(w), n.exit(l), n.exit(i), n.exit(r), e) : (n.enter(u), n.enter("chunkString", {\n      contentType: "string"\n    }), d(w));\n  }\n  function d(w) {\n    return w === 62 ? (n.exit("chunkString"), n.exit(u), g(w)) : w === null || w === 60 || L(w) ? t(w) : (n.consume(w), w === 92 ? m : d);\n  }\n  function m(w) {\n    return w === 60 || w === 62 || w === 92 ? (n.consume(w), d) : d(w);\n  }\n  function y(w) {\n    return w === 40 ? ++s > c ? t(w) : (n.consume(w), y) : w === 41 ? s-- ? (n.consume(w), y) : (n.exit("chunkString"), n.exit(u), n.exit(o), n.exit(r), e(w)) : w === null || sn(w) ? s ? t(w) : (n.exit("chunkString"), n.exit(u), n.exit(o), n.exit(r), e(w)) : ye(w) ? t(w) : (n.consume(w), w === 92 ? x : y);\n  }\n  function x(w) {\n    return w === 40 || w === 41 || w === 92 ? (n.consume(w), y) : y(w);\n  }\n}\nfunction Mt(n, e, t, r, i, l) {\n  const o = this;\n  let u = 0, a;\n  return c;\n  function c(d) {\n    return n.enter(r), n.enter(i), n.consume(d), n.exit(i), n.enter(l), s;\n  }\n  function s(d) {\n    return d === null || d === 91 || d === 93 && !a || /* To do: remove in the future once we\u2019ve switched from\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n     * which doesn\u2019t need this */\n    /* Hidden footnotes hook */\n    /* c8 ignore next 3 */\n    d === 94 && !u && "_hiddenFootnoteSupport" in o.parser.constructs || u > 999 ? t(d) : d === 93 ? (n.exit(l), n.enter(i), n.consume(d), n.exit(i), n.exit(r), e) : L(d) ? (n.enter("lineEnding"), n.consume(d), n.exit("lineEnding"), s) : (n.enter("chunkString", {\n      contentType: "string"\n    }), h(d));\n  }\n  function h(d) {\n    return d === null || d === 91 || d === 93 || L(d) || u++ > 999 ? (n.exit("chunkString"), s(d)) : (n.consume(d), a = a || !G(d), d === 92 ? g : h);\n  }\n  function g(d) {\n    return d === 91 || d === 92 || d === 93 ? (n.consume(d), u++, h) : h(d);\n  }\n}\nfunction Bt(n, e, t, r, i, l) {\n  let o;\n  return u;\n  function u(g) {\n    return n.enter(r), n.enter(i), n.consume(g), n.exit(i), o = g === 40 ? 41 : g, a;\n  }\n  function a(g) {\n    return g === o ? (n.enter(i), n.consume(g), n.exit(i), n.exit(r), e) : (n.enter(l), c(g));\n  }\n  function c(g) {\n    return g === o ? (n.exit(l), a(o)) : g === null ? t(g) : L(g) ? (n.enter("lineEnding"), n.consume(g), n.exit("lineEnding"), U(n, c, "linePrefix")) : (n.enter("chunkString", {\n      contentType: "string"\n    }), s(g));\n  }\n  function s(g) {\n    return g === o || g === null || L(g) ? (n.exit("chunkString"), c(g)) : (n.consume(g), g === 92 ? h : s);\n  }\n  function h(g) {\n    return g === o || g === 92 ? (n.consume(g), s) : s(g);\n  }\n}\nfunction $n(n, e) {\n  let t;\n  return r;\n  function r(i) {\n    return L(i) ? (n.enter("lineEnding"), n.consume(i), n.exit("lineEnding"), t = !0, r) : G(i) ? U(\n      n,\n      r,\n      t ? "linePrefix" : "lineSuffix"\n    )(i) : e(i);\n  }\n}\nfunction Ln(n) {\n  return n.replace(/[\\t\\n\\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();\n}\nconst wi = {\n  name: "definition",\n  tokenize: Ei\n}, Si = {\n  tokenize: Ci,\n  partial: !0\n};\nfunction Ei(n, e, t) {\n  const r = this;\n  let i;\n  return l;\n  function l(a) {\n    return n.enter("definition"), Mt.call(\n      r,\n      n,\n      o,\n      t,\n      "definitionLabel",\n      "definitionLabelMarker",\n      "definitionLabelString"\n    )(a);\n  }\n  function o(a) {\n    return i = Ln(\n      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)\n    ), a === 58 ? (n.enter("definitionMarker"), n.consume(a), n.exit("definitionMarker"), $n(\n      n,\n      _t(\n        n,\n        n.attempt(\n          Si,\n          U(n, u, "whitespace"),\n          U(n, u, "whitespace")\n        ),\n        t,\n        "definitionDestination",\n        "definitionDestinationLiteral",\n        "definitionDestinationLiteralMarker",\n        "definitionDestinationRaw",\n        "definitionDestinationString"\n      )\n    )) : t(a);\n  }\n  function u(a) {\n    return a === null || L(a) ? (n.exit("definition"), r.parser.defined.includes(i) || r.parser.defined.push(i), e(a)) : t(a);\n  }\n}\nfunction Ci(n, e, t) {\n  return r;\n  function r(o) {\n    return sn(o) ? $n(n, i)(o) : t(o);\n  }\n  function i(o) {\n    return o === 34 || o === 39 || o === 40 ? Bt(\n      n,\n      U(n, l, "whitespace"),\n      t,\n      "definitionTitle",\n      "definitionTitleMarker",\n      "definitionTitleString"\n    )(o) : t(o);\n  }\n  function l(o) {\n    return o === null || L(o) ? e(o) : t(o);\n  }\n}\nconst Ai = {\n  name: "hardBreakEscape",\n  tokenize: Pi\n};\nfunction Pi(n, e, t) {\n  return r;\n  function r(l) {\n    return n.enter("hardBreakEscape"), n.enter("escapeMarker"), n.consume(l), i;\n  }\n  function i(l) {\n    return L(l) ? (n.exit("escapeMarker"), n.exit("hardBreakEscape"), e(l)) : t(l);\n  }\n}\nconst Fi = {\n  name: "headingAtx",\n  tokenize: Ii,\n  resolve: Ti\n};\nfunction Ti(n, e) {\n  let t = n.length - 2, r = 3, i, l;\n  return n[r][1].type === "whitespace" && (r += 2), t - 2 > r && n[t][1].type === "whitespace" && (t -= 2), n[t][1].type === "atxHeadingSequence" && (r === t - 1 || t - 4 > r && n[t - 2][1].type === "whitespace") && (t -= r + 1 === t ? 2 : 4), t > r && (i = {\n    type: "atxHeadingText",\n    start: n[r][1].start,\n    end: n[t][1].end\n  }, l = {\n    type: "chunkText",\n    start: n[r][1].start,\n    end: n[t][1].end,\n    // @ts-expect-error Constants are fine to assign.\n    contentType: "text"\n  }, gn(n, r, t - r + 1, [\n    ["enter", i, e],\n    ["enter", l, e],\n    ["exit", l, e],\n    ["exit", i, e]\n  ])), n;\n}\nfunction Ii(n, e, t) {\n  const r = this;\n  let i = 0;\n  return l;\n  function l(s) {\n    return n.enter("atxHeading"), n.enter("atxHeadingSequence"), o(s);\n  }\n  function o(s) {\n    return s === 35 && i++ < 6 ? (n.consume(s), o) : s === null || sn(s) ? (n.exit("atxHeadingSequence"), r.interrupt ? e(s) : u(s)) : t(s);\n  }\n  function u(s) {\n    return s === 35 ? (n.enter("atxHeadingSequence"), a(s)) : s === null || L(s) ? (n.exit("atxHeading"), e(s)) : G(s) ? U(n, u, "whitespace")(s) : (n.enter("atxHeadingText"), c(s));\n  }\n  function a(s) {\n    return s === 35 ? (n.consume(s), a) : (n.exit("atxHeadingSequence"), u(s));\n  }\n  function c(s) {\n    return s === null || s === 35 || sn(s) ? (n.exit("atxHeadingText"), u(s)) : (n.consume(s), c);\n  }\n}\nconst Oi = [\n  "address",\n  "article",\n  "aside",\n  "base",\n  "basefont",\n  "blockquote",\n  "body",\n  "caption",\n  "center",\n  "col",\n  "colgroup",\n  "dd",\n  "details",\n  "dialog",\n  "dir",\n  "div",\n  "dl",\n  "dt",\n  "fieldset",\n  "figcaption",\n  "figure",\n  "footer",\n  "form",\n  "frame",\n  "frameset",\n  "h1",\n  "h2",\n  "h3",\n  "h4",\n  "h5",\n  "h6",\n  "head",\n  "header",\n  "hr",\n  "html",\n  "iframe",\n  "legend",\n  "li",\n  "link",\n  "main",\n  "menu",\n  "menuitem",\n  "nav",\n  "noframes",\n  "ol",\n  "optgroup",\n  "option",\n  "p",\n  "param",\n  "section",\n  "summary",\n  "table",\n  "tbody",\n  "td",\n  "tfoot",\n  "th",\n  "thead",\n  "title",\n  "tr",\n  "track",\n  "ul"\n], rt = ["pre", "script", "style", "textarea"], Li = {\n  name: "htmlFlow",\n  tokenize: zi,\n  resolveTo: vi,\n  concrete: !0\n}, Di = {\n  tokenize: Ri,\n  partial: !0\n};\nfunction vi(n) {\n  let e = n.length;\n  for (; e-- && !(n[e][0] === "enter" && n[e][1].type === "htmlFlow"); )\n    ;\n  return e > 1 && n[e - 2][1].type === "linePrefix" && (n[e][1].start = n[e - 2][1].start, n[e + 1][1].start = n[e - 2][1].start, n.splice(e - 2, 2)), n;\n}\nfunction zi(n, e, t) {\n  const r = this;\n  let i, l, o, u, a;\n  return c;\n  function c(p) {\n    return n.enter("htmlFlow"), n.enter("htmlFlowData"), n.consume(p), s;\n  }\n  function s(p) {\n    return p === 33 ? (n.consume(p), h) : p === 47 ? (n.consume(p), m) : p === 63 ? (n.consume(p), i = 3, r.interrupt ? e : J) : dn(p) ? (n.consume(p), o = String.fromCharCode(p), l = !0, y) : t(p);\n  }\n  function h(p) {\n    return p === 45 ? (n.consume(p), i = 2, g) : p === 91 ? (n.consume(p), i = 5, o = "CDATA[", u = 0, d) : dn(p) ? (n.consume(p), i = 4, r.interrupt ? e : J) : t(p);\n  }\n  function g(p) {\n    return p === 45 ? (n.consume(p), r.interrupt ? e : J) : t(p);\n  }\n  function d(p) {\n    return p === o.charCodeAt(u++) ? (n.consume(p), u === o.length ? r.interrupt ? e : C : d) : t(p);\n  }\n  function m(p) {\n    return dn(p) ? (n.consume(p), o = String.fromCharCode(p), y) : t(p);\n  }\n  function y(p) {\n    return p === null || p === 47 || p === 62 || sn(p) ? p !== 47 && l && rt.includes(o.toLowerCase()) ? (i = 1, r.interrupt ? e(p) : C(p)) : Oi.includes(o.toLowerCase()) ? (i = 6, p === 47 ? (n.consume(p), x) : r.interrupt ? e(p) : C(p)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? t(p) : l ? v(p) : w(p)) : p === 45 || on(p) ? (n.consume(p), o += String.fromCharCode(p), y) : t(p);\n  }\n  function x(p) {\n    return p === 62 ? (n.consume(p), r.interrupt ? e : C) : t(p);\n  }\n  function w(p) {\n    return G(p) ? (n.consume(p), w) : M(p);\n  }\n  function v(p) {\n    return p === 47 ? (n.consume(p), M) : p === 58 || p === 95 || dn(p) ? (n.consume(p), A) : G(p) ? (n.consume(p), v) : M(p);\n  }\n  function A(p) {\n    return p === 45 || p === 46 || p === 58 || p === 95 || on(p) ? (n.consume(p), A) : _(p);\n  }\n  function _(p) {\n    return p === 61 ? (n.consume(p), T) : G(p) ? (n.consume(p), _) : v(p);\n  }\n  function T(p) {\n    return p === null || p === 60 || p === 61 || p === 62 || p === 96 ? t(p) : p === 34 || p === 39 ? (n.consume(p), a = p, b) : G(p) ? (n.consume(p), T) : (a = null, I(p));\n  }\n  function b(p) {\n    return p === null || L(p) ? t(p) : p === a ? (n.consume(p), R) : (n.consume(p), b);\n  }\n  function I(p) {\n    return p === null || p === 34 || p === 39 || p === 60 || p === 61 || p === 62 || p === 96 || sn(p) ? _(p) : (n.consume(p), I);\n  }\n  function R(p) {\n    return p === 47 || p === 62 || G(p) ? v(p) : t(p);\n  }\n  function M(p) {\n    return p === 62 ? (n.consume(p), X) : t(p);\n  }\n  function X(p) {\n    return G(p) ? (n.consume(p), X) : p === null || L(p) ? C(p) : t(p);\n  }\n  function C(p) {\n    return p === 45 && i === 2 ? (n.consume(p), en) : p === 60 && i === 1 ? (n.consume(p), un) : p === 62 && i === 4 ? (n.consume(p), W) : p === 63 && i === 3 ? (n.consume(p), J) : p === 93 && i === 5 ? (n.consume(p), q) : L(p) && (i === 6 || i === 7) ? n.check(\n      Di,\n      W,\n      F\n    )(p) : p === null || L(p) ? F(p) : (n.consume(p), C);\n  }\n  function F(p) {\n    return n.exit("htmlFlowData"), B(p);\n  }\n  function B(p) {\n    return p === null ? f(p) : L(p) ? n.attempt(\n      {\n        tokenize: Z,\n        partial: !0\n      },\n      B,\n      f\n    )(p) : (n.enter("htmlFlowData"), C(p));\n  }\n  function Z(p, kn, Pn) {\n    return bn;\n    function bn(rn) {\n      return p.enter("lineEnding"), p.consume(rn), p.exit("lineEnding"), Y;\n    }\n    function Y(rn) {\n      return r.parser.lazy[r.now().line] ? Pn(rn) : kn(rn);\n    }\n  }\n  function en(p) {\n    return p === 45 ? (n.consume(p), J) : C(p);\n  }\n  function un(p) {\n    return p === 47 ? (n.consume(p), o = "", tn) : C(p);\n  }\n  function tn(p) {\n    return p === 62 && rt.includes(o.toLowerCase()) ? (n.consume(p), W) : dn(p) && o.length < 8 ? (n.consume(p), o += String.fromCharCode(p), tn) : C(p);\n  }\n  function q(p) {\n    return p === 93 ? (n.consume(p), J) : C(p);\n  }\n  function J(p) {\n    return p === 62 ? (n.consume(p), W) : p === 45 && i === 2 ? (n.consume(p), J) : C(p);\n  }\n  function W(p) {\n    return p === null || L(p) ? (n.exit("htmlFlowData"), f(p)) : (n.consume(p), W);\n  }\n  function f(p) {\n    return n.exit("htmlFlow"), e(p);\n  }\n}\nfunction Ri(n, e, t) {\n  return r;\n  function r(i) {\n    return n.exit("htmlFlowData"), n.enter("lineEndingBlank"), n.consume(i), n.exit("lineEndingBlank"), n.attempt(Zn, e, t);\n  }\n}\nconst _i = {\n  name: "htmlText",\n  tokenize: Mi\n};\nfunction Mi(n, e, t) {\n  const r = this;\n  let i, l, o, u;\n  return a;\n  function a(f) {\n    return n.enter("htmlText"), n.enter("htmlTextData"), n.consume(f), c;\n  }\n  function c(f) {\n    return f === 33 ? (n.consume(f), s) : f === 47 ? (n.consume(f), I) : f === 63 ? (n.consume(f), T) : dn(f) ? (n.consume(f), X) : t(f);\n  }\n  function s(f) {\n    return f === 45 ? (n.consume(f), h) : f === 91 ? (n.consume(f), l = "CDATA[", o = 0, x) : dn(f) ? (n.consume(f), _) : t(f);\n  }\n  function h(f) {\n    return f === 45 ? (n.consume(f), g) : t(f);\n  }\n  function g(f) {\n    return f === null || f === 62 ? t(f) : f === 45 ? (n.consume(f), d) : m(f);\n  }\n  function d(f) {\n    return f === null || f === 62 ? t(f) : m(f);\n  }\n  function m(f) {\n    return f === null ? t(f) : f === 45 ? (n.consume(f), y) : L(f) ? (u = m, q(f)) : (n.consume(f), m);\n  }\n  function y(f) {\n    return f === 45 ? (n.consume(f), W) : m(f);\n  }\n  function x(f) {\n    return f === l.charCodeAt(o++) ? (n.consume(f), o === l.length ? w : x) : t(f);\n  }\n  function w(f) {\n    return f === null ? t(f) : f === 93 ? (n.consume(f), v) : L(f) ? (u = w, q(f)) : (n.consume(f), w);\n  }\n  function v(f) {\n    return f === 93 ? (n.consume(f), A) : w(f);\n  }\n  function A(f) {\n    return f === 62 ? W(f) : f === 93 ? (n.consume(f), A) : w(f);\n  }\n  function _(f) {\n    return f === null || f === 62 ? W(f) : L(f) ? (u = _, q(f)) : (n.consume(f), _);\n  }\n  function T(f) {\n    return f === null ? t(f) : f === 63 ? (n.consume(f), b) : L(f) ? (u = T, q(f)) : (n.consume(f), T);\n  }\n  function b(f) {\n    return f === 62 ? W(f) : T(f);\n  }\n  function I(f) {\n    return dn(f) ? (n.consume(f), R) : t(f);\n  }\n  function R(f) {\n    return f === 45 || on(f) ? (n.consume(f), R) : M(f);\n  }\n  function M(f) {\n    return L(f) ? (u = M, q(f)) : G(f) ? (n.consume(f), M) : W(f);\n  }\n  function X(f) {\n    return f === 45 || on(f) ? (n.consume(f), X) : f === 47 || f === 62 || sn(f) ? C(f) : t(f);\n  }\n  function C(f) {\n    return f === 47 ? (n.consume(f), W) : f === 58 || f === 95 || dn(f) ? (n.consume(f), F) : L(f) ? (u = C, q(f)) : G(f) ? (n.consume(f), C) : W(f);\n  }\n  function F(f) {\n    return f === 45 || f === 46 || f === 58 || f === 95 || on(f) ? (n.consume(f), F) : B(f);\n  }\n  function B(f) {\n    return f === 61 ? (n.consume(f), Z) : L(f) ? (u = B, q(f)) : G(f) ? (n.consume(f), B) : C(f);\n  }\n  function Z(f) {\n    return f === null || f === 60 || f === 61 || f === 62 || f === 96 ? t(f) : f === 34 || f === 39 ? (n.consume(f), i = f, en) : L(f) ? (u = Z, q(f)) : G(f) ? (n.consume(f), Z) : (n.consume(f), i = void 0, tn);\n  }\n  function en(f) {\n    return f === i ? (n.consume(f), un) : f === null ? t(f) : L(f) ? (u = en, q(f)) : (n.consume(f), en);\n  }\n  function un(f) {\n    return f === 62 || f === 47 || sn(f) ? C(f) : t(f);\n  }\n  function tn(f) {\n    return f === null || f === 34 || f === 39 || f === 60 || f === 61 || f === 96 ? t(f) : f === 62 || sn(f) ? C(f) : (n.consume(f), tn);\n  }\n  function q(f) {\n    return n.exit("htmlTextData"), n.enter("lineEnding"), n.consume(f), n.exit("lineEnding"), U(\n      n,\n      J,\n      "linePrefix",\n      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4\n    );\n  }\n  function J(f) {\n    return n.enter("htmlTextData"), u(f);\n  }\n  function W(f) {\n    return f === 62 ? (n.consume(f), n.exit("htmlTextData"), n.exit("htmlText"), e) : t(f);\n  }\n}\nconst Pe = {\n  name: "labelEnd",\n  tokenize: Ui,\n  resolveTo: Hi,\n  resolveAll: $i\n}, Bi = {\n  tokenize: Vi\n}, Ni = {\n  tokenize: qi\n}, ji = {\n  tokenize: Wi\n};\nfunction $i(n) {\n  let e = -1, t;\n  for (; ++e < n.length; )\n    t = n[e][1], (t.type === "labelImage" || t.type === "labelLink" || t.type === "labelEnd") && (n.splice(e + 1, t.type === "labelImage" ? 4 : 2), t.type = "data", e++);\n  return n;\n}\nfunction Hi(n, e) {\n  let t = n.length, r = 0, i, l, o, u;\n  for (; t--; )\n    if (i = n[t][1], l) {\n      if (i.type === "link" || i.type === "labelLink" && i._inactive)\n        break;\n      n[t][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);\n    } else if (o) {\n      if (n[t][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (l = t, i.type !== "labelLink")) {\n        r = 2;\n        break;\n      }\n    } else\n      i.type === "labelEnd" && (o = t);\n  const a = {\n    type: n[l][1].type === "labelLink" ? "link" : "image",\n    start: Object.assign({}, n[l][1].start),\n    end: Object.assign({}, n[n.length - 1][1].end)\n  }, c = {\n    type: "label",\n    start: Object.assign({}, n[l][1].start),\n    end: Object.assign({}, n[o][1].end)\n  }, s = {\n    type: "labelText",\n    start: Object.assign({}, n[l + r + 2][1].end),\n    end: Object.assign({}, n[o - 2][1].start)\n  };\n  return u = [\n    ["enter", a, e],\n    ["enter", c, e]\n  ], u = an(u, n.slice(l + 1, l + r + 3)), u = an(u, [["enter", s, e]]), u = an(\n    u,\n    Ce(\n      e.parser.constructs.insideSpan.null,\n      n.slice(l + r + 4, o - 3),\n      e\n    )\n  ), u = an(u, [\n    ["exit", s, e],\n    n[o - 2],\n    n[o - 1],\n    ["exit", c, e]\n  ]), u = an(u, n.slice(o + 1)), u = an(u, [["exit", a, e]]), gn(n, l, n.length, u), n;\n}\nfunction Ui(n, e, t) {\n  const r = this;\n  let i = r.events.length, l, o;\n  for (; i--; )\n    if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) {\n      l = r.events[i][1];\n      break;\n    }\n  return u;\n  function u(s) {\n    return l ? l._inactive ? c(s) : (o = r.parser.defined.includes(\n      Ln(\n        r.sliceSerialize({\n          start: l.end,\n          end: r.now()\n        })\n      )\n    ), n.enter("labelEnd"), n.enter("labelMarker"), n.consume(s), n.exit("labelMarker"), n.exit("labelEnd"), a) : t(s);\n  }\n  function a(s) {\n    return s === 40 ? n.attempt(\n      Bi,\n      e,\n      o ? e : c\n    )(s) : s === 91 ? n.attempt(\n      Ni,\n      e,\n      o ? n.attempt(ji, e, c) : c\n    )(s) : o ? e(s) : c(s);\n  }\n  function c(s) {\n    return l._balanced = !0, t(s);\n  }\n}\nfunction Vi(n, e, t) {\n  return r;\n  function r(a) {\n    return n.enter("resource"), n.enter("resourceMarker"), n.consume(a), n.exit("resourceMarker"), $n(n, i);\n  }\n  function i(a) {\n    return a === 41 ? u(a) : _t(\n      n,\n      l,\n      t,\n      "resourceDestination",\n      "resourceDestinationLiteral",\n      "resourceDestinationLiteralMarker",\n      "resourceDestinationRaw",\n      "resourceDestinationString",\n      32\n    )(a);\n  }\n  function l(a) {\n    return sn(a) ? $n(n, o)(a) : u(a);\n  }\n  function o(a) {\n    return a === 34 || a === 39 || a === 40 ? Bt(\n      n,\n      $n(n, u),\n      t,\n      "resourceTitle",\n      "resourceTitleMarker",\n      "resourceTitleString"\n    )(a) : u(a);\n  }\n  function u(a) {\n    return a === 41 ? (n.enter("resourceMarker"), n.consume(a), n.exit("resourceMarker"), n.exit("resource"), e) : t(a);\n  }\n}\nfunction qi(n, e, t) {\n  const r = this;\n  return i;\n  function i(o) {\n    return Mt.call(\n      r,\n      n,\n      l,\n      t,\n      "reference",\n      "referenceMarker",\n      "referenceString"\n    )(o);\n  }\n  function l(o) {\n    return r.parser.defined.includes(\n      Ln(\n        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)\n      )\n    ) ? e(o) : t(o);\n  }\n}\nfunction Wi(n, e, t) {\n  return r;\n  function r(l) {\n    return n.enter("reference"), n.enter("referenceMarker"), n.consume(l), n.exit("referenceMarker"), i;\n  }\n  function i(l) {\n    return l === 93 ? (n.enter("referenceMarker"), n.consume(l), n.exit("referenceMarker"), n.exit("reference"), e) : t(l);\n  }\n}\nconst Yi = {\n  name: "labelStartImage",\n  tokenize: Qi,\n  resolveAll: Pe.resolveAll\n};\nfunction Qi(n, e, t) {\n  const r = this;\n  return i;\n  function i(u) {\n    return n.enter("labelImage"), n.enter("labelImageMarker"), n.consume(u), n.exit("labelImageMarker"), l;\n  }\n  function l(u) {\n    return u === 91 ? (n.enter("labelMarker"), n.consume(u), n.exit("labelMarker"), n.exit("labelImage"), o) : t(u);\n  }\n  function o(u) {\n    return u === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? t(u) : e(u);\n  }\n}\nconst Xi = {\n  name: "labelStartLink",\n  tokenize: Ki,\n  resolveAll: Pe.resolveAll\n};\nfunction Ki(n, e, t) {\n  const r = this;\n  return i;\n  function i(o) {\n    return n.enter("labelLink"), n.enter("labelMarker"), n.consume(o), n.exit("labelMarker"), n.exit("labelLink"), l;\n  }\n  function l(o) {\n    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? t(o) : e(o);\n  }\n}\nconst ce = {\n  name: "lineEnding",\n  tokenize: Gi\n};\nfunction Gi(n, e) {\n  return t;\n  function t(r) {\n    return n.enter("lineEnding"), n.consume(r), n.exit("lineEnding"), U(n, e, "linePrefix");\n  }\n}\nconst Qn = {\n  name: "thematicBreak",\n  tokenize: Zi\n};\nfunction Zi(n, e, t) {\n  let r = 0, i;\n  return l;\n  function l(a) {\n    return n.enter("thematicBreak"), i = a, o(a);\n  }\n  function o(a) {\n    return a === i ? (n.enter("thematicBreakSequence"), u(a)) : G(a) ? U(n, o, "whitespace")(a) : r < 3 || a !== null && !L(a) ? t(a) : (n.exit("thematicBreak"), e(a));\n  }\n  function u(a) {\n    return a === i ? (n.consume(a), r++, u) : (n.exit("thematicBreakSequence"), o(a));\n  }\n}\nconst nn = {\n  name: "list",\n  tokenize: el,\n  continuation: {\n    tokenize: tl\n  },\n  exit: il\n}, Ji = {\n  tokenize: ll,\n  partial: !0\n}, nl = {\n  tokenize: rl,\n  partial: !0\n};\nfunction el(n, e, t) {\n  const r = this, i = r.events[r.events.length - 1];\n  let l = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, o = 0;\n  return u;\n  function u(d) {\n    const m = r.containerState.type || (d === 42 || d === 43 || d === 45 ? "listUnordered" : "listOrdered");\n    if (m === "listUnordered" ? !r.containerState.marker || d === r.containerState.marker : ge(d)) {\n      if (r.containerState.type || (r.containerState.type = m, n.enter(m, {\n        _container: !0\n      })), m === "listUnordered")\n        return n.enter("listItemPrefix"), d === 42 || d === 45 ? n.check(Qn, t, c)(d) : c(d);\n      if (!r.interrupt || d === 49)\n        return n.enter("listItemPrefix"), n.enter("listItemValue"), a(d);\n    }\n    return t(d);\n  }\n  function a(d) {\n    return ge(d) && ++o < 10 ? (n.consume(d), a) : (!r.interrupt || o < 2) && (r.containerState.marker ? d === r.containerState.marker : d === 41 || d === 46) ? (n.exit("listItemValue"), c(d)) : t(d);\n  }\n  function c(d) {\n    return n.enter("listItemMarker"), n.consume(d), n.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || d, n.check(\n      Zn,\n      // Can\u2019t be empty when interrupting.\n      r.interrupt ? t : s,\n      n.attempt(\n        Ji,\n        g,\n        h\n      )\n    );\n  }\n  function s(d) {\n    return r.containerState.initialBlankLine = !0, l++, g(d);\n  }\n  function h(d) {\n    return G(d) ? (n.enter("listItemPrefixWhitespace"), n.consume(d), n.exit("listItemPrefixWhitespace"), g) : t(d);\n  }\n  function g(d) {\n    return r.containerState.size = l + r.sliceSerialize(n.exit("listItemPrefix"), !0).length, e(d);\n  }\n}\nfunction tl(n, e, t) {\n  const r = this;\n  return r.containerState._closeFlow = void 0, n.check(Zn, i, l);\n  function i(u) {\n    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, U(\n      n,\n      e,\n      "listItemIndent",\n      r.containerState.size + 1\n    )(u);\n  }\n  function l(u) {\n    return r.containerState.furtherBlankLines || !G(u) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(u)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, n.attempt(nl, e, o)(u));\n  }\n  function o(u) {\n    return r.containerState._closeFlow = !0, r.interrupt = void 0, U(\n      n,\n      n.attempt(nn, e, t),\n      "linePrefix",\n      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4\n    )(u);\n  }\n}\nfunction rl(n, e, t) {\n  const r = this;\n  return U(\n    n,\n    i,\n    "listItemIndent",\n    r.containerState.size + 1\n  );\n  function i(l) {\n    const o = r.events[r.events.length - 1];\n    return o && o[1].type === "listItemIndent" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? e(l) : t(l);\n  }\n}\nfunction il(n) {\n  n.exit(this.containerState.type);\n}\nfunction ll(n, e, t) {\n  const r = this;\n  return U(\n    n,\n    i,\n    "listItemPrefixWhitespace",\n    r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4 + 1\n  );\n  function i(l) {\n    const o = r.events[r.events.length - 1];\n    return !G(l) && o && o[1].type === "listItemPrefixWhitespace" ? e(l) : t(l);\n  }\n}\nconst it = {\n  name: "setextUnderline",\n  tokenize: ul,\n  resolveTo: ol\n};\nfunction ol(n, e) {\n  let t = n.length, r, i, l;\n  for (; t--; )\n    if (n[t][0] === "enter") {\n      if (n[t][1].type === "content") {\n        r = t;\n        break;\n      }\n      n[t][1].type === "paragraph" && (i = t);\n    } else\n      n[t][1].type === "content" && n.splice(t, 1), !l && n[t][1].type === "definition" && (l = t);\n  const o = {\n    type: "setextHeading",\n    start: Object.assign({}, n[i][1].start),\n    end: Object.assign({}, n[n.length - 1][1].end)\n  };\n  return n[i][1].type = "setextHeadingText", l ? (n.splice(i, 0, ["enter", o, e]), n.splice(l + 1, 0, ["exit", n[r][1], e]), n[r][1].end = Object.assign({}, n[l][1].end)) : n[r][1] = o, n.push(["exit", o, e]), n;\n}\nfunction ul(n, e, t) {\n  const r = this;\n  let i = r.events.length, l, o;\n  for (; i--; )\n    if (r.events[i][1].type !== "lineEnding" && r.events[i][1].type !== "linePrefix" && r.events[i][1].type !== "content") {\n      o = r.events[i][1].type === "paragraph";\n      break;\n    }\n  return u;\n  function u(s) {\n    return !r.parser.lazy[r.now().line] && (r.interrupt || o) ? (n.enter("setextHeadingLine"), n.enter("setextHeadingLineSequence"), l = s, a(s)) : t(s);\n  }\n  function a(s) {\n    return s === l ? (n.consume(s), a) : (n.exit("setextHeadingLineSequence"), U(n, c, "lineSuffix")(s));\n  }\n  function c(s) {\n    return s === null || L(s) ? (n.exit("setextHeadingLine"), e(s)) : t(s);\n  }\n}\nconst al = {\n  tokenize: sl\n};\nfunction sl(n) {\n  const e = this, t = n.attempt(\n    // Try to parse a blank line.\n    Zn,\n    r,\n    // Try to parse initial flow (essentially, only code).\n    n.attempt(\n      this.parser.constructs.flowInitial,\n      i,\n      U(\n        n,\n        n.attempt(\n          this.parser.constructs.flow,\n          i,\n          n.attempt(gi, i)\n        ),\n        "linePrefix"\n      )\n    )\n  );\n  return t;\n  function r(l) {\n    if (l === null) {\n      n.consume(l);\n      return;\n    }\n    return n.enter("lineEndingBlank"), n.consume(l), n.exit("lineEndingBlank"), e.currentConstruct = void 0, t;\n  }\n  function i(l) {\n    if (l === null) {\n      n.consume(l);\n      return;\n    }\n    return n.enter("lineEnding"), n.consume(l), n.exit("lineEnding"), e.currentConstruct = void 0, t;\n  }\n}\nconst cl = {\n  resolveAll: jt()\n}, pl = Nt("string"), fl = Nt("text");\nfunction Nt(n) {\n  return {\n    tokenize: e,\n    resolveAll: jt(\n      n === "text" ? hl : void 0\n    )\n  };\n  function e(t) {\n    const r = this, i = this.parser.constructs[n], l = t.attempt(i, o, u);\n    return o;\n    function o(s) {\n      return c(s) ? l(s) : u(s);\n    }\n    function u(s) {\n      if (s === null) {\n        t.consume(s);\n        return;\n      }\n      return t.enter("data"), t.consume(s), a;\n    }\n    function a(s) {\n      return c(s) ? (t.exit("data"), l(s)) : (t.consume(s), a);\n    }\n    function c(s) {\n      if (s === null)\n        return !0;\n      const h = i[s];\n      let g = -1;\n      if (h)\n        for (; ++g < h.length; ) {\n          const d = h[g];\n          if (!d.previous || d.previous.call(r, r.previous))\n            return !0;\n        }\n      return !1;\n    }\n  }\n}\nfunction jt(n) {\n  return e;\n  function e(t, r) {\n    let i = -1, l;\n    for (; ++i <= t.length; )\n      l === void 0 ? t[i] && t[i][1].type === "data" && (l = i, i++) : (!t[i] || t[i][1].type !== "data") && (i !== l + 2 && (t[l][1].end = t[i - 1][1].end, t.splice(l + 2, i - l - 2), i = l + 2), l = void 0);\n    return n ? n(t, r) : t;\n  }\n}\nfunction hl(n, e) {\n  let t = 0;\n  for (; ++t <= n.length; )\n    if ((t === n.length || n[t][1].type === "lineEnding") && n[t - 1][1].type === "data") {\n      const r = n[t - 1][1], i = e.sliceStream(r);\n      let l = i.length, o = -1, u = 0, a;\n      for (; l--; ) {\n        const c = i[l];\n        if (typeof c == "string") {\n          for (o = c.length; c.charCodeAt(o - 1) === 32; )\n            u++, o--;\n          if (o)\n            break;\n          o = -1;\n        } else if (c === -2)\n          a = !0, u++;\n        else if (c !== -1) {\n          l++;\n          break;\n        }\n      }\n      if (u) {\n        const c = {\n          type: t === n.length || a || u < 2 ? "lineSuffix" : "hardBreakTrailing",\n          start: {\n            line: r.end.line,\n            column: r.end.column - u,\n            offset: r.end.offset - u,\n            _index: r.start._index + l,\n            _bufferIndex: l ? o : r.start._bufferIndex + o\n          },\n          end: Object.assign({}, r.end)\n        };\n        r.end = Object.assign({}, c.start), r.start.offset === r.end.offset ? Object.assign(r, c) : (n.splice(\n          t,\n          0,\n          ["enter", c, e],\n          ["exit", c, e]\n        ), t += 2);\n      }\n      t++;\n    }\n  return n;\n}\nfunction ml(n, e, t) {\n  let r = Object.assign(\n    t ? Object.assign({}, t) : {\n      line: 1,\n      column: 1,\n      offset: 0\n    },\n    {\n      _index: 0,\n      _bufferIndex: -1\n    }\n  );\n  const i = {}, l = [];\n  let o = [], u = [];\n  const a = {\n    consume: v,\n    enter: A,\n    exit: _,\n    attempt: I(T),\n    check: I(b),\n    interrupt: I(b, {\n      interrupt: !0\n    })\n  }, c = {\n    previous: null,\n    code: null,\n    containerState: {},\n    events: [],\n    parser: n,\n    sliceStream: d,\n    sliceSerialize: g,\n    now: m,\n    defineSkip: y,\n    write: h\n  };\n  let s = e.tokenize.call(c, a);\n  return e.resolveAll && l.push(e), c;\n  function h(C) {\n    return o = an(o, C), x(), o[o.length - 1] !== null ? [] : (R(e, 0), c.events = Ce(l, c.events, c), c.events);\n  }\n  function g(C, F) {\n    return gl(d(C), F);\n  }\n  function d(C) {\n    return dl(o, C);\n  }\n  function m() {\n    return Object.assign({}, r);\n  }\n  function y(C) {\n    i[C.line] = C.column, X();\n  }\n  function x() {\n    let C;\n    for (; r._index < o.length; ) {\n      const F = o[r._index];\n      if (typeof F == "string")\n        for (C = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === C && r._bufferIndex < F.length; )\n          w(F.charCodeAt(r._bufferIndex));\n      else\n        w(F);\n    }\n  }\n  function w(C) {\n    s = s(C);\n  }\n  function v(C) {\n    L(C) ? (r.line++, r.column = 1, r.offset += C === -3 ? 2 : 1, X()) : C !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === o[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = C;\n  }\n  function A(C, F) {\n    const B = F || {};\n    return B.type = C, B.start = m(), c.events.push(["enter", B, c]), u.push(B), B;\n  }\n  function _(C) {\n    const F = u.pop();\n    return F.end = m(), c.events.push(["exit", F, c]), F;\n  }\n  function T(C, F) {\n    R(C, F.from);\n  }\n  function b(C, F) {\n    F.restore();\n  }\n  function I(C, F) {\n    return B;\n    function B(Z, en, un) {\n      let tn, q, J, W;\n      return Array.isArray(Z) ? (\n        /* c8 ignore next 1 */\n        p(Z)\n      ) : "tokenize" in Z ? p([Z]) : f(Z);\n      function f(Y) {\n        return rn;\n        function rn(hn) {\n          const wn = hn !== null && Y[hn], Sn = hn !== null && Y.null, Rn = [\n            // To do: add more extension tests.\n            /* c8 ignore next 2 */\n            ...Array.isArray(wn) ? wn : wn ? [wn] : [],\n            ...Array.isArray(Sn) ? Sn : Sn ? [Sn] : []\n          ];\n          return p(Rn)(hn);\n        }\n      }\n      function p(Y) {\n        return tn = Y, q = 0, Y.length === 0 ? un : kn(Y[q]);\n      }\n      function kn(Y) {\n        return rn;\n        function rn(hn) {\n          return W = M(), J = Y, Y.partial || (c.currentConstruct = Y), Y.name && c.parser.constructs.disable.null.includes(Y.name) ? bn() : Y.tokenize.call(\n            // If we do have fields, create an object w/ `context` as its\n            // prototype.\n            // This allows a \u201clive binding\u201d, which is needed for `interrupt`.\n            F ? Object.assign(Object.create(c), F) : c,\n            a,\n            Pn,\n            bn\n          )(hn);\n        }\n      }\n      function Pn(Y) {\n        return C(J, W), en;\n      }\n      function bn(Y) {\n        return W.restore(), ++q < tn.length ? kn(tn[q]) : un;\n      }\n    }\n  }\n  function R(C, F) {\n    C.resolveAll && !l.includes(C) && l.push(C), C.resolve && gn(\n      c.events,\n      F,\n      c.events.length - F,\n      C.resolve(c.events.slice(F), c)\n    ), C.resolveTo && (c.events = C.resolveTo(c.events, c));\n  }\n  function M() {\n    const C = m(), F = c.previous, B = c.currentConstruct, Z = c.events.length, en = Array.from(u);\n    return {\n      restore: un,\n      from: Z\n    };\n    function un() {\n      r = C, c.previous = F, c.currentConstruct = B, c.events.length = Z, u = en, X();\n    }\n  }\n  function X() {\n    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);\n  }\n}\nfunction dl(n, e) {\n  const t = e.start._index, r = e.start._bufferIndex, i = e.end._index, l = e.end._bufferIndex;\n  let o;\n  return t === i ? o = [n[t].slice(r, l)] : (o = n.slice(t, i), r > -1 && (o[0] = o[0].slice(r)), l > 0 && o.push(n[i].slice(0, l))), o;\n}\nfunction gl(n, e) {\n  let t = -1;\n  const r = [];\n  let i;\n  for (; ++t < n.length; ) {\n    const l = n[t];\n    let o;\n    if (typeof l == "string")\n      o = l;\n    else\n      switch (l) {\n        case -5: {\n          o = "\\r";\n          break;\n        }\n        case -4: {\n          o = `\n`;\n          break;\n        }\n        case -3: {\n          o = `\\r\n`;\n          break;\n        }\n        case -2: {\n          o = e ? " " : "\t";\n          break;\n        }\n        case -1: {\n          if (!e && i)\n            continue;\n          o = " ";\n          break;\n        }\n        default:\n          o = String.fromCharCode(l);\n      }\n    i = l === -2, r.push(o);\n  }\n  return r.join("");\n}\nconst yl = {\n  [42]: nn,\n  [43]: nn,\n  [45]: nn,\n  [48]: nn,\n  [49]: nn,\n  [50]: nn,\n  [51]: nn,\n  [52]: nn,\n  [53]: nn,\n  [54]: nn,\n  [55]: nn,\n  [56]: nn,\n  [57]: nn,\n  [62]: Dt\n}, xl = {\n  [91]: wi\n}, kl = {\n  [-2]: se,\n  [-1]: se,\n  [32]: se\n}, bl = {\n  [35]: Fi,\n  [42]: Qn,\n  [45]: [it, Qn],\n  [60]: Li,\n  [61]: it,\n  [95]: Qn,\n  [96]: tt,\n  [126]: tt\n}, wl = {\n  [38]: zt,\n  [92]: vt\n}, Sl = {\n  [-5]: ce,\n  [-4]: ce,\n  [-3]: ce,\n  [33]: Yi,\n  [38]: zt,\n  [42]: xe,\n  [60]: [Jr, _i],\n  [91]: Xi,\n  [92]: [Ai, vt],\n  [93]: Pe,\n  [95]: xe,\n  [96]: pi\n}, El = {\n  null: [xe, cl]\n}, Cl = {\n  null: [42, 95]\n}, Al = {\n  null: []\n}, Pl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  attentionMarkers: Cl,\n  contentInitial: xl,\n  disable: Al,\n  document: yl,\n  flow: bl,\n  flowInitial: kl,\n  insideSpan: El,\n  string: wl,\n  text: Sl\n}, Symbol.toStringTag, { value: "Module" }));\nfunction Fl(n = {}) {\n  const e = Br(\n    // @ts-expect-error Same as above.\n    [Pl].concat(n.extensions || [])\n  ), t = {\n    defined: [],\n    lazy: {},\n    constructs: e,\n    content: r(Wr),\n    document: r(Qr),\n    flow: r(al),\n    string: r(pl),\n    text: r(fl)\n  };\n  return t;\n  function r(i) {\n    return l;\n    function l(o) {\n      return ml(t, i, o);\n    }\n  }\n}\nconst lt = /[\\0\\t\\n\\r]/g;\nfunction Tl() {\n  let n = 1, e = "", t = !0, r;\n  return i;\n  function i(l, o, u) {\n    const a = [];\n    let c, s, h, g, d;\n    for (l = e + l.toString(o), h = 0, e = "", t && (l.charCodeAt(0) === 65279 && h++, t = void 0); h < l.length; ) {\n      if (lt.lastIndex = h, c = lt.exec(l), g = c && c.index !== void 0 ? c.index : l.length, d = l.charCodeAt(g), !c) {\n        e = l.slice(h);\n        break;\n      }\n      if (d === 10 && h === g && r)\n        a.push(-3), r = void 0;\n      else\n        switch (r && (a.push(-5), r = void 0), h < g && (a.push(l.slice(h, g)), n += g - h), d) {\n          case 0: {\n            a.push(65533), n++;\n            break;\n          }\n          case 9: {\n            for (s = Math.ceil(n / 4) * 4, a.push(-2); n++ < s; )\n              a.push(-1);\n            break;\n          }\n          case 10: {\n            a.push(-4), n = 1;\n            break;\n          }\n          default:\n            r = !0, n = 1;\n        }\n      h = g + 1;\n    }\n    return u && (r && a.push(-5), e && a.push(e), a.push(null)), a;\n  }\n}\nfunction Il(n) {\n  for (; !Rt(n); )\n    ;\n  return n;\n}\nfunction $t(n, e) {\n  const t = Number.parseInt(n, e);\n  return (\n    // C0 except for HT, LF, FF, CR, space\n    t < 9 || t === 11 || t > 13 && t < 32 || // Control character (DEL) of the basic block and C1 controls.\n    t > 126 && t < 160 || // Lone high surrogates and low surrogates.\n    t > 55295 && t < 57344 || // Noncharacters.\n    t > 64975 && t < 65008 || (t & 65535) === 65535 || (t & 65535) === 65534 || // Out of range\n    t > 1114111 ? "\ufffd" : String.fromCharCode(t)\n  );\n}\nconst Ol = /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi;\nfunction Ll(n) {\n  return n.replace(Ol, Dl);\n}\nfunction Dl(n, e, t) {\n  if (e)\n    return e;\n  if (t.charCodeAt(0) === 35) {\n    const i = t.charCodeAt(1), l = i === 120 || i === 88;\n    return $t(t.slice(l ? 2 : 1), l ? 16 : 10);\n  }\n  return Ae(t) || n;\n}\nfunction Xn(n) {\n  return !n || typeof n != "object" ? "" : "position" in n || "type" in n ? ot(n.position) : "start" in n || "end" in n ? ot(n) : "line" in n || "column" in n ? ke(n) : "";\n}\nfunction ke(n) {\n  return ut(n && n.line) + ":" + ut(n && n.column);\n}\nfunction ot(n) {\n  return ke(n && n.start) + "-" + ke(n && n.end);\n}\nfunction ut(n) {\n  return n && typeof n == "number" ? n : 1;\n}\nconst Ht = {}.hasOwnProperty, vl = (\n  /**\n   * @type {(\n   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &\n   *   ((value: Value, options?: Options | null | undefined) => Root)\n   * )}\n   */\n  /**\n   * @param {Value} value\n   * @param {Encoding | Options | null | undefined} [encoding]\n   * @param {Options | null | undefined} [options]\n   * @returns {Root}\n   */\n  function(n, e, t) {\n    return typeof e != "string" && (t = e, e = void 0), zl(t)(\n      Il(\n        // @ts-expect-error: micromark types need to accept `null`.\n        Fl(t).document().write(Tl()(n, e, !0))\n      )\n    );\n  }\n);\nfunction zl(n) {\n  const e = {\n    transforms: [],\n    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],\n    enter: {\n      autolink: u(De),\n      autolinkProtocol: C,\n      autolinkEmail: C,\n      atxHeading: u(Fn),\n      blockQuote: u(Rn),\n      characterEscape: C,\n      characterReference: C,\n      codeFenced: u(Vn),\n      codeFencedFenceInfo: a,\n      codeFencedFenceMeta: a,\n      codeIndented: u(Vn, a),\n      codeText: u(ee, a),\n      codeTextData: C,\n      data: C,\n      codeFlowValue: C,\n      definition: u(P),\n      definitionDestinationString: a,\n      definitionLabelString: a,\n      definitionTitleString: a,\n      emphasis: u(_n),\n      hardBreakEscape: u(Mn),\n      hardBreakTrailing: u(Mn),\n      htmlFlow: u(Le, a),\n      htmlFlowData: C,\n      htmlText: u(Le, a),\n      htmlTextData: C,\n      image: u(sr),\n      label: a,\n      link: u(De),\n      listItem: u(cr),\n      listItemValue: m,\n      listOrdered: u(ve, d),\n      listUnordered: u(ve),\n      paragraph: u(pr),\n      reference: bn,\n      referenceString: a,\n      resourceDestinationString: a,\n      resourceTitleString: a,\n      setextHeading: u(Fn),\n      strong: u(fr),\n      thematicBreak: u(mr)\n    },\n    exit: {\n      atxHeading: s(),\n      atxHeadingSequence: I,\n      autolink: s(),\n      autolinkEmail: Sn,\n      autolinkProtocol: wn,\n      blockQuote: s(),\n      characterEscapeValue: F,\n      characterReferenceMarkerHexadecimal: rn,\n      characterReferenceMarkerNumeric: rn,\n      characterReferenceValue: hn,\n      codeFenced: s(v),\n      codeFencedFence: w,\n      codeFencedFenceInfo: y,\n      codeFencedFenceMeta: x,\n      codeFlowValue: F,\n      codeIndented: s(A),\n      codeText: s(tn),\n      codeTextData: F,\n      data: F,\n      definition: s(),\n      definitionDestinationString: b,\n      definitionLabelString: _,\n      definitionTitleString: T,\n      emphasis: s(),\n      hardBreakEscape: s(Z),\n      hardBreakTrailing: s(Z),\n      htmlFlow: s(en),\n      htmlFlowData: F,\n      htmlText: s(un),\n      htmlTextData: F,\n      image: s(J),\n      label: f,\n      labelText: W,\n      lineEnding: B,\n      link: s(q),\n      listItem: s(),\n      listOrdered: s(),\n      listUnordered: s(),\n      paragraph: s(),\n      referenceString: Y,\n      resourceDestinationString: p,\n      resourceTitleString: kn,\n      resource: Pn,\n      setextHeading: s(X),\n      setextHeadingLineSequence: M,\n      setextHeadingText: R,\n      strong: s(),\n      thematicBreak: s()\n    }\n  };\n  Ut(e, (n || {}).mdastExtensions || []);\n  const t = {};\n  return r;\n  function r(k) {\n    let E = {\n      type: "root",\n      children: []\n    };\n    const O = {\n      stack: [E],\n      tokenStack: [],\n      config: e,\n      enter: c,\n      exit: h,\n      buffer: a,\n      resume: g,\n      setData: l,\n      getData: o\n    }, $ = [];\n    let H = -1;\n    for (; ++H < k.length; )\n      if (k[H][1].type === "listOrdered" || k[H][1].type === "listUnordered")\n        if (k[H][0] === "enter")\n          $.push(H);\n        else {\n          const fn = $.pop();\n          H = i(k, fn, H);\n        }\n    for (H = -1; ++H < k.length; ) {\n      const fn = e[k[H][0]];\n      Ht.call(fn, k[H][1].type) && fn[k[H][1].type].call(\n        Object.assign(\n          {\n            sliceSerialize: k[H][2].sliceSerialize\n          },\n          O\n        ),\n        k[H][1]\n      );\n    }\n    if (O.tokenStack.length > 0) {\n      const fn = O.tokenStack[O.tokenStack.length - 1];\n      (fn[1] || at).call(O, void 0, fn[0]);\n    }\n    for (E.position = {\n      start: Cn(\n        k.length > 0 ? k[0][1].start : {\n          line: 1,\n          column: 1,\n          offset: 0\n        }\n      ),\n      end: Cn(\n        k.length > 0 ? k[k.length - 2][1].end : {\n          line: 1,\n          column: 1,\n          offset: 0\n        }\n      )\n    }, H = -1; ++H < e.transforms.length; )\n      E = e.transforms[H](E) || E;\n    return E;\n  }\n  function i(k, E, O) {\n    let $ = E - 1, H = -1, fn = !1, En, yn, Bn, Nn;\n    for (; ++$ <= O; ) {\n      const Q = k[$];\n      if (Q[1].type === "listUnordered" || Q[1].type === "listOrdered" || Q[1].type === "blockQuote" ? (Q[0] === "enter" ? H++ : H--, Nn = void 0) : Q[1].type === "lineEndingBlank" ? Q[0] === "enter" && (En && !Nn && !H && !Bn && (Bn = $), Nn = void 0) : Q[1].type === "linePrefix" || Q[1].type === "listItemValue" || Q[1].type === "listItemMarker" || Q[1].type === "listItemPrefix" || Q[1].type === "listItemPrefixWhitespace" || (Nn = void 0), !H && Q[0] === "enter" && Q[1].type === "listItemPrefix" || H === -1 && Q[0] === "exit" && (Q[1].type === "listUnordered" || Q[1].type === "listOrdered")) {\n        if (En) {\n          let te = $;\n          for (yn = void 0; te--; ) {\n            const xn = k[te];\n            if (xn[1].type === "lineEnding" || xn[1].type === "lineEndingBlank") {\n              if (xn[0] === "exit")\n                continue;\n              yn && (k[yn][1].type = "lineEndingBlank", fn = !0), xn[1].type = "lineEnding", yn = te;\n            } else if (!(xn[1].type === "linePrefix" || xn[1].type === "blockQuotePrefix" || xn[1].type === "blockQuotePrefixWhitespace" || xn[1].type === "blockQuoteMarker" || xn[1].type === "listItemIndent"))\n              break;\n          }\n          Bn && (!yn || Bn < yn) && (En._spread = !0), En.end = Object.assign(\n            {},\n            yn ? k[yn][1].start : Q[1].end\n          ), k.splice(yn || $, 0, ["exit", En, Q[2]]), $++, O++;\n        }\n        Q[1].type === "listItemPrefix" && (En = {\n          type: "listItem",\n          // @ts-expect-error Patched\n          _spread: !1,\n          start: Object.assign({}, Q[1].start)\n        }, k.splice($, 0, ["enter", En, Q[2]]), $++, O++, Bn = void 0, Nn = !0);\n      }\n    }\n    return k[E][1]._spread = fn, O;\n  }\n  function l(k, E) {\n    t[k] = E;\n  }\n  function o(k) {\n    return t[k];\n  }\n  function u(k, E) {\n    return O;\n    function O($) {\n      c.call(this, k($), $), E && E.call(this, $);\n    }\n  }\n  function a() {\n    this.stack.push({\n      type: "fragment",\n      children: []\n    });\n  }\n  function c(k, E, O) {\n    return this.stack[this.stack.length - 1].children.push(k), this.stack.push(k), this.tokenStack.push([E, O]), k.position = {\n      start: Cn(E.start)\n    }, k;\n  }\n  function s(k) {\n    return E;\n    function E(O) {\n      k && k.call(this, O), h.call(this, O);\n    }\n  }\n  function h(k, E) {\n    const O = this.stack.pop(), $ = this.tokenStack.pop();\n    if ($)\n      $[0].type !== k.type && (E ? E.call(this, k, $[0]) : ($[1] || at).call(this, k, $[0]));\n    else\n      throw new Error(\n        "Cannot close `" + k.type + "` (" + Xn({\n          start: k.start,\n          end: k.end\n        }) + "): it\u2019s not open"\n      );\n    return O.position.end = Cn(k.end), O;\n  }\n  function g() {\n    return _r(this.stack.pop());\n  }\n  function d() {\n    l("expectingFirstListItemValue", !0);\n  }\n  function m(k) {\n    if (o("expectingFirstListItemValue")) {\n      const E = this.stack[this.stack.length - 2];\n      E.start = Number.parseInt(this.sliceSerialize(k), 10), l("expectingFirstListItemValue");\n    }\n  }\n  function y() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.lang = k;\n  }\n  function x() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.meta = k;\n  }\n  function w() {\n    o("flowCodeInside") || (this.buffer(), l("flowCodeInside", !0));\n  }\n  function v() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.value = k.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, ""), l("flowCodeInside");\n  }\n  function A() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.value = k.replace(/(\\r?\\n|\\r)$/g, "");\n  }\n  function _(k) {\n    const E = this.resume(), O = this.stack[this.stack.length - 1];\n    O.label = E, O.identifier = Ln(\n      this.sliceSerialize(k)\n    ).toLowerCase();\n  }\n  function T() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.title = k;\n  }\n  function b() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.url = k;\n  }\n  function I(k) {\n    const E = this.stack[this.stack.length - 1];\n    if (!E.depth) {\n      const O = this.sliceSerialize(k).length;\n      E.depth = O;\n    }\n  }\n  function R() {\n    l("setextHeadingSlurpLineEnding", !0);\n  }\n  function M(k) {\n    const E = this.stack[this.stack.length - 1];\n    E.depth = this.sliceSerialize(k).charCodeAt(0) === 61 ? 1 : 2;\n  }\n  function X() {\n    l("setextHeadingSlurpLineEnding");\n  }\n  function C(k) {\n    const E = this.stack[this.stack.length - 1];\n    let O = E.children[E.children.length - 1];\n    (!O || O.type !== "text") && (O = hr(), O.position = {\n      start: Cn(k.start)\n    }, E.children.push(O)), this.stack.push(O);\n  }\n  function F(k) {\n    const E = this.stack.pop();\n    E.value += this.sliceSerialize(k), E.position.end = Cn(k.end);\n  }\n  function B(k) {\n    const E = this.stack[this.stack.length - 1];\n    if (o("atHardBreak")) {\n      const O = E.children[E.children.length - 1];\n      O.position.end = Cn(k.end), l("atHardBreak");\n      return;\n    }\n    !o("setextHeadingSlurpLineEnding") && e.canContainEols.includes(E.type) && (C.call(this, k), F.call(this, k));\n  }\n  function Z() {\n    l("atHardBreak", !0);\n  }\n  function en() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.value = k;\n  }\n  function un() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.value = k;\n  }\n  function tn() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.value = k;\n  }\n  function q() {\n    const k = this.stack[this.stack.length - 1];\n    if (o("inReference")) {\n      const E = o("referenceType") || "shortcut";\n      k.type += "Reference", k.referenceType = E, delete k.url, delete k.title;\n    } else\n      delete k.identifier, delete k.label;\n    l("referenceType");\n  }\n  function J() {\n    const k = this.stack[this.stack.length - 1];\n    if (o("inReference")) {\n      const E = o("referenceType") || "shortcut";\n      k.type += "Reference", k.referenceType = E, delete k.url, delete k.title;\n    } else\n      delete k.identifier, delete k.label;\n    l("referenceType");\n  }\n  function W(k) {\n    const E = this.sliceSerialize(k), O = this.stack[this.stack.length - 2];\n    O.label = Ll(E), O.identifier = Ln(E).toLowerCase();\n  }\n  function f() {\n    const k = this.stack[this.stack.length - 1], E = this.resume(), O = this.stack[this.stack.length - 1];\n    if (l("inReference", !0), O.type === "link") {\n      const $ = k.children;\n      O.children = $;\n    } else\n      O.alt = E;\n  }\n  function p() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.url = k;\n  }\n  function kn() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.title = k;\n  }\n  function Pn() {\n    l("inReference");\n  }\n  function bn() {\n    l("referenceType", "collapsed");\n  }\n  function Y(k) {\n    const E = this.resume(), O = this.stack[this.stack.length - 1];\n    O.label = E, O.identifier = Ln(\n      this.sliceSerialize(k)\n    ).toLowerCase(), l("referenceType", "full");\n  }\n  function rn(k) {\n    l("characterReferenceType", k.type);\n  }\n  function hn(k) {\n    const E = this.sliceSerialize(k), O = o("characterReferenceType");\n    let $;\n    O ? ($ = $t(\n      E,\n      O === "characterReferenceMarkerNumeric" ? 10 : 16\n    ), l("characterReferenceType")) : $ = Ae(E);\n    const H = this.stack.pop();\n    H.value += $, H.position.end = Cn(k.end);\n  }\n  function wn(k) {\n    F.call(this, k);\n    const E = this.stack[this.stack.length - 1];\n    E.url = this.sliceSerialize(k);\n  }\n  function Sn(k) {\n    F.call(this, k);\n    const E = this.stack[this.stack.length - 1];\n    E.url = "mailto:" + this.sliceSerialize(k);\n  }\n  function Rn() {\n    return {\n      type: "blockquote",\n      children: []\n    };\n  }\n  function Vn() {\n    return {\n      type: "code",\n      lang: null,\n      meta: null,\n      value: ""\n    };\n  }\n  function ee() {\n    return {\n      type: "inlineCode",\n      value: ""\n    };\n  }\n  function P() {\n    return {\n      type: "definition",\n      identifier: "",\n      label: null,\n      title: null,\n      url: ""\n    };\n  }\n  function _n() {\n    return {\n      type: "emphasis",\n      children: []\n    };\n  }\n  function Fn() {\n    return {\n      type: "heading",\n      depth: void 0,\n      children: []\n    };\n  }\n  function Mn() {\n    return {\n      type: "break"\n    };\n  }\n  function Le() {\n    return {\n      type: "html",\n      value: ""\n    };\n  }\n  function sr() {\n    return {\n      type: "image",\n      title: null,\n      url: "",\n      alt: null\n    };\n  }\n  function De() {\n    return {\n      type: "link",\n      title: null,\n      url: "",\n      children: []\n    };\n  }\n  function ve(k) {\n    return {\n      type: "list",\n      ordered: k.type === "listOrdered",\n      start: null,\n      // @ts-expect-error Patched.\n      spread: k._spread,\n      children: []\n    };\n  }\n  function cr(k) {\n    return {\n      type: "listItem",\n      // @ts-expect-error Patched.\n      spread: k._spread,\n      checked: null,\n      children: []\n    };\n  }\n  function pr() {\n    return {\n      type: "paragraph",\n      children: []\n    };\n  }\n  function fr() {\n    return {\n      type: "strong",\n      children: []\n    };\n  }\n  function hr() {\n    return {\n      type: "text",\n      value: ""\n    };\n  }\n  function mr() {\n    return {\n      type: "thematicBreak"\n    };\n  }\n}\nfunction Cn(n) {\n  return {\n    line: n.line,\n    column: n.column,\n    offset: n.offset\n  };\n}\nfunction Ut(n, e) {\n  let t = -1;\n  for (; ++t < e.length; ) {\n    const r = e[t];\n    Array.isArray(r) ? Ut(n, r) : Rl(n, r);\n  }\n}\nfunction Rl(n, e) {\n  let t;\n  for (t in e)\n    if (Ht.call(e, t)) {\n      if (t === "canContainEols") {\n        const r = e[t];\n        r && n[t].push(...r);\n      } else if (t === "transforms") {\n        const r = e[t];\n        r && n[t].push(...r);\n      } else if (t === "enter" || t === "exit") {\n        const r = e[t];\n        r && Object.assign(n[t], r);\n      }\n    }\n}\nfunction at(n, e) {\n  throw n ? new Error(\n    "Cannot close `" + n.type + "` (" + Xn({\n      start: n.start,\n      end: n.end\n    }) + "): a different token (`" + e.type + "`, " + Xn({\n      start: e.start,\n      end: e.end\n    }) + ") is open"\n  ) : new Error(\n    "Cannot close document, a token (`" + e.type + "`, " + Xn({\n      start: e.start,\n      end: e.end\n    }) + ") is still open"\n  );\n}\nfunction _l(n) {\n  Object.assign(this, { Parser: (t) => {\n    const r = (\n      /** @type {Options} */\n      this.data("settings")\n    );\n    return vl(\n      t,\n      Object.assign({}, r, n, {\n        // Note: these options are not in the readme.\n        // The goal is for them to be set by plugins on `data` instead of being\n        // passed by users.\n        extensions: this.data("micromarkExtensions") || [],\n        mdastExtensions: this.data("fromMarkdownExtensions") || []\n      })\n    );\n  } });\n}\nfunction Ml(n, e) {\n  const t = {\n    type: "element",\n    tagName: "blockquote",\n    properties: {},\n    children: n.wrap(n.all(e), !0)\n  };\n  return n.patch(e, t), n.applyData(e, t);\n}\nfunction Bl(n, e) {\n  const t = { type: "element", tagName: "br", properties: {}, children: [] };\n  return n.patch(e, t), [n.applyData(e, t), { type: "text", value: `\n` }];\n}\nfunction Nl(n, e) {\n  const t = e.value ? e.value + `\n` : "", r = e.lang ? e.lang.match(/^[^ \\t]+(?=[ \\t]|$)/) : null, i = {};\n  r && (i.className = ["language-" + r]);\n  let l = {\n    type: "element",\n    tagName: "code",\n    properties: i,\n    children: [{ type: "text", value: t }]\n  };\n  return e.meta && (l.data = { meta: e.meta }), n.patch(e, l), l = n.applyData(e, l), l = { type: "element", tagName: "pre", properties: {}, children: [l] }, n.patch(e, l), l;\n}\nfunction jl(n, e) {\n  const t = {\n    type: "element",\n    tagName: "del",\n    properties: {},\n    children: n.all(e)\n  };\n  return n.patch(e, t), n.applyData(e, t);\n}\nfunction $l(n, e) {\n  const t = {\n    type: "element",\n    tagName: "em",\n    properties: {},\n    children: n.all(e)\n  };\n  return n.patch(e, t), n.applyData(e, t);\n}\nfunction vn(n) {\n  const e = [];\n  let t = -1, r = 0, i = 0;\n  for (; ++t < n.length; ) {\n    const l = n.charCodeAt(t);\n    let o = "";\n    if (l === 37 && on(n.charCodeAt(t + 1)) && on(n.charCodeAt(t + 2)))\n      i = 2;\n    else if (l < 128)\n      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(l)) || (o = String.fromCharCode(l));\n    else if (l > 55295 && l < 57344) {\n      const u = n.charCodeAt(t + 1);\n      l < 56320 && u > 56319 && u < 57344 ? (o = String.fromCharCode(l, u), i = 1) : o = "\ufffd";\n    } else\n      o = String.fromCharCode(l);\n    o && (e.push(n.slice(r, t), encodeURIComponent(o)), r = t + i + 1, o = ""), i && (t += i, i = 0);\n  }\n  return e.join("") + n.slice(r);\n}\nfunction Vt(n, e) {\n  const t = String(e.identifier).toUpperCase(), r = vn(t.toLowerCase()), i = n.footnoteOrder.indexOf(t);\n  let l;\n  i === -1 ? (n.footnoteOrder.push(t), n.footnoteCounts[t] = 1, l = n.footnoteOrder.length) : (n.footnoteCounts[t]++, l = i + 1);\n  const o = n.footnoteCounts[t], u = {\n    type: "element",\n    tagName: "a",\n    properties: {\n      href: "#" + n.clobberPrefix + "fn-" + r,\n      id: n.clobberPrefix + "fnref-" + r + (o > 1 ? "-" + o : ""),\n      dataFootnoteRef: !0,\n      ariaDescribedBy: ["footnote-label"]\n    },\n    children: [{ type: "text", value: String(l) }]\n  };\n  n.patch(e, u);\n  const a = {\n    type: "element",\n    tagName: "sup",\n    properties: {},\n    children: [u]\n  };\n  return n.patch(e, a), n.applyData(e, a);\n}\nfunction Hl(n, e) {\n  const t = n.footnoteById;\n  let r = 1;\n  for (; r in t; )\n    r++;\n  const i = String(r);\n  return t[i] = {\n    type: "footnoteDefinition",\n    identifier: i,\n    children: [{ type: "paragraph", children: e.children }],\n    position: e.position\n  }, Vt(n, {\n    type: "footnoteReference",\n    identifier: i,\n    position: e.position\n  });\n}\nfunction Ul(n, e) {\n  const t = {\n    type: "element",\n    tagName: "h" + e.depth,\n    properties: {},\n    children: n.all(e)\n  };\n  return n.patch(e, t), n.applyData(e, t);\n}\nfunction Vl(n, e) {\n  if (n.dangerous) {\n    const t = { type: "raw", value: e.value };\n    return n.patch(e, t), n.applyData(e, t);\n  }\n  return null;\n}\nfunction qt(n, e) {\n  const t = e.referenceType;\n  let r = "]";\n  if (t === "collapsed" ? r += "[]" : t === "full" && (r += "[" + (e.label || e.identifier) + "]"), e.type === "imageReference")\n    return { type: "text", value: "![" + e.alt + r };\n  const i = n.all(e), l = i[0];\n  l && l.type === "text" ? l.value = "[" + l.value : i.unshift({ type: "text", value: "[" });\n  const o = i[i.length - 1];\n  return o && o.type === "text" ? o.value += r : i.push({ type: "text", value: r }), i;\n}\nfunction ql(n, e) {\n  const t = n.definition(e.identifier);\n  if (!t)\n    return qt(n, e);\n  const r = { src: vn(t.url || ""), alt: e.alt };\n  t.title !== null && t.title !== void 0 && (r.title = t.title);\n  const i = { type: "element", tagName: "img", properties: r, children: [] };\n  return n.patch(e, i), n.applyData(e, i);\n}\nfunction Wl(n, e) {\n  const t = { src: vn(e.url) };\n  e.alt !== null && e.alt !== void 0 && (t.alt = e.alt), e.title !== null && e.title !== void 0 && (t.title = e.title);\n  const r = { type: "element", tagName: "img", properties: t, children: [] };\n  return n.patch(e, r), n.applyData(e, r);\n}\nfunction Yl(n, e) {\n  const t = { type: "text", value: e.value.replace(/\\r?\\n|\\r/g, " ") };\n  n.patch(e, t);\n  const r = {\n    type: "element",\n    tagName: "code",\n    properties: {},\n    children: [t]\n  };\n  return n.patch(e, r), n.applyData(e, r);\n}\nfunction Ql(n, e) {\n  const t = n.definition(e.identifier);\n  if (!t)\n    return qt(n, e);\n  const r = { href: vn(t.url || "") };\n  t.title !== null && t.title !== void 0 && (r.title = t.title);\n  const i = {\n    type: "element",\n    tagName: "a",\n    properties: r,\n    children: n.all(e)\n  };\n  return n.patch(e, i), n.applyData(e, i);\n}\nfunction Xl(n, e) {\n  const t = { href: vn(e.url) };\n  e.title !== null && e.title !== void 0 && (t.title = e.title);\n  const r = {\n    type: "element",\n    tagName: "a",\n    properties: t,\n    children: n.all(e)\n  };\n  return n.patch(e, r), n.applyData(e, r);\n}\nfunction Kl(n, e, t) {\n  const r = n.all(e), i = t ? Gl(t) : Wt(e), l = {}, o = [];\n  if (typeof e.checked == "boolean") {\n    const s = r[0];\n    let h;\n    s && s.type === "element" && s.tagName === "p" ? h = s : (h = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(h)), h.children.length > 0 && h.children.unshift({ type: "text", value: " " }), h.children.unshift({\n      type: "element",\n      tagName: "input",\n      properties: { type: "checkbox", checked: e.checked, disabled: !0 },\n      children: []\n    }), l.className = ["task-list-item"];\n  }\n  let u = -1;\n  for (; ++u < r.length; ) {\n    const s = r[u];\n    (i || u !== 0 || s.type !== "element" || s.tagName !== "p") && o.push({ type: "text", value: `\n` }), s.type === "element" && s.tagName === "p" && !i ? o.push(...s.children) : o.push(s);\n  }\n  const a = r[r.length - 1];\n  a && (i || a.type !== "element" || a.tagName !== "p") && o.push({ type: "text", value: `\n` });\n  const c = { type: "element", tagName: "li", properties: l, children: o };\n  return n.patch(e, c), n.applyData(e, c);\n}\nfunction Gl(n) {\n  let e = !1;\n  if (n.type === "list") {\n    e = n.spread || !1;\n    const t = n.children;\n    let r = -1;\n    for (; !e && ++r < t.length; )\n      e = Wt(t[r]);\n  }\n  return e;\n}\nfunction Wt(n) {\n  const e = n.spread;\n  return e ?? n.children.length > 1;\n}\nfunction Zl(n, e) {\n  const t = {}, r = n.all(e);\n  let i = -1;\n  for (typeof e.start == "number" && e.start !== 1 && (t.start = e.start); ++i < r.length; ) {\n    const o = r[i];\n    if (o.type === "element" && o.tagName === "li" && o.properties && Array.isArray(o.properties.className) && o.properties.className.includes("task-list-item")) {\n      t.className = ["contains-task-list"];\n      break;\n    }\n  }\n  const l = {\n    type: "element",\n    tagName: e.ordered ? "ol" : "ul",\n    properties: t,\n    children: n.wrap(r, !0)\n  };\n  return n.patch(e, l), n.applyData(e, l);\n}\nfunction Jl(n, e) {\n  const t = {\n    type: "element",\n    tagName: "p",\n    properties: {},\n    children: n.all(e)\n  };\n  return n.patch(e, t), n.applyData(e, t);\n}\nfunction no(n, e) {\n  const t = { type: "root", children: n.wrap(n.all(e)) };\n  return n.patch(e, t), n.applyData(e, t);\n}\nfunction eo(n, e) {\n  const t = {\n    type: "element",\n    tagName: "strong",\n    properties: {},\n    children: n.all(e)\n  };\n  return n.patch(e, t), n.applyData(e, t);\n}\nconst Fe = Yt("start"), Te = Yt("end");\nfunction to(n) {\n  return { start: Fe(n), end: Te(n) };\n}\nfunction Yt(n) {\n  return e;\n  function e(t) {\n    const r = t && t.position && t.position[n] || {};\n    return {\n      // @ts-expect-error: in practice, null is allowed.\n      line: r.line || null,\n      // @ts-expect-error: in practice, null is allowed.\n      column: r.column || null,\n      // @ts-expect-error: in practice, null is allowed.\n      offset: r.offset > -1 ? r.offset : null\n    };\n  }\n}\nfunction ro(n, e) {\n  const t = n.all(e), r = t.shift(), i = [];\n  if (r) {\n    const o = {\n      type: "element",\n      tagName: "thead",\n      properties: {},\n      children: n.wrap([r], !0)\n    };\n    n.patch(e.children[0], o), i.push(o);\n  }\n  if (t.length > 0) {\n    const o = {\n      type: "element",\n      tagName: "tbody",\n      properties: {},\n      children: n.wrap(t, !0)\n    }, u = Fe(e.children[1]), a = Te(e.children[e.children.length - 1]);\n    u.line && a.line && (o.position = { start: u, end: a }), i.push(o);\n  }\n  const l = {\n    type: "element",\n    tagName: "table",\n    properties: {},\n    children: n.wrap(i, !0)\n  };\n  return n.patch(e, l), n.applyData(e, l);\n}\nfunction io(n, e, t) {\n  const r = t ? t.children : void 0, l = (r ? r.indexOf(e) : 1) === 0 ? "th" : "td", o = t && t.type === "table" ? t.align : void 0, u = o ? o.length : e.children.length;\n  let a = -1;\n  const c = [];\n  for (; ++a < u; ) {\n    const h = e.children[a], g = {}, d = o ? o[a] : void 0;\n    d && (g.align = d);\n    let m = { type: "element", tagName: l, properties: g, children: [] };\n    h && (m.children = n.all(h), n.patch(h, m), m = n.applyData(e, m)), c.push(m);\n  }\n  const s = {\n    type: "element",\n    tagName: "tr",\n    properties: {},\n    children: n.wrap(c, !0)\n  };\n  return n.patch(e, s), n.applyData(e, s);\n}\nfunction lo(n, e) {\n  const t = {\n    type: "element",\n    tagName: "td",\n    // Assume body cell.\n    properties: {},\n    children: n.all(e)\n  };\n  return n.patch(e, t), n.applyData(e, t);\n}\nconst st = 9, ct = 32;\nfunction oo(n) {\n  const e = String(n), t = /\\r?\\n|\\r/g;\n  let r = t.exec(e), i = 0;\n  const l = [];\n  for (; r; )\n    l.push(\n      pt(e.slice(i, r.index), i > 0, !0),\n      r[0]\n    ), i = r.index + r[0].length, r = t.exec(e);\n  return l.push(pt(e.slice(i), i > 0, !1)), l.join("");\n}\nfunction pt(n, e, t) {\n  let r = 0, i = n.length;\n  if (e) {\n    let l = n.codePointAt(r);\n    for (; l === st || l === ct; )\n      r++, l = n.codePointAt(r);\n  }\n  if (t) {\n    let l = n.codePointAt(i - 1);\n    for (; l === st || l === ct; )\n      i--, l = n.codePointAt(i - 1);\n  }\n  return i > r ? n.slice(r, i) : "";\n}\nfunction uo(n, e) {\n  const t = { type: "text", value: oo(String(e.value)) };\n  return n.patch(e, t), n.applyData(e, t);\n}\nfunction ao(n, e) {\n  const t = {\n    type: "element",\n    tagName: "hr",\n    properties: {},\n    children: []\n  };\n  return n.patch(e, t), n.applyData(e, t);\n}\nconst so = {\n  blockquote: Ml,\n  break: Bl,\n  code: Nl,\n  delete: jl,\n  emphasis: $l,\n  footnoteReference: Vt,\n  footnote: Hl,\n  heading: Ul,\n  html: Vl,\n  imageReference: ql,\n  image: Wl,\n  inlineCode: Yl,\n  linkReference: Ql,\n  link: Xl,\n  listItem: Kl,\n  list: Zl,\n  paragraph: Jl,\n  root: no,\n  strong: eo,\n  table: ro,\n  tableCell: lo,\n  tableRow: io,\n  text: uo,\n  thematicBreak: ao,\n  toml: qn,\n  yaml: qn,\n  definition: qn,\n  footnoteDefinition: qn\n};\nfunction qn() {\n  return null;\n}\nconst Qt = (\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  /**\n   * @param {Test} [test]\n   * @returns {AssertAnything}\n   */\n  function(n) {\n    if (n == null)\n      return ho;\n    if (typeof n == "string")\n      return fo(n);\n    if (typeof n == "object")\n      return Array.isArray(n) ? co(n) : po(n);\n    if (typeof n == "function")\n      return Jn(n);\n    throw new Error("Expected function, string, or object as test");\n  }\n);\nfunction co(n) {\n  const e = [];\n  let t = -1;\n  for (; ++t < n.length; )\n    e[t] = Qt(n[t]);\n  return Jn(r);\n  function r(...i) {\n    let l = -1;\n    for (; ++l < e.length; )\n      if (e[l].call(this, ...i))\n        return !0;\n    return !1;\n  }\n}\nfunction po(n) {\n  return Jn(e);\n  function e(t) {\n    let r;\n    for (r in n)\n      if (t[r] !== n[r])\n        return !1;\n    return !0;\n  }\n}\nfunction fo(n) {\n  return Jn(e);\n  function e(t) {\n    return t && t.type === n;\n  }\n}\nfunction Jn(n) {\n  return e;\n  function e(t, ...r) {\n    return !!(t && typeof t == "object" && "type" in t && n.call(this, t, ...r));\n  }\n}\nfunction ho() {\n  return !0;\n}\nconst mo = !0, ft = !1, go = "skip", yo = (\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  /**\n   * @param {Node} tree\n   * @param {Test} test\n   * @param {Visitor<Node>} visitor\n   * @param {boolean | null | undefined} [reverse]\n   * @returns {void}\n   */\n  function(n, e, t, r) {\n    typeof e == "function" && typeof t != "function" && (r = t, t = e, e = null);\n    const i = Qt(e), l = r ? -1 : 1;\n    o(n, void 0, [])();\n    function o(u, a, c) {\n      const s = u && typeof u == "object" ? u : {};\n      if (typeof s.type == "string") {\n        const g = (\n          // `hast`\n          typeof s.tagName == "string" ? s.tagName : (\n            // `xast`\n            typeof s.name == "string" ? s.name : void 0\n          )\n        );\n        Object.defineProperty(h, "name", {\n          value: "node (" + (u.type + (g ? "<" + g + ">" : "")) + ")"\n        });\n      }\n      return h;\n      function h() {\n        let g = [], d, m, y;\n        if ((!e || i(u, a, c[c.length - 1] || null)) && (g = xo(t(u, c)), g[0] === ft))\n          return g;\n        if (u.children && g[0] !== go)\n          for (m = (r ? u.children.length : -1) + l, y = c.concat(u); m > -1 && m < u.children.length; ) {\n            if (d = o(u.children[m], m, y)(), d[0] === ft)\n              return d;\n            m = typeof d[1] == "number" ? d[1] : m + l;\n          }\n        return g;\n      }\n    }\n  }\n);\nfunction xo(n) {\n  return Array.isArray(n) ? n : typeof n == "number" ? [mo, n] : [n];\n}\nconst Xt = (\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  /**\n   * @param {Node} tree\n   * @param {Test} test\n   * @param {Visitor} visitor\n   * @param {boolean | null | undefined} [reverse]\n   * @returns {void}\n   */\n  function(n, e, t, r) {\n    typeof e == "function" && typeof t != "function" && (r = t, t = e, e = null), yo(n, e, i, r);\n    function i(l, o) {\n      const u = o[o.length - 1];\n      return t(\n        l,\n        u ? u.children.indexOf(l) : null,\n        u\n      );\n    }\n  }\n);\nfunction ko(n) {\n  return !n || !n.position || !n.position.start || !n.position.start.line || !n.position.start.column || !n.position.end || !n.position.end.line || !n.position.end.column;\n}\nconst ht = {}.hasOwnProperty;\nfunction bo(n) {\n  const e = /* @__PURE__ */ Object.create(null);\n  if (!n || !n.type)\n    throw new Error("mdast-util-definitions expected node");\n  return Xt(n, "definition", (r) => {\n    const i = mt(r.identifier);\n    i && !ht.call(e, i) && (e[i] = r);\n  }), t;\n  function t(r) {\n    const i = mt(r);\n    return i && ht.call(e, i) ? e[i] : null;\n  }\n}\nfunction mt(n) {\n  return String(n || "").toUpperCase();\n}\nconst Kn = {}.hasOwnProperty;\nfunction wo(n, e) {\n  const t = e || {}, r = t.allowDangerousHtml || !1, i = {};\n  return o.dangerous = r, o.clobberPrefix = t.clobberPrefix === void 0 || t.clobberPrefix === null ? "user-content-" : t.clobberPrefix, o.footnoteLabel = t.footnoteLabel || "Footnotes", o.footnoteLabelTagName = t.footnoteLabelTagName || "h2", o.footnoteLabelProperties = t.footnoteLabelProperties || {\n    className: ["sr-only"]\n  }, o.footnoteBackLabel = t.footnoteBackLabel || "Back to content", o.unknownHandler = t.unknownHandler, o.passThrough = t.passThrough, o.handlers = { ...so, ...t.handlers }, o.definition = bo(n), o.footnoteById = i, o.footnoteOrder = [], o.footnoteCounts = {}, o.patch = So, o.applyData = Eo, o.one = u, o.all = a, o.wrap = Ao, o.augment = l, Xt(n, "footnoteDefinition", (c) => {\n    const s = String(c.identifier).toUpperCase();\n    Kn.call(i, s) || (i[s] = c);\n  }), o;\n  function l(c, s) {\n    if (c && "data" in c && c.data) {\n      const h = c.data;\n      h.hName && (s.type !== "element" && (s = {\n        type: "element",\n        tagName: "",\n        properties: {},\n        children: []\n      }), s.tagName = h.hName), s.type === "element" && h.hProperties && (s.properties = { ...s.properties, ...h.hProperties }), "children" in s && s.children && h.hChildren && (s.children = h.hChildren);\n    }\n    if (c) {\n      const h = "type" in c ? c : { position: c };\n      ko(h) || (s.position = { start: Fe(h), end: Te(h) });\n    }\n    return s;\n  }\n  function o(c, s, h, g) {\n    return Array.isArray(h) && (g = h, h = {}), l(c, {\n      type: "element",\n      tagName: s,\n      properties: h || {},\n      children: g || []\n    });\n  }\n  function u(c, s) {\n    return Kt(o, c, s);\n  }\n  function a(c) {\n    return Ie(o, c);\n  }\n}\nfunction So(n, e) {\n  n.position && (e.position = to(n));\n}\nfunction Eo(n, e) {\n  let t = e;\n  if (n && n.data) {\n    const r = n.data.hName, i = n.data.hChildren, l = n.data.hProperties;\n    typeof r == "string" && (t.type === "element" ? t.tagName = r : t = {\n      type: "element",\n      tagName: r,\n      properties: {},\n      children: []\n    }), t.type === "element" && l && (t.properties = { ...t.properties, ...l }), "children" in t && t.children && i !== null && i !== void 0 && (t.children = i);\n  }\n  return t;\n}\nfunction Kt(n, e, t) {\n  const r = e && e.type;\n  if (!r)\n    throw new Error("Expected node, got `" + e + "`");\n  return Kn.call(n.handlers, r) ? n.handlers[r](n, e, t) : n.passThrough && n.passThrough.includes(r) ? "children" in e ? { ...e, children: Ie(n, e) } : e : n.unknownHandler ? n.unknownHandler(n, e, t) : Co(n, e);\n}\nfunction Ie(n, e) {\n  const t = [];\n  if ("children" in e) {\n    const r = e.children;\n    let i = -1;\n    for (; ++i < r.length; ) {\n      const l = Kt(n, r[i], e);\n      if (l) {\n        if (i && r[i - 1].type === "break" && (!Array.isArray(l) && l.type === "text" && (l.value = l.value.replace(/^\\s+/, "")), !Array.isArray(l) && l.type === "element")) {\n          const o = l.children[0];\n          o && o.type === "text" && (o.value = o.value.replace(/^\\s+/, ""));\n        }\n        Array.isArray(l) ? t.push(...l) : t.push(l);\n      }\n    }\n  }\n  return t;\n}\nfunction Co(n, e) {\n  const t = e.data || {}, r = "value" in e && !(Kn.call(t, "hProperties") || Kn.call(t, "hChildren")) ? { type: "text", value: e.value } : {\n    type: "element",\n    tagName: "div",\n    properties: {},\n    children: Ie(n, e)\n  };\n  return n.patch(e, r), n.applyData(e, r);\n}\nfunction Ao(n, e) {\n  const t = [];\n  let r = -1;\n  for (e && t.push({ type: "text", value: `\n` }); ++r < n.length; )\n    r && t.push({ type: "text", value: `\n` }), t.push(n[r]);\n  return e && n.length > 0 && t.push({ type: "text", value: `\n` }), t;\n}\nfunction Po(n) {\n  const e = [];\n  let t = -1;\n  for (; ++t < n.footnoteOrder.length; ) {\n    const r = n.footnoteById[n.footnoteOrder[t]];\n    if (!r)\n      continue;\n    const i = n.all(r), l = String(r.identifier).toUpperCase(), o = vn(l.toLowerCase());\n    let u = 0;\n    const a = [];\n    for (; ++u <= n.footnoteCounts[l]; ) {\n      const h = {\n        type: "element",\n        tagName: "a",\n        properties: {\n          href: "#" + n.clobberPrefix + "fnref-" + o + (u > 1 ? "-" + u : ""),\n          dataFootnoteBackref: !0,\n          className: ["data-footnote-backref"],\n          ariaLabel: n.footnoteBackLabel\n        },\n        children: [{ type: "text", value: "\u21a9" }]\n      };\n      u > 1 && h.children.push({\n        type: "element",\n        tagName: "sup",\n        children: [{ type: "text", value: String(u) }]\n      }), a.length > 0 && a.push({ type: "text", value: " " }), a.push(h);\n    }\n    const c = i[i.length - 1];\n    if (c && c.type === "element" && c.tagName === "p") {\n      const h = c.children[c.children.length - 1];\n      h && h.type === "text" ? h.value += " " : c.children.push({ type: "text", value: " " }), c.children.push(...a);\n    } else\n      i.push(...a);\n    const s = {\n      type: "element",\n      tagName: "li",\n      properties: { id: n.clobberPrefix + "fn-" + o },\n      children: n.wrap(i, !0)\n    };\n    n.patch(r, s), e.push(s);\n  }\n  if (e.length !== 0)\n    return {\n      type: "element",\n      tagName: "section",\n      properties: { dataFootnotes: !0, className: ["footnotes"] },\n      children: [\n        {\n          type: "element",\n          tagName: n.footnoteLabelTagName,\n          properties: {\n            // To do: use structured clone.\n            ...JSON.parse(JSON.stringify(n.footnoteLabelProperties)),\n            id: "footnote-label"\n          },\n          children: [{ type: "text", value: n.footnoteLabel }]\n        },\n        { type: "text", value: `\n` },\n        {\n          type: "element",\n          tagName: "ol",\n          properties: {},\n          children: n.wrap(e, !0)\n        },\n        { type: "text", value: `\n` }\n      ]\n    };\n}\nfunction Gt(n, e) {\n  const t = wo(n, e), r = t.one(n, null), i = Po(t);\n  return i && r.children.push({ type: "text", value: `\n` }, i), Array.isArray(r) ? { type: "root", children: r } : r;\n}\nconst Fo = (\n  /** @type {(import(\'unified\').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */\n  function(n, e) {\n    return n && "run" in n ? Io(n, e) : Oo(n || e);\n  }\n), To = Fo;\nfunction Io(n, e) {\n  return (t, r, i) => {\n    n.run(Gt(t, e), r, (l) => {\n      i(l);\n    });\n  };\n}\nfunction Oo(n) {\n  return (e) => Gt(e, n);\n}\nclass Un {\n  /**\n   * @constructor\n   * @param {Properties} property\n   * @param {Normal} normal\n   * @param {string} [space]\n   */\n  constructor(e, t, r) {\n    this.property = e, this.normal = t, r && (this.space = r);\n  }\n}\nUn.prototype.property = {};\nUn.prototype.normal = {};\nUn.prototype.space = null;\nfunction Zt(n, e) {\n  const t = {}, r = {};\n  let i = -1;\n  for (; ++i < n.length; )\n    Object.assign(t, n[i].property), Object.assign(r, n[i].normal);\n  return new Un(t, r, e);\n}\nfunction be(n) {\n  return n.toLowerCase();\n}\nclass pn {\n  /**\n   * @constructor\n   * @param {string} property\n   * @param {string} attribute\n   */\n  constructor(e, t) {\n    this.property = e, this.attribute = t;\n  }\n}\npn.prototype.space = null;\npn.prototype.boolean = !1;\npn.prototype.booleanish = !1;\npn.prototype.overloadedBoolean = !1;\npn.prototype.number = !1;\npn.prototype.commaSeparated = !1;\npn.prototype.spaceSeparated = !1;\npn.prototype.commaOrSpaceSeparated = !1;\npn.prototype.mustUseProperty = !1;\npn.prototype.defined = !1;\nlet Lo = 0;\nconst z = In(), K = In(), Jt = In(), S = In(), V = In(), Dn = In(), ln = In();\nfunction In() {\n  return 2 ** ++Lo;\n}\nconst we = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  boolean: z,\n  booleanish: K,\n  commaOrSpaceSeparated: ln,\n  commaSeparated: Dn,\n  number: S,\n  overloadedBoolean: Jt,\n  spaceSeparated: V\n}, Symbol.toStringTag, { value: "Module" })), pe = Object.keys(we);\nclass Oe extends pn {\n  /**\n   * @constructor\n   * @param {string} property\n   * @param {string} attribute\n   * @param {number|null} [mask]\n   * @param {string} [space]\n   */\n  constructor(e, t, r, i) {\n    let l = -1;\n    if (super(e, t), dt(this, "space", i), typeof r == "number")\n      for (; ++l < pe.length; ) {\n        const o = pe[l];\n        dt(this, pe[l], (r & we[o]) === we[o]);\n      }\n  }\n}\nOe.prototype.defined = !0;\nfunction dt(n, e, t) {\n  t && (n[e] = t);\n}\nconst Do = {}.hasOwnProperty;\nfunction zn(n) {\n  const e = {}, t = {};\n  let r;\n  for (r in n.properties)\n    if (Do.call(n.properties, r)) {\n      const i = n.properties[r], l = new Oe(\n        r,\n        n.transform(n.attributes || {}, r),\n        i,\n        n.space\n      );\n      n.mustUseProperty && n.mustUseProperty.includes(r) && (l.mustUseProperty = !0), e[r] = l, t[be(r)] = r, t[be(l.attribute)] = r;\n    }\n  return new Un(e, t, n.space);\n}\nconst nr = zn({\n  space: "xlink",\n  transform(n, e) {\n    return "xlink:" + e.slice(5).toLowerCase();\n  },\n  properties: {\n    xLinkActuate: null,\n    xLinkArcRole: null,\n    xLinkHref: null,\n    xLinkRole: null,\n    xLinkShow: null,\n    xLinkTitle: null,\n    xLinkType: null\n  }\n}), er = zn({\n  space: "xml",\n  transform(n, e) {\n    return "xml:" + e.slice(3).toLowerCase();\n  },\n  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }\n});\nfunction tr(n, e) {\n  return e in n ? n[e] : e;\n}\nfunction rr(n, e) {\n  return tr(n, e.toLowerCase());\n}\nconst ir = zn({\n  space: "xmlns",\n  attributes: { xmlnsxlink: "xmlns:xlink" },\n  transform: rr,\n  properties: { xmlns: null, xmlnsXLink: null }\n}), lr = zn({\n  transform(n, e) {\n    return e === "role" ? e : "aria-" + e.slice(4).toLowerCase();\n  },\n  properties: {\n    ariaActiveDescendant: null,\n    ariaAtomic: K,\n    ariaAutoComplete: null,\n    ariaBusy: K,\n    ariaChecked: K,\n    ariaColCount: S,\n    ariaColIndex: S,\n    ariaColSpan: S,\n    ariaControls: V,\n    ariaCurrent: null,\n    ariaDescribedBy: V,\n    ariaDetails: null,\n    ariaDisabled: K,\n    ariaDropEffect: V,\n    ariaErrorMessage: null,\n    ariaExpanded: K,\n    ariaFlowTo: V,\n    ariaGrabbed: K,\n    ariaHasPopup: null,\n    ariaHidden: K,\n    ariaInvalid: null,\n    ariaKeyShortcuts: null,\n    ariaLabel: null,\n    ariaLabelledBy: V,\n    ariaLevel: S,\n    ariaLive: null,\n    ariaModal: K,\n    ariaMultiLine: K,\n    ariaMultiSelectable: K,\n    ariaOrientation: null,\n    ariaOwns: V,\n    ariaPlaceholder: null,\n    ariaPosInSet: S,\n    ariaPressed: K,\n    ariaReadOnly: K,\n    ariaRelevant: null,\n    ariaRequired: K,\n    ariaRoleDescription: V,\n    ariaRowCount: S,\n    ariaRowIndex: S,\n    ariaRowSpan: S,\n    ariaSelected: K,\n    ariaSetSize: S,\n    ariaSort: null,\n    ariaValueMax: S,\n    ariaValueMin: S,\n    ariaValueNow: S,\n    ariaValueText: null,\n    role: null\n  }\n}), vo = zn({\n  space: "html",\n  attributes: {\n    acceptcharset: "accept-charset",\n    classname: "class",\n    htmlfor: "for",\n    httpequiv: "http-equiv"\n  },\n  transform: rr,\n  mustUseProperty: ["checked", "multiple", "muted", "selected"],\n  properties: {\n    // Standard Properties.\n    abbr: null,\n    accept: Dn,\n    acceptCharset: V,\n    accessKey: V,\n    action: null,\n    allow: null,\n    allowFullScreen: z,\n    allowPaymentRequest: z,\n    allowUserMedia: z,\n    alt: null,\n    as: null,\n    async: z,\n    autoCapitalize: null,\n    autoComplete: V,\n    autoFocus: z,\n    autoPlay: z,\n    capture: z,\n    charSet: null,\n    checked: z,\n    cite: null,\n    className: V,\n    cols: S,\n    colSpan: null,\n    content: null,\n    contentEditable: K,\n    controls: z,\n    controlsList: V,\n    coords: S | Dn,\n    crossOrigin: null,\n    data: null,\n    dateTime: null,\n    decoding: null,\n    default: z,\n    defer: z,\n    dir: null,\n    dirName: null,\n    disabled: z,\n    download: Jt,\n    draggable: K,\n    encType: null,\n    enterKeyHint: null,\n    form: null,\n    formAction: null,\n    formEncType: null,\n    formMethod: null,\n    formNoValidate: z,\n    formTarget: null,\n    headers: V,\n    height: S,\n    hidden: z,\n    high: S,\n    href: null,\n    hrefLang: null,\n    htmlFor: V,\n    httpEquiv: V,\n    id: null,\n    imageSizes: null,\n    imageSrcSet: null,\n    inputMode: null,\n    integrity: null,\n    is: null,\n    isMap: z,\n    itemId: null,\n    itemProp: V,\n    itemRef: V,\n    itemScope: z,\n    itemType: V,\n    kind: null,\n    label: null,\n    lang: null,\n    language: null,\n    list: null,\n    loading: null,\n    loop: z,\n    low: S,\n    manifest: null,\n    max: null,\n    maxLength: S,\n    media: null,\n    method: null,\n    min: null,\n    minLength: S,\n    multiple: z,\n    muted: z,\n    name: null,\n    nonce: null,\n    noModule: z,\n    noValidate: z,\n    onAbort: null,\n    onAfterPrint: null,\n    onAuxClick: null,\n    onBeforeMatch: null,\n    onBeforePrint: null,\n    onBeforeUnload: null,\n    onBlur: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onContextLost: null,\n    onContextMenu: null,\n    onContextRestored: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFormData: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLanguageChange: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadEnd: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMessageError: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRejectionHandled: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onScrollEnd: null,\n    onSecurityPolicyViolation: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onSlotChange: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnhandledRejection: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onWheel: null,\n    open: z,\n    optimum: S,\n    pattern: null,\n    ping: V,\n    placeholder: null,\n    playsInline: z,\n    poster: null,\n    preload: null,\n    readOnly: z,\n    referrerPolicy: null,\n    rel: V,\n    required: z,\n    reversed: z,\n    rows: S,\n    rowSpan: S,\n    sandbox: V,\n    scope: null,\n    scoped: z,\n    seamless: z,\n    selected: z,\n    shape: null,\n    size: S,\n    sizes: null,\n    slot: null,\n    span: S,\n    spellCheck: K,\n    src: null,\n    srcDoc: null,\n    srcLang: null,\n    srcSet: null,\n    start: S,\n    step: null,\n    style: null,\n    tabIndex: S,\n    target: null,\n    title: null,\n    translate: null,\n    type: null,\n    typeMustMatch: z,\n    useMap: null,\n    value: K,\n    width: S,\n    wrap: null,\n    // Legacy.\n    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis\n    align: null,\n    // Several. Use CSS `text-align` instead,\n    aLink: null,\n    // `<body>`. Use CSS `a:active {color}` instead\n    archive: V,\n    // `<object>`. List of URIs to archives\n    axis: null,\n    // `<td>` and `<th>`. Use `scope` on `<th>`\n    background: null,\n    // `<body>`. Use CSS `background-image` instead\n    bgColor: null,\n    // `<body>` and table elements. Use CSS `background-color` instead\n    border: S,\n    // `<table>`. Use CSS `border-width` instead,\n    borderColor: null,\n    // `<table>`. Use CSS `border-color` instead,\n    bottomMargin: S,\n    // `<body>`\n    cellPadding: null,\n    // `<table>`\n    cellSpacing: null,\n    // `<table>`\n    char: null,\n    // Several table elements. When `align=char`, sets the character to align on\n    charOff: null,\n    // Several table elements. When `char`, offsets the alignment\n    classId: null,\n    // `<object>`\n    clear: null,\n    // `<br>`. Use CSS `clear` instead\n    code: null,\n    // `<object>`\n    codeBase: null,\n    // `<object>`\n    codeType: null,\n    // `<object>`\n    color: null,\n    // `<font>` and `<hr>`. Use CSS instead\n    compact: z,\n    // Lists. Use CSS to reduce space between items instead\n    declare: z,\n    // `<object>`\n    event: null,\n    // `<script>`\n    face: null,\n    // `<font>`. Use CSS instead\n    frame: null,\n    // `<table>`\n    frameBorder: null,\n    // `<iframe>`. Use CSS `border` instead\n    hSpace: S,\n    // `<img>` and `<object>`\n    leftMargin: S,\n    // `<body>`\n    link: null,\n    // `<body>`. Use CSS `a:link {color: *}` instead\n    longDesc: null,\n    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`\n    lowSrc: null,\n    // `<img>`. Use a `<picture>`\n    marginHeight: S,\n    // `<body>`\n    marginWidth: S,\n    // `<body>`\n    noResize: z,\n    // `<frame>`\n    noHref: z,\n    // `<area>`. Use no href instead of an explicit `nohref`\n    noShade: z,\n    // `<hr>`. Use background-color and height instead of borders\n    noWrap: z,\n    // `<td>` and `<th>`\n    object: null,\n    // `<applet>`\n    profile: null,\n    // `<head>`\n    prompt: null,\n    // `<isindex>`\n    rev: null,\n    // `<link>`\n    rightMargin: S,\n    // `<body>`\n    rules: null,\n    // `<table>`\n    scheme: null,\n    // `<meta>`\n    scrolling: K,\n    // `<frame>`. Use overflow in the child context\n    standby: null,\n    // `<object>`\n    summary: null,\n    // `<table>`\n    text: null,\n    // `<body>`. Use CSS `color` instead\n    topMargin: S,\n    // `<body>`\n    valueType: null,\n    // `<param>`\n    version: null,\n    // `<html>`. Use a doctype.\n    vAlign: null,\n    // Several. Use CSS `vertical-align` instead\n    vLink: null,\n    // `<body>`. Use CSS `a:visited {color}` instead\n    vSpace: S,\n    // `<img>` and `<object>`\n    // Non-standard Properties.\n    allowTransparency: null,\n    autoCorrect: null,\n    autoSave: null,\n    disablePictureInPicture: z,\n    disableRemotePlayback: z,\n    prefix: null,\n    property: null,\n    results: S,\n    security: null,\n    unselectable: null\n  }\n}), zo = zn({\n  space: "svg",\n  attributes: {\n    accentHeight: "accent-height",\n    alignmentBaseline: "alignment-baseline",\n    arabicForm: "arabic-form",\n    baselineShift: "baseline-shift",\n    capHeight: "cap-height",\n    className: "class",\n    clipPath: "clip-path",\n    clipRule: "clip-rule",\n    colorInterpolation: "color-interpolation",\n    colorInterpolationFilters: "color-interpolation-filters",\n    colorProfile: "color-profile",\n    colorRendering: "color-rendering",\n    crossOrigin: "crossorigin",\n    dataType: "datatype",\n    dominantBaseline: "dominant-baseline",\n    enableBackground: "enable-background",\n    fillOpacity: "fill-opacity",\n    fillRule: "fill-rule",\n    floodColor: "flood-color",\n    floodOpacity: "flood-opacity",\n    fontFamily: "font-family",\n    fontSize: "font-size",\n    fontSizeAdjust: "font-size-adjust",\n    fontStretch: "font-stretch",\n    fontStyle: "font-style",\n    fontVariant: "font-variant",\n    fontWeight: "font-weight",\n    glyphName: "glyph-name",\n    glyphOrientationHorizontal: "glyph-orientation-horizontal",\n    glyphOrientationVertical: "glyph-orientation-vertical",\n    hrefLang: "hreflang",\n    horizAdvX: "horiz-adv-x",\n    horizOriginX: "horiz-origin-x",\n    horizOriginY: "horiz-origin-y",\n    imageRendering: "image-rendering",\n    letterSpacing: "letter-spacing",\n    lightingColor: "lighting-color",\n    markerEnd: "marker-end",\n    markerMid: "marker-mid",\n    markerStart: "marker-start",\n    navDown: "nav-down",\n    navDownLeft: "nav-down-left",\n    navDownRight: "nav-down-right",\n    navLeft: "nav-left",\n    navNext: "nav-next",\n    navPrev: "nav-prev",\n    navRight: "nav-right",\n    navUp: "nav-up",\n    navUpLeft: "nav-up-left",\n    navUpRight: "nav-up-right",\n    onAbort: "onabort",\n    onActivate: "onactivate",\n    onAfterPrint: "onafterprint",\n    onBeforePrint: "onbeforeprint",\n    onBegin: "onbegin",\n    onCancel: "oncancel",\n    onCanPlay: "oncanplay",\n    onCanPlayThrough: "oncanplaythrough",\n    onChange: "onchange",\n    onClick: "onclick",\n    onClose: "onclose",\n    onCopy: "oncopy",\n    onCueChange: "oncuechange",\n    onCut: "oncut",\n    onDblClick: "ondblclick",\n    onDrag: "ondrag",\n    onDragEnd: "ondragend",\n    onDragEnter: "ondragenter",\n    onDragExit: "ondragexit",\n    onDragLeave: "ondragleave",\n    onDragOver: "ondragover",\n    onDragStart: "ondragstart",\n    onDrop: "ondrop",\n    onDurationChange: "ondurationchange",\n    onEmptied: "onemptied",\n    onEnd: "onend",\n    onEnded: "onended",\n    onError: "onerror",\n    onFocus: "onfocus",\n    onFocusIn: "onfocusin",\n    onFocusOut: "onfocusout",\n    onHashChange: "onhashchange",\n    onInput: "oninput",\n    onInvalid: "oninvalid",\n    onKeyDown: "onkeydown",\n    onKeyPress: "onkeypress",\n    onKeyUp: "onkeyup",\n    onLoad: "onload",\n    onLoadedData: "onloadeddata",\n    onLoadedMetadata: "onloadedmetadata",\n    onLoadStart: "onloadstart",\n    onMessage: "onmessage",\n    onMouseDown: "onmousedown",\n    onMouseEnter: "onmouseenter",\n    onMouseLeave: "onmouseleave",\n    onMouseMove: "onmousemove",\n    onMouseOut: "onmouseout",\n    onMouseOver: "onmouseover",\n    onMouseUp: "onmouseup",\n    onMouseWheel: "onmousewheel",\n    onOffline: "onoffline",\n    onOnline: "ononline",\n    onPageHide: "onpagehide",\n    onPageShow: "onpageshow",\n    onPaste: "onpaste",\n    onPause: "onpause",\n    onPlay: "onplay",\n    onPlaying: "onplaying",\n    onPopState: "onpopstate",\n    onProgress: "onprogress",\n    onRateChange: "onratechange",\n    onRepeat: "onrepeat",\n    onReset: "onreset",\n    onResize: "onresize",\n    onScroll: "onscroll",\n    onSeeked: "onseeked",\n    onSeeking: "onseeking",\n    onSelect: "onselect",\n    onShow: "onshow",\n    onStalled: "onstalled",\n    onStorage: "onstorage",\n    onSubmit: "onsubmit",\n    onSuspend: "onsuspend",\n    onTimeUpdate: "ontimeupdate",\n    onToggle: "ontoggle",\n    onUnload: "onunload",\n    onVolumeChange: "onvolumechange",\n    onWaiting: "onwaiting",\n    onZoom: "onzoom",\n    overlinePosition: "overline-position",\n    overlineThickness: "overline-thickness",\n    paintOrder: "paint-order",\n    panose1: "panose-1",\n    pointerEvents: "pointer-events",\n    referrerPolicy: "referrerpolicy",\n    renderingIntent: "rendering-intent",\n    shapeRendering: "shape-rendering",\n    stopColor: "stop-color",\n    stopOpacity: "stop-opacity",\n    strikethroughPosition: "strikethrough-position",\n    strikethroughThickness: "strikethrough-thickness",\n    strokeDashArray: "stroke-dasharray",\n    strokeDashOffset: "stroke-dashoffset",\n    strokeLineCap: "stroke-linecap",\n    strokeLineJoin: "stroke-linejoin",\n    strokeMiterLimit: "stroke-miterlimit",\n    strokeOpacity: "stroke-opacity",\n    strokeWidth: "stroke-width",\n    tabIndex: "tabindex",\n    textAnchor: "text-anchor",\n    textDecoration: "text-decoration",\n    textRendering: "text-rendering",\n    typeOf: "typeof",\n    underlinePosition: "underline-position",\n    underlineThickness: "underline-thickness",\n    unicodeBidi: "unicode-bidi",\n    unicodeRange: "unicode-range",\n    unitsPerEm: "units-per-em",\n    vAlphabetic: "v-alphabetic",\n    vHanging: "v-hanging",\n    vIdeographic: "v-ideographic",\n    vMathematical: "v-mathematical",\n    vectorEffect: "vector-effect",\n    vertAdvY: "vert-adv-y",\n    vertOriginX: "vert-origin-x",\n    vertOriginY: "vert-origin-y",\n    wordSpacing: "word-spacing",\n    writingMode: "writing-mode",\n    xHeight: "x-height",\n    // These were camelcased in Tiny. Now lowercased in SVG 2\n    playbackOrder: "playbackorder",\n    timelineBegin: "timelinebegin"\n  },\n  transform: tr,\n  properties: {\n    about: ln,\n    accentHeight: S,\n    accumulate: null,\n    additive: null,\n    alignmentBaseline: null,\n    alphabetic: S,\n    amplitude: S,\n    arabicForm: null,\n    ascent: S,\n    attributeName: null,\n    attributeType: null,\n    azimuth: S,\n    bandwidth: null,\n    baselineShift: null,\n    baseFrequency: null,\n    baseProfile: null,\n    bbox: null,\n    begin: null,\n    bias: S,\n    by: null,\n    calcMode: null,\n    capHeight: S,\n    className: V,\n    clip: null,\n    clipPath: null,\n    clipPathUnits: null,\n    clipRule: null,\n    color: null,\n    colorInterpolation: null,\n    colorInterpolationFilters: null,\n    colorProfile: null,\n    colorRendering: null,\n    content: null,\n    contentScriptType: null,\n    contentStyleType: null,\n    crossOrigin: null,\n    cursor: null,\n    cx: null,\n    cy: null,\n    d: null,\n    dataType: null,\n    defaultAction: null,\n    descent: S,\n    diffuseConstant: S,\n    direction: null,\n    display: null,\n    dur: null,\n    divisor: S,\n    dominantBaseline: null,\n    download: z,\n    dx: null,\n    dy: null,\n    edgeMode: null,\n    editable: null,\n    elevation: S,\n    enableBackground: null,\n    end: null,\n    event: null,\n    exponent: S,\n    externalResourcesRequired: null,\n    fill: null,\n    fillOpacity: S,\n    fillRule: null,\n    filter: null,\n    filterRes: null,\n    filterUnits: null,\n    floodColor: null,\n    floodOpacity: null,\n    focusable: null,\n    focusHighlight: null,\n    fontFamily: null,\n    fontSize: null,\n    fontSizeAdjust: null,\n    fontStretch: null,\n    fontStyle: null,\n    fontVariant: null,\n    fontWeight: null,\n    format: null,\n    fr: null,\n    from: null,\n    fx: null,\n    fy: null,\n    g1: Dn,\n    g2: Dn,\n    glyphName: Dn,\n    glyphOrientationHorizontal: null,\n    glyphOrientationVertical: null,\n    glyphRef: null,\n    gradientTransform: null,\n    gradientUnits: null,\n    handler: null,\n    hanging: S,\n    hatchContentUnits: null,\n    hatchUnits: null,\n    height: null,\n    href: null,\n    hrefLang: null,\n    horizAdvX: S,\n    horizOriginX: S,\n    horizOriginY: S,\n    id: null,\n    ideographic: S,\n    imageRendering: null,\n    initialVisibility: null,\n    in: null,\n    in2: null,\n    intercept: S,\n    k: S,\n    k1: S,\n    k2: S,\n    k3: S,\n    k4: S,\n    kernelMatrix: ln,\n    kernelUnitLength: null,\n    keyPoints: null,\n    // SEMI_COLON_SEPARATED\n    keySplines: null,\n    // SEMI_COLON_SEPARATED\n    keyTimes: null,\n    // SEMI_COLON_SEPARATED\n    kerning: null,\n    lang: null,\n    lengthAdjust: null,\n    letterSpacing: null,\n    lightingColor: null,\n    limitingConeAngle: S,\n    local: null,\n    markerEnd: null,\n    markerMid: null,\n    markerStart: null,\n    markerHeight: null,\n    markerUnits: null,\n    markerWidth: null,\n    mask: null,\n    maskContentUnits: null,\n    maskUnits: null,\n    mathematical: null,\n    max: null,\n    media: null,\n    mediaCharacterEncoding: null,\n    mediaContentEncodings: null,\n    mediaSize: S,\n    mediaTime: null,\n    method: null,\n    min: null,\n    mode: null,\n    name: null,\n    navDown: null,\n    navDownLeft: null,\n    navDownRight: null,\n    navLeft: null,\n    navNext: null,\n    navPrev: null,\n    navRight: null,\n    navUp: null,\n    navUpLeft: null,\n    navUpRight: null,\n    numOctaves: null,\n    observer: null,\n    offset: null,\n    onAbort: null,\n    onActivate: null,\n    onAfterPrint: null,\n    onBeforePrint: null,\n    onBegin: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnd: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFocusIn: null,\n    onFocusOut: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onMouseWheel: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRepeat: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onShow: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onZoom: null,\n    opacity: null,\n    operator: null,\n    order: null,\n    orient: null,\n    orientation: null,\n    origin: null,\n    overflow: null,\n    overlay: null,\n    overlinePosition: S,\n    overlineThickness: S,\n    paintOrder: null,\n    panose1: null,\n    path: null,\n    pathLength: S,\n    patternContentUnits: null,\n    patternTransform: null,\n    patternUnits: null,\n    phase: null,\n    ping: V,\n    pitch: null,\n    playbackOrder: null,\n    pointerEvents: null,\n    points: null,\n    pointsAtX: S,\n    pointsAtY: S,\n    pointsAtZ: S,\n    preserveAlpha: null,\n    preserveAspectRatio: null,\n    primitiveUnits: null,\n    propagate: null,\n    property: ln,\n    r: null,\n    radius: null,\n    referrerPolicy: null,\n    refX: null,\n    refY: null,\n    rel: ln,\n    rev: ln,\n    renderingIntent: null,\n    repeatCount: null,\n    repeatDur: null,\n    requiredExtensions: ln,\n    requiredFeatures: ln,\n    requiredFonts: ln,\n    requiredFormats: ln,\n    resource: null,\n    restart: null,\n    result: null,\n    rotate: null,\n    rx: null,\n    ry: null,\n    scale: null,\n    seed: null,\n    shapeRendering: null,\n    side: null,\n    slope: null,\n    snapshotTime: null,\n    specularConstant: S,\n    specularExponent: S,\n    spreadMethod: null,\n    spacing: null,\n    startOffset: null,\n    stdDeviation: null,\n    stemh: null,\n    stemv: null,\n    stitchTiles: null,\n    stopColor: null,\n    stopOpacity: null,\n    strikethroughPosition: S,\n    strikethroughThickness: S,\n    string: null,\n    stroke: null,\n    strokeDashArray: ln,\n    strokeDashOffset: null,\n    strokeLineCap: null,\n    strokeLineJoin: null,\n    strokeMiterLimit: S,\n    strokeOpacity: S,\n    strokeWidth: null,\n    style: null,\n    surfaceScale: S,\n    syncBehavior: null,\n    syncBehaviorDefault: null,\n    syncMaster: null,\n    syncTolerance: null,\n    syncToleranceDefault: null,\n    systemLanguage: ln,\n    tabIndex: S,\n    tableValues: null,\n    target: null,\n    targetX: S,\n    targetY: S,\n    textAnchor: null,\n    textDecoration: null,\n    textRendering: null,\n    textLength: null,\n    timelineBegin: null,\n    title: null,\n    transformBehavior: null,\n    type: null,\n    typeOf: ln,\n    to: null,\n    transform: null,\n    u1: null,\n    u2: null,\n    underlinePosition: S,\n    underlineThickness: S,\n    unicode: null,\n    unicodeBidi: null,\n    unicodeRange: null,\n    unitsPerEm: S,\n    values: null,\n    vAlphabetic: S,\n    vMathematical: S,\n    vectorEffect: null,\n    vHanging: S,\n    vIdeographic: S,\n    version: null,\n    vertAdvY: S,\n    vertOriginX: S,\n    vertOriginY: S,\n    viewBox: null,\n    viewTarget: null,\n    visibility: null,\n    width: null,\n    widths: null,\n    wordSpacing: null,\n    writingMode: null,\n    x: null,\n    x1: null,\n    x2: null,\n    xChannelSelector: null,\n    xHeight: S,\n    y: null,\n    y1: null,\n    y2: null,\n    yChannelSelector: null,\n    z: null,\n    zoomAndPan: null\n  }\n}), Ro = /^data[-\\w.:]+$/i, gt = /-[a-z]/g, _o = /[A-Z]/g;\nfunction Mo(n, e) {\n  const t = be(e);\n  let r = e, i = pn;\n  if (t in n.normal)\n    return n.property[n.normal[t]];\n  if (t.length > 4 && t.slice(0, 4) === "data" && Ro.test(e)) {\n    if (e.charAt(4) === "-") {\n      const l = e.slice(5).replace(gt, No);\n      r = "data" + l.charAt(0).toUpperCase() + l.slice(1);\n    } else {\n      const l = e.slice(4);\n      if (!gt.test(l)) {\n        let o = l.replace(_o, Bo);\n        o.charAt(0) !== "-" && (o = "-" + o), e = "data" + o;\n      }\n    }\n    i = Oe;\n  }\n  return new i(r, e);\n}\nfunction Bo(n) {\n  return "-" + n.toLowerCase();\n}\nfunction No(n) {\n  return n.charAt(1).toUpperCase();\n}\nconst yt = {\n  classId: "classID",\n  dataType: "datatype",\n  itemId: "itemID",\n  strokeDashArray: "strokeDasharray",\n  strokeDashOffset: "strokeDashoffset",\n  strokeLineCap: "strokeLinecap",\n  strokeLineJoin: "strokeLinejoin",\n  strokeMiterLimit: "strokeMiterlimit",\n  typeOf: "typeof",\n  xLinkActuate: "xlinkActuate",\n  xLinkArcRole: "xlinkArcrole",\n  xLinkHref: "xlinkHref",\n  xLinkRole: "xlinkRole",\n  xLinkShow: "xlinkShow",\n  xLinkTitle: "xlinkTitle",\n  xLinkType: "xlinkType",\n  xmlnsXLink: "xmlnsXlink"\n}, jo = Zt([er, nr, ir, lr, vo], "html"), $o = Zt([er, nr, ir, lr, zo], "svg"), or = (\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  /**\n   * @param {Test} [test]\n   * @returns {AssertAnything}\n   */\n  function(n) {\n    if (n == null)\n      return qo;\n    if (typeof n == "string")\n      return Vo(n);\n    if (typeof n == "object")\n      return Array.isArray(n) ? Ho(n) : Uo(n);\n    if (typeof n == "function")\n      return ne(n);\n    throw new Error("Expected function, string, or object as test");\n  }\n);\nfunction Ho(n) {\n  const e = [];\n  let t = -1;\n  for (; ++t < n.length; )\n    e[t] = or(n[t]);\n  return ne(r);\n  function r(...i) {\n    let l = -1;\n    for (; ++l < e.length; )\n      if (e[l].call(this, ...i))\n        return !0;\n    return !1;\n  }\n}\nfunction Uo(n) {\n  return ne(e);\n  function e(t) {\n    let r;\n    for (r in n)\n      if (t[r] !== n[r])\n        return !1;\n    return !0;\n  }\n}\nfunction Vo(n) {\n  return ne(e);\n  function e(t) {\n    return t && t.type === n;\n  }\n}\nfunction ne(n) {\n  return e;\n  function e(t, ...r) {\n    return !!(t && typeof t == "object" && "type" in t && n.call(this, t, ...r));\n  }\n}\nfunction qo() {\n  return !0;\n}\nconst Wo = !0, xt = !1, Yo = "skip", Qo = (\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  /**\n   * @param {Node} tree\n   * @param {Test} test\n   * @param {Visitor<Node>} visitor\n   * @param {boolean | null | undefined} [reverse]\n   * @returns {void}\n   */\n  function(n, e, t, r) {\n    typeof e == "function" && typeof t != "function" && (r = t, t = e, e = null);\n    const i = or(e), l = r ? -1 : 1;\n    o(n, void 0, [])();\n    function o(u, a, c) {\n      const s = u && typeof u == "object" ? u : {};\n      if (typeof s.type == "string") {\n        const g = (\n          // `hast`\n          typeof s.tagName == "string" ? s.tagName : (\n            // `xast`\n            typeof s.name == "string" ? s.name : void 0\n          )\n        );\n        Object.defineProperty(h, "name", {\n          value: "node (" + (u.type + (g ? "<" + g + ">" : "")) + ")"\n        });\n      }\n      return h;\n      function h() {\n        let g = [], d, m, y;\n        if ((!e || i(u, a, c[c.length - 1] || null)) && (g = Xo(t(u, c)), g[0] === xt))\n          return g;\n        if (u.children && g[0] !== Yo)\n          for (m = (r ? u.children.length : -1) + l, y = c.concat(u); m > -1 && m < u.children.length; ) {\n            if (d = o(u.children[m], m, y)(), d[0] === xt)\n              return d;\n            m = typeof d[1] == "number" ? d[1] : m + l;\n          }\n        return g;\n      }\n    }\n  }\n);\nfunction Xo(n) {\n  return Array.isArray(n) ? n : typeof n == "number" ? [Wo, n] : [n];\n}\nconst Ko = (\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  /**\n   * @param {Node} tree\n   * @param {Test} test\n   * @param {Visitor} visitor\n   * @param {boolean | null | undefined} [reverse]\n   * @returns {void}\n   */\n  function(n, e, t, r) {\n    typeof e == "function" && typeof t != "function" && (r = t, t = e, e = null), Qo(n, e, i, r);\n    function i(l, o) {\n      const u = o[o.length - 1];\n      return t(\n        l,\n        u ? u.children.indexOf(l) : null,\n        u\n      );\n    }\n  }\n);\nfunction Go(n) {\n  if (n.allowedElements && n.disallowedElements)\n    throw new TypeError(\n      "Only one of `allowedElements` and `disallowedElements` should be defined"\n    );\n  if (n.allowedElements || n.disallowedElements || n.allowElement)\n    return (e) => {\n      Ko(e, "element", (t, r, i) => {\n        const l = (\n          /** @type {Element|Root} */\n          i\n        );\n        let o;\n        if (n.allowedElements ? o = !n.allowedElements.includes(t.tagName) : n.disallowedElements && (o = n.disallowedElements.includes(t.tagName)), !o && n.allowElement && typeof r == "number" && (o = !n.allowElement(t, r, l)), o && typeof r == "number")\n          return n.unwrapDisallowed && t.children ? l.children.splice(r, 1, ...t.children) : l.children.splice(r, 1), r;\n      });\n    };\n}\nvar Se = {}, Zo = {\n  get exports() {\n    return Se;\n  },\n  set exports(n) {\n    Se = n;\n  }\n}, N = {};\n/**\n * @license React\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar kt;\nfunction Jo() {\n  if (kt)\n    return N;\n  kt = 1;\n  var n = Symbol.for("react.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), o = Symbol.for("react.context"), u = Symbol.for("react.server_context"), a = Symbol.for("react.forward_ref"), c = Symbol.for("react.suspense"), s = Symbol.for("react.suspense_list"), h = Symbol.for("react.memo"), g = Symbol.for("react.lazy"), d = Symbol.for("react.offscreen"), m;\n  m = Symbol.for("react.module.reference");\n  function y(x) {\n    if (typeof x == "object" && x !== null) {\n      var w = x.$$typeof;\n      switch (w) {\n        case n:\n          switch (x = x.type, x) {\n            case t:\n            case i:\n            case r:\n            case c:\n            case s:\n              return x;\n            default:\n              switch (x = x && x.$$typeof, x) {\n                case u:\n                case o:\n                case a:\n                case g:\n                case h:\n                case l:\n                  return x;\n                default:\n                  return w;\n              }\n          }\n        case e:\n          return w;\n      }\n    }\n  }\n  return N.ContextConsumer = o, N.ContextProvider = l, N.Element = n, N.ForwardRef = a, N.Fragment = t, N.Lazy = g, N.Memo = h, N.Portal = e, N.Profiler = i, N.StrictMode = r, N.Suspense = c, N.SuspenseList = s, N.isAsyncMode = function() {\n    return !1;\n  }, N.isConcurrentMode = function() {\n    return !1;\n  }, N.isContextConsumer = function(x) {\n    return y(x) === o;\n  }, N.isContextProvider = function(x) {\n    return y(x) === l;\n  }, N.isElement = function(x) {\n    return typeof x == "object" && x !== null && x.$$typeof === n;\n  }, N.isForwardRef = function(x) {\n    return y(x) === a;\n  }, N.isFragment = function(x) {\n    return y(x) === t;\n  }, N.isLazy = function(x) {\n    return y(x) === g;\n  }, N.isMemo = function(x) {\n    return y(x) === h;\n  }, N.isPortal = function(x) {\n    return y(x) === e;\n  }, N.isProfiler = function(x) {\n    return y(x) === i;\n  }, N.isStrictMode = function(x) {\n    return y(x) === r;\n  }, N.isSuspense = function(x) {\n    return y(x) === c;\n  }, N.isSuspenseList = function(x) {\n    return y(x) === s;\n  }, N.isValidElementType = function(x) {\n    return typeof x == "string" || typeof x == "function" || x === t || x === i || x === r || x === c || x === s || x === d || typeof x == "object" && x !== null && (x.$$typeof === g || x.$$typeof === h || x.$$typeof === l || x.$$typeof === o || x.$$typeof === a || x.$$typeof === m || x.getModuleId !== void 0);\n  }, N.typeOf = y, N;\n}\nvar j = {};\n/**\n * @license React\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar bt;\nfunction nu() {\n  return bt || (bt = 1,  false && 0), j;\n}\n(function(n) {\n   true ? n.exports = Jo() : 0;\n})(Zo);\nconst eu = /* @__PURE__ */ (0,_index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.g)(Se);\nfunction tu(n) {\n  const e = (\n    // @ts-expect-error looks like a node.\n    n && typeof n == "object" && n.type === "text" ? (\n      // @ts-expect-error looks like a text.\n      n.value || ""\n    ) : n\n  );\n  return typeof e == "string" && e.replace(/[ \\t\\n\\f\\r]/g, "") === "";\n}\nfunction ru(n) {\n  return n.join(" ").trim();\n}\nfunction iu(n, e) {\n  const t = e || {};\n  return (n[n.length - 1] === "" ? [...n, ""] : n).join(\n    (t.padRight ? " " : "") + "," + (t.padLeft === !1 ? "" : " ")\n  ).trim();\n}\nvar Gn = {}, lu = {\n  get exports() {\n    return Gn;\n  },\n  set exports(n) {\n    Gn = n;\n  }\n}, wt = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g, ou = /\\n/g, uu = /^\\s*/, au = /^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/, su = /^:\\s*/, cu = /^((?:\'(?:\\\\\'|.)*?\'|"(?:\\\\"|.)*?"|\\([^)]*?\\)|[^};])+)/, pu = /^[;\\s]*/, fu = /^\\s+|\\s+$/g, hu = `\n`, St = "/", Et = "*", Tn = "", mu = "comment", du = "declaration", gu = function(n, e) {\n  if (typeof n != "string")\n    throw new TypeError("First argument must be a string");\n  if (!n)\n    return [];\n  e = e || {};\n  var t = 1, r = 1;\n  function i(m) {\n    var y = m.match(ou);\n    y && (t += y.length);\n    var x = m.lastIndexOf(hu);\n    r = ~x ? m.length - x : r + m.length;\n  }\n  function l() {\n    var m = { line: t, column: r };\n    return function(y) {\n      return y.position = new o(m), c(), y;\n    };\n  }\n  function o(m) {\n    this.start = m, this.end = { line: t, column: r }, this.source = e.source;\n  }\n  o.prototype.content = n;\n  function u(m) {\n    var y = new Error(\n      e.source + ":" + t + ":" + r + ": " + m\n    );\n    if (y.reason = m, y.filename = e.source, y.line = t, y.column = r, y.source = n, !e.silent)\n      throw y;\n  }\n  function a(m) {\n    var y = m.exec(n);\n    if (y) {\n      var x = y[0];\n      return i(x), n = n.slice(x.length), y;\n    }\n  }\n  function c() {\n    a(uu);\n  }\n  function s(m) {\n    var y;\n    for (m = m || []; y = h(); )\n      y !== !1 && m.push(y);\n    return m;\n  }\n  function h() {\n    var m = l();\n    if (!(St != n.charAt(0) || Et != n.charAt(1))) {\n      for (var y = 2; Tn != n.charAt(y) && (Et != n.charAt(y) || St != n.charAt(y + 1)); )\n        ++y;\n      if (y += 2, Tn === n.charAt(y - 1))\n        return u("End of comment missing");\n      var x = n.slice(2, y - 2);\n      return r += 2, i(x), n = n.slice(y), r += 2, m({\n        type: mu,\n        comment: x\n      });\n    }\n  }\n  function g() {\n    var m = l(), y = a(au);\n    if (y) {\n      if (h(), !a(su))\n        return u("property missing \':\'");\n      var x = a(cu), w = m({\n        type: du,\n        property: Ct(y[0].replace(wt, Tn)),\n        value: x ? Ct(x[0].replace(wt, Tn)) : Tn\n      });\n      return a(pu), w;\n    }\n  }\n  function d() {\n    var m = [];\n    s(m);\n    for (var y; y = g(); )\n      y !== !1 && (m.push(y), s(m));\n    return m;\n  }\n  return c(), d();\n};\nfunction Ct(n) {\n  return n ? n.replace(fu, Tn) : Tn;\n}\nvar yu = gu;\nfunction ur(n, e) {\n  var t = null;\n  if (!n || typeof n != "string")\n    return t;\n  for (var r, i = yu(n), l = typeof e == "function", o, u, a = 0, c = i.length; a < c; a++)\n    r = i[a], o = r.property, u = r.value, l ? e(o, u, r) : u && (t || (t = {}), t[o] = u);\n  return t;\n}\nlu.exports = ur;\nGn.default = ur;\nconst xu = Gn, Ee = {}.hasOwnProperty, ku = /* @__PURE__ */ new Set(["table", "thead", "tbody", "tfoot", "tr"]);\nfunction ar(n, e) {\n  const t = [];\n  let r = -1, i;\n  for (; ++r < e.children.length; )\n    i = e.children[r], i.type === "element" ? t.push(bu(n, i, r, e)) : i.type === "text" ? (e.type !== "element" || !ku.has(e.tagName) || !tu(i)) && t.push(i.value) : i.type === "raw" && !n.options.skipHtml && t.push(i.value);\n  return t;\n}\nfunction bu(n, e, t, r) {\n  const i = n.options, l = i.transformLinkUri === void 0 ? gr : i.transformLinkUri, o = n.schema, u = e.tagName, a = {};\n  let c = o, s;\n  if (o.space === "html" && u === "svg" && (c = $o, n.schema = c), e.properties)\n    for (s in e.properties)\n      Ee.call(e.properties, s) && Su(a, s, e.properties[s], n);\n  (u === "ol" || u === "ul") && n.listDepth++;\n  const h = ar(n, e);\n  (u === "ol" || u === "ul") && n.listDepth--, n.schema = o;\n  const g = e.position || {\n    start: { line: null, column: null, offset: null },\n    end: { line: null, column: null, offset: null }\n  }, d = i.components && Ee.call(i.components, u) ? i.components[u] : u, m = typeof d == "string" || d === react__WEBPACK_IMPORTED_MODULE_0__.Fragment;\n  if (!eu.isValidElementType(d))\n    throw new TypeError(\n      `Component for name \\`${u}\\` not defined or is not renderable`\n    );\n  if (a.key = [\n    u,\n    g.start.line,\n    g.start.column,\n    t\n  ].join("-"), u === "a" && i.linkTarget && (a.target = typeof i.linkTarget == "function" ? i.linkTarget(\n    String(a.href || ""),\n    e.children,\n    typeof a.title == "string" ? a.title : null\n  ) : i.linkTarget), u === "a" && l && (a.href = l(\n    String(a.href || ""),\n    e.children,\n    typeof a.title == "string" ? a.title : null\n  )), !m && u === "code" && r.type === "element" && r.tagName !== "pre" && (a.inline = !0), !m && (u === "h1" || u === "h2" || u === "h3" || u === "h4" || u === "h5" || u === "h6") && (a.level = Number.parseInt(u.charAt(1), 10)), u === "img" && i.transformImageUri && (a.src = i.transformImageUri(\n    String(a.src || ""),\n    String(a.alt || ""),\n    typeof a.title == "string" ? a.title : null\n  )), !m && u === "li" && r.type === "element") {\n    const y = wu(e);\n    a.checked = y && y.properties ? !!y.properties.checked : null, a.index = fe(r, e), a.ordered = r.tagName === "ol";\n  }\n  return !m && (u === "ol" || u === "ul") && (a.ordered = u === "ol", a.depth = n.listDepth), (u === "td" || u === "th") && (a.align && (a.style || (a.style = {}), a.style.textAlign = a.align, delete a.align), m || (a.isHeader = u === "th")), !m && u === "tr" && r.type === "element" && (a.isHeader = r.tagName === "thead"), i.sourcePos && (a["data-sourcepos"] = Au(g)), !m && i.rawSourcePos && (a.sourcePosition = e.position), !m && i.includeElementIndex && (a.index = fe(r, e), a.siblingCount = fe(r)), m || (a.node = e), h.length > 0 ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(d, a, h) : react__WEBPACK_IMPORTED_MODULE_0__.createElement(d, a);\n}\nfunction wu(n) {\n  let e = -1;\n  for (; ++e < n.children.length; ) {\n    const t = n.children[e];\n    if (t.type === "element" && t.tagName === "input")\n      return t;\n  }\n  return null;\n}\nfunction fe(n, e) {\n  let t = -1, r = 0;\n  for (; ++t < n.children.length && n.children[t] !== e; )\n    n.children[t].type === "element" && r++;\n  return r;\n}\nfunction Su(n, e, t, r) {\n  const i = Mo(r.schema, e);\n  let l = t;\n  l == null || l !== l || (Array.isArray(l) && (l = i.commaSeparated ? iu(l) : ru(l)), i.property === "style" && typeof l == "string" && (l = Eu(l)), i.space && i.property ? n[Ee.call(yt, i.property) ? yt[i.property] : i.property] = l : i.attribute && (n[i.attribute] = l));\n}\nfunction Eu(n) {\n  const e = {};\n  try {\n    xu(n, t);\n  } catch {\n  }\n  return e;\n  function t(r, i) {\n    const l = r.slice(0, 4) === "-ms-" ? `ms-${r.slice(4)}` : r;\n    e[l.replace(/-([a-z])/g, Cu)] = i;\n  }\n}\nfunction Cu(n, e) {\n  return e.toUpperCase();\n}\nfunction Au(n) {\n  return [\n    n.start.line,\n    ":",\n    n.start.column,\n    "-",\n    n.end.line,\n    ":",\n    n.end.column\n  ].map(String).join("");\n}\nconst At = {}.hasOwnProperty, Pu = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", Wn = {\n  plugins: { to: "remarkPlugins", id: "change-plugins-to-remarkplugins" },\n  renderers: { to: "components", id: "change-renderers-to-components" },\n  astPlugins: { id: "remove-buggy-html-in-markdown-parser" },\n  allowDangerousHtml: { id: "remove-buggy-html-in-markdown-parser" },\n  escapeHtml: { id: "remove-buggy-html-in-markdown-parser" },\n  source: { to: "children", id: "change-source-to-children" },\n  allowNode: {\n    to: "allowElement",\n    id: "replace-allownode-allowedtypes-and-disallowedtypes"\n  },\n  allowedTypes: {\n    to: "allowedElements",\n    id: "replace-allownode-allowedtypes-and-disallowedtypes"\n  },\n  disallowedTypes: {\n    to: "disallowedElements",\n    id: "replace-allownode-allowedtypes-and-disallowedtypes"\n  },\n  includeNodeIndex: {\n    to: "includeElementIndex",\n    id: "change-includenodeindex-to-includeelementindex"\n  }\n};\nfunction Fu(n) {\n  for (const l in Wn)\n    if (At.call(Wn, l) && At.call(n, l)) {\n      const o = Wn[l];\n      console.warn(\n        `[react-markdown] Warning: please ${o.to ? `use \\`${o.to}\\` instead of` : "remove"} \\`${l}\\` (see <${Pu}#${o.id}> for more info)`\n      ), delete Wn[l];\n    }\n  const e = Dr().use(_l).use(n.remarkPlugins || []).use(To, {\n    ...n.remarkRehypeOptions,\n    allowDangerousHtml: !0\n  }).use(n.rehypePlugins || []).use(Go, n), t = new Ft();\n  typeof n.children == "string" ? t.value = n.children : n.children !== void 0 && n.children !== null && console.warn(\n    `[react-markdown] Warning: please pass a string as \\`children\\` (not: \\`${n.children}\\`)`\n  );\n  const r = e.runSync(e.parse(t), t);\n  if (r.type !== "root")\n    throw new TypeError("Expected a `root` node");\n  let i = react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    react__WEBPACK_IMPORTED_MODULE_0__.Fragment,\n    {},\n    ar({ options: n, schema: jo, listDepth: 0 }, r)\n  );\n  return n.className && (i = react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", { className: n.className }, i)), i;\n}\nFu.propTypes = {\n  // Core options:\n  children: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.string,\n  // Layout options:\n  className: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.string,\n  // Filter options:\n  allowElement: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.func,\n  allowedElements: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.arrayOf(_index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.string),\n  disallowedElements: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.arrayOf(_index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.string),\n  unwrapDisallowed: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.bool,\n  // Plugin options:\n  remarkPlugins: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.arrayOf(\n    _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.oneOfType([\n      _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.object,\n      _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.func,\n      _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.arrayOf(\n        _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.oneOfType([\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.bool,\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.string,\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.object,\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.func,\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.arrayOf(\n            // prettier-ignore\n            // type-coverage:ignore-next-line\n            _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.any\n          )\n        ])\n      )\n    ])\n  ),\n  rehypePlugins: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.arrayOf(\n    _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.oneOfType([\n      _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.object,\n      _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.func,\n      _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.arrayOf(\n        _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.oneOfType([\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.bool,\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.string,\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.object,\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.func,\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.arrayOf(\n            // prettier-ignore\n            // type-coverage:ignore-next-line\n            _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.any\n          )\n        ])\n      )\n    ])\n  ),\n  // Transform options:\n  sourcePos: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.bool,\n  rawSourcePos: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.bool,\n  skipHtml: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.bool,\n  includeElementIndex: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.bool,\n  transformLinkUri: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.oneOfType([_index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.func, _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.bool]),\n  linkTarget: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.oneOfType([_index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.func, _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.string]),\n  transformImageUri: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.func,\n  components: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.object\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxhQUFhLDhDQUE4QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrRkFBa0Y7QUFDaEg7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0EsZ0dBQWdHLEtBQUs7QUFDckc7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOERBQThEO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCLEdBQUc7QUFDSDtBQUNBLDJCQUEyQjtBQUMzQix5QkFBeUI7QUFDekIsR0FBRztBQUNIO0FBQ0EsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxLQUFLO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQix5QkFBeUI7QUFDekI7QUFDQSwySkFBMko7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlCQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxhQUFhLEtBQUs7QUFDbEI7QUFDQTtBQUNBLDZCQUE2Qiw0QkFBNEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLCtCQUErQjtBQUMvQjtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBLHVFQUF1RSw2Q0FBNkM7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFVBQVUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsTUFBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGdCQUFnQjtBQUNoQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQSxnQkFBZ0I7QUFDaEIsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLE1BQU07QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxNQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE1BQU07QUFDbkIsYUFBYSxlQUFlO0FBQzVCLGFBQWEsNEJBQTRCO0FBQ3pDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGlDQUFpQztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxNQUFNO0FBQ25CLGFBQWEsU0FBUztBQUN0QixhQUFhLDRCQUE0QjtBQUN6QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE1BQXFDLElBQUksQ0FzRjVEO0FBQ0w7QUFDQTtBQUNBLEVBQUUsS0FBcUMsc0JBQXNCLENBQWdCO0FBQzdFLENBQUM7QUFDRCwyQkFBMkIscURBQUU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNMQUFzTCxnQkFBZ0I7QUFDdk07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9CQUFvQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUVBQW1FO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsT0FBTztBQUN2Riw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdDQUF3QztBQUNyRCxXQUFXO0FBQ1gsR0FBRyx3R0FBd0csMkNBQVc7QUFDdEg7QUFDQTtBQUNBLDhCQUE4QixFQUFFO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUtBQWlLLDBYQUEwWCxnREFBZ0IsWUFBWSxnREFBZ0I7QUFDdmtCO0FBQ0E7QUFDQTtBQUNBLFNBQVMseUJBQXlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdEQUFnRDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhLDREQUE0RDtBQUN6RSxlQUFlLHdEQUF3RDtBQUN2RSxnQkFBZ0IsNENBQTRDO0FBQzVELHdCQUF3Qiw0Q0FBNEM7QUFDcEUsZ0JBQWdCLDRDQUE0QztBQUM1RCxZQUFZLGlEQUFpRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0IsS0FBSywyQkFBMkIsSUFBSSxFQUFFLFdBQVcsR0FBRyxHQUFHLEtBQUs7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDhFQUE4RSxXQUFXO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnREFBZ0I7QUFDMUIsSUFBSSwyQ0FBVztBQUNmLE1BQU07QUFDTixTQUFTLHNDQUFzQztBQUMvQztBQUNBLDZCQUE2QixnREFBZ0IsVUFBVSx3QkFBd0I7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBUTtBQUNwQjtBQUNBLGFBQWEsd0RBQVE7QUFDckI7QUFDQSxnQkFBZ0Isc0RBQU07QUFDdEIsbUJBQW1CLHlEQUFTLENBQUMsd0RBQVE7QUFDckMsc0JBQXNCLHlEQUFTLENBQUMsd0RBQVE7QUFDeEMsb0JBQW9CLHNEQUFNO0FBQzFCO0FBQ0EsaUJBQWlCLHlEQUFTO0FBQzFCLElBQUksMkRBQVc7QUFDZixNQUFNLHdEQUFRO0FBQ2QsTUFBTSxzREFBTTtBQUNaLE1BQU0seURBQVM7QUFDZixRQUFRLDJEQUFXO0FBQ25CLFVBQVUsc0RBQU07QUFDaEIsVUFBVSx3REFBUTtBQUNsQixVQUFVLHdEQUFRO0FBQ2xCLFVBQVUsc0RBQU07QUFDaEIsVUFBVSx5REFBUztBQUNuQjtBQUNBO0FBQ0EsWUFBWSxxREFBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFTO0FBQzFCLElBQUksMkRBQVc7QUFDZixNQUFNLHdEQUFRO0FBQ2QsTUFBTSxzREFBTTtBQUNaLE1BQU0seURBQVM7QUFDZixRQUFRLDJEQUFXO0FBQ25CLFVBQVUsc0RBQU07QUFDaEIsVUFBVSx3REFBUTtBQUNsQixVQUFVLHdEQUFRO0FBQ2xCLFVBQVUsc0RBQU07QUFDaEIsVUFBVSx5REFBUztBQUNuQjtBQUNBO0FBQ0EsWUFBWSxxREFBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNEQUFNO0FBQ25CLGdCQUFnQixzREFBTTtBQUN0QixZQUFZLHNEQUFNO0FBQ2xCLHVCQUF1QixzREFBTTtBQUM3QixvQkFBb0IsMkRBQVcsRUFBRSxzREFBTSxFQUFFLHNEQUFNO0FBQy9DLGNBQWMsMkRBQVcsRUFBRSxzREFBTSxFQUFFLHdEQUFRO0FBQzNDLHFCQUFxQixzREFBTTtBQUMzQixjQUFjLHdEQUFRO0FBQ3RCO0FBSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL2VuaGFuY2Vkb2NzLXNlYXJjaC9kaXN0L2luZGV4LTVmNGNlZGIyLmpzP2ZjNmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE9uIGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgZyBhcyBkciwgcCBhcyBEIH0gZnJvbSBcIi4vaW5kZXgtYTI0OTFiZjMuanNcIjtcbmNvbnN0IHplID0gW1wiaHR0cFwiLCBcImh0dHBzXCIsIFwibWFpbHRvXCIsIFwidGVsXCJdO1xuZnVuY3Rpb24gZ3Iobikge1xuICBjb25zdCBlID0gKG4gfHwgXCJcIikudHJpbSgpLCB0ID0gZS5jaGFyQXQoMCk7XG4gIGlmICh0ID09PSBcIiNcIiB8fCB0ID09PSBcIi9cIilcbiAgICByZXR1cm4gZTtcbiAgY29uc3QgciA9IGUuaW5kZXhPZihcIjpcIik7XG4gIGlmIChyID09PSAtMSlcbiAgICByZXR1cm4gZTtcbiAgbGV0IGkgPSAtMTtcbiAgZm9yICg7ICsraSA8IHplLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgbCA9IHplW2ldO1xuICAgIGlmIChyID09PSBsLmxlbmd0aCAmJiBlLnNsaWNlKDAsIGwubGVuZ3RoKS50b0xvd2VyQ2FzZSgpID09PSBsKVxuICAgICAgcmV0dXJuIGU7XG4gIH1cbiAgcmV0dXJuIGkgPSBlLmluZGV4T2YoXCI/XCIpLCBpICE9PSAtMSAmJiByID4gaSB8fCAoaSA9IGUuaW5kZXhPZihcIiNcIiksIGkgIT09IC0xICYmIHIgPiBpKSA/IGUgOiBcImphdmFzY3JpcHQ6dm9pZCgwKVwiO1xufVxuLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xudmFyIHlyID0gZnVuY3Rpb24oZSkge1xuICByZXR1cm4gZSAhPSBudWxsICYmIGUuY29uc3RydWN0b3IgIT0gbnVsbCAmJiB0eXBlb2YgZS5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PSBcImZ1bmN0aW9uXCIgJiYgZS5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihlKTtcbn07XG5jb25zdCBQdCA9IHlyO1xuZnVuY3Rpb24geHIobikge1xuICByZXR1cm4gIW4gfHwgdHlwZW9mIG4gIT0gXCJvYmplY3RcIiA/IFwiXCIgOiBcInBvc2l0aW9uXCIgaW4gbiB8fCBcInR5cGVcIiBpbiBuID8gUmUobi5wb3NpdGlvbikgOiBcInN0YXJ0XCIgaW4gbiB8fCBcImVuZFwiIGluIG4gPyBSZShuKSA6IFwibGluZVwiIGluIG4gfHwgXCJjb2x1bW5cIiBpbiBuID8gaGUobikgOiBcIlwiO1xufVxuZnVuY3Rpb24gaGUobikge1xuICByZXR1cm4gX2UobiAmJiBuLmxpbmUpICsgXCI6XCIgKyBfZShuICYmIG4uY29sdW1uKTtcbn1cbmZ1bmN0aW9uIFJlKG4pIHtcbiAgcmV0dXJuIGhlKG4gJiYgbi5zdGFydCkgKyBcIi1cIiArIGhlKG4gJiYgbi5lbmQpO1xufVxuZnVuY3Rpb24gX2Uobikge1xuICByZXR1cm4gbiAmJiB0eXBlb2YgbiA9PSBcIm51bWJlclwiID8gbiA6IDE7XG59XG5jbGFzcyBjbiBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1lc3NhZ2UgZm9yIGByZWFzb25gIGF0IGBwbGFjZWAgZnJvbSBgb3JpZ2luYC5cbiAgICpcbiAgICogV2hlbiBhbiBlcnJvciBpcyBwYXNzZWQgaW4gYXMgYHJlYXNvbmAsIHRoZSBgc3RhY2tgIGlzIGNvcGllZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBFcnJvciB8IFZGaWxlTWVzc2FnZX0gcmVhc29uXG4gICAqICAgUmVhc29uIGZvciBtZXNzYWdlLCB1c2VzIHRoZSBzdGFjayBhbmQgbWVzc2FnZSBvZiB0aGUgZXJyb3IgaWYgZ2l2ZW4uXG4gICAqXG4gICAqICAgPiDwn5GJICoqTm90ZSoqOiB5b3Ugc2hvdWxkIHVzZSBtYXJrZG93bi5cbiAgICogQHBhcmFtIHtOb2RlIHwgTm9kZUxpa2UgfCBQb3NpdGlvbiB8IFBvaW50IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3BsYWNlXVxuICAgKiAgIFBsYWNlIGluIGZpbGUgd2hlcmUgdGhlIG1lc3NhZ2Ugb2NjdXJyZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl1cbiAgICogICBQbGFjZSBpbiBjb2RlIHdoZXJlIHRoZSBtZXNzYWdlIG9yaWdpbmF0ZXMgKGV4YW1wbGU6XG4gICAqICAgYCdteS1wYWNrYWdlOm15LXJ1bGUnYCBvciBgJ215LXJ1bGUnYCkuXG4gICAqIEByZXR1cm5zXG4gICAqICAgSW5zdGFuY2Ugb2YgYFZGaWxlTWVzc2FnZWAuXG4gICAqL1xuICAvLyBUbyBkbzogbmV4dCBtYWpvcjogZXhwb3NlIGB1bmRlZmluZWRgIGV2ZXJ5d2hlcmUgaW5zdGVhZCBvZiBgbnVsbGAuXG4gIGNvbnN0cnVjdG9yKGUsIHQsIHIpIHtcbiAgICBjb25zdCBpID0gW251bGwsIG51bGxdO1xuICAgIGxldCBsID0ge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogd2UgYWx3YXlzIGZvbGxvd3MgdGhlIHN0cnVjdHVyZSBvZiBgcG9zaXRpb25gLlxuICAgICAgc3RhcnQ6IHsgbGluZTogbnVsbCwgY29sdW1uOiBudWxsIH0sXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBcIlxuICAgICAgZW5kOiB7IGxpbmU6IG51bGwsIGNvbHVtbjogbnVsbCB9XG4gICAgfTtcbiAgICBpZiAoc3VwZXIoKSwgdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiAmJiAociA9IHQsIHQgPSB2b2lkIDApLCB0eXBlb2YgciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBvID0gci5pbmRleE9mKFwiOlwiKTtcbiAgICAgIG8gPT09IC0xID8gaVsxXSA9IHIgOiAoaVswXSA9IHIuc2xpY2UoMCwgbyksIGlbMV0gPSByLnNsaWNlKG8gKyAxKSk7XG4gICAgfVxuICAgIHQgJiYgKFwidHlwZVwiIGluIHQgfHwgXCJwb3NpdGlvblwiIGluIHQgPyB0LnBvc2l0aW9uICYmIChsID0gdC5wb3NpdGlvbikgOiBcInN0YXJ0XCIgaW4gdCB8fCBcImVuZFwiIGluIHQgPyBsID0gdCA6IChcImxpbmVcIiBpbiB0IHx8IFwiY29sdW1uXCIgaW4gdCkgJiYgKGwuc3RhcnQgPSB0KSksIHRoaXMubmFtZSA9IHhyKHQpIHx8IFwiMToxXCIsIHRoaXMubWVzc2FnZSA9IHR5cGVvZiBlID09IFwib2JqZWN0XCIgPyBlLm1lc3NhZ2UgOiBlLCB0aGlzLnN0YWNrID0gXCJcIiwgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBlLnN0YWNrICYmICh0aGlzLnN0YWNrID0gZS5zdGFjayksIHRoaXMucmVhc29uID0gdGhpcy5tZXNzYWdlLCB0aGlzLmZhdGFsLCB0aGlzLmxpbmUgPSBsLnN0YXJ0LmxpbmUsIHRoaXMuY29sdW1uID0gbC5zdGFydC5jb2x1bW4sIHRoaXMucG9zaXRpb24gPSBsLCB0aGlzLnNvdXJjZSA9IGlbMF0sIHRoaXMucnVsZUlkID0gaVsxXSwgdGhpcy5maWxlLCB0aGlzLmFjdHVhbCwgdGhpcy5leHBlY3RlZCwgdGhpcy51cmwsIHRoaXMubm90ZTtcbiAgfVxufVxuY24ucHJvdG90eXBlLmZpbGUgPSBcIlwiO1xuY24ucHJvdG90eXBlLm5hbWUgPSBcIlwiO1xuY24ucHJvdG90eXBlLnJlYXNvbiA9IFwiXCI7XG5jbi5wcm90b3R5cGUubWVzc2FnZSA9IFwiXCI7XG5jbi5wcm90b3R5cGUuc3RhY2sgPSBcIlwiO1xuY24ucHJvdG90eXBlLmZhdGFsID0gbnVsbDtcbmNuLnByb3RvdHlwZS5jb2x1bW4gPSBudWxsO1xuY24ucHJvdG90eXBlLmxpbmUgPSBudWxsO1xuY24ucHJvdG90eXBlLnNvdXJjZSA9IG51bGw7XG5jbi5wcm90b3R5cGUucnVsZUlkID0gbnVsbDtcbmNuLnByb3RvdHlwZS5wb3NpdGlvbiA9IG51bGw7XG5jb25zdCBtbiA9IHsgYmFzZW5hbWU6IGtyLCBkaXJuYW1lOiBiciwgZXh0bmFtZTogd3IsIGpvaW46IFNyLCBzZXA6IFwiL1wiIH07XG5mdW5jdGlvbiBrcihuLCBlKSB7XG4gIGlmIChlICE9PSB2b2lkIDAgJiYgdHlwZW9mIGUgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4dFwiIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgSG4obik7XG4gIGxldCB0ID0gMCwgciA9IC0xLCBpID0gbi5sZW5ndGgsIGw7XG4gIGlmIChlID09PSB2b2lkIDAgfHwgZS5sZW5ndGggPT09IDAgfHwgZS5sZW5ndGggPiBuLmxlbmd0aCkge1xuICAgIGZvciAoOyBpLS07IClcbiAgICAgIGlmIChuLmNoYXJDb2RlQXQoaSkgPT09IDQ3KSB7XG4gICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgdCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgciA8IDAgJiYgKGwgPSAhMCwgciA9IGkgKyAxKTtcbiAgICByZXR1cm4gciA8IDAgPyBcIlwiIDogbi5zbGljZSh0LCByKTtcbiAgfVxuICBpZiAoZSA9PT0gbilcbiAgICByZXR1cm4gXCJcIjtcbiAgbGV0IG8gPSAtMSwgdSA9IGUubGVuZ3RoIC0gMTtcbiAgZm9yICg7IGktLTsgKVxuICAgIGlmIChuLmNoYXJDb2RlQXQoaSkgPT09IDQ3KSB7XG4gICAgICBpZiAobCkge1xuICAgICAgICB0ID0gaSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgbyA8IDAgJiYgKGwgPSAhMCwgbyA9IGkgKyAxKSwgdSA+IC0xICYmIChuLmNoYXJDb2RlQXQoaSkgPT09IGUuY2hhckNvZGVBdCh1LS0pID8gdSA8IDAgJiYgKHIgPSBpKSA6ICh1ID0gLTEsIHIgPSBvKSk7XG4gIHJldHVybiB0ID09PSByID8gciA9IG8gOiByIDwgMCAmJiAociA9IG4ubGVuZ3RoKSwgbi5zbGljZSh0LCByKTtcbn1cbmZ1bmN0aW9uIGJyKG4pIHtcbiAgaWYgKEhuKG4pLCBuLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gXCIuXCI7XG4gIGxldCBlID0gLTEsIHQgPSBuLmxlbmd0aCwgcjtcbiAgZm9yICg7IC0tdDsgKVxuICAgIGlmIChuLmNoYXJDb2RlQXQodCkgPT09IDQ3KSB7XG4gICAgICBpZiAocikge1xuICAgICAgICBlID0gdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlXG4gICAgICByIHx8IChyID0gITApO1xuICByZXR1cm4gZSA8IDAgPyBuLmNoYXJDb2RlQXQoMCkgPT09IDQ3ID8gXCIvXCIgOiBcIi5cIiA6IGUgPT09IDEgJiYgbi5jaGFyQ29kZUF0KDApID09PSA0NyA/IFwiLy9cIiA6IG4uc2xpY2UoMCwgZSk7XG59XG5mdW5jdGlvbiB3cihuKSB7XG4gIEhuKG4pO1xuICBsZXQgZSA9IG4ubGVuZ3RoLCB0ID0gLTEsIHIgPSAwLCBpID0gLTEsIGwgPSAwLCBvO1xuICBmb3IgKDsgZS0tOyApIHtcbiAgICBjb25zdCB1ID0gbi5jaGFyQ29kZUF0KGUpO1xuICAgIGlmICh1ID09PSA0Nykge1xuICAgICAgaWYgKG8pIHtcbiAgICAgICAgciA9IGUgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB0IDwgMCAmJiAobyA9ICEwLCB0ID0gZSArIDEpLCB1ID09PSA0NiA/IGkgPCAwID8gaSA9IGUgOiBsICE9PSAxICYmIChsID0gMSkgOiBpID4gLTEgJiYgKGwgPSAtMSk7XG4gIH1cbiAgcmV0dXJuIGkgPCAwIHx8IHQgPCAwIHx8IC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90LlxuICBsID09PSAwIHx8IC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5IGAuLmAuXG4gIGwgPT09IDEgJiYgaSA9PT0gdCAtIDEgJiYgaSA9PT0gciArIDEgPyBcIlwiIDogbi5zbGljZShpLCB0KTtcbn1cbmZ1bmN0aW9uIFNyKC4uLm4pIHtcbiAgbGV0IGUgPSAtMSwgdDtcbiAgZm9yICg7ICsrZSA8IG4ubGVuZ3RoOyApXG4gICAgSG4obltlXSksIG5bZV0gJiYgKHQgPSB0ID09PSB2b2lkIDAgPyBuW2VdIDogdCArIFwiL1wiICsgbltlXSk7XG4gIHJldHVybiB0ID09PSB2b2lkIDAgPyBcIi5cIiA6IEVyKHQpO1xufVxuZnVuY3Rpb24gRXIobikge1xuICBIbihuKTtcbiAgY29uc3QgZSA9IG4uY2hhckNvZGVBdCgwKSA9PT0gNDc7XG4gIGxldCB0ID0gQ3IobiwgIWUpO1xuICByZXR1cm4gdC5sZW5ndGggPT09IDAgJiYgIWUgJiYgKHQgPSBcIi5cIiksIHQubGVuZ3RoID4gMCAmJiBuLmNoYXJDb2RlQXQobi5sZW5ndGggLSAxKSA9PT0gNDcgJiYgKHQgKz0gXCIvXCIpLCBlID8gXCIvXCIgKyB0IDogdDtcbn1cbmZ1bmN0aW9uIENyKG4sIGUpIHtcbiAgbGV0IHQgPSBcIlwiLCByID0gMCwgaSA9IC0xLCBsID0gMCwgbyA9IC0xLCB1LCBhO1xuICBmb3IgKDsgKytvIDw9IG4ubGVuZ3RoOyApIHtcbiAgICBpZiAobyA8IG4ubGVuZ3RoKVxuICAgICAgdSA9IG4uY2hhckNvZGVBdChvKTtcbiAgICBlbHNlIHtcbiAgICAgIGlmICh1ID09PSA0NylcbiAgICAgICAgYnJlYWs7XG4gICAgICB1ID0gNDc7XG4gICAgfVxuICAgIGlmICh1ID09PSA0Nykge1xuICAgICAgaWYgKCEoaSA9PT0gbyAtIDEgfHwgbCA9PT0gMSkpXG4gICAgICAgIGlmIChpICE9PSBvIC0gMSAmJiBsID09PSAyKSB7XG4gICAgICAgICAgaWYgKHQubGVuZ3RoIDwgMiB8fCByICE9PSAyIHx8IHQuY2hhckNvZGVBdCh0Lmxlbmd0aCAtIDEpICE9PSA0NiB8fCB0LmNoYXJDb2RlQXQodC5sZW5ndGggLSAyKSAhPT0gNDYpIHtcbiAgICAgICAgICAgIGlmICh0Lmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgICAgaWYgKGEgPSB0Lmxhc3RJbmRleE9mKFwiL1wiKSwgYSAhPT0gdC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgYSA8IDAgPyAodCA9IFwiXCIsIHIgPSAwKSA6ICh0ID0gdC5zbGljZSgwLCBhKSwgciA9IHQubGVuZ3RoIC0gMSAtIHQubGFzdEluZGV4T2YoXCIvXCIpKSwgaSA9IG8sIGwgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICB0ID0gXCJcIiwgciA9IDAsIGkgPSBvLCBsID0gMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGUgJiYgKHQgPSB0Lmxlbmd0aCA+IDAgPyB0ICsgXCIvLi5cIiA6IFwiLi5cIiwgciA9IDIpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB0Lmxlbmd0aCA+IDAgPyB0ICs9IFwiL1wiICsgbi5zbGljZShpICsgMSwgbykgOiB0ID0gbi5zbGljZShpICsgMSwgbyksIHIgPSBvIC0gaSAtIDE7XG4gICAgICBpID0gbywgbCA9IDA7XG4gICAgfSBlbHNlXG4gICAgICB1ID09PSA0NiAmJiBsID4gLTEgPyBsKysgOiBsID0gLTE7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBIbihuKSB7XG4gIGlmICh0eXBlb2YgbiAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIlBhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgXCIgKyBKU09OLnN0cmluZ2lmeShuKVxuICAgICk7XG59XG5jb25zdCBBciA9IHsgY3dkOiBQciB9O1xuZnVuY3Rpb24gUHIoKSB7XG4gIHJldHVybiBcIi9cIjtcbn1cbmZ1bmN0aW9uIG1lKG4pIHtcbiAgcmV0dXJuIG4gIT09IG51bGwgJiYgdHlwZW9mIG4gPT0gXCJvYmplY3RcIiAmJiAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbmRleGFibGUuXG4gIG4uaHJlZiAmJiAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbmRleGFibGUuXG4gIG4ub3JpZ2luO1xufVxuZnVuY3Rpb24gRnIobikge1xuICBpZiAodHlwZW9mIG4gPT0gXCJzdHJpbmdcIilcbiAgICBuID0gbmV3IFVSTChuKTtcbiAgZWxzZSBpZiAoIW1lKG4pKSB7XG4gICAgY29uc3QgZSA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwicGF0aFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcgb3IgYW4gaW5zdGFuY2Ugb2YgVVJMLiBSZWNlaXZlZCBgJyArIG4gKyBcImBcIlxuICAgICk7XG4gICAgdGhyb3cgZS5jb2RlID0gXCJFUlJfSU5WQUxJRF9BUkdfVFlQRVwiLCBlO1xuICB9XG4gIGlmIChuLnByb3RvY29sICE9PSBcImZpbGU6XCIpIHtcbiAgICBjb25zdCBlID0gbmV3IFR5cGVFcnJvcihcIlRoZSBVUkwgbXVzdCBiZSBvZiBzY2hlbWUgZmlsZVwiKTtcbiAgICB0aHJvdyBlLmNvZGUgPSBcIkVSUl9JTlZBTElEX1VSTF9TQ0hFTUVcIiwgZTtcbiAgfVxuICByZXR1cm4gVHIobik7XG59XG5mdW5jdGlvbiBUcihuKSB7XG4gIGlmIChuLmhvc3RuYW1lICE9PSBcIlwiKSB7XG4gICAgY29uc3QgciA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnRmlsZSBVUkwgaG9zdCBtdXN0IGJlIFwibG9jYWxob3N0XCIgb3IgZW1wdHkgb24gZGFyd2luJ1xuICAgICk7XG4gICAgdGhyb3cgci5jb2RlID0gXCJFUlJfSU5WQUxJRF9GSUxFX1VSTF9IT1NUXCIsIHI7XG4gIH1cbiAgY29uc3QgZSA9IG4ucGF0aG5hbWU7XG4gIGxldCB0ID0gLTE7XG4gIGZvciAoOyArK3QgPCBlLmxlbmd0aDsgKVxuICAgIGlmIChlLmNoYXJDb2RlQXQodCkgPT09IDM3ICYmIGUuY2hhckNvZGVBdCh0ICsgMSkgPT09IDUwKSB7XG4gICAgICBjb25zdCByID0gZS5jaGFyQ29kZUF0KHQgKyAyKTtcbiAgICAgIGlmIChyID09PSA3MCB8fCByID09PSAxMDIpIHtcbiAgICAgICAgY29uc3QgaSA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJGaWxlIFVSTCBwYXRoIG11c3Qgbm90IGluY2x1ZGUgZW5jb2RlZCAvIGNoYXJhY3RlcnNcIlxuICAgICAgICApO1xuICAgICAgICB0aHJvdyBpLmNvZGUgPSBcIkVSUl9JTlZBTElEX0ZJTEVfVVJMX1BBVEhcIiwgaTtcbiAgICAgIH1cbiAgICB9XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZSk7XG59XG5jb25zdCByZSA9IFtcImhpc3RvcnlcIiwgXCJwYXRoXCIsIFwiYmFzZW5hbWVcIiwgXCJzdGVtXCIsIFwiZXh0bmFtZVwiLCBcImRpcm5hbWVcIl07XG5jbGFzcyBGdCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgdmlydHVhbCBmaWxlLlxuICAgKlxuICAgKiBgb3B0aW9uc2AgaXMgdHJlYXRlZCBhczpcbiAgICpcbiAgICogKiAgIGBzdHJpbmdgIG9yIGBCdWZmZXJgIOKAlCBge3ZhbHVlOiBvcHRpb25zfWBcbiAgICogKiAgIGBVUkxgIOKAlCBge3BhdGg6IG9wdGlvbnN9YFxuICAgKiAqICAgYFZGaWxlYCDigJQgc2hhbGxvdyBjb3BpZXMgaXRzIGRhdGEgb3ZlciB0byB0aGUgbmV3IGZpbGVcbiAgICogKiAgIGBvYmplY3RgIOKAlCBhbGwgZmllbGRzIGFyZSBzaGFsbG93IGNvcGllZCBvdmVyIHRvIHRoZSBuZXcgZmlsZVxuICAgKlxuICAgKiBQYXRoIHJlbGF0ZWQgZmllbGRzIGFyZSBzZXQgaW4gdGhlIGZvbGxvd2luZyBvcmRlciAobGVhc3Qgc3BlY2lmaWMgdG9cbiAgICogbW9zdCBzcGVjaWZpYyk6IGBoaXN0b3J5YCwgYHBhdGhgLCBgYmFzZW5hbWVgLCBgc3RlbWAsIGBleHRuYW1lYCxcbiAgICogYGRpcm5hbWVgLlxuICAgKlxuICAgKiBZb3UgY2Fubm90IHNldCBgZGlybmFtZWAgb3IgYGV4dG5hbWVgIHdpdGhvdXQgc2V0dGluZyBlaXRoZXIgYGhpc3RvcnlgLFxuICAgKiBgcGF0aGAsIGBiYXNlbmFtZWAsIG9yIGBzdGVtYCB0b28uXG4gICAqXG4gICAqIEBwYXJhbSB7Q29tcGF0aWJsZSB8IG51bGwgfCB1bmRlZmluZWR9IFt2YWx1ZV1cbiAgICogICBGaWxlIHZhbHVlLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgIE5ldyBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBsZXQgdDtcbiAgICBlID8gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiB8fCBJcihlKSA/IHQgPSB7IHZhbHVlOiBlIH0gOiBtZShlKSA/IHQgPSB7IHBhdGg6IGUgfSA6IHQgPSBlIDogdCA9IHt9LCB0aGlzLmRhdGEgPSB7fSwgdGhpcy5tZXNzYWdlcyA9IFtdLCB0aGlzLmhpc3RvcnkgPSBbXSwgdGhpcy5jd2QgPSBBci5jd2QoKSwgdGhpcy52YWx1ZSwgdGhpcy5zdG9yZWQsIHRoaXMucmVzdWx0LCB0aGlzLm1hcDtcbiAgICBsZXQgciA9IC0xO1xuICAgIGZvciAoOyArK3IgPCByZS5sZW5ndGg7ICkge1xuICAgICAgY29uc3QgbCA9IHJlW3JdO1xuICAgICAgbCBpbiB0ICYmIHRbbF0gIT09IHZvaWQgMCAmJiB0W2xdICE9PSBudWxsICYmICh0aGlzW2xdID0gbCA9PT0gXCJoaXN0b3J5XCIgPyBbLi4udFtsXV0gOiB0W2xdKTtcbiAgICB9XG4gICAgbGV0IGk7XG4gICAgZm9yIChpIGluIHQpXG4gICAgICByZS5pbmNsdWRlcyhpKSB8fCAodGhpc1tpXSA9IHRbaV0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGZ1bGwgcGF0aCAoZXhhbXBsZTogYCd+L2luZGV4Lm1pbi5qcydgKS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldCBwYXRoKCkge1xuICAgIHJldHVybiB0aGlzLmhpc3RvcnlbdGhpcy5oaXN0b3J5Lmxlbmd0aCAtIDFdO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIGZ1bGwgcGF0aCAoZXhhbXBsZTogYCd+L2luZGV4Lm1pbi5qcydgKS5cbiAgICpcbiAgICogQ2Fubm90IGJlIG51bGxpZmllZC5cbiAgICogWW91IGNhbiBzZXQgYSBmaWxlIFVSTCAoYSBgVVJMYCBvYmplY3Qgd2l0aCBhIGBmaWxlOmAgcHJvdG9jb2wpIHdoaWNoIHdpbGxcbiAgICogYmUgdHVybmVkIGludG8gYSBwYXRoIHdpdGggYHVybC5maWxlVVJMVG9QYXRoYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBVUkx9IHBhdGhcbiAgICovXG4gIHNldCBwYXRoKGUpIHtcbiAgICBtZShlKSAmJiAoZSA9IEZyKGUpKSwgbGUoZSwgXCJwYXRoXCIpLCB0aGlzLnBhdGggIT09IGUgJiYgdGhpcy5oaXN0b3J5LnB1c2goZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgcGFyZW50IHBhdGggKGV4YW1wbGU6IGAnfidgKS5cbiAgICovXG4gIGdldCBkaXJuYW1lKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5wYXRoID09IFwic3RyaW5nXCIgPyBtbi5kaXJuYW1lKHRoaXMucGF0aCkgOiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgcGFyZW50IHBhdGggKGV4YW1wbGU6IGAnfidgKS5cbiAgICpcbiAgICogQ2Fubm90IGJlIHNldCBpZiB0aGVyZeKAmXMgbm8gYHBhdGhgIHlldC5cbiAgICovXG4gIHNldCBkaXJuYW1lKGUpIHtcbiAgICBNZSh0aGlzLmJhc2VuYW1lLCBcImRpcm5hbWVcIiksIHRoaXMucGF0aCA9IG1uLmpvaW4oZSB8fCBcIlwiLCB0aGlzLmJhc2VuYW1lKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBiYXNlbmFtZSAoaW5jbHVkaW5nIGV4dG5hbWUpIChleGFtcGxlOiBgJ2luZGV4Lm1pbi5qcydgKS5cbiAgICovXG4gIGdldCBiYXNlbmFtZSgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMucGF0aCA9PSBcInN0cmluZ1wiID8gbW4uYmFzZW5hbWUodGhpcy5wYXRoKSA6IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0IGJhc2VuYW1lIChpbmNsdWRpbmcgZXh0bmFtZSkgKGAnaW5kZXgubWluLmpzJ2ApLlxuICAgKlxuICAgKiBDYW5ub3QgY29udGFpbiBwYXRoIHNlcGFyYXRvcnMgKGAnLydgIG9uIHVuaXgsIG1hY09TLCBhbmQgYnJvd3NlcnMsIGAnXFwnYFxuICAgKiBvbiB3aW5kb3dzKS5cbiAgICogQ2Fubm90IGJlIG51bGxpZmllZCAodXNlIGBmaWxlLnBhdGggPSBmaWxlLmRpcm5hbWVgIGluc3RlYWQpLlxuICAgKi9cbiAgc2V0IGJhc2VuYW1lKGUpIHtcbiAgICBsZShlLCBcImJhc2VuYW1lXCIpLCBpZShlLCBcImJhc2VuYW1lXCIpLCB0aGlzLnBhdGggPSBtbi5qb2luKHRoaXMuZGlybmFtZSB8fCBcIlwiLCBlKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBleHRuYW1lIChpbmNsdWRpbmcgZG90KSAoZXhhbXBsZTogYCcuanMnYCkuXG4gICAqL1xuICBnZXQgZXh0bmFtZSgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMucGF0aCA9PSBcInN0cmluZ1wiID8gbW4uZXh0bmFtZSh0aGlzLnBhdGgpIDogdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgdGhlIGV4dG5hbWUgKGluY2x1ZGluZyBkb3QpIChleGFtcGxlOiBgJy5qcydgKS5cbiAgICpcbiAgICogQ2Fubm90IGNvbnRhaW4gcGF0aCBzZXBhcmF0b3JzIChgJy8nYCBvbiB1bml4LCBtYWNPUywgYW5kIGJyb3dzZXJzLCBgJ1xcJ2BcbiAgICogb24gd2luZG93cykuXG4gICAqIENhbm5vdCBiZSBzZXQgaWYgdGhlcmXigJlzIG5vIGBwYXRoYCB5ZXQuXG4gICAqL1xuICBzZXQgZXh0bmFtZShlKSB7XG4gICAgaWYgKGllKGUsIFwiZXh0bmFtZVwiKSwgTWUodGhpcy5kaXJuYW1lLCBcImV4dG5hbWVcIiksIGUpIHtcbiAgICAgIGlmIChlLmNoYXJDb2RlQXQoMCkgIT09IDQ2KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZXh0bmFtZWAgbXVzdCBzdGFydCB3aXRoIGAuYFwiKTtcbiAgICAgIGlmIChlLmluY2x1ZGVzKFwiLlwiLCAxKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYGV4dG5hbWVgIGNhbm5vdCBjb250YWluIG11bHRpcGxlIGRvdHNcIik7XG4gICAgfVxuICAgIHRoaXMucGF0aCA9IG1uLmpvaW4odGhpcy5kaXJuYW1lLCB0aGlzLnN0ZW0gKyAoZSB8fCBcIlwiKSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RlbSAoYmFzZW5hbWUgdy9vIGV4dG5hbWUpIChleGFtcGxlOiBgJ2luZGV4Lm1pbidgKS5cbiAgICovXG4gIGdldCBzdGVtKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5wYXRoID09IFwic3RyaW5nXCIgPyBtbi5iYXNlbmFtZSh0aGlzLnBhdGgsIHRoaXMuZXh0bmFtZSkgOiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgc3RlbSAoYmFzZW5hbWUgdy9vIGV4dG5hbWUpIChleGFtcGxlOiBgJ2luZGV4Lm1pbidgKS5cbiAgICpcbiAgICogQ2Fubm90IGNvbnRhaW4gcGF0aCBzZXBhcmF0b3JzIChgJy8nYCBvbiB1bml4LCBtYWNPUywgYW5kIGJyb3dzZXJzLCBgJ1xcJ2BcbiAgICogb24gd2luZG93cykuXG4gICAqIENhbm5vdCBiZSBudWxsaWZpZWQgKHVzZSBgZmlsZS5wYXRoID0gZmlsZS5kaXJuYW1lYCBpbnN0ZWFkKS5cbiAgICovXG4gIHNldCBzdGVtKGUpIHtcbiAgICBsZShlLCBcInN0ZW1cIiksIGllKGUsIFwic3RlbVwiKSwgdGhpcy5wYXRoID0gbW4uam9pbih0aGlzLmRpcm5hbWUgfHwgXCJcIiwgZSArICh0aGlzLmV4dG5hbWUgfHwgXCJcIikpO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyRW5jb2RpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbZW5jb2Rpbmc9J3V0ZjgnXVxuICAgKiAgIENoYXJhY3RlciBlbmNvZGluZyB0byB1bmRlcnN0YW5kIGB2YWx1ZWAgYXMgd2hlbiBpdOKAmXMgYSBgQnVmZmVyYFxuICAgKiAgIChkZWZhdWx0OiBgJ3V0ZjgnYCkuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqICAgU2VyaWFsaXplZCBmaWxlLlxuICAgKi9cbiAgdG9TdHJpbmcoZSkge1xuICAgIHJldHVybiAodGhpcy52YWx1ZSB8fCBcIlwiKS50b1N0cmluZyhlIHx8IHZvaWQgMCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHdhcm5pbmcgbWVzc2FnZSBhc3NvY2lhdGVkIHdpdGggdGhlIGZpbGUuXG4gICAqXG4gICAqIEl0cyBgZmF0YWxgIGlzIHNldCB0byBgZmFsc2VgIGFuZCBgZmlsZWAgaXMgc2V0IHRvIHRoZSBjdXJyZW50IGZpbGUgcGF0aC5cbiAgICogSXRzIGFkZGVkIHRvIGBmaWxlLm1lc3NhZ2VzYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBFcnJvciB8IFZGaWxlTWVzc2FnZX0gcmVhc29uXG4gICAqICAgUmVhc29uIGZvciBtZXNzYWdlLCB1c2VzIHRoZSBzdGFjayBhbmQgbWVzc2FnZSBvZiB0aGUgZXJyb3IgaWYgZ2l2ZW4uXG4gICAqIEBwYXJhbSB7Tm9kZSB8IE5vZGVMaWtlIHwgUG9zaXRpb24gfCBQb2ludCB8IG51bGwgfCB1bmRlZmluZWR9IFtwbGFjZV1cbiAgICogICBQbGFjZSBpbiBmaWxlIHdoZXJlIHRoZSBtZXNzYWdlIG9jY3VycmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtvcmlnaW5dXG4gICAqICAgUGxhY2UgaW4gY29kZSB3aGVyZSB0aGUgbWVzc2FnZSBvcmlnaW5hdGVzIChleGFtcGxlOlxuICAgKiAgIGAnbXktcGFja2FnZTpteS1ydWxlJ2Agb3IgYCdteS1ydWxlJ2ApLlxuICAgKiBAcmV0dXJucyB7VkZpbGVNZXNzYWdlfVxuICAgKiAgIE1lc3NhZ2UuXG4gICAqL1xuICBtZXNzYWdlKGUsIHQsIHIpIHtcbiAgICBjb25zdCBpID0gbmV3IGNuKGUsIHQsIHIpO1xuICAgIHJldHVybiB0aGlzLnBhdGggJiYgKGkubmFtZSA9IHRoaXMucGF0aCArIFwiOlwiICsgaS5uYW1lLCBpLmZpbGUgPSB0aGlzLnBhdGgpLCBpLmZhdGFsID0gITEsIHRoaXMubWVzc2FnZXMucHVzaChpKSwgaTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGFuIGluZm8gbWVzc2FnZSBhc3NvY2lhdGVkIHdpdGggdGhlIGZpbGUuXG4gICAqXG4gICAqIEl0cyBgZmF0YWxgIGlzIHNldCB0byBgbnVsbGAgYW5kIGBmaWxlYCBpcyBzZXQgdG8gdGhlIGN1cnJlbnQgZmlsZSBwYXRoLlxuICAgKiBJdHMgYWRkZWQgdG8gYGZpbGUubWVzc2FnZXNgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IEVycm9yIHwgVkZpbGVNZXNzYWdlfSByZWFzb25cbiAgICogICBSZWFzb24gZm9yIG1lc3NhZ2UsIHVzZXMgdGhlIHN0YWNrIGFuZCBtZXNzYWdlIG9mIHRoZSBlcnJvciBpZiBnaXZlbi5cbiAgICogQHBhcmFtIHtOb2RlIHwgTm9kZUxpa2UgfCBQb3NpdGlvbiB8IFBvaW50IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3BsYWNlXVxuICAgKiAgIFBsYWNlIGluIGZpbGUgd2hlcmUgdGhlIG1lc3NhZ2Ugb2NjdXJyZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl1cbiAgICogICBQbGFjZSBpbiBjb2RlIHdoZXJlIHRoZSBtZXNzYWdlIG9yaWdpbmF0ZXMgKGV4YW1wbGU6XG4gICAqICAgYCdteS1wYWNrYWdlOm15LXJ1bGUnYCBvciBgJ215LXJ1bGUnYCkuXG4gICAqIEByZXR1cm5zIHtWRmlsZU1lc3NhZ2V9XG4gICAqICAgTWVzc2FnZS5cbiAgICovXG4gIGluZm8oZSwgdCwgcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLm1lc3NhZ2UoZSwgdCwgcik7XG4gICAgcmV0dXJuIGkuZmF0YWwgPSBudWxsLCBpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmYXRhbCBlcnJvciBhc3NvY2lhdGVkIHdpdGggdGhlIGZpbGUuXG4gICAqXG4gICAqIEl0cyBgZmF0YWxgIGlzIHNldCB0byBgdHJ1ZWAgYW5kIGBmaWxlYCBpcyBzZXQgdG8gdGhlIGN1cnJlbnQgZmlsZSBwYXRoLlxuICAgKiBJdHMgYWRkZWQgdG8gYGZpbGUubWVzc2FnZXNgLlxuICAgKlxuICAgKiA+IPCfkYkgKipOb3RlKio6IGEgZmF0YWwgZXJyb3IgbWVhbnMgdGhhdCBhIGZpbGUgaXMgbm8gbG9uZ2VyIHByb2Nlc3NhYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IEVycm9yIHwgVkZpbGVNZXNzYWdlfSByZWFzb25cbiAgICogICBSZWFzb24gZm9yIG1lc3NhZ2UsIHVzZXMgdGhlIHN0YWNrIGFuZCBtZXNzYWdlIG9mIHRoZSBlcnJvciBpZiBnaXZlbi5cbiAgICogQHBhcmFtIHtOb2RlIHwgTm9kZUxpa2UgfCBQb3NpdGlvbiB8IFBvaW50IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3BsYWNlXVxuICAgKiAgIFBsYWNlIGluIGZpbGUgd2hlcmUgdGhlIG1lc3NhZ2Ugb2NjdXJyZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl1cbiAgICogICBQbGFjZSBpbiBjb2RlIHdoZXJlIHRoZSBtZXNzYWdlIG9yaWdpbmF0ZXMgKGV4YW1wbGU6XG4gICAqICAgYCdteS1wYWNrYWdlOm15LXJ1bGUnYCBvciBgJ215LXJ1bGUnYCkuXG4gICAqIEByZXR1cm5zIHtuZXZlcn1cbiAgICogICBNZXNzYWdlLlxuICAgKiBAdGhyb3dzIHtWRmlsZU1lc3NhZ2V9XG4gICAqICAgTWVzc2FnZS5cbiAgICovXG4gIGZhaWwoZSwgdCwgcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLm1lc3NhZ2UoZSwgdCwgcik7XG4gICAgdGhyb3cgaS5mYXRhbCA9ICEwLCBpO1xuICB9XG59XG5mdW5jdGlvbiBpZShuLCBlKSB7XG4gIGlmIChuICYmIG4uaW5jbHVkZXMobW4uc2VwKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImBcIiArIGUgKyBcImAgY2Fubm90IGJlIGEgcGF0aDogZGlkIG5vdCBleHBlY3QgYFwiICsgbW4uc2VwICsgXCJgXCJcbiAgICApO1xufVxuZnVuY3Rpb24gbGUobiwgZSkge1xuICBpZiAoIW4pXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYFwiICsgZSArIFwiYCBjYW5ub3QgYmUgZW1wdHlcIik7XG59XG5mdW5jdGlvbiBNZShuLCBlKSB7XG4gIGlmICghbilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXR0aW5nIGBcIiArIGUgKyBcImAgcmVxdWlyZXMgYHBhdGhgIHRvIGJlIHNldCB0b29cIik7XG59XG5mdW5jdGlvbiBJcihuKSB7XG4gIHJldHVybiBQdChuKTtcbn1cbmZ1bmN0aW9uIEJlKG4pIHtcbiAgaWYgKG4pXG4gICAgdGhyb3cgbjtcbn1cbnZhciBZbiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIFR0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZywgTmUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHksIGplID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciwgJGUgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiB0eXBlb2YgQXJyYXkuaXNBcnJheSA9PSBcImZ1bmN0aW9uXCIgPyBBcnJheS5pc0FycmF5KGUpIDogVHQuY2FsbChlKSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiO1xufSwgSGUgPSBmdW5jdGlvbihlKSB7XG4gIGlmICghZSB8fCBUdC5jYWxsKGUpICE9PSBcIltvYmplY3QgT2JqZWN0XVwiKVxuICAgIHJldHVybiAhMTtcbiAgdmFyIHQgPSBZbi5jYWxsKGUsIFwiY29uc3RydWN0b3JcIiksIHIgPSBlLmNvbnN0cnVjdG9yICYmIGUuY29uc3RydWN0b3IucHJvdG90eXBlICYmIFluLmNhbGwoZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIFwiaXNQcm90b3R5cGVPZlwiKTtcbiAgaWYgKGUuY29uc3RydWN0b3IgJiYgIXQgJiYgIXIpXG4gICAgcmV0dXJuICExO1xuICB2YXIgaTtcbiAgZm9yIChpIGluIGUpXG4gICAgO1xuICByZXR1cm4gdHlwZW9mIGkgPiBcInVcIiB8fCBZbi5jYWxsKGUsIGkpO1xufSwgVWUgPSBmdW5jdGlvbihlLCB0KSB7XG4gIE5lICYmIHQubmFtZSA9PT0gXCJfX3Byb3RvX19cIiA/IE5lKGUsIHQubmFtZSwge1xuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgdmFsdWU6IHQubmV3VmFsdWUsXG4gICAgd3JpdGFibGU6ICEwXG4gIH0pIDogZVt0Lm5hbWVdID0gdC5uZXdWYWx1ZTtcbn0sIFZlID0gZnVuY3Rpb24oZSwgdCkge1xuICBpZiAodCA9PT0gXCJfX3Byb3RvX19cIilcbiAgICBpZiAoWW4uY2FsbChlLCB0KSkge1xuICAgICAgaWYgKGplKVxuICAgICAgICByZXR1cm4gamUoZSwgdCkudmFsdWU7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm47XG4gIHJldHVybiBlW3RdO1xufSwgcWUgPSBmdW5jdGlvbiBuKCkge1xuICB2YXIgZSwgdCwgciwgaSwgbCwgbywgdSA9IGFyZ3VtZW50c1swXSwgYSA9IDEsIGMgPSBhcmd1bWVudHMubGVuZ3RoLCBzID0gITE7XG4gIGZvciAodHlwZW9mIHUgPT0gXCJib29sZWFuXCIgJiYgKHMgPSB1LCB1ID0gYXJndW1lbnRzWzFdIHx8IHt9LCBhID0gMiksICh1ID09IG51bGwgfHwgdHlwZW9mIHUgIT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdSAhPSBcImZ1bmN0aW9uXCIpICYmICh1ID0ge30pOyBhIDwgYzsgKythKVxuICAgIGlmIChlID0gYXJndW1lbnRzW2FdLCBlICE9IG51bGwpXG4gICAgICBmb3IgKHQgaW4gZSlcbiAgICAgICAgciA9IFZlKHUsIHQpLCBpID0gVmUoZSwgdCksIHUgIT09IGkgJiYgKHMgJiYgaSAmJiAoSGUoaSkgfHwgKGwgPSAkZShpKSkpID8gKGwgPyAobCA9ICExLCBvID0gciAmJiAkZShyKSA/IHIgOiBbXSkgOiBvID0gciAmJiBIZShyKSA/IHIgOiB7fSwgVWUodSwgeyBuYW1lOiB0LCBuZXdWYWx1ZTogbihzLCBvLCBpKSB9KSkgOiB0eXBlb2YgaSA8IFwidVwiICYmIFVlKHUsIHsgbmFtZTogdCwgbmV3VmFsdWU6IGkgfSkpO1xuICByZXR1cm4gdTtcbn07XG5mdW5jdGlvbiBkZShuKSB7XG4gIGlmICh0eXBlb2YgbiAhPSBcIm9iamVjdFwiIHx8IG4gPT09IG51bGwpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pO1xuICByZXR1cm4gKGUgPT09IG51bGwgfHwgZSA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkgPT09IG51bGwpICYmICEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIG4pICYmICEoU3ltYm9sLml0ZXJhdG9yIGluIG4pO1xufVxuZnVuY3Rpb24gT3IoKSB7XG4gIGNvbnN0IG4gPSBbXSwgZSA9IHsgcnVuOiB0LCB1c2U6IHIgfTtcbiAgcmV0dXJuIGU7XG4gIGZ1bmN0aW9uIHQoLi4uaSkge1xuICAgIGxldCBsID0gLTE7XG4gICAgY29uc3QgbyA9IGkucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBvICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBmdW5jdGlvbiBhcyBsYXN0IGFyZ3VtZW50LCBub3QgXCIgKyBvKTtcbiAgICB1KG51bGwsIC4uLmkpO1xuICAgIGZ1bmN0aW9uIHUoYSwgLi4uYykge1xuICAgICAgY29uc3QgcyA9IG5bKytsXTtcbiAgICAgIGxldCBoID0gLTE7XG4gICAgICBpZiAoYSkge1xuICAgICAgICBvKGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKDsgKytoIDwgaS5sZW5ndGg7IClcbiAgICAgICAgKGNbaF0gPT09IG51bGwgfHwgY1toXSA9PT0gdm9pZCAwKSAmJiAoY1toXSA9IGlbaF0pO1xuICAgICAgaSA9IGMsIHMgPyBMcihzLCB1KSguLi5jKSA6IG8obnVsbCwgLi4uYyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHIoaSkge1xuICAgIGlmICh0eXBlb2YgaSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIkV4cGVjdGVkIGBtaWRkZWx3YXJlYCB0byBiZSBhIGZ1bmN0aW9uLCBub3QgXCIgKyBpXG4gICAgICApO1xuICAgIHJldHVybiBuLnB1c2goaSksIGU7XG4gIH1cbn1cbmZ1bmN0aW9uIExyKG4sIGUpIHtcbiAgbGV0IHQ7XG4gIHJldHVybiByO1xuICBmdW5jdGlvbiByKC4uLm8pIHtcbiAgICBjb25zdCB1ID0gbi5sZW5ndGggPiBvLmxlbmd0aDtcbiAgICBsZXQgYTtcbiAgICB1ICYmIG8ucHVzaChpKTtcbiAgICB0cnkge1xuICAgICAgYSA9IG4uYXBwbHkodGhpcywgbyk7XG4gICAgfSBjYXRjaCAoYykge1xuICAgICAgY29uc3QgcyA9IChcbiAgICAgICAgLyoqIEB0eXBlIHtFcnJvcn0gKi9cbiAgICAgICAgY1xuICAgICAgKTtcbiAgICAgIGlmICh1ICYmIHQpXG4gICAgICAgIHRocm93IHM7XG4gICAgICByZXR1cm4gaShzKTtcbiAgICB9XG4gICAgdSB8fCAoYSBpbnN0YW5jZW9mIFByb21pc2UgPyBhLnRoZW4obCwgaSkgOiBhIGluc3RhbmNlb2YgRXJyb3IgPyBpKGEpIDogbChhKSk7XG4gIH1cbiAgZnVuY3Rpb24gaShvLCAuLi51KSB7XG4gICAgdCB8fCAodCA9ICEwLCBlKG8sIC4uLnUpKTtcbiAgfVxuICBmdW5jdGlvbiBsKG8pIHtcbiAgICBpKG51bGwsIG8pO1xuICB9XG59XG5jb25zdCBEciA9IE90KCkuZnJlZXplKCksIEl0ID0ge30uaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBPdCgpIHtcbiAgY29uc3QgbiA9IE9yKCksIGUgPSBbXTtcbiAgbGV0IHQgPSB7fSwgciwgaSA9IC0xO1xuICByZXR1cm4gbC5kYXRhID0gbywgbC5QYXJzZXIgPSB2b2lkIDAsIGwuQ29tcGlsZXIgPSB2b2lkIDAsIGwuZnJlZXplID0gdSwgbC5hdHRhY2hlcnMgPSBlLCBsLnVzZSA9IGEsIGwucGFyc2UgPSBjLCBsLnN0cmluZ2lmeSA9IHMsIGwucnVuID0gaCwgbC5ydW5TeW5jID0gZywgbC5wcm9jZXNzID0gZCwgbC5wcm9jZXNzU3luYyA9IG0sIGw7XG4gIGZ1bmN0aW9uIGwoKSB7XG4gICAgY29uc3QgeSA9IE90KCk7XG4gICAgbGV0IHggPSAtMTtcbiAgICBmb3IgKDsgKyt4IDwgZS5sZW5ndGg7IClcbiAgICAgIHkudXNlKC4uLmVbeF0pO1xuICAgIHJldHVybiB5LmRhdGEocWUoITAsIHt9LCB0KSksIHk7XG4gIH1cbiAgZnVuY3Rpb24gbyh5LCB4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB5ID09IFwic3RyaW5nXCIgPyBhcmd1bWVudHMubGVuZ3RoID09PSAyID8gKGFlKFwiZGF0YVwiLCByKSwgdFt5XSA9IHgsIGwpIDogSXQuY2FsbCh0LCB5KSAmJiB0W3ldIHx8IG51bGwgOiB5ID8gKGFlKFwiZGF0YVwiLCByKSwgdCA9IHksIGwpIDogdDtcbiAgfVxuICBmdW5jdGlvbiB1KCkge1xuICAgIGlmIChyKVxuICAgICAgcmV0dXJuIGw7XG4gICAgZm9yICg7ICsraSA8IGUubGVuZ3RoOyApIHtcbiAgICAgIGNvbnN0IFt5LCAuLi54XSA9IGVbaV07XG4gICAgICBpZiAoeFswXSA9PT0gITEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgeFswXSA9PT0gITAgJiYgKHhbMF0gPSB2b2lkIDApO1xuICAgICAgY29uc3QgdyA9IHkuY2FsbChsLCAuLi54KTtcbiAgICAgIHR5cGVvZiB3ID09IFwiZnVuY3Rpb25cIiAmJiBuLnVzZSh3KTtcbiAgICB9XG4gICAgcmV0dXJuIHIgPSAhMCwgaSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgbDtcbiAgfVxuICBmdW5jdGlvbiBhKHksIC4uLngpIHtcbiAgICBsZXQgdztcbiAgICBpZiAoYWUoXCJ1c2VcIiwgciksIHkgIT0gbnVsbClcbiAgICAgIGlmICh0eXBlb2YgeSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIFQoeSwgLi4ueCk7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgeSA9PSBcIm9iamVjdFwiKVxuICAgICAgICBBcnJheS5pc0FycmF5KHkpID8gXyh5KSA6IEEoeSk7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB1c2FibGUgdmFsdWUsIG5vdCBgXCIgKyB5ICsgXCJgXCIpO1xuICAgIHJldHVybiB3ICYmICh0LnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih0LnNldHRpbmdzIHx8IHt9LCB3KSksIGw7XG4gICAgZnVuY3Rpb24gdihiKSB7XG4gICAgICBpZiAodHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBUKGIpO1xuICAgICAgZWxzZSBpZiAodHlwZW9mIGIgPT0gXCJvYmplY3RcIilcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgICBjb25zdCBbSSwgLi4uUl0gPSBiO1xuICAgICAgICAgIFQoSSwgLi4uUik7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIEEoYik7XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB1c2FibGUgdmFsdWUsIG5vdCBgXCIgKyBiICsgXCJgXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBBKGIpIHtcbiAgICAgIF8oYi5wbHVnaW5zKSwgYi5zZXR0aW5ncyAmJiAodyA9IE9iamVjdC5hc3NpZ24odyB8fCB7fSwgYi5zZXR0aW5ncykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfKGIpIHtcbiAgICAgIGxldCBJID0gLTE7XG4gICAgICBpZiAoYiAhPSBudWxsKVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSlcbiAgICAgICAgICBmb3IgKDsgKytJIDwgYi5sZW5ndGg7ICkge1xuICAgICAgICAgICAgY29uc3QgUiA9IGJbSV07XG4gICAgICAgICAgICB2KFIpO1xuICAgICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIGxpc3Qgb2YgcGx1Z2lucywgbm90IGBcIiArIGIgKyBcImBcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFQoYiwgSSkge1xuICAgICAgbGV0IFIgPSAtMSwgTTtcbiAgICAgIGZvciAoOyArK1IgPCBlLmxlbmd0aDsgKVxuICAgICAgICBpZiAoZVtSXVswXSA9PT0gYikge1xuICAgICAgICAgIE0gPSBlW1JdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBNID8gKGRlKE1bMV0pICYmIGRlKEkpICYmIChJID0gcWUoITAsIE1bMV0sIEkpKSwgTVsxXSA9IEkpIDogZS5wdXNoKFsuLi5hcmd1bWVudHNdKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYyh5KSB7XG4gICAgbC5mcmVlemUoKTtcbiAgICBjb25zdCB4ID0gam4oeSksIHcgPSBsLlBhcnNlcjtcbiAgICByZXR1cm4gb2UoXCJwYXJzZVwiLCB3KSwgV2UodywgXCJwYXJzZVwiKSA/IG5ldyB3KFN0cmluZyh4KSwgeCkucGFyc2UoKSA6IHcoU3RyaW5nKHgpLCB4KTtcbiAgfVxuICBmdW5jdGlvbiBzKHksIHgpIHtcbiAgICBsLmZyZWV6ZSgpO1xuICAgIGNvbnN0IHcgPSBqbih4KSwgdiA9IGwuQ29tcGlsZXI7XG4gICAgcmV0dXJuIHVlKFwic3RyaW5naWZ5XCIsIHYpLCBZZSh5KSwgV2UodiwgXCJjb21waWxlXCIpID8gbmV3IHYoeSwgdykuY29tcGlsZSgpIDogdih5LCB3KTtcbiAgfVxuICBmdW5jdGlvbiBoKHksIHgsIHcpIHtcbiAgICBpZiAoWWUoeSksIGwuZnJlZXplKCksICF3ICYmIHR5cGVvZiB4ID09IFwiZnVuY3Rpb25cIiAmJiAodyA9IHgsIHggPSB2b2lkIDApLCAhdylcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSh2KTtcbiAgICB2KG51bGwsIHcpO1xuICAgIGZ1bmN0aW9uIHYoQSwgXykge1xuICAgICAgbi5ydW4oeSwgam4oeCksIFQpO1xuICAgICAgZnVuY3Rpb24gVChiLCBJLCBSKSB7XG4gICAgICAgIEkgPSBJIHx8IHksIGIgPyBfKGIpIDogQSA/IEEoSSkgOiB3KG51bGwsIEksIFIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnKHksIHgpIHtcbiAgICBsZXQgdywgdjtcbiAgICByZXR1cm4gbC5ydW4oeSwgeCwgQSksIFFlKFwicnVuU3luY1wiLCBcInJ1blwiLCB2KSwgdztcbiAgICBmdW5jdGlvbiBBKF8sIFQpIHtcbiAgICAgIEJlKF8pLCB3ID0gVCwgdiA9ICEwO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkKHksIHgpIHtcbiAgICBpZiAobC5mcmVlemUoKSwgb2UoXCJwcm9jZXNzXCIsIGwuUGFyc2VyKSwgdWUoXCJwcm9jZXNzXCIsIGwuQ29tcGlsZXIpLCAheClcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSh3KTtcbiAgICB3KG51bGwsIHgpO1xuICAgIGZ1bmN0aW9uIHcodiwgQSkge1xuICAgICAgY29uc3QgXyA9IGpuKHkpO1xuICAgICAgbC5ydW4obC5wYXJzZShfKSwgXywgKGIsIEksIFIpID0+IHtcbiAgICAgICAgaWYgKGIgfHwgIUkgfHwgIVIpXG4gICAgICAgICAgVChiKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc3QgTSA9IGwuc3RyaW5naWZ5KEksIFIpO1xuICAgICAgICAgIE0gPT0gbnVsbCB8fCAoUnIoTSkgPyBSLnZhbHVlID0gTSA6IFIucmVzdWx0ID0gTSksIFQoYiwgUik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZnVuY3Rpb24gVChiLCBJKSB7XG4gICAgICAgIGIgfHwgIUkgPyBBKGIpIDogdiA/IHYoSSkgOiB4KG51bGwsIEkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtKHkpIHtcbiAgICBsZXQgeDtcbiAgICBsLmZyZWV6ZSgpLCBvZShcInByb2Nlc3NTeW5jXCIsIGwuUGFyc2VyKSwgdWUoXCJwcm9jZXNzU3luY1wiLCBsLkNvbXBpbGVyKTtcbiAgICBjb25zdCB3ID0gam4oeSk7XG4gICAgcmV0dXJuIGwucHJvY2Vzcyh3LCB2KSwgUWUoXCJwcm9jZXNzU3luY1wiLCBcInByb2Nlc3NcIiwgeCksIHc7XG4gICAgZnVuY3Rpb24gdihBKSB7XG4gICAgICB4ID0gITAsIEJlKEEpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gV2UobiwgZSkge1xuICByZXR1cm4gdHlwZW9mIG4gPT0gXCJmdW5jdGlvblwiICYmIC8vIFByb3RvdHlwZXMgZG8gZXhpc3QuXG4gIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICBuLnByb3RvdHlwZSAmJiAvLyBBIGZ1bmN0aW9uIHdpdGgga2V5cyBpbiBpdHMgcHJvdG90eXBlIGlzIHByb2JhYmx5IGEgY29uc3RydWN0b3IuXG4gIC8vIENsYXNzZXPigJkgcHJvdG90eXBlIG1ldGhvZHMgYXJlIG5vdCBlbnVtZXJhYmxlLCBzbyB3ZSBjaGVjayBpZiBzb21lIHZhbHVlXG4gIC8vIGV4aXN0cyBpbiB0aGUgcHJvdG90eXBlLlxuICAvLyB0eXBlLWNvdmVyYWdlOmlnbm9yZS1uZXh0LWxpbmVcbiAgKHZyKG4ucHJvdG90eXBlKSB8fCBlIGluIG4ucHJvdG90eXBlKTtcbn1cbmZ1bmN0aW9uIHZyKG4pIHtcbiAgbGV0IGU7XG4gIGZvciAoZSBpbiBuKVxuICAgIGlmIChJdC5jYWxsKG4sIGUpKVxuICAgICAgcmV0dXJuICEwO1xuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBvZShuLCBlKSB7XG4gIGlmICh0eXBlb2YgZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBgXCIgKyBuICsgXCJgIHdpdGhvdXQgYFBhcnNlcmBcIik7XG59XG5mdW5jdGlvbiB1ZShuLCBlKSB7XG4gIGlmICh0eXBlb2YgZSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBgXCIgKyBuICsgXCJgIHdpdGhvdXQgYENvbXBpbGVyYFwiKTtcbn1cbmZ1bmN0aW9uIGFlKG4sIGUpIHtcbiAgaWYgKGUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJDYW5ub3QgY2FsbCBgXCIgKyBuICsgXCJgIG9uIGEgZnJvemVuIHByb2Nlc3Nvci5cXG5DcmVhdGUgYSBuZXcgcHJvY2Vzc29yIGZpcnN0LCBieSBjYWxsaW5nIGl0OiB1c2UgYHByb2Nlc3NvcigpYCBpbnN0ZWFkIG9mIGBwcm9jZXNzb3JgLlwiXG4gICAgKTtcbn1cbmZ1bmN0aW9uIFllKG4pIHtcbiAgaWYgKCFkZShuKSB8fCB0eXBlb2Ygbi50eXBlICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIG5vZGUsIGdvdCBgXCIgKyBuICsgXCJgXCIpO1xufVxuZnVuY3Rpb24gUWUobiwgZSwgdCkge1xuICBpZiAoIXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJgXCIgKyBuICsgXCJgIGZpbmlzaGVkIGFzeW5jLiBVc2UgYFwiICsgZSArIFwiYCBpbnN0ZWFkXCJcbiAgICApO1xufVxuZnVuY3Rpb24gam4obikge1xuICByZXR1cm4genIobikgPyBuIDogbmV3IEZ0KG4pO1xufVxuZnVuY3Rpb24genIobikge1xuICByZXR1cm4gISEobiAmJiB0eXBlb2YgbiA9PSBcIm9iamVjdFwiICYmIFwibWVzc2FnZVwiIGluIG4gJiYgXCJtZXNzYWdlc1wiIGluIG4pO1xufVxuZnVuY3Rpb24gUnIobikge1xuICByZXR1cm4gdHlwZW9mIG4gPT0gXCJzdHJpbmdcIiB8fCBQdChuKTtcbn1cbmZ1bmN0aW9uIF9yKG4sIGUpIHtcbiAgY29uc3QgdCA9IChlIHx8IHt9KS5pbmNsdWRlSW1hZ2VBbHQ7XG4gIHJldHVybiBMdChcbiAgICBuLFxuICAgIHR5cGVvZiB0ID09IFwiYm9vbGVhblwiID8gdCA6ICEwXG4gICk7XG59XG5mdW5jdGlvbiBMdChuLCBlKSB7XG4gIHJldHVybiBNcihuKSAmJiAoXCJ2YWx1ZVwiIGluIG4gJiYgbi52YWx1ZSB8fCBlICYmIFwiYWx0XCIgaW4gbiAmJiBuLmFsdCB8fCBcImNoaWxkcmVuXCIgaW4gbiAmJiBYZShuLmNoaWxkcmVuLCBlKSkgfHwgQXJyYXkuaXNBcnJheShuKSAmJiBYZShuLCBlKSB8fCBcIlwiO1xufVxuZnVuY3Rpb24gWGUobiwgZSkge1xuICBjb25zdCB0ID0gW107XG4gIGxldCByID0gLTE7XG4gIGZvciAoOyArK3IgPCBuLmxlbmd0aDsgKVxuICAgIHRbcl0gPSBMdChuW3JdLCBlKTtcbiAgcmV0dXJuIHQuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIE1yKG4pIHtcbiAgcmV0dXJuICEhKG4gJiYgdHlwZW9mIG4gPT0gXCJvYmplY3RcIik7XG59XG5mdW5jdGlvbiBnbihuLCBlLCB0LCByKSB7XG4gIGNvbnN0IGkgPSBuLmxlbmd0aDtcbiAgbGV0IGwgPSAwLCBvO1xuICBpZiAoZSA8IDAgPyBlID0gLWUgPiBpID8gMCA6IGkgKyBlIDogZSA9IGUgPiBpID8gaSA6IGUsIHQgPSB0ID4gMCA/IHQgOiAwLCByLmxlbmd0aCA8IDFlNClcbiAgICBvID0gQXJyYXkuZnJvbShyKSwgby51bnNoaWZ0KGUsIHQpLCBbXS5zcGxpY2UuYXBwbHkobiwgbyk7XG4gIGVsc2VcbiAgICBmb3IgKHQgJiYgW10uc3BsaWNlLmFwcGx5KG4sIFtlLCB0XSk7IGwgPCByLmxlbmd0aDsgKVxuICAgICAgbyA9IHIuc2xpY2UobCwgbCArIDFlNCksIG8udW5zaGlmdChlLCAwKSwgW10uc3BsaWNlLmFwcGx5KG4sIG8pLCBsICs9IDFlNCwgZSArPSAxZTQ7XG59XG5mdW5jdGlvbiBhbihuLCBlKSB7XG4gIHJldHVybiBuLmxlbmd0aCA+IDAgPyAoZ24obiwgbi5sZW5ndGgsIDAsIGUpLCBuKSA6IGU7XG59XG5jb25zdCBLZSA9IHt9Lmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gQnIobikge1xuICBjb25zdCBlID0ge307XG4gIGxldCB0ID0gLTE7XG4gIGZvciAoOyArK3QgPCBuLmxlbmd0aDsgKVxuICAgIE5yKGUsIG5bdF0pO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIE5yKG4sIGUpIHtcbiAgbGV0IHQ7XG4gIGZvciAodCBpbiBlKSB7XG4gICAgY29uc3QgaSA9IChLZS5jYWxsKG4sIHQpID8gblt0XSA6IHZvaWQgMCkgfHwgKG5bdF0gPSB7fSksIGwgPSBlW3RdO1xuICAgIGxldCBvO1xuICAgIGZvciAobyBpbiBsKSB7XG4gICAgICBLZS5jYWxsKGksIG8pIHx8IChpW29dID0gW10pO1xuICAgICAgY29uc3QgdSA9IGxbb107XG4gICAgICBqcihcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBMb29rcyBsaWtlIGEgbGlzdC5cbiAgICAgICAgaVtvXSxcbiAgICAgICAgQXJyYXkuaXNBcnJheSh1KSA/IHUgOiB1ID8gW3VdIDogW11cbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBqcihuLCBlKSB7XG4gIGxldCB0ID0gLTE7XG4gIGNvbnN0IHIgPSBbXTtcbiAgZm9yICg7ICsrdCA8IGUubGVuZ3RoOyApXG4gICAgKGVbdF0uYWRkID09PSBcImFmdGVyXCIgPyBuIDogcikucHVzaChlW3RdKTtcbiAgZ24obiwgMCwgMCwgcik7XG59XG5jb25zdCAkciA9IC9bIS0vOi1AWy1gey1+XFx1MDBBMVxcdTAwQTdcXHUwMEFCXFx1MDBCNlxcdTAwQjdcXHUwMEJCXFx1MDBCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwOUZEXFx1MEE3NlxcdTBBRjBcXHUwQzc3XFx1MEM4NFxcdTBERjRcXHUwRTRGXFx1MEU1QVxcdTBFNUJcXHUwRjA0LVxcdTBGMTJcXHUwRjE0XFx1MEYzQS1cXHUwRjNEXFx1MEY4NVxcdTBGRDAtXFx1MEZENFxcdTBGRDlcXHUwRkRBXFx1MTA0QS1cXHUxMDRGXFx1MTBGQlxcdTEzNjAtXFx1MTM2OFxcdTE0MDBcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMwOC1cXHUyMzBCXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTRGXFx1MkU1MlxcdTMwMDEtXFx1MzAwM1xcdTMwMDgtXFx1MzAxMVxcdTMwMTQtXFx1MzAxRlxcdTMwMzBcXHUzMDNEXFx1MzBBMFxcdTMwRkJcXHVBNEZFXFx1QTRGRlxcdUE2MEQtXFx1QTYwRlxcdUE2NzNcXHVBNjdFXFx1QTZGMi1cXHVBNkY3XFx1QTg3NC1cXHVBODc3XFx1QThDRVxcdUE4Q0ZcXHVBOEY4LVxcdUE4RkFcXHVBOEZDXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdLywgZG4gPSBBbigvW0EtWmEtel0vKSwgZ2UgPSBBbigvXFxkLyksIEhyID0gQW4oL1tcXGRBLUZhLWZdLyksIG9uID0gQW4oL1tcXGRBLVphLXpdLyksIFVyID0gQW4oL1shLS86LUBbLWB7LX5dLyksIEdlID0gQW4oL1sjLScqK1xcLS05PT9BLVpeLX5dLyk7XG5mdW5jdGlvbiB5ZShuKSB7XG4gIHJldHVybiAoXG4gICAgLy8gU3BlY2lhbCB3aGl0ZXNwYWNlIGNvZGVzICh3aGljaCBoYXZlIG5lZ2F0aXZlIHZhbHVlcyksIEMwIGFuZCBDb250cm9sXG4gICAgLy8gY2hhcmFjdGVyIERFTFxuICAgIG4gIT09IG51bGwgJiYgKG4gPCAzMiB8fCBuID09PSAxMjcpXG4gICk7XG59XG5mdW5jdGlvbiBzbihuKSB7XG4gIHJldHVybiBuICE9PSBudWxsICYmIChuIDwgMCB8fCBuID09PSAzMik7XG59XG5mdW5jdGlvbiBMKG4pIHtcbiAgcmV0dXJuIG4gIT09IG51bGwgJiYgbiA8IC0yO1xufVxuZnVuY3Rpb24gRyhuKSB7XG4gIHJldHVybiBuID09PSAtMiB8fCBuID09PSAtMSB8fCBuID09PSAzMjtcbn1cbmNvbnN0IFZyID0gQW4oL1xccy8pLCBxciA9IEFuKCRyKTtcbmZ1bmN0aW9uIEFuKG4pIHtcbiAgcmV0dXJuIGU7XG4gIGZ1bmN0aW9uIGUodCkge1xuICAgIHJldHVybiB0ICE9PSBudWxsICYmIG4udGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKHQpKTtcbiAgfVxufVxuZnVuY3Rpb24gVShuLCBlLCB0LCByKSB7XG4gIGNvbnN0IGkgPSByID8gciAtIDEgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGxldCBsID0gMDtcbiAgcmV0dXJuIG87XG4gIGZ1bmN0aW9uIG8oYSkge1xuICAgIHJldHVybiBHKGEpID8gKG4uZW50ZXIodCksIHUoYSkpIDogZShhKTtcbiAgfVxuICBmdW5jdGlvbiB1KGEpIHtcbiAgICByZXR1cm4gRyhhKSAmJiBsKysgPCBpID8gKG4uY29uc3VtZShhKSwgdSkgOiAobi5leGl0KHQpLCBlKGEpKTtcbiAgfVxufVxuY29uc3QgV3IgPSB7XG4gIHRva2VuaXplOiBZclxufTtcbmZ1bmN0aW9uIFlyKG4pIHtcbiAgY29uc3QgZSA9IG4uYXR0ZW1wdChcbiAgICB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmNvbnRlbnRJbml0aWFsLFxuICAgIHIsXG4gICAgaVxuICApO1xuICBsZXQgdDtcbiAgcmV0dXJuIGU7XG4gIGZ1bmN0aW9uIHIodSkge1xuICAgIGlmICh1ID09PSBudWxsKSB7XG4gICAgICBuLmNvbnN1bWUodSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBuLmVudGVyKFwibGluZUVuZGluZ1wiKSwgbi5jb25zdW1lKHUpLCBuLmV4aXQoXCJsaW5lRW5kaW5nXCIpLCBVKG4sIGUsIFwibGluZVByZWZpeFwiKTtcbiAgfVxuICBmdW5jdGlvbiBpKHUpIHtcbiAgICByZXR1cm4gbi5lbnRlcihcInBhcmFncmFwaFwiKSwgbCh1KTtcbiAgfVxuICBmdW5jdGlvbiBsKHUpIHtcbiAgICBjb25zdCBhID0gbi5lbnRlcihcImNodW5rVGV4dFwiLCB7XG4gICAgICBjb250ZW50VHlwZTogXCJ0ZXh0XCIsXG4gICAgICBwcmV2aW91czogdFxuICAgIH0pO1xuICAgIHJldHVybiB0ICYmICh0Lm5leHQgPSBhKSwgdCA9IGEsIG8odSk7XG4gIH1cbiAgZnVuY3Rpb24gbyh1KSB7XG4gICAgaWYgKHUgPT09IG51bGwpIHtcbiAgICAgIG4uZXhpdChcImNodW5rVGV4dFwiKSwgbi5leGl0KFwicGFyYWdyYXBoXCIpLCBuLmNvbnN1bWUodSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBMKHUpID8gKG4uY29uc3VtZSh1KSwgbi5leGl0KFwiY2h1bmtUZXh0XCIpLCBsKSA6IChuLmNvbnN1bWUodSksIG8pO1xuICB9XG59XG5jb25zdCBRciA9IHtcbiAgdG9rZW5pemU6IFhyXG59LCBaZSA9IHtcbiAgdG9rZW5pemU6IEtyXG59O1xuZnVuY3Rpb24gWHIobikge1xuICBjb25zdCBlID0gdGhpcywgdCA9IFtdO1xuICBsZXQgciA9IDAsIGksIGwsIG87XG4gIHJldHVybiB1O1xuICBmdW5jdGlvbiB1KEEpIHtcbiAgICBpZiAociA8IHQubGVuZ3RoKSB7XG4gICAgICBjb25zdCBfID0gdFtyXTtcbiAgICAgIHJldHVybiBlLmNvbnRhaW5lclN0YXRlID0gX1sxXSwgbi5hdHRlbXB0KFxuICAgICAgICBfWzBdLmNvbnRpbnVhdGlvbixcbiAgICAgICAgYSxcbiAgICAgICAgY1xuICAgICAgKShBKTtcbiAgICB9XG4gICAgcmV0dXJuIGMoQSk7XG4gIH1cbiAgZnVuY3Rpb24gYShBKSB7XG4gICAgaWYgKHIrKywgZS5jb250YWluZXJTdGF0ZS5fY2xvc2VGbG93KSB7XG4gICAgICBlLmNvbnRhaW5lclN0YXRlLl9jbG9zZUZsb3cgPSB2b2lkIDAsIGkgJiYgdigpO1xuICAgICAgY29uc3QgXyA9IGUuZXZlbnRzLmxlbmd0aDtcbiAgICAgIGxldCBUID0gXywgYjtcbiAgICAgIGZvciAoOyBULS07IClcbiAgICAgICAgaWYgKGUuZXZlbnRzW1RdWzBdID09PSBcImV4aXRcIiAmJiBlLmV2ZW50c1tUXVsxXS50eXBlID09PSBcImNodW5rRmxvd1wiKSB7XG4gICAgICAgICAgYiA9IGUuZXZlbnRzW1RdWzFdLmVuZDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgdyhyKTtcbiAgICAgIGxldCBJID0gXztcbiAgICAgIGZvciAoOyBJIDwgZS5ldmVudHMubGVuZ3RoOyApXG4gICAgICAgIGUuZXZlbnRzW0ldWzFdLmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIGIpLCBJKys7XG4gICAgICByZXR1cm4gZ24oXG4gICAgICAgIGUuZXZlbnRzLFxuICAgICAgICBUICsgMSxcbiAgICAgICAgMCxcbiAgICAgICAgZS5ldmVudHMuc2xpY2UoXylcbiAgICAgICksIGUuZXZlbnRzLmxlbmd0aCA9IEksIGMoQSk7XG4gICAgfVxuICAgIHJldHVybiB1KEEpO1xuICB9XG4gIGZ1bmN0aW9uIGMoQSkge1xuICAgIGlmIChyID09PSB0Lmxlbmd0aCkge1xuICAgICAgaWYgKCFpKVxuICAgICAgICByZXR1cm4gZyhBKTtcbiAgICAgIGlmIChpLmN1cnJlbnRDb25zdHJ1Y3QgJiYgaS5jdXJyZW50Q29uc3RydWN0LmNvbmNyZXRlKVxuICAgICAgICByZXR1cm4gbShBKTtcbiAgICAgIGUuaW50ZXJydXB0ID0gISEoaS5jdXJyZW50Q29uc3RydWN0ICYmICFpLl9nZm1UYWJsZUR5bmFtaWNJbnRlcnJ1cHRIYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIGUuY29udGFpbmVyU3RhdGUgPSB7fSwgbi5jaGVjayhcbiAgICAgIFplLFxuICAgICAgcyxcbiAgICAgIGhcbiAgICApKEEpO1xuICB9XG4gIGZ1bmN0aW9uIHMoQSkge1xuICAgIHJldHVybiBpICYmIHYoKSwgdyhyKSwgZyhBKTtcbiAgfVxuICBmdW5jdGlvbiBoKEEpIHtcbiAgICByZXR1cm4gZS5wYXJzZXIubGF6eVtlLm5vdygpLmxpbmVdID0gciAhPT0gdC5sZW5ndGgsIG8gPSBlLm5vdygpLm9mZnNldCwgbShBKTtcbiAgfVxuICBmdW5jdGlvbiBnKEEpIHtcbiAgICByZXR1cm4gZS5jb250YWluZXJTdGF0ZSA9IHt9LCBuLmF0dGVtcHQoXG4gICAgICBaZSxcbiAgICAgIGQsXG4gICAgICBtXG4gICAgKShBKTtcbiAgfVxuICBmdW5jdGlvbiBkKEEpIHtcbiAgICByZXR1cm4gcisrLCB0LnB1c2goW2UuY3VycmVudENvbnN0cnVjdCwgZS5jb250YWluZXJTdGF0ZV0pLCBnKEEpO1xuICB9XG4gIGZ1bmN0aW9uIG0oQSkge1xuICAgIGlmIChBID09PSBudWxsKSB7XG4gICAgICBpICYmIHYoKSwgdygwKSwgbi5jb25zdW1lKEEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gaSA9IGkgfHwgZS5wYXJzZXIuZmxvdyhlLm5vdygpKSwgbi5lbnRlcihcImNodW5rRmxvd1wiLCB7XG4gICAgICBjb250ZW50VHlwZTogXCJmbG93XCIsXG4gICAgICBwcmV2aW91czogbCxcbiAgICAgIF90b2tlbml6ZXI6IGlcbiAgICB9KSwgeShBKTtcbiAgfVxuICBmdW5jdGlvbiB5KEEpIHtcbiAgICBpZiAoQSA9PT0gbnVsbCkge1xuICAgICAgeChuLmV4aXQoXCJjaHVua0Zsb3dcIiksICEwKSwgdygwKSwgbi5jb25zdW1lKEEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gTChBKSA/IChuLmNvbnN1bWUoQSksIHgobi5leGl0KFwiY2h1bmtGbG93XCIpKSwgciA9IDAsIGUuaW50ZXJydXB0ID0gdm9pZCAwLCB1KSA6IChuLmNvbnN1bWUoQSksIHkpO1xuICB9XG4gIGZ1bmN0aW9uIHgoQSwgXykge1xuICAgIGNvbnN0IFQgPSBlLnNsaWNlU3RyZWFtKEEpO1xuICAgIGlmIChfICYmIFQucHVzaChudWxsKSwgQS5wcmV2aW91cyA9IGwsIGwgJiYgKGwubmV4dCA9IEEpLCBsID0gQSwgaS5kZWZpbmVTa2lwKEEuc3RhcnQpLCBpLndyaXRlKFQpLCBlLnBhcnNlci5sYXp5W0Euc3RhcnQubGluZV0pIHtcbiAgICAgIGxldCBiID0gaS5ldmVudHMubGVuZ3RoO1xuICAgICAgZm9yICg7IGItLTsgKVxuICAgICAgICBpZiAoXG4gICAgICAgICAgLy8gVGhlIHRva2VuIHN0YXJ0cyBiZWZvcmUgdGhlIGxpbmUgZW5kaW5n4oCmXG4gICAgICAgICAgaS5ldmVudHNbYl1bMV0uc3RhcnQub2Zmc2V0IDwgbyAmJiAvLyDigKZhbmQgZWl0aGVyIGlzIG5vdCBlbmRlZCB5ZXTigKZcbiAgICAgICAgICAoIWkuZXZlbnRzW2JdWzFdLmVuZCB8fCAvLyDigKZvciBlbmRzIGFmdGVyIGl0LlxuICAgICAgICAgIGkuZXZlbnRzW2JdWzFdLmVuZC5vZmZzZXQgPiBvKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgSSA9IGUuZXZlbnRzLmxlbmd0aDtcbiAgICAgIGxldCBSID0gSSwgTSwgWDtcbiAgICAgIGZvciAoOyBSLS07IClcbiAgICAgICAgaWYgKGUuZXZlbnRzW1JdWzBdID09PSBcImV4aXRcIiAmJiBlLmV2ZW50c1tSXVsxXS50eXBlID09PSBcImNodW5rRmxvd1wiKSB7XG4gICAgICAgICAgaWYgKE0pIHtcbiAgICAgICAgICAgIFggPSBlLmV2ZW50c1tSXVsxXS5lbmQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgTSA9ICEwO1xuICAgICAgICB9XG4gICAgICBmb3IgKHcociksIGIgPSBJOyBiIDwgZS5ldmVudHMubGVuZ3RoOyApXG4gICAgICAgIGUuZXZlbnRzW2JdWzFdLmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIFgpLCBiKys7XG4gICAgICBnbihcbiAgICAgICAgZS5ldmVudHMsXG4gICAgICAgIFIgKyAxLFxuICAgICAgICAwLFxuICAgICAgICBlLmV2ZW50cy5zbGljZShJKVxuICAgICAgKSwgZS5ldmVudHMubGVuZ3RoID0gYjtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdyhBKSB7XG4gICAgbGV0IF8gPSB0Lmxlbmd0aDtcbiAgICBmb3IgKDsgXy0tID4gQTsgKSB7XG4gICAgICBjb25zdCBUID0gdFtfXTtcbiAgICAgIGUuY29udGFpbmVyU3RhdGUgPSBUWzFdLCBUWzBdLmV4aXQuY2FsbChlLCBuKTtcbiAgICB9XG4gICAgdC5sZW5ndGggPSBBO1xuICB9XG4gIGZ1bmN0aW9uIHYoKSB7XG4gICAgaS53cml0ZShbbnVsbF0pLCBsID0gdm9pZCAwLCBpID0gdm9pZCAwLCBlLmNvbnRhaW5lclN0YXRlLl9jbG9zZUZsb3cgPSB2b2lkIDA7XG4gIH1cbn1cbmZ1bmN0aW9uIEtyKG4sIGUsIHQpIHtcbiAgcmV0dXJuIFUoXG4gICAgbixcbiAgICBuLmF0dGVtcHQodGhpcy5wYXJzZXIuY29uc3RydWN0cy5kb2N1bWVudCwgZSwgdCksXG4gICAgXCJsaW5lUHJlZml4XCIsXG4gICAgdGhpcy5wYXJzZXIuY29uc3RydWN0cy5kaXNhYmxlLm51bGwuaW5jbHVkZXMoXCJjb2RlSW5kZW50ZWRcIikgPyB2b2lkIDAgOiA0XG4gICk7XG59XG5mdW5jdGlvbiBKZShuKSB7XG4gIGlmIChuID09PSBudWxsIHx8IHNuKG4pIHx8IFZyKG4pKVxuICAgIHJldHVybiAxO1xuICBpZiAocXIobikpXG4gICAgcmV0dXJuIDI7XG59XG5mdW5jdGlvbiBDZShuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSBbXTtcbiAgbGV0IGkgPSAtMTtcbiAgZm9yICg7ICsraSA8IG4ubGVuZ3RoOyApIHtcbiAgICBjb25zdCBsID0gbltpXS5yZXNvbHZlQWxsO1xuICAgIGwgJiYgIXIuaW5jbHVkZXMobCkgJiYgKGUgPSBsKGUsIHQpLCByLnB1c2gobCkpO1xuICB9XG4gIHJldHVybiBlO1xufVxuY29uc3QgeGUgPSB7XG4gIG5hbWU6IFwiYXR0ZW50aW9uXCIsXG4gIHRva2VuaXplOiBacixcbiAgcmVzb2x2ZUFsbDogR3Jcbn07XG5mdW5jdGlvbiBHcihuLCBlKSB7XG4gIGxldCB0ID0gLTEsIHIsIGksIGwsIG8sIHUsIGEsIGMsIHM7XG4gIGZvciAoOyArK3QgPCBuLmxlbmd0aDsgKVxuICAgIGlmIChuW3RdWzBdID09PSBcImVudGVyXCIgJiYgblt0XVsxXS50eXBlID09PSBcImF0dGVudGlvblNlcXVlbmNlXCIgJiYgblt0XVsxXS5fY2xvc2UpIHtcbiAgICAgIGZvciAociA9IHQ7IHItLTsgKVxuICAgICAgICBpZiAobltyXVswXSA9PT0gXCJleGl0XCIgJiYgbltyXVsxXS50eXBlID09PSBcImF0dGVudGlvblNlcXVlbmNlXCIgJiYgbltyXVsxXS5fb3BlbiAmJiAvLyBJZiB0aGUgbWFya2VycyBhcmUgdGhlIHNhbWU6XG4gICAgICAgIGUuc2xpY2VTZXJpYWxpemUobltyXVsxXSkuY2hhckNvZGVBdCgwKSA9PT0gZS5zbGljZVNlcmlhbGl6ZShuW3RdWzFdKS5jaGFyQ29kZUF0KDApKSB7XG4gICAgICAgICAgaWYgKChuW3JdWzFdLl9jbG9zZSB8fCBuW3RdWzFdLl9vcGVuKSAmJiAoblt0XVsxXS5lbmQub2Zmc2V0IC0gblt0XVsxXS5zdGFydC5vZmZzZXQpICUgMyAmJiAhKChuW3JdWzFdLmVuZC5vZmZzZXQgLSBuW3JdWzFdLnN0YXJ0Lm9mZnNldCArIG5bdF1bMV0uZW5kLm9mZnNldCAtIG5bdF1bMV0uc3RhcnQub2Zmc2V0KSAlIDMpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgYSA9IG5bcl1bMV0uZW5kLm9mZnNldCAtIG5bcl1bMV0uc3RhcnQub2Zmc2V0ID4gMSAmJiBuW3RdWzFdLmVuZC5vZmZzZXQgLSBuW3RdWzFdLnN0YXJ0Lm9mZnNldCA+IDEgPyAyIDogMTtcbiAgICAgICAgICBjb25zdCBoID0gT2JqZWN0LmFzc2lnbih7fSwgbltyXVsxXS5lbmQpLCBnID0gT2JqZWN0LmFzc2lnbih7fSwgblt0XVsxXS5zdGFydCk7XG4gICAgICAgICAgbnQoaCwgLWEpLCBudChnLCBhKSwgbyA9IHtcbiAgICAgICAgICAgIHR5cGU6IGEgPiAxID8gXCJzdHJvbmdTZXF1ZW5jZVwiIDogXCJlbXBoYXNpc1NlcXVlbmNlXCIsXG4gICAgICAgICAgICBzdGFydDogaCxcbiAgICAgICAgICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgbltyXVsxXS5lbmQpXG4gICAgICAgICAgfSwgdSA9IHtcbiAgICAgICAgICAgIHR5cGU6IGEgPiAxID8gXCJzdHJvbmdTZXF1ZW5jZVwiIDogXCJlbXBoYXNpc1NlcXVlbmNlXCIsXG4gICAgICAgICAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgblt0XVsxXS5zdGFydCksXG4gICAgICAgICAgICBlbmQ6IGdcbiAgICAgICAgICB9LCBsID0ge1xuICAgICAgICAgICAgdHlwZTogYSA+IDEgPyBcInN0cm9uZ1RleHRcIiA6IFwiZW1waGFzaXNUZXh0XCIsXG4gICAgICAgICAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgbltyXVsxXS5lbmQpLFxuICAgICAgICAgICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBuW3RdWzFdLnN0YXJ0KVxuICAgICAgICAgIH0sIGkgPSB7XG4gICAgICAgICAgICB0eXBlOiBhID4gMSA/IFwic3Ryb25nXCIgOiBcImVtcGhhc2lzXCIsXG4gICAgICAgICAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgby5zdGFydCksXG4gICAgICAgICAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIHUuZW5kKVxuICAgICAgICAgIH0sIG5bcl1bMV0uZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgby5zdGFydCksIG5bdF1bMV0uc3RhcnQgPSBPYmplY3QuYXNzaWduKHt9LCB1LmVuZCksIGMgPSBbXSwgbltyXVsxXS5lbmQub2Zmc2V0IC0gbltyXVsxXS5zdGFydC5vZmZzZXQgJiYgKGMgPSBhbihjLCBbXG4gICAgICAgICAgICBbXCJlbnRlclwiLCBuW3JdWzFdLCBlXSxcbiAgICAgICAgICAgIFtcImV4aXRcIiwgbltyXVsxXSwgZV1cbiAgICAgICAgICBdKSksIGMgPSBhbihjLCBbXG4gICAgICAgICAgICBbXCJlbnRlclwiLCBpLCBlXSxcbiAgICAgICAgICAgIFtcImVudGVyXCIsIG8sIGVdLFxuICAgICAgICAgICAgW1wiZXhpdFwiLCBvLCBlXSxcbiAgICAgICAgICAgIFtcImVudGVyXCIsIGwsIGVdXG4gICAgICAgICAgXSksIGMgPSBhbihcbiAgICAgICAgICAgIGMsXG4gICAgICAgICAgICBDZShcbiAgICAgICAgICAgICAgZS5wYXJzZXIuY29uc3RydWN0cy5pbnNpZGVTcGFuLm51bGwsXG4gICAgICAgICAgICAgIG4uc2xpY2UociArIDEsIHQpLFxuICAgICAgICAgICAgICBlXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSwgYyA9IGFuKGMsIFtcbiAgICAgICAgICAgIFtcImV4aXRcIiwgbCwgZV0sXG4gICAgICAgICAgICBbXCJlbnRlclwiLCB1LCBlXSxcbiAgICAgICAgICAgIFtcImV4aXRcIiwgdSwgZV0sXG4gICAgICAgICAgICBbXCJleGl0XCIsIGksIGVdXG4gICAgICAgICAgXSksIG5bdF1bMV0uZW5kLm9mZnNldCAtIG5bdF1bMV0uc3RhcnQub2Zmc2V0ID8gKHMgPSAyLCBjID0gYW4oYywgW1xuICAgICAgICAgICAgW1wiZW50ZXJcIiwgblt0XVsxXSwgZV0sXG4gICAgICAgICAgICBbXCJleGl0XCIsIG5bdF1bMV0sIGVdXG4gICAgICAgICAgXSkpIDogcyA9IDAsIGduKG4sIHIgLSAxLCB0IC0gciArIDMsIGMpLCB0ID0gciArIGMubGVuZ3RoIC0gcyAtIDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIGZvciAodCA9IC0xOyArK3QgPCBuLmxlbmd0aDsgKVxuICAgIG5bdF1bMV0udHlwZSA9PT0gXCJhdHRlbnRpb25TZXF1ZW5jZVwiICYmIChuW3RdWzFdLnR5cGUgPSBcImRhdGFcIik7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gWnIobiwgZSkge1xuICBjb25zdCB0ID0gdGhpcy5wYXJzZXIuY29uc3RydWN0cy5hdHRlbnRpb25NYXJrZXJzLm51bGwsIHIgPSB0aGlzLnByZXZpb3VzLCBpID0gSmUocik7XG4gIGxldCBsO1xuICByZXR1cm4gbztcbiAgZnVuY3Rpb24gbyhhKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJhdHRlbnRpb25TZXF1ZW5jZVwiKSwgbCA9IGEsIHUoYSk7XG4gIH1cbiAgZnVuY3Rpb24gdShhKSB7XG4gICAgaWYgKGEgPT09IGwpXG4gICAgICByZXR1cm4gbi5jb25zdW1lKGEpLCB1O1xuICAgIGNvbnN0IGMgPSBuLmV4aXQoXCJhdHRlbnRpb25TZXF1ZW5jZVwiKSwgcyA9IEplKGEpLCBoID0gIXMgfHwgcyA9PT0gMiAmJiBpIHx8IHQuaW5jbHVkZXMoYSksIGcgPSAhaSB8fCBpID09PSAyICYmIHMgfHwgdC5pbmNsdWRlcyhyKTtcbiAgICByZXR1cm4gYy5fb3BlbiA9ICEhKGwgPT09IDQyID8gaCA6IGggJiYgKGkgfHwgIWcpKSwgYy5fY2xvc2UgPSAhIShsID09PSA0MiA/IGcgOiBnICYmIChzIHx8ICFoKSksIGUoYSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG50KG4sIGUpIHtcbiAgbi5jb2x1bW4gKz0gZSwgbi5vZmZzZXQgKz0gZSwgbi5fYnVmZmVySW5kZXggKz0gZTtcbn1cbmNvbnN0IEpyID0ge1xuICBuYW1lOiBcImF1dG9saW5rXCIsXG4gIHRva2VuaXplOiBuaVxufTtcbmZ1bmN0aW9uIG5pKG4sIGUsIHQpIHtcbiAgbGV0IHIgPSAxO1xuICByZXR1cm4gaTtcbiAgZnVuY3Rpb24gaShtKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJhdXRvbGlua1wiKSwgbi5lbnRlcihcImF1dG9saW5rTWFya2VyXCIpLCBuLmNvbnN1bWUobSksIG4uZXhpdChcImF1dG9saW5rTWFya2VyXCIpLCBuLmVudGVyKFwiYXV0b2xpbmtQcm90b2NvbFwiKSwgbDtcbiAgfVxuICBmdW5jdGlvbiBsKG0pIHtcbiAgICByZXR1cm4gZG4obSkgPyAobi5jb25zdW1lKG0pLCBvKSA6IEdlKG0pID8gYyhtKSA6IHQobSk7XG4gIH1cbiAgZnVuY3Rpb24gbyhtKSB7XG4gICAgcmV0dXJuIG0gPT09IDQzIHx8IG0gPT09IDQ1IHx8IG0gPT09IDQ2IHx8IG9uKG0pID8gdShtKSA6IGMobSk7XG4gIH1cbiAgZnVuY3Rpb24gdShtKSB7XG4gICAgcmV0dXJuIG0gPT09IDU4ID8gKG4uY29uc3VtZShtKSwgYSkgOiAobSA9PT0gNDMgfHwgbSA9PT0gNDUgfHwgbSA9PT0gNDYgfHwgb24obSkpICYmIHIrKyA8IDMyID8gKG4uY29uc3VtZShtKSwgdSkgOiBjKG0pO1xuICB9XG4gIGZ1bmN0aW9uIGEobSkge1xuICAgIHJldHVybiBtID09PSA2MiA/IChuLmV4aXQoXCJhdXRvbGlua1Byb3RvY29sXCIpLCBkKG0pKSA6IG0gPT09IG51bGwgfHwgbSA9PT0gMzIgfHwgbSA9PT0gNjAgfHwgeWUobSkgPyB0KG0pIDogKG4uY29uc3VtZShtKSwgYSk7XG4gIH1cbiAgZnVuY3Rpb24gYyhtKSB7XG4gICAgcmV0dXJuIG0gPT09IDY0ID8gKG4uY29uc3VtZShtKSwgciA9IDAsIHMpIDogR2UobSkgPyAobi5jb25zdW1lKG0pLCBjKSA6IHQobSk7XG4gIH1cbiAgZnVuY3Rpb24gcyhtKSB7XG4gICAgcmV0dXJuIG9uKG0pID8gaChtKSA6IHQobSk7XG4gIH1cbiAgZnVuY3Rpb24gaChtKSB7XG4gICAgcmV0dXJuIG0gPT09IDQ2ID8gKG4uY29uc3VtZShtKSwgciA9IDAsIHMpIDogbSA9PT0gNjIgPyAobi5leGl0KFwiYXV0b2xpbmtQcm90b2NvbFwiKS50eXBlID0gXCJhdXRvbGlua0VtYWlsXCIsIGQobSkpIDogZyhtKTtcbiAgfVxuICBmdW5jdGlvbiBnKG0pIHtcbiAgICByZXR1cm4gKG0gPT09IDQ1IHx8IG9uKG0pKSAmJiByKysgPCA2MyA/IChuLmNvbnN1bWUobSksIG0gPT09IDQ1ID8gZyA6IGgpIDogdChtKTtcbiAgfVxuICBmdW5jdGlvbiBkKG0pIHtcbiAgICByZXR1cm4gbi5lbnRlcihcImF1dG9saW5rTWFya2VyXCIpLCBuLmNvbnN1bWUobSksIG4uZXhpdChcImF1dG9saW5rTWFya2VyXCIpLCBuLmV4aXQoXCJhdXRvbGlua1wiKSwgZTtcbiAgfVxufVxuY29uc3QgWm4gPSB7XG4gIHRva2VuaXplOiBlaSxcbiAgcGFydGlhbDogITBcbn07XG5mdW5jdGlvbiBlaShuLCBlLCB0KSB7XG4gIHJldHVybiBVKG4sIHIsIFwibGluZVByZWZpeFwiKTtcbiAgZnVuY3Rpb24gcihpKSB7XG4gICAgcmV0dXJuIGkgPT09IG51bGwgfHwgTChpKSA/IGUoaSkgOiB0KGkpO1xuICB9XG59XG5jb25zdCBEdCA9IHtcbiAgbmFtZTogXCJibG9ja1F1b3RlXCIsXG4gIHRva2VuaXplOiB0aSxcbiAgY29udGludWF0aW9uOiB7XG4gICAgdG9rZW5pemU6IHJpXG4gIH0sXG4gIGV4aXQ6IGlpXG59O1xuZnVuY3Rpb24gdGkobiwgZSwgdCkge1xuICBjb25zdCByID0gdGhpcztcbiAgcmV0dXJuIGk7XG4gIGZ1bmN0aW9uIGkobykge1xuICAgIGlmIChvID09PSA2Mikge1xuICAgICAgY29uc3QgdSA9IHIuY29udGFpbmVyU3RhdGU7XG4gICAgICByZXR1cm4gdS5vcGVuIHx8IChuLmVudGVyKFwiYmxvY2tRdW90ZVwiLCB7XG4gICAgICAgIF9jb250YWluZXI6ICEwXG4gICAgICB9KSwgdS5vcGVuID0gITApLCBuLmVudGVyKFwiYmxvY2tRdW90ZVByZWZpeFwiKSwgbi5lbnRlcihcImJsb2NrUXVvdGVNYXJrZXJcIiksIG4uY29uc3VtZShvKSwgbi5leGl0KFwiYmxvY2tRdW90ZU1hcmtlclwiKSwgbDtcbiAgICB9XG4gICAgcmV0dXJuIHQobyk7XG4gIH1cbiAgZnVuY3Rpb24gbChvKSB7XG4gICAgcmV0dXJuIEcobykgPyAobi5lbnRlcihcImJsb2NrUXVvdGVQcmVmaXhXaGl0ZXNwYWNlXCIpLCBuLmNvbnN1bWUobyksIG4uZXhpdChcImJsb2NrUXVvdGVQcmVmaXhXaGl0ZXNwYWNlXCIpLCBuLmV4aXQoXCJibG9ja1F1b3RlUHJlZml4XCIpLCBlKSA6IChuLmV4aXQoXCJibG9ja1F1b3RlUHJlZml4XCIpLCBlKG8pKTtcbiAgfVxufVxuZnVuY3Rpb24gcmkobiwgZSwgdCkge1xuICByZXR1cm4gVShcbiAgICBuLFxuICAgIG4uYXR0ZW1wdChEdCwgZSwgdCksXG4gICAgXCJsaW5lUHJlZml4XCIsXG4gICAgdGhpcy5wYXJzZXIuY29uc3RydWN0cy5kaXNhYmxlLm51bGwuaW5jbHVkZXMoXCJjb2RlSW5kZW50ZWRcIikgPyB2b2lkIDAgOiA0XG4gICk7XG59XG5mdW5jdGlvbiBpaShuKSB7XG4gIG4uZXhpdChcImJsb2NrUXVvdGVcIik7XG59XG5jb25zdCB2dCA9IHtcbiAgbmFtZTogXCJjaGFyYWN0ZXJFc2NhcGVcIixcbiAgdG9rZW5pemU6IGxpXG59O1xuZnVuY3Rpb24gbGkobiwgZSwgdCkge1xuICByZXR1cm4gcjtcbiAgZnVuY3Rpb24gcihsKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJjaGFyYWN0ZXJFc2NhcGVcIiksIG4uZW50ZXIoXCJlc2NhcGVNYXJrZXJcIiksIG4uY29uc3VtZShsKSwgbi5leGl0KFwiZXNjYXBlTWFya2VyXCIpLCBpO1xuICB9XG4gIGZ1bmN0aW9uIGkobCkge1xuICAgIHJldHVybiBVcihsKSA/IChuLmVudGVyKFwiY2hhcmFjdGVyRXNjYXBlVmFsdWVcIiksIG4uY29uc3VtZShsKSwgbi5leGl0KFwiY2hhcmFjdGVyRXNjYXBlVmFsdWVcIiksIG4uZXhpdChcImNoYXJhY3RlckVzY2FwZVwiKSwgZSkgOiB0KGwpO1xuICB9XG59XG5jb25zdCBldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpXCIpO1xuZnVuY3Rpb24gQWUobikge1xuICBjb25zdCBlID0gXCImXCIgKyBuICsgXCI7XCI7XG4gIGV0LmlubmVySFRNTCA9IGU7XG4gIGNvbnN0IHQgPSBldC50ZXh0Q29udGVudDtcbiAgcmV0dXJuIHQuY2hhckNvZGVBdCh0Lmxlbmd0aCAtIDEpID09PSA1OSAmJiBuICE9PSBcInNlbWlcIiB8fCB0ID09PSBlID8gITEgOiB0O1xufVxuY29uc3QgenQgPSB7XG4gIG5hbWU6IFwiY2hhcmFjdGVyUmVmZXJlbmNlXCIsXG4gIHRva2VuaXplOiBvaVxufTtcbmZ1bmN0aW9uIG9pKG4sIGUsIHQpIHtcbiAgY29uc3QgciA9IHRoaXM7XG4gIGxldCBpID0gMCwgbCwgbztcbiAgcmV0dXJuIHU7XG4gIGZ1bmN0aW9uIHUoaCkge1xuICAgIHJldHVybiBuLmVudGVyKFwiY2hhcmFjdGVyUmVmZXJlbmNlXCIpLCBuLmVudGVyKFwiY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyXCIpLCBuLmNvbnN1bWUoaCksIG4uZXhpdChcImNoYXJhY3RlclJlZmVyZW5jZU1hcmtlclwiKSwgYTtcbiAgfVxuICBmdW5jdGlvbiBhKGgpIHtcbiAgICByZXR1cm4gaCA9PT0gMzUgPyAobi5lbnRlcihcImNoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWNcIiksIG4uY29uc3VtZShoKSwgbi5leGl0KFwiY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyTnVtZXJpY1wiKSwgYykgOiAobi5lbnRlcihcImNoYXJhY3RlclJlZmVyZW5jZVZhbHVlXCIpLCBsID0gMzEsIG8gPSBvbiwgcyhoKSk7XG4gIH1cbiAgZnVuY3Rpb24gYyhoKSB7XG4gICAgcmV0dXJuIGggPT09IDg4IHx8IGggPT09IDEyMCA/IChuLmVudGVyKFwiY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VySGV4YWRlY2ltYWxcIiksIG4uY29uc3VtZShoKSwgbi5leGl0KFwiY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VySGV4YWRlY2ltYWxcIiksIG4uZW50ZXIoXCJjaGFyYWN0ZXJSZWZlcmVuY2VWYWx1ZVwiKSwgbCA9IDYsIG8gPSBIciwgcykgOiAobi5lbnRlcihcImNoYXJhY3RlclJlZmVyZW5jZVZhbHVlXCIpLCBsID0gNywgbyA9IGdlLCBzKGgpKTtcbiAgfVxuICBmdW5jdGlvbiBzKGgpIHtcbiAgICBsZXQgZztcbiAgICByZXR1cm4gaCA9PT0gNTkgJiYgaSA/IChnID0gbi5leGl0KFwiY2hhcmFjdGVyUmVmZXJlbmNlVmFsdWVcIiksIG8gPT09IG9uICYmICFBZShyLnNsaWNlU2VyaWFsaXplKGcpKSA/IHQoaCkgOiAobi5lbnRlcihcImNoYXJhY3RlclJlZmVyZW5jZU1hcmtlclwiKSwgbi5jb25zdW1lKGgpLCBuLmV4aXQoXCJjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJcIiksIG4uZXhpdChcImNoYXJhY3RlclJlZmVyZW5jZVwiKSwgZSkpIDogbyhoKSAmJiBpKysgPCBsID8gKG4uY29uc3VtZShoKSwgcykgOiB0KGgpO1xuICB9XG59XG5jb25zdCB0dCA9IHtcbiAgbmFtZTogXCJjb2RlRmVuY2VkXCIsXG4gIHRva2VuaXplOiB1aSxcbiAgY29uY3JldGU6ICEwXG59O1xuZnVuY3Rpb24gdWkobiwgZSwgdCkge1xuICBjb25zdCByID0gdGhpcywgaSA9IHtcbiAgICB0b2tlbml6ZTogVCxcbiAgICBwYXJ0aWFsOiAhMFxuICB9LCBsID0ge1xuICAgIHRva2VuaXplOiBfLFxuICAgIHBhcnRpYWw6ICEwXG4gIH0sIG8gPSB0aGlzLmV2ZW50c1t0aGlzLmV2ZW50cy5sZW5ndGggLSAxXSwgdSA9IG8gJiYgb1sxXS50eXBlID09PSBcImxpbmVQcmVmaXhcIiA/IG9bMl0uc2xpY2VTZXJpYWxpemUob1sxXSwgITApLmxlbmd0aCA6IDA7XG4gIGxldCBhID0gMCwgYztcbiAgcmV0dXJuIHM7XG4gIGZ1bmN0aW9uIHMoYikge1xuICAgIHJldHVybiBuLmVudGVyKFwiY29kZUZlbmNlZFwiKSwgbi5lbnRlcihcImNvZGVGZW5jZWRGZW5jZVwiKSwgbi5lbnRlcihcImNvZGVGZW5jZWRGZW5jZVNlcXVlbmNlXCIpLCBjID0gYiwgaChiKTtcbiAgfVxuICBmdW5jdGlvbiBoKGIpIHtcbiAgICByZXR1cm4gYiA9PT0gYyA/IChuLmNvbnN1bWUoYiksIGErKywgaCkgOiAobi5leGl0KFwiY29kZUZlbmNlZEZlbmNlU2VxdWVuY2VcIiksIGEgPCAzID8gdChiKSA6IFUobiwgZywgXCJ3aGl0ZXNwYWNlXCIpKGIpKTtcbiAgfVxuICBmdW5jdGlvbiBnKGIpIHtcbiAgICByZXR1cm4gYiA9PT0gbnVsbCB8fCBMKGIpID8geChiKSA6IChuLmVudGVyKFwiY29kZUZlbmNlZEZlbmNlSW5mb1wiKSwgbi5lbnRlcihcImNodW5rU3RyaW5nXCIsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiBcInN0cmluZ1wiXG4gICAgfSksIGQoYikpO1xuICB9XG4gIGZ1bmN0aW9uIGQoYikge1xuICAgIHJldHVybiBiID09PSBudWxsIHx8IHNuKGIpID8gKG4uZXhpdChcImNodW5rU3RyaW5nXCIpLCBuLmV4aXQoXCJjb2RlRmVuY2VkRmVuY2VJbmZvXCIpLCBVKG4sIG0sIFwid2hpdGVzcGFjZVwiKShiKSkgOiBiID09PSA5NiAmJiBiID09PSBjID8gdChiKSA6IChuLmNvbnN1bWUoYiksIGQpO1xuICB9XG4gIGZ1bmN0aW9uIG0oYikge1xuICAgIHJldHVybiBiID09PSBudWxsIHx8IEwoYikgPyB4KGIpIDogKG4uZW50ZXIoXCJjb2RlRmVuY2VkRmVuY2VNZXRhXCIpLCBuLmVudGVyKFwiY2h1bmtTdHJpbmdcIiwge1xuICAgICAgY29udGVudFR5cGU6IFwic3RyaW5nXCJcbiAgICB9KSwgeShiKSk7XG4gIH1cbiAgZnVuY3Rpb24geShiKSB7XG4gICAgcmV0dXJuIGIgPT09IG51bGwgfHwgTChiKSA/IChuLmV4aXQoXCJjaHVua1N0cmluZ1wiKSwgbi5leGl0KFwiY29kZUZlbmNlZEZlbmNlTWV0YVwiKSwgeChiKSkgOiBiID09PSA5NiAmJiBiID09PSBjID8gdChiKSA6IChuLmNvbnN1bWUoYiksIHkpO1xuICB9XG4gIGZ1bmN0aW9uIHgoYikge1xuICAgIHJldHVybiBuLmV4aXQoXCJjb2RlRmVuY2VkRmVuY2VcIiksIHIuaW50ZXJydXB0ID8gZShiKSA6IHcoYik7XG4gIH1cbiAgZnVuY3Rpb24gdyhiKSB7XG4gICAgcmV0dXJuIGIgPT09IG51bGwgPyBBKGIpIDogTChiKSA/IG4uYXR0ZW1wdChcbiAgICAgIGwsXG4gICAgICBuLmF0dGVtcHQoXG4gICAgICAgIGksXG4gICAgICAgIEEsXG4gICAgICAgIHUgPyBVKFxuICAgICAgICAgIG4sXG4gICAgICAgICAgdyxcbiAgICAgICAgICBcImxpbmVQcmVmaXhcIixcbiAgICAgICAgICB1ICsgMVxuICAgICAgICApIDogd1xuICAgICAgKSxcbiAgICAgIEFcbiAgICApKGIpIDogKG4uZW50ZXIoXCJjb2RlRmxvd1ZhbHVlXCIpLCB2KGIpKTtcbiAgfVxuICBmdW5jdGlvbiB2KGIpIHtcbiAgICByZXR1cm4gYiA9PT0gbnVsbCB8fCBMKGIpID8gKG4uZXhpdChcImNvZGVGbG93VmFsdWVcIiksIHcoYikpIDogKG4uY29uc3VtZShiKSwgdik7XG4gIH1cbiAgZnVuY3Rpb24gQShiKSB7XG4gICAgcmV0dXJuIG4uZXhpdChcImNvZGVGZW5jZWRcIiksIGUoYik7XG4gIH1cbiAgZnVuY3Rpb24gXyhiLCBJLCBSKSB7XG4gICAgY29uc3QgTSA9IHRoaXM7XG4gICAgcmV0dXJuIFg7XG4gICAgZnVuY3Rpb24gWChGKSB7XG4gICAgICByZXR1cm4gYi5lbnRlcihcImxpbmVFbmRpbmdcIiksIGIuY29uc3VtZShGKSwgYi5leGl0KFwibGluZUVuZGluZ1wiKSwgQztcbiAgICB9XG4gICAgZnVuY3Rpb24gQyhGKSB7XG4gICAgICByZXR1cm4gTS5wYXJzZXIubGF6eVtNLm5vdygpLmxpbmVdID8gUihGKSA6IEkoRik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFQoYiwgSSwgUikge1xuICAgIGxldCBNID0gMDtcbiAgICByZXR1cm4gVShcbiAgICAgIGIsXG4gICAgICBYLFxuICAgICAgXCJsaW5lUHJlZml4XCIsXG4gICAgICB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcyhcImNvZGVJbmRlbnRlZFwiKSA/IHZvaWQgMCA6IDRcbiAgICApO1xuICAgIGZ1bmN0aW9uIFgoQikge1xuICAgICAgcmV0dXJuIGIuZW50ZXIoXCJjb2RlRmVuY2VkRmVuY2VcIiksIGIuZW50ZXIoXCJjb2RlRmVuY2VkRmVuY2VTZXF1ZW5jZVwiKSwgQyhCKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQyhCKSB7XG4gICAgICByZXR1cm4gQiA9PT0gYyA/IChiLmNvbnN1bWUoQiksIE0rKywgQykgOiBNIDwgYSA/IFIoQikgOiAoYi5leGl0KFwiY29kZUZlbmNlZEZlbmNlU2VxdWVuY2VcIiksIFUoYiwgRiwgXCJ3aGl0ZXNwYWNlXCIpKEIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gRihCKSB7XG4gICAgICByZXR1cm4gQiA9PT0gbnVsbCB8fCBMKEIpID8gKGIuZXhpdChcImNvZGVGZW5jZWRGZW5jZVwiKSwgSShCKSkgOiBSKEIpO1xuICAgIH1cbiAgfVxufVxuY29uc3Qgc2UgPSB7XG4gIG5hbWU6IFwiY29kZUluZGVudGVkXCIsXG4gIHRva2VuaXplOiBzaVxufSwgYWkgPSB7XG4gIHRva2VuaXplOiBjaSxcbiAgcGFydGlhbDogITBcbn07XG5mdW5jdGlvbiBzaShuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB0aGlzO1xuICByZXR1cm4gaTtcbiAgZnVuY3Rpb24gaShjKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJjb2RlSW5kZW50ZWRcIiksIFUobiwgbCwgXCJsaW5lUHJlZml4XCIsIDQgKyAxKShjKTtcbiAgfVxuICBmdW5jdGlvbiBsKGMpIHtcbiAgICBjb25zdCBzID0gci5ldmVudHNbci5ldmVudHMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHMgJiYgc1sxXS50eXBlID09PSBcImxpbmVQcmVmaXhcIiAmJiBzWzJdLnNsaWNlU2VyaWFsaXplKHNbMV0sICEwKS5sZW5ndGggPj0gNCA/IG8oYykgOiB0KGMpO1xuICB9XG4gIGZ1bmN0aW9uIG8oYykge1xuICAgIHJldHVybiBjID09PSBudWxsID8gYShjKSA6IEwoYykgPyBuLmF0dGVtcHQoYWksIG8sIGEpKGMpIDogKG4uZW50ZXIoXCJjb2RlRmxvd1ZhbHVlXCIpLCB1KGMpKTtcbiAgfVxuICBmdW5jdGlvbiB1KGMpIHtcbiAgICByZXR1cm4gYyA9PT0gbnVsbCB8fCBMKGMpID8gKG4uZXhpdChcImNvZGVGbG93VmFsdWVcIiksIG8oYykpIDogKG4uY29uc3VtZShjKSwgdSk7XG4gIH1cbiAgZnVuY3Rpb24gYShjKSB7XG4gICAgcmV0dXJuIG4uZXhpdChcImNvZGVJbmRlbnRlZFwiKSwgZShjKTtcbiAgfVxufVxuZnVuY3Rpb24gY2kobiwgZSwgdCkge1xuICBjb25zdCByID0gdGhpcztcbiAgcmV0dXJuIGk7XG4gIGZ1bmN0aW9uIGkobykge1xuICAgIHJldHVybiByLnBhcnNlci5sYXp5W3Iubm93KCkubGluZV0gPyB0KG8pIDogTChvKSA/IChuLmVudGVyKFwibGluZUVuZGluZ1wiKSwgbi5jb25zdW1lKG8pLCBuLmV4aXQoXCJsaW5lRW5kaW5nXCIpLCBpKSA6IFUobiwgbCwgXCJsaW5lUHJlZml4XCIsIDQgKyAxKShvKTtcbiAgfVxuICBmdW5jdGlvbiBsKG8pIHtcbiAgICBjb25zdCB1ID0gci5ldmVudHNbci5ldmVudHMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHUgJiYgdVsxXS50eXBlID09PSBcImxpbmVQcmVmaXhcIiAmJiB1WzJdLnNsaWNlU2VyaWFsaXplKHVbMV0sICEwKS5sZW5ndGggPj0gNCA/IGUobykgOiBMKG8pID8gaShvKSA6IHQobyk7XG4gIH1cbn1cbmNvbnN0IHBpID0ge1xuICBuYW1lOiBcImNvZGVUZXh0XCIsXG4gIHRva2VuaXplOiBtaSxcbiAgcmVzb2x2ZTogZmksXG4gIHByZXZpb3VzOiBoaVxufTtcbmZ1bmN0aW9uIGZpKG4pIHtcbiAgbGV0IGUgPSBuLmxlbmd0aCAtIDQsIHQgPSAzLCByLCBpO1xuICBpZiAoKG5bdF1bMV0udHlwZSA9PT0gXCJsaW5lRW5kaW5nXCIgfHwgblt0XVsxXS50eXBlID09PSBcInNwYWNlXCIpICYmIChuW2VdWzFdLnR5cGUgPT09IFwibGluZUVuZGluZ1wiIHx8IG5bZV1bMV0udHlwZSA9PT0gXCJzcGFjZVwiKSkge1xuICAgIGZvciAociA9IHQ7ICsrciA8IGU7IClcbiAgICAgIGlmIChuW3JdWzFdLnR5cGUgPT09IFwiY29kZVRleHREYXRhXCIpIHtcbiAgICAgICAgblt0XVsxXS50eXBlID0gXCJjb2RlVGV4dFBhZGRpbmdcIiwgbltlXVsxXS50eXBlID0gXCJjb2RlVGV4dFBhZGRpbmdcIiwgdCArPSAyLCBlIC09IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG4gIGZvciAociA9IHQgLSAxLCBlKys7ICsrciA8PSBlOyApXG4gICAgaSA9PT0gdm9pZCAwID8gciAhPT0gZSAmJiBuW3JdWzFdLnR5cGUgIT09IFwibGluZUVuZGluZ1wiICYmIChpID0gcikgOiAociA9PT0gZSB8fCBuW3JdWzFdLnR5cGUgPT09IFwibGluZUVuZGluZ1wiKSAmJiAobltpXVsxXS50eXBlID0gXCJjb2RlVGV4dERhdGFcIiwgciAhPT0gaSArIDIgJiYgKG5baV1bMV0uZW5kID0gbltyIC0gMV1bMV0uZW5kLCBuLnNwbGljZShpICsgMiwgciAtIGkgLSAyKSwgZSAtPSByIC0gaSAtIDIsIHIgPSBpICsgMiksIGkgPSB2b2lkIDApO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGhpKG4pIHtcbiAgcmV0dXJuIG4gIT09IDk2IHx8IHRoaXMuZXZlbnRzW3RoaXMuZXZlbnRzLmxlbmd0aCAtIDFdWzFdLnR5cGUgPT09IFwiY2hhcmFjdGVyRXNjYXBlXCI7XG59XG5mdW5jdGlvbiBtaShuLCBlLCB0KSB7XG4gIGxldCByID0gMCwgaSwgbDtcbiAgcmV0dXJuIG87XG4gIGZ1bmN0aW9uIG8oaCkge1xuICAgIHJldHVybiBuLmVudGVyKFwiY29kZVRleHRcIiksIG4uZW50ZXIoXCJjb2RlVGV4dFNlcXVlbmNlXCIpLCB1KGgpO1xuICB9XG4gIGZ1bmN0aW9uIHUoaCkge1xuICAgIHJldHVybiBoID09PSA5NiA/IChuLmNvbnN1bWUoaCksIHIrKywgdSkgOiAobi5leGl0KFwiY29kZVRleHRTZXF1ZW5jZVwiKSwgYShoKSk7XG4gIH1cbiAgZnVuY3Rpb24gYShoKSB7XG4gICAgcmV0dXJuIGggPT09IG51bGwgPyB0KGgpIDogaCA9PT0gOTYgPyAobCA9IG4uZW50ZXIoXCJjb2RlVGV4dFNlcXVlbmNlXCIpLCBpID0gMCwgcyhoKSkgOiBoID09PSAzMiA/IChuLmVudGVyKFwic3BhY2VcIiksIG4uY29uc3VtZShoKSwgbi5leGl0KFwic3BhY2VcIiksIGEpIDogTChoKSA/IChuLmVudGVyKFwibGluZUVuZGluZ1wiKSwgbi5jb25zdW1lKGgpLCBuLmV4aXQoXCJsaW5lRW5kaW5nXCIpLCBhKSA6IChuLmVudGVyKFwiY29kZVRleHREYXRhXCIpLCBjKGgpKTtcbiAgfVxuICBmdW5jdGlvbiBjKGgpIHtcbiAgICByZXR1cm4gaCA9PT0gbnVsbCB8fCBoID09PSAzMiB8fCBoID09PSA5NiB8fCBMKGgpID8gKG4uZXhpdChcImNvZGVUZXh0RGF0YVwiKSwgYShoKSkgOiAobi5jb25zdW1lKGgpLCBjKTtcbiAgfVxuICBmdW5jdGlvbiBzKGgpIHtcbiAgICByZXR1cm4gaCA9PT0gOTYgPyAobi5jb25zdW1lKGgpLCBpKyssIHMpIDogaSA9PT0gciA/IChuLmV4aXQoXCJjb2RlVGV4dFNlcXVlbmNlXCIpLCBuLmV4aXQoXCJjb2RlVGV4dFwiKSwgZShoKSkgOiAobC50eXBlID0gXCJjb2RlVGV4dERhdGFcIiwgYyhoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIFJ0KG4pIHtcbiAgY29uc3QgZSA9IHt9O1xuICBsZXQgdCA9IC0xLCByLCBpLCBsLCBvLCB1LCBhLCBjO1xuICBmb3IgKDsgKyt0IDwgbi5sZW5ndGg7ICkge1xuICAgIGZvciAoOyB0IGluIGU7IClcbiAgICAgIHQgPSBlW3RdO1xuICAgIGlmIChyID0gblt0XSwgdCAmJiByWzFdLnR5cGUgPT09IFwiY2h1bmtGbG93XCIgJiYgblt0IC0gMV1bMV0udHlwZSA9PT0gXCJsaXN0SXRlbVByZWZpeFwiICYmIChhID0gclsxXS5fdG9rZW5pemVyLmV2ZW50cywgbCA9IDAsIGwgPCBhLmxlbmd0aCAmJiBhW2xdWzFdLnR5cGUgPT09IFwibGluZUVuZGluZ0JsYW5rXCIgJiYgKGwgKz0gMiksIGwgPCBhLmxlbmd0aCAmJiBhW2xdWzFdLnR5cGUgPT09IFwiY29udGVudFwiKSlcbiAgICAgIGZvciAoOyArK2wgPCBhLmxlbmd0aCAmJiBhW2xdWzFdLnR5cGUgIT09IFwiY29udGVudFwiOyApXG4gICAgICAgIGFbbF1bMV0udHlwZSA9PT0gXCJjaHVua1RleHRcIiAmJiAoYVtsXVsxXS5faXNJbkZpcnN0Q29udGVudE9mTGlzdEl0ZW0gPSAhMCwgbCsrKTtcbiAgICBpZiAoclswXSA9PT0gXCJlbnRlclwiKVxuICAgICAgclsxXS5jb250ZW50VHlwZSAmJiAoT2JqZWN0LmFzc2lnbihlLCBkaShuLCB0KSksIHQgPSBlW3RdLCBjID0gITApO1xuICAgIGVsc2UgaWYgKHJbMV0uX2NvbnRhaW5lcikge1xuICAgICAgZm9yIChsID0gdCwgaSA9IHZvaWQgMDsgbC0tICYmIChvID0gbltsXSwgb1sxXS50eXBlID09PSBcImxpbmVFbmRpbmdcIiB8fCBvWzFdLnR5cGUgPT09IFwibGluZUVuZGluZ0JsYW5rXCIpOyApXG4gICAgICAgIG9bMF0gPT09IFwiZW50ZXJcIiAmJiAoaSAmJiAobltpXVsxXS50eXBlID0gXCJsaW5lRW5kaW5nQmxhbmtcIiksIG9bMV0udHlwZSA9IFwibGluZUVuZGluZ1wiLCBpID0gbCk7XG4gICAgICBpICYmIChyWzFdLmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIG5baV1bMV0uc3RhcnQpLCB1ID0gbi5zbGljZShpLCB0KSwgdS51bnNoaWZ0KHIpLCBnbihuLCBpLCB0IC0gaSArIDEsIHUpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICFjO1xufVxuZnVuY3Rpb24gZGkobiwgZSkge1xuICBjb25zdCB0ID0gbltlXVsxXSwgciA9IG5bZV1bMl07XG4gIGxldCBpID0gZSAtIDE7XG4gIGNvbnN0IGwgPSBbXSwgbyA9IHQuX3Rva2VuaXplciB8fCByLnBhcnNlclt0LmNvbnRlbnRUeXBlXSh0LnN0YXJ0KSwgdSA9IG8uZXZlbnRzLCBhID0gW10sIGMgPSB7fTtcbiAgbGV0IHMsIGgsIGcgPSAtMSwgZCA9IHQsIG0gPSAwLCB5ID0gMDtcbiAgY29uc3QgeCA9IFt5XTtcbiAgZm9yICg7IGQ7ICkge1xuICAgIGZvciAoOyBuWysraV1bMV0gIT09IGQ7IClcbiAgICAgIDtcbiAgICBsLnB1c2goaSksIGQuX3Rva2VuaXplciB8fCAocyA9IHIuc2xpY2VTdHJlYW0oZCksIGQubmV4dCB8fCBzLnB1c2gobnVsbCksIGggJiYgby5kZWZpbmVTa2lwKGQuc3RhcnQpLCBkLl9pc0luRmlyc3RDb250ZW50T2ZMaXN0SXRlbSAmJiAoby5fZ2ZtVGFza2xpc3RGaXJzdENvbnRlbnRPZkxpc3RJdGVtID0gITApLCBvLndyaXRlKHMpLCBkLl9pc0luRmlyc3RDb250ZW50T2ZMaXN0SXRlbSAmJiAoby5fZ2ZtVGFza2xpc3RGaXJzdENvbnRlbnRPZkxpc3RJdGVtID0gdm9pZCAwKSksIGggPSBkLCBkID0gZC5uZXh0O1xuICB9XG4gIGZvciAoZCA9IHQ7ICsrZyA8IHUubGVuZ3RoOyApXG4gICAgLy8gRmluZCBhIHZvaWQgdG9rZW4gdGhhdCBpbmNsdWRlcyBhIGJyZWFrLlxuICAgIHVbZ11bMF0gPT09IFwiZXhpdFwiICYmIHVbZyAtIDFdWzBdID09PSBcImVudGVyXCIgJiYgdVtnXVsxXS50eXBlID09PSB1W2cgLSAxXVsxXS50eXBlICYmIHVbZ11bMV0uc3RhcnQubGluZSAhPT0gdVtnXVsxXS5lbmQubGluZSAmJiAoeSA9IGcgKyAxLCB4LnB1c2goeSksIGQuX3Rva2VuaXplciA9IHZvaWQgMCwgZC5wcmV2aW91cyA9IHZvaWQgMCwgZCA9IGQubmV4dCk7XG4gIGZvciAoby5ldmVudHMgPSBbXSwgZCA/IChkLl90b2tlbml6ZXIgPSB2b2lkIDAsIGQucHJldmlvdXMgPSB2b2lkIDApIDogeC5wb3AoKSwgZyA9IHgubGVuZ3RoOyBnLS07ICkge1xuICAgIGNvbnN0IHcgPSB1LnNsaWNlKHhbZ10sIHhbZyArIDFdKSwgdiA9IGwucG9wKCk7XG4gICAgYS51bnNoaWZ0KFt2LCB2ICsgdy5sZW5ndGggLSAxXSksIGduKG4sIHYsIDIsIHcpO1xuICB9XG4gIGZvciAoZyA9IC0xOyArK2cgPCBhLmxlbmd0aDsgKVxuICAgIGNbbSArIGFbZ11bMF1dID0gbSArIGFbZ11bMV0sIG0gKz0gYVtnXVsxXSAtIGFbZ11bMF0gLSAxO1xuICByZXR1cm4gYztcbn1cbmNvbnN0IGdpID0ge1xuICB0b2tlbml6ZToga2ksXG4gIHJlc29sdmU6IHhpXG59LCB5aSA9IHtcbiAgdG9rZW5pemU6IGJpLFxuICBwYXJ0aWFsOiAhMFxufTtcbmZ1bmN0aW9uIHhpKG4pIHtcbiAgcmV0dXJuIFJ0KG4pLCBuO1xufVxuZnVuY3Rpb24ga2kobiwgZSkge1xuICBsZXQgdDtcbiAgcmV0dXJuIHI7XG4gIGZ1bmN0aW9uIHIodSkge1xuICAgIHJldHVybiBuLmVudGVyKFwiY29udGVudFwiKSwgdCA9IG4uZW50ZXIoXCJjaHVua0NvbnRlbnRcIiwge1xuICAgICAgY29udGVudFR5cGU6IFwiY29udGVudFwiXG4gICAgfSksIGkodSk7XG4gIH1cbiAgZnVuY3Rpb24gaSh1KSB7XG4gICAgcmV0dXJuIHUgPT09IG51bGwgPyBsKHUpIDogTCh1KSA/IG4uY2hlY2soXG4gICAgICB5aSxcbiAgICAgIG8sXG4gICAgICBsXG4gICAgKSh1KSA6IChuLmNvbnN1bWUodSksIGkpO1xuICB9XG4gIGZ1bmN0aW9uIGwodSkge1xuICAgIHJldHVybiBuLmV4aXQoXCJjaHVua0NvbnRlbnRcIiksIG4uZXhpdChcImNvbnRlbnRcIiksIGUodSk7XG4gIH1cbiAgZnVuY3Rpb24gbyh1KSB7XG4gICAgcmV0dXJuIG4uY29uc3VtZSh1KSwgbi5leGl0KFwiY2h1bmtDb250ZW50XCIpLCB0Lm5leHQgPSBuLmVudGVyKFwiY2h1bmtDb250ZW50XCIsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiBcImNvbnRlbnRcIixcbiAgICAgIHByZXZpb3VzOiB0XG4gICAgfSksIHQgPSB0Lm5leHQsIGk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJpKG4sIGUsIHQpIHtcbiAgY29uc3QgciA9IHRoaXM7XG4gIHJldHVybiBpO1xuICBmdW5jdGlvbiBpKG8pIHtcbiAgICByZXR1cm4gbi5leGl0KFwiY2h1bmtDb250ZW50XCIpLCBuLmVudGVyKFwibGluZUVuZGluZ1wiKSwgbi5jb25zdW1lKG8pLCBuLmV4aXQoXCJsaW5lRW5kaW5nXCIpLCBVKG4sIGwsIFwibGluZVByZWZpeFwiKTtcbiAgfVxuICBmdW5jdGlvbiBsKG8pIHtcbiAgICBpZiAobyA9PT0gbnVsbCB8fCBMKG8pKVxuICAgICAgcmV0dXJuIHQobyk7XG4gICAgY29uc3QgdSA9IHIuZXZlbnRzW3IuZXZlbnRzLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiAhci5wYXJzZXIuY29uc3RydWN0cy5kaXNhYmxlLm51bGwuaW5jbHVkZXMoXCJjb2RlSW5kZW50ZWRcIikgJiYgdSAmJiB1WzFdLnR5cGUgPT09IFwibGluZVByZWZpeFwiICYmIHVbMl0uc2xpY2VTZXJpYWxpemUodVsxXSwgITApLmxlbmd0aCA+PSA0ID8gZShvKSA6IG4uaW50ZXJydXB0KHIucGFyc2VyLmNvbnN0cnVjdHMuZmxvdywgdCwgZSkobyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF90KG4sIGUsIHQsIHIsIGksIGwsIG8sIHUsIGEpIHtcbiAgY29uc3QgYyA9IGEgfHwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICBsZXQgcyA9IDA7XG4gIHJldHVybiBoO1xuICBmdW5jdGlvbiBoKHcpIHtcbiAgICByZXR1cm4gdyA9PT0gNjAgPyAobi5lbnRlcihyKSwgbi5lbnRlcihpKSwgbi5lbnRlcihsKSwgbi5jb25zdW1lKHcpLCBuLmV4aXQobCksIGcpIDogdyA9PT0gbnVsbCB8fCB3ID09PSA0MSB8fCB5ZSh3KSA/IHQodykgOiAobi5lbnRlcihyKSwgbi5lbnRlcihvKSwgbi5lbnRlcih1KSwgbi5lbnRlcihcImNodW5rU3RyaW5nXCIsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiBcInN0cmluZ1wiXG4gICAgfSksIHkodykpO1xuICB9XG4gIGZ1bmN0aW9uIGcodykge1xuICAgIHJldHVybiB3ID09PSA2MiA/IChuLmVudGVyKGwpLCBuLmNvbnN1bWUodyksIG4uZXhpdChsKSwgbi5leGl0KGkpLCBuLmV4aXQociksIGUpIDogKG4uZW50ZXIodSksIG4uZW50ZXIoXCJjaHVua1N0cmluZ1wiLCB7XG4gICAgICBjb250ZW50VHlwZTogXCJzdHJpbmdcIlxuICAgIH0pLCBkKHcpKTtcbiAgfVxuICBmdW5jdGlvbiBkKHcpIHtcbiAgICByZXR1cm4gdyA9PT0gNjIgPyAobi5leGl0KFwiY2h1bmtTdHJpbmdcIiksIG4uZXhpdCh1KSwgZyh3KSkgOiB3ID09PSBudWxsIHx8IHcgPT09IDYwIHx8IEwodykgPyB0KHcpIDogKG4uY29uc3VtZSh3KSwgdyA9PT0gOTIgPyBtIDogZCk7XG4gIH1cbiAgZnVuY3Rpb24gbSh3KSB7XG4gICAgcmV0dXJuIHcgPT09IDYwIHx8IHcgPT09IDYyIHx8IHcgPT09IDkyID8gKG4uY29uc3VtZSh3KSwgZCkgOiBkKHcpO1xuICB9XG4gIGZ1bmN0aW9uIHkodykge1xuICAgIHJldHVybiB3ID09PSA0MCA/ICsrcyA+IGMgPyB0KHcpIDogKG4uY29uc3VtZSh3KSwgeSkgOiB3ID09PSA0MSA/IHMtLSA/IChuLmNvbnN1bWUodyksIHkpIDogKG4uZXhpdChcImNodW5rU3RyaW5nXCIpLCBuLmV4aXQodSksIG4uZXhpdChvKSwgbi5leGl0KHIpLCBlKHcpKSA6IHcgPT09IG51bGwgfHwgc24odykgPyBzID8gdCh3KSA6IChuLmV4aXQoXCJjaHVua1N0cmluZ1wiKSwgbi5leGl0KHUpLCBuLmV4aXQobyksIG4uZXhpdChyKSwgZSh3KSkgOiB5ZSh3KSA/IHQodykgOiAobi5jb25zdW1lKHcpLCB3ID09PSA5MiA/IHggOiB5KTtcbiAgfVxuICBmdW5jdGlvbiB4KHcpIHtcbiAgICByZXR1cm4gdyA9PT0gNDAgfHwgdyA9PT0gNDEgfHwgdyA9PT0gOTIgPyAobi5jb25zdW1lKHcpLCB5KSA6IHkodyk7XG4gIH1cbn1cbmZ1bmN0aW9uIE10KG4sIGUsIHQsIHIsIGksIGwpIHtcbiAgY29uc3QgbyA9IHRoaXM7XG4gIGxldCB1ID0gMCwgYTtcbiAgcmV0dXJuIGM7XG4gIGZ1bmN0aW9uIGMoZCkge1xuICAgIHJldHVybiBuLmVudGVyKHIpLCBuLmVudGVyKGkpLCBuLmNvbnN1bWUoZCksIG4uZXhpdChpKSwgbi5lbnRlcihsKSwgcztcbiAgfVxuICBmdW5jdGlvbiBzKGQpIHtcbiAgICByZXR1cm4gZCA9PT0gbnVsbCB8fCBkID09PSA5MSB8fCBkID09PSA5MyAmJiAhYSB8fCAvKiBUbyBkbzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgb25jZSB3ZeKAmXZlIHN3aXRjaGVkIGZyb21cbiAgICAgKiBgbWljcm9tYXJrLWV4dGVuc2lvbi1mb290bm90ZWAgdG8gYG1pY3JvbWFyay1leHRlbnNpb24tZ2ZtLWZvb3Rub3RlYCxcbiAgICAgKiB3aGljaCBkb2VzbuKAmXQgbmVlZCB0aGlzICovXG4gICAgLyogSGlkZGVuIGZvb3Rub3RlcyBob29rICovXG4gICAgLyogYzggaWdub3JlIG5leHQgMyAqL1xuICAgIGQgPT09IDk0ICYmICF1ICYmIFwiX2hpZGRlbkZvb3Rub3RlU3VwcG9ydFwiIGluIG8ucGFyc2VyLmNvbnN0cnVjdHMgfHwgdSA+IDk5OSA/IHQoZCkgOiBkID09PSA5MyA/IChuLmV4aXQobCksIG4uZW50ZXIoaSksIG4uY29uc3VtZShkKSwgbi5leGl0KGkpLCBuLmV4aXQociksIGUpIDogTChkKSA/IChuLmVudGVyKFwibGluZUVuZGluZ1wiKSwgbi5jb25zdW1lKGQpLCBuLmV4aXQoXCJsaW5lRW5kaW5nXCIpLCBzKSA6IChuLmVudGVyKFwiY2h1bmtTdHJpbmdcIiwge1xuICAgICAgY29udGVudFR5cGU6IFwic3RyaW5nXCJcbiAgICB9KSwgaChkKSk7XG4gIH1cbiAgZnVuY3Rpb24gaChkKSB7XG4gICAgcmV0dXJuIGQgPT09IG51bGwgfHwgZCA9PT0gOTEgfHwgZCA9PT0gOTMgfHwgTChkKSB8fCB1KysgPiA5OTkgPyAobi5leGl0KFwiY2h1bmtTdHJpbmdcIiksIHMoZCkpIDogKG4uY29uc3VtZShkKSwgYSA9IGEgfHwgIUcoZCksIGQgPT09IDkyID8gZyA6IGgpO1xuICB9XG4gIGZ1bmN0aW9uIGcoZCkge1xuICAgIHJldHVybiBkID09PSA5MSB8fCBkID09PSA5MiB8fCBkID09PSA5MyA/IChuLmNvbnN1bWUoZCksIHUrKywgaCkgOiBoKGQpO1xuICB9XG59XG5mdW5jdGlvbiBCdChuLCBlLCB0LCByLCBpLCBsKSB7XG4gIGxldCBvO1xuICByZXR1cm4gdTtcbiAgZnVuY3Rpb24gdShnKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIociksIG4uZW50ZXIoaSksIG4uY29uc3VtZShnKSwgbi5leGl0KGkpLCBvID0gZyA9PT0gNDAgPyA0MSA6IGcsIGE7XG4gIH1cbiAgZnVuY3Rpb24gYShnKSB7XG4gICAgcmV0dXJuIGcgPT09IG8gPyAobi5lbnRlcihpKSwgbi5jb25zdW1lKGcpLCBuLmV4aXQoaSksIG4uZXhpdChyKSwgZSkgOiAobi5lbnRlcihsKSwgYyhnKSk7XG4gIH1cbiAgZnVuY3Rpb24gYyhnKSB7XG4gICAgcmV0dXJuIGcgPT09IG8gPyAobi5leGl0KGwpLCBhKG8pKSA6IGcgPT09IG51bGwgPyB0KGcpIDogTChnKSA/IChuLmVudGVyKFwibGluZUVuZGluZ1wiKSwgbi5jb25zdW1lKGcpLCBuLmV4aXQoXCJsaW5lRW5kaW5nXCIpLCBVKG4sIGMsIFwibGluZVByZWZpeFwiKSkgOiAobi5lbnRlcihcImNodW5rU3RyaW5nXCIsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiBcInN0cmluZ1wiXG4gICAgfSksIHMoZykpO1xuICB9XG4gIGZ1bmN0aW9uIHMoZykge1xuICAgIHJldHVybiBnID09PSBvIHx8IGcgPT09IG51bGwgfHwgTChnKSA/IChuLmV4aXQoXCJjaHVua1N0cmluZ1wiKSwgYyhnKSkgOiAobi5jb25zdW1lKGcpLCBnID09PSA5MiA/IGggOiBzKTtcbiAgfVxuICBmdW5jdGlvbiBoKGcpIHtcbiAgICByZXR1cm4gZyA9PT0gbyB8fCBnID09PSA5MiA/IChuLmNvbnN1bWUoZyksIHMpIDogcyhnKTtcbiAgfVxufVxuZnVuY3Rpb24gJG4obiwgZSkge1xuICBsZXQgdDtcbiAgcmV0dXJuIHI7XG4gIGZ1bmN0aW9uIHIoaSkge1xuICAgIHJldHVybiBMKGkpID8gKG4uZW50ZXIoXCJsaW5lRW5kaW5nXCIpLCBuLmNvbnN1bWUoaSksIG4uZXhpdChcImxpbmVFbmRpbmdcIiksIHQgPSAhMCwgcikgOiBHKGkpID8gVShcbiAgICAgIG4sXG4gICAgICByLFxuICAgICAgdCA/IFwibGluZVByZWZpeFwiIDogXCJsaW5lU3VmZml4XCJcbiAgICApKGkpIDogZShpKTtcbiAgfVxufVxuZnVuY3Rpb24gTG4obikge1xuICByZXR1cm4gbi5yZXBsYWNlKC9bXFx0XFxuXFxyIF0rL2csIFwiIFwiKS5yZXBsYWNlKC9eIHwgJC9nLCBcIlwiKS50b0xvd2VyQ2FzZSgpLnRvVXBwZXJDYXNlKCk7XG59XG5jb25zdCB3aSA9IHtcbiAgbmFtZTogXCJkZWZpbml0aW9uXCIsXG4gIHRva2VuaXplOiBFaVxufSwgU2kgPSB7XG4gIHRva2VuaXplOiBDaSxcbiAgcGFydGlhbDogITBcbn07XG5mdW5jdGlvbiBFaShuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB0aGlzO1xuICBsZXQgaTtcbiAgcmV0dXJuIGw7XG4gIGZ1bmN0aW9uIGwoYSkge1xuICAgIHJldHVybiBuLmVudGVyKFwiZGVmaW5pdGlvblwiKSwgTXQuY2FsbChcbiAgICAgIHIsXG4gICAgICBuLFxuICAgICAgbyxcbiAgICAgIHQsXG4gICAgICBcImRlZmluaXRpb25MYWJlbFwiLFxuICAgICAgXCJkZWZpbml0aW9uTGFiZWxNYXJrZXJcIixcbiAgICAgIFwiZGVmaW5pdGlvbkxhYmVsU3RyaW5nXCJcbiAgICApKGEpO1xuICB9XG4gIGZ1bmN0aW9uIG8oYSkge1xuICAgIHJldHVybiBpID0gTG4oXG4gICAgICByLnNsaWNlU2VyaWFsaXplKHIuZXZlbnRzW3IuZXZlbnRzLmxlbmd0aCAtIDFdWzFdKS5zbGljZSgxLCAtMSlcbiAgICApLCBhID09PSA1OCA/IChuLmVudGVyKFwiZGVmaW5pdGlvbk1hcmtlclwiKSwgbi5jb25zdW1lKGEpLCBuLmV4aXQoXCJkZWZpbml0aW9uTWFya2VyXCIpLCAkbihcbiAgICAgIG4sXG4gICAgICBfdChcbiAgICAgICAgbixcbiAgICAgICAgbi5hdHRlbXB0KFxuICAgICAgICAgIFNpLFxuICAgICAgICAgIFUobiwgdSwgXCJ3aGl0ZXNwYWNlXCIpLFxuICAgICAgICAgIFUobiwgdSwgXCJ3aGl0ZXNwYWNlXCIpXG4gICAgICAgICksXG4gICAgICAgIHQsXG4gICAgICAgIFwiZGVmaW5pdGlvbkRlc3RpbmF0aW9uXCIsXG4gICAgICAgIFwiZGVmaW5pdGlvbkRlc3RpbmF0aW9uTGl0ZXJhbFwiLFxuICAgICAgICBcImRlZmluaXRpb25EZXN0aW5hdGlvbkxpdGVyYWxNYXJrZXJcIixcbiAgICAgICAgXCJkZWZpbml0aW9uRGVzdGluYXRpb25SYXdcIixcbiAgICAgICAgXCJkZWZpbml0aW9uRGVzdGluYXRpb25TdHJpbmdcIlxuICAgICAgKVxuICAgICkpIDogdChhKTtcbiAgfVxuICBmdW5jdGlvbiB1KGEpIHtcbiAgICByZXR1cm4gYSA9PT0gbnVsbCB8fCBMKGEpID8gKG4uZXhpdChcImRlZmluaXRpb25cIiksIHIucGFyc2VyLmRlZmluZWQuaW5jbHVkZXMoaSkgfHwgci5wYXJzZXIuZGVmaW5lZC5wdXNoKGkpLCBlKGEpKSA6IHQoYSk7XG4gIH1cbn1cbmZ1bmN0aW9uIENpKG4sIGUsIHQpIHtcbiAgcmV0dXJuIHI7XG4gIGZ1bmN0aW9uIHIobykge1xuICAgIHJldHVybiBzbihvKSA/ICRuKG4sIGkpKG8pIDogdChvKTtcbiAgfVxuICBmdW5jdGlvbiBpKG8pIHtcbiAgICByZXR1cm4gbyA9PT0gMzQgfHwgbyA9PT0gMzkgfHwgbyA9PT0gNDAgPyBCdChcbiAgICAgIG4sXG4gICAgICBVKG4sIGwsIFwid2hpdGVzcGFjZVwiKSxcbiAgICAgIHQsXG4gICAgICBcImRlZmluaXRpb25UaXRsZVwiLFxuICAgICAgXCJkZWZpbml0aW9uVGl0bGVNYXJrZXJcIixcbiAgICAgIFwiZGVmaW5pdGlvblRpdGxlU3RyaW5nXCJcbiAgICApKG8pIDogdChvKTtcbiAgfVxuICBmdW5jdGlvbiBsKG8pIHtcbiAgICByZXR1cm4gbyA9PT0gbnVsbCB8fCBMKG8pID8gZShvKSA6IHQobyk7XG4gIH1cbn1cbmNvbnN0IEFpID0ge1xuICBuYW1lOiBcImhhcmRCcmVha0VzY2FwZVwiLFxuICB0b2tlbml6ZTogUGlcbn07XG5mdW5jdGlvbiBQaShuLCBlLCB0KSB7XG4gIHJldHVybiByO1xuICBmdW5jdGlvbiByKGwpIHtcbiAgICByZXR1cm4gbi5lbnRlcihcImhhcmRCcmVha0VzY2FwZVwiKSwgbi5lbnRlcihcImVzY2FwZU1hcmtlclwiKSwgbi5jb25zdW1lKGwpLCBpO1xuICB9XG4gIGZ1bmN0aW9uIGkobCkge1xuICAgIHJldHVybiBMKGwpID8gKG4uZXhpdChcImVzY2FwZU1hcmtlclwiKSwgbi5leGl0KFwiaGFyZEJyZWFrRXNjYXBlXCIpLCBlKGwpKSA6IHQobCk7XG4gIH1cbn1cbmNvbnN0IEZpID0ge1xuICBuYW1lOiBcImhlYWRpbmdBdHhcIixcbiAgdG9rZW5pemU6IElpLFxuICByZXNvbHZlOiBUaVxufTtcbmZ1bmN0aW9uIFRpKG4sIGUpIHtcbiAgbGV0IHQgPSBuLmxlbmd0aCAtIDIsIHIgPSAzLCBpLCBsO1xuICByZXR1cm4gbltyXVsxXS50eXBlID09PSBcIndoaXRlc3BhY2VcIiAmJiAociArPSAyKSwgdCAtIDIgPiByICYmIG5bdF1bMV0udHlwZSA9PT0gXCJ3aGl0ZXNwYWNlXCIgJiYgKHQgLT0gMiksIG5bdF1bMV0udHlwZSA9PT0gXCJhdHhIZWFkaW5nU2VxdWVuY2VcIiAmJiAociA9PT0gdCAtIDEgfHwgdCAtIDQgPiByICYmIG5bdCAtIDJdWzFdLnR5cGUgPT09IFwid2hpdGVzcGFjZVwiKSAmJiAodCAtPSByICsgMSA9PT0gdCA/IDIgOiA0KSwgdCA+IHIgJiYgKGkgPSB7XG4gICAgdHlwZTogXCJhdHhIZWFkaW5nVGV4dFwiLFxuICAgIHN0YXJ0OiBuW3JdWzFdLnN0YXJ0LFxuICAgIGVuZDogblt0XVsxXS5lbmRcbiAgfSwgbCA9IHtcbiAgICB0eXBlOiBcImNodW5rVGV4dFwiLFxuICAgIHN0YXJ0OiBuW3JdWzFdLnN0YXJ0LFxuICAgIGVuZDogblt0XVsxXS5lbmQsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBDb25zdGFudHMgYXJlIGZpbmUgdG8gYXNzaWduLlxuICAgIGNvbnRlbnRUeXBlOiBcInRleHRcIlxuICB9LCBnbihuLCByLCB0IC0gciArIDEsIFtcbiAgICBbXCJlbnRlclwiLCBpLCBlXSxcbiAgICBbXCJlbnRlclwiLCBsLCBlXSxcbiAgICBbXCJleGl0XCIsIGwsIGVdLFxuICAgIFtcImV4aXRcIiwgaSwgZV1cbiAgXSkpLCBuO1xufVxuZnVuY3Rpb24gSWkobiwgZSwgdCkge1xuICBjb25zdCByID0gdGhpcztcbiAgbGV0IGkgPSAwO1xuICByZXR1cm4gbDtcbiAgZnVuY3Rpb24gbChzKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJhdHhIZWFkaW5nXCIpLCBuLmVudGVyKFwiYXR4SGVhZGluZ1NlcXVlbmNlXCIpLCBvKHMpO1xuICB9XG4gIGZ1bmN0aW9uIG8ocykge1xuICAgIHJldHVybiBzID09PSAzNSAmJiBpKysgPCA2ID8gKG4uY29uc3VtZShzKSwgbykgOiBzID09PSBudWxsIHx8IHNuKHMpID8gKG4uZXhpdChcImF0eEhlYWRpbmdTZXF1ZW5jZVwiKSwgci5pbnRlcnJ1cHQgPyBlKHMpIDogdShzKSkgOiB0KHMpO1xuICB9XG4gIGZ1bmN0aW9uIHUocykge1xuICAgIHJldHVybiBzID09PSAzNSA/IChuLmVudGVyKFwiYXR4SGVhZGluZ1NlcXVlbmNlXCIpLCBhKHMpKSA6IHMgPT09IG51bGwgfHwgTChzKSA/IChuLmV4aXQoXCJhdHhIZWFkaW5nXCIpLCBlKHMpKSA6IEcocykgPyBVKG4sIHUsIFwid2hpdGVzcGFjZVwiKShzKSA6IChuLmVudGVyKFwiYXR4SGVhZGluZ1RleHRcIiksIGMocykpO1xuICB9XG4gIGZ1bmN0aW9uIGEocykge1xuICAgIHJldHVybiBzID09PSAzNSA/IChuLmNvbnN1bWUocyksIGEpIDogKG4uZXhpdChcImF0eEhlYWRpbmdTZXF1ZW5jZVwiKSwgdShzKSk7XG4gIH1cbiAgZnVuY3Rpb24gYyhzKSB7XG4gICAgcmV0dXJuIHMgPT09IG51bGwgfHwgcyA9PT0gMzUgfHwgc24ocykgPyAobi5leGl0KFwiYXR4SGVhZGluZ1RleHRcIiksIHUocykpIDogKG4uY29uc3VtZShzKSwgYyk7XG4gIH1cbn1cbmNvbnN0IE9pID0gW1xuICBcImFkZHJlc3NcIixcbiAgXCJhcnRpY2xlXCIsXG4gIFwiYXNpZGVcIixcbiAgXCJiYXNlXCIsXG4gIFwiYmFzZWZvbnRcIixcbiAgXCJibG9ja3F1b3RlXCIsXG4gIFwiYm9keVwiLFxuICBcImNhcHRpb25cIixcbiAgXCJjZW50ZXJcIixcbiAgXCJjb2xcIixcbiAgXCJjb2xncm91cFwiLFxuICBcImRkXCIsXG4gIFwiZGV0YWlsc1wiLFxuICBcImRpYWxvZ1wiLFxuICBcImRpclwiLFxuICBcImRpdlwiLFxuICBcImRsXCIsXG4gIFwiZHRcIixcbiAgXCJmaWVsZHNldFwiLFxuICBcImZpZ2NhcHRpb25cIixcbiAgXCJmaWd1cmVcIixcbiAgXCJmb290ZXJcIixcbiAgXCJmb3JtXCIsXG4gIFwiZnJhbWVcIixcbiAgXCJmcmFtZXNldFwiLFxuICBcImgxXCIsXG4gIFwiaDJcIixcbiAgXCJoM1wiLFxuICBcImg0XCIsXG4gIFwiaDVcIixcbiAgXCJoNlwiLFxuICBcImhlYWRcIixcbiAgXCJoZWFkZXJcIixcbiAgXCJoclwiLFxuICBcImh0bWxcIixcbiAgXCJpZnJhbWVcIixcbiAgXCJsZWdlbmRcIixcbiAgXCJsaVwiLFxuICBcImxpbmtcIixcbiAgXCJtYWluXCIsXG4gIFwibWVudVwiLFxuICBcIm1lbnVpdGVtXCIsXG4gIFwibmF2XCIsXG4gIFwibm9mcmFtZXNcIixcbiAgXCJvbFwiLFxuICBcIm9wdGdyb3VwXCIsXG4gIFwib3B0aW9uXCIsXG4gIFwicFwiLFxuICBcInBhcmFtXCIsXG4gIFwic2VjdGlvblwiLFxuICBcInN1bW1hcnlcIixcbiAgXCJ0YWJsZVwiLFxuICBcInRib2R5XCIsXG4gIFwidGRcIixcbiAgXCJ0Zm9vdFwiLFxuICBcInRoXCIsXG4gIFwidGhlYWRcIixcbiAgXCJ0aXRsZVwiLFxuICBcInRyXCIsXG4gIFwidHJhY2tcIixcbiAgXCJ1bFwiXG5dLCBydCA9IFtcInByZVwiLCBcInNjcmlwdFwiLCBcInN0eWxlXCIsIFwidGV4dGFyZWFcIl0sIExpID0ge1xuICBuYW1lOiBcImh0bWxGbG93XCIsXG4gIHRva2VuaXplOiB6aSxcbiAgcmVzb2x2ZVRvOiB2aSxcbiAgY29uY3JldGU6ICEwXG59LCBEaSA9IHtcbiAgdG9rZW5pemU6IFJpLFxuICBwYXJ0aWFsOiAhMFxufTtcbmZ1bmN0aW9uIHZpKG4pIHtcbiAgbGV0IGUgPSBuLmxlbmd0aDtcbiAgZm9yICg7IGUtLSAmJiAhKG5bZV1bMF0gPT09IFwiZW50ZXJcIiAmJiBuW2VdWzFdLnR5cGUgPT09IFwiaHRtbEZsb3dcIik7IClcbiAgICA7XG4gIHJldHVybiBlID4gMSAmJiBuW2UgLSAyXVsxXS50eXBlID09PSBcImxpbmVQcmVmaXhcIiAmJiAobltlXVsxXS5zdGFydCA9IG5bZSAtIDJdWzFdLnN0YXJ0LCBuW2UgKyAxXVsxXS5zdGFydCA9IG5bZSAtIDJdWzFdLnN0YXJ0LCBuLnNwbGljZShlIC0gMiwgMikpLCBuO1xufVxuZnVuY3Rpb24gemkobiwgZSwgdCkge1xuICBjb25zdCByID0gdGhpcztcbiAgbGV0IGksIGwsIG8sIHUsIGE7XG4gIHJldHVybiBjO1xuICBmdW5jdGlvbiBjKHApIHtcbiAgICByZXR1cm4gbi5lbnRlcihcImh0bWxGbG93XCIpLCBuLmVudGVyKFwiaHRtbEZsb3dEYXRhXCIpLCBuLmNvbnN1bWUocCksIHM7XG4gIH1cbiAgZnVuY3Rpb24gcyhwKSB7XG4gICAgcmV0dXJuIHAgPT09IDMzID8gKG4uY29uc3VtZShwKSwgaCkgOiBwID09PSA0NyA/IChuLmNvbnN1bWUocCksIG0pIDogcCA9PT0gNjMgPyAobi5jb25zdW1lKHApLCBpID0gMywgci5pbnRlcnJ1cHQgPyBlIDogSikgOiBkbihwKSA/IChuLmNvbnN1bWUocCksIG8gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHApLCBsID0gITAsIHkpIDogdChwKTtcbiAgfVxuICBmdW5jdGlvbiBoKHApIHtcbiAgICByZXR1cm4gcCA9PT0gNDUgPyAobi5jb25zdW1lKHApLCBpID0gMiwgZykgOiBwID09PSA5MSA/IChuLmNvbnN1bWUocCksIGkgPSA1LCBvID0gXCJDREFUQVtcIiwgdSA9IDAsIGQpIDogZG4ocCkgPyAobi5jb25zdW1lKHApLCBpID0gNCwgci5pbnRlcnJ1cHQgPyBlIDogSikgOiB0KHApO1xuICB9XG4gIGZ1bmN0aW9uIGcocCkge1xuICAgIHJldHVybiBwID09PSA0NSA/IChuLmNvbnN1bWUocCksIHIuaW50ZXJydXB0ID8gZSA6IEopIDogdChwKTtcbiAgfVxuICBmdW5jdGlvbiBkKHApIHtcbiAgICByZXR1cm4gcCA9PT0gby5jaGFyQ29kZUF0KHUrKykgPyAobi5jb25zdW1lKHApLCB1ID09PSBvLmxlbmd0aCA/IHIuaW50ZXJydXB0ID8gZSA6IEMgOiBkKSA6IHQocCk7XG4gIH1cbiAgZnVuY3Rpb24gbShwKSB7XG4gICAgcmV0dXJuIGRuKHApID8gKG4uY29uc3VtZShwKSwgbyA9IFN0cmluZy5mcm9tQ2hhckNvZGUocCksIHkpIDogdChwKTtcbiAgfVxuICBmdW5jdGlvbiB5KHApIHtcbiAgICByZXR1cm4gcCA9PT0gbnVsbCB8fCBwID09PSA0NyB8fCBwID09PSA2MiB8fCBzbihwKSA/IHAgIT09IDQ3ICYmIGwgJiYgcnQuaW5jbHVkZXMoby50b0xvd2VyQ2FzZSgpKSA/IChpID0gMSwgci5pbnRlcnJ1cHQgPyBlKHApIDogQyhwKSkgOiBPaS5pbmNsdWRlcyhvLnRvTG93ZXJDYXNlKCkpID8gKGkgPSA2LCBwID09PSA0NyA/IChuLmNvbnN1bWUocCksIHgpIDogci5pbnRlcnJ1cHQgPyBlKHApIDogQyhwKSkgOiAoaSA9IDcsIHIuaW50ZXJydXB0ICYmICFyLnBhcnNlci5sYXp5W3Iubm93KCkubGluZV0gPyB0KHApIDogbCA/IHYocCkgOiB3KHApKSA6IHAgPT09IDQ1IHx8IG9uKHApID8gKG4uY29uc3VtZShwKSwgbyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHApLCB5KSA6IHQocCk7XG4gIH1cbiAgZnVuY3Rpb24geChwKSB7XG4gICAgcmV0dXJuIHAgPT09IDYyID8gKG4uY29uc3VtZShwKSwgci5pbnRlcnJ1cHQgPyBlIDogQykgOiB0KHApO1xuICB9XG4gIGZ1bmN0aW9uIHcocCkge1xuICAgIHJldHVybiBHKHApID8gKG4uY29uc3VtZShwKSwgdykgOiBNKHApO1xuICB9XG4gIGZ1bmN0aW9uIHYocCkge1xuICAgIHJldHVybiBwID09PSA0NyA/IChuLmNvbnN1bWUocCksIE0pIDogcCA9PT0gNTggfHwgcCA9PT0gOTUgfHwgZG4ocCkgPyAobi5jb25zdW1lKHApLCBBKSA6IEcocCkgPyAobi5jb25zdW1lKHApLCB2KSA6IE0ocCk7XG4gIH1cbiAgZnVuY3Rpb24gQShwKSB7XG4gICAgcmV0dXJuIHAgPT09IDQ1IHx8IHAgPT09IDQ2IHx8IHAgPT09IDU4IHx8IHAgPT09IDk1IHx8IG9uKHApID8gKG4uY29uc3VtZShwKSwgQSkgOiBfKHApO1xuICB9XG4gIGZ1bmN0aW9uIF8ocCkge1xuICAgIHJldHVybiBwID09PSA2MSA/IChuLmNvbnN1bWUocCksIFQpIDogRyhwKSA/IChuLmNvbnN1bWUocCksIF8pIDogdihwKTtcbiAgfVxuICBmdW5jdGlvbiBUKHApIHtcbiAgICByZXR1cm4gcCA9PT0gbnVsbCB8fCBwID09PSA2MCB8fCBwID09PSA2MSB8fCBwID09PSA2MiB8fCBwID09PSA5NiA/IHQocCkgOiBwID09PSAzNCB8fCBwID09PSAzOSA/IChuLmNvbnN1bWUocCksIGEgPSBwLCBiKSA6IEcocCkgPyAobi5jb25zdW1lKHApLCBUKSA6IChhID0gbnVsbCwgSShwKSk7XG4gIH1cbiAgZnVuY3Rpb24gYihwKSB7XG4gICAgcmV0dXJuIHAgPT09IG51bGwgfHwgTChwKSA/IHQocCkgOiBwID09PSBhID8gKG4uY29uc3VtZShwKSwgUikgOiAobi5jb25zdW1lKHApLCBiKTtcbiAgfVxuICBmdW5jdGlvbiBJKHApIHtcbiAgICByZXR1cm4gcCA9PT0gbnVsbCB8fCBwID09PSAzNCB8fCBwID09PSAzOSB8fCBwID09PSA2MCB8fCBwID09PSA2MSB8fCBwID09PSA2MiB8fCBwID09PSA5NiB8fCBzbihwKSA/IF8ocCkgOiAobi5jb25zdW1lKHApLCBJKTtcbiAgfVxuICBmdW5jdGlvbiBSKHApIHtcbiAgICByZXR1cm4gcCA9PT0gNDcgfHwgcCA9PT0gNjIgfHwgRyhwKSA/IHYocCkgOiB0KHApO1xuICB9XG4gIGZ1bmN0aW9uIE0ocCkge1xuICAgIHJldHVybiBwID09PSA2MiA/IChuLmNvbnN1bWUocCksIFgpIDogdChwKTtcbiAgfVxuICBmdW5jdGlvbiBYKHApIHtcbiAgICByZXR1cm4gRyhwKSA/IChuLmNvbnN1bWUocCksIFgpIDogcCA9PT0gbnVsbCB8fCBMKHApID8gQyhwKSA6IHQocCk7XG4gIH1cbiAgZnVuY3Rpb24gQyhwKSB7XG4gICAgcmV0dXJuIHAgPT09IDQ1ICYmIGkgPT09IDIgPyAobi5jb25zdW1lKHApLCBlbikgOiBwID09PSA2MCAmJiBpID09PSAxID8gKG4uY29uc3VtZShwKSwgdW4pIDogcCA9PT0gNjIgJiYgaSA9PT0gNCA/IChuLmNvbnN1bWUocCksIFcpIDogcCA9PT0gNjMgJiYgaSA9PT0gMyA/IChuLmNvbnN1bWUocCksIEopIDogcCA9PT0gOTMgJiYgaSA9PT0gNSA/IChuLmNvbnN1bWUocCksIHEpIDogTChwKSAmJiAoaSA9PT0gNiB8fCBpID09PSA3KSA/IG4uY2hlY2soXG4gICAgICBEaSxcbiAgICAgIFcsXG4gICAgICBGXG4gICAgKShwKSA6IHAgPT09IG51bGwgfHwgTChwKSA/IEYocCkgOiAobi5jb25zdW1lKHApLCBDKTtcbiAgfVxuICBmdW5jdGlvbiBGKHApIHtcbiAgICByZXR1cm4gbi5leGl0KFwiaHRtbEZsb3dEYXRhXCIpLCBCKHApO1xuICB9XG4gIGZ1bmN0aW9uIEIocCkge1xuICAgIHJldHVybiBwID09PSBudWxsID8gZihwKSA6IEwocCkgPyBuLmF0dGVtcHQoXG4gICAgICB7XG4gICAgICAgIHRva2VuaXplOiBaLFxuICAgICAgICBwYXJ0aWFsOiAhMFxuICAgICAgfSxcbiAgICAgIEIsXG4gICAgICBmXG4gICAgKShwKSA6IChuLmVudGVyKFwiaHRtbEZsb3dEYXRhXCIpLCBDKHApKTtcbiAgfVxuICBmdW5jdGlvbiBaKHAsIGtuLCBQbikge1xuICAgIHJldHVybiBibjtcbiAgICBmdW5jdGlvbiBibihybikge1xuICAgICAgcmV0dXJuIHAuZW50ZXIoXCJsaW5lRW5kaW5nXCIpLCBwLmNvbnN1bWUocm4pLCBwLmV4aXQoXCJsaW5lRW5kaW5nXCIpLCBZO1xuICAgIH1cbiAgICBmdW5jdGlvbiBZKHJuKSB7XG4gICAgICByZXR1cm4gci5wYXJzZXIubGF6eVtyLm5vdygpLmxpbmVdID8gUG4ocm4pIDoga24ocm4pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBlbihwKSB7XG4gICAgcmV0dXJuIHAgPT09IDQ1ID8gKG4uY29uc3VtZShwKSwgSikgOiBDKHApO1xuICB9XG4gIGZ1bmN0aW9uIHVuKHApIHtcbiAgICByZXR1cm4gcCA9PT0gNDcgPyAobi5jb25zdW1lKHApLCBvID0gXCJcIiwgdG4pIDogQyhwKTtcbiAgfVxuICBmdW5jdGlvbiB0bihwKSB7XG4gICAgcmV0dXJuIHAgPT09IDYyICYmIHJ0LmluY2x1ZGVzKG8udG9Mb3dlckNhc2UoKSkgPyAobi5jb25zdW1lKHApLCBXKSA6IGRuKHApICYmIG8ubGVuZ3RoIDwgOCA/IChuLmNvbnN1bWUocCksIG8gKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwKSwgdG4pIDogQyhwKTtcbiAgfVxuICBmdW5jdGlvbiBxKHApIHtcbiAgICByZXR1cm4gcCA9PT0gOTMgPyAobi5jb25zdW1lKHApLCBKKSA6IEMocCk7XG4gIH1cbiAgZnVuY3Rpb24gSihwKSB7XG4gICAgcmV0dXJuIHAgPT09IDYyID8gKG4uY29uc3VtZShwKSwgVykgOiBwID09PSA0NSAmJiBpID09PSAyID8gKG4uY29uc3VtZShwKSwgSikgOiBDKHApO1xuICB9XG4gIGZ1bmN0aW9uIFcocCkge1xuICAgIHJldHVybiBwID09PSBudWxsIHx8IEwocCkgPyAobi5leGl0KFwiaHRtbEZsb3dEYXRhXCIpLCBmKHApKSA6IChuLmNvbnN1bWUocCksIFcpO1xuICB9XG4gIGZ1bmN0aW9uIGYocCkge1xuICAgIHJldHVybiBuLmV4aXQoXCJodG1sRmxvd1wiKSwgZShwKTtcbiAgfVxufVxuZnVuY3Rpb24gUmkobiwgZSwgdCkge1xuICByZXR1cm4gcjtcbiAgZnVuY3Rpb24gcihpKSB7XG4gICAgcmV0dXJuIG4uZXhpdChcImh0bWxGbG93RGF0YVwiKSwgbi5lbnRlcihcImxpbmVFbmRpbmdCbGFua1wiKSwgbi5jb25zdW1lKGkpLCBuLmV4aXQoXCJsaW5lRW5kaW5nQmxhbmtcIiksIG4uYXR0ZW1wdChabiwgZSwgdCk7XG4gIH1cbn1cbmNvbnN0IF9pID0ge1xuICBuYW1lOiBcImh0bWxUZXh0XCIsXG4gIHRva2VuaXplOiBNaVxufTtcbmZ1bmN0aW9uIE1pKG4sIGUsIHQpIHtcbiAgY29uc3QgciA9IHRoaXM7XG4gIGxldCBpLCBsLCBvLCB1O1xuICByZXR1cm4gYTtcbiAgZnVuY3Rpb24gYShmKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJodG1sVGV4dFwiKSwgbi5lbnRlcihcImh0bWxUZXh0RGF0YVwiKSwgbi5jb25zdW1lKGYpLCBjO1xuICB9XG4gIGZ1bmN0aW9uIGMoZikge1xuICAgIHJldHVybiBmID09PSAzMyA/IChuLmNvbnN1bWUoZiksIHMpIDogZiA9PT0gNDcgPyAobi5jb25zdW1lKGYpLCBJKSA6IGYgPT09IDYzID8gKG4uY29uc3VtZShmKSwgVCkgOiBkbihmKSA/IChuLmNvbnN1bWUoZiksIFgpIDogdChmKTtcbiAgfVxuICBmdW5jdGlvbiBzKGYpIHtcbiAgICByZXR1cm4gZiA9PT0gNDUgPyAobi5jb25zdW1lKGYpLCBoKSA6IGYgPT09IDkxID8gKG4uY29uc3VtZShmKSwgbCA9IFwiQ0RBVEFbXCIsIG8gPSAwLCB4KSA6IGRuKGYpID8gKG4uY29uc3VtZShmKSwgXykgOiB0KGYpO1xuICB9XG4gIGZ1bmN0aW9uIGgoZikge1xuICAgIHJldHVybiBmID09PSA0NSA/IChuLmNvbnN1bWUoZiksIGcpIDogdChmKTtcbiAgfVxuICBmdW5jdGlvbiBnKGYpIHtcbiAgICByZXR1cm4gZiA9PT0gbnVsbCB8fCBmID09PSA2MiA/IHQoZikgOiBmID09PSA0NSA/IChuLmNvbnN1bWUoZiksIGQpIDogbShmKTtcbiAgfVxuICBmdW5jdGlvbiBkKGYpIHtcbiAgICByZXR1cm4gZiA9PT0gbnVsbCB8fCBmID09PSA2MiA/IHQoZikgOiBtKGYpO1xuICB9XG4gIGZ1bmN0aW9uIG0oZikge1xuICAgIHJldHVybiBmID09PSBudWxsID8gdChmKSA6IGYgPT09IDQ1ID8gKG4uY29uc3VtZShmKSwgeSkgOiBMKGYpID8gKHUgPSBtLCBxKGYpKSA6IChuLmNvbnN1bWUoZiksIG0pO1xuICB9XG4gIGZ1bmN0aW9uIHkoZikge1xuICAgIHJldHVybiBmID09PSA0NSA/IChuLmNvbnN1bWUoZiksIFcpIDogbShmKTtcbiAgfVxuICBmdW5jdGlvbiB4KGYpIHtcbiAgICByZXR1cm4gZiA9PT0gbC5jaGFyQ29kZUF0KG8rKykgPyAobi5jb25zdW1lKGYpLCBvID09PSBsLmxlbmd0aCA/IHcgOiB4KSA6IHQoZik7XG4gIH1cbiAgZnVuY3Rpb24gdyhmKSB7XG4gICAgcmV0dXJuIGYgPT09IG51bGwgPyB0KGYpIDogZiA9PT0gOTMgPyAobi5jb25zdW1lKGYpLCB2KSA6IEwoZikgPyAodSA9IHcsIHEoZikpIDogKG4uY29uc3VtZShmKSwgdyk7XG4gIH1cbiAgZnVuY3Rpb24gdihmKSB7XG4gICAgcmV0dXJuIGYgPT09IDkzID8gKG4uY29uc3VtZShmKSwgQSkgOiB3KGYpO1xuICB9XG4gIGZ1bmN0aW9uIEEoZikge1xuICAgIHJldHVybiBmID09PSA2MiA/IFcoZikgOiBmID09PSA5MyA/IChuLmNvbnN1bWUoZiksIEEpIDogdyhmKTtcbiAgfVxuICBmdW5jdGlvbiBfKGYpIHtcbiAgICByZXR1cm4gZiA9PT0gbnVsbCB8fCBmID09PSA2MiA/IFcoZikgOiBMKGYpID8gKHUgPSBfLCBxKGYpKSA6IChuLmNvbnN1bWUoZiksIF8pO1xuICB9XG4gIGZ1bmN0aW9uIFQoZikge1xuICAgIHJldHVybiBmID09PSBudWxsID8gdChmKSA6IGYgPT09IDYzID8gKG4uY29uc3VtZShmKSwgYikgOiBMKGYpID8gKHUgPSBULCBxKGYpKSA6IChuLmNvbnN1bWUoZiksIFQpO1xuICB9XG4gIGZ1bmN0aW9uIGIoZikge1xuICAgIHJldHVybiBmID09PSA2MiA/IFcoZikgOiBUKGYpO1xuICB9XG4gIGZ1bmN0aW9uIEkoZikge1xuICAgIHJldHVybiBkbihmKSA/IChuLmNvbnN1bWUoZiksIFIpIDogdChmKTtcbiAgfVxuICBmdW5jdGlvbiBSKGYpIHtcbiAgICByZXR1cm4gZiA9PT0gNDUgfHwgb24oZikgPyAobi5jb25zdW1lKGYpLCBSKSA6IE0oZik7XG4gIH1cbiAgZnVuY3Rpb24gTShmKSB7XG4gICAgcmV0dXJuIEwoZikgPyAodSA9IE0sIHEoZikpIDogRyhmKSA/IChuLmNvbnN1bWUoZiksIE0pIDogVyhmKTtcbiAgfVxuICBmdW5jdGlvbiBYKGYpIHtcbiAgICByZXR1cm4gZiA9PT0gNDUgfHwgb24oZikgPyAobi5jb25zdW1lKGYpLCBYKSA6IGYgPT09IDQ3IHx8IGYgPT09IDYyIHx8IHNuKGYpID8gQyhmKSA6IHQoZik7XG4gIH1cbiAgZnVuY3Rpb24gQyhmKSB7XG4gICAgcmV0dXJuIGYgPT09IDQ3ID8gKG4uY29uc3VtZShmKSwgVykgOiBmID09PSA1OCB8fCBmID09PSA5NSB8fCBkbihmKSA/IChuLmNvbnN1bWUoZiksIEYpIDogTChmKSA/ICh1ID0gQywgcShmKSkgOiBHKGYpID8gKG4uY29uc3VtZShmKSwgQykgOiBXKGYpO1xuICB9XG4gIGZ1bmN0aW9uIEYoZikge1xuICAgIHJldHVybiBmID09PSA0NSB8fCBmID09PSA0NiB8fCBmID09PSA1OCB8fCBmID09PSA5NSB8fCBvbihmKSA/IChuLmNvbnN1bWUoZiksIEYpIDogQihmKTtcbiAgfVxuICBmdW5jdGlvbiBCKGYpIHtcbiAgICByZXR1cm4gZiA9PT0gNjEgPyAobi5jb25zdW1lKGYpLCBaKSA6IEwoZikgPyAodSA9IEIsIHEoZikpIDogRyhmKSA/IChuLmNvbnN1bWUoZiksIEIpIDogQyhmKTtcbiAgfVxuICBmdW5jdGlvbiBaKGYpIHtcbiAgICByZXR1cm4gZiA9PT0gbnVsbCB8fCBmID09PSA2MCB8fCBmID09PSA2MSB8fCBmID09PSA2MiB8fCBmID09PSA5NiA/IHQoZikgOiBmID09PSAzNCB8fCBmID09PSAzOSA/IChuLmNvbnN1bWUoZiksIGkgPSBmLCBlbikgOiBMKGYpID8gKHUgPSBaLCBxKGYpKSA6IEcoZikgPyAobi5jb25zdW1lKGYpLCBaKSA6IChuLmNvbnN1bWUoZiksIGkgPSB2b2lkIDAsIHRuKTtcbiAgfVxuICBmdW5jdGlvbiBlbihmKSB7XG4gICAgcmV0dXJuIGYgPT09IGkgPyAobi5jb25zdW1lKGYpLCB1bikgOiBmID09PSBudWxsID8gdChmKSA6IEwoZikgPyAodSA9IGVuLCBxKGYpKSA6IChuLmNvbnN1bWUoZiksIGVuKTtcbiAgfVxuICBmdW5jdGlvbiB1bihmKSB7XG4gICAgcmV0dXJuIGYgPT09IDYyIHx8IGYgPT09IDQ3IHx8IHNuKGYpID8gQyhmKSA6IHQoZik7XG4gIH1cbiAgZnVuY3Rpb24gdG4oZikge1xuICAgIHJldHVybiBmID09PSBudWxsIHx8IGYgPT09IDM0IHx8IGYgPT09IDM5IHx8IGYgPT09IDYwIHx8IGYgPT09IDYxIHx8IGYgPT09IDk2ID8gdChmKSA6IGYgPT09IDYyIHx8IHNuKGYpID8gQyhmKSA6IChuLmNvbnN1bWUoZiksIHRuKTtcbiAgfVxuICBmdW5jdGlvbiBxKGYpIHtcbiAgICByZXR1cm4gbi5leGl0KFwiaHRtbFRleHREYXRhXCIpLCBuLmVudGVyKFwibGluZUVuZGluZ1wiKSwgbi5jb25zdW1lKGYpLCBuLmV4aXQoXCJsaW5lRW5kaW5nXCIpLCBVKFxuICAgICAgbixcbiAgICAgIEosXG4gICAgICBcImxpbmVQcmVmaXhcIixcbiAgICAgIHIucGFyc2VyLmNvbnN0cnVjdHMuZGlzYWJsZS5udWxsLmluY2x1ZGVzKFwiY29kZUluZGVudGVkXCIpID8gdm9pZCAwIDogNFxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gSihmKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJodG1sVGV4dERhdGFcIiksIHUoZik7XG4gIH1cbiAgZnVuY3Rpb24gVyhmKSB7XG4gICAgcmV0dXJuIGYgPT09IDYyID8gKG4uY29uc3VtZShmKSwgbi5leGl0KFwiaHRtbFRleHREYXRhXCIpLCBuLmV4aXQoXCJodG1sVGV4dFwiKSwgZSkgOiB0KGYpO1xuICB9XG59XG5jb25zdCBQZSA9IHtcbiAgbmFtZTogXCJsYWJlbEVuZFwiLFxuICB0b2tlbml6ZTogVWksXG4gIHJlc29sdmVUbzogSGksXG4gIHJlc29sdmVBbGw6ICRpXG59LCBCaSA9IHtcbiAgdG9rZW5pemU6IFZpXG59LCBOaSA9IHtcbiAgdG9rZW5pemU6IHFpXG59LCBqaSA9IHtcbiAgdG9rZW5pemU6IFdpXG59O1xuZnVuY3Rpb24gJGkobikge1xuICBsZXQgZSA9IC0xLCB0O1xuICBmb3IgKDsgKytlIDwgbi5sZW5ndGg7IClcbiAgICB0ID0gbltlXVsxXSwgKHQudHlwZSA9PT0gXCJsYWJlbEltYWdlXCIgfHwgdC50eXBlID09PSBcImxhYmVsTGlua1wiIHx8IHQudHlwZSA9PT0gXCJsYWJlbEVuZFwiKSAmJiAobi5zcGxpY2UoZSArIDEsIHQudHlwZSA9PT0gXCJsYWJlbEltYWdlXCIgPyA0IDogMiksIHQudHlwZSA9IFwiZGF0YVwiLCBlKyspO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIEhpKG4sIGUpIHtcbiAgbGV0IHQgPSBuLmxlbmd0aCwgciA9IDAsIGksIGwsIG8sIHU7XG4gIGZvciAoOyB0LS07IClcbiAgICBpZiAoaSA9IG5bdF1bMV0sIGwpIHtcbiAgICAgIGlmIChpLnR5cGUgPT09IFwibGlua1wiIHx8IGkudHlwZSA9PT0gXCJsYWJlbExpbmtcIiAmJiBpLl9pbmFjdGl2ZSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBuW3RdWzBdID09PSBcImVudGVyXCIgJiYgaS50eXBlID09PSBcImxhYmVsTGlua1wiICYmIChpLl9pbmFjdGl2ZSA9ICEwKTtcbiAgICB9IGVsc2UgaWYgKG8pIHtcbiAgICAgIGlmIChuW3RdWzBdID09PSBcImVudGVyXCIgJiYgKGkudHlwZSA9PT0gXCJsYWJlbEltYWdlXCIgfHwgaS50eXBlID09PSBcImxhYmVsTGlua1wiKSAmJiAhaS5fYmFsYW5jZWQgJiYgKGwgPSB0LCBpLnR5cGUgIT09IFwibGFiZWxMaW5rXCIpKSB7XG4gICAgICAgIHIgPSAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIGkudHlwZSA9PT0gXCJsYWJlbEVuZFwiICYmIChvID0gdCk7XG4gIGNvbnN0IGEgPSB7XG4gICAgdHlwZTogbltsXVsxXS50eXBlID09PSBcImxhYmVsTGlua1wiID8gXCJsaW5rXCIgOiBcImltYWdlXCIsXG4gICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIG5bbF1bMV0uc3RhcnQpLFxuICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgbltuLmxlbmd0aCAtIDFdWzFdLmVuZClcbiAgfSwgYyA9IHtcbiAgICB0eXBlOiBcImxhYmVsXCIsXG4gICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIG5bbF1bMV0uc3RhcnQpLFxuICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgbltvXVsxXS5lbmQpXG4gIH0sIHMgPSB7XG4gICAgdHlwZTogXCJsYWJlbFRleHRcIixcbiAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgbltsICsgciArIDJdWzFdLmVuZCksXG4gICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBuW28gLSAyXVsxXS5zdGFydClcbiAgfTtcbiAgcmV0dXJuIHUgPSBbXG4gICAgW1wiZW50ZXJcIiwgYSwgZV0sXG4gICAgW1wiZW50ZXJcIiwgYywgZV1cbiAgXSwgdSA9IGFuKHUsIG4uc2xpY2UobCArIDEsIGwgKyByICsgMykpLCB1ID0gYW4odSwgW1tcImVudGVyXCIsIHMsIGVdXSksIHUgPSBhbihcbiAgICB1LFxuICAgIENlKFxuICAgICAgZS5wYXJzZXIuY29uc3RydWN0cy5pbnNpZGVTcGFuLm51bGwsXG4gICAgICBuLnNsaWNlKGwgKyByICsgNCwgbyAtIDMpLFxuICAgICAgZVxuICAgIClcbiAgKSwgdSA9IGFuKHUsIFtcbiAgICBbXCJleGl0XCIsIHMsIGVdLFxuICAgIG5bbyAtIDJdLFxuICAgIG5bbyAtIDFdLFxuICAgIFtcImV4aXRcIiwgYywgZV1cbiAgXSksIHUgPSBhbih1LCBuLnNsaWNlKG8gKyAxKSksIHUgPSBhbih1LCBbW1wiZXhpdFwiLCBhLCBlXV0pLCBnbihuLCBsLCBuLmxlbmd0aCwgdSksIG47XG59XG5mdW5jdGlvbiBVaShuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB0aGlzO1xuICBsZXQgaSA9IHIuZXZlbnRzLmxlbmd0aCwgbCwgbztcbiAgZm9yICg7IGktLTsgKVxuICAgIGlmICgoci5ldmVudHNbaV1bMV0udHlwZSA9PT0gXCJsYWJlbEltYWdlXCIgfHwgci5ldmVudHNbaV1bMV0udHlwZSA9PT0gXCJsYWJlbExpbmtcIikgJiYgIXIuZXZlbnRzW2ldWzFdLl9iYWxhbmNlZCkge1xuICAgICAgbCA9IHIuZXZlbnRzW2ldWzFdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gdTtcbiAgZnVuY3Rpb24gdShzKSB7XG4gICAgcmV0dXJuIGwgPyBsLl9pbmFjdGl2ZSA/IGMocykgOiAobyA9IHIucGFyc2VyLmRlZmluZWQuaW5jbHVkZXMoXG4gICAgICBMbihcbiAgICAgICAgci5zbGljZVNlcmlhbGl6ZSh7XG4gICAgICAgICAgc3RhcnQ6IGwuZW5kLFxuICAgICAgICAgIGVuZDogci5ub3coKVxuICAgICAgICB9KVxuICAgICAgKVxuICAgICksIG4uZW50ZXIoXCJsYWJlbEVuZFwiKSwgbi5lbnRlcihcImxhYmVsTWFya2VyXCIpLCBuLmNvbnN1bWUocyksIG4uZXhpdChcImxhYmVsTWFya2VyXCIpLCBuLmV4aXQoXCJsYWJlbEVuZFwiKSwgYSkgOiB0KHMpO1xuICB9XG4gIGZ1bmN0aW9uIGEocykge1xuICAgIHJldHVybiBzID09PSA0MCA/IG4uYXR0ZW1wdChcbiAgICAgIEJpLFxuICAgICAgZSxcbiAgICAgIG8gPyBlIDogY1xuICAgICkocykgOiBzID09PSA5MSA/IG4uYXR0ZW1wdChcbiAgICAgIE5pLFxuICAgICAgZSxcbiAgICAgIG8gPyBuLmF0dGVtcHQoamksIGUsIGMpIDogY1xuICAgICkocykgOiBvID8gZShzKSA6IGMocyk7XG4gIH1cbiAgZnVuY3Rpb24gYyhzKSB7XG4gICAgcmV0dXJuIGwuX2JhbGFuY2VkID0gITAsIHQocyk7XG4gIH1cbn1cbmZ1bmN0aW9uIFZpKG4sIGUsIHQpIHtcbiAgcmV0dXJuIHI7XG4gIGZ1bmN0aW9uIHIoYSkge1xuICAgIHJldHVybiBuLmVudGVyKFwicmVzb3VyY2VcIiksIG4uZW50ZXIoXCJyZXNvdXJjZU1hcmtlclwiKSwgbi5jb25zdW1lKGEpLCBuLmV4aXQoXCJyZXNvdXJjZU1hcmtlclwiKSwgJG4obiwgaSk7XG4gIH1cbiAgZnVuY3Rpb24gaShhKSB7XG4gICAgcmV0dXJuIGEgPT09IDQxID8gdShhKSA6IF90KFxuICAgICAgbixcbiAgICAgIGwsXG4gICAgICB0LFxuICAgICAgXCJyZXNvdXJjZURlc3RpbmF0aW9uXCIsXG4gICAgICBcInJlc291cmNlRGVzdGluYXRpb25MaXRlcmFsXCIsXG4gICAgICBcInJlc291cmNlRGVzdGluYXRpb25MaXRlcmFsTWFya2VyXCIsXG4gICAgICBcInJlc291cmNlRGVzdGluYXRpb25SYXdcIixcbiAgICAgIFwicmVzb3VyY2VEZXN0aW5hdGlvblN0cmluZ1wiLFxuICAgICAgMzJcbiAgICApKGEpO1xuICB9XG4gIGZ1bmN0aW9uIGwoYSkge1xuICAgIHJldHVybiBzbihhKSA/ICRuKG4sIG8pKGEpIDogdShhKTtcbiAgfVxuICBmdW5jdGlvbiBvKGEpIHtcbiAgICByZXR1cm4gYSA9PT0gMzQgfHwgYSA9PT0gMzkgfHwgYSA9PT0gNDAgPyBCdChcbiAgICAgIG4sXG4gICAgICAkbihuLCB1KSxcbiAgICAgIHQsXG4gICAgICBcInJlc291cmNlVGl0bGVcIixcbiAgICAgIFwicmVzb3VyY2VUaXRsZU1hcmtlclwiLFxuICAgICAgXCJyZXNvdXJjZVRpdGxlU3RyaW5nXCJcbiAgICApKGEpIDogdShhKTtcbiAgfVxuICBmdW5jdGlvbiB1KGEpIHtcbiAgICByZXR1cm4gYSA9PT0gNDEgPyAobi5lbnRlcihcInJlc291cmNlTWFya2VyXCIpLCBuLmNvbnN1bWUoYSksIG4uZXhpdChcInJlc291cmNlTWFya2VyXCIpLCBuLmV4aXQoXCJyZXNvdXJjZVwiKSwgZSkgOiB0KGEpO1xuICB9XG59XG5mdW5jdGlvbiBxaShuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB0aGlzO1xuICByZXR1cm4gaTtcbiAgZnVuY3Rpb24gaShvKSB7XG4gICAgcmV0dXJuIE10LmNhbGwoXG4gICAgICByLFxuICAgICAgbixcbiAgICAgIGwsXG4gICAgICB0LFxuICAgICAgXCJyZWZlcmVuY2VcIixcbiAgICAgIFwicmVmZXJlbmNlTWFya2VyXCIsXG4gICAgICBcInJlZmVyZW5jZVN0cmluZ1wiXG4gICAgKShvKTtcbiAgfVxuICBmdW5jdGlvbiBsKG8pIHtcbiAgICByZXR1cm4gci5wYXJzZXIuZGVmaW5lZC5pbmNsdWRlcyhcbiAgICAgIExuKFxuICAgICAgICByLnNsaWNlU2VyaWFsaXplKHIuZXZlbnRzW3IuZXZlbnRzLmxlbmd0aCAtIDFdWzFdKS5zbGljZSgxLCAtMSlcbiAgICAgIClcbiAgICApID8gZShvKSA6IHQobyk7XG4gIH1cbn1cbmZ1bmN0aW9uIFdpKG4sIGUsIHQpIHtcbiAgcmV0dXJuIHI7XG4gIGZ1bmN0aW9uIHIobCkge1xuICAgIHJldHVybiBuLmVudGVyKFwicmVmZXJlbmNlXCIpLCBuLmVudGVyKFwicmVmZXJlbmNlTWFya2VyXCIpLCBuLmNvbnN1bWUobCksIG4uZXhpdChcInJlZmVyZW5jZU1hcmtlclwiKSwgaTtcbiAgfVxuICBmdW5jdGlvbiBpKGwpIHtcbiAgICByZXR1cm4gbCA9PT0gOTMgPyAobi5lbnRlcihcInJlZmVyZW5jZU1hcmtlclwiKSwgbi5jb25zdW1lKGwpLCBuLmV4aXQoXCJyZWZlcmVuY2VNYXJrZXJcIiksIG4uZXhpdChcInJlZmVyZW5jZVwiKSwgZSkgOiB0KGwpO1xuICB9XG59XG5jb25zdCBZaSA9IHtcbiAgbmFtZTogXCJsYWJlbFN0YXJ0SW1hZ2VcIixcbiAgdG9rZW5pemU6IFFpLFxuICByZXNvbHZlQWxsOiBQZS5yZXNvbHZlQWxsXG59O1xuZnVuY3Rpb24gUWkobiwgZSwgdCkge1xuICBjb25zdCByID0gdGhpcztcbiAgcmV0dXJuIGk7XG4gIGZ1bmN0aW9uIGkodSkge1xuICAgIHJldHVybiBuLmVudGVyKFwibGFiZWxJbWFnZVwiKSwgbi5lbnRlcihcImxhYmVsSW1hZ2VNYXJrZXJcIiksIG4uY29uc3VtZSh1KSwgbi5leGl0KFwibGFiZWxJbWFnZU1hcmtlclwiKSwgbDtcbiAgfVxuICBmdW5jdGlvbiBsKHUpIHtcbiAgICByZXR1cm4gdSA9PT0gOTEgPyAobi5lbnRlcihcImxhYmVsTWFya2VyXCIpLCBuLmNvbnN1bWUodSksIG4uZXhpdChcImxhYmVsTWFya2VyXCIpLCBuLmV4aXQoXCJsYWJlbEltYWdlXCIpLCBvKSA6IHQodSk7XG4gIH1cbiAgZnVuY3Rpb24gbyh1KSB7XG4gICAgcmV0dXJuIHUgPT09IDk0ICYmIFwiX2hpZGRlbkZvb3Rub3RlU3VwcG9ydFwiIGluIHIucGFyc2VyLmNvbnN0cnVjdHMgPyB0KHUpIDogZSh1KTtcbiAgfVxufVxuY29uc3QgWGkgPSB7XG4gIG5hbWU6IFwibGFiZWxTdGFydExpbmtcIixcbiAgdG9rZW5pemU6IEtpLFxuICByZXNvbHZlQWxsOiBQZS5yZXNvbHZlQWxsXG59O1xuZnVuY3Rpb24gS2kobiwgZSwgdCkge1xuICBjb25zdCByID0gdGhpcztcbiAgcmV0dXJuIGk7XG4gIGZ1bmN0aW9uIGkobykge1xuICAgIHJldHVybiBuLmVudGVyKFwibGFiZWxMaW5rXCIpLCBuLmVudGVyKFwibGFiZWxNYXJrZXJcIiksIG4uY29uc3VtZShvKSwgbi5leGl0KFwibGFiZWxNYXJrZXJcIiksIG4uZXhpdChcImxhYmVsTGlua1wiKSwgbDtcbiAgfVxuICBmdW5jdGlvbiBsKG8pIHtcbiAgICByZXR1cm4gbyA9PT0gOTQgJiYgXCJfaGlkZGVuRm9vdG5vdGVTdXBwb3J0XCIgaW4gci5wYXJzZXIuY29uc3RydWN0cyA/IHQobykgOiBlKG8pO1xuICB9XG59XG5jb25zdCBjZSA9IHtcbiAgbmFtZTogXCJsaW5lRW5kaW5nXCIsXG4gIHRva2VuaXplOiBHaVxufTtcbmZ1bmN0aW9uIEdpKG4sIGUpIHtcbiAgcmV0dXJuIHQ7XG4gIGZ1bmN0aW9uIHQocikge1xuICAgIHJldHVybiBuLmVudGVyKFwibGluZUVuZGluZ1wiKSwgbi5jb25zdW1lKHIpLCBuLmV4aXQoXCJsaW5lRW5kaW5nXCIpLCBVKG4sIGUsIFwibGluZVByZWZpeFwiKTtcbiAgfVxufVxuY29uc3QgUW4gPSB7XG4gIG5hbWU6IFwidGhlbWF0aWNCcmVha1wiLFxuICB0b2tlbml6ZTogWmlcbn07XG5mdW5jdGlvbiBaaShuLCBlLCB0KSB7XG4gIGxldCByID0gMCwgaTtcbiAgcmV0dXJuIGw7XG4gIGZ1bmN0aW9uIGwoYSkge1xuICAgIHJldHVybiBuLmVudGVyKFwidGhlbWF0aWNCcmVha1wiKSwgaSA9IGEsIG8oYSk7XG4gIH1cbiAgZnVuY3Rpb24gbyhhKSB7XG4gICAgcmV0dXJuIGEgPT09IGkgPyAobi5lbnRlcihcInRoZW1hdGljQnJlYWtTZXF1ZW5jZVwiKSwgdShhKSkgOiBHKGEpID8gVShuLCBvLCBcIndoaXRlc3BhY2VcIikoYSkgOiByIDwgMyB8fCBhICE9PSBudWxsICYmICFMKGEpID8gdChhKSA6IChuLmV4aXQoXCJ0aGVtYXRpY0JyZWFrXCIpLCBlKGEpKTtcbiAgfVxuICBmdW5jdGlvbiB1KGEpIHtcbiAgICByZXR1cm4gYSA9PT0gaSA/IChuLmNvbnN1bWUoYSksIHIrKywgdSkgOiAobi5leGl0KFwidGhlbWF0aWNCcmVha1NlcXVlbmNlXCIpLCBvKGEpKTtcbiAgfVxufVxuY29uc3Qgbm4gPSB7XG4gIG5hbWU6IFwibGlzdFwiLFxuICB0b2tlbml6ZTogZWwsXG4gIGNvbnRpbnVhdGlvbjoge1xuICAgIHRva2VuaXplOiB0bFxuICB9LFxuICBleGl0OiBpbFxufSwgSmkgPSB7XG4gIHRva2VuaXplOiBsbCxcbiAgcGFydGlhbDogITBcbn0sIG5sID0ge1xuICB0b2tlbml6ZTogcmwsXG4gIHBhcnRpYWw6ICEwXG59O1xuZnVuY3Rpb24gZWwobiwgZSwgdCkge1xuICBjb25zdCByID0gdGhpcywgaSA9IHIuZXZlbnRzW3IuZXZlbnRzLmxlbmd0aCAtIDFdO1xuICBsZXQgbCA9IGkgJiYgaVsxXS50eXBlID09PSBcImxpbmVQcmVmaXhcIiA/IGlbMl0uc2xpY2VTZXJpYWxpemUoaVsxXSwgITApLmxlbmd0aCA6IDAsIG8gPSAwO1xuICByZXR1cm4gdTtcbiAgZnVuY3Rpb24gdShkKSB7XG4gICAgY29uc3QgbSA9IHIuY29udGFpbmVyU3RhdGUudHlwZSB8fCAoZCA9PT0gNDIgfHwgZCA9PT0gNDMgfHwgZCA9PT0gNDUgPyBcImxpc3RVbm9yZGVyZWRcIiA6IFwibGlzdE9yZGVyZWRcIik7XG4gICAgaWYgKG0gPT09IFwibGlzdFVub3JkZXJlZFwiID8gIXIuY29udGFpbmVyU3RhdGUubWFya2VyIHx8IGQgPT09IHIuY29udGFpbmVyU3RhdGUubWFya2VyIDogZ2UoZCkpIHtcbiAgICAgIGlmIChyLmNvbnRhaW5lclN0YXRlLnR5cGUgfHwgKHIuY29udGFpbmVyU3RhdGUudHlwZSA9IG0sIG4uZW50ZXIobSwge1xuICAgICAgICBfY29udGFpbmVyOiAhMFxuICAgICAgfSkpLCBtID09PSBcImxpc3RVbm9yZGVyZWRcIilcbiAgICAgICAgcmV0dXJuIG4uZW50ZXIoXCJsaXN0SXRlbVByZWZpeFwiKSwgZCA9PT0gNDIgfHwgZCA9PT0gNDUgPyBuLmNoZWNrKFFuLCB0LCBjKShkKSA6IGMoZCk7XG4gICAgICBpZiAoIXIuaW50ZXJydXB0IHx8IGQgPT09IDQ5KVxuICAgICAgICByZXR1cm4gbi5lbnRlcihcImxpc3RJdGVtUHJlZml4XCIpLCBuLmVudGVyKFwibGlzdEl0ZW1WYWx1ZVwiKSwgYShkKTtcbiAgICB9XG4gICAgcmV0dXJuIHQoZCk7XG4gIH1cbiAgZnVuY3Rpb24gYShkKSB7XG4gICAgcmV0dXJuIGdlKGQpICYmICsrbyA8IDEwID8gKG4uY29uc3VtZShkKSwgYSkgOiAoIXIuaW50ZXJydXB0IHx8IG8gPCAyKSAmJiAoci5jb250YWluZXJTdGF0ZS5tYXJrZXIgPyBkID09PSByLmNvbnRhaW5lclN0YXRlLm1hcmtlciA6IGQgPT09IDQxIHx8IGQgPT09IDQ2KSA/IChuLmV4aXQoXCJsaXN0SXRlbVZhbHVlXCIpLCBjKGQpKSA6IHQoZCk7XG4gIH1cbiAgZnVuY3Rpb24gYyhkKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJsaXN0SXRlbU1hcmtlclwiKSwgbi5jb25zdW1lKGQpLCBuLmV4aXQoXCJsaXN0SXRlbU1hcmtlclwiKSwgci5jb250YWluZXJTdGF0ZS5tYXJrZXIgPSByLmNvbnRhaW5lclN0YXRlLm1hcmtlciB8fCBkLCBuLmNoZWNrKFxuICAgICAgWm4sXG4gICAgICAvLyBDYW7igJl0IGJlIGVtcHR5IHdoZW4gaW50ZXJydXB0aW5nLlxuICAgICAgci5pbnRlcnJ1cHQgPyB0IDogcyxcbiAgICAgIG4uYXR0ZW1wdChcbiAgICAgICAgSmksXG4gICAgICAgIGcsXG4gICAgICAgIGhcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGZ1bmN0aW9uIHMoZCkge1xuICAgIHJldHVybiByLmNvbnRhaW5lclN0YXRlLmluaXRpYWxCbGFua0xpbmUgPSAhMCwgbCsrLCBnKGQpO1xuICB9XG4gIGZ1bmN0aW9uIGgoZCkge1xuICAgIHJldHVybiBHKGQpID8gKG4uZW50ZXIoXCJsaXN0SXRlbVByZWZpeFdoaXRlc3BhY2VcIiksIG4uY29uc3VtZShkKSwgbi5leGl0KFwibGlzdEl0ZW1QcmVmaXhXaGl0ZXNwYWNlXCIpLCBnKSA6IHQoZCk7XG4gIH1cbiAgZnVuY3Rpb24gZyhkKSB7XG4gICAgcmV0dXJuIHIuY29udGFpbmVyU3RhdGUuc2l6ZSA9IGwgKyByLnNsaWNlU2VyaWFsaXplKG4uZXhpdChcImxpc3RJdGVtUHJlZml4XCIpLCAhMCkubGVuZ3RoLCBlKGQpO1xuICB9XG59XG5mdW5jdGlvbiB0bChuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB0aGlzO1xuICByZXR1cm4gci5jb250YWluZXJTdGF0ZS5fY2xvc2VGbG93ID0gdm9pZCAwLCBuLmNoZWNrKFpuLCBpLCBsKTtcbiAgZnVuY3Rpb24gaSh1KSB7XG4gICAgcmV0dXJuIHIuY29udGFpbmVyU3RhdGUuZnVydGhlckJsYW5rTGluZXMgPSByLmNvbnRhaW5lclN0YXRlLmZ1cnRoZXJCbGFua0xpbmVzIHx8IHIuY29udGFpbmVyU3RhdGUuaW5pdGlhbEJsYW5rTGluZSwgVShcbiAgICAgIG4sXG4gICAgICBlLFxuICAgICAgXCJsaXN0SXRlbUluZGVudFwiLFxuICAgICAgci5jb250YWluZXJTdGF0ZS5zaXplICsgMVxuICAgICkodSk7XG4gIH1cbiAgZnVuY3Rpb24gbCh1KSB7XG4gICAgcmV0dXJuIHIuY29udGFpbmVyU3RhdGUuZnVydGhlckJsYW5rTGluZXMgfHwgIUcodSkgPyAoci5jb250YWluZXJTdGF0ZS5mdXJ0aGVyQmxhbmtMaW5lcyA9IHZvaWQgMCwgci5jb250YWluZXJTdGF0ZS5pbml0aWFsQmxhbmtMaW5lID0gdm9pZCAwLCBvKHUpKSA6IChyLmNvbnRhaW5lclN0YXRlLmZ1cnRoZXJCbGFua0xpbmVzID0gdm9pZCAwLCByLmNvbnRhaW5lclN0YXRlLmluaXRpYWxCbGFua0xpbmUgPSB2b2lkIDAsIG4uYXR0ZW1wdChubCwgZSwgbykodSkpO1xuICB9XG4gIGZ1bmN0aW9uIG8odSkge1xuICAgIHJldHVybiByLmNvbnRhaW5lclN0YXRlLl9jbG9zZUZsb3cgPSAhMCwgci5pbnRlcnJ1cHQgPSB2b2lkIDAsIFUoXG4gICAgICBuLFxuICAgICAgbi5hdHRlbXB0KG5uLCBlLCB0KSxcbiAgICAgIFwibGluZVByZWZpeFwiLFxuICAgICAgci5wYXJzZXIuY29uc3RydWN0cy5kaXNhYmxlLm51bGwuaW5jbHVkZXMoXCJjb2RlSW5kZW50ZWRcIikgPyB2b2lkIDAgOiA0XG4gICAgKSh1KTtcbiAgfVxufVxuZnVuY3Rpb24gcmwobiwgZSwgdCkge1xuICBjb25zdCByID0gdGhpcztcbiAgcmV0dXJuIFUoXG4gICAgbixcbiAgICBpLFxuICAgIFwibGlzdEl0ZW1JbmRlbnRcIixcbiAgICByLmNvbnRhaW5lclN0YXRlLnNpemUgKyAxXG4gICk7XG4gIGZ1bmN0aW9uIGkobCkge1xuICAgIGNvbnN0IG8gPSByLmV2ZW50c1tyLmV2ZW50cy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gbyAmJiBvWzFdLnR5cGUgPT09IFwibGlzdEl0ZW1JbmRlbnRcIiAmJiBvWzJdLnNsaWNlU2VyaWFsaXplKG9bMV0sICEwKS5sZW5ndGggPT09IHIuY29udGFpbmVyU3RhdGUuc2l6ZSA/IGUobCkgOiB0KGwpO1xuICB9XG59XG5mdW5jdGlvbiBpbChuKSB7XG4gIG4uZXhpdCh0aGlzLmNvbnRhaW5lclN0YXRlLnR5cGUpO1xufVxuZnVuY3Rpb24gbGwobiwgZSwgdCkge1xuICBjb25zdCByID0gdGhpcztcbiAgcmV0dXJuIFUoXG4gICAgbixcbiAgICBpLFxuICAgIFwibGlzdEl0ZW1QcmVmaXhXaGl0ZXNwYWNlXCIsXG4gICAgci5wYXJzZXIuY29uc3RydWN0cy5kaXNhYmxlLm51bGwuaW5jbHVkZXMoXCJjb2RlSW5kZW50ZWRcIikgPyB2b2lkIDAgOiA0ICsgMVxuICApO1xuICBmdW5jdGlvbiBpKGwpIHtcbiAgICBjb25zdCBvID0gci5ldmVudHNbci5ldmVudHMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuICFHKGwpICYmIG8gJiYgb1sxXS50eXBlID09PSBcImxpc3RJdGVtUHJlZml4V2hpdGVzcGFjZVwiID8gZShsKSA6IHQobCk7XG4gIH1cbn1cbmNvbnN0IGl0ID0ge1xuICBuYW1lOiBcInNldGV4dFVuZGVybGluZVwiLFxuICB0b2tlbml6ZTogdWwsXG4gIHJlc29sdmVUbzogb2xcbn07XG5mdW5jdGlvbiBvbChuLCBlKSB7XG4gIGxldCB0ID0gbi5sZW5ndGgsIHIsIGksIGw7XG4gIGZvciAoOyB0LS07IClcbiAgICBpZiAoblt0XVswXSA9PT0gXCJlbnRlclwiKSB7XG4gICAgICBpZiAoblt0XVsxXS50eXBlID09PSBcImNvbnRlbnRcIikge1xuICAgICAgICByID0gdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBuW3RdWzFdLnR5cGUgPT09IFwicGFyYWdyYXBoXCIgJiYgKGkgPSB0KTtcbiAgICB9IGVsc2VcbiAgICAgIG5bdF1bMV0udHlwZSA9PT0gXCJjb250ZW50XCIgJiYgbi5zcGxpY2UodCwgMSksICFsICYmIG5bdF1bMV0udHlwZSA9PT0gXCJkZWZpbml0aW9uXCIgJiYgKGwgPSB0KTtcbiAgY29uc3QgbyA9IHtcbiAgICB0eXBlOiBcInNldGV4dEhlYWRpbmdcIixcbiAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgbltpXVsxXS5zdGFydCksXG4gICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBuW24ubGVuZ3RoIC0gMV1bMV0uZW5kKVxuICB9O1xuICByZXR1cm4gbltpXVsxXS50eXBlID0gXCJzZXRleHRIZWFkaW5nVGV4dFwiLCBsID8gKG4uc3BsaWNlKGksIDAsIFtcImVudGVyXCIsIG8sIGVdKSwgbi5zcGxpY2UobCArIDEsIDAsIFtcImV4aXRcIiwgbltyXVsxXSwgZV0pLCBuW3JdWzFdLmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIG5bbF1bMV0uZW5kKSkgOiBuW3JdWzFdID0gbywgbi5wdXNoKFtcImV4aXRcIiwgbywgZV0pLCBuO1xufVxuZnVuY3Rpb24gdWwobiwgZSwgdCkge1xuICBjb25zdCByID0gdGhpcztcbiAgbGV0IGkgPSByLmV2ZW50cy5sZW5ndGgsIGwsIG87XG4gIGZvciAoOyBpLS07IClcbiAgICBpZiAoci5ldmVudHNbaV1bMV0udHlwZSAhPT0gXCJsaW5lRW5kaW5nXCIgJiYgci5ldmVudHNbaV1bMV0udHlwZSAhPT0gXCJsaW5lUHJlZml4XCIgJiYgci5ldmVudHNbaV1bMV0udHlwZSAhPT0gXCJjb250ZW50XCIpIHtcbiAgICAgIG8gPSByLmV2ZW50c1tpXVsxXS50eXBlID09PSBcInBhcmFncmFwaFwiO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gdTtcbiAgZnVuY3Rpb24gdShzKSB7XG4gICAgcmV0dXJuICFyLnBhcnNlci5sYXp5W3Iubm93KCkubGluZV0gJiYgKHIuaW50ZXJydXB0IHx8IG8pID8gKG4uZW50ZXIoXCJzZXRleHRIZWFkaW5nTGluZVwiKSwgbi5lbnRlcihcInNldGV4dEhlYWRpbmdMaW5lU2VxdWVuY2VcIiksIGwgPSBzLCBhKHMpKSA6IHQocyk7XG4gIH1cbiAgZnVuY3Rpb24gYShzKSB7XG4gICAgcmV0dXJuIHMgPT09IGwgPyAobi5jb25zdW1lKHMpLCBhKSA6IChuLmV4aXQoXCJzZXRleHRIZWFkaW5nTGluZVNlcXVlbmNlXCIpLCBVKG4sIGMsIFwibGluZVN1ZmZpeFwiKShzKSk7XG4gIH1cbiAgZnVuY3Rpb24gYyhzKSB7XG4gICAgcmV0dXJuIHMgPT09IG51bGwgfHwgTChzKSA/IChuLmV4aXQoXCJzZXRleHRIZWFkaW5nTGluZVwiKSwgZShzKSkgOiB0KHMpO1xuICB9XG59XG5jb25zdCBhbCA9IHtcbiAgdG9rZW5pemU6IHNsXG59O1xuZnVuY3Rpb24gc2wobikge1xuICBjb25zdCBlID0gdGhpcywgdCA9IG4uYXR0ZW1wdChcbiAgICAvLyBUcnkgdG8gcGFyc2UgYSBibGFuayBsaW5lLlxuICAgIFpuLFxuICAgIHIsXG4gICAgLy8gVHJ5IHRvIHBhcnNlIGluaXRpYWwgZmxvdyAoZXNzZW50aWFsbHksIG9ubHkgY29kZSkuXG4gICAgbi5hdHRlbXB0KFxuICAgICAgdGhpcy5wYXJzZXIuY29uc3RydWN0cy5mbG93SW5pdGlhbCxcbiAgICAgIGksXG4gICAgICBVKFxuICAgICAgICBuLFxuICAgICAgICBuLmF0dGVtcHQoXG4gICAgICAgICAgdGhpcy5wYXJzZXIuY29uc3RydWN0cy5mbG93LFxuICAgICAgICAgIGksXG4gICAgICAgICAgbi5hdHRlbXB0KGdpLCBpKVxuICAgICAgICApLFxuICAgICAgICBcImxpbmVQcmVmaXhcIlxuICAgICAgKVxuICAgIClcbiAgKTtcbiAgcmV0dXJuIHQ7XG4gIGZ1bmN0aW9uIHIobCkge1xuICAgIGlmIChsID09PSBudWxsKSB7XG4gICAgICBuLmNvbnN1bWUobCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBuLmVudGVyKFwibGluZUVuZGluZ0JsYW5rXCIpLCBuLmNvbnN1bWUobCksIG4uZXhpdChcImxpbmVFbmRpbmdCbGFua1wiKSwgZS5jdXJyZW50Q29uc3RydWN0ID0gdm9pZCAwLCB0O1xuICB9XG4gIGZ1bmN0aW9uIGkobCkge1xuICAgIGlmIChsID09PSBudWxsKSB7XG4gICAgICBuLmNvbnN1bWUobCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBuLmVudGVyKFwibGluZUVuZGluZ1wiKSwgbi5jb25zdW1lKGwpLCBuLmV4aXQoXCJsaW5lRW5kaW5nXCIpLCBlLmN1cnJlbnRDb25zdHJ1Y3QgPSB2b2lkIDAsIHQ7XG4gIH1cbn1cbmNvbnN0IGNsID0ge1xuICByZXNvbHZlQWxsOiBqdCgpXG59LCBwbCA9IE50KFwic3RyaW5nXCIpLCBmbCA9IE50KFwidGV4dFwiKTtcbmZ1bmN0aW9uIE50KG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbml6ZTogZSxcbiAgICByZXNvbHZlQWxsOiBqdChcbiAgICAgIG4gPT09IFwidGV4dFwiID8gaGwgOiB2b2lkIDBcbiAgICApXG4gIH07XG4gIGZ1bmN0aW9uIGUodCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLCBpID0gdGhpcy5wYXJzZXIuY29uc3RydWN0c1tuXSwgbCA9IHQuYXR0ZW1wdChpLCBvLCB1KTtcbiAgICByZXR1cm4gbztcbiAgICBmdW5jdGlvbiBvKHMpIHtcbiAgICAgIHJldHVybiBjKHMpID8gbChzKSA6IHUocyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHUocykge1xuICAgICAgaWYgKHMgPT09IG51bGwpIHtcbiAgICAgICAgdC5jb25zdW1lKHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdC5lbnRlcihcImRhdGFcIiksIHQuY29uc3VtZShzKSwgYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYShzKSB7XG4gICAgICByZXR1cm4gYyhzKSA/ICh0LmV4aXQoXCJkYXRhXCIpLCBsKHMpKSA6ICh0LmNvbnN1bWUocyksIGEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjKHMpIHtcbiAgICAgIGlmIChzID09PSBudWxsKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBjb25zdCBoID0gaVtzXTtcbiAgICAgIGxldCBnID0gLTE7XG4gICAgICBpZiAoaClcbiAgICAgICAgZm9yICg7ICsrZyA8IGgubGVuZ3RoOyApIHtcbiAgICAgICAgICBjb25zdCBkID0gaFtnXTtcbiAgICAgICAgICBpZiAoIWQucHJldmlvdXMgfHwgZC5wcmV2aW91cy5jYWxsKHIsIHIucHJldmlvdXMpKVxuICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBqdChuKSB7XG4gIHJldHVybiBlO1xuICBmdW5jdGlvbiBlKHQsIHIpIHtcbiAgICBsZXQgaSA9IC0xLCBsO1xuICAgIGZvciAoOyArK2kgPD0gdC5sZW5ndGg7IClcbiAgICAgIGwgPT09IHZvaWQgMCA/IHRbaV0gJiYgdFtpXVsxXS50eXBlID09PSBcImRhdGFcIiAmJiAobCA9IGksIGkrKykgOiAoIXRbaV0gfHwgdFtpXVsxXS50eXBlICE9PSBcImRhdGFcIikgJiYgKGkgIT09IGwgKyAyICYmICh0W2xdWzFdLmVuZCA9IHRbaSAtIDFdWzFdLmVuZCwgdC5zcGxpY2UobCArIDIsIGkgLSBsIC0gMiksIGkgPSBsICsgMiksIGwgPSB2b2lkIDApO1xuICAgIHJldHVybiBuID8gbih0LCByKSA6IHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGhsKG4sIGUpIHtcbiAgbGV0IHQgPSAwO1xuICBmb3IgKDsgKyt0IDw9IG4ubGVuZ3RoOyApXG4gICAgaWYgKCh0ID09PSBuLmxlbmd0aCB8fCBuW3RdWzFdLnR5cGUgPT09IFwibGluZUVuZGluZ1wiKSAmJiBuW3QgLSAxXVsxXS50eXBlID09PSBcImRhdGFcIikge1xuICAgICAgY29uc3QgciA9IG5bdCAtIDFdWzFdLCBpID0gZS5zbGljZVN0cmVhbShyKTtcbiAgICAgIGxldCBsID0gaS5sZW5ndGgsIG8gPSAtMSwgdSA9IDAsIGE7XG4gICAgICBmb3IgKDsgbC0tOyApIHtcbiAgICAgICAgY29uc3QgYyA9IGlbbF07XG4gICAgICAgIGlmICh0eXBlb2YgYyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgZm9yIChvID0gYy5sZW5ndGg7IGMuY2hhckNvZGVBdChvIC0gMSkgPT09IDMyOyApXG4gICAgICAgICAgICB1KyssIG8tLTtcbiAgICAgICAgICBpZiAobylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIG8gPSAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChjID09PSAtMilcbiAgICAgICAgICBhID0gITAsIHUrKztcbiAgICAgICAgZWxzZSBpZiAoYyAhPT0gLTEpIHtcbiAgICAgICAgICBsKys7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1KSB7XG4gICAgICAgIGNvbnN0IGMgPSB7XG4gICAgICAgICAgdHlwZTogdCA9PT0gbi5sZW5ndGggfHwgYSB8fCB1IDwgMiA/IFwibGluZVN1ZmZpeFwiIDogXCJoYXJkQnJlYWtUcmFpbGluZ1wiLFxuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBsaW5lOiByLmVuZC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiByLmVuZC5jb2x1bW4gLSB1LFxuICAgICAgICAgICAgb2Zmc2V0OiByLmVuZC5vZmZzZXQgLSB1LFxuICAgICAgICAgICAgX2luZGV4OiByLnN0YXJ0Ll9pbmRleCArIGwsXG4gICAgICAgICAgICBfYnVmZmVySW5kZXg6IGwgPyBvIDogci5zdGFydC5fYnVmZmVySW5kZXggKyBvXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIHIuZW5kKVxuICAgICAgICB9O1xuICAgICAgICByLmVuZCA9IE9iamVjdC5hc3NpZ24oe30sIGMuc3RhcnQpLCByLnN0YXJ0Lm9mZnNldCA9PT0gci5lbmQub2Zmc2V0ID8gT2JqZWN0LmFzc2lnbihyLCBjKSA6IChuLnNwbGljZShcbiAgICAgICAgICB0LFxuICAgICAgICAgIDAsXG4gICAgICAgICAgW1wiZW50ZXJcIiwgYywgZV0sXG4gICAgICAgICAgW1wiZXhpdFwiLCBjLCBlXVxuICAgICAgICApLCB0ICs9IDIpO1xuICAgICAgfVxuICAgICAgdCsrO1xuICAgIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBtbChuLCBlLCB0KSB7XG4gIGxldCByID0gT2JqZWN0LmFzc2lnbihcbiAgICB0ID8gT2JqZWN0LmFzc2lnbih7fSwgdCkgOiB7XG4gICAgICBsaW5lOiAxLFxuICAgICAgY29sdW1uOiAxLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSxcbiAgICB7XG4gICAgICBfaW5kZXg6IDAsXG4gICAgICBfYnVmZmVySW5kZXg6IC0xXG4gICAgfVxuICApO1xuICBjb25zdCBpID0ge30sIGwgPSBbXTtcbiAgbGV0IG8gPSBbXSwgdSA9IFtdO1xuICBjb25zdCBhID0ge1xuICAgIGNvbnN1bWU6IHYsXG4gICAgZW50ZXI6IEEsXG4gICAgZXhpdDogXyxcbiAgICBhdHRlbXB0OiBJKFQpLFxuICAgIGNoZWNrOiBJKGIpLFxuICAgIGludGVycnVwdDogSShiLCB7XG4gICAgICBpbnRlcnJ1cHQ6ICEwXG4gICAgfSlcbiAgfSwgYyA9IHtcbiAgICBwcmV2aW91czogbnVsbCxcbiAgICBjb2RlOiBudWxsLFxuICAgIGNvbnRhaW5lclN0YXRlOiB7fSxcbiAgICBldmVudHM6IFtdLFxuICAgIHBhcnNlcjogbixcbiAgICBzbGljZVN0cmVhbTogZCxcbiAgICBzbGljZVNlcmlhbGl6ZTogZyxcbiAgICBub3c6IG0sXG4gICAgZGVmaW5lU2tpcDogeSxcbiAgICB3cml0ZTogaFxuICB9O1xuICBsZXQgcyA9IGUudG9rZW5pemUuY2FsbChjLCBhKTtcbiAgcmV0dXJuIGUucmVzb2x2ZUFsbCAmJiBsLnB1c2goZSksIGM7XG4gIGZ1bmN0aW9uIGgoQykge1xuICAgIHJldHVybiBvID0gYW4obywgQyksIHgoKSwgb1tvLmxlbmd0aCAtIDFdICE9PSBudWxsID8gW10gOiAoUihlLCAwKSwgYy5ldmVudHMgPSBDZShsLCBjLmV2ZW50cywgYyksIGMuZXZlbnRzKTtcbiAgfVxuICBmdW5jdGlvbiBnKEMsIEYpIHtcbiAgICByZXR1cm4gZ2woZChDKSwgRik7XG4gIH1cbiAgZnVuY3Rpb24gZChDKSB7XG4gICAgcmV0dXJuIGRsKG8sIEMpO1xuICB9XG4gIGZ1bmN0aW9uIG0oKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHIpO1xuICB9XG4gIGZ1bmN0aW9uIHkoQykge1xuICAgIGlbQy5saW5lXSA9IEMuY29sdW1uLCBYKCk7XG4gIH1cbiAgZnVuY3Rpb24geCgpIHtcbiAgICBsZXQgQztcbiAgICBmb3IgKDsgci5faW5kZXggPCBvLmxlbmd0aDsgKSB7XG4gICAgICBjb25zdCBGID0gb1tyLl9pbmRleF07XG4gICAgICBpZiAodHlwZW9mIEYgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgZm9yIChDID0gci5faW5kZXgsIHIuX2J1ZmZlckluZGV4IDwgMCAmJiAoci5fYnVmZmVySW5kZXggPSAwKTsgci5faW5kZXggPT09IEMgJiYgci5fYnVmZmVySW5kZXggPCBGLmxlbmd0aDsgKVxuICAgICAgICAgIHcoRi5jaGFyQ29kZUF0KHIuX2J1ZmZlckluZGV4KSk7XG4gICAgICBlbHNlXG4gICAgICAgIHcoRik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHcoQykge1xuICAgIHMgPSBzKEMpO1xuICB9XG4gIGZ1bmN0aW9uIHYoQykge1xuICAgIEwoQykgPyAoci5saW5lKyssIHIuY29sdW1uID0gMSwgci5vZmZzZXQgKz0gQyA9PT0gLTMgPyAyIDogMSwgWCgpKSA6IEMgIT09IC0xICYmIChyLmNvbHVtbisrLCByLm9mZnNldCsrKSwgci5fYnVmZmVySW5kZXggPCAwID8gci5faW5kZXgrKyA6IChyLl9idWZmZXJJbmRleCsrLCByLl9idWZmZXJJbmRleCA9PT0gb1tyLl9pbmRleF0ubGVuZ3RoICYmIChyLl9idWZmZXJJbmRleCA9IC0xLCByLl9pbmRleCsrKSksIGMucHJldmlvdXMgPSBDO1xuICB9XG4gIGZ1bmN0aW9uIEEoQywgRikge1xuICAgIGNvbnN0IEIgPSBGIHx8IHt9O1xuICAgIHJldHVybiBCLnR5cGUgPSBDLCBCLnN0YXJ0ID0gbSgpLCBjLmV2ZW50cy5wdXNoKFtcImVudGVyXCIsIEIsIGNdKSwgdS5wdXNoKEIpLCBCO1xuICB9XG4gIGZ1bmN0aW9uIF8oQykge1xuICAgIGNvbnN0IEYgPSB1LnBvcCgpO1xuICAgIHJldHVybiBGLmVuZCA9IG0oKSwgYy5ldmVudHMucHVzaChbXCJleGl0XCIsIEYsIGNdKSwgRjtcbiAgfVxuICBmdW5jdGlvbiBUKEMsIEYpIHtcbiAgICBSKEMsIEYuZnJvbSk7XG4gIH1cbiAgZnVuY3Rpb24gYihDLCBGKSB7XG4gICAgRi5yZXN0b3JlKCk7XG4gIH1cbiAgZnVuY3Rpb24gSShDLCBGKSB7XG4gICAgcmV0dXJuIEI7XG4gICAgZnVuY3Rpb24gQihaLCBlbiwgdW4pIHtcbiAgICAgIGxldCB0biwgcSwgSiwgVztcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KFopID8gKFxuICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAxICovXG4gICAgICAgIHAoWilcbiAgICAgICkgOiBcInRva2VuaXplXCIgaW4gWiA/IHAoW1pdKSA6IGYoWik7XG4gICAgICBmdW5jdGlvbiBmKFkpIHtcbiAgICAgICAgcmV0dXJuIHJuO1xuICAgICAgICBmdW5jdGlvbiBybihobikge1xuICAgICAgICAgIGNvbnN0IHduID0gaG4gIT09IG51bGwgJiYgWVtobl0sIFNuID0gaG4gIT09IG51bGwgJiYgWS5udWxsLCBSbiA9IFtcbiAgICAgICAgICAgIC8vIFRvIGRvOiBhZGQgbW9yZSBleHRlbnNpb24gdGVzdHMuXG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAyICovXG4gICAgICAgICAgICAuLi5BcnJheS5pc0FycmF5KHduKSA/IHduIDogd24gPyBbd25dIDogW10sXG4gICAgICAgICAgICAuLi5BcnJheS5pc0FycmF5KFNuKSA/IFNuIDogU24gPyBbU25dIDogW11cbiAgICAgICAgICBdO1xuICAgICAgICAgIHJldHVybiBwKFJuKShobik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHAoWSkge1xuICAgICAgICByZXR1cm4gdG4gPSBZLCBxID0gMCwgWS5sZW5ndGggPT09IDAgPyB1biA6IGtuKFlbcV0pO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24ga24oWSkge1xuICAgICAgICByZXR1cm4gcm47XG4gICAgICAgIGZ1bmN0aW9uIHJuKGhuKSB7XG4gICAgICAgICAgcmV0dXJuIFcgPSBNKCksIEogPSBZLCBZLnBhcnRpYWwgfHwgKGMuY3VycmVudENvbnN0cnVjdCA9IFkpLCBZLm5hbWUgJiYgYy5wYXJzZXIuY29uc3RydWN0cy5kaXNhYmxlLm51bGwuaW5jbHVkZXMoWS5uYW1lKSA/IGJuKCkgOiBZLnRva2VuaXplLmNhbGwoXG4gICAgICAgICAgICAvLyBJZiB3ZSBkbyBoYXZlIGZpZWxkcywgY3JlYXRlIGFuIG9iamVjdCB3LyBgY29udGV4dGAgYXMgaXRzXG4gICAgICAgICAgICAvLyBwcm90b3R5cGUuXG4gICAgICAgICAgICAvLyBUaGlzIGFsbG93cyBhIOKAnGxpdmUgYmluZGluZ+KAnSwgd2hpY2ggaXMgbmVlZGVkIGZvciBgaW50ZXJydXB0YC5cbiAgICAgICAgICAgIEYgPyBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoYyksIEYpIDogYyxcbiAgICAgICAgICAgIGEsXG4gICAgICAgICAgICBQbixcbiAgICAgICAgICAgIGJuXG4gICAgICAgICAgKShobik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIFBuKFkpIHtcbiAgICAgICAgcmV0dXJuIEMoSiwgVyksIGVuO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYm4oWSkge1xuICAgICAgICByZXR1cm4gVy5yZXN0b3JlKCksICsrcSA8IHRuLmxlbmd0aCA/IGtuKHRuW3FdKSA6IHVuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBSKEMsIEYpIHtcbiAgICBDLnJlc29sdmVBbGwgJiYgIWwuaW5jbHVkZXMoQykgJiYgbC5wdXNoKEMpLCBDLnJlc29sdmUgJiYgZ24oXG4gICAgICBjLmV2ZW50cyxcbiAgICAgIEYsXG4gICAgICBjLmV2ZW50cy5sZW5ndGggLSBGLFxuICAgICAgQy5yZXNvbHZlKGMuZXZlbnRzLnNsaWNlKEYpLCBjKVxuICAgICksIEMucmVzb2x2ZVRvICYmIChjLmV2ZW50cyA9IEMucmVzb2x2ZVRvKGMuZXZlbnRzLCBjKSk7XG4gIH1cbiAgZnVuY3Rpb24gTSgpIHtcbiAgICBjb25zdCBDID0gbSgpLCBGID0gYy5wcmV2aW91cywgQiA9IGMuY3VycmVudENvbnN0cnVjdCwgWiA9IGMuZXZlbnRzLmxlbmd0aCwgZW4gPSBBcnJheS5mcm9tKHUpO1xuICAgIHJldHVybiB7XG4gICAgICByZXN0b3JlOiB1bixcbiAgICAgIGZyb206IFpcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHVuKCkge1xuICAgICAgciA9IEMsIGMucHJldmlvdXMgPSBGLCBjLmN1cnJlbnRDb25zdHJ1Y3QgPSBCLCBjLmV2ZW50cy5sZW5ndGggPSBaLCB1ID0gZW4sIFgoKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gWCgpIHtcbiAgICByLmxpbmUgaW4gaSAmJiByLmNvbHVtbiA8IDIgJiYgKHIuY29sdW1uID0gaVtyLmxpbmVdLCByLm9mZnNldCArPSBpW3IubGluZV0gLSAxKTtcbiAgfVxufVxuZnVuY3Rpb24gZGwobiwgZSkge1xuICBjb25zdCB0ID0gZS5zdGFydC5faW5kZXgsIHIgPSBlLnN0YXJ0Ll9idWZmZXJJbmRleCwgaSA9IGUuZW5kLl9pbmRleCwgbCA9IGUuZW5kLl9idWZmZXJJbmRleDtcbiAgbGV0IG87XG4gIHJldHVybiB0ID09PSBpID8gbyA9IFtuW3RdLnNsaWNlKHIsIGwpXSA6IChvID0gbi5zbGljZSh0LCBpKSwgciA+IC0xICYmIChvWzBdID0gb1swXS5zbGljZShyKSksIGwgPiAwICYmIG8ucHVzaChuW2ldLnNsaWNlKDAsIGwpKSksIG87XG59XG5mdW5jdGlvbiBnbChuLCBlKSB7XG4gIGxldCB0ID0gLTE7XG4gIGNvbnN0IHIgPSBbXTtcbiAgbGV0IGk7XG4gIGZvciAoOyArK3QgPCBuLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgbCA9IG5bdF07XG4gICAgbGV0IG87XG4gICAgaWYgKHR5cGVvZiBsID09IFwic3RyaW5nXCIpXG4gICAgICBvID0gbDtcbiAgICBlbHNlXG4gICAgICBzd2l0Y2ggKGwpIHtcbiAgICAgICAgY2FzZSAtNToge1xuICAgICAgICAgIG8gPSBcIlxcclwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgLTQ6IHtcbiAgICAgICAgICBvID0gYFxuYDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIC0zOiB7XG4gICAgICAgICAgbyA9IGBcXHJcbmA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAtMjoge1xuICAgICAgICAgIG8gPSBlID8gXCIgXCIgOiBcIlx0XCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAtMToge1xuICAgICAgICAgIGlmICghZSAmJiBpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgbyA9IFwiIFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgbyA9IFN0cmluZy5mcm9tQ2hhckNvZGUobCk7XG4gICAgICB9XG4gICAgaSA9IGwgPT09IC0yLCByLnB1c2gobyk7XG4gIH1cbiAgcmV0dXJuIHIuam9pbihcIlwiKTtcbn1cbmNvbnN0IHlsID0ge1xuICBbNDJdOiBubixcbiAgWzQzXTogbm4sXG4gIFs0NV06IG5uLFxuICBbNDhdOiBubixcbiAgWzQ5XTogbm4sXG4gIFs1MF06IG5uLFxuICBbNTFdOiBubixcbiAgWzUyXTogbm4sXG4gIFs1M106IG5uLFxuICBbNTRdOiBubixcbiAgWzU1XTogbm4sXG4gIFs1Nl06IG5uLFxuICBbNTddOiBubixcbiAgWzYyXTogRHRcbn0sIHhsID0ge1xuICBbOTFdOiB3aVxufSwga2wgPSB7XG4gIFstMl06IHNlLFxuICBbLTFdOiBzZSxcbiAgWzMyXTogc2Vcbn0sIGJsID0ge1xuICBbMzVdOiBGaSxcbiAgWzQyXTogUW4sXG4gIFs0NV06IFtpdCwgUW5dLFxuICBbNjBdOiBMaSxcbiAgWzYxXTogaXQsXG4gIFs5NV06IFFuLFxuICBbOTZdOiB0dCxcbiAgWzEyNl06IHR0XG59LCB3bCA9IHtcbiAgWzM4XTogenQsXG4gIFs5Ml06IHZ0XG59LCBTbCA9IHtcbiAgWy01XTogY2UsXG4gIFstNF06IGNlLFxuICBbLTNdOiBjZSxcbiAgWzMzXTogWWksXG4gIFszOF06IHp0LFxuICBbNDJdOiB4ZSxcbiAgWzYwXTogW0pyLCBfaV0sXG4gIFs5MV06IFhpLFxuICBbOTJdOiBbQWksIHZ0XSxcbiAgWzkzXTogUGUsXG4gIFs5NV06IHhlLFxuICBbOTZdOiBwaVxufSwgRWwgPSB7XG4gIG51bGw6IFt4ZSwgY2xdXG59LCBDbCA9IHtcbiAgbnVsbDogWzQyLCA5NV1cbn0sIEFsID0ge1xuICBudWxsOiBbXVxufSwgUGwgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgX19wcm90b19fOiBudWxsLFxuICBhdHRlbnRpb25NYXJrZXJzOiBDbCxcbiAgY29udGVudEluaXRpYWw6IHhsLFxuICBkaXNhYmxlOiBBbCxcbiAgZG9jdW1lbnQ6IHlsLFxuICBmbG93OiBibCxcbiAgZmxvd0luaXRpYWw6IGtsLFxuICBpbnNpZGVTcGFuOiBFbCxcbiAgc3RyaW5nOiB3bCxcbiAgdGV4dDogU2xcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSk7XG5mdW5jdGlvbiBGbChuID0ge30pIHtcbiAgY29uc3QgZSA9IEJyKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgU2FtZSBhcyBhYm92ZS5cbiAgICBbUGxdLmNvbmNhdChuLmV4dGVuc2lvbnMgfHwgW10pXG4gICksIHQgPSB7XG4gICAgZGVmaW5lZDogW10sXG4gICAgbGF6eToge30sXG4gICAgY29uc3RydWN0czogZSxcbiAgICBjb250ZW50OiByKFdyKSxcbiAgICBkb2N1bWVudDogcihRciksXG4gICAgZmxvdzogcihhbCksXG4gICAgc3RyaW5nOiByKHBsKSxcbiAgICB0ZXh0OiByKGZsKVxuICB9O1xuICByZXR1cm4gdDtcbiAgZnVuY3Rpb24gcihpKSB7XG4gICAgcmV0dXJuIGw7XG4gICAgZnVuY3Rpb24gbChvKSB7XG4gICAgICByZXR1cm4gbWwodCwgaSwgbyk7XG4gICAgfVxuICB9XG59XG5jb25zdCBsdCA9IC9bXFwwXFx0XFxuXFxyXS9nO1xuZnVuY3Rpb24gVGwoKSB7XG4gIGxldCBuID0gMSwgZSA9IFwiXCIsIHQgPSAhMCwgcjtcbiAgcmV0dXJuIGk7XG4gIGZ1bmN0aW9uIGkobCwgbywgdSkge1xuICAgIGNvbnN0IGEgPSBbXTtcbiAgICBsZXQgYywgcywgaCwgZywgZDtcbiAgICBmb3IgKGwgPSBlICsgbC50b1N0cmluZyhvKSwgaCA9IDAsIGUgPSBcIlwiLCB0ICYmIChsLmNoYXJDb2RlQXQoMCkgPT09IDY1Mjc5ICYmIGgrKywgdCA9IHZvaWQgMCk7IGggPCBsLmxlbmd0aDsgKSB7XG4gICAgICBpZiAobHQubGFzdEluZGV4ID0gaCwgYyA9IGx0LmV4ZWMobCksIGcgPSBjICYmIGMuaW5kZXggIT09IHZvaWQgMCA/IGMuaW5kZXggOiBsLmxlbmd0aCwgZCA9IGwuY2hhckNvZGVBdChnKSwgIWMpIHtcbiAgICAgICAgZSA9IGwuc2xpY2UoaCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGQgPT09IDEwICYmIGggPT09IGcgJiYgcilcbiAgICAgICAgYS5wdXNoKC0zKSwgciA9IHZvaWQgMDtcbiAgICAgIGVsc2VcbiAgICAgICAgc3dpdGNoIChyICYmIChhLnB1c2goLTUpLCByID0gdm9pZCAwKSwgaCA8IGcgJiYgKGEucHVzaChsLnNsaWNlKGgsIGcpKSwgbiArPSBnIC0gaCksIGQpIHtcbiAgICAgICAgICBjYXNlIDA6IHtcbiAgICAgICAgICAgIGEucHVzaCg2NTUzMyksIG4rKztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDk6IHtcbiAgICAgICAgICAgIGZvciAocyA9IE1hdGguY2VpbChuIC8gNCkgKiA0LCBhLnB1c2goLTIpOyBuKysgPCBzOyApXG4gICAgICAgICAgICAgIGEucHVzaCgtMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAxMDoge1xuICAgICAgICAgICAgYS5wdXNoKC00KSwgbiA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHIgPSAhMCwgbiA9IDE7XG4gICAgICAgIH1cbiAgICAgIGggPSBnICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHUgJiYgKHIgJiYgYS5wdXNoKC01KSwgZSAmJiBhLnB1c2goZSksIGEucHVzaChudWxsKSksIGE7XG4gIH1cbn1cbmZ1bmN0aW9uIElsKG4pIHtcbiAgZm9yICg7ICFSdChuKTsgKVxuICAgIDtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiAkdChuLCBlKSB7XG4gIGNvbnN0IHQgPSBOdW1iZXIucGFyc2VJbnQobiwgZSk7XG4gIHJldHVybiAoXG4gICAgLy8gQzAgZXhjZXB0IGZvciBIVCwgTEYsIEZGLCBDUiwgc3BhY2VcbiAgICB0IDwgOSB8fCB0ID09PSAxMSB8fCB0ID4gMTMgJiYgdCA8IDMyIHx8IC8vIENvbnRyb2wgY2hhcmFjdGVyIChERUwpIG9mIHRoZSBiYXNpYyBibG9jayBhbmQgQzEgY29udHJvbHMuXG4gICAgdCA+IDEyNiAmJiB0IDwgMTYwIHx8IC8vIExvbmUgaGlnaCBzdXJyb2dhdGVzIGFuZCBsb3cgc3Vycm9nYXRlcy5cbiAgICB0ID4gNTUyOTUgJiYgdCA8IDU3MzQ0IHx8IC8vIE5vbmNoYXJhY3RlcnMuXG4gICAgdCA+IDY0OTc1ICYmIHQgPCA2NTAwOCB8fCAodCAmIDY1NTM1KSA9PT0gNjU1MzUgfHwgKHQgJiA2NTUzNSkgPT09IDY1NTM0IHx8IC8vIE91dCBvZiByYW5nZVxuICAgIHQgPiAxMTE0MTExID8gXCLvv71cIiA6IFN0cmluZy5mcm9tQ2hhckNvZGUodClcbiAgKTtcbn1cbmNvbnN0IE9sID0gL1xcXFwoWyEtLzotQFstYHstfl0pfCYoIyg/OlxcZHsxLDd9fHhbXFxkYS1mXXsxLDZ9KXxbXFxkYS16XXsxLDMxfSk7L2dpO1xuZnVuY3Rpb24gTGwobikge1xuICByZXR1cm4gbi5yZXBsYWNlKE9sLCBEbCk7XG59XG5mdW5jdGlvbiBEbChuLCBlLCB0KSB7XG4gIGlmIChlKVxuICAgIHJldHVybiBlO1xuICBpZiAodC5jaGFyQ29kZUF0KDApID09PSAzNSkge1xuICAgIGNvbnN0IGkgPSB0LmNoYXJDb2RlQXQoMSksIGwgPSBpID09PSAxMjAgfHwgaSA9PT0gODg7XG4gICAgcmV0dXJuICR0KHQuc2xpY2UobCA/IDIgOiAxKSwgbCA/IDE2IDogMTApO1xuICB9XG4gIHJldHVybiBBZSh0KSB8fCBuO1xufVxuZnVuY3Rpb24gWG4obikge1xuICByZXR1cm4gIW4gfHwgdHlwZW9mIG4gIT0gXCJvYmplY3RcIiA/IFwiXCIgOiBcInBvc2l0aW9uXCIgaW4gbiB8fCBcInR5cGVcIiBpbiBuID8gb3Qobi5wb3NpdGlvbikgOiBcInN0YXJ0XCIgaW4gbiB8fCBcImVuZFwiIGluIG4gPyBvdChuKSA6IFwibGluZVwiIGluIG4gfHwgXCJjb2x1bW5cIiBpbiBuID8ga2UobikgOiBcIlwiO1xufVxuZnVuY3Rpb24ga2Uobikge1xuICByZXR1cm4gdXQobiAmJiBuLmxpbmUpICsgXCI6XCIgKyB1dChuICYmIG4uY29sdW1uKTtcbn1cbmZ1bmN0aW9uIG90KG4pIHtcbiAgcmV0dXJuIGtlKG4gJiYgbi5zdGFydCkgKyBcIi1cIiArIGtlKG4gJiYgbi5lbmQpO1xufVxuZnVuY3Rpb24gdXQobikge1xuICByZXR1cm4gbiAmJiB0eXBlb2YgbiA9PSBcIm51bWJlclwiID8gbiA6IDE7XG59XG5jb25zdCBIdCA9IHt9Lmhhc093blByb3BlcnR5LCB2bCA9IChcbiAgLyoqXG4gICAqIEB0eXBlIHsoXG4gICAqICAgKCh2YWx1ZTogVmFsdWUsIGVuY29kaW5nOiBFbmNvZGluZywgb3B0aW9ucz86IE9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBSb290KSAmXG4gICAqICAgKCh2YWx1ZTogVmFsdWUsIG9wdGlvbnM/OiBPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gUm9vdClcbiAgICogKX1cbiAgICovXG4gIC8qKlxuICAgKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZVxuICAgKiBAcGFyYW0ge0VuY29kaW5nIHwgT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWR9IFtlbmNvZGluZ11cbiAgICogQHBhcmFtIHtPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29wdGlvbnNdXG4gICAqIEByZXR1cm5zIHtSb290fVxuICAgKi9cbiAgZnVuY3Rpb24obiwgZSwgdCkge1xuICAgIHJldHVybiB0eXBlb2YgZSAhPSBcInN0cmluZ1wiICYmICh0ID0gZSwgZSA9IHZvaWQgMCksIHpsKHQpKFxuICAgICAgSWwoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IG1pY3JvbWFyayB0eXBlcyBuZWVkIHRvIGFjY2VwdCBgbnVsbGAuXG4gICAgICAgIEZsKHQpLmRvY3VtZW50KCkud3JpdGUoVGwoKShuLCBlLCAhMCkpXG4gICAgICApXG4gICAgKTtcbiAgfVxuKTtcbmZ1bmN0aW9uIHpsKG4pIHtcbiAgY29uc3QgZSA9IHtcbiAgICB0cmFuc2Zvcm1zOiBbXSxcbiAgICBjYW5Db250YWluRW9sczogW1wiZW1waGFzaXNcIiwgXCJmcmFnbWVudFwiLCBcImhlYWRpbmdcIiwgXCJwYXJhZ3JhcGhcIiwgXCJzdHJvbmdcIl0sXG4gICAgZW50ZXI6IHtcbiAgICAgIGF1dG9saW5rOiB1KERlKSxcbiAgICAgIGF1dG9saW5rUHJvdG9jb2w6IEMsXG4gICAgICBhdXRvbGlua0VtYWlsOiBDLFxuICAgICAgYXR4SGVhZGluZzogdShGbiksXG4gICAgICBibG9ja1F1b3RlOiB1KFJuKSxcbiAgICAgIGNoYXJhY3RlckVzY2FwZTogQyxcbiAgICAgIGNoYXJhY3RlclJlZmVyZW5jZTogQyxcbiAgICAgIGNvZGVGZW5jZWQ6IHUoVm4pLFxuICAgICAgY29kZUZlbmNlZEZlbmNlSW5mbzogYSxcbiAgICAgIGNvZGVGZW5jZWRGZW5jZU1ldGE6IGEsXG4gICAgICBjb2RlSW5kZW50ZWQ6IHUoVm4sIGEpLFxuICAgICAgY29kZVRleHQ6IHUoZWUsIGEpLFxuICAgICAgY29kZVRleHREYXRhOiBDLFxuICAgICAgZGF0YTogQyxcbiAgICAgIGNvZGVGbG93VmFsdWU6IEMsXG4gICAgICBkZWZpbml0aW9uOiB1KFApLFxuICAgICAgZGVmaW5pdGlvbkRlc3RpbmF0aW9uU3RyaW5nOiBhLFxuICAgICAgZGVmaW5pdGlvbkxhYmVsU3RyaW5nOiBhLFxuICAgICAgZGVmaW5pdGlvblRpdGxlU3RyaW5nOiBhLFxuICAgICAgZW1waGFzaXM6IHUoX24pLFxuICAgICAgaGFyZEJyZWFrRXNjYXBlOiB1KE1uKSxcbiAgICAgIGhhcmRCcmVha1RyYWlsaW5nOiB1KE1uKSxcbiAgICAgIGh0bWxGbG93OiB1KExlLCBhKSxcbiAgICAgIGh0bWxGbG93RGF0YTogQyxcbiAgICAgIGh0bWxUZXh0OiB1KExlLCBhKSxcbiAgICAgIGh0bWxUZXh0RGF0YTogQyxcbiAgICAgIGltYWdlOiB1KHNyKSxcbiAgICAgIGxhYmVsOiBhLFxuICAgICAgbGluazogdShEZSksXG4gICAgICBsaXN0SXRlbTogdShjciksXG4gICAgICBsaXN0SXRlbVZhbHVlOiBtLFxuICAgICAgbGlzdE9yZGVyZWQ6IHUodmUsIGQpLFxuICAgICAgbGlzdFVub3JkZXJlZDogdSh2ZSksXG4gICAgICBwYXJhZ3JhcGg6IHUocHIpLFxuICAgICAgcmVmZXJlbmNlOiBibixcbiAgICAgIHJlZmVyZW5jZVN0cmluZzogYSxcbiAgICAgIHJlc291cmNlRGVzdGluYXRpb25TdHJpbmc6IGEsXG4gICAgICByZXNvdXJjZVRpdGxlU3RyaW5nOiBhLFxuICAgICAgc2V0ZXh0SGVhZGluZzogdShGbiksXG4gICAgICBzdHJvbmc6IHUoZnIpLFxuICAgICAgdGhlbWF0aWNCcmVhazogdShtcilcbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIGF0eEhlYWRpbmc6IHMoKSxcbiAgICAgIGF0eEhlYWRpbmdTZXF1ZW5jZTogSSxcbiAgICAgIGF1dG9saW5rOiBzKCksXG4gICAgICBhdXRvbGlua0VtYWlsOiBTbixcbiAgICAgIGF1dG9saW5rUHJvdG9jb2w6IHduLFxuICAgICAgYmxvY2tRdW90ZTogcygpLFxuICAgICAgY2hhcmFjdGVyRXNjYXBlVmFsdWU6IEYsXG4gICAgICBjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJIZXhhZGVjaW1hbDogcm4sXG4gICAgICBjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljOiBybixcbiAgICAgIGNoYXJhY3RlclJlZmVyZW5jZVZhbHVlOiBobixcbiAgICAgIGNvZGVGZW5jZWQ6IHModiksXG4gICAgICBjb2RlRmVuY2VkRmVuY2U6IHcsXG4gICAgICBjb2RlRmVuY2VkRmVuY2VJbmZvOiB5LFxuICAgICAgY29kZUZlbmNlZEZlbmNlTWV0YTogeCxcbiAgICAgIGNvZGVGbG93VmFsdWU6IEYsXG4gICAgICBjb2RlSW5kZW50ZWQ6IHMoQSksXG4gICAgICBjb2RlVGV4dDogcyh0biksXG4gICAgICBjb2RlVGV4dERhdGE6IEYsXG4gICAgICBkYXRhOiBGLFxuICAgICAgZGVmaW5pdGlvbjogcygpLFxuICAgICAgZGVmaW5pdGlvbkRlc3RpbmF0aW9uU3RyaW5nOiBiLFxuICAgICAgZGVmaW5pdGlvbkxhYmVsU3RyaW5nOiBfLFxuICAgICAgZGVmaW5pdGlvblRpdGxlU3RyaW5nOiBULFxuICAgICAgZW1waGFzaXM6IHMoKSxcbiAgICAgIGhhcmRCcmVha0VzY2FwZTogcyhaKSxcbiAgICAgIGhhcmRCcmVha1RyYWlsaW5nOiBzKFopLFxuICAgICAgaHRtbEZsb3c6IHMoZW4pLFxuICAgICAgaHRtbEZsb3dEYXRhOiBGLFxuICAgICAgaHRtbFRleHQ6IHModW4pLFxuICAgICAgaHRtbFRleHREYXRhOiBGLFxuICAgICAgaW1hZ2U6IHMoSiksXG4gICAgICBsYWJlbDogZixcbiAgICAgIGxhYmVsVGV4dDogVyxcbiAgICAgIGxpbmVFbmRpbmc6IEIsXG4gICAgICBsaW5rOiBzKHEpLFxuICAgICAgbGlzdEl0ZW06IHMoKSxcbiAgICAgIGxpc3RPcmRlcmVkOiBzKCksXG4gICAgICBsaXN0VW5vcmRlcmVkOiBzKCksXG4gICAgICBwYXJhZ3JhcGg6IHMoKSxcbiAgICAgIHJlZmVyZW5jZVN0cmluZzogWSxcbiAgICAgIHJlc291cmNlRGVzdGluYXRpb25TdHJpbmc6IHAsXG4gICAgICByZXNvdXJjZVRpdGxlU3RyaW5nOiBrbixcbiAgICAgIHJlc291cmNlOiBQbixcbiAgICAgIHNldGV4dEhlYWRpbmc6IHMoWCksXG4gICAgICBzZXRleHRIZWFkaW5nTGluZVNlcXVlbmNlOiBNLFxuICAgICAgc2V0ZXh0SGVhZGluZ1RleHQ6IFIsXG4gICAgICBzdHJvbmc6IHMoKSxcbiAgICAgIHRoZW1hdGljQnJlYWs6IHMoKVxuICAgIH1cbiAgfTtcbiAgVXQoZSwgKG4gfHwge30pLm1kYXN0RXh0ZW5zaW9ucyB8fCBbXSk7XG4gIGNvbnN0IHQgPSB7fTtcbiAgcmV0dXJuIHI7XG4gIGZ1bmN0aW9uIHIoaykge1xuICAgIGxldCBFID0ge1xuICAgICAgdHlwZTogXCJyb290XCIsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuICAgIGNvbnN0IE8gPSB7XG4gICAgICBzdGFjazogW0VdLFxuICAgICAgdG9rZW5TdGFjazogW10sXG4gICAgICBjb25maWc6IGUsXG4gICAgICBlbnRlcjogYyxcbiAgICAgIGV4aXQ6IGgsXG4gICAgICBidWZmZXI6IGEsXG4gICAgICByZXN1bWU6IGcsXG4gICAgICBzZXREYXRhOiBsLFxuICAgICAgZ2V0RGF0YTogb1xuICAgIH0sICQgPSBbXTtcbiAgICBsZXQgSCA9IC0xO1xuICAgIGZvciAoOyArK0ggPCBrLmxlbmd0aDsgKVxuICAgICAgaWYgKGtbSF1bMV0udHlwZSA9PT0gXCJsaXN0T3JkZXJlZFwiIHx8IGtbSF1bMV0udHlwZSA9PT0gXCJsaXN0VW5vcmRlcmVkXCIpXG4gICAgICAgIGlmIChrW0hdWzBdID09PSBcImVudGVyXCIpXG4gICAgICAgICAgJC5wdXNoKEgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBmbiA9ICQucG9wKCk7XG4gICAgICAgICAgSCA9IGkoaywgZm4sIEgpO1xuICAgICAgICB9XG4gICAgZm9yIChIID0gLTE7ICsrSCA8IGsubGVuZ3RoOyApIHtcbiAgICAgIGNvbnN0IGZuID0gZVtrW0hdWzBdXTtcbiAgICAgIEh0LmNhbGwoZm4sIGtbSF1bMV0udHlwZSkgJiYgZm5ba1tIXVsxXS50eXBlXS5jYWxsKFxuICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHNsaWNlU2VyaWFsaXplOiBrW0hdWzJdLnNsaWNlU2VyaWFsaXplXG4gICAgICAgICAgfSxcbiAgICAgICAgICBPXG4gICAgICAgICksXG4gICAgICAgIGtbSF1bMV1cbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChPLnRva2VuU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZm4gPSBPLnRva2VuU3RhY2tbTy50b2tlblN0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgKGZuWzFdIHx8IGF0KS5jYWxsKE8sIHZvaWQgMCwgZm5bMF0pO1xuICAgIH1cbiAgICBmb3IgKEUucG9zaXRpb24gPSB7XG4gICAgICBzdGFydDogQ24oXG4gICAgICAgIGsubGVuZ3RoID4gMCA/IGtbMF1bMV0uc3RhcnQgOiB7XG4gICAgICAgICAgbGluZTogMSxcbiAgICAgICAgICBjb2x1bW46IDEsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBlbmQ6IENuKFxuICAgICAgICBrLmxlbmd0aCA+IDAgPyBrW2subGVuZ3RoIC0gMl1bMV0uZW5kIDoge1xuICAgICAgICAgIGxpbmU6IDEsXG4gICAgICAgICAgY29sdW1uOiAxLFxuICAgICAgICAgIG9mZnNldDogMFxuICAgICAgICB9XG4gICAgICApXG4gICAgfSwgSCA9IC0xOyArK0ggPCBlLnRyYW5zZm9ybXMubGVuZ3RoOyApXG4gICAgICBFID0gZS50cmFuc2Zvcm1zW0hdKEUpIHx8IEU7XG4gICAgcmV0dXJuIEU7XG4gIH1cbiAgZnVuY3Rpb24gaShrLCBFLCBPKSB7XG4gICAgbGV0ICQgPSBFIC0gMSwgSCA9IC0xLCBmbiA9ICExLCBFbiwgeW4sIEJuLCBObjtcbiAgICBmb3IgKDsgKyskIDw9IE87ICkge1xuICAgICAgY29uc3QgUSA9IGtbJF07XG4gICAgICBpZiAoUVsxXS50eXBlID09PSBcImxpc3RVbm9yZGVyZWRcIiB8fCBRWzFdLnR5cGUgPT09IFwibGlzdE9yZGVyZWRcIiB8fCBRWzFdLnR5cGUgPT09IFwiYmxvY2tRdW90ZVwiID8gKFFbMF0gPT09IFwiZW50ZXJcIiA/IEgrKyA6IEgtLSwgTm4gPSB2b2lkIDApIDogUVsxXS50eXBlID09PSBcImxpbmVFbmRpbmdCbGFua1wiID8gUVswXSA9PT0gXCJlbnRlclwiICYmIChFbiAmJiAhTm4gJiYgIUggJiYgIUJuICYmIChCbiA9ICQpLCBObiA9IHZvaWQgMCkgOiBRWzFdLnR5cGUgPT09IFwibGluZVByZWZpeFwiIHx8IFFbMV0udHlwZSA9PT0gXCJsaXN0SXRlbVZhbHVlXCIgfHwgUVsxXS50eXBlID09PSBcImxpc3RJdGVtTWFya2VyXCIgfHwgUVsxXS50eXBlID09PSBcImxpc3RJdGVtUHJlZml4XCIgfHwgUVsxXS50eXBlID09PSBcImxpc3RJdGVtUHJlZml4V2hpdGVzcGFjZVwiIHx8IChObiA9IHZvaWQgMCksICFIICYmIFFbMF0gPT09IFwiZW50ZXJcIiAmJiBRWzFdLnR5cGUgPT09IFwibGlzdEl0ZW1QcmVmaXhcIiB8fCBIID09PSAtMSAmJiBRWzBdID09PSBcImV4aXRcIiAmJiAoUVsxXS50eXBlID09PSBcImxpc3RVbm9yZGVyZWRcIiB8fCBRWzFdLnR5cGUgPT09IFwibGlzdE9yZGVyZWRcIikpIHtcbiAgICAgICAgaWYgKEVuKSB7XG4gICAgICAgICAgbGV0IHRlID0gJDtcbiAgICAgICAgICBmb3IgKHluID0gdm9pZCAwOyB0ZS0tOyApIHtcbiAgICAgICAgICAgIGNvbnN0IHhuID0ga1t0ZV07XG4gICAgICAgICAgICBpZiAoeG5bMV0udHlwZSA9PT0gXCJsaW5lRW5kaW5nXCIgfHwgeG5bMV0udHlwZSA9PT0gXCJsaW5lRW5kaW5nQmxhbmtcIikge1xuICAgICAgICAgICAgICBpZiAoeG5bMF0gPT09IFwiZXhpdFwiKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB5biAmJiAoa1t5bl1bMV0udHlwZSA9IFwibGluZUVuZGluZ0JsYW5rXCIsIGZuID0gITApLCB4blsxXS50eXBlID0gXCJsaW5lRW5kaW5nXCIsIHluID0gdGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEoeG5bMV0udHlwZSA9PT0gXCJsaW5lUHJlZml4XCIgfHwgeG5bMV0udHlwZSA9PT0gXCJibG9ja1F1b3RlUHJlZml4XCIgfHwgeG5bMV0udHlwZSA9PT0gXCJibG9ja1F1b3RlUHJlZml4V2hpdGVzcGFjZVwiIHx8IHhuWzFdLnR5cGUgPT09IFwiYmxvY2tRdW90ZU1hcmtlclwiIHx8IHhuWzFdLnR5cGUgPT09IFwibGlzdEl0ZW1JbmRlbnRcIikpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBCbiAmJiAoIXluIHx8IEJuIDwgeW4pICYmIChFbi5fc3ByZWFkID0gITApLCBFbi5lbmQgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICB5biA/IGtbeW5dWzFdLnN0YXJ0IDogUVsxXS5lbmRcbiAgICAgICAgICApLCBrLnNwbGljZSh5biB8fCAkLCAwLCBbXCJleGl0XCIsIEVuLCBRWzJdXSksICQrKywgTysrO1xuICAgICAgICB9XG4gICAgICAgIFFbMV0udHlwZSA9PT0gXCJsaXN0SXRlbVByZWZpeFwiICYmIChFbiA9IHtcbiAgICAgICAgICB0eXBlOiBcImxpc3RJdGVtXCIsXG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBQYXRjaGVkXG4gICAgICAgICAgX3NwcmVhZDogITEsXG4gICAgICAgICAgc3RhcnQ6IE9iamVjdC5hc3NpZ24oe30sIFFbMV0uc3RhcnQpXG4gICAgICAgIH0sIGsuc3BsaWNlKCQsIDAsIFtcImVudGVyXCIsIEVuLCBRWzJdXSksICQrKywgTysrLCBCbiA9IHZvaWQgMCwgTm4gPSAhMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrW0VdWzFdLl9zcHJlYWQgPSBmbiwgTztcbiAgfVxuICBmdW5jdGlvbiBsKGssIEUpIHtcbiAgICB0W2tdID0gRTtcbiAgfVxuICBmdW5jdGlvbiBvKGspIHtcbiAgICByZXR1cm4gdFtrXTtcbiAgfVxuICBmdW5jdGlvbiB1KGssIEUpIHtcbiAgICByZXR1cm4gTztcbiAgICBmdW5jdGlvbiBPKCQpIHtcbiAgICAgIGMuY2FsbCh0aGlzLCBrKCQpLCAkKSwgRSAmJiBFLmNhbGwodGhpcywgJCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGEoKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgIHR5cGU6IFwiZnJhZ21lbnRcIixcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGMoaywgRSwgTykge1xuICAgIHJldHVybiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0uY2hpbGRyZW4ucHVzaChrKSwgdGhpcy5zdGFjay5wdXNoKGspLCB0aGlzLnRva2VuU3RhY2sucHVzaChbRSwgT10pLCBrLnBvc2l0aW9uID0ge1xuICAgICAgc3RhcnQ6IENuKEUuc3RhcnQpXG4gICAgfSwgaztcbiAgfVxuICBmdW5jdGlvbiBzKGspIHtcbiAgICByZXR1cm4gRTtcbiAgICBmdW5jdGlvbiBFKE8pIHtcbiAgICAgIGsgJiYgay5jYWxsKHRoaXMsIE8pLCBoLmNhbGwodGhpcywgTyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGgoaywgRSkge1xuICAgIGNvbnN0IE8gPSB0aGlzLnN0YWNrLnBvcCgpLCAkID0gdGhpcy50b2tlblN0YWNrLnBvcCgpO1xuICAgIGlmICgkKVxuICAgICAgJFswXS50eXBlICE9PSBrLnR5cGUgJiYgKEUgPyBFLmNhbGwodGhpcywgaywgJFswXSkgOiAoJFsxXSB8fCBhdCkuY2FsbCh0aGlzLCBrLCAkWzBdKSk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNhbm5vdCBjbG9zZSBgXCIgKyBrLnR5cGUgKyBcImAgKFwiICsgWG4oe1xuICAgICAgICAgIHN0YXJ0OiBrLnN0YXJ0LFxuICAgICAgICAgIGVuZDogay5lbmRcbiAgICAgICAgfSkgKyBcIik6IGl04oCZcyBub3Qgb3BlblwiXG4gICAgICApO1xuICAgIHJldHVybiBPLnBvc2l0aW9uLmVuZCA9IENuKGsuZW5kKSwgTztcbiAgfVxuICBmdW5jdGlvbiBnKCkge1xuICAgIHJldHVybiBfcih0aGlzLnN0YWNrLnBvcCgpKTtcbiAgfVxuICBmdW5jdGlvbiBkKCkge1xuICAgIGwoXCJleHBlY3RpbmdGaXJzdExpc3RJdGVtVmFsdWVcIiwgITApO1xuICB9XG4gIGZ1bmN0aW9uIG0oaykge1xuICAgIGlmIChvKFwiZXhwZWN0aW5nRmlyc3RMaXN0SXRlbVZhbHVlXCIpKSB7XG4gICAgICBjb25zdCBFID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdO1xuICAgICAgRS5zdGFydCA9IE51bWJlci5wYXJzZUludCh0aGlzLnNsaWNlU2VyaWFsaXplKGspLCAxMCksIGwoXCJleHBlY3RpbmdGaXJzdExpc3RJdGVtVmFsdWVcIik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHkoKSB7XG4gICAgY29uc3QgayA9IHRoaXMucmVzdW1lKCksIEUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgRS5sYW5nID0gaztcbiAgfVxuICBmdW5jdGlvbiB4KCkge1xuICAgIGNvbnN0IGsgPSB0aGlzLnJlc3VtZSgpLCBFID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIEUubWV0YSA9IGs7XG4gIH1cbiAgZnVuY3Rpb24gdygpIHtcbiAgICBvKFwiZmxvd0NvZGVJbnNpZGVcIikgfHwgKHRoaXMuYnVmZmVyKCksIGwoXCJmbG93Q29kZUluc2lkZVwiLCAhMCkpO1xuICB9XG4gIGZ1bmN0aW9uIHYoKSB7XG4gICAgY29uc3QgayA9IHRoaXMucmVzdW1lKCksIEUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgRS52YWx1ZSA9IGsucmVwbGFjZSgvXihcXHI/XFxufFxccil8KFxccj9cXG58XFxyKSQvZywgXCJcIiksIGwoXCJmbG93Q29kZUluc2lkZVwiKTtcbiAgfVxuICBmdW5jdGlvbiBBKCkge1xuICAgIGNvbnN0IGsgPSB0aGlzLnJlc3VtZSgpLCBFID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIEUudmFsdWUgPSBrLnJlcGxhY2UoLyhcXHI/XFxufFxccikkL2csIFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIF8oaykge1xuICAgIGNvbnN0IEUgPSB0aGlzLnJlc3VtZSgpLCBPID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIE8ubGFiZWwgPSBFLCBPLmlkZW50aWZpZXIgPSBMbihcbiAgICAgIHRoaXMuc2xpY2VTZXJpYWxpemUoaylcbiAgICApLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgZnVuY3Rpb24gVCgpIHtcbiAgICBjb25zdCBrID0gdGhpcy5yZXN1bWUoKSwgRSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICBFLnRpdGxlID0gaztcbiAgfVxuICBmdW5jdGlvbiBiKCkge1xuICAgIGNvbnN0IGsgPSB0aGlzLnJlc3VtZSgpLCBFID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIEUudXJsID0gaztcbiAgfVxuICBmdW5jdGlvbiBJKGspIHtcbiAgICBjb25zdCBFID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmICghRS5kZXB0aCkge1xuICAgICAgY29uc3QgTyA9IHRoaXMuc2xpY2VTZXJpYWxpemUoaykubGVuZ3RoO1xuICAgICAgRS5kZXB0aCA9IE87XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFIoKSB7XG4gICAgbChcInNldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmdcIiwgITApO1xuICB9XG4gIGZ1bmN0aW9uIE0oaykge1xuICAgIGNvbnN0IEUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgRS5kZXB0aCA9IHRoaXMuc2xpY2VTZXJpYWxpemUoaykuY2hhckNvZGVBdCgwKSA9PT0gNjEgPyAxIDogMjtcbiAgfVxuICBmdW5jdGlvbiBYKCkge1xuICAgIGwoXCJzZXRleHRIZWFkaW5nU2x1cnBMaW5lRW5kaW5nXCIpO1xuICB9XG4gIGZ1bmN0aW9uIEMoaykge1xuICAgIGNvbnN0IEUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgbGV0IE8gPSBFLmNoaWxkcmVuW0UuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgKCFPIHx8IE8udHlwZSAhPT0gXCJ0ZXh0XCIpICYmIChPID0gaHIoKSwgTy5wb3NpdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBDbihrLnN0YXJ0KVxuICAgIH0sIEUuY2hpbGRyZW4ucHVzaChPKSksIHRoaXMuc3RhY2sucHVzaChPKTtcbiAgfVxuICBmdW5jdGlvbiBGKGspIHtcbiAgICBjb25zdCBFID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICBFLnZhbHVlICs9IHRoaXMuc2xpY2VTZXJpYWxpemUoayksIEUucG9zaXRpb24uZW5kID0gQ24oay5lbmQpO1xuICB9XG4gIGZ1bmN0aW9uIEIoaykge1xuICAgIGNvbnN0IEUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgaWYgKG8oXCJhdEhhcmRCcmVha1wiKSkge1xuICAgICAgY29uc3QgTyA9IEUuY2hpbGRyZW5bRS5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIE8ucG9zaXRpb24uZW5kID0gQ24oay5lbmQpLCBsKFwiYXRIYXJkQnJlYWtcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICFvKFwic2V0ZXh0SGVhZGluZ1NsdXJwTGluZUVuZGluZ1wiKSAmJiBlLmNhbkNvbnRhaW5Fb2xzLmluY2x1ZGVzKEUudHlwZSkgJiYgKEMuY2FsbCh0aGlzLCBrKSwgRi5jYWxsKHRoaXMsIGspKTtcbiAgfVxuICBmdW5jdGlvbiBaKCkge1xuICAgIGwoXCJhdEhhcmRCcmVha1wiLCAhMCk7XG4gIH1cbiAgZnVuY3Rpb24gZW4oKSB7XG4gICAgY29uc3QgayA9IHRoaXMucmVzdW1lKCksIEUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgRS52YWx1ZSA9IGs7XG4gIH1cbiAgZnVuY3Rpb24gdW4oKSB7XG4gICAgY29uc3QgayA9IHRoaXMucmVzdW1lKCksIEUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgRS52YWx1ZSA9IGs7XG4gIH1cbiAgZnVuY3Rpb24gdG4oKSB7XG4gICAgY29uc3QgayA9IHRoaXMucmVzdW1lKCksIEUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgRS52YWx1ZSA9IGs7XG4gIH1cbiAgZnVuY3Rpb24gcSgpIHtcbiAgICBjb25zdCBrID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmIChvKFwiaW5SZWZlcmVuY2VcIikpIHtcbiAgICAgIGNvbnN0IEUgPSBvKFwicmVmZXJlbmNlVHlwZVwiKSB8fCBcInNob3J0Y3V0XCI7XG4gICAgICBrLnR5cGUgKz0gXCJSZWZlcmVuY2VcIiwgay5yZWZlcmVuY2VUeXBlID0gRSwgZGVsZXRlIGsudXJsLCBkZWxldGUgay50aXRsZTtcbiAgICB9IGVsc2VcbiAgICAgIGRlbGV0ZSBrLmlkZW50aWZpZXIsIGRlbGV0ZSBrLmxhYmVsO1xuICAgIGwoXCJyZWZlcmVuY2VUeXBlXCIpO1xuICB9XG4gIGZ1bmN0aW9uIEooKSB7XG4gICAgY29uc3QgayA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAobyhcImluUmVmZXJlbmNlXCIpKSB7XG4gICAgICBjb25zdCBFID0gbyhcInJlZmVyZW5jZVR5cGVcIikgfHwgXCJzaG9ydGN1dFwiO1xuICAgICAgay50eXBlICs9IFwiUmVmZXJlbmNlXCIsIGsucmVmZXJlbmNlVHlwZSA9IEUsIGRlbGV0ZSBrLnVybCwgZGVsZXRlIGsudGl0bGU7XG4gICAgfSBlbHNlXG4gICAgICBkZWxldGUgay5pZGVudGlmaWVyLCBkZWxldGUgay5sYWJlbDtcbiAgICBsKFwicmVmZXJlbmNlVHlwZVwiKTtcbiAgfVxuICBmdW5jdGlvbiBXKGspIHtcbiAgICBjb25zdCBFID0gdGhpcy5zbGljZVNlcmlhbGl6ZShrKSwgTyA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAyXTtcbiAgICBPLmxhYmVsID0gTGwoRSksIE8uaWRlbnRpZmllciA9IExuKEUpLnRvTG93ZXJDYXNlKCk7XG4gIH1cbiAgZnVuY3Rpb24gZigpIHtcbiAgICBjb25zdCBrID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdLCBFID0gdGhpcy5yZXN1bWUoKSwgTyA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAobChcImluUmVmZXJlbmNlXCIsICEwKSwgTy50eXBlID09PSBcImxpbmtcIikge1xuICAgICAgY29uc3QgJCA9IGsuY2hpbGRyZW47XG4gICAgICBPLmNoaWxkcmVuID0gJDtcbiAgICB9IGVsc2VcbiAgICAgIE8uYWx0ID0gRTtcbiAgfVxuICBmdW5jdGlvbiBwKCkge1xuICAgIGNvbnN0IGsgPSB0aGlzLnJlc3VtZSgpLCBFID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIEUudXJsID0gaztcbiAgfVxuICBmdW5jdGlvbiBrbigpIHtcbiAgICBjb25zdCBrID0gdGhpcy5yZXN1bWUoKSwgRSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICBFLnRpdGxlID0gaztcbiAgfVxuICBmdW5jdGlvbiBQbigpIHtcbiAgICBsKFwiaW5SZWZlcmVuY2VcIik7XG4gIH1cbiAgZnVuY3Rpb24gYm4oKSB7XG4gICAgbChcInJlZmVyZW5jZVR5cGVcIiwgXCJjb2xsYXBzZWRcIik7XG4gIH1cbiAgZnVuY3Rpb24gWShrKSB7XG4gICAgY29uc3QgRSA9IHRoaXMucmVzdW1lKCksIE8gPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgTy5sYWJlbCA9IEUsIE8uaWRlbnRpZmllciA9IExuKFxuICAgICAgdGhpcy5zbGljZVNlcmlhbGl6ZShrKVxuICAgICkudG9Mb3dlckNhc2UoKSwgbChcInJlZmVyZW5jZVR5cGVcIiwgXCJmdWxsXCIpO1xuICB9XG4gIGZ1bmN0aW9uIHJuKGspIHtcbiAgICBsKFwiY2hhcmFjdGVyUmVmZXJlbmNlVHlwZVwiLCBrLnR5cGUpO1xuICB9XG4gIGZ1bmN0aW9uIGhuKGspIHtcbiAgICBjb25zdCBFID0gdGhpcy5zbGljZVNlcmlhbGl6ZShrKSwgTyA9IG8oXCJjaGFyYWN0ZXJSZWZlcmVuY2VUeXBlXCIpO1xuICAgIGxldCAkO1xuICAgIE8gPyAoJCA9ICR0KFxuICAgICAgRSxcbiAgICAgIE8gPT09IFwiY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyTnVtZXJpY1wiID8gMTAgOiAxNlxuICAgICksIGwoXCJjaGFyYWN0ZXJSZWZlcmVuY2VUeXBlXCIpKSA6ICQgPSBBZShFKTtcbiAgICBjb25zdCBIID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICBILnZhbHVlICs9ICQsIEgucG9zaXRpb24uZW5kID0gQ24oay5lbmQpO1xuICB9XG4gIGZ1bmN0aW9uIHduKGspIHtcbiAgICBGLmNhbGwodGhpcywgayk7XG4gICAgY29uc3QgRSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICBFLnVybCA9IHRoaXMuc2xpY2VTZXJpYWxpemUoayk7XG4gIH1cbiAgZnVuY3Rpb24gU24oaykge1xuICAgIEYuY2FsbCh0aGlzLCBrKTtcbiAgICBjb25zdCBFID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIEUudXJsID0gXCJtYWlsdG86XCIgKyB0aGlzLnNsaWNlU2VyaWFsaXplKGspO1xuICB9XG4gIGZ1bmN0aW9uIFJuKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImJsb2NrcXVvdGVcIixcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gVm4oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiY29kZVwiLFxuICAgICAgbGFuZzogbnVsbCxcbiAgICAgIG1ldGE6IG51bGwsXG4gICAgICB2YWx1ZTogXCJcIlxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZWUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaW5saW5lQ29kZVwiLFxuICAgICAgdmFsdWU6IFwiXCJcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIFAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZGVmaW5pdGlvblwiLFxuICAgICAgaWRlbnRpZmllcjogXCJcIixcbiAgICAgIGxhYmVsOiBudWxsLFxuICAgICAgdGl0bGU6IG51bGwsXG4gICAgICB1cmw6IFwiXCJcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIF9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVtcGhhc2lzXCIsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIEZuKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImhlYWRpbmdcIixcbiAgICAgIGRlcHRoOiB2b2lkIDAsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIE1uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImJyZWFrXCJcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIExlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImh0bWxcIixcbiAgICAgIHZhbHVlOiBcIlwiXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBzcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgdGl0bGU6IG51bGwsXG4gICAgICB1cmw6IFwiXCIsXG4gICAgICBhbHQ6IG51bGxcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIERlKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImxpbmtcIixcbiAgICAgIHRpdGxlOiBudWxsLFxuICAgICAgdXJsOiBcIlwiLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB2ZShrKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGlzdFwiLFxuICAgICAgb3JkZXJlZDogay50eXBlID09PSBcImxpc3RPcmRlcmVkXCIsXG4gICAgICBzdGFydDogbnVsbCxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgUGF0Y2hlZC5cbiAgICAgIHNwcmVhZDogay5fc3ByZWFkLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBjcihrKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGlzdEl0ZW1cIixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgUGF0Y2hlZC5cbiAgICAgIHNwcmVhZDogay5fc3ByZWFkLFxuICAgICAgY2hlY2tlZDogbnVsbCxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gcHIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwicGFyYWdyYXBoXCIsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZyKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInN0cm9uZ1wiLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBocigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICB2YWx1ZTogXCJcIlxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gbXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidGhlbWF0aWNCcmVha1wiXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gQ24obikge1xuICByZXR1cm4ge1xuICAgIGxpbmU6IG4ubGluZSxcbiAgICBjb2x1bW46IG4uY29sdW1uLFxuICAgIG9mZnNldDogbi5vZmZzZXRcbiAgfTtcbn1cbmZ1bmN0aW9uIFV0KG4sIGUpIHtcbiAgbGV0IHQgPSAtMTtcbiAgZm9yICg7ICsrdCA8IGUubGVuZ3RoOyApIHtcbiAgICBjb25zdCByID0gZVt0XTtcbiAgICBBcnJheS5pc0FycmF5KHIpID8gVXQobiwgcikgOiBSbChuLCByKTtcbiAgfVxufVxuZnVuY3Rpb24gUmwobiwgZSkge1xuICBsZXQgdDtcbiAgZm9yICh0IGluIGUpXG4gICAgaWYgKEh0LmNhbGwoZSwgdCkpIHtcbiAgICAgIGlmICh0ID09PSBcImNhbkNvbnRhaW5Fb2xzXCIpIHtcbiAgICAgICAgY29uc3QgciA9IGVbdF07XG4gICAgICAgIHIgJiYgblt0XS5wdXNoKC4uLnIpO1xuICAgICAgfSBlbHNlIGlmICh0ID09PSBcInRyYW5zZm9ybXNcIikge1xuICAgICAgICBjb25zdCByID0gZVt0XTtcbiAgICAgICAgciAmJiBuW3RdLnB1c2goLi4ucik7XG4gICAgICB9IGVsc2UgaWYgKHQgPT09IFwiZW50ZXJcIiB8fCB0ID09PSBcImV4aXRcIikge1xuICAgICAgICBjb25zdCByID0gZVt0XTtcbiAgICAgICAgciAmJiBPYmplY3QuYXNzaWduKG5bdF0sIHIpO1xuICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGF0KG4sIGUpIHtcbiAgdGhyb3cgbiA/IG5ldyBFcnJvcihcbiAgICBcIkNhbm5vdCBjbG9zZSBgXCIgKyBuLnR5cGUgKyBcImAgKFwiICsgWG4oe1xuICAgICAgc3RhcnQ6IG4uc3RhcnQsXG4gICAgICBlbmQ6IG4uZW5kXG4gICAgfSkgKyBcIik6IGEgZGlmZmVyZW50IHRva2VuIChgXCIgKyBlLnR5cGUgKyBcImAsIFwiICsgWG4oe1xuICAgICAgc3RhcnQ6IGUuc3RhcnQsXG4gICAgICBlbmQ6IGUuZW5kXG4gICAgfSkgKyBcIikgaXMgb3BlblwiXG4gICkgOiBuZXcgRXJyb3IoXG4gICAgXCJDYW5ub3QgY2xvc2UgZG9jdW1lbnQsIGEgdG9rZW4gKGBcIiArIGUudHlwZSArIFwiYCwgXCIgKyBYbih7XG4gICAgICBzdGFydDogZS5zdGFydCxcbiAgICAgIGVuZDogZS5lbmRcbiAgICB9KSArIFwiKSBpcyBzdGlsbCBvcGVuXCJcbiAgKTtcbn1cbmZ1bmN0aW9uIF9sKG4pIHtcbiAgT2JqZWN0LmFzc2lnbih0aGlzLCB7IFBhcnNlcjogKHQpID0+IHtcbiAgICBjb25zdCByID0gKFxuICAgICAgLyoqIEB0eXBlIHtPcHRpb25zfSAqL1xuICAgICAgdGhpcy5kYXRhKFwic2V0dGluZ3NcIilcbiAgICApO1xuICAgIHJldHVybiB2bChcbiAgICAgIHQsXG4gICAgICBPYmplY3QuYXNzaWduKHt9LCByLCBuLCB7XG4gICAgICAgIC8vIE5vdGU6IHRoZXNlIG9wdGlvbnMgYXJlIG5vdCBpbiB0aGUgcmVhZG1lLlxuICAgICAgICAvLyBUaGUgZ29hbCBpcyBmb3IgdGhlbSB0byBiZSBzZXQgYnkgcGx1Z2lucyBvbiBgZGF0YWAgaW5zdGVhZCBvZiBiZWluZ1xuICAgICAgICAvLyBwYXNzZWQgYnkgdXNlcnMuXG4gICAgICAgIGV4dGVuc2lvbnM6IHRoaXMuZGF0YShcIm1pY3JvbWFya0V4dGVuc2lvbnNcIikgfHwgW10sXG4gICAgICAgIG1kYXN0RXh0ZW5zaW9uczogdGhpcy5kYXRhKFwiZnJvbU1hcmtkb3duRXh0ZW5zaW9uc1wiKSB8fCBbXVxuICAgICAgfSlcbiAgICApO1xuICB9IH0pO1xufVxuZnVuY3Rpb24gTWwobiwgZSkge1xuICBjb25zdCB0ID0ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IFwiYmxvY2txdW90ZVwiLFxuICAgIHByb3BlcnRpZXM6IHt9LFxuICAgIGNoaWxkcmVuOiBuLndyYXAobi5hbGwoZSksICEwKVxuICB9O1xuICByZXR1cm4gbi5wYXRjaChlLCB0KSwgbi5hcHBseURhdGEoZSwgdCk7XG59XG5mdW5jdGlvbiBCbChuLCBlKSB7XG4gIGNvbnN0IHQgPSB7IHR5cGU6IFwiZWxlbWVudFwiLCB0YWdOYW1lOiBcImJyXCIsIHByb3BlcnRpZXM6IHt9LCBjaGlsZHJlbjogW10gfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgdCksIFtuLmFwcGx5RGF0YShlLCB0KSwgeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IGBcbmAgfV07XG59XG5mdW5jdGlvbiBObChuLCBlKSB7XG4gIGNvbnN0IHQgPSBlLnZhbHVlID8gZS52YWx1ZSArIGBcbmAgOiBcIlwiLCByID0gZS5sYW5nID8gZS5sYW5nLm1hdGNoKC9eW14gXFx0XSsoPz1bIFxcdF18JCkvKSA6IG51bGwsIGkgPSB7fTtcbiAgciAmJiAoaS5jbGFzc05hbWUgPSBbXCJsYW5ndWFnZS1cIiArIHJdKTtcbiAgbGV0IGwgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJjb2RlXCIsXG4gICAgcHJvcGVydGllczogaSxcbiAgICBjaGlsZHJlbjogW3sgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiB0IH1dXG4gIH07XG4gIHJldHVybiBlLm1ldGEgJiYgKGwuZGF0YSA9IHsgbWV0YTogZS5tZXRhIH0pLCBuLnBhdGNoKGUsIGwpLCBsID0gbi5hcHBseURhdGEoZSwgbCksIGwgPSB7IHR5cGU6IFwiZWxlbWVudFwiLCB0YWdOYW1lOiBcInByZVwiLCBwcm9wZXJ0aWVzOiB7fSwgY2hpbGRyZW46IFtsXSB9LCBuLnBhdGNoKGUsIGwpLCBsO1xufVxuZnVuY3Rpb24gamwobiwgZSkge1xuICBjb25zdCB0ID0ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IFwiZGVsXCIsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgY2hpbGRyZW46IG4uYWxsKGUpXG4gIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIHQpLCBuLmFwcGx5RGF0YShlLCB0KTtcbn1cbmZ1bmN0aW9uICRsKG4sIGUpIHtcbiAgY29uc3QgdCA9IHtcbiAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICB0YWdOYW1lOiBcImVtXCIsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgY2hpbGRyZW46IG4uYWxsKGUpXG4gIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIHQpLCBuLmFwcGx5RGF0YShlLCB0KTtcbn1cbmZ1bmN0aW9uIHZuKG4pIHtcbiAgY29uc3QgZSA9IFtdO1xuICBsZXQgdCA9IC0xLCByID0gMCwgaSA9IDA7XG4gIGZvciAoOyArK3QgPCBuLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgbCA9IG4uY2hhckNvZGVBdCh0KTtcbiAgICBsZXQgbyA9IFwiXCI7XG4gICAgaWYgKGwgPT09IDM3ICYmIG9uKG4uY2hhckNvZGVBdCh0ICsgMSkpICYmIG9uKG4uY2hhckNvZGVBdCh0ICsgMikpKVxuICAgICAgaSA9IDI7XG4gICAgZWxzZSBpZiAobCA8IDEyOClcbiAgICAgIC9bISMkJi07PT8tWl9hLXp+XS8udGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGwpKSB8fCAobyA9IFN0cmluZy5mcm9tQ2hhckNvZGUobCkpO1xuICAgIGVsc2UgaWYgKGwgPiA1NTI5NSAmJiBsIDwgNTczNDQpIHtcbiAgICAgIGNvbnN0IHUgPSBuLmNoYXJDb2RlQXQodCArIDEpO1xuICAgICAgbCA8IDU2MzIwICYmIHUgPiA1NjMxOSAmJiB1IDwgNTczNDQgPyAobyA9IFN0cmluZy5mcm9tQ2hhckNvZGUobCwgdSksIGkgPSAxKSA6IG8gPSBcIu+/vVwiO1xuICAgIH0gZWxzZVxuICAgICAgbyA9IFN0cmluZy5mcm9tQ2hhckNvZGUobCk7XG4gICAgbyAmJiAoZS5wdXNoKG4uc2xpY2UociwgdCksIGVuY29kZVVSSUNvbXBvbmVudChvKSksIHIgPSB0ICsgaSArIDEsIG8gPSBcIlwiKSwgaSAmJiAodCArPSBpLCBpID0gMCk7XG4gIH1cbiAgcmV0dXJuIGUuam9pbihcIlwiKSArIG4uc2xpY2Uocik7XG59XG5mdW5jdGlvbiBWdChuLCBlKSB7XG4gIGNvbnN0IHQgPSBTdHJpbmcoZS5pZGVudGlmaWVyKS50b1VwcGVyQ2FzZSgpLCByID0gdm4odC50b0xvd2VyQ2FzZSgpKSwgaSA9IG4uZm9vdG5vdGVPcmRlci5pbmRleE9mKHQpO1xuICBsZXQgbDtcbiAgaSA9PT0gLTEgPyAobi5mb290bm90ZU9yZGVyLnB1c2godCksIG4uZm9vdG5vdGVDb3VudHNbdF0gPSAxLCBsID0gbi5mb290bm90ZU9yZGVyLmxlbmd0aCkgOiAobi5mb290bm90ZUNvdW50c1t0XSsrLCBsID0gaSArIDEpO1xuICBjb25zdCBvID0gbi5mb290bm90ZUNvdW50c1t0XSwgdSA9IHtcbiAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICB0YWdOYW1lOiBcImFcIixcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBocmVmOiBcIiNcIiArIG4uY2xvYmJlclByZWZpeCArIFwiZm4tXCIgKyByLFxuICAgICAgaWQ6IG4uY2xvYmJlclByZWZpeCArIFwiZm5yZWYtXCIgKyByICsgKG8gPiAxID8gXCItXCIgKyBvIDogXCJcIiksXG4gICAgICBkYXRhRm9vdG5vdGVSZWY6ICEwLFxuICAgICAgYXJpYURlc2NyaWJlZEJ5OiBbXCJmb290bm90ZS1sYWJlbFwiXVxuICAgIH0sXG4gICAgY2hpbGRyZW46IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogU3RyaW5nKGwpIH1dXG4gIH07XG4gIG4ucGF0Y2goZSwgdSk7XG4gIGNvbnN0IGEgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJzdXBcIixcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBjaGlsZHJlbjogW3VdXG4gIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIGEpLCBuLmFwcGx5RGF0YShlLCBhKTtcbn1cbmZ1bmN0aW9uIEhsKG4sIGUpIHtcbiAgY29uc3QgdCA9IG4uZm9vdG5vdGVCeUlkO1xuICBsZXQgciA9IDE7XG4gIGZvciAoOyByIGluIHQ7IClcbiAgICByKys7XG4gIGNvbnN0IGkgPSBTdHJpbmcocik7XG4gIHJldHVybiB0W2ldID0ge1xuICAgIHR5cGU6IFwiZm9vdG5vdGVEZWZpbml0aW9uXCIsXG4gICAgaWRlbnRpZmllcjogaSxcbiAgICBjaGlsZHJlbjogW3sgdHlwZTogXCJwYXJhZ3JhcGhcIiwgY2hpbGRyZW46IGUuY2hpbGRyZW4gfV0sXG4gICAgcG9zaXRpb246IGUucG9zaXRpb25cbiAgfSwgVnQobiwge1xuICAgIHR5cGU6IFwiZm9vdG5vdGVSZWZlcmVuY2VcIixcbiAgICBpZGVudGlmaWVyOiBpLFxuICAgIHBvc2l0aW9uOiBlLnBvc2l0aW9uXG4gIH0pO1xufVxuZnVuY3Rpb24gVWwobiwgZSkge1xuICBjb25zdCB0ID0ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IFwiaFwiICsgZS5kZXB0aCxcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBjaGlsZHJlbjogbi5hbGwoZSlcbiAgfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgdCksIG4uYXBwbHlEYXRhKGUsIHQpO1xufVxuZnVuY3Rpb24gVmwobiwgZSkge1xuICBpZiAobi5kYW5nZXJvdXMpIHtcbiAgICBjb25zdCB0ID0geyB0eXBlOiBcInJhd1wiLCB2YWx1ZTogZS52YWx1ZSB9O1xuICAgIHJldHVybiBuLnBhdGNoKGUsIHQpLCBuLmFwcGx5RGF0YShlLCB0KTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHF0KG4sIGUpIHtcbiAgY29uc3QgdCA9IGUucmVmZXJlbmNlVHlwZTtcbiAgbGV0IHIgPSBcIl1cIjtcbiAgaWYgKHQgPT09IFwiY29sbGFwc2VkXCIgPyByICs9IFwiW11cIiA6IHQgPT09IFwiZnVsbFwiICYmIChyICs9IFwiW1wiICsgKGUubGFiZWwgfHwgZS5pZGVudGlmaWVyKSArIFwiXVwiKSwgZS50eXBlID09PSBcImltYWdlUmVmZXJlbmNlXCIpXG4gICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBcIiFbXCIgKyBlLmFsdCArIHIgfTtcbiAgY29uc3QgaSA9IG4uYWxsKGUpLCBsID0gaVswXTtcbiAgbCAmJiBsLnR5cGUgPT09IFwidGV4dFwiID8gbC52YWx1ZSA9IFwiW1wiICsgbC52YWx1ZSA6IGkudW5zaGlmdCh7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogXCJbXCIgfSk7XG4gIGNvbnN0IG8gPSBpW2kubGVuZ3RoIC0gMV07XG4gIHJldHVybiBvICYmIG8udHlwZSA9PT0gXCJ0ZXh0XCIgPyBvLnZhbHVlICs9IHIgOiBpLnB1c2goeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IHIgfSksIGk7XG59XG5mdW5jdGlvbiBxbChuLCBlKSB7XG4gIGNvbnN0IHQgPSBuLmRlZmluaXRpb24oZS5pZGVudGlmaWVyKTtcbiAgaWYgKCF0KVxuICAgIHJldHVybiBxdChuLCBlKTtcbiAgY29uc3QgciA9IHsgc3JjOiB2bih0LnVybCB8fCBcIlwiKSwgYWx0OiBlLmFsdCB9O1xuICB0LnRpdGxlICE9PSBudWxsICYmIHQudGl0bGUgIT09IHZvaWQgMCAmJiAoci50aXRsZSA9IHQudGl0bGUpO1xuICBjb25zdCBpID0geyB0eXBlOiBcImVsZW1lbnRcIiwgdGFnTmFtZTogXCJpbWdcIiwgcHJvcGVydGllczogciwgY2hpbGRyZW46IFtdIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIGkpLCBuLmFwcGx5RGF0YShlLCBpKTtcbn1cbmZ1bmN0aW9uIFdsKG4sIGUpIHtcbiAgY29uc3QgdCA9IHsgc3JjOiB2bihlLnVybCkgfTtcbiAgZS5hbHQgIT09IG51bGwgJiYgZS5hbHQgIT09IHZvaWQgMCAmJiAodC5hbHQgPSBlLmFsdCksIGUudGl0bGUgIT09IG51bGwgJiYgZS50aXRsZSAhPT0gdm9pZCAwICYmICh0LnRpdGxlID0gZS50aXRsZSk7XG4gIGNvbnN0IHIgPSB7IHR5cGU6IFwiZWxlbWVudFwiLCB0YWdOYW1lOiBcImltZ1wiLCBwcm9wZXJ0aWVzOiB0LCBjaGlsZHJlbjogW10gfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgciksIG4uYXBwbHlEYXRhKGUsIHIpO1xufVxuZnVuY3Rpb24gWWwobiwgZSkge1xuICBjb25zdCB0ID0geyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IGUudmFsdWUucmVwbGFjZSgvXFxyP1xcbnxcXHIvZywgXCIgXCIpIH07XG4gIG4ucGF0Y2goZSwgdCk7XG4gIGNvbnN0IHIgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJjb2RlXCIsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgY2hpbGRyZW46IFt0XVxuICB9O1xuICByZXR1cm4gbi5wYXRjaChlLCByKSwgbi5hcHBseURhdGEoZSwgcik7XG59XG5mdW5jdGlvbiBRbChuLCBlKSB7XG4gIGNvbnN0IHQgPSBuLmRlZmluaXRpb24oZS5pZGVudGlmaWVyKTtcbiAgaWYgKCF0KVxuICAgIHJldHVybiBxdChuLCBlKTtcbiAgY29uc3QgciA9IHsgaHJlZjogdm4odC51cmwgfHwgXCJcIikgfTtcbiAgdC50aXRsZSAhPT0gbnVsbCAmJiB0LnRpdGxlICE9PSB2b2lkIDAgJiYgKHIudGl0bGUgPSB0LnRpdGxlKTtcbiAgY29uc3QgaSA9IHtcbiAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICB0YWdOYW1lOiBcImFcIixcbiAgICBwcm9wZXJ0aWVzOiByLFxuICAgIGNoaWxkcmVuOiBuLmFsbChlKVxuICB9O1xuICByZXR1cm4gbi5wYXRjaChlLCBpKSwgbi5hcHBseURhdGEoZSwgaSk7XG59XG5mdW5jdGlvbiBYbChuLCBlKSB7XG4gIGNvbnN0IHQgPSB7IGhyZWY6IHZuKGUudXJsKSB9O1xuICBlLnRpdGxlICE9PSBudWxsICYmIGUudGl0bGUgIT09IHZvaWQgMCAmJiAodC50aXRsZSA9IGUudGl0bGUpO1xuICBjb25zdCByID0ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IFwiYVwiLFxuICAgIHByb3BlcnRpZXM6IHQsXG4gICAgY2hpbGRyZW46IG4uYWxsKGUpXG4gIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIHIpLCBuLmFwcGx5RGF0YShlLCByKTtcbn1cbmZ1bmN0aW9uIEtsKG4sIGUsIHQpIHtcbiAgY29uc3QgciA9IG4uYWxsKGUpLCBpID0gdCA/IEdsKHQpIDogV3QoZSksIGwgPSB7fSwgbyA9IFtdO1xuICBpZiAodHlwZW9mIGUuY2hlY2tlZCA9PSBcImJvb2xlYW5cIikge1xuICAgIGNvbnN0IHMgPSByWzBdO1xuICAgIGxldCBoO1xuICAgIHMgJiYgcy50eXBlID09PSBcImVsZW1lbnRcIiAmJiBzLnRhZ05hbWUgPT09IFwicFwiID8gaCA9IHMgOiAoaCA9IHsgdHlwZTogXCJlbGVtZW50XCIsIHRhZ05hbWU6IFwicFwiLCBwcm9wZXJ0aWVzOiB7fSwgY2hpbGRyZW46IFtdIH0sIHIudW5zaGlmdChoKSksIGguY2hpbGRyZW4ubGVuZ3RoID4gMCAmJiBoLmNoaWxkcmVuLnVuc2hpZnQoeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IFwiIFwiIH0pLCBoLmNoaWxkcmVuLnVuc2hpZnQoe1xuICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICB0YWdOYW1lOiBcImlucHV0XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7IHR5cGU6IFwiY2hlY2tib3hcIiwgY2hlY2tlZDogZS5jaGVja2VkLCBkaXNhYmxlZDogITAgfSxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH0pLCBsLmNsYXNzTmFtZSA9IFtcInRhc2stbGlzdC1pdGVtXCJdO1xuICB9XG4gIGxldCB1ID0gLTE7XG4gIGZvciAoOyArK3UgPCByLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgcyA9IHJbdV07XG4gICAgKGkgfHwgdSAhPT0gMCB8fCBzLnR5cGUgIT09IFwiZWxlbWVudFwiIHx8IHMudGFnTmFtZSAhPT0gXCJwXCIpICYmIG8ucHVzaCh7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogYFxuYCB9KSwgcy50eXBlID09PSBcImVsZW1lbnRcIiAmJiBzLnRhZ05hbWUgPT09IFwicFwiICYmICFpID8gby5wdXNoKC4uLnMuY2hpbGRyZW4pIDogby5wdXNoKHMpO1xuICB9XG4gIGNvbnN0IGEgPSByW3IubGVuZ3RoIC0gMV07XG4gIGEgJiYgKGkgfHwgYS50eXBlICE9PSBcImVsZW1lbnRcIiB8fCBhLnRhZ05hbWUgIT09IFwicFwiKSAmJiBvLnB1c2goeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IGBcbmAgfSk7XG4gIGNvbnN0IGMgPSB7IHR5cGU6IFwiZWxlbWVudFwiLCB0YWdOYW1lOiBcImxpXCIsIHByb3BlcnRpZXM6IGwsIGNoaWxkcmVuOiBvIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIGMpLCBuLmFwcGx5RGF0YShlLCBjKTtcbn1cbmZ1bmN0aW9uIEdsKG4pIHtcbiAgbGV0IGUgPSAhMTtcbiAgaWYgKG4udHlwZSA9PT0gXCJsaXN0XCIpIHtcbiAgICBlID0gbi5zcHJlYWQgfHwgITE7XG4gICAgY29uc3QgdCA9IG4uY2hpbGRyZW47XG4gICAgbGV0IHIgPSAtMTtcbiAgICBmb3IgKDsgIWUgJiYgKytyIDwgdC5sZW5ndGg7IClcbiAgICAgIGUgPSBXdCh0W3JdKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIFd0KG4pIHtcbiAgY29uc3QgZSA9IG4uc3ByZWFkO1xuICByZXR1cm4gZSA/PyBuLmNoaWxkcmVuLmxlbmd0aCA+IDE7XG59XG5mdW5jdGlvbiBabChuLCBlKSB7XG4gIGNvbnN0IHQgPSB7fSwgciA9IG4uYWxsKGUpO1xuICBsZXQgaSA9IC0xO1xuICBmb3IgKHR5cGVvZiBlLnN0YXJ0ID09IFwibnVtYmVyXCIgJiYgZS5zdGFydCAhPT0gMSAmJiAodC5zdGFydCA9IGUuc3RhcnQpOyArK2kgPCByLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgbyA9IHJbaV07XG4gICAgaWYgKG8udHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgby50YWdOYW1lID09PSBcImxpXCIgJiYgby5wcm9wZXJ0aWVzICYmIEFycmF5LmlzQXJyYXkoby5wcm9wZXJ0aWVzLmNsYXNzTmFtZSkgJiYgby5wcm9wZXJ0aWVzLmNsYXNzTmFtZS5pbmNsdWRlcyhcInRhc2stbGlzdC1pdGVtXCIpKSB7XG4gICAgICB0LmNsYXNzTmFtZSA9IFtcImNvbnRhaW5zLXRhc2stbGlzdFwiXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjb25zdCBsID0ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IGUub3JkZXJlZCA/IFwib2xcIiA6IFwidWxcIixcbiAgICBwcm9wZXJ0aWVzOiB0LFxuICAgIGNoaWxkcmVuOiBuLndyYXAociwgITApXG4gIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIGwpLCBuLmFwcGx5RGF0YShlLCBsKTtcbn1cbmZ1bmN0aW9uIEpsKG4sIGUpIHtcbiAgY29uc3QgdCA9IHtcbiAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICB0YWdOYW1lOiBcInBcIixcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBjaGlsZHJlbjogbi5hbGwoZSlcbiAgfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgdCksIG4uYXBwbHlEYXRhKGUsIHQpO1xufVxuZnVuY3Rpb24gbm8obiwgZSkge1xuICBjb25zdCB0ID0geyB0eXBlOiBcInJvb3RcIiwgY2hpbGRyZW46IG4ud3JhcChuLmFsbChlKSkgfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgdCksIG4uYXBwbHlEYXRhKGUsIHQpO1xufVxuZnVuY3Rpb24gZW8obiwgZSkge1xuICBjb25zdCB0ID0ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IFwic3Ryb25nXCIsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgY2hpbGRyZW46IG4uYWxsKGUpXG4gIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIHQpLCBuLmFwcGx5RGF0YShlLCB0KTtcbn1cbmNvbnN0IEZlID0gWXQoXCJzdGFydFwiKSwgVGUgPSBZdChcImVuZFwiKTtcbmZ1bmN0aW9uIHRvKG4pIHtcbiAgcmV0dXJuIHsgc3RhcnQ6IEZlKG4pLCBlbmQ6IFRlKG4pIH07XG59XG5mdW5jdGlvbiBZdChuKSB7XG4gIHJldHVybiBlO1xuICBmdW5jdGlvbiBlKHQpIHtcbiAgICBjb25zdCByID0gdCAmJiB0LnBvc2l0aW9uICYmIHQucG9zaXRpb25bbl0gfHwge307XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGluIHByYWN0aWNlLCBudWxsIGlzIGFsbG93ZWQuXG4gICAgICBsaW5lOiByLmxpbmUgfHwgbnVsbCxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGluIHByYWN0aWNlLCBudWxsIGlzIGFsbG93ZWQuXG4gICAgICBjb2x1bW46IHIuY29sdW1uIHx8IG51bGwsXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbiBwcmFjdGljZSwgbnVsbCBpcyBhbGxvd2VkLlxuICAgICAgb2Zmc2V0OiByLm9mZnNldCA+IC0xID8gci5vZmZzZXQgOiBudWxsXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcm8obiwgZSkge1xuICBjb25zdCB0ID0gbi5hbGwoZSksIHIgPSB0LnNoaWZ0KCksIGkgPSBbXTtcbiAgaWYgKHIpIHtcbiAgICBjb25zdCBvID0ge1xuICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICB0YWdOYW1lOiBcInRoZWFkXCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgIGNoaWxkcmVuOiBuLndyYXAoW3JdLCAhMClcbiAgICB9O1xuICAgIG4ucGF0Y2goZS5jaGlsZHJlblswXSwgbyksIGkucHVzaChvKTtcbiAgfVxuICBpZiAodC5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgdGFnTmFtZTogXCJ0Ym9keVwiLFxuICAgICAgcHJvcGVydGllczoge30sXG4gICAgICBjaGlsZHJlbjogbi53cmFwKHQsICEwKVxuICAgIH0sIHUgPSBGZShlLmNoaWxkcmVuWzFdKSwgYSA9IFRlKGUuY2hpbGRyZW5bZS5jaGlsZHJlbi5sZW5ndGggLSAxXSk7XG4gICAgdS5saW5lICYmIGEubGluZSAmJiAoby5wb3NpdGlvbiA9IHsgc3RhcnQ6IHUsIGVuZDogYSB9KSwgaS5wdXNoKG8pO1xuICB9XG4gIGNvbnN0IGwgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJ0YWJsZVwiLFxuICAgIHByb3BlcnRpZXM6IHt9LFxuICAgIGNoaWxkcmVuOiBuLndyYXAoaSwgITApXG4gIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIGwpLCBuLmFwcGx5RGF0YShlLCBsKTtcbn1cbmZ1bmN0aW9uIGlvKG4sIGUsIHQpIHtcbiAgY29uc3QgciA9IHQgPyB0LmNoaWxkcmVuIDogdm9pZCAwLCBsID0gKHIgPyByLmluZGV4T2YoZSkgOiAxKSA9PT0gMCA/IFwidGhcIiA6IFwidGRcIiwgbyA9IHQgJiYgdC50eXBlID09PSBcInRhYmxlXCIgPyB0LmFsaWduIDogdm9pZCAwLCB1ID0gbyA/IG8ubGVuZ3RoIDogZS5jaGlsZHJlbi5sZW5ndGg7XG4gIGxldCBhID0gLTE7XG4gIGNvbnN0IGMgPSBbXTtcbiAgZm9yICg7ICsrYSA8IHU7ICkge1xuICAgIGNvbnN0IGggPSBlLmNoaWxkcmVuW2FdLCBnID0ge30sIGQgPSBvID8gb1thXSA6IHZvaWQgMDtcbiAgICBkICYmIChnLmFsaWduID0gZCk7XG4gICAgbGV0IG0gPSB7IHR5cGU6IFwiZWxlbWVudFwiLCB0YWdOYW1lOiBsLCBwcm9wZXJ0aWVzOiBnLCBjaGlsZHJlbjogW10gfTtcbiAgICBoICYmIChtLmNoaWxkcmVuID0gbi5hbGwoaCksIG4ucGF0Y2goaCwgbSksIG0gPSBuLmFwcGx5RGF0YShlLCBtKSksIGMucHVzaChtKTtcbiAgfVxuICBjb25zdCBzID0ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IFwidHJcIixcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBjaGlsZHJlbjogbi53cmFwKGMsICEwKVxuICB9O1xuICByZXR1cm4gbi5wYXRjaChlLCBzKSwgbi5hcHBseURhdGEoZSwgcyk7XG59XG5mdW5jdGlvbiBsbyhuLCBlKSB7XG4gIGNvbnN0IHQgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJ0ZFwiLFxuICAgIC8vIEFzc3VtZSBib2R5IGNlbGwuXG4gICAgcHJvcGVydGllczoge30sXG4gICAgY2hpbGRyZW46IG4uYWxsKGUpXG4gIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIHQpLCBuLmFwcGx5RGF0YShlLCB0KTtcbn1cbmNvbnN0IHN0ID0gOSwgY3QgPSAzMjtcbmZ1bmN0aW9uIG9vKG4pIHtcbiAgY29uc3QgZSA9IFN0cmluZyhuKSwgdCA9IC9cXHI/XFxufFxcci9nO1xuICBsZXQgciA9IHQuZXhlYyhlKSwgaSA9IDA7XG4gIGNvbnN0IGwgPSBbXTtcbiAgZm9yICg7IHI7IClcbiAgICBsLnB1c2goXG4gICAgICBwdChlLnNsaWNlKGksIHIuaW5kZXgpLCBpID4gMCwgITApLFxuICAgICAgclswXVxuICAgICksIGkgPSByLmluZGV4ICsgclswXS5sZW5ndGgsIHIgPSB0LmV4ZWMoZSk7XG4gIHJldHVybiBsLnB1c2gocHQoZS5zbGljZShpKSwgaSA+IDAsICExKSksIGwuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIHB0KG4sIGUsIHQpIHtcbiAgbGV0IHIgPSAwLCBpID0gbi5sZW5ndGg7XG4gIGlmIChlKSB7XG4gICAgbGV0IGwgPSBuLmNvZGVQb2ludEF0KHIpO1xuICAgIGZvciAoOyBsID09PSBzdCB8fCBsID09PSBjdDsgKVxuICAgICAgcisrLCBsID0gbi5jb2RlUG9pbnRBdChyKTtcbiAgfVxuICBpZiAodCkge1xuICAgIGxldCBsID0gbi5jb2RlUG9pbnRBdChpIC0gMSk7XG4gICAgZm9yICg7IGwgPT09IHN0IHx8IGwgPT09IGN0OyApXG4gICAgICBpLS0sIGwgPSBuLmNvZGVQb2ludEF0KGkgLSAxKTtcbiAgfVxuICByZXR1cm4gaSA+IHIgPyBuLnNsaWNlKHIsIGkpIDogXCJcIjtcbn1cbmZ1bmN0aW9uIHVvKG4sIGUpIHtcbiAgY29uc3QgdCA9IHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBvbyhTdHJpbmcoZS52YWx1ZSkpIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIHQpLCBuLmFwcGx5RGF0YShlLCB0KTtcbn1cbmZ1bmN0aW9uIGFvKG4sIGUpIHtcbiAgY29uc3QgdCA9IHtcbiAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICB0YWdOYW1lOiBcImhyXCIsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgY2hpbGRyZW46IFtdXG4gIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIHQpLCBuLmFwcGx5RGF0YShlLCB0KTtcbn1cbmNvbnN0IHNvID0ge1xuICBibG9ja3F1b3RlOiBNbCxcbiAgYnJlYWs6IEJsLFxuICBjb2RlOiBObCxcbiAgZGVsZXRlOiBqbCxcbiAgZW1waGFzaXM6ICRsLFxuICBmb290bm90ZVJlZmVyZW5jZTogVnQsXG4gIGZvb3Rub3RlOiBIbCxcbiAgaGVhZGluZzogVWwsXG4gIGh0bWw6IFZsLFxuICBpbWFnZVJlZmVyZW5jZTogcWwsXG4gIGltYWdlOiBXbCxcbiAgaW5saW5lQ29kZTogWWwsXG4gIGxpbmtSZWZlcmVuY2U6IFFsLFxuICBsaW5rOiBYbCxcbiAgbGlzdEl0ZW06IEtsLFxuICBsaXN0OiBabCxcbiAgcGFyYWdyYXBoOiBKbCxcbiAgcm9vdDogbm8sXG4gIHN0cm9uZzogZW8sXG4gIHRhYmxlOiBybyxcbiAgdGFibGVDZWxsOiBsbyxcbiAgdGFibGVSb3c6IGlvLFxuICB0ZXh0OiB1byxcbiAgdGhlbWF0aWNCcmVhazogYW8sXG4gIHRvbWw6IHFuLFxuICB5YW1sOiBxbixcbiAgZGVmaW5pdGlvbjogcW4sXG4gIGZvb3Rub3RlRGVmaW5pdGlvbjogcW5cbn07XG5mdW5jdGlvbiBxbigpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBRdCA9IChcbiAgLyoqXG4gICAqIEB0eXBlIHsoXG4gICAqICAgKDxLaW5kIGV4dGVuZHMgTm9kZT4odGVzdDogUHJlZGljYXRlVGVzdDxLaW5kPikgPT4gQXNzZXJ0UHJlZGljYXRlPEtpbmQ+KSAmXG4gICAqICAgKCh0ZXN0PzogVGVzdCkgPT4gQXNzZXJ0QW55dGhpbmcpXG4gICAqICl9XG4gICAqL1xuICAvKipcbiAgICogQHBhcmFtIHtUZXN0fSBbdGVzdF1cbiAgICogQHJldHVybnMge0Fzc2VydEFueXRoaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24obikge1xuICAgIGlmIChuID09IG51bGwpXG4gICAgICByZXR1cm4gaG87XG4gICAgaWYgKHR5cGVvZiBuID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gZm8obik7XG4gICAgaWYgKHR5cGVvZiBuID09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShuKSA/IGNvKG4pIDogcG8obik7XG4gICAgaWYgKHR5cGVvZiBuID09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybiBKbihuKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBmdW5jdGlvbiwgc3RyaW5nLCBvciBvYmplY3QgYXMgdGVzdFwiKTtcbiAgfVxuKTtcbmZ1bmN0aW9uIGNvKG4pIHtcbiAgY29uc3QgZSA9IFtdO1xuICBsZXQgdCA9IC0xO1xuICBmb3IgKDsgKyt0IDwgbi5sZW5ndGg7IClcbiAgICBlW3RdID0gUXQoblt0XSk7XG4gIHJldHVybiBKbihyKTtcbiAgZnVuY3Rpb24gciguLi5pKSB7XG4gICAgbGV0IGwgPSAtMTtcbiAgICBmb3IgKDsgKytsIDwgZS5sZW5ndGg7IClcbiAgICAgIGlmIChlW2xdLmNhbGwodGhpcywgLi4uaSkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIHBvKG4pIHtcbiAgcmV0dXJuIEpuKGUpO1xuICBmdW5jdGlvbiBlKHQpIHtcbiAgICBsZXQgcjtcbiAgICBmb3IgKHIgaW4gbilcbiAgICAgIGlmICh0W3JdICE9PSBuW3JdKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgcmV0dXJuICEwO1xuICB9XG59XG5mdW5jdGlvbiBmbyhuKSB7XG4gIHJldHVybiBKbihlKTtcbiAgZnVuY3Rpb24gZSh0KSB7XG4gICAgcmV0dXJuIHQgJiYgdC50eXBlID09PSBuO1xuICB9XG59XG5mdW5jdGlvbiBKbihuKSB7XG4gIHJldHVybiBlO1xuICBmdW5jdGlvbiBlKHQsIC4uLnIpIHtcbiAgICByZXR1cm4gISEodCAmJiB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIFwidHlwZVwiIGluIHQgJiYgbi5jYWxsKHRoaXMsIHQsIC4uLnIpKTtcbiAgfVxufVxuZnVuY3Rpb24gaG8oKSB7XG4gIHJldHVybiAhMDtcbn1cbmNvbnN0IG1vID0gITAsIGZ0ID0gITEsIGdvID0gXCJza2lwXCIsIHlvID0gKFxuICAvKipcbiAgICogQHR5cGUgeyhcbiAgICogICAoPFRyZWUgZXh0ZW5kcyBOb2RlLCBDaGVjayBleHRlbmRzIFRlc3Q+KHRyZWU6IFRyZWUsIHRlc3Q6IENoZWNrLCB2aXNpdG9yOiBCdWlsZFZpc2l0b3I8VHJlZSwgQ2hlY2s+LCByZXZlcnNlPzogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQpID0+IHZvaWQpICZcbiAgICogICAoPFRyZWUgZXh0ZW5kcyBOb2RlPih0cmVlOiBUcmVlLCB2aXNpdG9yOiBCdWlsZFZpc2l0b3I8VHJlZT4sIHJldmVyc2U/OiBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gdm9pZClcbiAgICogKX1cbiAgICovXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IHRyZWVcbiAgICogQHBhcmFtIHtUZXN0fSB0ZXN0XG4gICAqIEBwYXJhbSB7VmlzaXRvcjxOb2RlPn0gdmlzaXRvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbcmV2ZXJzZV1cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbihuLCBlLCB0LCByKSB7XG4gICAgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB0ICE9IFwiZnVuY3Rpb25cIiAmJiAociA9IHQsIHQgPSBlLCBlID0gbnVsbCk7XG4gICAgY29uc3QgaSA9IFF0KGUpLCBsID0gciA/IC0xIDogMTtcbiAgICBvKG4sIHZvaWQgMCwgW10pKCk7XG4gICAgZnVuY3Rpb24gbyh1LCBhLCBjKSB7XG4gICAgICBjb25zdCBzID0gdSAmJiB0eXBlb2YgdSA9PSBcIm9iamVjdFwiID8gdSA6IHt9O1xuICAgICAgaWYgKHR5cGVvZiBzLnR5cGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBnID0gKFxuICAgICAgICAgIC8vIGBoYXN0YFxuICAgICAgICAgIHR5cGVvZiBzLnRhZ05hbWUgPT0gXCJzdHJpbmdcIiA/IHMudGFnTmFtZSA6IChcbiAgICAgICAgICAgIC8vIGB4YXN0YFxuICAgICAgICAgICAgdHlwZW9mIHMubmFtZSA9PSBcInN0cmluZ1wiID8gcy5uYW1lIDogdm9pZCAwXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaCwgXCJuYW1lXCIsIHtcbiAgICAgICAgICB2YWx1ZTogXCJub2RlIChcIiArICh1LnR5cGUgKyAoZyA/IFwiPFwiICsgZyArIFwiPlwiIDogXCJcIikpICsgXCIpXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaDtcbiAgICAgIGZ1bmN0aW9uIGgoKSB7XG4gICAgICAgIGxldCBnID0gW10sIGQsIG0sIHk7XG4gICAgICAgIGlmICgoIWUgfHwgaSh1LCBhLCBjW2MubGVuZ3RoIC0gMV0gfHwgbnVsbCkpICYmIChnID0geG8odCh1LCBjKSksIGdbMF0gPT09IGZ0KSlcbiAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgaWYgKHUuY2hpbGRyZW4gJiYgZ1swXSAhPT0gZ28pXG4gICAgICAgICAgZm9yIChtID0gKHIgPyB1LmNoaWxkcmVuLmxlbmd0aCA6IC0xKSArIGwsIHkgPSBjLmNvbmNhdCh1KTsgbSA+IC0xICYmIG0gPCB1LmNoaWxkcmVuLmxlbmd0aDsgKSB7XG4gICAgICAgICAgICBpZiAoZCA9IG8odS5jaGlsZHJlblttXSwgbSwgeSkoKSwgZFswXSA9PT0gZnQpXG4gICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgbSA9IHR5cGVvZiBkWzFdID09IFwibnVtYmVyXCIgPyBkWzFdIDogbSArIGw7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbik7XG5mdW5jdGlvbiB4byhuKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG4pID8gbiA6IHR5cGVvZiBuID09IFwibnVtYmVyXCIgPyBbbW8sIG5dIDogW25dO1xufVxuY29uc3QgWHQgPSAoXG4gIC8qKlxuICAgKiBAdHlwZSB7KFxuICAgKiAgICg8VHJlZSBleHRlbmRzIE5vZGUsIENoZWNrIGV4dGVuZHMgVGVzdD4odHJlZTogVHJlZSwgdGVzdDogQ2hlY2ssIHZpc2l0b3I6IEJ1aWxkVmlzaXRvcjxUcmVlLCBDaGVjaz4sIHJldmVyc2U/OiBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gdm9pZCkgJlxuICAgKiAgICg8VHJlZSBleHRlbmRzIE5vZGU+KHRyZWU6IFRyZWUsIHZpc2l0b3I6IEJ1aWxkVmlzaXRvcjxUcmVlPiwgcmV2ZXJzZT86IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB2b2lkKVxuICAgKiApfVxuICAgKi9cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdHJlZVxuICAgKiBAcGFyYW0ge1Rlc3R9IHRlc3RcbiAgICogQHBhcmFtIHtWaXNpdG9yfSB2aXNpdG9yXG4gICAqIEBwYXJhbSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtyZXZlcnNlXVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uKG4sIGUsIHQsIHIpIHtcbiAgICB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiICYmIChyID0gdCwgdCA9IGUsIGUgPSBudWxsKSwgeW8obiwgZSwgaSwgcik7XG4gICAgZnVuY3Rpb24gaShsLCBvKSB7XG4gICAgICBjb25zdCB1ID0gb1tvLmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIHQoXG4gICAgICAgIGwsXG4gICAgICAgIHUgPyB1LmNoaWxkcmVuLmluZGV4T2YobCkgOiBudWxsLFxuICAgICAgICB1XG4gICAgICApO1xuICAgIH1cbiAgfVxuKTtcbmZ1bmN0aW9uIGtvKG4pIHtcbiAgcmV0dXJuICFuIHx8ICFuLnBvc2l0aW9uIHx8ICFuLnBvc2l0aW9uLnN0YXJ0IHx8ICFuLnBvc2l0aW9uLnN0YXJ0LmxpbmUgfHwgIW4ucG9zaXRpb24uc3RhcnQuY29sdW1uIHx8ICFuLnBvc2l0aW9uLmVuZCB8fCAhbi5wb3NpdGlvbi5lbmQubGluZSB8fCAhbi5wb3NpdGlvbi5lbmQuY29sdW1uO1xufVxuY29uc3QgaHQgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIGJvKG4pIHtcbiAgY29uc3QgZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIW4gfHwgIW4udHlwZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZGFzdC11dGlsLWRlZmluaXRpb25zIGV4cGVjdGVkIG5vZGVcIik7XG4gIHJldHVybiBYdChuLCBcImRlZmluaXRpb25cIiwgKHIpID0+IHtcbiAgICBjb25zdCBpID0gbXQoci5pZGVudGlmaWVyKTtcbiAgICBpICYmICFodC5jYWxsKGUsIGkpICYmIChlW2ldID0gcik7XG4gIH0pLCB0O1xuICBmdW5jdGlvbiB0KHIpIHtcbiAgICBjb25zdCBpID0gbXQocik7XG4gICAgcmV0dXJuIGkgJiYgaHQuY2FsbChlLCBpKSA/IGVbaV0gOiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBtdChuKSB7XG4gIHJldHVybiBTdHJpbmcobiB8fCBcIlwiKS50b1VwcGVyQ2FzZSgpO1xufVxuY29uc3QgS24gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIHdvKG4sIGUpIHtcbiAgY29uc3QgdCA9IGUgfHwge30sIHIgPSB0LmFsbG93RGFuZ2Vyb3VzSHRtbCB8fCAhMSwgaSA9IHt9O1xuICByZXR1cm4gby5kYW5nZXJvdXMgPSByLCBvLmNsb2JiZXJQcmVmaXggPSB0LmNsb2JiZXJQcmVmaXggPT09IHZvaWQgMCB8fCB0LmNsb2JiZXJQcmVmaXggPT09IG51bGwgPyBcInVzZXItY29udGVudC1cIiA6IHQuY2xvYmJlclByZWZpeCwgby5mb290bm90ZUxhYmVsID0gdC5mb290bm90ZUxhYmVsIHx8IFwiRm9vdG5vdGVzXCIsIG8uZm9vdG5vdGVMYWJlbFRhZ05hbWUgPSB0LmZvb3Rub3RlTGFiZWxUYWdOYW1lIHx8IFwiaDJcIiwgby5mb290bm90ZUxhYmVsUHJvcGVydGllcyA9IHQuZm9vdG5vdGVMYWJlbFByb3BlcnRpZXMgfHwge1xuICAgIGNsYXNzTmFtZTogW1wic3Itb25seVwiXVxuICB9LCBvLmZvb3Rub3RlQmFja0xhYmVsID0gdC5mb290bm90ZUJhY2tMYWJlbCB8fCBcIkJhY2sgdG8gY29udGVudFwiLCBvLnVua25vd25IYW5kbGVyID0gdC51bmtub3duSGFuZGxlciwgby5wYXNzVGhyb3VnaCA9IHQucGFzc1Rocm91Z2gsIG8uaGFuZGxlcnMgPSB7IC4uLnNvLCAuLi50LmhhbmRsZXJzIH0sIG8uZGVmaW5pdGlvbiA9IGJvKG4pLCBvLmZvb3Rub3RlQnlJZCA9IGksIG8uZm9vdG5vdGVPcmRlciA9IFtdLCBvLmZvb3Rub3RlQ291bnRzID0ge30sIG8ucGF0Y2ggPSBTbywgby5hcHBseURhdGEgPSBFbywgby5vbmUgPSB1LCBvLmFsbCA9IGEsIG8ud3JhcCA9IEFvLCBvLmF1Z21lbnQgPSBsLCBYdChuLCBcImZvb3Rub3RlRGVmaW5pdGlvblwiLCAoYykgPT4ge1xuICAgIGNvbnN0IHMgPSBTdHJpbmcoYy5pZGVudGlmaWVyKS50b1VwcGVyQ2FzZSgpO1xuICAgIEtuLmNhbGwoaSwgcykgfHwgKGlbc10gPSBjKTtcbiAgfSksIG87XG4gIGZ1bmN0aW9uIGwoYywgcykge1xuICAgIGlmIChjICYmIFwiZGF0YVwiIGluIGMgJiYgYy5kYXRhKSB7XG4gICAgICBjb25zdCBoID0gYy5kYXRhO1xuICAgICAgaC5oTmFtZSAmJiAocy50eXBlICE9PSBcImVsZW1lbnRcIiAmJiAocyA9IHtcbiAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgIHRhZ05hbWU6IFwiXCIsXG4gICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICAgIH0pLCBzLnRhZ05hbWUgPSBoLmhOYW1lKSwgcy50eXBlID09PSBcImVsZW1lbnRcIiAmJiBoLmhQcm9wZXJ0aWVzICYmIChzLnByb3BlcnRpZXMgPSB7IC4uLnMucHJvcGVydGllcywgLi4uaC5oUHJvcGVydGllcyB9KSwgXCJjaGlsZHJlblwiIGluIHMgJiYgcy5jaGlsZHJlbiAmJiBoLmhDaGlsZHJlbiAmJiAocy5jaGlsZHJlbiA9IGguaENoaWxkcmVuKTtcbiAgICB9XG4gICAgaWYgKGMpIHtcbiAgICAgIGNvbnN0IGggPSBcInR5cGVcIiBpbiBjID8gYyA6IHsgcG9zaXRpb246IGMgfTtcbiAgICAgIGtvKGgpIHx8IChzLnBvc2l0aW9uID0geyBzdGFydDogRmUoaCksIGVuZDogVGUoaCkgfSk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG4gIGZ1bmN0aW9uIG8oYywgcywgaCwgZykge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGgpICYmIChnID0gaCwgaCA9IHt9KSwgbChjLCB7XG4gICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgIHRhZ05hbWU6IHMsXG4gICAgICBwcm9wZXJ0aWVzOiBoIHx8IHt9LFxuICAgICAgY2hpbGRyZW46IGcgfHwgW11cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB1KGMsIHMpIHtcbiAgICByZXR1cm4gS3QobywgYywgcyk7XG4gIH1cbiAgZnVuY3Rpb24gYShjKSB7XG4gICAgcmV0dXJuIEllKG8sIGMpO1xuICB9XG59XG5mdW5jdGlvbiBTbyhuLCBlKSB7XG4gIG4ucG9zaXRpb24gJiYgKGUucG9zaXRpb24gPSB0byhuKSk7XG59XG5mdW5jdGlvbiBFbyhuLCBlKSB7XG4gIGxldCB0ID0gZTtcbiAgaWYgKG4gJiYgbi5kYXRhKSB7XG4gICAgY29uc3QgciA9IG4uZGF0YS5oTmFtZSwgaSA9IG4uZGF0YS5oQ2hpbGRyZW4sIGwgPSBuLmRhdGEuaFByb3BlcnRpZXM7XG4gICAgdHlwZW9mIHIgPT0gXCJzdHJpbmdcIiAmJiAodC50eXBlID09PSBcImVsZW1lbnRcIiA/IHQudGFnTmFtZSA9IHIgOiB0ID0ge1xuICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICB0YWdOYW1lOiByLFxuICAgICAgcHJvcGVydGllczoge30sXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9KSwgdC50eXBlID09PSBcImVsZW1lbnRcIiAmJiBsICYmICh0LnByb3BlcnRpZXMgPSB7IC4uLnQucHJvcGVydGllcywgLi4ubCB9KSwgXCJjaGlsZHJlblwiIGluIHQgJiYgdC5jaGlsZHJlbiAmJiBpICE9PSBudWxsICYmIGkgIT09IHZvaWQgMCAmJiAodC5jaGlsZHJlbiA9IGkpO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gS3QobiwgZSwgdCkge1xuICBjb25zdCByID0gZSAmJiBlLnR5cGU7XG4gIGlmICghcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBub2RlLCBnb3QgYFwiICsgZSArIFwiYFwiKTtcbiAgcmV0dXJuIEtuLmNhbGwobi5oYW5kbGVycywgcikgPyBuLmhhbmRsZXJzW3JdKG4sIGUsIHQpIDogbi5wYXNzVGhyb3VnaCAmJiBuLnBhc3NUaHJvdWdoLmluY2x1ZGVzKHIpID8gXCJjaGlsZHJlblwiIGluIGUgPyB7IC4uLmUsIGNoaWxkcmVuOiBJZShuLCBlKSB9IDogZSA6IG4udW5rbm93bkhhbmRsZXIgPyBuLnVua25vd25IYW5kbGVyKG4sIGUsIHQpIDogQ28obiwgZSk7XG59XG5mdW5jdGlvbiBJZShuLCBlKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgaWYgKFwiY2hpbGRyZW5cIiBpbiBlKSB7XG4gICAgY29uc3QgciA9IGUuY2hpbGRyZW47XG4gICAgbGV0IGkgPSAtMTtcbiAgICBmb3IgKDsgKytpIDwgci5sZW5ndGg7ICkge1xuICAgICAgY29uc3QgbCA9IEt0KG4sIHJbaV0sIGUpO1xuICAgICAgaWYgKGwpIHtcbiAgICAgICAgaWYgKGkgJiYgcltpIC0gMV0udHlwZSA9PT0gXCJicmVha1wiICYmICghQXJyYXkuaXNBcnJheShsKSAmJiBsLnR5cGUgPT09IFwidGV4dFwiICYmIChsLnZhbHVlID0gbC52YWx1ZS5yZXBsYWNlKC9eXFxzKy8sIFwiXCIpKSwgIUFycmF5LmlzQXJyYXkobCkgJiYgbC50eXBlID09PSBcImVsZW1lbnRcIikpIHtcbiAgICAgICAgICBjb25zdCBvID0gbC5jaGlsZHJlblswXTtcbiAgICAgICAgICBvICYmIG8udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgKG8udmFsdWUgPSBvLnZhbHVlLnJlcGxhY2UoL15cXHMrLywgXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIEFycmF5LmlzQXJyYXkobCkgPyB0LnB1c2goLi4ubCkgOiB0LnB1c2gobCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gQ28obiwgZSkge1xuICBjb25zdCB0ID0gZS5kYXRhIHx8IHt9LCByID0gXCJ2YWx1ZVwiIGluIGUgJiYgIShLbi5jYWxsKHQsIFwiaFByb3BlcnRpZXNcIikgfHwgS24uY2FsbCh0LCBcImhDaGlsZHJlblwiKSkgPyB7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogZS52YWx1ZSB9IDoge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IFwiZGl2XCIsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgY2hpbGRyZW46IEllKG4sIGUpXG4gIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIHIpLCBuLmFwcGx5RGF0YShlLCByKTtcbn1cbmZ1bmN0aW9uIEFvKG4sIGUpIHtcbiAgY29uc3QgdCA9IFtdO1xuICBsZXQgciA9IC0xO1xuICBmb3IgKGUgJiYgdC5wdXNoKHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBgXG5gIH0pOyArK3IgPCBuLmxlbmd0aDsgKVxuICAgIHIgJiYgdC5wdXNoKHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBgXG5gIH0pLCB0LnB1c2gobltyXSk7XG4gIHJldHVybiBlICYmIG4ubGVuZ3RoID4gMCAmJiB0LnB1c2goeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IGBcbmAgfSksIHQ7XG59XG5mdW5jdGlvbiBQbyhuKSB7XG4gIGNvbnN0IGUgPSBbXTtcbiAgbGV0IHQgPSAtMTtcbiAgZm9yICg7ICsrdCA8IG4uZm9vdG5vdGVPcmRlci5sZW5ndGg7ICkge1xuICAgIGNvbnN0IHIgPSBuLmZvb3Rub3RlQnlJZFtuLmZvb3Rub3RlT3JkZXJbdF1dO1xuICAgIGlmICghcilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGkgPSBuLmFsbChyKSwgbCA9IFN0cmluZyhyLmlkZW50aWZpZXIpLnRvVXBwZXJDYXNlKCksIG8gPSB2bihsLnRvTG93ZXJDYXNlKCkpO1xuICAgIGxldCB1ID0gMDtcbiAgICBjb25zdCBhID0gW107XG4gICAgZm9yICg7ICsrdSA8PSBuLmZvb3Rub3RlQ291bnRzW2xdOyApIHtcbiAgICAgIGNvbnN0IGggPSB7XG4gICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICB0YWdOYW1lOiBcImFcIixcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIGhyZWY6IFwiI1wiICsgbi5jbG9iYmVyUHJlZml4ICsgXCJmbnJlZi1cIiArIG8gKyAodSA+IDEgPyBcIi1cIiArIHUgOiBcIlwiKSxcbiAgICAgICAgICBkYXRhRm9vdG5vdGVCYWNrcmVmOiAhMCxcbiAgICAgICAgICBjbGFzc05hbWU6IFtcImRhdGEtZm9vdG5vdGUtYmFja3JlZlwiXSxcbiAgICAgICAgICBhcmlhTGFiZWw6IG4uZm9vdG5vdGVCYWNrTGFiZWxcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogXCLihqlcIiB9XVxuICAgICAgfTtcbiAgICAgIHUgPiAxICYmIGguY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICB0YWdOYW1lOiBcInN1cFwiLFxuICAgICAgICBjaGlsZHJlbjogW3sgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBTdHJpbmcodSkgfV1cbiAgICAgIH0pLCBhLmxlbmd0aCA+IDAgJiYgYS5wdXNoKHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBcIiBcIiB9KSwgYS5wdXNoKGgpO1xuICAgIH1cbiAgICBjb25zdCBjID0gaVtpLmxlbmd0aCAtIDFdO1xuICAgIGlmIChjICYmIGMudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgYy50YWdOYW1lID09PSBcInBcIikge1xuICAgICAgY29uc3QgaCA9IGMuY2hpbGRyZW5bYy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIGggJiYgaC50eXBlID09PSBcInRleHRcIiA/IGgudmFsdWUgKz0gXCIgXCIgOiBjLmNoaWxkcmVuLnB1c2goeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IFwiIFwiIH0pLCBjLmNoaWxkcmVuLnB1c2goLi4uYSk7XG4gICAgfSBlbHNlXG4gICAgICBpLnB1c2goLi4uYSk7XG4gICAgY29uc3QgcyA9IHtcbiAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgdGFnTmFtZTogXCJsaVwiLFxuICAgICAgcHJvcGVydGllczogeyBpZDogbi5jbG9iYmVyUHJlZml4ICsgXCJmbi1cIiArIG8gfSxcbiAgICAgIGNoaWxkcmVuOiBuLndyYXAoaSwgITApXG4gICAgfTtcbiAgICBuLnBhdGNoKHIsIHMpLCBlLnB1c2gocyk7XG4gIH1cbiAgaWYgKGUubGVuZ3RoICE9PSAwKVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgIHRhZ05hbWU6IFwic2VjdGlvblwiLFxuICAgICAgcHJvcGVydGllczogeyBkYXRhRm9vdG5vdGVzOiAhMCwgY2xhc3NOYW1lOiBbXCJmb290bm90ZXNcIl0gfSxcbiAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgICAgICB0YWdOYW1lOiBuLmZvb3Rub3RlTGFiZWxUYWdOYW1lLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIC8vIFRvIGRvOiB1c2Ugc3RydWN0dXJlZCBjbG9uZS5cbiAgICAgICAgICAgIC4uLkpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobi5mb290bm90ZUxhYmVsUHJvcGVydGllcykpLFxuICAgICAgICAgICAgaWQ6IFwiZm9vdG5vdGUtbGFiZWxcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hpbGRyZW46IFt7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogbi5mb290bm90ZUxhYmVsIH1dXG4gICAgICAgIH0sXG4gICAgICAgIHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBgXG5gIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgICAgICB0YWdOYW1lOiBcIm9sXCIsXG4gICAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgICAgICAgY2hpbGRyZW46IG4ud3JhcChlLCAhMClcbiAgICAgICAgfSxcbiAgICAgICAgeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IGBcbmAgfVxuICAgICAgXVxuICAgIH07XG59XG5mdW5jdGlvbiBHdChuLCBlKSB7XG4gIGNvbnN0IHQgPSB3byhuLCBlKSwgciA9IHQub25lKG4sIG51bGwpLCBpID0gUG8odCk7XG4gIHJldHVybiBpICYmIHIuY2hpbGRyZW4ucHVzaCh7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogYFxuYCB9LCBpKSwgQXJyYXkuaXNBcnJheShyKSA/IHsgdHlwZTogXCJyb290XCIsIGNoaWxkcmVuOiByIH0gOiByO1xufVxuY29uc3QgRm8gPSAoXG4gIC8qKiBAdHlwZSB7KGltcG9ydCgndW5pZmllZCcpLlBsdWdpbjxbUHJvY2Vzc29yLCBPcHRpb25zP118W251bGx8dW5kZWZpbmVkLCBPcHRpb25zP118W09wdGlvbnNdfFtdLCBNZGFzdFJvb3Q+KX0gKi9cbiAgZnVuY3Rpb24obiwgZSkge1xuICAgIHJldHVybiBuICYmIFwicnVuXCIgaW4gbiA/IElvKG4sIGUpIDogT28obiB8fCBlKTtcbiAgfVxuKSwgVG8gPSBGbztcbmZ1bmN0aW9uIElvKG4sIGUpIHtcbiAgcmV0dXJuICh0LCByLCBpKSA9PiB7XG4gICAgbi5ydW4oR3QodCwgZSksIHIsIChsKSA9PiB7XG4gICAgICBpKGwpO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gT28obikge1xuICByZXR1cm4gKGUpID0+IEd0KGUsIG4pO1xufVxuY2xhc3MgVW4ge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7UHJvcGVydGllc30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtOb3JtYWx9IG5vcm1hbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NwYWNlXVxuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgdCwgcikge1xuICAgIHRoaXMucHJvcGVydHkgPSBlLCB0aGlzLm5vcm1hbCA9IHQsIHIgJiYgKHRoaXMuc3BhY2UgPSByKTtcbiAgfVxufVxuVW4ucHJvdG90eXBlLnByb3BlcnR5ID0ge307XG5Vbi5wcm90b3R5cGUubm9ybWFsID0ge307XG5Vbi5wcm90b3R5cGUuc3BhY2UgPSBudWxsO1xuZnVuY3Rpb24gWnQobiwgZSkge1xuICBjb25zdCB0ID0ge30sIHIgPSB7fTtcbiAgbGV0IGkgPSAtMTtcbiAgZm9yICg7ICsraSA8IG4ubGVuZ3RoOyApXG4gICAgT2JqZWN0LmFzc2lnbih0LCBuW2ldLnByb3BlcnR5KSwgT2JqZWN0LmFzc2lnbihyLCBuW2ldLm5vcm1hbCk7XG4gIHJldHVybiBuZXcgVW4odCwgciwgZSk7XG59XG5mdW5jdGlvbiBiZShuKSB7XG4gIHJldHVybiBuLnRvTG93ZXJDYXNlKCk7XG59XG5jbGFzcyBwbiB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLnByb3BlcnR5ID0gZSwgdGhpcy5hdHRyaWJ1dGUgPSB0O1xuICB9XG59XG5wbi5wcm90b3R5cGUuc3BhY2UgPSBudWxsO1xucG4ucHJvdG90eXBlLmJvb2xlYW4gPSAhMTtcbnBuLnByb3RvdHlwZS5ib29sZWFuaXNoID0gITE7XG5wbi5wcm90b3R5cGUub3ZlcmxvYWRlZEJvb2xlYW4gPSAhMTtcbnBuLnByb3RvdHlwZS5udW1iZXIgPSAhMTtcbnBuLnByb3RvdHlwZS5jb21tYVNlcGFyYXRlZCA9ICExO1xucG4ucHJvdG90eXBlLnNwYWNlU2VwYXJhdGVkID0gITE7XG5wbi5wcm90b3R5cGUuY29tbWFPclNwYWNlU2VwYXJhdGVkID0gITE7XG5wbi5wcm90b3R5cGUubXVzdFVzZVByb3BlcnR5ID0gITE7XG5wbi5wcm90b3R5cGUuZGVmaW5lZCA9ICExO1xubGV0IExvID0gMDtcbmNvbnN0IHogPSBJbigpLCBLID0gSW4oKSwgSnQgPSBJbigpLCBTID0gSW4oKSwgViA9IEluKCksIERuID0gSW4oKSwgbG4gPSBJbigpO1xuZnVuY3Rpb24gSW4oKSB7XG4gIHJldHVybiAyICoqICsrTG87XG59XG5jb25zdCB3ZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJvb2xlYW46IHosXG4gIGJvb2xlYW5pc2g6IEssXG4gIGNvbW1hT3JTcGFjZVNlcGFyYXRlZDogbG4sXG4gIGNvbW1hU2VwYXJhdGVkOiBEbixcbiAgbnVtYmVyOiBTLFxuICBvdmVybG9hZGVkQm9vbGVhbjogSnQsXG4gIHNwYWNlU2VwYXJhdGVkOiBWXG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBwZSA9IE9iamVjdC5rZXlzKHdlKTtcbmNsYXNzIE9lIGV4dGVuZHMgcG4ge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfG51bGx9IFttYXNrXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3NwYWNlXVxuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgdCwgciwgaSkge1xuICAgIGxldCBsID0gLTE7XG4gICAgaWYgKHN1cGVyKGUsIHQpLCBkdCh0aGlzLCBcInNwYWNlXCIsIGkpLCB0eXBlb2YgciA9PSBcIm51bWJlclwiKVxuICAgICAgZm9yICg7ICsrbCA8IHBlLmxlbmd0aDsgKSB7XG4gICAgICAgIGNvbnN0IG8gPSBwZVtsXTtcbiAgICAgICAgZHQodGhpcywgcGVbbF0sIChyICYgd2Vbb10pID09PSB3ZVtvXSk7XG4gICAgICB9XG4gIH1cbn1cbk9lLnByb3RvdHlwZS5kZWZpbmVkID0gITA7XG5mdW5jdGlvbiBkdChuLCBlLCB0KSB7XG4gIHQgJiYgKG5bZV0gPSB0KTtcbn1cbmNvbnN0IERvID0ge30uaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiB6bihuKSB7XG4gIGNvbnN0IGUgPSB7fSwgdCA9IHt9O1xuICBsZXQgcjtcbiAgZm9yIChyIGluIG4ucHJvcGVydGllcylcbiAgICBpZiAoRG8uY2FsbChuLnByb3BlcnRpZXMsIHIpKSB7XG4gICAgICBjb25zdCBpID0gbi5wcm9wZXJ0aWVzW3JdLCBsID0gbmV3IE9lKFxuICAgICAgICByLFxuICAgICAgICBuLnRyYW5zZm9ybShuLmF0dHJpYnV0ZXMgfHwge30sIHIpLFxuICAgICAgICBpLFxuICAgICAgICBuLnNwYWNlXG4gICAgICApO1xuICAgICAgbi5tdXN0VXNlUHJvcGVydHkgJiYgbi5tdXN0VXNlUHJvcGVydHkuaW5jbHVkZXMocikgJiYgKGwubXVzdFVzZVByb3BlcnR5ID0gITApLCBlW3JdID0gbCwgdFtiZShyKV0gPSByLCB0W2JlKGwuYXR0cmlidXRlKV0gPSByO1xuICAgIH1cbiAgcmV0dXJuIG5ldyBVbihlLCB0LCBuLnNwYWNlKTtcbn1cbmNvbnN0IG5yID0gem4oe1xuICBzcGFjZTogXCJ4bGlua1wiLFxuICB0cmFuc2Zvcm0obiwgZSkge1xuICAgIHJldHVybiBcInhsaW5rOlwiICsgZS5zbGljZSg1KS50b0xvd2VyQ2FzZSgpO1xuICB9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgeExpbmtBY3R1YXRlOiBudWxsLFxuICAgIHhMaW5rQXJjUm9sZTogbnVsbCxcbiAgICB4TGlua0hyZWY6IG51bGwsXG4gICAgeExpbmtSb2xlOiBudWxsLFxuICAgIHhMaW5rU2hvdzogbnVsbCxcbiAgICB4TGlua1RpdGxlOiBudWxsLFxuICAgIHhMaW5rVHlwZTogbnVsbFxuICB9XG59KSwgZXIgPSB6bih7XG4gIHNwYWNlOiBcInhtbFwiLFxuICB0cmFuc2Zvcm0obiwgZSkge1xuICAgIHJldHVybiBcInhtbDpcIiArIGUuc2xpY2UoMykudG9Mb3dlckNhc2UoKTtcbiAgfSxcbiAgcHJvcGVydGllczogeyB4bWxMYW5nOiBudWxsLCB4bWxCYXNlOiBudWxsLCB4bWxTcGFjZTogbnVsbCB9XG59KTtcbmZ1bmN0aW9uIHRyKG4sIGUpIHtcbiAgcmV0dXJuIGUgaW4gbiA/IG5bZV0gOiBlO1xufVxuZnVuY3Rpb24gcnIobiwgZSkge1xuICByZXR1cm4gdHIobiwgZS50b0xvd2VyQ2FzZSgpKTtcbn1cbmNvbnN0IGlyID0gem4oe1xuICBzcGFjZTogXCJ4bWxuc1wiLFxuICBhdHRyaWJ1dGVzOiB7IHhtbG5zeGxpbms6IFwieG1sbnM6eGxpbmtcIiB9LFxuICB0cmFuc2Zvcm06IHJyLFxuICBwcm9wZXJ0aWVzOiB7IHhtbG5zOiBudWxsLCB4bWxuc1hMaW5rOiBudWxsIH1cbn0pLCBsciA9IHpuKHtcbiAgdHJhbnNmb3JtKG4sIGUpIHtcbiAgICByZXR1cm4gZSA9PT0gXCJyb2xlXCIgPyBlIDogXCJhcmlhLVwiICsgZS5zbGljZSg0KS50b0xvd2VyQ2FzZSgpO1xuICB9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgYXJpYUFjdGl2ZURlc2NlbmRhbnQ6IG51bGwsXG4gICAgYXJpYUF0b21pYzogSyxcbiAgICBhcmlhQXV0b0NvbXBsZXRlOiBudWxsLFxuICAgIGFyaWFCdXN5OiBLLFxuICAgIGFyaWFDaGVja2VkOiBLLFxuICAgIGFyaWFDb2xDb3VudDogUyxcbiAgICBhcmlhQ29sSW5kZXg6IFMsXG4gICAgYXJpYUNvbFNwYW46IFMsXG4gICAgYXJpYUNvbnRyb2xzOiBWLFxuICAgIGFyaWFDdXJyZW50OiBudWxsLFxuICAgIGFyaWFEZXNjcmliZWRCeTogVixcbiAgICBhcmlhRGV0YWlsczogbnVsbCxcbiAgICBhcmlhRGlzYWJsZWQ6IEssXG4gICAgYXJpYURyb3BFZmZlY3Q6IFYsXG4gICAgYXJpYUVycm9yTWVzc2FnZTogbnVsbCxcbiAgICBhcmlhRXhwYW5kZWQ6IEssXG4gICAgYXJpYUZsb3dUbzogVixcbiAgICBhcmlhR3JhYmJlZDogSyxcbiAgICBhcmlhSGFzUG9wdXA6IG51bGwsXG4gICAgYXJpYUhpZGRlbjogSyxcbiAgICBhcmlhSW52YWxpZDogbnVsbCxcbiAgICBhcmlhS2V5U2hvcnRjdXRzOiBudWxsLFxuICAgIGFyaWFMYWJlbDogbnVsbCxcbiAgICBhcmlhTGFiZWxsZWRCeTogVixcbiAgICBhcmlhTGV2ZWw6IFMsXG4gICAgYXJpYUxpdmU6IG51bGwsXG4gICAgYXJpYU1vZGFsOiBLLFxuICAgIGFyaWFNdWx0aUxpbmU6IEssXG4gICAgYXJpYU11bHRpU2VsZWN0YWJsZTogSyxcbiAgICBhcmlhT3JpZW50YXRpb246IG51bGwsXG4gICAgYXJpYU93bnM6IFYsXG4gICAgYXJpYVBsYWNlaG9sZGVyOiBudWxsLFxuICAgIGFyaWFQb3NJblNldDogUyxcbiAgICBhcmlhUHJlc3NlZDogSyxcbiAgICBhcmlhUmVhZE9ubHk6IEssXG4gICAgYXJpYVJlbGV2YW50OiBudWxsLFxuICAgIGFyaWFSZXF1aXJlZDogSyxcbiAgICBhcmlhUm9sZURlc2NyaXB0aW9uOiBWLFxuICAgIGFyaWFSb3dDb3VudDogUyxcbiAgICBhcmlhUm93SW5kZXg6IFMsXG4gICAgYXJpYVJvd1NwYW46IFMsXG4gICAgYXJpYVNlbGVjdGVkOiBLLFxuICAgIGFyaWFTZXRTaXplOiBTLFxuICAgIGFyaWFTb3J0OiBudWxsLFxuICAgIGFyaWFWYWx1ZU1heDogUyxcbiAgICBhcmlhVmFsdWVNaW46IFMsXG4gICAgYXJpYVZhbHVlTm93OiBTLFxuICAgIGFyaWFWYWx1ZVRleHQ6IG51bGwsXG4gICAgcm9sZTogbnVsbFxuICB9XG59KSwgdm8gPSB6bih7XG4gIHNwYWNlOiBcImh0bWxcIixcbiAgYXR0cmlidXRlczoge1xuICAgIGFjY2VwdGNoYXJzZXQ6IFwiYWNjZXB0LWNoYXJzZXRcIixcbiAgICBjbGFzc25hbWU6IFwiY2xhc3NcIixcbiAgICBodG1sZm9yOiBcImZvclwiLFxuICAgIGh0dHBlcXVpdjogXCJodHRwLWVxdWl2XCJcbiAgfSxcbiAgdHJhbnNmb3JtOiBycixcbiAgbXVzdFVzZVByb3BlcnR5OiBbXCJjaGVja2VkXCIsIFwibXVsdGlwbGVcIiwgXCJtdXRlZFwiLCBcInNlbGVjdGVkXCJdLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLy8gU3RhbmRhcmQgUHJvcGVydGllcy5cbiAgICBhYmJyOiBudWxsLFxuICAgIGFjY2VwdDogRG4sXG4gICAgYWNjZXB0Q2hhcnNldDogVixcbiAgICBhY2Nlc3NLZXk6IFYsXG4gICAgYWN0aW9uOiBudWxsLFxuICAgIGFsbG93OiBudWxsLFxuICAgIGFsbG93RnVsbFNjcmVlbjogeixcbiAgICBhbGxvd1BheW1lbnRSZXF1ZXN0OiB6LFxuICAgIGFsbG93VXNlck1lZGlhOiB6LFxuICAgIGFsdDogbnVsbCxcbiAgICBhczogbnVsbCxcbiAgICBhc3luYzogeixcbiAgICBhdXRvQ2FwaXRhbGl6ZTogbnVsbCxcbiAgICBhdXRvQ29tcGxldGU6IFYsXG4gICAgYXV0b0ZvY3VzOiB6LFxuICAgIGF1dG9QbGF5OiB6LFxuICAgIGNhcHR1cmU6IHosXG4gICAgY2hhclNldDogbnVsbCxcbiAgICBjaGVja2VkOiB6LFxuICAgIGNpdGU6IG51bGwsXG4gICAgY2xhc3NOYW1lOiBWLFxuICAgIGNvbHM6IFMsXG4gICAgY29sU3BhbjogbnVsbCxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGNvbnRlbnRFZGl0YWJsZTogSyxcbiAgICBjb250cm9sczogeixcbiAgICBjb250cm9sc0xpc3Q6IFYsXG4gICAgY29vcmRzOiBTIHwgRG4sXG4gICAgY3Jvc3NPcmlnaW46IG51bGwsXG4gICAgZGF0YTogbnVsbCxcbiAgICBkYXRlVGltZTogbnVsbCxcbiAgICBkZWNvZGluZzogbnVsbCxcbiAgICBkZWZhdWx0OiB6LFxuICAgIGRlZmVyOiB6LFxuICAgIGRpcjogbnVsbCxcbiAgICBkaXJOYW1lOiBudWxsLFxuICAgIGRpc2FibGVkOiB6LFxuICAgIGRvd25sb2FkOiBKdCxcbiAgICBkcmFnZ2FibGU6IEssXG4gICAgZW5jVHlwZTogbnVsbCxcbiAgICBlbnRlcktleUhpbnQ6IG51bGwsXG4gICAgZm9ybTogbnVsbCxcbiAgICBmb3JtQWN0aW9uOiBudWxsLFxuICAgIGZvcm1FbmNUeXBlOiBudWxsLFxuICAgIGZvcm1NZXRob2Q6IG51bGwsXG4gICAgZm9ybU5vVmFsaWRhdGU6IHosXG4gICAgZm9ybVRhcmdldDogbnVsbCxcbiAgICBoZWFkZXJzOiBWLFxuICAgIGhlaWdodDogUyxcbiAgICBoaWRkZW46IHosXG4gICAgaGlnaDogUyxcbiAgICBocmVmOiBudWxsLFxuICAgIGhyZWZMYW5nOiBudWxsLFxuICAgIGh0bWxGb3I6IFYsXG4gICAgaHR0cEVxdWl2OiBWLFxuICAgIGlkOiBudWxsLFxuICAgIGltYWdlU2l6ZXM6IG51bGwsXG4gICAgaW1hZ2VTcmNTZXQ6IG51bGwsXG4gICAgaW5wdXRNb2RlOiBudWxsLFxuICAgIGludGVncml0eTogbnVsbCxcbiAgICBpczogbnVsbCxcbiAgICBpc01hcDogeixcbiAgICBpdGVtSWQ6IG51bGwsXG4gICAgaXRlbVByb3A6IFYsXG4gICAgaXRlbVJlZjogVixcbiAgICBpdGVtU2NvcGU6IHosXG4gICAgaXRlbVR5cGU6IFYsXG4gICAga2luZDogbnVsbCxcbiAgICBsYWJlbDogbnVsbCxcbiAgICBsYW5nOiBudWxsLFxuICAgIGxhbmd1YWdlOiBudWxsLFxuICAgIGxpc3Q6IG51bGwsXG4gICAgbG9hZGluZzogbnVsbCxcbiAgICBsb29wOiB6LFxuICAgIGxvdzogUyxcbiAgICBtYW5pZmVzdDogbnVsbCxcbiAgICBtYXg6IG51bGwsXG4gICAgbWF4TGVuZ3RoOiBTLFxuICAgIG1lZGlhOiBudWxsLFxuICAgIG1ldGhvZDogbnVsbCxcbiAgICBtaW46IG51bGwsXG4gICAgbWluTGVuZ3RoOiBTLFxuICAgIG11bHRpcGxlOiB6LFxuICAgIG11dGVkOiB6LFxuICAgIG5hbWU6IG51bGwsXG4gICAgbm9uY2U6IG51bGwsXG4gICAgbm9Nb2R1bGU6IHosXG4gICAgbm9WYWxpZGF0ZTogeixcbiAgICBvbkFib3J0OiBudWxsLFxuICAgIG9uQWZ0ZXJQcmludDogbnVsbCxcbiAgICBvbkF1eENsaWNrOiBudWxsLFxuICAgIG9uQmVmb3JlTWF0Y2g6IG51bGwsXG4gICAgb25CZWZvcmVQcmludDogbnVsbCxcbiAgICBvbkJlZm9yZVVubG9hZDogbnVsbCxcbiAgICBvbkJsdXI6IG51bGwsXG4gICAgb25DYW5jZWw6IG51bGwsXG4gICAgb25DYW5QbGF5OiBudWxsLFxuICAgIG9uQ2FuUGxheVRocm91Z2g6IG51bGwsXG4gICAgb25DaGFuZ2U6IG51bGwsXG4gICAgb25DbGljazogbnVsbCxcbiAgICBvbkNsb3NlOiBudWxsLFxuICAgIG9uQ29udGV4dExvc3Q6IG51bGwsXG4gICAgb25Db250ZXh0TWVudTogbnVsbCxcbiAgICBvbkNvbnRleHRSZXN0b3JlZDogbnVsbCxcbiAgICBvbkNvcHk6IG51bGwsXG4gICAgb25DdWVDaGFuZ2U6IG51bGwsXG4gICAgb25DdXQ6IG51bGwsXG4gICAgb25EYmxDbGljazogbnVsbCxcbiAgICBvbkRyYWc6IG51bGwsXG4gICAgb25EcmFnRW5kOiBudWxsLFxuICAgIG9uRHJhZ0VudGVyOiBudWxsLFxuICAgIG9uRHJhZ0V4aXQ6IG51bGwsXG4gICAgb25EcmFnTGVhdmU6IG51bGwsXG4gICAgb25EcmFnT3ZlcjogbnVsbCxcbiAgICBvbkRyYWdTdGFydDogbnVsbCxcbiAgICBvbkRyb3A6IG51bGwsXG4gICAgb25EdXJhdGlvbkNoYW5nZTogbnVsbCxcbiAgICBvbkVtcHRpZWQ6IG51bGwsXG4gICAgb25FbmRlZDogbnVsbCxcbiAgICBvbkVycm9yOiBudWxsLFxuICAgIG9uRm9jdXM6IG51bGwsXG4gICAgb25Gb3JtRGF0YTogbnVsbCxcbiAgICBvbkhhc2hDaGFuZ2U6IG51bGwsXG4gICAgb25JbnB1dDogbnVsbCxcbiAgICBvbkludmFsaWQ6IG51bGwsXG4gICAgb25LZXlEb3duOiBudWxsLFxuICAgIG9uS2V5UHJlc3M6IG51bGwsXG4gICAgb25LZXlVcDogbnVsbCxcbiAgICBvbkxhbmd1YWdlQ2hhbmdlOiBudWxsLFxuICAgIG9uTG9hZDogbnVsbCxcbiAgICBvbkxvYWRlZERhdGE6IG51bGwsXG4gICAgb25Mb2FkZWRNZXRhZGF0YTogbnVsbCxcbiAgICBvbkxvYWRFbmQ6IG51bGwsXG4gICAgb25Mb2FkU3RhcnQ6IG51bGwsXG4gICAgb25NZXNzYWdlOiBudWxsLFxuICAgIG9uTWVzc2FnZUVycm9yOiBudWxsLFxuICAgIG9uTW91c2VEb3duOiBudWxsLFxuICAgIG9uTW91c2VFbnRlcjogbnVsbCxcbiAgICBvbk1vdXNlTGVhdmU6IG51bGwsXG4gICAgb25Nb3VzZU1vdmU6IG51bGwsXG4gICAgb25Nb3VzZU91dDogbnVsbCxcbiAgICBvbk1vdXNlT3ZlcjogbnVsbCxcbiAgICBvbk1vdXNlVXA6IG51bGwsXG4gICAgb25PZmZsaW5lOiBudWxsLFxuICAgIG9uT25saW5lOiBudWxsLFxuICAgIG9uUGFnZUhpZGU6IG51bGwsXG4gICAgb25QYWdlU2hvdzogbnVsbCxcbiAgICBvblBhc3RlOiBudWxsLFxuICAgIG9uUGF1c2U6IG51bGwsXG4gICAgb25QbGF5OiBudWxsLFxuICAgIG9uUGxheWluZzogbnVsbCxcbiAgICBvblBvcFN0YXRlOiBudWxsLFxuICAgIG9uUHJvZ3Jlc3M6IG51bGwsXG4gICAgb25SYXRlQ2hhbmdlOiBudWxsLFxuICAgIG9uUmVqZWN0aW9uSGFuZGxlZDogbnVsbCxcbiAgICBvblJlc2V0OiBudWxsLFxuICAgIG9uUmVzaXplOiBudWxsLFxuICAgIG9uU2Nyb2xsOiBudWxsLFxuICAgIG9uU2Nyb2xsRW5kOiBudWxsLFxuICAgIG9uU2VjdXJpdHlQb2xpY3lWaW9sYXRpb246IG51bGwsXG4gICAgb25TZWVrZWQ6IG51bGwsXG4gICAgb25TZWVraW5nOiBudWxsLFxuICAgIG9uU2VsZWN0OiBudWxsLFxuICAgIG9uU2xvdENoYW5nZTogbnVsbCxcbiAgICBvblN0YWxsZWQ6IG51bGwsXG4gICAgb25TdG9yYWdlOiBudWxsLFxuICAgIG9uU3VibWl0OiBudWxsLFxuICAgIG9uU3VzcGVuZDogbnVsbCxcbiAgICBvblRpbWVVcGRhdGU6IG51bGwsXG4gICAgb25Ub2dnbGU6IG51bGwsXG4gICAgb25VbmhhbmRsZWRSZWplY3Rpb246IG51bGwsXG4gICAgb25VbmxvYWQ6IG51bGwsXG4gICAgb25Wb2x1bWVDaGFuZ2U6IG51bGwsXG4gICAgb25XYWl0aW5nOiBudWxsLFxuICAgIG9uV2hlZWw6IG51bGwsXG4gICAgb3BlbjogeixcbiAgICBvcHRpbXVtOiBTLFxuICAgIHBhdHRlcm46IG51bGwsXG4gICAgcGluZzogVixcbiAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICBwbGF5c0lubGluZTogeixcbiAgICBwb3N0ZXI6IG51bGwsXG4gICAgcHJlbG9hZDogbnVsbCxcbiAgICByZWFkT25seTogeixcbiAgICByZWZlcnJlclBvbGljeTogbnVsbCxcbiAgICByZWw6IFYsXG4gICAgcmVxdWlyZWQ6IHosXG4gICAgcmV2ZXJzZWQ6IHosXG4gICAgcm93czogUyxcbiAgICByb3dTcGFuOiBTLFxuICAgIHNhbmRib3g6IFYsXG4gICAgc2NvcGU6IG51bGwsXG4gICAgc2NvcGVkOiB6LFxuICAgIHNlYW1sZXNzOiB6LFxuICAgIHNlbGVjdGVkOiB6LFxuICAgIHNoYXBlOiBudWxsLFxuICAgIHNpemU6IFMsXG4gICAgc2l6ZXM6IG51bGwsXG4gICAgc2xvdDogbnVsbCxcbiAgICBzcGFuOiBTLFxuICAgIHNwZWxsQ2hlY2s6IEssXG4gICAgc3JjOiBudWxsLFxuICAgIHNyY0RvYzogbnVsbCxcbiAgICBzcmNMYW5nOiBudWxsLFxuICAgIHNyY1NldDogbnVsbCxcbiAgICBzdGFydDogUyxcbiAgICBzdGVwOiBudWxsLFxuICAgIHN0eWxlOiBudWxsLFxuICAgIHRhYkluZGV4OiBTLFxuICAgIHRhcmdldDogbnVsbCxcbiAgICB0aXRsZTogbnVsbCxcbiAgICB0cmFuc2xhdGU6IG51bGwsXG4gICAgdHlwZTogbnVsbCxcbiAgICB0eXBlTXVzdE1hdGNoOiB6LFxuICAgIHVzZU1hcDogbnVsbCxcbiAgICB2YWx1ZTogSyxcbiAgICB3aWR0aDogUyxcbiAgICB3cmFwOiBudWxsLFxuICAgIC8vIExlZ2FjeS5cbiAgICAvLyBTZWU6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvI290aGVyLWVsZW1lbnRzLC1hdHRyaWJ1dGVzLWFuZC1hcGlzXG4gICAgYWxpZ246IG51bGwsXG4gICAgLy8gU2V2ZXJhbC4gVXNlIENTUyBgdGV4dC1hbGlnbmAgaW5zdGVhZCxcbiAgICBhTGluazogbnVsbCxcbiAgICAvLyBgPGJvZHk+YC4gVXNlIENTUyBgYTphY3RpdmUge2NvbG9yfWAgaW5zdGVhZFxuICAgIGFyY2hpdmU6IFYsXG4gICAgLy8gYDxvYmplY3Q+YC4gTGlzdCBvZiBVUklzIHRvIGFyY2hpdmVzXG4gICAgYXhpczogbnVsbCxcbiAgICAvLyBgPHRkPmAgYW5kIGA8dGg+YC4gVXNlIGBzY29wZWAgb24gYDx0aD5gXG4gICAgYmFja2dyb3VuZDogbnVsbCxcbiAgICAvLyBgPGJvZHk+YC4gVXNlIENTUyBgYmFja2dyb3VuZC1pbWFnZWAgaW5zdGVhZFxuICAgIGJnQ29sb3I6IG51bGwsXG4gICAgLy8gYDxib2R5PmAgYW5kIHRhYmxlIGVsZW1lbnRzLiBVc2UgQ1NTIGBiYWNrZ3JvdW5kLWNvbG9yYCBpbnN0ZWFkXG4gICAgYm9yZGVyOiBTLFxuICAgIC8vIGA8dGFibGU+YC4gVXNlIENTUyBgYm9yZGVyLXdpZHRoYCBpbnN0ZWFkLFxuICAgIGJvcmRlckNvbG9yOiBudWxsLFxuICAgIC8vIGA8dGFibGU+YC4gVXNlIENTUyBgYm9yZGVyLWNvbG9yYCBpbnN0ZWFkLFxuICAgIGJvdHRvbU1hcmdpbjogUyxcbiAgICAvLyBgPGJvZHk+YFxuICAgIGNlbGxQYWRkaW5nOiBudWxsLFxuICAgIC8vIGA8dGFibGU+YFxuICAgIGNlbGxTcGFjaW5nOiBudWxsLFxuICAgIC8vIGA8dGFibGU+YFxuICAgIGNoYXI6IG51bGwsXG4gICAgLy8gU2V2ZXJhbCB0YWJsZSBlbGVtZW50cy4gV2hlbiBgYWxpZ249Y2hhcmAsIHNldHMgdGhlIGNoYXJhY3RlciB0byBhbGlnbiBvblxuICAgIGNoYXJPZmY6IG51bGwsXG4gICAgLy8gU2V2ZXJhbCB0YWJsZSBlbGVtZW50cy4gV2hlbiBgY2hhcmAsIG9mZnNldHMgdGhlIGFsaWdubWVudFxuICAgIGNsYXNzSWQ6IG51bGwsXG4gICAgLy8gYDxvYmplY3Q+YFxuICAgIGNsZWFyOiBudWxsLFxuICAgIC8vIGA8YnI+YC4gVXNlIENTUyBgY2xlYXJgIGluc3RlYWRcbiAgICBjb2RlOiBudWxsLFxuICAgIC8vIGA8b2JqZWN0PmBcbiAgICBjb2RlQmFzZTogbnVsbCxcbiAgICAvLyBgPG9iamVjdD5gXG4gICAgY29kZVR5cGU6IG51bGwsXG4gICAgLy8gYDxvYmplY3Q+YFxuICAgIGNvbG9yOiBudWxsLFxuICAgIC8vIGA8Zm9udD5gIGFuZCBgPGhyPmAuIFVzZSBDU1MgaW5zdGVhZFxuICAgIGNvbXBhY3Q6IHosXG4gICAgLy8gTGlzdHMuIFVzZSBDU1MgdG8gcmVkdWNlIHNwYWNlIGJldHdlZW4gaXRlbXMgaW5zdGVhZFxuICAgIGRlY2xhcmU6IHosXG4gICAgLy8gYDxvYmplY3Q+YFxuICAgIGV2ZW50OiBudWxsLFxuICAgIC8vIGA8c2NyaXB0PmBcbiAgICBmYWNlOiBudWxsLFxuICAgIC8vIGA8Zm9udD5gLiBVc2UgQ1NTIGluc3RlYWRcbiAgICBmcmFtZTogbnVsbCxcbiAgICAvLyBgPHRhYmxlPmBcbiAgICBmcmFtZUJvcmRlcjogbnVsbCxcbiAgICAvLyBgPGlmcmFtZT5gLiBVc2UgQ1NTIGBib3JkZXJgIGluc3RlYWRcbiAgICBoU3BhY2U6IFMsXG4gICAgLy8gYDxpbWc+YCBhbmQgYDxvYmplY3Q+YFxuICAgIGxlZnRNYXJnaW46IFMsXG4gICAgLy8gYDxib2R5PmBcbiAgICBsaW5rOiBudWxsLFxuICAgIC8vIGA8Ym9keT5gLiBVc2UgQ1NTIGBhOmxpbmsge2NvbG9yOiAqfWAgaW5zdGVhZFxuICAgIGxvbmdEZXNjOiBudWxsLFxuICAgIC8vIGA8ZnJhbWU+YCwgYDxpZnJhbWU+YCwgYW5kIGA8aW1nPmAuIFVzZSBhbiBgPGE+YFxuICAgIGxvd1NyYzogbnVsbCxcbiAgICAvLyBgPGltZz5gLiBVc2UgYSBgPHBpY3R1cmU+YFxuICAgIG1hcmdpbkhlaWdodDogUyxcbiAgICAvLyBgPGJvZHk+YFxuICAgIG1hcmdpbldpZHRoOiBTLFxuICAgIC8vIGA8Ym9keT5gXG4gICAgbm9SZXNpemU6IHosXG4gICAgLy8gYDxmcmFtZT5gXG4gICAgbm9IcmVmOiB6LFxuICAgIC8vIGA8YXJlYT5gLiBVc2Ugbm8gaHJlZiBpbnN0ZWFkIG9mIGFuIGV4cGxpY2l0IGBub2hyZWZgXG4gICAgbm9TaGFkZTogeixcbiAgICAvLyBgPGhyPmAuIFVzZSBiYWNrZ3JvdW5kLWNvbG9yIGFuZCBoZWlnaHQgaW5zdGVhZCBvZiBib3JkZXJzXG4gICAgbm9XcmFwOiB6LFxuICAgIC8vIGA8dGQ+YCBhbmQgYDx0aD5gXG4gICAgb2JqZWN0OiBudWxsLFxuICAgIC8vIGA8YXBwbGV0PmBcbiAgICBwcm9maWxlOiBudWxsLFxuICAgIC8vIGA8aGVhZD5gXG4gICAgcHJvbXB0OiBudWxsLFxuICAgIC8vIGA8aXNpbmRleD5gXG4gICAgcmV2OiBudWxsLFxuICAgIC8vIGA8bGluaz5gXG4gICAgcmlnaHRNYXJnaW46IFMsXG4gICAgLy8gYDxib2R5PmBcbiAgICBydWxlczogbnVsbCxcbiAgICAvLyBgPHRhYmxlPmBcbiAgICBzY2hlbWU6IG51bGwsXG4gICAgLy8gYDxtZXRhPmBcbiAgICBzY3JvbGxpbmc6IEssXG4gICAgLy8gYDxmcmFtZT5gLiBVc2Ugb3ZlcmZsb3cgaW4gdGhlIGNoaWxkIGNvbnRleHRcbiAgICBzdGFuZGJ5OiBudWxsLFxuICAgIC8vIGA8b2JqZWN0PmBcbiAgICBzdW1tYXJ5OiBudWxsLFxuICAgIC8vIGA8dGFibGU+YFxuICAgIHRleHQ6IG51bGwsXG4gICAgLy8gYDxib2R5PmAuIFVzZSBDU1MgYGNvbG9yYCBpbnN0ZWFkXG4gICAgdG9wTWFyZ2luOiBTLFxuICAgIC8vIGA8Ym9keT5gXG4gICAgdmFsdWVUeXBlOiBudWxsLFxuICAgIC8vIGA8cGFyYW0+YFxuICAgIHZlcnNpb246IG51bGwsXG4gICAgLy8gYDxodG1sPmAuIFVzZSBhIGRvY3R5cGUuXG4gICAgdkFsaWduOiBudWxsLFxuICAgIC8vIFNldmVyYWwuIFVzZSBDU1MgYHZlcnRpY2FsLWFsaWduYCBpbnN0ZWFkXG4gICAgdkxpbms6IG51bGwsXG4gICAgLy8gYDxib2R5PmAuIFVzZSBDU1MgYGE6dmlzaXRlZCB7Y29sb3J9YCBpbnN0ZWFkXG4gICAgdlNwYWNlOiBTLFxuICAgIC8vIGA8aW1nPmAgYW5kIGA8b2JqZWN0PmBcbiAgICAvLyBOb24tc3RhbmRhcmQgUHJvcGVydGllcy5cbiAgICBhbGxvd1RyYW5zcGFyZW5jeTogbnVsbCxcbiAgICBhdXRvQ29ycmVjdDogbnVsbCxcbiAgICBhdXRvU2F2ZTogbnVsbCxcbiAgICBkaXNhYmxlUGljdHVyZUluUGljdHVyZTogeixcbiAgICBkaXNhYmxlUmVtb3RlUGxheWJhY2s6IHosXG4gICAgcHJlZml4OiBudWxsLFxuICAgIHByb3BlcnR5OiBudWxsLFxuICAgIHJlc3VsdHM6IFMsXG4gICAgc2VjdXJpdHk6IG51bGwsXG4gICAgdW5zZWxlY3RhYmxlOiBudWxsXG4gIH1cbn0pLCB6byA9IHpuKHtcbiAgc3BhY2U6IFwic3ZnXCIsXG4gIGF0dHJpYnV0ZXM6IHtcbiAgICBhY2NlbnRIZWlnaHQ6IFwiYWNjZW50LWhlaWdodFwiLFxuICAgIGFsaWdubWVudEJhc2VsaW5lOiBcImFsaWdubWVudC1iYXNlbGluZVwiLFxuICAgIGFyYWJpY0Zvcm06IFwiYXJhYmljLWZvcm1cIixcbiAgICBiYXNlbGluZVNoaWZ0OiBcImJhc2VsaW5lLXNoaWZ0XCIsXG4gICAgY2FwSGVpZ2h0OiBcImNhcC1oZWlnaHRcIixcbiAgICBjbGFzc05hbWU6IFwiY2xhc3NcIixcbiAgICBjbGlwUGF0aDogXCJjbGlwLXBhdGhcIixcbiAgICBjbGlwUnVsZTogXCJjbGlwLXJ1bGVcIixcbiAgICBjb2xvckludGVycG9sYXRpb246IFwiY29sb3ItaW50ZXJwb2xhdGlvblwiLFxuICAgIGNvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnM6IFwiY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzXCIsXG4gICAgY29sb3JQcm9maWxlOiBcImNvbG9yLXByb2ZpbGVcIixcbiAgICBjb2xvclJlbmRlcmluZzogXCJjb2xvci1yZW5kZXJpbmdcIixcbiAgICBjcm9zc09yaWdpbjogXCJjcm9zc29yaWdpblwiLFxuICAgIGRhdGFUeXBlOiBcImRhdGF0eXBlXCIsXG4gICAgZG9taW5hbnRCYXNlbGluZTogXCJkb21pbmFudC1iYXNlbGluZVwiLFxuICAgIGVuYWJsZUJhY2tncm91bmQ6IFwiZW5hYmxlLWJhY2tncm91bmRcIixcbiAgICBmaWxsT3BhY2l0eTogXCJmaWxsLW9wYWNpdHlcIixcbiAgICBmaWxsUnVsZTogXCJmaWxsLXJ1bGVcIixcbiAgICBmbG9vZENvbG9yOiBcImZsb29kLWNvbG9yXCIsXG4gICAgZmxvb2RPcGFjaXR5OiBcImZsb29kLW9wYWNpdHlcIixcbiAgICBmb250RmFtaWx5OiBcImZvbnQtZmFtaWx5XCIsXG4gICAgZm9udFNpemU6IFwiZm9udC1zaXplXCIsXG4gICAgZm9udFNpemVBZGp1c3Q6IFwiZm9udC1zaXplLWFkanVzdFwiLFxuICAgIGZvbnRTdHJldGNoOiBcImZvbnQtc3RyZXRjaFwiLFxuICAgIGZvbnRTdHlsZTogXCJmb250LXN0eWxlXCIsXG4gICAgZm9udFZhcmlhbnQ6IFwiZm9udC12YXJpYW50XCIsXG4gICAgZm9udFdlaWdodDogXCJmb250LXdlaWdodFwiLFxuICAgIGdseXBoTmFtZTogXCJnbHlwaC1uYW1lXCIsXG4gICAgZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWw6IFwiZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbFwiLFxuICAgIGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbDogXCJnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbFwiLFxuICAgIGhyZWZMYW5nOiBcImhyZWZsYW5nXCIsXG4gICAgaG9yaXpBZHZYOiBcImhvcml6LWFkdi14XCIsXG4gICAgaG9yaXpPcmlnaW5YOiBcImhvcml6LW9yaWdpbi14XCIsXG4gICAgaG9yaXpPcmlnaW5ZOiBcImhvcml6LW9yaWdpbi15XCIsXG4gICAgaW1hZ2VSZW5kZXJpbmc6IFwiaW1hZ2UtcmVuZGVyaW5nXCIsXG4gICAgbGV0dGVyU3BhY2luZzogXCJsZXR0ZXItc3BhY2luZ1wiLFxuICAgIGxpZ2h0aW5nQ29sb3I6IFwibGlnaHRpbmctY29sb3JcIixcbiAgICBtYXJrZXJFbmQ6IFwibWFya2VyLWVuZFwiLFxuICAgIG1hcmtlck1pZDogXCJtYXJrZXItbWlkXCIsXG4gICAgbWFya2VyU3RhcnQ6IFwibWFya2VyLXN0YXJ0XCIsXG4gICAgbmF2RG93bjogXCJuYXYtZG93blwiLFxuICAgIG5hdkRvd25MZWZ0OiBcIm5hdi1kb3duLWxlZnRcIixcbiAgICBuYXZEb3duUmlnaHQ6IFwibmF2LWRvd24tcmlnaHRcIixcbiAgICBuYXZMZWZ0OiBcIm5hdi1sZWZ0XCIsXG4gICAgbmF2TmV4dDogXCJuYXYtbmV4dFwiLFxuICAgIG5hdlByZXY6IFwibmF2LXByZXZcIixcbiAgICBuYXZSaWdodDogXCJuYXYtcmlnaHRcIixcbiAgICBuYXZVcDogXCJuYXYtdXBcIixcbiAgICBuYXZVcExlZnQ6IFwibmF2LXVwLWxlZnRcIixcbiAgICBuYXZVcFJpZ2h0OiBcIm5hdi11cC1yaWdodFwiLFxuICAgIG9uQWJvcnQ6IFwib25hYm9ydFwiLFxuICAgIG9uQWN0aXZhdGU6IFwib25hY3RpdmF0ZVwiLFxuICAgIG9uQWZ0ZXJQcmludDogXCJvbmFmdGVycHJpbnRcIixcbiAgICBvbkJlZm9yZVByaW50OiBcIm9uYmVmb3JlcHJpbnRcIixcbiAgICBvbkJlZ2luOiBcIm9uYmVnaW5cIixcbiAgICBvbkNhbmNlbDogXCJvbmNhbmNlbFwiLFxuICAgIG9uQ2FuUGxheTogXCJvbmNhbnBsYXlcIixcbiAgICBvbkNhblBsYXlUaHJvdWdoOiBcIm9uY2FucGxheXRocm91Z2hcIixcbiAgICBvbkNoYW5nZTogXCJvbmNoYW5nZVwiLFxuICAgIG9uQ2xpY2s6IFwib25jbGlja1wiLFxuICAgIG9uQ2xvc2U6IFwib25jbG9zZVwiLFxuICAgIG9uQ29weTogXCJvbmNvcHlcIixcbiAgICBvbkN1ZUNoYW5nZTogXCJvbmN1ZWNoYW5nZVwiLFxuICAgIG9uQ3V0OiBcIm9uY3V0XCIsXG4gICAgb25EYmxDbGljazogXCJvbmRibGNsaWNrXCIsXG4gICAgb25EcmFnOiBcIm9uZHJhZ1wiLFxuICAgIG9uRHJhZ0VuZDogXCJvbmRyYWdlbmRcIixcbiAgICBvbkRyYWdFbnRlcjogXCJvbmRyYWdlbnRlclwiLFxuICAgIG9uRHJhZ0V4aXQ6IFwib25kcmFnZXhpdFwiLFxuICAgIG9uRHJhZ0xlYXZlOiBcIm9uZHJhZ2xlYXZlXCIsXG4gICAgb25EcmFnT3ZlcjogXCJvbmRyYWdvdmVyXCIsXG4gICAgb25EcmFnU3RhcnQ6IFwib25kcmFnc3RhcnRcIixcbiAgICBvbkRyb3A6IFwib25kcm9wXCIsXG4gICAgb25EdXJhdGlvbkNoYW5nZTogXCJvbmR1cmF0aW9uY2hhbmdlXCIsXG4gICAgb25FbXB0aWVkOiBcIm9uZW1wdGllZFwiLFxuICAgIG9uRW5kOiBcIm9uZW5kXCIsXG4gICAgb25FbmRlZDogXCJvbmVuZGVkXCIsXG4gICAgb25FcnJvcjogXCJvbmVycm9yXCIsXG4gICAgb25Gb2N1czogXCJvbmZvY3VzXCIsXG4gICAgb25Gb2N1c0luOiBcIm9uZm9jdXNpblwiLFxuICAgIG9uRm9jdXNPdXQ6IFwib25mb2N1c291dFwiLFxuICAgIG9uSGFzaENoYW5nZTogXCJvbmhhc2hjaGFuZ2VcIixcbiAgICBvbklucHV0OiBcIm9uaW5wdXRcIixcbiAgICBvbkludmFsaWQ6IFwib25pbnZhbGlkXCIsXG4gICAgb25LZXlEb3duOiBcIm9ua2V5ZG93blwiLFxuICAgIG9uS2V5UHJlc3M6IFwib25rZXlwcmVzc1wiLFxuICAgIG9uS2V5VXA6IFwib25rZXl1cFwiLFxuICAgIG9uTG9hZDogXCJvbmxvYWRcIixcbiAgICBvbkxvYWRlZERhdGE6IFwib25sb2FkZWRkYXRhXCIsXG4gICAgb25Mb2FkZWRNZXRhZGF0YTogXCJvbmxvYWRlZG1ldGFkYXRhXCIsXG4gICAgb25Mb2FkU3RhcnQ6IFwib25sb2Fkc3RhcnRcIixcbiAgICBvbk1lc3NhZ2U6IFwib25tZXNzYWdlXCIsXG4gICAgb25Nb3VzZURvd246IFwib25tb3VzZWRvd25cIixcbiAgICBvbk1vdXNlRW50ZXI6IFwib25tb3VzZWVudGVyXCIsXG4gICAgb25Nb3VzZUxlYXZlOiBcIm9ubW91c2VsZWF2ZVwiLFxuICAgIG9uTW91c2VNb3ZlOiBcIm9ubW91c2Vtb3ZlXCIsXG4gICAgb25Nb3VzZU91dDogXCJvbm1vdXNlb3V0XCIsXG4gICAgb25Nb3VzZU92ZXI6IFwib25tb3VzZW92ZXJcIixcbiAgICBvbk1vdXNlVXA6IFwib25tb3VzZXVwXCIsXG4gICAgb25Nb3VzZVdoZWVsOiBcIm9ubW91c2V3aGVlbFwiLFxuICAgIG9uT2ZmbGluZTogXCJvbm9mZmxpbmVcIixcbiAgICBvbk9ubGluZTogXCJvbm9ubGluZVwiLFxuICAgIG9uUGFnZUhpZGU6IFwib25wYWdlaGlkZVwiLFxuICAgIG9uUGFnZVNob3c6IFwib25wYWdlc2hvd1wiLFxuICAgIG9uUGFzdGU6IFwib25wYXN0ZVwiLFxuICAgIG9uUGF1c2U6IFwib25wYXVzZVwiLFxuICAgIG9uUGxheTogXCJvbnBsYXlcIixcbiAgICBvblBsYXlpbmc6IFwib25wbGF5aW5nXCIsXG4gICAgb25Qb3BTdGF0ZTogXCJvbnBvcHN0YXRlXCIsXG4gICAgb25Qcm9ncmVzczogXCJvbnByb2dyZXNzXCIsXG4gICAgb25SYXRlQ2hhbmdlOiBcIm9ucmF0ZWNoYW5nZVwiLFxuICAgIG9uUmVwZWF0OiBcIm9ucmVwZWF0XCIsXG4gICAgb25SZXNldDogXCJvbnJlc2V0XCIsXG4gICAgb25SZXNpemU6IFwib25yZXNpemVcIixcbiAgICBvblNjcm9sbDogXCJvbnNjcm9sbFwiLFxuICAgIG9uU2Vla2VkOiBcIm9uc2Vla2VkXCIsXG4gICAgb25TZWVraW5nOiBcIm9uc2Vla2luZ1wiLFxuICAgIG9uU2VsZWN0OiBcIm9uc2VsZWN0XCIsXG4gICAgb25TaG93OiBcIm9uc2hvd1wiLFxuICAgIG9uU3RhbGxlZDogXCJvbnN0YWxsZWRcIixcbiAgICBvblN0b3JhZ2U6IFwib25zdG9yYWdlXCIsXG4gICAgb25TdWJtaXQ6IFwib25zdWJtaXRcIixcbiAgICBvblN1c3BlbmQ6IFwib25zdXNwZW5kXCIsXG4gICAgb25UaW1lVXBkYXRlOiBcIm9udGltZXVwZGF0ZVwiLFxuICAgIG9uVG9nZ2xlOiBcIm9udG9nZ2xlXCIsXG4gICAgb25VbmxvYWQ6IFwib251bmxvYWRcIixcbiAgICBvblZvbHVtZUNoYW5nZTogXCJvbnZvbHVtZWNoYW5nZVwiLFxuICAgIG9uV2FpdGluZzogXCJvbndhaXRpbmdcIixcbiAgICBvblpvb206IFwib256b29tXCIsXG4gICAgb3ZlcmxpbmVQb3NpdGlvbjogXCJvdmVybGluZS1wb3NpdGlvblwiLFxuICAgIG92ZXJsaW5lVGhpY2tuZXNzOiBcIm92ZXJsaW5lLXRoaWNrbmVzc1wiLFxuICAgIHBhaW50T3JkZXI6IFwicGFpbnQtb3JkZXJcIixcbiAgICBwYW5vc2UxOiBcInBhbm9zZS0xXCIsXG4gICAgcG9pbnRlckV2ZW50czogXCJwb2ludGVyLWV2ZW50c1wiLFxuICAgIHJlZmVycmVyUG9saWN5OiBcInJlZmVycmVycG9saWN5XCIsXG4gICAgcmVuZGVyaW5nSW50ZW50OiBcInJlbmRlcmluZy1pbnRlbnRcIixcbiAgICBzaGFwZVJlbmRlcmluZzogXCJzaGFwZS1yZW5kZXJpbmdcIixcbiAgICBzdG9wQ29sb3I6IFwic3RvcC1jb2xvclwiLFxuICAgIHN0b3BPcGFjaXR5OiBcInN0b3Atb3BhY2l0eVwiLFxuICAgIHN0cmlrZXRocm91Z2hQb3NpdGlvbjogXCJzdHJpa2V0aHJvdWdoLXBvc2l0aW9uXCIsXG4gICAgc3RyaWtldGhyb3VnaFRoaWNrbmVzczogXCJzdHJpa2V0aHJvdWdoLXRoaWNrbmVzc1wiLFxuICAgIHN0cm9rZURhc2hBcnJheTogXCJzdHJva2UtZGFzaGFycmF5XCIsXG4gICAgc3Ryb2tlRGFzaE9mZnNldDogXCJzdHJva2UtZGFzaG9mZnNldFwiLFxuICAgIHN0cm9rZUxpbmVDYXA6IFwic3Ryb2tlLWxpbmVjYXBcIixcbiAgICBzdHJva2VMaW5lSm9pbjogXCJzdHJva2UtbGluZWpvaW5cIixcbiAgICBzdHJva2VNaXRlckxpbWl0OiBcInN0cm9rZS1taXRlcmxpbWl0XCIsXG4gICAgc3Ryb2tlT3BhY2l0eTogXCJzdHJva2Utb3BhY2l0eVwiLFxuICAgIHN0cm9rZVdpZHRoOiBcInN0cm9rZS13aWR0aFwiLFxuICAgIHRhYkluZGV4OiBcInRhYmluZGV4XCIsXG4gICAgdGV4dEFuY2hvcjogXCJ0ZXh0LWFuY2hvclwiLFxuICAgIHRleHREZWNvcmF0aW9uOiBcInRleHQtZGVjb3JhdGlvblwiLFxuICAgIHRleHRSZW5kZXJpbmc6IFwidGV4dC1yZW5kZXJpbmdcIixcbiAgICB0eXBlT2Y6IFwidHlwZW9mXCIsXG4gICAgdW5kZXJsaW5lUG9zaXRpb246IFwidW5kZXJsaW5lLXBvc2l0aW9uXCIsXG4gICAgdW5kZXJsaW5lVGhpY2tuZXNzOiBcInVuZGVybGluZS10aGlja25lc3NcIixcbiAgICB1bmljb2RlQmlkaTogXCJ1bmljb2RlLWJpZGlcIixcbiAgICB1bmljb2RlUmFuZ2U6IFwidW5pY29kZS1yYW5nZVwiLFxuICAgIHVuaXRzUGVyRW06IFwidW5pdHMtcGVyLWVtXCIsXG4gICAgdkFscGhhYmV0aWM6IFwidi1hbHBoYWJldGljXCIsXG4gICAgdkhhbmdpbmc6IFwidi1oYW5naW5nXCIsXG4gICAgdklkZW9ncmFwaGljOiBcInYtaWRlb2dyYXBoaWNcIixcbiAgICB2TWF0aGVtYXRpY2FsOiBcInYtbWF0aGVtYXRpY2FsXCIsXG4gICAgdmVjdG9yRWZmZWN0OiBcInZlY3Rvci1lZmZlY3RcIixcbiAgICB2ZXJ0QWR2WTogXCJ2ZXJ0LWFkdi15XCIsXG4gICAgdmVydE9yaWdpblg6IFwidmVydC1vcmlnaW4teFwiLFxuICAgIHZlcnRPcmlnaW5ZOiBcInZlcnQtb3JpZ2luLXlcIixcbiAgICB3b3JkU3BhY2luZzogXCJ3b3JkLXNwYWNpbmdcIixcbiAgICB3cml0aW5nTW9kZTogXCJ3cml0aW5nLW1vZGVcIixcbiAgICB4SGVpZ2h0OiBcIngtaGVpZ2h0XCIsXG4gICAgLy8gVGhlc2Ugd2VyZSBjYW1lbGNhc2VkIGluIFRpbnkuIE5vdyBsb3dlcmNhc2VkIGluIFNWRyAyXG4gICAgcGxheWJhY2tPcmRlcjogXCJwbGF5YmFja29yZGVyXCIsXG4gICAgdGltZWxpbmVCZWdpbjogXCJ0aW1lbGluZWJlZ2luXCJcbiAgfSxcbiAgdHJhbnNmb3JtOiB0cixcbiAgcHJvcGVydGllczoge1xuICAgIGFib3V0OiBsbixcbiAgICBhY2NlbnRIZWlnaHQ6IFMsXG4gICAgYWNjdW11bGF0ZTogbnVsbCxcbiAgICBhZGRpdGl2ZTogbnVsbCxcbiAgICBhbGlnbm1lbnRCYXNlbGluZTogbnVsbCxcbiAgICBhbHBoYWJldGljOiBTLFxuICAgIGFtcGxpdHVkZTogUyxcbiAgICBhcmFiaWNGb3JtOiBudWxsLFxuICAgIGFzY2VudDogUyxcbiAgICBhdHRyaWJ1dGVOYW1lOiBudWxsLFxuICAgIGF0dHJpYnV0ZVR5cGU6IG51bGwsXG4gICAgYXppbXV0aDogUyxcbiAgICBiYW5kd2lkdGg6IG51bGwsXG4gICAgYmFzZWxpbmVTaGlmdDogbnVsbCxcbiAgICBiYXNlRnJlcXVlbmN5OiBudWxsLFxuICAgIGJhc2VQcm9maWxlOiBudWxsLFxuICAgIGJib3g6IG51bGwsXG4gICAgYmVnaW46IG51bGwsXG4gICAgYmlhczogUyxcbiAgICBieTogbnVsbCxcbiAgICBjYWxjTW9kZTogbnVsbCxcbiAgICBjYXBIZWlnaHQ6IFMsXG4gICAgY2xhc3NOYW1lOiBWLFxuICAgIGNsaXA6IG51bGwsXG4gICAgY2xpcFBhdGg6IG51bGwsXG4gICAgY2xpcFBhdGhVbml0czogbnVsbCxcbiAgICBjbGlwUnVsZTogbnVsbCxcbiAgICBjb2xvcjogbnVsbCxcbiAgICBjb2xvckludGVycG9sYXRpb246IG51bGwsXG4gICAgY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyczogbnVsbCxcbiAgICBjb2xvclByb2ZpbGU6IG51bGwsXG4gICAgY29sb3JSZW5kZXJpbmc6IG51bGwsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBjb250ZW50U2NyaXB0VHlwZTogbnVsbCxcbiAgICBjb250ZW50U3R5bGVUeXBlOiBudWxsLFxuICAgIGNyb3NzT3JpZ2luOiBudWxsLFxuICAgIGN1cnNvcjogbnVsbCxcbiAgICBjeDogbnVsbCxcbiAgICBjeTogbnVsbCxcbiAgICBkOiBudWxsLFxuICAgIGRhdGFUeXBlOiBudWxsLFxuICAgIGRlZmF1bHRBY3Rpb246IG51bGwsXG4gICAgZGVzY2VudDogUyxcbiAgICBkaWZmdXNlQ29uc3RhbnQ6IFMsXG4gICAgZGlyZWN0aW9uOiBudWxsLFxuICAgIGRpc3BsYXk6IG51bGwsXG4gICAgZHVyOiBudWxsLFxuICAgIGRpdmlzb3I6IFMsXG4gICAgZG9taW5hbnRCYXNlbGluZTogbnVsbCxcbiAgICBkb3dubG9hZDogeixcbiAgICBkeDogbnVsbCxcbiAgICBkeTogbnVsbCxcbiAgICBlZGdlTW9kZTogbnVsbCxcbiAgICBlZGl0YWJsZTogbnVsbCxcbiAgICBlbGV2YXRpb246IFMsXG4gICAgZW5hYmxlQmFja2dyb3VuZDogbnVsbCxcbiAgICBlbmQ6IG51bGwsXG4gICAgZXZlbnQ6IG51bGwsXG4gICAgZXhwb25lbnQ6IFMsXG4gICAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogbnVsbCxcbiAgICBmaWxsOiBudWxsLFxuICAgIGZpbGxPcGFjaXR5OiBTLFxuICAgIGZpbGxSdWxlOiBudWxsLFxuICAgIGZpbHRlcjogbnVsbCxcbiAgICBmaWx0ZXJSZXM6IG51bGwsXG4gICAgZmlsdGVyVW5pdHM6IG51bGwsXG4gICAgZmxvb2RDb2xvcjogbnVsbCxcbiAgICBmbG9vZE9wYWNpdHk6IG51bGwsXG4gICAgZm9jdXNhYmxlOiBudWxsLFxuICAgIGZvY3VzSGlnaGxpZ2h0OiBudWxsLFxuICAgIGZvbnRGYW1pbHk6IG51bGwsXG4gICAgZm9udFNpemU6IG51bGwsXG4gICAgZm9udFNpemVBZGp1c3Q6IG51bGwsXG4gICAgZm9udFN0cmV0Y2g6IG51bGwsXG4gICAgZm9udFN0eWxlOiBudWxsLFxuICAgIGZvbnRWYXJpYW50OiBudWxsLFxuICAgIGZvbnRXZWlnaHQ6IG51bGwsXG4gICAgZm9ybWF0OiBudWxsLFxuICAgIGZyOiBudWxsLFxuICAgIGZyb206IG51bGwsXG4gICAgZng6IG51bGwsXG4gICAgZnk6IG51bGwsXG4gICAgZzE6IERuLFxuICAgIGcyOiBEbixcbiAgICBnbHlwaE5hbWU6IERuLFxuICAgIGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsOiBudWxsLFxuICAgIGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbDogbnVsbCxcbiAgICBnbHlwaFJlZjogbnVsbCxcbiAgICBncmFkaWVudFRyYW5zZm9ybTogbnVsbCxcbiAgICBncmFkaWVudFVuaXRzOiBudWxsLFxuICAgIGhhbmRsZXI6IG51bGwsXG4gICAgaGFuZ2luZzogUyxcbiAgICBoYXRjaENvbnRlbnRVbml0czogbnVsbCxcbiAgICBoYXRjaFVuaXRzOiBudWxsLFxuICAgIGhlaWdodDogbnVsbCxcbiAgICBocmVmOiBudWxsLFxuICAgIGhyZWZMYW5nOiBudWxsLFxuICAgIGhvcml6QWR2WDogUyxcbiAgICBob3Jpek9yaWdpblg6IFMsXG4gICAgaG9yaXpPcmlnaW5ZOiBTLFxuICAgIGlkOiBudWxsLFxuICAgIGlkZW9ncmFwaGljOiBTLFxuICAgIGltYWdlUmVuZGVyaW5nOiBudWxsLFxuICAgIGluaXRpYWxWaXNpYmlsaXR5OiBudWxsLFxuICAgIGluOiBudWxsLFxuICAgIGluMjogbnVsbCxcbiAgICBpbnRlcmNlcHQ6IFMsXG4gICAgazogUyxcbiAgICBrMTogUyxcbiAgICBrMjogUyxcbiAgICBrMzogUyxcbiAgICBrNDogUyxcbiAgICBrZXJuZWxNYXRyaXg6IGxuLFxuICAgIGtlcm5lbFVuaXRMZW5ndGg6IG51bGwsXG4gICAga2V5UG9pbnRzOiBudWxsLFxuICAgIC8vIFNFTUlfQ09MT05fU0VQQVJBVEVEXG4gICAga2V5U3BsaW5lczogbnVsbCxcbiAgICAvLyBTRU1JX0NPTE9OX1NFUEFSQVRFRFxuICAgIGtleVRpbWVzOiBudWxsLFxuICAgIC8vIFNFTUlfQ09MT05fU0VQQVJBVEVEXG4gICAga2VybmluZzogbnVsbCxcbiAgICBsYW5nOiBudWxsLFxuICAgIGxlbmd0aEFkanVzdDogbnVsbCxcbiAgICBsZXR0ZXJTcGFjaW5nOiBudWxsLFxuICAgIGxpZ2h0aW5nQ29sb3I6IG51bGwsXG4gICAgbGltaXRpbmdDb25lQW5nbGU6IFMsXG4gICAgbG9jYWw6IG51bGwsXG4gICAgbWFya2VyRW5kOiBudWxsLFxuICAgIG1hcmtlck1pZDogbnVsbCxcbiAgICBtYXJrZXJTdGFydDogbnVsbCxcbiAgICBtYXJrZXJIZWlnaHQ6IG51bGwsXG4gICAgbWFya2VyVW5pdHM6IG51bGwsXG4gICAgbWFya2VyV2lkdGg6IG51bGwsXG4gICAgbWFzazogbnVsbCxcbiAgICBtYXNrQ29udGVudFVuaXRzOiBudWxsLFxuICAgIG1hc2tVbml0czogbnVsbCxcbiAgICBtYXRoZW1hdGljYWw6IG51bGwsXG4gICAgbWF4OiBudWxsLFxuICAgIG1lZGlhOiBudWxsLFxuICAgIG1lZGlhQ2hhcmFjdGVyRW5jb2Rpbmc6IG51bGwsXG4gICAgbWVkaWFDb250ZW50RW5jb2RpbmdzOiBudWxsLFxuICAgIG1lZGlhU2l6ZTogUyxcbiAgICBtZWRpYVRpbWU6IG51bGwsXG4gICAgbWV0aG9kOiBudWxsLFxuICAgIG1pbjogbnVsbCxcbiAgICBtb2RlOiBudWxsLFxuICAgIG5hbWU6IG51bGwsXG4gICAgbmF2RG93bjogbnVsbCxcbiAgICBuYXZEb3duTGVmdDogbnVsbCxcbiAgICBuYXZEb3duUmlnaHQ6IG51bGwsXG4gICAgbmF2TGVmdDogbnVsbCxcbiAgICBuYXZOZXh0OiBudWxsLFxuICAgIG5hdlByZXY6IG51bGwsXG4gICAgbmF2UmlnaHQ6IG51bGwsXG4gICAgbmF2VXA6IG51bGwsXG4gICAgbmF2VXBMZWZ0OiBudWxsLFxuICAgIG5hdlVwUmlnaHQ6IG51bGwsXG4gICAgbnVtT2N0YXZlczogbnVsbCxcbiAgICBvYnNlcnZlcjogbnVsbCxcbiAgICBvZmZzZXQ6IG51bGwsXG4gICAgb25BYm9ydDogbnVsbCxcbiAgICBvbkFjdGl2YXRlOiBudWxsLFxuICAgIG9uQWZ0ZXJQcmludDogbnVsbCxcbiAgICBvbkJlZm9yZVByaW50OiBudWxsLFxuICAgIG9uQmVnaW46IG51bGwsXG4gICAgb25DYW5jZWw6IG51bGwsXG4gICAgb25DYW5QbGF5OiBudWxsLFxuICAgIG9uQ2FuUGxheVRocm91Z2g6IG51bGwsXG4gICAgb25DaGFuZ2U6IG51bGwsXG4gICAgb25DbGljazogbnVsbCxcbiAgICBvbkNsb3NlOiBudWxsLFxuICAgIG9uQ29weTogbnVsbCxcbiAgICBvbkN1ZUNoYW5nZTogbnVsbCxcbiAgICBvbkN1dDogbnVsbCxcbiAgICBvbkRibENsaWNrOiBudWxsLFxuICAgIG9uRHJhZzogbnVsbCxcbiAgICBvbkRyYWdFbmQ6IG51bGwsXG4gICAgb25EcmFnRW50ZXI6IG51bGwsXG4gICAgb25EcmFnRXhpdDogbnVsbCxcbiAgICBvbkRyYWdMZWF2ZTogbnVsbCxcbiAgICBvbkRyYWdPdmVyOiBudWxsLFxuICAgIG9uRHJhZ1N0YXJ0OiBudWxsLFxuICAgIG9uRHJvcDogbnVsbCxcbiAgICBvbkR1cmF0aW9uQ2hhbmdlOiBudWxsLFxuICAgIG9uRW1wdGllZDogbnVsbCxcbiAgICBvbkVuZDogbnVsbCxcbiAgICBvbkVuZGVkOiBudWxsLFxuICAgIG9uRXJyb3I6IG51bGwsXG4gICAgb25Gb2N1czogbnVsbCxcbiAgICBvbkZvY3VzSW46IG51bGwsXG4gICAgb25Gb2N1c091dDogbnVsbCxcbiAgICBvbkhhc2hDaGFuZ2U6IG51bGwsXG4gICAgb25JbnB1dDogbnVsbCxcbiAgICBvbkludmFsaWQ6IG51bGwsXG4gICAgb25LZXlEb3duOiBudWxsLFxuICAgIG9uS2V5UHJlc3M6IG51bGwsXG4gICAgb25LZXlVcDogbnVsbCxcbiAgICBvbkxvYWQ6IG51bGwsXG4gICAgb25Mb2FkZWREYXRhOiBudWxsLFxuICAgIG9uTG9hZGVkTWV0YWRhdGE6IG51bGwsXG4gICAgb25Mb2FkU3RhcnQ6IG51bGwsXG4gICAgb25NZXNzYWdlOiBudWxsLFxuICAgIG9uTW91c2VEb3duOiBudWxsLFxuICAgIG9uTW91c2VFbnRlcjogbnVsbCxcbiAgICBvbk1vdXNlTGVhdmU6IG51bGwsXG4gICAgb25Nb3VzZU1vdmU6IG51bGwsXG4gICAgb25Nb3VzZU91dDogbnVsbCxcbiAgICBvbk1vdXNlT3ZlcjogbnVsbCxcbiAgICBvbk1vdXNlVXA6IG51bGwsXG4gICAgb25Nb3VzZVdoZWVsOiBudWxsLFxuICAgIG9uT2ZmbGluZTogbnVsbCxcbiAgICBvbk9ubGluZTogbnVsbCxcbiAgICBvblBhZ2VIaWRlOiBudWxsLFxuICAgIG9uUGFnZVNob3c6IG51bGwsXG4gICAgb25QYXN0ZTogbnVsbCxcbiAgICBvblBhdXNlOiBudWxsLFxuICAgIG9uUGxheTogbnVsbCxcbiAgICBvblBsYXlpbmc6IG51bGwsXG4gICAgb25Qb3BTdGF0ZTogbnVsbCxcbiAgICBvblByb2dyZXNzOiBudWxsLFxuICAgIG9uUmF0ZUNoYW5nZTogbnVsbCxcbiAgICBvblJlcGVhdDogbnVsbCxcbiAgICBvblJlc2V0OiBudWxsLFxuICAgIG9uUmVzaXplOiBudWxsLFxuICAgIG9uU2Nyb2xsOiBudWxsLFxuICAgIG9uU2Vla2VkOiBudWxsLFxuICAgIG9uU2Vla2luZzogbnVsbCxcbiAgICBvblNlbGVjdDogbnVsbCxcbiAgICBvblNob3c6IG51bGwsXG4gICAgb25TdGFsbGVkOiBudWxsLFxuICAgIG9uU3RvcmFnZTogbnVsbCxcbiAgICBvblN1Ym1pdDogbnVsbCxcbiAgICBvblN1c3BlbmQ6IG51bGwsXG4gICAgb25UaW1lVXBkYXRlOiBudWxsLFxuICAgIG9uVG9nZ2xlOiBudWxsLFxuICAgIG9uVW5sb2FkOiBudWxsLFxuICAgIG9uVm9sdW1lQ2hhbmdlOiBudWxsLFxuICAgIG9uV2FpdGluZzogbnVsbCxcbiAgICBvblpvb206IG51bGwsXG4gICAgb3BhY2l0eTogbnVsbCxcbiAgICBvcGVyYXRvcjogbnVsbCxcbiAgICBvcmRlcjogbnVsbCxcbiAgICBvcmllbnQ6IG51bGwsXG4gICAgb3JpZW50YXRpb246IG51bGwsXG4gICAgb3JpZ2luOiBudWxsLFxuICAgIG92ZXJmbG93OiBudWxsLFxuICAgIG92ZXJsYXk6IG51bGwsXG4gICAgb3ZlcmxpbmVQb3NpdGlvbjogUyxcbiAgICBvdmVybGluZVRoaWNrbmVzczogUyxcbiAgICBwYWludE9yZGVyOiBudWxsLFxuICAgIHBhbm9zZTE6IG51bGwsXG4gICAgcGF0aDogbnVsbCxcbiAgICBwYXRoTGVuZ3RoOiBTLFxuICAgIHBhdHRlcm5Db250ZW50VW5pdHM6IG51bGwsXG4gICAgcGF0dGVyblRyYW5zZm9ybTogbnVsbCxcbiAgICBwYXR0ZXJuVW5pdHM6IG51bGwsXG4gICAgcGhhc2U6IG51bGwsXG4gICAgcGluZzogVixcbiAgICBwaXRjaDogbnVsbCxcbiAgICBwbGF5YmFja09yZGVyOiBudWxsLFxuICAgIHBvaW50ZXJFdmVudHM6IG51bGwsXG4gICAgcG9pbnRzOiBudWxsLFxuICAgIHBvaW50c0F0WDogUyxcbiAgICBwb2ludHNBdFk6IFMsXG4gICAgcG9pbnRzQXRaOiBTLFxuICAgIHByZXNlcnZlQWxwaGE6IG51bGwsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogbnVsbCxcbiAgICBwcmltaXRpdmVVbml0czogbnVsbCxcbiAgICBwcm9wYWdhdGU6IG51bGwsXG4gICAgcHJvcGVydHk6IGxuLFxuICAgIHI6IG51bGwsXG4gICAgcmFkaXVzOiBudWxsLFxuICAgIHJlZmVycmVyUG9saWN5OiBudWxsLFxuICAgIHJlZlg6IG51bGwsXG4gICAgcmVmWTogbnVsbCxcbiAgICByZWw6IGxuLFxuICAgIHJldjogbG4sXG4gICAgcmVuZGVyaW5nSW50ZW50OiBudWxsLFxuICAgIHJlcGVhdENvdW50OiBudWxsLFxuICAgIHJlcGVhdER1cjogbnVsbCxcbiAgICByZXF1aXJlZEV4dGVuc2lvbnM6IGxuLFxuICAgIHJlcXVpcmVkRmVhdHVyZXM6IGxuLFxuICAgIHJlcXVpcmVkRm9udHM6IGxuLFxuICAgIHJlcXVpcmVkRm9ybWF0czogbG4sXG4gICAgcmVzb3VyY2U6IG51bGwsXG4gICAgcmVzdGFydDogbnVsbCxcbiAgICByZXN1bHQ6IG51bGwsXG4gICAgcm90YXRlOiBudWxsLFxuICAgIHJ4OiBudWxsLFxuICAgIHJ5OiBudWxsLFxuICAgIHNjYWxlOiBudWxsLFxuICAgIHNlZWQ6IG51bGwsXG4gICAgc2hhcGVSZW5kZXJpbmc6IG51bGwsXG4gICAgc2lkZTogbnVsbCxcbiAgICBzbG9wZTogbnVsbCxcbiAgICBzbmFwc2hvdFRpbWU6IG51bGwsXG4gICAgc3BlY3VsYXJDb25zdGFudDogUyxcbiAgICBzcGVjdWxhckV4cG9uZW50OiBTLFxuICAgIHNwcmVhZE1ldGhvZDogbnVsbCxcbiAgICBzcGFjaW5nOiBudWxsLFxuICAgIHN0YXJ0T2Zmc2V0OiBudWxsLFxuICAgIHN0ZERldmlhdGlvbjogbnVsbCxcbiAgICBzdGVtaDogbnVsbCxcbiAgICBzdGVtdjogbnVsbCxcbiAgICBzdGl0Y2hUaWxlczogbnVsbCxcbiAgICBzdG9wQ29sb3I6IG51bGwsXG4gICAgc3RvcE9wYWNpdHk6IG51bGwsXG4gICAgc3RyaWtldGhyb3VnaFBvc2l0aW9uOiBTLFxuICAgIHN0cmlrZXRocm91Z2hUaGlja25lc3M6IFMsXG4gICAgc3RyaW5nOiBudWxsLFxuICAgIHN0cm9rZTogbnVsbCxcbiAgICBzdHJva2VEYXNoQXJyYXk6IGxuLFxuICAgIHN0cm9rZURhc2hPZmZzZXQ6IG51bGwsXG4gICAgc3Ryb2tlTGluZUNhcDogbnVsbCxcbiAgICBzdHJva2VMaW5lSm9pbjogbnVsbCxcbiAgICBzdHJva2VNaXRlckxpbWl0OiBTLFxuICAgIHN0cm9rZU9wYWNpdHk6IFMsXG4gICAgc3Ryb2tlV2lkdGg6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgc3VyZmFjZVNjYWxlOiBTLFxuICAgIHN5bmNCZWhhdmlvcjogbnVsbCxcbiAgICBzeW5jQmVoYXZpb3JEZWZhdWx0OiBudWxsLFxuICAgIHN5bmNNYXN0ZXI6IG51bGwsXG4gICAgc3luY1RvbGVyYW5jZTogbnVsbCxcbiAgICBzeW5jVG9sZXJhbmNlRGVmYXVsdDogbnVsbCxcbiAgICBzeXN0ZW1MYW5ndWFnZTogbG4sXG4gICAgdGFiSW5kZXg6IFMsXG4gICAgdGFibGVWYWx1ZXM6IG51bGwsXG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIHRhcmdldFg6IFMsXG4gICAgdGFyZ2V0WTogUyxcbiAgICB0ZXh0QW5jaG9yOiBudWxsLFxuICAgIHRleHREZWNvcmF0aW9uOiBudWxsLFxuICAgIHRleHRSZW5kZXJpbmc6IG51bGwsXG4gICAgdGV4dExlbmd0aDogbnVsbCxcbiAgICB0aW1lbGluZUJlZ2luOiBudWxsLFxuICAgIHRpdGxlOiBudWxsLFxuICAgIHRyYW5zZm9ybUJlaGF2aW9yOiBudWxsLFxuICAgIHR5cGU6IG51bGwsXG4gICAgdHlwZU9mOiBsbixcbiAgICB0bzogbnVsbCxcbiAgICB0cmFuc2Zvcm06IG51bGwsXG4gICAgdTE6IG51bGwsXG4gICAgdTI6IG51bGwsXG4gICAgdW5kZXJsaW5lUG9zaXRpb246IFMsXG4gICAgdW5kZXJsaW5lVGhpY2tuZXNzOiBTLFxuICAgIHVuaWNvZGU6IG51bGwsXG4gICAgdW5pY29kZUJpZGk6IG51bGwsXG4gICAgdW5pY29kZVJhbmdlOiBudWxsLFxuICAgIHVuaXRzUGVyRW06IFMsXG4gICAgdmFsdWVzOiBudWxsLFxuICAgIHZBbHBoYWJldGljOiBTLFxuICAgIHZNYXRoZW1hdGljYWw6IFMsXG4gICAgdmVjdG9yRWZmZWN0OiBudWxsLFxuICAgIHZIYW5naW5nOiBTLFxuICAgIHZJZGVvZ3JhcGhpYzogUyxcbiAgICB2ZXJzaW9uOiBudWxsLFxuICAgIHZlcnRBZHZZOiBTLFxuICAgIHZlcnRPcmlnaW5YOiBTLFxuICAgIHZlcnRPcmlnaW5ZOiBTLFxuICAgIHZpZXdCb3g6IG51bGwsXG4gICAgdmlld1RhcmdldDogbnVsbCxcbiAgICB2aXNpYmlsaXR5OiBudWxsLFxuICAgIHdpZHRoOiBudWxsLFxuICAgIHdpZHRoczogbnVsbCxcbiAgICB3b3JkU3BhY2luZzogbnVsbCxcbiAgICB3cml0aW5nTW9kZTogbnVsbCxcbiAgICB4OiBudWxsLFxuICAgIHgxOiBudWxsLFxuICAgIHgyOiBudWxsLFxuICAgIHhDaGFubmVsU2VsZWN0b3I6IG51bGwsXG4gICAgeEhlaWdodDogUyxcbiAgICB5OiBudWxsLFxuICAgIHkxOiBudWxsLFxuICAgIHkyOiBudWxsLFxuICAgIHlDaGFubmVsU2VsZWN0b3I6IG51bGwsXG4gICAgejogbnVsbCxcbiAgICB6b29tQW5kUGFuOiBudWxsXG4gIH1cbn0pLCBSbyA9IC9eZGF0YVstXFx3LjpdKyQvaSwgZ3QgPSAvLVthLXpdL2csIF9vID0gL1tBLVpdL2c7XG5mdW5jdGlvbiBNbyhuLCBlKSB7XG4gIGNvbnN0IHQgPSBiZShlKTtcbiAgbGV0IHIgPSBlLCBpID0gcG47XG4gIGlmICh0IGluIG4ubm9ybWFsKVxuICAgIHJldHVybiBuLnByb3BlcnR5W24ubm9ybWFsW3RdXTtcbiAgaWYgKHQubGVuZ3RoID4gNCAmJiB0LnNsaWNlKDAsIDQpID09PSBcImRhdGFcIiAmJiBSby50ZXN0KGUpKSB7XG4gICAgaWYgKGUuY2hhckF0KDQpID09PSBcIi1cIikge1xuICAgICAgY29uc3QgbCA9IGUuc2xpY2UoNSkucmVwbGFjZShndCwgTm8pO1xuICAgICAgciA9IFwiZGF0YVwiICsgbC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGwuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGwgPSBlLnNsaWNlKDQpO1xuICAgICAgaWYgKCFndC50ZXN0KGwpKSB7XG4gICAgICAgIGxldCBvID0gbC5yZXBsYWNlKF9vLCBCbyk7XG4gICAgICAgIG8uY2hhckF0KDApICE9PSBcIi1cIiAmJiAobyA9IFwiLVwiICsgbyksIGUgPSBcImRhdGFcIiArIG87XG4gICAgICB9XG4gICAgfVxuICAgIGkgPSBPZTtcbiAgfVxuICByZXR1cm4gbmV3IGkociwgZSk7XG59XG5mdW5jdGlvbiBCbyhuKSB7XG4gIHJldHVybiBcIi1cIiArIG4udG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIE5vKG4pIHtcbiAgcmV0dXJuIG4uY2hhckF0KDEpLnRvVXBwZXJDYXNlKCk7XG59XG5jb25zdCB5dCA9IHtcbiAgY2xhc3NJZDogXCJjbGFzc0lEXCIsXG4gIGRhdGFUeXBlOiBcImRhdGF0eXBlXCIsXG4gIGl0ZW1JZDogXCJpdGVtSURcIixcbiAgc3Ryb2tlRGFzaEFycmF5OiBcInN0cm9rZURhc2hhcnJheVwiLFxuICBzdHJva2VEYXNoT2Zmc2V0OiBcInN0cm9rZURhc2hvZmZzZXRcIixcbiAgc3Ryb2tlTGluZUNhcDogXCJzdHJva2VMaW5lY2FwXCIsXG4gIHN0cm9rZUxpbmVKb2luOiBcInN0cm9rZUxpbmVqb2luXCIsXG4gIHN0cm9rZU1pdGVyTGltaXQ6IFwic3Ryb2tlTWl0ZXJsaW1pdFwiLFxuICB0eXBlT2Y6IFwidHlwZW9mXCIsXG4gIHhMaW5rQWN0dWF0ZTogXCJ4bGlua0FjdHVhdGVcIixcbiAgeExpbmtBcmNSb2xlOiBcInhsaW5rQXJjcm9sZVwiLFxuICB4TGlua0hyZWY6IFwieGxpbmtIcmVmXCIsXG4gIHhMaW5rUm9sZTogXCJ4bGlua1JvbGVcIixcbiAgeExpbmtTaG93OiBcInhsaW5rU2hvd1wiLFxuICB4TGlua1RpdGxlOiBcInhsaW5rVGl0bGVcIixcbiAgeExpbmtUeXBlOiBcInhsaW5rVHlwZVwiLFxuICB4bWxuc1hMaW5rOiBcInhtbG5zWGxpbmtcIlxufSwgam8gPSBadChbZXIsIG5yLCBpciwgbHIsIHZvXSwgXCJodG1sXCIpLCAkbyA9IFp0KFtlciwgbnIsIGlyLCBsciwgem9dLCBcInN2Z1wiKSwgb3IgPSAoXG4gIC8qKlxuICAgKiBAdHlwZSB7KFxuICAgKiAgICg8S2luZCBleHRlbmRzIE5vZGU+KHRlc3Q6IFByZWRpY2F0ZVRlc3Q8S2luZD4pID0+IEFzc2VydFByZWRpY2F0ZTxLaW5kPikgJlxuICAgKiAgICgodGVzdD86IFRlc3QpID0+IEFzc2VydEFueXRoaW5nKVxuICAgKiApfVxuICAgKi9cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGVzdH0gW3Rlc3RdXG4gICAqIEByZXR1cm5zIHtBc3NlcnRBbnl0aGluZ31cbiAgICovXG4gIGZ1bmN0aW9uKG4pIHtcbiAgICBpZiAobiA9PSBudWxsKVxuICAgICAgcmV0dXJuIHFvO1xuICAgIGlmICh0eXBlb2YgbiA9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIFZvKG4pO1xuICAgIGlmICh0eXBlb2YgbiA9PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkobikgPyBIbyhuKSA6IFVvKG4pO1xuICAgIGlmICh0eXBlb2YgbiA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByZXR1cm4gbmUobik7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgZnVuY3Rpb24sIHN0cmluZywgb3Igb2JqZWN0IGFzIHRlc3RcIik7XG4gIH1cbik7XG5mdW5jdGlvbiBIbyhuKSB7XG4gIGNvbnN0IGUgPSBbXTtcbiAgbGV0IHQgPSAtMTtcbiAgZm9yICg7ICsrdCA8IG4ubGVuZ3RoOyApXG4gICAgZVt0XSA9IG9yKG5bdF0pO1xuICByZXR1cm4gbmUocik7XG4gIGZ1bmN0aW9uIHIoLi4uaSkge1xuICAgIGxldCBsID0gLTE7XG4gICAgZm9yICg7ICsrbCA8IGUubGVuZ3RoOyApXG4gICAgICBpZiAoZVtsXS5jYWxsKHRoaXMsIC4uLmkpKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBVbyhuKSB7XG4gIHJldHVybiBuZShlKTtcbiAgZnVuY3Rpb24gZSh0KSB7XG4gICAgbGV0IHI7XG4gICAgZm9yIChyIGluIG4pXG4gICAgICBpZiAodFtyXSAhPT0gbltyXSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgIHJldHVybiAhMDtcbiAgfVxufVxuZnVuY3Rpb24gVm8obikge1xuICByZXR1cm4gbmUoZSk7XG4gIGZ1bmN0aW9uIGUodCkge1xuICAgIHJldHVybiB0ICYmIHQudHlwZSA9PT0gbjtcbiAgfVxufVxuZnVuY3Rpb24gbmUobikge1xuICByZXR1cm4gZTtcbiAgZnVuY3Rpb24gZSh0LCAuLi5yKSB7XG4gICAgcmV0dXJuICEhKHQgJiYgdHlwZW9mIHQgPT0gXCJvYmplY3RcIiAmJiBcInR5cGVcIiBpbiB0ICYmIG4uY2FsbCh0aGlzLCB0LCAuLi5yKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHFvKCkge1xuICByZXR1cm4gITA7XG59XG5jb25zdCBXbyA9ICEwLCB4dCA9ICExLCBZbyA9IFwic2tpcFwiLCBRbyA9IChcbiAgLyoqXG4gICAqIEB0eXBlIHsoXG4gICAqICAgKDxUcmVlIGV4dGVuZHMgTm9kZSwgQ2hlY2sgZXh0ZW5kcyBUZXN0Pih0cmVlOiBUcmVlLCB0ZXN0OiBDaGVjaywgdmlzaXRvcjogQnVpbGRWaXNpdG9yPFRyZWUsIENoZWNrPiwgcmV2ZXJzZT86IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB2b2lkKSAmXG4gICAqICAgKDxUcmVlIGV4dGVuZHMgTm9kZT4odHJlZTogVHJlZSwgdmlzaXRvcjogQnVpbGRWaXNpdG9yPFRyZWU+LCByZXZlcnNlPzogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQpID0+IHZvaWQpXG4gICAqICl9XG4gICAqL1xuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSB0cmVlXG4gICAqIEBwYXJhbSB7VGVzdH0gdGVzdFxuICAgKiBAcGFyYW0ge1Zpc2l0b3I8Tm9kZT59IHZpc2l0b3JcbiAgICogQHBhcmFtIHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3JldmVyc2VdXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24obiwgZSwgdCwgcikge1xuICAgIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIgJiYgKHIgPSB0LCB0ID0gZSwgZSA9IG51bGwpO1xuICAgIGNvbnN0IGkgPSBvcihlKSwgbCA9IHIgPyAtMSA6IDE7XG4gICAgbyhuLCB2b2lkIDAsIFtdKSgpO1xuICAgIGZ1bmN0aW9uIG8odSwgYSwgYykge1xuICAgICAgY29uc3QgcyA9IHUgJiYgdHlwZW9mIHUgPT0gXCJvYmplY3RcIiA/IHUgOiB7fTtcbiAgICAgIGlmICh0eXBlb2Ygcy50eXBlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgZyA9IChcbiAgICAgICAgICAvLyBgaGFzdGBcbiAgICAgICAgICB0eXBlb2Ygcy50YWdOYW1lID09IFwic3RyaW5nXCIgPyBzLnRhZ05hbWUgOiAoXG4gICAgICAgICAgICAvLyBgeGFzdGBcbiAgICAgICAgICAgIHR5cGVvZiBzLm5hbWUgPT0gXCJzdHJpbmdcIiA/IHMubmFtZSA6IHZvaWQgMFxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGgsIFwibmFtZVwiLCB7XG4gICAgICAgICAgdmFsdWU6IFwibm9kZSAoXCIgKyAodS50eXBlICsgKGcgPyBcIjxcIiArIGcgKyBcIj5cIiA6IFwiXCIpKSArIFwiKVwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGg7XG4gICAgICBmdW5jdGlvbiBoKCkge1xuICAgICAgICBsZXQgZyA9IFtdLCBkLCBtLCB5O1xuICAgICAgICBpZiAoKCFlIHx8IGkodSwgYSwgY1tjLmxlbmd0aCAtIDFdIHx8IG51bGwpKSAmJiAoZyA9IFhvKHQodSwgYykpLCBnWzBdID09PSB4dCkpXG4gICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgIGlmICh1LmNoaWxkcmVuICYmIGdbMF0gIT09IFlvKVxuICAgICAgICAgIGZvciAobSA9IChyID8gdS5jaGlsZHJlbi5sZW5ndGggOiAtMSkgKyBsLCB5ID0gYy5jb25jYXQodSk7IG0gPiAtMSAmJiBtIDwgdS5jaGlsZHJlbi5sZW5ndGg7ICkge1xuICAgICAgICAgICAgaWYgKGQgPSBvKHUuY2hpbGRyZW5bbV0sIG0sIHkpKCksIGRbMF0gPT09IHh0KVxuICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgICAgIG0gPSB0eXBlb2YgZFsxXSA9PSBcIm51bWJlclwiID8gZFsxXSA6IG0gKyBsO1xuICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICB9XG4gICAgfVxuICB9XG4pO1xuZnVuY3Rpb24gWG8obikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShuKSA/IG4gOiB0eXBlb2YgbiA9PSBcIm51bWJlclwiID8gW1dvLCBuXSA6IFtuXTtcbn1cbmNvbnN0IEtvID0gKFxuICAvKipcbiAgICogQHR5cGUgeyhcbiAgICogICAoPFRyZWUgZXh0ZW5kcyBOb2RlLCBDaGVjayBleHRlbmRzIFRlc3Q+KHRyZWU6IFRyZWUsIHRlc3Q6IENoZWNrLCB2aXNpdG9yOiBCdWlsZFZpc2l0b3I8VHJlZSwgQ2hlY2s+LCByZXZlcnNlPzogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQpID0+IHZvaWQpICZcbiAgICogICAoPFRyZWUgZXh0ZW5kcyBOb2RlPih0cmVlOiBUcmVlLCB2aXNpdG9yOiBCdWlsZFZpc2l0b3I8VHJlZT4sIHJldmVyc2U/OiBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gdm9pZClcbiAgICogKX1cbiAgICovXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IHRyZWVcbiAgICogQHBhcmFtIHtUZXN0fSB0ZXN0XG4gICAqIEBwYXJhbSB7VmlzaXRvcn0gdmlzaXRvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbcmV2ZXJzZV1cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbihuLCBlLCB0LCByKSB7XG4gICAgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB0ICE9IFwiZnVuY3Rpb25cIiAmJiAociA9IHQsIHQgPSBlLCBlID0gbnVsbCksIFFvKG4sIGUsIGksIHIpO1xuICAgIGZ1bmN0aW9uIGkobCwgbykge1xuICAgICAgY29uc3QgdSA9IG9bby5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiB0KFxuICAgICAgICBsLFxuICAgICAgICB1ID8gdS5jaGlsZHJlbi5pbmRleE9mKGwpIDogbnVsbCxcbiAgICAgICAgdVxuICAgICAgKTtcbiAgICB9XG4gIH1cbik7XG5mdW5jdGlvbiBHbyhuKSB7XG4gIGlmIChuLmFsbG93ZWRFbGVtZW50cyAmJiBuLmRpc2FsbG93ZWRFbGVtZW50cylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgXCJPbmx5IG9uZSBvZiBgYWxsb3dlZEVsZW1lbnRzYCBhbmQgYGRpc2FsbG93ZWRFbGVtZW50c2Agc2hvdWxkIGJlIGRlZmluZWRcIlxuICAgICk7XG4gIGlmIChuLmFsbG93ZWRFbGVtZW50cyB8fCBuLmRpc2FsbG93ZWRFbGVtZW50cyB8fCBuLmFsbG93RWxlbWVudClcbiAgICByZXR1cm4gKGUpID0+IHtcbiAgICAgIEtvKGUsIFwiZWxlbWVudFwiLCAodCwgciwgaSkgPT4ge1xuICAgICAgICBjb25zdCBsID0gKFxuICAgICAgICAgIC8qKiBAdHlwZSB7RWxlbWVudHxSb290fSAqL1xuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgICAgbGV0IG87XG4gICAgICAgIGlmIChuLmFsbG93ZWRFbGVtZW50cyA/IG8gPSAhbi5hbGxvd2VkRWxlbWVudHMuaW5jbHVkZXModC50YWdOYW1lKSA6IG4uZGlzYWxsb3dlZEVsZW1lbnRzICYmIChvID0gbi5kaXNhbGxvd2VkRWxlbWVudHMuaW5jbHVkZXModC50YWdOYW1lKSksICFvICYmIG4uYWxsb3dFbGVtZW50ICYmIHR5cGVvZiByID09IFwibnVtYmVyXCIgJiYgKG8gPSAhbi5hbGxvd0VsZW1lbnQodCwgciwgbCkpLCBvICYmIHR5cGVvZiByID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgcmV0dXJuIG4udW53cmFwRGlzYWxsb3dlZCAmJiB0LmNoaWxkcmVuID8gbC5jaGlsZHJlbi5zcGxpY2UociwgMSwgLi4udC5jaGlsZHJlbikgOiBsLmNoaWxkcmVuLnNwbGljZShyLCAxKSwgcjtcbiAgICAgIH0pO1xuICAgIH07XG59XG52YXIgU2UgPSB7fSwgWm8gPSB7XG4gIGdldCBleHBvcnRzKCkge1xuICAgIHJldHVybiBTZTtcbiAgfSxcbiAgc2V0IGV4cG9ydHMobikge1xuICAgIFNlID0gbjtcbiAgfVxufSwgTiA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIGt0O1xuZnVuY3Rpb24gSm8oKSB7XG4gIGlmIChrdClcbiAgICByZXR1cm4gTjtcbiAga3QgPSAxO1xuICB2YXIgbiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5lbGVtZW50XCIpLCBlID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSwgdCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgciA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKSwgaSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKSwgbCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKSwgbyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jb250ZXh0XCIpLCB1ID0gU3ltYm9sLmZvcihcInJlYWN0LnNlcnZlcl9jb250ZXh0XCIpLCBhID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpLCBjID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLCBzID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksIGggPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSwgZyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLCBkID0gU3ltYm9sLmZvcihcInJlYWN0Lm9mZnNjcmVlblwiKSwgbTtcbiAgbSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tb2R1bGUucmVmZXJlbmNlXCIpO1xuICBmdW5jdGlvbiB5KHgpIHtcbiAgICBpZiAodHlwZW9mIHggPT0gXCJvYmplY3RcIiAmJiB4ICE9PSBudWxsKSB7XG4gICAgICB2YXIgdyA9IHguJCR0eXBlb2Y7XG4gICAgICBzd2l0Y2ggKHcpIHtcbiAgICAgICAgY2FzZSBuOlxuICAgICAgICAgIHN3aXRjaCAoeCA9IHgudHlwZSwgeCkge1xuICAgICAgICAgICAgY2FzZSB0OlxuICAgICAgICAgICAgY2FzZSBpOlxuICAgICAgICAgICAgY2FzZSByOlxuICAgICAgICAgICAgY2FzZSBjOlxuICAgICAgICAgICAgY2FzZSBzOlxuICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHN3aXRjaCAoeCA9IHggJiYgeC4kJHR5cGVvZiwgeCkge1xuICAgICAgICAgICAgICAgIGNhc2UgdTpcbiAgICAgICAgICAgICAgICBjYXNlIG86XG4gICAgICAgICAgICAgICAgY2FzZSBhOlxuICAgICAgICAgICAgICAgIGNhc2UgZzpcbiAgICAgICAgICAgICAgICBjYXNlIGg6XG4gICAgICAgICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB3O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIGU6XG4gICAgICAgICAgcmV0dXJuIHc7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBOLkNvbnRleHRDb25zdW1lciA9IG8sIE4uQ29udGV4dFByb3ZpZGVyID0gbCwgTi5FbGVtZW50ID0gbiwgTi5Gb3J3YXJkUmVmID0gYSwgTi5GcmFnbWVudCA9IHQsIE4uTGF6eSA9IGcsIE4uTWVtbyA9IGgsIE4uUG9ydGFsID0gZSwgTi5Qcm9maWxlciA9IGksIE4uU3RyaWN0TW9kZSA9IHIsIE4uU3VzcGVuc2UgPSBjLCBOLlN1c3BlbnNlTGlzdCA9IHMsIE4uaXNBc3luY01vZGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gITE7XG4gIH0sIE4uaXNDb25jdXJyZW50TW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhMTtcbiAgfSwgTi5pc0NvbnRleHRDb25zdW1lciA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geSh4KSA9PT0gbztcbiAgfSwgTi5pc0NvbnRleHRQcm92aWRlciA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geSh4KSA9PT0gbDtcbiAgfSwgTi5pc0VsZW1lbnQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwib2JqZWN0XCIgJiYgeCAhPT0gbnVsbCAmJiB4LiQkdHlwZW9mID09PSBuO1xuICB9LCBOLmlzRm9yd2FyZFJlZiA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geSh4KSA9PT0gYTtcbiAgfSwgTi5pc0ZyYWdtZW50ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB5KHgpID09PSB0O1xuICB9LCBOLmlzTGF6eSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geSh4KSA9PT0gZztcbiAgfSwgTi5pc01lbW8gPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHkoeCkgPT09IGg7XG4gIH0sIE4uaXNQb3J0YWwgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHkoeCkgPT09IGU7XG4gIH0sIE4uaXNQcm9maWxlciA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geSh4KSA9PT0gaTtcbiAgfSwgTi5pc1N0cmljdE1vZGUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHkoeCkgPT09IHI7XG4gIH0sIE4uaXNTdXNwZW5zZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geSh4KSA9PT0gYztcbiAgfSwgTi5pc1N1c3BlbnNlTGlzdCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geSh4KSA9PT0gcztcbiAgfSwgTi5pc1ZhbGlkRWxlbWVudFR5cGUgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB4ID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHggPT0gXCJmdW5jdGlvblwiIHx8IHggPT09IHQgfHwgeCA9PT0gaSB8fCB4ID09PSByIHx8IHggPT09IGMgfHwgeCA9PT0gcyB8fCB4ID09PSBkIHx8IHR5cGVvZiB4ID09IFwib2JqZWN0XCIgJiYgeCAhPT0gbnVsbCAmJiAoeC4kJHR5cGVvZiA9PT0gZyB8fCB4LiQkdHlwZW9mID09PSBoIHx8IHguJCR0eXBlb2YgPT09IGwgfHwgeC4kJHR5cGVvZiA9PT0gbyB8fCB4LiQkdHlwZW9mID09PSBhIHx8IHguJCR0eXBlb2YgPT09IG0gfHwgeC5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKTtcbiAgfSwgTi50eXBlT2YgPSB5LCBOO1xufVxudmFyIGogPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBidDtcbmZ1bmN0aW9uIG51KCkge1xuICByZXR1cm4gYnQgfHwgKGJ0ID0gMSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGZ1bmN0aW9uKCkge1xuICAgIHZhciBuID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIGUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCB0ID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCByID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLCBpID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLCBsID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLCBvID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksIHUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc2VydmVyX2NvbnRleHRcIiksIGEgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksIGMgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksIHMgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSwgaCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLCBnID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksIGQgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLCBtID0gITEsIHkgPSAhMSwgeCA9ICExLCB3ID0gITEsIHYgPSAhMSwgQTtcbiAgICBBID0gU3ltYm9sLmZvcihcInJlYWN0Lm1vZHVsZS5yZWZlcmVuY2VcIik7XG4gICAgZnVuY3Rpb24gXyhQKSB7XG4gICAgICByZXR1cm4gISEodHlwZW9mIFAgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgUCA9PSBcImZ1bmN0aW9uXCIgfHwgUCA9PT0gdCB8fCBQID09PSBpIHx8IHYgfHwgUCA9PT0gciB8fCBQID09PSBjIHx8IFAgPT09IHMgfHwgdyB8fCBQID09PSBkIHx8IG0gfHwgeSB8fCB4IHx8IHR5cGVvZiBQID09IFwib2JqZWN0XCIgJiYgUCAhPT0gbnVsbCAmJiAoUC4kJHR5cGVvZiA9PT0gZyB8fCBQLiQkdHlwZW9mID09PSBoIHx8IFAuJCR0eXBlb2YgPT09IGwgfHwgUC4kJHR5cGVvZiA9PT0gbyB8fCBQLiQkdHlwZW9mID09PSBhIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAgIC8vIHdlIGRvbid0IGtub3cgd2hpY2ggRmxpZ2h0IGJ1aWxkIHRoaXMgd2lsbCBlbmQgdXAgYmVpbmcgdXNlZFxuICAgICAgLy8gd2l0aC5cbiAgICAgIFAuJCR0eXBlb2YgPT09IEEgfHwgUC5nZXRNb2R1bGVJZCAhPT0gdm9pZCAwKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFQoUCkge1xuICAgICAgaWYgKHR5cGVvZiBQID09IFwib2JqZWN0XCIgJiYgUCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX24gPSBQLiQkdHlwZW9mO1xuICAgICAgICBzd2l0Y2ggKF9uKSB7XG4gICAgICAgICAgY2FzZSBuOlxuICAgICAgICAgICAgdmFyIEZuID0gUC50eXBlO1xuICAgICAgICAgICAgc3dpdGNoIChGbikge1xuICAgICAgICAgICAgICBjYXNlIHQ6XG4gICAgICAgICAgICAgIGNhc2UgaTpcbiAgICAgICAgICAgICAgY2FzZSByOlxuICAgICAgICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgICAgIGNhc2UgczpcbiAgICAgICAgICAgICAgICByZXR1cm4gRm47XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdmFyIE1uID0gRm4gJiYgRm4uJCR0eXBlb2Y7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChNbikge1xuICAgICAgICAgICAgICAgICAgY2FzZSB1OlxuICAgICAgICAgICAgICAgICAgY2FzZSBvOlxuICAgICAgICAgICAgICAgICAgY2FzZSBhOlxuICAgICAgICAgICAgICAgICAgY2FzZSBnOlxuICAgICAgICAgICAgICAgICAgY2FzZSBoOlxuICAgICAgICAgICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTW47XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgZTpcbiAgICAgICAgICAgIHJldHVybiBfbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgYiA9IG8sIEkgPSBsLCBSID0gbiwgTSA9IGEsIFggPSB0LCBDID0gZywgRiA9IGgsIEIgPSBlLCBaID0gaSwgZW4gPSByLCB1biA9IGMsIHRuID0gcywgcSA9ICExLCBKID0gITE7XG4gICAgZnVuY3Rpb24gVyhQKSB7XG4gICAgICByZXR1cm4gcSB8fCAocSA9ICEwLCBjb25zb2xlLndhcm4oXCJUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTgrLlwiKSksICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmKFApIHtcbiAgICAgIHJldHVybiBKIHx8IChKID0gITAsIGNvbnNvbGUud2FybihcIlRoZSBSZWFjdElzLmlzQ29uY3VycmVudE1vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIFJlYWN0IDE4Ky5cIikpLCAhMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcChQKSB7XG4gICAgICByZXR1cm4gVChQKSA9PT0gbztcbiAgICB9XG4gICAgZnVuY3Rpb24ga24oUCkge1xuICAgICAgcmV0dXJuIFQoUCkgPT09IGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFBuKFApIHtcbiAgICAgIHJldHVybiB0eXBlb2YgUCA9PSBcIm9iamVjdFwiICYmIFAgIT09IG51bGwgJiYgUC4kJHR5cGVvZiA9PT0gbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYm4oUCkge1xuICAgICAgcmV0dXJuIFQoUCkgPT09IGE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFkoUCkge1xuICAgICAgcmV0dXJuIFQoUCkgPT09IHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJuKFApIHtcbiAgICAgIHJldHVybiBUKFApID09PSBnO1xuICAgIH1cbiAgICBmdW5jdGlvbiBobihQKSB7XG4gICAgICByZXR1cm4gVChQKSA9PT0gaDtcbiAgICB9XG4gICAgZnVuY3Rpb24gd24oUCkge1xuICAgICAgcmV0dXJuIFQoUCkgPT09IGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNuKFApIHtcbiAgICAgIHJldHVybiBUKFApID09PSBpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSbihQKSB7XG4gICAgICByZXR1cm4gVChQKSA9PT0gcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gVm4oUCkge1xuICAgICAgcmV0dXJuIFQoUCkgPT09IGM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVlKFApIHtcbiAgICAgIHJldHVybiBUKFApID09PSBzO1xuICAgIH1cbiAgICBqLkNvbnRleHRDb25zdW1lciA9IGIsIGouQ29udGV4dFByb3ZpZGVyID0gSSwgai5FbGVtZW50ID0gUiwgai5Gb3J3YXJkUmVmID0gTSwgai5GcmFnbWVudCA9IFgsIGouTGF6eSA9IEMsIGouTWVtbyA9IEYsIGouUG9ydGFsID0gQiwgai5Qcm9maWxlciA9IFosIGouU3RyaWN0TW9kZSA9IGVuLCBqLlN1c3BlbnNlID0gdW4sIGouU3VzcGVuc2VMaXN0ID0gdG4sIGouaXNBc3luY01vZGUgPSBXLCBqLmlzQ29uY3VycmVudE1vZGUgPSBmLCBqLmlzQ29udGV4dENvbnN1bWVyID0gcCwgai5pc0NvbnRleHRQcm92aWRlciA9IGtuLCBqLmlzRWxlbWVudCA9IFBuLCBqLmlzRm9yd2FyZFJlZiA9IGJuLCBqLmlzRnJhZ21lbnQgPSBZLCBqLmlzTGF6eSA9IHJuLCBqLmlzTWVtbyA9IGhuLCBqLmlzUG9ydGFsID0gd24sIGouaXNQcm9maWxlciA9IFNuLCBqLmlzU3RyaWN0TW9kZSA9IFJuLCBqLmlzU3VzcGVuc2UgPSBWbiwgai5pc1N1c3BlbnNlTGlzdCA9IGVlLCBqLmlzVmFsaWRFbGVtZW50VHlwZSA9IF8sIGoudHlwZU9mID0gVDtcbiAgfSgpKSwgajtcbn1cbihmdW5jdGlvbihuKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIiA/IG4uZXhwb3J0cyA9IEpvKCkgOiBuLmV4cG9ydHMgPSBudSgpO1xufSkoWm8pO1xuY29uc3QgZXUgPSAvKiBAX19QVVJFX18gKi8gZHIoU2UpO1xuZnVuY3Rpb24gdHUobikge1xuICBjb25zdCBlID0gKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbG9va3MgbGlrZSBhIG5vZGUuXG4gICAgbiAmJiB0eXBlb2YgbiA9PSBcIm9iamVjdFwiICYmIG4udHlwZSA9PT0gXCJ0ZXh0XCIgPyAoXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGxvb2tzIGxpa2UgYSB0ZXh0LlxuICAgICAgbi52YWx1ZSB8fCBcIlwiXG4gICAgKSA6IG5cbiAgKTtcbiAgcmV0dXJuIHR5cGVvZiBlID09IFwic3RyaW5nXCIgJiYgZS5yZXBsYWNlKC9bIFxcdFxcblxcZlxccl0vZywgXCJcIikgPT09IFwiXCI7XG59XG5mdW5jdGlvbiBydShuKSB7XG4gIHJldHVybiBuLmpvaW4oXCIgXCIpLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIGl1KG4sIGUpIHtcbiAgY29uc3QgdCA9IGUgfHwge307XG4gIHJldHVybiAobltuLmxlbmd0aCAtIDFdID09PSBcIlwiID8gWy4uLm4sIFwiXCJdIDogbikuam9pbihcbiAgICAodC5wYWRSaWdodCA/IFwiIFwiIDogXCJcIikgKyBcIixcIiArICh0LnBhZExlZnQgPT09ICExID8gXCJcIiA6IFwiIFwiKVxuICApLnRyaW0oKTtcbn1cbnZhciBHbiA9IHt9LCBsdSA9IHtcbiAgZ2V0IGV4cG9ydHMoKSB7XG4gICAgcmV0dXJuIEduO1xuICB9LFxuICBzZXQgZXhwb3J0cyhuKSB7XG4gICAgR24gPSBuO1xuICB9XG59LCB3dCA9IC9cXC9cXCpbXipdKlxcKisoW14vKl1bXipdKlxcKispKlxcLy9nLCBvdSA9IC9cXG4vZywgdXUgPSAvXlxccyovLCBhdSA9IC9eKFxcKj9bLSMvKlxcXFxcXHddKyhcXFtbMC05YS16Xy1dK1xcXSk/KVxccyovLCBzdSA9IC9eOlxccyovLCBjdSA9IC9eKCg/OicoPzpcXFxcJ3wuKSo/J3xcIig/OlxcXFxcInwuKSo/XCJ8XFwoW14pXSo/XFwpfFtefTtdKSspLywgcHUgPSAvXls7XFxzXSovLCBmdSA9IC9eXFxzK3xcXHMrJC9nLCBodSA9IGBcbmAsIFN0ID0gXCIvXCIsIEV0ID0gXCIqXCIsIFRuID0gXCJcIiwgbXUgPSBcImNvbW1lbnRcIiwgZHUgPSBcImRlY2xhcmF0aW9uXCIsIGd1ID0gZnVuY3Rpb24obiwgZSkge1xuICBpZiAodHlwZW9mIG4gIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgaWYgKCFuKVxuICAgIHJldHVybiBbXTtcbiAgZSA9IGUgfHwge307XG4gIHZhciB0ID0gMSwgciA9IDE7XG4gIGZ1bmN0aW9uIGkobSkge1xuICAgIHZhciB5ID0gbS5tYXRjaChvdSk7XG4gICAgeSAmJiAodCArPSB5Lmxlbmd0aCk7XG4gICAgdmFyIHggPSBtLmxhc3RJbmRleE9mKGh1KTtcbiAgICByID0gfnggPyBtLmxlbmd0aCAtIHggOiByICsgbS5sZW5ndGg7XG4gIH1cbiAgZnVuY3Rpb24gbCgpIHtcbiAgICB2YXIgbSA9IHsgbGluZTogdCwgY29sdW1uOiByIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHkpIHtcbiAgICAgIHJldHVybiB5LnBvc2l0aW9uID0gbmV3IG8obSksIGMoKSwgeTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG8obSkge1xuICAgIHRoaXMuc3RhcnQgPSBtLCB0aGlzLmVuZCA9IHsgbGluZTogdCwgY29sdW1uOiByIH0sIHRoaXMuc291cmNlID0gZS5zb3VyY2U7XG4gIH1cbiAgby5wcm90b3R5cGUuY29udGVudCA9IG47XG4gIGZ1bmN0aW9uIHUobSkge1xuICAgIHZhciB5ID0gbmV3IEVycm9yKFxuICAgICAgZS5zb3VyY2UgKyBcIjpcIiArIHQgKyBcIjpcIiArIHIgKyBcIjogXCIgKyBtXG4gICAgKTtcbiAgICBpZiAoeS5yZWFzb24gPSBtLCB5LmZpbGVuYW1lID0gZS5zb3VyY2UsIHkubGluZSA9IHQsIHkuY29sdW1uID0gciwgeS5zb3VyY2UgPSBuLCAhZS5zaWxlbnQpXG4gICAgICB0aHJvdyB5O1xuICB9XG4gIGZ1bmN0aW9uIGEobSkge1xuICAgIHZhciB5ID0gbS5leGVjKG4pO1xuICAgIGlmICh5KSB7XG4gICAgICB2YXIgeCA9IHlbMF07XG4gICAgICByZXR1cm4gaSh4KSwgbiA9IG4uc2xpY2UoeC5sZW5ndGgpLCB5O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjKCkge1xuICAgIGEodXUpO1xuICB9XG4gIGZ1bmN0aW9uIHMobSkge1xuICAgIHZhciB5O1xuICAgIGZvciAobSA9IG0gfHwgW107IHkgPSBoKCk7IClcbiAgICAgIHkgIT09ICExICYmIG0ucHVzaCh5KTtcbiAgICByZXR1cm4gbTtcbiAgfVxuICBmdW5jdGlvbiBoKCkge1xuICAgIHZhciBtID0gbCgpO1xuICAgIGlmICghKFN0ICE9IG4uY2hhckF0KDApIHx8IEV0ICE9IG4uY2hhckF0KDEpKSkge1xuICAgICAgZm9yICh2YXIgeSA9IDI7IFRuICE9IG4uY2hhckF0KHkpICYmIChFdCAhPSBuLmNoYXJBdCh5KSB8fCBTdCAhPSBuLmNoYXJBdCh5ICsgMSkpOyApXG4gICAgICAgICsreTtcbiAgICAgIGlmICh5ICs9IDIsIFRuID09PSBuLmNoYXJBdCh5IC0gMSkpXG4gICAgICAgIHJldHVybiB1KFwiRW5kIG9mIGNvbW1lbnQgbWlzc2luZ1wiKTtcbiAgICAgIHZhciB4ID0gbi5zbGljZSgyLCB5IC0gMik7XG4gICAgICByZXR1cm4gciArPSAyLCBpKHgpLCBuID0gbi5zbGljZSh5KSwgciArPSAyLCBtKHtcbiAgICAgICAgdHlwZTogbXUsXG4gICAgICAgIGNvbW1lbnQ6IHhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnKCkge1xuICAgIHZhciBtID0gbCgpLCB5ID0gYShhdSk7XG4gICAgaWYgKHkpIHtcbiAgICAgIGlmIChoKCksICFhKHN1KSlcbiAgICAgICAgcmV0dXJuIHUoXCJwcm9wZXJ0eSBtaXNzaW5nICc6J1wiKTtcbiAgICAgIHZhciB4ID0gYShjdSksIHcgPSBtKHtcbiAgICAgICAgdHlwZTogZHUsXG4gICAgICAgIHByb3BlcnR5OiBDdCh5WzBdLnJlcGxhY2Uod3QsIFRuKSksXG4gICAgICAgIHZhbHVlOiB4ID8gQ3QoeFswXS5yZXBsYWNlKHd0LCBUbikpIDogVG5cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGEocHUpLCB3O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBkKCkge1xuICAgIHZhciBtID0gW107XG4gICAgcyhtKTtcbiAgICBmb3IgKHZhciB5OyB5ID0gZygpOyApXG4gICAgICB5ICE9PSAhMSAmJiAobS5wdXNoKHkpLCBzKG0pKTtcbiAgICByZXR1cm4gbTtcbiAgfVxuICByZXR1cm4gYygpLCBkKCk7XG59O1xuZnVuY3Rpb24gQ3Qobikge1xuICByZXR1cm4gbiA/IG4ucmVwbGFjZShmdSwgVG4pIDogVG47XG59XG52YXIgeXUgPSBndTtcbmZ1bmN0aW9uIHVyKG4sIGUpIHtcbiAgdmFyIHQgPSBudWxsO1xuICBpZiAoIW4gfHwgdHlwZW9mIG4gIT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gdDtcbiAgZm9yICh2YXIgciwgaSA9IHl1KG4pLCBsID0gdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiLCBvLCB1LCBhID0gMCwgYyA9IGkubGVuZ3RoOyBhIDwgYzsgYSsrKVxuICAgIHIgPSBpW2FdLCBvID0gci5wcm9wZXJ0eSwgdSA9IHIudmFsdWUsIGwgPyBlKG8sIHUsIHIpIDogdSAmJiAodCB8fCAodCA9IHt9KSwgdFtvXSA9IHUpO1xuICByZXR1cm4gdDtcbn1cbmx1LmV4cG9ydHMgPSB1cjtcbkduLmRlZmF1bHQgPSB1cjtcbmNvbnN0IHh1ID0gR24sIEVlID0ge30uaGFzT3duUHJvcGVydHksIGt1ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1widGFibGVcIiwgXCJ0aGVhZFwiLCBcInRib2R5XCIsIFwidGZvb3RcIiwgXCJ0clwiXSk7XG5mdW5jdGlvbiBhcihuLCBlKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgbGV0IHIgPSAtMSwgaTtcbiAgZm9yICg7ICsrciA8IGUuY2hpbGRyZW4ubGVuZ3RoOyApXG4gICAgaSA9IGUuY2hpbGRyZW5bcl0sIGkudHlwZSA9PT0gXCJlbGVtZW50XCIgPyB0LnB1c2goYnUobiwgaSwgciwgZSkpIDogaS50eXBlID09PSBcInRleHRcIiA/IChlLnR5cGUgIT09IFwiZWxlbWVudFwiIHx8ICFrdS5oYXMoZS50YWdOYW1lKSB8fCAhdHUoaSkpICYmIHQucHVzaChpLnZhbHVlKSA6IGkudHlwZSA9PT0gXCJyYXdcIiAmJiAhbi5vcHRpb25zLnNraXBIdG1sICYmIHQucHVzaChpLnZhbHVlKTtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBidShuLCBlLCB0LCByKSB7XG4gIGNvbnN0IGkgPSBuLm9wdGlvbnMsIGwgPSBpLnRyYW5zZm9ybUxpbmtVcmkgPT09IHZvaWQgMCA/IGdyIDogaS50cmFuc2Zvcm1MaW5rVXJpLCBvID0gbi5zY2hlbWEsIHUgPSBlLnRhZ05hbWUsIGEgPSB7fTtcbiAgbGV0IGMgPSBvLCBzO1xuICBpZiAoby5zcGFjZSA9PT0gXCJodG1sXCIgJiYgdSA9PT0gXCJzdmdcIiAmJiAoYyA9ICRvLCBuLnNjaGVtYSA9IGMpLCBlLnByb3BlcnRpZXMpXG4gICAgZm9yIChzIGluIGUucHJvcGVydGllcylcbiAgICAgIEVlLmNhbGwoZS5wcm9wZXJ0aWVzLCBzKSAmJiBTdShhLCBzLCBlLnByb3BlcnRpZXNbc10sIG4pO1xuICAodSA9PT0gXCJvbFwiIHx8IHUgPT09IFwidWxcIikgJiYgbi5saXN0RGVwdGgrKztcbiAgY29uc3QgaCA9IGFyKG4sIGUpO1xuICAodSA9PT0gXCJvbFwiIHx8IHUgPT09IFwidWxcIikgJiYgbi5saXN0RGVwdGgtLSwgbi5zY2hlbWEgPSBvO1xuICBjb25zdCBnID0gZS5wb3NpdGlvbiB8fCB7XG4gICAgc3RhcnQ6IHsgbGluZTogbnVsbCwgY29sdW1uOiBudWxsLCBvZmZzZXQ6IG51bGwgfSxcbiAgICBlbmQ6IHsgbGluZTogbnVsbCwgY29sdW1uOiBudWxsLCBvZmZzZXQ6IG51bGwgfVxuICB9LCBkID0gaS5jb21wb25lbnRzICYmIEVlLmNhbGwoaS5jb21wb25lbnRzLCB1KSA/IGkuY29tcG9uZW50c1t1XSA6IHUsIG0gPSB0eXBlb2YgZCA9PSBcInN0cmluZ1wiIHx8IGQgPT09IE9uLkZyYWdtZW50O1xuICBpZiAoIWV1LmlzVmFsaWRFbGVtZW50VHlwZShkKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYENvbXBvbmVudCBmb3IgbmFtZSBcXGAke3V9XFxgIG5vdCBkZWZpbmVkIG9yIGlzIG5vdCByZW5kZXJhYmxlYFxuICAgICk7XG4gIGlmIChhLmtleSA9IFtcbiAgICB1LFxuICAgIGcuc3RhcnQubGluZSxcbiAgICBnLnN0YXJ0LmNvbHVtbixcbiAgICB0XG4gIF0uam9pbihcIi1cIiksIHUgPT09IFwiYVwiICYmIGkubGlua1RhcmdldCAmJiAoYS50YXJnZXQgPSB0eXBlb2YgaS5saW5rVGFyZ2V0ID09IFwiZnVuY3Rpb25cIiA/IGkubGlua1RhcmdldChcbiAgICBTdHJpbmcoYS5ocmVmIHx8IFwiXCIpLFxuICAgIGUuY2hpbGRyZW4sXG4gICAgdHlwZW9mIGEudGl0bGUgPT0gXCJzdHJpbmdcIiA/IGEudGl0bGUgOiBudWxsXG4gICkgOiBpLmxpbmtUYXJnZXQpLCB1ID09PSBcImFcIiAmJiBsICYmIChhLmhyZWYgPSBsKFxuICAgIFN0cmluZyhhLmhyZWYgfHwgXCJcIiksXG4gICAgZS5jaGlsZHJlbixcbiAgICB0eXBlb2YgYS50aXRsZSA9PSBcInN0cmluZ1wiID8gYS50aXRsZSA6IG51bGxcbiAgKSksICFtICYmIHUgPT09IFwiY29kZVwiICYmIHIudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgci50YWdOYW1lICE9PSBcInByZVwiICYmIChhLmlubGluZSA9ICEwKSwgIW0gJiYgKHUgPT09IFwiaDFcIiB8fCB1ID09PSBcImgyXCIgfHwgdSA9PT0gXCJoM1wiIHx8IHUgPT09IFwiaDRcIiB8fCB1ID09PSBcImg1XCIgfHwgdSA9PT0gXCJoNlwiKSAmJiAoYS5sZXZlbCA9IE51bWJlci5wYXJzZUludCh1LmNoYXJBdCgxKSwgMTApKSwgdSA9PT0gXCJpbWdcIiAmJiBpLnRyYW5zZm9ybUltYWdlVXJpICYmIChhLnNyYyA9IGkudHJhbnNmb3JtSW1hZ2VVcmkoXG4gICAgU3RyaW5nKGEuc3JjIHx8IFwiXCIpLFxuICAgIFN0cmluZyhhLmFsdCB8fCBcIlwiKSxcbiAgICB0eXBlb2YgYS50aXRsZSA9PSBcInN0cmluZ1wiID8gYS50aXRsZSA6IG51bGxcbiAgKSksICFtICYmIHUgPT09IFwibGlcIiAmJiByLnR5cGUgPT09IFwiZWxlbWVudFwiKSB7XG4gICAgY29uc3QgeSA9IHd1KGUpO1xuICAgIGEuY2hlY2tlZCA9IHkgJiYgeS5wcm9wZXJ0aWVzID8gISF5LnByb3BlcnRpZXMuY2hlY2tlZCA6IG51bGwsIGEuaW5kZXggPSBmZShyLCBlKSwgYS5vcmRlcmVkID0gci50YWdOYW1lID09PSBcIm9sXCI7XG4gIH1cbiAgcmV0dXJuICFtICYmICh1ID09PSBcIm9sXCIgfHwgdSA9PT0gXCJ1bFwiKSAmJiAoYS5vcmRlcmVkID0gdSA9PT0gXCJvbFwiLCBhLmRlcHRoID0gbi5saXN0RGVwdGgpLCAodSA9PT0gXCJ0ZFwiIHx8IHUgPT09IFwidGhcIikgJiYgKGEuYWxpZ24gJiYgKGEuc3R5bGUgfHwgKGEuc3R5bGUgPSB7fSksIGEuc3R5bGUudGV4dEFsaWduID0gYS5hbGlnbiwgZGVsZXRlIGEuYWxpZ24pLCBtIHx8IChhLmlzSGVhZGVyID0gdSA9PT0gXCJ0aFwiKSksICFtICYmIHUgPT09IFwidHJcIiAmJiByLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIChhLmlzSGVhZGVyID0gci50YWdOYW1lID09PSBcInRoZWFkXCIpLCBpLnNvdXJjZVBvcyAmJiAoYVtcImRhdGEtc291cmNlcG9zXCJdID0gQXUoZykpLCAhbSAmJiBpLnJhd1NvdXJjZVBvcyAmJiAoYS5zb3VyY2VQb3NpdGlvbiA9IGUucG9zaXRpb24pLCAhbSAmJiBpLmluY2x1ZGVFbGVtZW50SW5kZXggJiYgKGEuaW5kZXggPSBmZShyLCBlKSwgYS5zaWJsaW5nQ291bnQgPSBmZShyKSksIG0gfHwgKGEubm9kZSA9IGUpLCBoLmxlbmd0aCA+IDAgPyBPbi5jcmVhdGVFbGVtZW50KGQsIGEsIGgpIDogT24uY3JlYXRlRWxlbWVudChkLCBhKTtcbn1cbmZ1bmN0aW9uIHd1KG4pIHtcbiAgbGV0IGUgPSAtMTtcbiAgZm9yICg7ICsrZSA8IG4uY2hpbGRyZW4ubGVuZ3RoOyApIHtcbiAgICBjb25zdCB0ID0gbi5jaGlsZHJlbltlXTtcbiAgICBpZiAodC50eXBlID09PSBcImVsZW1lbnRcIiAmJiB0LnRhZ05hbWUgPT09IFwiaW5wdXRcIilcbiAgICAgIHJldHVybiB0O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmUobiwgZSkge1xuICBsZXQgdCA9IC0xLCByID0gMDtcbiAgZm9yICg7ICsrdCA8IG4uY2hpbGRyZW4ubGVuZ3RoICYmIG4uY2hpbGRyZW5bdF0gIT09IGU7IClcbiAgICBuLmNoaWxkcmVuW3RdLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIHIrKztcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBTdShuLCBlLCB0LCByKSB7XG4gIGNvbnN0IGkgPSBNbyhyLnNjaGVtYSwgZSk7XG4gIGxldCBsID0gdDtcbiAgbCA9PSBudWxsIHx8IGwgIT09IGwgfHwgKEFycmF5LmlzQXJyYXkobCkgJiYgKGwgPSBpLmNvbW1hU2VwYXJhdGVkID8gaXUobCkgOiBydShsKSksIGkucHJvcGVydHkgPT09IFwic3R5bGVcIiAmJiB0eXBlb2YgbCA9PSBcInN0cmluZ1wiICYmIChsID0gRXUobCkpLCBpLnNwYWNlICYmIGkucHJvcGVydHkgPyBuW0VlLmNhbGwoeXQsIGkucHJvcGVydHkpID8geXRbaS5wcm9wZXJ0eV0gOiBpLnByb3BlcnR5XSA9IGwgOiBpLmF0dHJpYnV0ZSAmJiAobltpLmF0dHJpYnV0ZV0gPSBsKSk7XG59XG5mdW5jdGlvbiBFdShuKSB7XG4gIGNvbnN0IGUgPSB7fTtcbiAgdHJ5IHtcbiAgICB4dShuLCB0KTtcbiAgfSBjYXRjaCB7XG4gIH1cbiAgcmV0dXJuIGU7XG4gIGZ1bmN0aW9uIHQociwgaSkge1xuICAgIGNvbnN0IGwgPSByLnNsaWNlKDAsIDQpID09PSBcIi1tcy1cIiA/IGBtcy0ke3Iuc2xpY2UoNCl9YCA6IHI7XG4gICAgZVtsLnJlcGxhY2UoLy0oW2Etel0pL2csIEN1KV0gPSBpO1xuICB9XG59XG5mdW5jdGlvbiBDdShuLCBlKSB7XG4gIHJldHVybiBlLnRvVXBwZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBBdShuKSB7XG4gIHJldHVybiBbXG4gICAgbi5zdGFydC5saW5lLFxuICAgIFwiOlwiLFxuICAgIG4uc3RhcnQuY29sdW1uLFxuICAgIFwiLVwiLFxuICAgIG4uZW5kLmxpbmUsXG4gICAgXCI6XCIsXG4gICAgbi5lbmQuY29sdW1uXG4gIF0ubWFwKFN0cmluZykuam9pbihcIlwiKTtcbn1cbmNvbnN0IEF0ID0ge30uaGFzT3duUHJvcGVydHksIFB1ID0gXCJodHRwczovL2dpdGh1Yi5jb20vcmVtYXJranMvcmVhY3QtbWFya2Rvd24vYmxvYi9tYWluL2NoYW5nZWxvZy5tZFwiLCBXbiA9IHtcbiAgcGx1Z2luczogeyB0bzogXCJyZW1hcmtQbHVnaW5zXCIsIGlkOiBcImNoYW5nZS1wbHVnaW5zLXRvLXJlbWFya3BsdWdpbnNcIiB9LFxuICByZW5kZXJlcnM6IHsgdG86IFwiY29tcG9uZW50c1wiLCBpZDogXCJjaGFuZ2UtcmVuZGVyZXJzLXRvLWNvbXBvbmVudHNcIiB9LFxuICBhc3RQbHVnaW5zOiB7IGlkOiBcInJlbW92ZS1idWdneS1odG1sLWluLW1hcmtkb3duLXBhcnNlclwiIH0sXG4gIGFsbG93RGFuZ2Vyb3VzSHRtbDogeyBpZDogXCJyZW1vdmUtYnVnZ3ktaHRtbC1pbi1tYXJrZG93bi1wYXJzZXJcIiB9LFxuICBlc2NhcGVIdG1sOiB7IGlkOiBcInJlbW92ZS1idWdneS1odG1sLWluLW1hcmtkb3duLXBhcnNlclwiIH0sXG4gIHNvdXJjZTogeyB0bzogXCJjaGlsZHJlblwiLCBpZDogXCJjaGFuZ2Utc291cmNlLXRvLWNoaWxkcmVuXCIgfSxcbiAgYWxsb3dOb2RlOiB7XG4gICAgdG86IFwiYWxsb3dFbGVtZW50XCIsXG4gICAgaWQ6IFwicmVwbGFjZS1hbGxvd25vZGUtYWxsb3dlZHR5cGVzLWFuZC1kaXNhbGxvd2VkdHlwZXNcIlxuICB9LFxuICBhbGxvd2VkVHlwZXM6IHtcbiAgICB0bzogXCJhbGxvd2VkRWxlbWVudHNcIixcbiAgICBpZDogXCJyZXBsYWNlLWFsbG93bm9kZS1hbGxvd2VkdHlwZXMtYW5kLWRpc2FsbG93ZWR0eXBlc1wiXG4gIH0sXG4gIGRpc2FsbG93ZWRUeXBlczoge1xuICAgIHRvOiBcImRpc2FsbG93ZWRFbGVtZW50c1wiLFxuICAgIGlkOiBcInJlcGxhY2UtYWxsb3dub2RlLWFsbG93ZWR0eXBlcy1hbmQtZGlzYWxsb3dlZHR5cGVzXCJcbiAgfSxcbiAgaW5jbHVkZU5vZGVJbmRleDoge1xuICAgIHRvOiBcImluY2x1ZGVFbGVtZW50SW5kZXhcIixcbiAgICBpZDogXCJjaGFuZ2UtaW5jbHVkZW5vZGVpbmRleC10by1pbmNsdWRlZWxlbWVudGluZGV4XCJcbiAgfVxufTtcbmZ1bmN0aW9uIEZ1KG4pIHtcbiAgZm9yIChjb25zdCBsIGluIFduKVxuICAgIGlmIChBdC5jYWxsKFduLCBsKSAmJiBBdC5jYWxsKG4sIGwpKSB7XG4gICAgICBjb25zdCBvID0gV25bbF07XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbcmVhY3QtbWFya2Rvd25dIFdhcm5pbmc6IHBsZWFzZSAke28udG8gPyBgdXNlIFxcYCR7by50b31cXGAgaW5zdGVhZCBvZmAgOiBcInJlbW92ZVwifSBcXGAke2x9XFxgIChzZWUgPCR7UHV9IyR7by5pZH0+IGZvciBtb3JlIGluZm8pYFxuICAgICAgKSwgZGVsZXRlIFduW2xdO1xuICAgIH1cbiAgY29uc3QgZSA9IERyKCkudXNlKF9sKS51c2Uobi5yZW1hcmtQbHVnaW5zIHx8IFtdKS51c2UoVG8sIHtcbiAgICAuLi5uLnJlbWFya1JlaHlwZU9wdGlvbnMsXG4gICAgYWxsb3dEYW5nZXJvdXNIdG1sOiAhMFxuICB9KS51c2Uobi5yZWh5cGVQbHVnaW5zIHx8IFtdKS51c2UoR28sIG4pLCB0ID0gbmV3IEZ0KCk7XG4gIHR5cGVvZiBuLmNoaWxkcmVuID09IFwic3RyaW5nXCIgPyB0LnZhbHVlID0gbi5jaGlsZHJlbiA6IG4uY2hpbGRyZW4gIT09IHZvaWQgMCAmJiBuLmNoaWxkcmVuICE9PSBudWxsICYmIGNvbnNvbGUud2FybihcbiAgICBgW3JlYWN0LW1hcmtkb3duXSBXYXJuaW5nOiBwbGVhc2UgcGFzcyBhIHN0cmluZyBhcyBcXGBjaGlsZHJlblxcYCAobm90OiBcXGAke24uY2hpbGRyZW59XFxgKWBcbiAgKTtcbiAgY29uc3QgciA9IGUucnVuU3luYyhlLnBhcnNlKHQpLCB0KTtcbiAgaWYgKHIudHlwZSAhPT0gXCJyb290XCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgYHJvb3RgIG5vZGVcIik7XG4gIGxldCBpID0gT24uY3JlYXRlRWxlbWVudChcbiAgICBPbi5GcmFnbWVudCxcbiAgICB7fSxcbiAgICBhcih7IG9wdGlvbnM6IG4sIHNjaGVtYTogam8sIGxpc3REZXB0aDogMCB9LCByKVxuICApO1xuICByZXR1cm4gbi5jbGFzc05hbWUgJiYgKGkgPSBPbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBuLmNsYXNzTmFtZSB9LCBpKSksIGk7XG59XG5GdS5wcm9wVHlwZXMgPSB7XG4gIC8vIENvcmUgb3B0aW9uczpcbiAgY2hpbGRyZW46IEQuc3RyaW5nLFxuICAvLyBMYXlvdXQgb3B0aW9uczpcbiAgY2xhc3NOYW1lOiBELnN0cmluZyxcbiAgLy8gRmlsdGVyIG9wdGlvbnM6XG4gIGFsbG93RWxlbWVudDogRC5mdW5jLFxuICBhbGxvd2VkRWxlbWVudHM6IEQuYXJyYXlPZihELnN0cmluZyksXG4gIGRpc2FsbG93ZWRFbGVtZW50czogRC5hcnJheU9mKEQuc3RyaW5nKSxcbiAgdW53cmFwRGlzYWxsb3dlZDogRC5ib29sLFxuICAvLyBQbHVnaW4gb3B0aW9uczpcbiAgcmVtYXJrUGx1Z2luczogRC5hcnJheU9mKFxuICAgIEQub25lT2ZUeXBlKFtcbiAgICAgIEQub2JqZWN0LFxuICAgICAgRC5mdW5jLFxuICAgICAgRC5hcnJheU9mKFxuICAgICAgICBELm9uZU9mVHlwZShbXG4gICAgICAgICAgRC5ib29sLFxuICAgICAgICAgIEQuc3RyaW5nLFxuICAgICAgICAgIEQub2JqZWN0LFxuICAgICAgICAgIEQuZnVuYyxcbiAgICAgICAgICBELmFycmF5T2YoXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICAgICAgICAgICAgRC5hbnlcbiAgICAgICAgICApXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgXSlcbiAgKSxcbiAgcmVoeXBlUGx1Z2luczogRC5hcnJheU9mKFxuICAgIEQub25lT2ZUeXBlKFtcbiAgICAgIEQub2JqZWN0LFxuICAgICAgRC5mdW5jLFxuICAgICAgRC5hcnJheU9mKFxuICAgICAgICBELm9uZU9mVHlwZShbXG4gICAgICAgICAgRC5ib29sLFxuICAgICAgICAgIEQuc3RyaW5nLFxuICAgICAgICAgIEQub2JqZWN0LFxuICAgICAgICAgIEQuZnVuYyxcbiAgICAgICAgICBELmFycmF5T2YoXG4gICAgICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICAgICAgICAgICAgRC5hbnlcbiAgICAgICAgICApXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgXSlcbiAgKSxcbiAgLy8gVHJhbnNmb3JtIG9wdGlvbnM6XG4gIHNvdXJjZVBvczogRC5ib29sLFxuICByYXdTb3VyY2VQb3M6IEQuYm9vbCxcbiAgc2tpcEh0bWw6IEQuYm9vbCxcbiAgaW5jbHVkZUVsZW1lbnRJbmRleDogRC5ib29sLFxuICB0cmFuc2Zvcm1MaW5rVXJpOiBELm9uZU9mVHlwZShbRC5mdW5jLCBELmJvb2xdKSxcbiAgbGlua1RhcmdldDogRC5vbmVPZlR5cGUoW0QuZnVuYywgRC5zdHJpbmddKSxcbiAgdHJhbnNmb3JtSW1hZ2VVcmk6IEQuZnVuYyxcbiAgY29tcG9uZW50czogRC5vYmplY3Rcbn07XG5leHBvcnQge1xuICBGdSBhcyBkZWZhdWx0LFxuICBnciBhcyB1cmlUcmFuc2Zvcm1lclxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///995\n')}}]);