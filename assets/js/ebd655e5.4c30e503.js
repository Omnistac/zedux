"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[3293],{3144:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return u},toc:function(){return m},popupStyle:function(){return p},default:function(){return h}});var a=n(3117),o=n(102),s=(n(7294),n(3905)),i=n(3052),r=["components"],l={id:"context",title:"Context"},c=void 0,u={unversionedId:"walkthrough/context",id:"walkthrough/context",isDocsHomePage:!1,title:"Context",description:"The atomic model naturally fixes all the problems with React context. In Zedux, we can use React context with all of its benefits and none of its downsides.",source:"@site/docs/walkthrough/context.mdx",sourceDirName:"walkthrough",slug:"/walkthrough/context",permalink:"/zedux/docs/walkthrough/context",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/walkthrough/context.mdx",tags:[],version:"current",frontMatter:{id:"context",title:"Context"},sidebar:"react",previous:{title:"State Machines",permalink:"/zedux/docs/walkthrough/state-machines"},next:{title:"Suspense",permalink:"/zedux/docs/walkthrough/suspense"}},m=[{value:"Simple Example",id:"simple-example",children:[],level:2},{value:"Providing",id:"providing",children:[{value:"Multiple Instances",id:"multiple-instances",children:[],level:3}],level:2},{value:"Consuming",id:"consuming",children:[{value:"If an Instance Wasn&#39;t Provided",id:"if-an-instance-wasnt-provided",children:[{value:"Case #1: I want a default atom instance to be created, if none was provided.",id:"case-1-i-want-a-default-atom-instance-to-be-created-if-none-was-provided",children:[],level:4},{value:"Case #2: I don&#39;t ever want an instance to not be provided. Throw an error if I forget!",id:"case-2-i-dont-ever-want-an-instance-to-not-be-provided-throw-an-error-if-i-forget",children:[],level:4}],level:3}],level:2},{value:"Subscribing",id:"subscribing",children:[],level:2},{value:"Using Selectors",id:"using-selectors",children:[],level:2},{value:"Local Atoms",id:"local-atoms",children:[{value:"Example",id:"example",children:[],level:3}],level:2},{value:"Recap",id:"recap",children:[],level:2},{value:"Next Steps",id:"next-steps",children:[],level:2}],p={background:"rgba(255, 255, 255, 0.4)",boxShadow:"2px 2px 5px 1px rgba(0, 0, 0, 0.2)",padding:"12px",position:"absolute",top:"8px",right:"20px"},d={toc:m,popupStyle:p};function h(e){var t=e.components,n=(0,o.Z)(e,r);return(0,s.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"The atomic model naturally fixes all the problems with React context. In Zedux, we can use React context with all of its benefits and none of its downsides."),(0,s.kt)("p",null,"The important philosophy here is that Zedux uses ",(0,s.kt)("a",{parentName:"p",href:"https://blog.testdouble.com/posts/2021-03-19-react-context-for-dependency-injection-not-state/"},"React context for Dependency Injection, not State Management"),". That article is an excellent breakdown of this technique."),(0,s.kt)("h2",{id:"simple-example"},"Simple Example"),(0,s.kt)(i.u,{resultVar:"Parent",mdxType:"LiveEditor"},"\nconst providedAtom = atom('provided', 'the state!')\n\nfunction Child() {\n  const instance = useAtomConsumer(providedAtom)\n  const [state, setState] = useAtomState(instance)\n\n  return (\n    <>\n      <div>Child State (subscribed): {state}</div>\n      <button onClick={() => setState('new state!')}>Change</button>\n    </>\n  )\n}\n\nfunction Parent() {\n  const instance = useAtomInstance(providedAtom)\n\n  return (\n    <AtomInstanceProvider instance={instance}>\n      <div>Parent State (not subscribed): {instance.store.getState()}</div>\n      <Child />\n    </AtomInstanceProvider>\n  )\n}\n"),(0,s.kt)("h2",{id:"providing"},"Providing"),(0,s.kt)("p",null,"An atom instance can be provided over React context via ",(0,s.kt)("a",{parentName:"p",href:"../api/components/AtomInstanceProvider"},(0,s.kt)("inlineCode",{parentName:"a"},"<AtomInstanceProvider>")),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import { AtomInstanceProvider, useAtomInstance } from '@zedux/react'\n\nfunction Parent() {\n  const instance = useAtomInstance(myAtom)\n\n  return (\n    <AtomInstanceProvider instance={instance}>\n      <Child />\n    </AtomInstanceProvider>\n  )\n}\n")),(0,s.kt)("h3",{id:"multiple-instances"},"Multiple Instances"),(0,s.kt)("p",null,"To provide instances of multiple atoms from the same component, you could nest a bunch of ",(0,s.kt)("inlineCode",{parentName:"p"},"<AtomInstanceProvider>"),"s. But that isn't very aesthetically pleasing now, is it."),(0,s.kt)("p",null,"To this end, ",(0,s.kt)("inlineCode",{parentName:"p"},"AtomInstanceProvider")," accepts an ",(0,s.kt)("inlineCode",{parentName:"p"},"instances")," prop, whose value is an array of instances to provide. Only provide either an ",(0,s.kt)("inlineCode",{parentName:"p"},"instance")," or an ",(0,s.kt)("inlineCode",{parentName:"p"},"instances")," prop, not both."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"return (\n  <AtomInstanceProvider instances={[instanceA, instanceB]}>\n    {children}\n  </AtomInstanceProvider>\n)\n")),(0,s.kt)("h2",{id:"consuming"},"Consuming"),(0,s.kt)("p",null,"Consume provided instances with ",(0,s.kt)("a",{parentName:"p",href:"../api/hooks/useAtomConsumer"},(0,s.kt)("inlineCode",{parentName:"a"},"useAtomConsumer"))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { useAtomConsumer } from '@zedux/react'\n\nfunction Child() {\n  const instance = useAtomConsumer(myAtom)\n  ...\n}\n")),(0,s.kt)("h3",{id:"if-an-instance-wasnt-provided"},"If an Instance Wasn't Provided"),(0,s.kt)("p",null,"If a component uses ",(0,s.kt)("inlineCode",{parentName:"p"},"useAtomConsumer")," but no instance was provided by any parent, an empty object will be returned."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const instance = useAtomConsumer()\ninstance.invalidate() // error! instance.invalidate is not a function\n")),(0,s.kt)("p",null,"TypeScript users will be warned of this. But to get around it, you'd have to put checks before everything you try to do with that instance. This isn't very useful. In fact, it's downright annoying."),(0,s.kt)("p",null,"Fortunately (on purpose), ",(0,s.kt)("inlineCode",{parentName:"p"},"useAtomConsumer")," has two overloads that help with this:"),(0,s.kt)("h4",{id:"case-1-i-want-a-default-atom-instance-to-be-created-if-none-was-provided"},"Case #1: I want a default atom instance to be created, if none was provided."),(0,s.kt)("p",null,"You can provide an array of params to ",(0,s.kt)("inlineCode",{parentName:"p"},"useAtomConsumer"),". These params must match the params of the atom. If no atom instance was provided, Zedux will use the passed default params to locate an existing atom instance or create a new instance if it doesn't exist yet."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const instance = useAtomConsumer(myAtom, ['default instance params'])\ninstance.invalidate() // all good! Even TS is happy\n")),(0,s.kt)("p",null,"If the atom doesn't take params, you must still pass an empty array for Zedux to find/create a default instance."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const paramlessInstance = useAtomConsumer(myAtom, [])\ninstance.invalidate() // \ud83d\ude0a\n")),(0,s.kt)("h4",{id:"case-2-i-dont-ever-want-an-instance-to-not-be-provided-throw-an-error-if-i-forget"},"Case #2: I don't ever want an instance to not be provided. Throw an error if I forget!"),(0,s.kt)("p",null,"Instead of an array of default parameters, you can pass ",(0,s.kt)("inlineCode",{parentName:"p"},"true")," as the second param to ",(0,s.kt)("inlineCode",{parentName:"p"},"useAtomConsumer"),". This tells Zedux to throw an error if no atom instance was provided."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const instance = useAtomConsumer(myAtom, true)\ninstance.invalidate() // all good again! TS smiles upon you\n")),(0,s.kt)("p",null,"#failfast"),(0,s.kt)("h2",{id:"subscribing"},"Subscribing"),(0,s.kt)("p",null,"The amazing thing about using atoms for React context is that neither the providing nor consuming component subscribes to the atom instance by default. This gives you full control over rerenders."),(0,s.kt)("p",null,"Any component can set the state of the atom without subscribing to the state itself. And, of course, any component can subscribe itself to the atom instance using ",(0,s.kt)("a",{parentName:"p",href:"../api/hooks/useAtomValue"},(0,s.kt)("inlineCode",{parentName:"a"},"useAtomValue"))," or similar."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"function Parent() {\n  const instance = useAtomInstance(myAtom) // doesn't subscribe\n  const value = useAtomValue(instance) // subscribes\n  ...\n}\n\nfunction Child() {\n  const instance = useAtomConsumer(myAtom, []) // doesn't subscribe\n  const value = useAtomValue(instance) // subscribes\n  ...\n}\n")),(0,s.kt)("h2",{id:"using-selectors"},"Using Selectors"),(0,s.kt)("p",null,"A common pattern is to pass the provided atom instance to ",(0,s.kt)("a",{parentName:"p",href:"../api/hooks/useAtomSelector"},(0,s.kt)("inlineCode",{parentName:"a"},"useAtomSelector"))," to limit component rerenders."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"function Child() {\n  const instance = useAtomConsumer(myAtom, []) // doesn't subscribe\n\n  // subscribes, but only causes a rerender when `someField` changes.\n  const someField = useAtomSelector(instance, ({ someField }) => someField)\n}\n")),(0,s.kt)("h2",{id:"local-atoms"},"Local Atoms"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"../api/classes/LocalAtom"},"Local atoms")," are a type of atom that specializes in React Context."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { localAtom } from '@zedux/react'\n\nconst myContextAtom = localAtom('myContext')\n")),(0,s.kt)("p",null,"The first param of all local atoms is an optional string id. You can pass this string yourself to id local atoms manually. This can be useful e.g. when persisting/rehydrating them, or just so you know what's what when debugging. Manually-id'd local atoms can also be reused anywhere by passing the same id, just like any other normal atom."),(0,s.kt)("p",null,"If you don't pass an id, Zedux will auto-generate one every time you use the local atom in any hook or injector."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"injectAtomValue(myContextAtom) // creates a new instance\ninjectAtomInstance(myContextAtom) // creates another new instance\n\nuseAtomInstance(myContextAtom) // creates another new instance\nuseAtomState(myContextAtom) // creates another new instance\nuseAtomState(myContextAtom, []) // creates another new instance\n\nuseAtomInstance(myContextAtom, ['manual-id']) // creates another new instance\nuseAtomInstance(myContextAtom, ['manual-id']) // reuses the 'manual-id' instance\n")),(0,s.kt)("p",null,"Local atoms also always set ",(0,s.kt)("a",{parentName:"p",href:"../api/classes/Atom#ttl"},(0,s.kt)("inlineCode",{parentName:"a"},"ttl"))," to ",(0,s.kt)("inlineCode",{parentName:"p"},"0"),", which will clean up atom instances immediately when all components using the atom instance unmount."),(0,s.kt)("h3",{id:"example"},"Example"),(0,s.kt)("p",null,"Local atoms are useful when you just want to provide different atom instances to different component trees."),(0,s.kt)(i.u,{extraScope:{popupStyle:p},resultVar:"Popups",mdxType:"LiveEditor"},"\nconst popupAtom = localAtom('popup', () => ({ isOpen: false }))\n\nfunction Popup() {\n  const [{ isOpen }, setVal] = useAtomState(useAtomConsumer(popupAtom, []))\n  const toggle = () => setVal(val => ({ ...val, isOpen: !val.isOpen }))\n\n  return (\n    <div>\n      <button onClick={toggle}>\n        {isOpen ? 'Close' : 'Open'}\n      </button>\n      {isOpen && (\n        <div style={popupStyle} onClick={toggle}>\n          I Am Open!!\n        </div>\n      )}\n    </div>\n  )\n}\n\nfunction Popups() {\n  const instanceA = useAtomInstance(popupAtom)\n  const instanceB = useAtomInstance(popupAtom)\n\n  return (\n    <>\n      <AtomInstanceProvider instance={instanceA}>\n        <Popup />\n      </AtomInstanceProvider>\n      <AtomInstanceProvider instance={instanceB}>\n        <Popup />\n      </AtomInstanceProvider>\n    </>\n  )\n}\n"),(0,s.kt)("h2",{id:"recap"},"Recap"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Atom instances can be provided over React context via ",(0,s.kt)("a",{parentName:"li",href:"../api/components/AtomInstanceProvider"},(0,s.kt)("inlineCode",{parentName:"a"},"<AtomInstanceProvider>")),"."),(0,s.kt)("li",{parentName:"ul"},"Atom instances can be consumed from React context via ",(0,s.kt)("a",{parentName:"li",href:"../api/hooks/useAtomConsumer"},(0,s.kt)("inlineCode",{parentName:"a"},"useAtomConsumer")),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"useAtomConsumer(myAtom, [...defaultParams])")," creates an atom instance with ",(0,s.kt)("inlineCode",{parentName:"li"},"defaultParams")," if no instance was provided."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"useAtomConsumer(myAtom, true)")," throws an error if no atom instance was provided."),(0,s.kt)("li",{parentName:"ul"},"You can subscribe any component to an atom instance by using ",(0,s.kt)("a",{parentName:"li",href:"../api/hooks/useAtomValue"},(0,s.kt)("inlineCode",{parentName:"a"},"useAtomValue"))," or any other hook that creates a ",(0,s.kt)("a",{parentName:"li",href:"../api/glossary#dynamic-graph-dependency"},"dynamic graph dependency"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"useAtomSelector")," will only rerender the component when the selector result changes."),(0,s.kt)("li",{parentName:"ul"},"Local atoms set their first param to an optional string, which can be used to create multiple atom instances without specifying unique ids.")),(0,s.kt)("h2",{id:"next-steps"},"Next Steps"),(0,s.kt)("p",null,"Let's continue exploring advanced React usage by looking at ",(0,s.kt)("a",{parentName:"p",href:"suspense"},"React suspense"),"."))}h.isMDXComponent=!0}}]);