(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[9259],{7384:function(e,t,a){"use strict";a.r(t),a.d(t,{frontMatter:function(){return i},metadata:function(){return n},toc:function(){return p},default:function(){return c}});var r=a(4034),o=a(9973),s=(a(7294),a(3905)),i={id:"api",title:"api"},n={unversionedId:"api/factories/api",id:"api/factories/api",isDocsHomePage:!1,title:"api",description:"`ts",source:"@site/docs/api/factories/api.mdx",sourceDirName:"api/factories",slug:"/api/factories/api",permalink:"/zedux/docs/api/factories/api",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/factories/api.mdx",version:"current",frontMatter:{id:"api",title:"api"},sidebar:"react",previous:{title:"zeduxGlobalStore",permalink:"/zedux/docs/api/constants/zeduxGlobalStore"},next:{title:"atom",permalink:"/zedux/docs/api/factories/atom"}},p=[{value:"Examples",id:"examples",children:[]},{value:"Signature",id:"signature",children:[{value:"Overloads",id:"overloads",children:[]},{value:"<code>value</code>",id:"value",children:[]},{value:"<code>store</code>",id:"store",children:[]}]},{value:"Notes",id:"notes",children:[]}],l={toc:p};function c(e){var t=e.components,a=(0,o.Z)(e,["components"]);return(0,s.kt)("wrapper",(0,r.Z)({},l,a,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { api } from '@zedux/react'\n")),(0,s.kt)("p",null,"A factory for creating ",(0,s.kt)("a",{parentName:"p",href:"../classes/AtomApi"},"AtomApis"),"."),(0,s.kt)("h2",{id:"examples"},"Examples"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { api } from '@zedux/react'\n\nconst myApi = api()\nconst withValue = api('some value')\nconst withStore = api(createStore())\nconst withExports = api(val).setExports({ ...myExports })\nconst withPromise = api(val).setPromise(myPromise)\nconst fromApi = api(myApi)\nconst addingExports = api(withExports).addExports({ ...moreExports })\nconst overwritingExports = api(withExports).setExports({ ...newExports })\n")),(0,s.kt)("h2",{id:"signature"},"Signature"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"api(value?) => AtomApi\n")),(0,s.kt)("h3",{id:"overloads"},"Overloads"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"atom(store?) => AtomApi\n")),(0,s.kt)("h3",{id:"value"},(0,s.kt)("inlineCode",{parentName:"h3"},"value")),(0,s.kt)("p",null,"Any raw value. If this AtomApi is returned from an ",(0,s.kt)("a",{parentName:"p",href:"../glossary#evaluator"},"evaluator function"),", this value will be set as the atom instance's state."),(0,s.kt)("h3",{id:"store"},(0,s.kt)("inlineCode",{parentName:"h3"},"store")),(0,s.kt)("p",null,"A ",(0,s.kt)("a",{parentName:"p",href:"../classes/Store"},"Zedux store"),". If this AtomApi is returned from an evaluator function, this store will be set as the ",(0,s.kt)("a",{parentName:"p",href:"../classes/AtomInstance#store"},"atom instance's store"),". It should therefore be a stable reference that won't change across reevaluations, e.g. by using ",(0,s.kt)("a",{parentName:"p",href:"../injectors/injectStore"},"injectStore"),"."),(0,s.kt)("h2",{id:"notes"},"Notes"),(0,s.kt)("p",null,"See ",(0,s.kt)("a",{parentName:"p",href:"../classes/AtomApi"},"the AtomApi class")," for more info."))}c.isMDXComponent=!0}}]);