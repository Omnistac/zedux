"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[1917,668],{8911:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return m},toc:function(){return p},AtomKeyDesc:function(){return c},default:function(){return u}});var n=a(3117),o=a(102),i=(a(7294),a(3905)),s=["components"],r={id:"Atom",title:"Atom"},l=void 0,m={unversionedId:"api/classes/Atom",id:"api/classes/Atom",isDocsHomePage:!1,title:"Atom",description:"export const AtomKeyDesc = () => (",source:"@site/docs/api/classes/Atom.mdx",sourceDirName:"api/classes",slug:"/api/classes/Atom",permalink:"/zedux/docs/api/classes/Atom",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/classes/Atom.mdx",tags:[],version:"current",frontMatter:{id:"Atom",title:"Atom"},sidebar:"react",previous:{title:"Suspense",permalink:"/zedux/docs/walkthrough/suspense"},next:{title:"AtomApi",permalink:"/zedux/docs/api/classes/AtomApi"}},p=[{value:"Creation",id:"creation",children:[],level:2},{value:"Properties",id:"properties",children:[{value:"<code>.internalId</code>",id:"internalid",children:[],level:3},{value:"<code>.key</code>",id:"key",children:[],level:3},{value:"<code>.flags</code>",id:"flags",children:[],level:3},{value:"<code>.forwardPromises</code>",id:"forwardpromises",children:[],level:3},{value:"<code>.maxInstances</code>",id:"maxinstances",children:[],level:3},{value:"<code>.ttl</code>",id:"ttl",children:[],level:3}],level:2},{value:"Methods",id:"methods",children:[{value:"<code>.override</code>",id:"override",children:[{value:"<code>newValue</code>",id:"newvalue",children:[],level:4}],level:3}],level:2},{value:"Extending",id:"extending",children:[],level:2}],c=function(){return(0,i.kt)("div",null,"The key is the key to Dependency Injection - it's how ecosystems know which atoms to override. It also aids development - many errors will log the key of the atom they originated in. Keys also help with a codebase's grepability.")},d={toc:p,AtomKeyDesc:c};function u(e){var t=e.components,a=(0,o.Z)(e,s);return(0,i.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The standard, default atom type. Instances of this class are passed to most of Zedux' hooks and injectors."),(0,i.kt)("p",null,'An atom defines a template that Zedux will use to create atom instances. Do not confuse "atom instances" with instances of this Atom class! Atom instances are actually instances of ',(0,i.kt)("a",{parentName:"p",href:"AtomInstance"},"the AtomInstance class"),' \ud83e\udd15. We refer to instances of this Atom class as simply "atoms".'),(0,i.kt)("h2",{id:"creation"},"Creation"),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"../factories/atom"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"atom()")," factory")," to create atoms:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Atom, atom } from '@zedux/react'\n\nconst exampleAtom = atom('example', 'initial state')\n\nexampleAtom instanceof Atom // true\n")),(0,i.kt)("h2",{id:"properties"},"Properties"),(0,i.kt)("p",null,"This class exposes the following properties:"),(0,i.kt)("h3",{id:"internalid"},(0,i.kt)("inlineCode",{parentName:"h3"},".internalId")),(0,i.kt)("p",null,"A string. Readonly. All atoms generate a basic, incrementing, unique id. Zedux uses this internally."),(0,i.kt)("h3",{id:"key"},(0,i.kt)("inlineCode",{parentName:"h3"},".key")),(0,i.kt)("p",null,"A string. Will always be set. This is the first parameter passed to ",(0,i.kt)("a",{parentName:"p",href:"../factories/atom"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"atom()")," factory"),"."),(0,i.kt)(c,{mdxType:"AtomKeyDesc"}),(0,i.kt)("h3",{id:"flags"},(0,i.kt)("inlineCode",{parentName:"h3"},".flags")),(0,i.kt)("p",null,"An array of strings. May be undefined. The flags that will be checked alongside an ",(0,i.kt)("a",{parentName:"p",href:"Ecosystem#flags"},"ecosystem's flags")," to warn about unsafe atoms being used in certain environments."),(0,i.kt)("p",null,"Set this via the ",(0,i.kt)("a",{parentName:"p",href:"../types/AtomConfig#flags"},"AtomConfig option")," passed to ",(0,i.kt)("a",{parentName:"p",href:"../factories/atom"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"atom()")," factory"),"."),(0,i.kt)("h3",{id:"forwardpromises"},(0,i.kt)("inlineCode",{parentName:"h3"},".forwardPromises")),(0,i.kt)("p",null,"A boolean. May be undefined. If not set, the ",(0,i.kt)("a",{parentName:"p",href:"Ecosystem#defaultforwardpromises"},"ecosystem's ",(0,i.kt)("inlineCode",{parentName:"a"},".defaultForwardPromises")," property")," will be used. If set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", this atom's instances will create a default ",(0,i.kt)("a",{parentName:"p",href:"AtomInstance#promise"},(0,i.kt)("inlineCode",{parentName:"a"},"promise")," property")," that is effectively a ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.all()")," of the atom instance's initial dependencies' promises."),(0,i.kt)("p",null,"No default promise will be created if:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"None of the initial dependencies have promises."),(0,i.kt)("li",{parentName:"ul"},"A promise is set manually via ",(0,i.kt)("a",{parentName:"li",href:"AtomApi#setpromise"},"AtomApi's ",(0,i.kt)("inlineCode",{parentName:"a"},".setPromise()")),".")),(0,i.kt)("p",null,"Setting this option overrides the ",(0,i.kt)("inlineCode",{parentName:"p"},".defaultForwardPromises")," config option set at ",(0,i.kt)("a",{parentName:"p",href:"Ecosystem#defaultforwardpromises"},"the ecosystem level"),"."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../../walkthrough/suspense"},"the suspense walkthrough")," for examples."),(0,i.kt)("p",null,"Set this via the ",(0,i.kt)("a",{parentName:"p",href:"../types/AtomConfig#forwardpromises"},"AtomConfig option")," passed to ",(0,i.kt)("a",{parentName:"p",href:"../factories/atom"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"atom()")," factory"),"."),(0,i.kt)("h3",{id:"maxinstances"},(0,i.kt)("inlineCode",{parentName:"h3"},".maxInstances")),(0,i.kt)("p",null,"A number. May be undefined. Indicates the largest ideal cache size of the atom."),(0,i.kt)("p",null,"When more than ",(0,i.kt)("inlineCode",{parentName:"p"},"maxInstances")," number of atom instances of this atom are created in an ecosystem, Zedux' behavior will change regarding the cleanup of those instances. Zedux will ignore ",(0,i.kt)("inlineCode",{parentName:"p"},"ttl")," and instantly clean up instances when they go stale until the number of instances is back within ",(0,i.kt)("inlineCode",{parentName:"p"},"maxInstances"),"."),(0,i.kt)("p",null,"Set this via the ",(0,i.kt)("a",{parentName:"p",href:"../types/AtomConfig#maxinstances"},"AtomConfig option")," passed to ",(0,i.kt)("a",{parentName:"p",href:"../factories/atom"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"atom()")," factory"),"."),(0,i.kt)("h3",{id:"ttl"},(0,i.kt)("inlineCode",{parentName:"h3"},".ttl")),(0,i.kt)("p",null,"A number. May be undefined. If not set, the ",(0,i.kt)("a",{parentName:"p",href:"Ecosystem#defaultttl"},"ecosystem's ",(0,i.kt)("inlineCode",{parentName:"a"},"defaultTtl"))," will be used. If the ecosystem doesn't set a default, instances of this atom will live forever by default. Setting this value will override any default."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Set to ",(0,i.kt)("inlineCode",{parentName:"li"},"-1")," to make this atom's instances live forever."),(0,i.kt)("li",{parentName:"ul"},"Set to ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," to make all atom instances in this ecosystem die by default as soon as they go stale."),(0,i.kt)("li",{parentName:"ul"},"Set to any positive integer to make atoms live in a stale state for ",(0,i.kt)("inlineCode",{parentName:"li"},"<ttl>")," milliseconds before being cleaned up.")),(0,i.kt)("p",null,"This option can be overridden and configured more granularly by the atom instances themselves via ",(0,i.kt)("a",{parentName:"p",href:"AtomApi#setttl"},"AtomApi#setTtl"),"."),(0,i.kt)("p",null,"Set this via the ",(0,i.kt)("a",{parentName:"p",href:"../types/AtomConfig#ttl"},"AtomConfig option")," passed to ",(0,i.kt)("a",{parentName:"p",href:"../factories/atom"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"atom()")," factory"),"."),(0,i.kt)("h2",{id:"methods"},"Methods"),(0,i.kt)("p",null,"This class exposes the following methods:"),(0,i.kt)("h3",{id:"override"},(0,i.kt)("inlineCode",{parentName:"h3"},".override")),(0,i.kt)("p",null,"Creates an exact clone of this atom, but with a different value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},".override(newValue) => Atom\n")),(0,i.kt)("p",null,"Returns the new atom."),(0,i.kt)("h4",{id:"newvalue"},(0,i.kt)("inlineCode",{parentName:"h4"},"newValue")),(0,i.kt)("p",null,"Can be any of the same ",(0,i.kt)("a",{parentName:"p",href:"../factories/atom#value"},"six value types")," that ",(0,i.kt)("inlineCode",{parentName:"p"},"atom()")," accepts."),(0,i.kt)("h2",{id:"extending"},"Extending"),(0,i.kt)("p",null,"When creating your own, custom atom types, you'll usually want to extend this class. Creating your own atom types is an advanced feature and we're not currently documenting it as the internals of these classes may change."))}u.isMDXComponent=!0},1098:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return m},contentTitle:function(){return p},metadata:function(){return c},toc:function(){return d},default:function(){return h}});var n=a(3117),o=a(102),i=(a(7294),a(3905)),s=a(3052),r=a(8911),l=["components"],m={id:"atom",title:"atom"},p=void 0,c={unversionedId:"api/factories/atom",id:"api/factories/atom",isDocsHomePage:!1,title:"atom",description:"Where it all starts. atom() is a factory for creating normal, everyday atoms. These atoms are actually instances of the Atom class.",source:"@site/docs/api/factories/atom.mdx",sourceDirName:"api/factories",slug:"/api/factories/atom",permalink:"/zedux/docs/api/factories/atom",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/factories/atom.mdx",tags:[],version:"current",frontMatter:{id:"atom",title:"atom"},sidebar:"react",previous:{title:"api",permalink:"/zedux/docs/api/factories/api"},next:{title:"createActor",permalink:"/zedux/docs/api/factories/createActor"}},d=[{value:"Example",id:"example",children:[],level:2},{value:"Signature",id:"signature",children:[{value:"Overloads",id:"overloads",children:[],level:3},{value:"<code>key</code>",id:"key",children:[],level:3},{value:"<code>value</code>",id:"value",children:[],level:3},{value:"<code>config</code>",id:"config",children:[],level:3}],level:2},{value:"Typescript",id:"typescript",children:[],level:2}],u={toc:d};function h(e){var t=e.components,a=(0,o.Z)(e,l);return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { atom } from '@zedux/react'\n")),(0,i.kt)("p",null,"Where it all starts. ",(0,i.kt)("inlineCode",{parentName:"p"},"atom()")," is a factory for creating normal, everyday atoms. These atoms are actually instances of ",(0,i.kt)("a",{parentName:"p",href:"../classes/Atom"},"the Atom class"),"."),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)(s.u,{resultVar:"App",mdxType:"LiveEditor"},"\nconst simpleAtom = atom('simple', 'super simple state stuffs')\n\nconst complexAtom = atom('complex', () => {\n  const store = injectStore({ date: new Date() })\n\n  injectEffect(() => {\n    const intervalId = setInterval(\n      () => store.setState({ date: new Date() }),\n      1000\n    )\n\n    return () => clearInterval(intervalId)\n  }, [])\n\n  return store\n}, {\n  flags: ['side-effect']\n})\n\nfunction App() {\n  const simple = useAtomValue(simpleAtom)\n  const { date } = useAtomValue(complexAtom)\n\n  return (\n    <>\n      <div>simple state: {simple}</div>\n      <div>complex state: {date.toLocaleTimeString()}</div>\n    </>\n  )\n}\n"),(0,i.kt)("h2",{id:"signature"},"Signature"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"atom(key, value, config?) => Atom\n")),(0,i.kt)("h3",{id:"overloads"},"Overloads"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"atom(key, value, config?) => Atom\natom(key, store, config?) => Atom\natom(key, api, config?) => Atom\natom(key, (...params) => value, config?) => Atom\natom(key, (...params) => store, config?) => Atom\natom(key, (...params) => api, config?) => Atom\n")),(0,i.kt)("h3",{id:"key"},(0,i.kt)("inlineCode",{parentName:"h3"},"key")),(0,i.kt)("p",null,"Required. A string. The key should typically be unique, though there are cases (e.g. for DI) where you won't make them unique. The key identifies the atom in ecosystems where it's used."),(0,i.kt)(r.AtomKeyDesc,{mdxType:"AtomKeyDesc"}),(0,i.kt)("h3",{id:"value"},(0,i.kt)("inlineCode",{parentName:"h3"},"value")),(0,i.kt)("p",null,"Required. Can be one of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A raw value"),(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("a",{parentName:"li",href:"../classes/Store"},"store")," that holds the value"),(0,i.kt)("li",{parentName:"ul"},"An ",(0,i.kt)("a",{parentName:"li",href:"../classes/AtomApi"},"AtomApi")," that wraps either a store or raw value"),(0,i.kt)("li",{parentName:"ul"},"An evaluator function that returns a raw value"),(0,i.kt)("li",{parentName:"ul"},"An evaluator function that returns a store"),(0,i.kt)("li",{parentName:"ul"},"An evaluator function that returns an AtomApi")),(0,i.kt)("h3",{id:"config"},(0,i.kt)("inlineCode",{parentName:"h3"},"config")),(0,i.kt)("p",null,"Optional. An ",(0,i.kt)("a",{parentName:"p",href:"../types/AtomConfig"},"AtomConfig")," object. If it isn't passed, ",(0,i.kt)("inlineCode",{parentName:"p"},"ttl")," will default to -1, which means the atom instance never dies."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"atom('key', getter, { ttl: 0 })\n")),(0,i.kt)("h2",{id:"typescript"},"Typescript"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"atom")," can be given 3 generics:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"State - the type of the state this atom holds. Can be absolutely anything. Does not have to be serializable."),(0,i.kt)("li",{parentName:"ul"},"Params - the tuple of parameters the evaluator function accepts. Must be an array or tuple type."),(0,i.kt)("li",{parentName:"ul"},"Exports - the object of properties this atom exports. Must be a record (object) type.")),(0,i.kt)("p",null,"You typically shouldn't need to specify any of these. They're all inferred."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { api, atom, injectStore } from '@zedux/react'\n\nconst inferredAtom = atom('inferred', (one: string, two: number) => {\n  const store = injectStore(one + two) // string + number = string\n\n  return api(store).setExports({\n    getOne: () => one,\n    getTwo: () => two,\n  })\n})\n\ninferredAtom\n// Atom<\n//   string,\n//   [one: string, two: number],\n//   { getOne: () => string; getTwo: () => number }\n// >\n")))}h.isMDXComponent=!0}}]);