"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[6540,668],{9443:function(e,t,n){var a=(0,n(7294).createContext)(void 0);t.Z=a},8911:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return m},AtomKeyDesc:function(){return c},default:function(){return u}});var a=n(3117),o=n(102),i=(n(7294),n(3905)),s=["components"],r={id:"Atom",title:"Atom"},l=void 0,p={unversionedId:"api/classes/Atom",id:"api/classes/Atom",isDocsHomePage:!1,title:"Atom",description:"export const AtomKeyDesc = () => (",source:"@site/docs/api/classes/Atom.mdx",sourceDirName:"api/classes",slug:"/api/classes/Atom",permalink:"/zedux/docs/api/classes/Atom",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/classes/Atom.mdx",tags:[],version:"current",frontMatter:{id:"Atom",title:"Atom"},sidebar:"react",previous:{title:"Suspense",permalink:"/zedux/docs/walkthrough/suspense"},next:{title:"AtomApi",permalink:"/zedux/docs/api/classes/AtomApi"}},m=[{value:"Creation",id:"creation",children:[],level:2},{value:"Properties",id:"properties",children:[{value:"<code>.internalId</code>",id:"internalid",children:[],level:3},{value:"<code>.key</code>",id:"key",children:[],level:3},{value:"<code>.flags</code>",id:"flags",children:[],level:3},{value:"<code>.forwardPromises</code>",id:"forwardpromises",children:[],level:3},{value:"<code>.maxInstances</code>",id:"maxinstances",children:[],level:3},{value:"<code>.ttl</code>",id:"ttl",children:[],level:3}],level:2},{value:"Methods",id:"methods",children:[{value:"<code>.override</code>",id:"override",children:[{value:"<code>newValue</code>",id:"newvalue",children:[],level:4}],level:3}],level:2},{value:"Extending",id:"extending",children:[],level:2}],c=function(){return(0,i.kt)("div",null,"The key is the key to Dependency Injection - it's how ecosystems know which atoms to override. It also aids development - many errors will log the key of the atom they originated in. Keys also help with a codebase's grepability.")},d={toc:m,AtomKeyDesc:c};function u(e){var t=e.components,n=(0,o.Z)(e,s);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"The standard, default atom type. Instances of this class are passed to most of Zedux' hooks and injectors."),(0,i.kt)("p",null,'An atom defines a template that Zedux will use to create atom instances. Do not confuse "atom instances" with instances of this Atom class! Atom instances are actually instances of ',(0,i.kt)("a",{parentName:"p",href:"AtomInstance"},"the AtomInstance class"),' \ud83e\udd15. We refer to instances of this Atom class as simply "atoms".'),(0,i.kt)("h2",{id:"creation"},"Creation"),(0,i.kt)("p",null,"Use ",(0,i.kt)("a",{parentName:"p",href:"../factories/atom"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"atom()")," factory")," to create atoms:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { Atom, atom } from '@zedux/react'\n\nconst exampleAtom = atom('example', 'initial state')\n\nexampleAtom instanceof Atom // true\n")),(0,i.kt)("h2",{id:"properties"},"Properties"),(0,i.kt)("p",null,"This class exposes the following properties:"),(0,i.kt)("h3",{id:"internalid"},(0,i.kt)("inlineCode",{parentName:"h3"},".internalId")),(0,i.kt)("p",null,"A string. Readonly. All atoms generate a basic, incrementing, unique id. Zedux uses this internally."),(0,i.kt)("h3",{id:"key"},(0,i.kt)("inlineCode",{parentName:"h3"},".key")),(0,i.kt)("p",null,"A string. Will always be set. This is the first parameter passed to ",(0,i.kt)("a",{parentName:"p",href:"../factories/atom"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"atom()")," factory"),"."),(0,i.kt)(c,{mdxType:"AtomKeyDesc"}),(0,i.kt)("h3",{id:"flags"},(0,i.kt)("inlineCode",{parentName:"h3"},".flags")),(0,i.kt)("p",null,"An array of strings. May be undefined. The flags that will be checked alongside an ",(0,i.kt)("a",{parentName:"p",href:"Ecosystem#flags"},"ecosystem's flags")," to warn about unsafe atoms being used in certain environments."),(0,i.kt)("p",null,"Set this via the ",(0,i.kt)("a",{parentName:"p",href:"../types/AtomConfig#flags"},"AtomConfig option")," passed to ",(0,i.kt)("a",{parentName:"p",href:"../factories/atom"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"atom()")," factory"),"."),(0,i.kt)("h3",{id:"forwardpromises"},(0,i.kt)("inlineCode",{parentName:"h3"},".forwardPromises")),(0,i.kt)("p",null,"A boolean. May be undefined. If not set, the ",(0,i.kt)("a",{parentName:"p",href:"Ecosystem#defaultforwardpromises"},"ecosystem's ",(0,i.kt)("inlineCode",{parentName:"a"},".defaultForwardPromises")," property")," will be used. If set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", this atom's instances will create a default ",(0,i.kt)("a",{parentName:"p",href:"AtomInstance#promise"},(0,i.kt)("inlineCode",{parentName:"a"},"promise")," property")," that is effectively a ",(0,i.kt)("inlineCode",{parentName:"p"},"Promise.all()")," of the atom instance's initial dependencies' promises."),(0,i.kt)("p",null,"No default promise will be created if:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"None of the initial dependencies have promises."),(0,i.kt)("li",{parentName:"ul"},"A promise is set manually via ",(0,i.kt)("a",{parentName:"li",href:"AtomApi#setpromise"},"AtomApi's ",(0,i.kt)("inlineCode",{parentName:"a"},".setPromise()")),".")),(0,i.kt)("p",null,"Setting this option overrides the ",(0,i.kt)("inlineCode",{parentName:"p"},".defaultForwardPromises")," config option set at ",(0,i.kt)("a",{parentName:"p",href:"Ecosystem#defaultforwardpromises"},"the ecosystem level"),"."),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../../walkthrough/suspense"},"the suspense walkthrough")," for examples."),(0,i.kt)("p",null,"Set this via the ",(0,i.kt)("a",{parentName:"p",href:"../types/AtomConfig#forwardpromises"},"AtomConfig option")," passed to ",(0,i.kt)("a",{parentName:"p",href:"../factories/atom"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"atom()")," factory"),"."),(0,i.kt)("h3",{id:"maxinstances"},(0,i.kt)("inlineCode",{parentName:"h3"},".maxInstances")),(0,i.kt)("p",null,"A number. May be undefined. Indicates the largest ideal cache size of the atom."),(0,i.kt)("p",null,"When more than ",(0,i.kt)("inlineCode",{parentName:"p"},"maxInstances")," number of atom instances of this atom are created in an ecosystem, Zedux' behavior will change regarding the cleanup of those instances. Zedux will ignore ",(0,i.kt)("inlineCode",{parentName:"p"},"ttl")," and instantly clean up instances when they go stale until the number of instances is back within ",(0,i.kt)("inlineCode",{parentName:"p"},"maxInstances"),"."),(0,i.kt)("p",null,"Set this via the ",(0,i.kt)("a",{parentName:"p",href:"../types/AtomConfig#maxinstances"},"AtomConfig option")," passed to ",(0,i.kt)("a",{parentName:"p",href:"../factories/atom"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"atom()")," factory"),"."),(0,i.kt)("h3",{id:"ttl"},(0,i.kt)("inlineCode",{parentName:"h3"},".ttl")),(0,i.kt)("p",null,"A number. May be undefined. If not set, the ",(0,i.kt)("a",{parentName:"p",href:"Ecosystem#defaultttl"},"ecosystem's ",(0,i.kt)("inlineCode",{parentName:"a"},"defaultTtl"))," will be used. If the ecosystem doesn't set a default, instances of this atom will live forever by default. Setting this value will override any default."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Set to ",(0,i.kt)("inlineCode",{parentName:"li"},"-1")," to make this atom's instances live forever."),(0,i.kt)("li",{parentName:"ul"},"Set to ",(0,i.kt)("inlineCode",{parentName:"li"},"0")," to make all atom instances in this ecosystem die by default as soon as they go stale."),(0,i.kt)("li",{parentName:"ul"},"Set to any positive integer to make atoms live in a stale state for ",(0,i.kt)("inlineCode",{parentName:"li"},"<ttl>")," milliseconds before being cleaned up.")),(0,i.kt)("p",null,"This option can be overridden and configured more granularly by the atom instances themselves via ",(0,i.kt)("a",{parentName:"p",href:"AtomApi#setttl"},"AtomApi#setTtl"),"."),(0,i.kt)("p",null,"Set this via the ",(0,i.kt)("a",{parentName:"p",href:"../types/AtomConfig#ttl"},"AtomConfig option")," passed to ",(0,i.kt)("a",{parentName:"p",href:"../factories/atom"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"atom()")," factory"),"."),(0,i.kt)("h2",{id:"methods"},"Methods"),(0,i.kt)("p",null,"This class exposes the following methods:"),(0,i.kt)("h3",{id:"override"},(0,i.kt)("inlineCode",{parentName:"h3"},".override")),(0,i.kt)("p",null,"Creates an exact clone of this atom, but with a different value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},".override(newValue) => Atom\n")),(0,i.kt)("p",null,"Returns the new atom."),(0,i.kt)("h4",{id:"newvalue"},(0,i.kt)("inlineCode",{parentName:"h4"},"newValue")),(0,i.kt)("p",null,"Can be any of the same ",(0,i.kt)("a",{parentName:"p",href:"../factories/atom#value"},"six value types")," that ",(0,i.kt)("inlineCode",{parentName:"p"},"atom()")," accepts."),(0,i.kt)("h2",{id:"extending"},"Extending"),(0,i.kt)("p",null,"When creating your own, custom atom types, you'll usually want to extend this class. Creating your own atom types is an advanced feature and we're not currently documenting it as the internals of these classes may change."))}u.isMDXComponent=!0},8732:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return m},default:function(){return h},frontMatter:function(){return p},metadata:function(){return c},toc:function(){return d}});var a=n(3117),o=n(102),i=(n(7294),n(3905));n(2389),n(9443);n(2822);var s=n(3052),r=n(8911),l=["components"],p={id:"ion",title:"ion"},m=void 0,c={unversionedId:"api/factories/ion",id:"api/factories/ion",isDocsHomePage:!1,title:"ion",description:"ion() is a factory for creating Ions. Ions are a type of atom that specialize in selection and derivation operations.",source:"@site/docs/api/factories/ion.mdx",sourceDirName:"api/factories",slug:"/api/factories/ion",permalink:"/zedux/docs/api/factories/ion",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/factories/ion.mdx",tags:[],version:"current",frontMatter:{id:"ion",title:"ion"},sidebar:"react",previous:{title:"ecosystem",permalink:"/zedux/docs/api/factories/ecosystem"},next:{title:"localAtom",permalink:"/zedux/docs/api/factories/localAtom"}},d=[{value:"Example",id:"example",children:[],level:2},{value:"Signature",id:"signature",children:[{value:"Overloads",id:"overloads",children:[],level:3},{value:"<code>key</code>",id:"key",children:[],level:3},{value:"<code>get</code>",id:"get",children:[],level:3},{value:"<code>set</code>",id:"set",children:[],level:3},{value:"<code>config</code>",id:"config",children:[],level:3}],level:2},{value:"Typescript",id:"typescript",children:[],level:2}],u={toc:d};function h(e){var t=e.components,n=(0,o.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { ion } from '@zedux/react'\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ion()")," is a factory for creating ",(0,i.kt)("a",{parentName:"p",href:"../classes/Ion"},"Ions"),". Ions are a type of atom that specialize in selection and derivation operations."),(0,i.kt)("p",null,"Ions are loosely based off of Recoil's ",(0,i.kt)("a",{parentName:"p",href:"https://recoiljs.org/docs/api-reference/core/selector"},"selectors"),"."),(0,i.kt)("h2",{id:"example"},"Example"),(0,i.kt)(s.u,{resultVar:"TempCelsius",mdxType:"LiveEditor"},"\nconst tempFahrenheit = atom('tempFahrenheit', 32);\n\nconst tempCelsius = ion(\n  'tempCelsius',\n  ({ get }) => ((get(tempFahrenheit) - 32) * 5) / 9,\n  ({ set }, newValue) =>\n    set(\n      tempFahrenheit,\n      (newValue * 9) / 5 + 32\n    ),\n});\n\nfunction TempCelsius() {\n  const [tempF, setTempF] = useAtomState(tempFahrenheit);\n  const [tempC, setTempC] = useAtomState(tempCelsius);\n\n  const addTenCelsius = () => setTempC(tempC + 10);\n  const addTenFahrenheit = () => setTempF(tempF + 10);\n\n  return (\n    <div>\n      Temp (Celsius): {Math.round(tempC)}\n      <br />\n      Temp (Fahrenheit): {Math.round(tempF)}\n      <br />\n      <button onClick={addTenCelsius}>Add 10 Celsius</button>\n      <br />\n      <button onClick={addTenFahrenheit}>Add 10 Fahrenheit</button>\n    </div>\n  );\n}\n"),(0,i.kt)("h2",{id:"signature"},"Signature"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"ion(key, get, set?, config?) => Ion\n")),(0,i.kt)("h3",{id:"overloads"},"Overloads"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"ion(key, get, set?) => Ion\nion(key, get, config?) => Ion\n")),(0,i.kt)("h3",{id:"key"},(0,i.kt)("inlineCode",{parentName:"h3"},"key")),(0,i.kt)("p",null,"Required. A string. The key should typically be unique, though there are cases (e.g. for DI) where you won't make them unique. The key identifies the ion in ecosystems where it's used."),(0,i.kt)(r.AtomKeyDesc,{mdxType:"AtomKeyDesc"}),(0,i.kt)("h3",{id:"get"},(0,i.kt)("inlineCode",{parentName:"h3"},"get")),(0,i.kt)("p",null,"Required. Can be one of:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"An evaluator function that returns a raw value"),(0,i.kt)("li",{parentName:"ul"},"An evaluator function that returns a ",(0,i.kt)("a",{parentName:"li",href:"../classes/Store"},"store")),(0,i.kt)("li",{parentName:"ul"},"An evaluator function that returns an ",(0,i.kt)("a",{parentName:"li",href:"../classes/AtomApi"},"AtomApi"))),(0,i.kt)("p",null,"The first parameter passed to ",(0,i.kt)("inlineCode",{parentName:"p"},"get")," will be a special ",(0,i.kt)("a",{parentName:"p",href:"../types/AtomGetters"},"AtomGetters object"),". Any parameters after that will be the actual params of the atom instance."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"ion('key', ({ ecosystem, get, getInstance }, param) => {\n  const otherVal = get(otherAtom)\n  const otherInstance = getInstance(otherAtom)\n\n  // injectors can be used\n  injectEffect(someEffect, [])\n\n  return otherVal ** 2\n})\n")),(0,i.kt)("h3",{id:"set"},(0,i.kt)("inlineCode",{parentName:"h3"},"set")),(0,i.kt)("p",null,"Optional. A function that receives a special ",(0,i.kt)("a",{parentName:"p",href:"../types/AtomSetters"},"AtomSetters object")," and returns either void or the new state of this ion atom instance."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"ion('key', getter, ({ set }, newVal) => {\n  set(otherAtom, newVal) // forward setState call to another atom instance\n})\n")),(0,i.kt)("h3",{id:"config"},(0,i.kt)("inlineCode",{parentName:"h3"},"config")),(0,i.kt)("p",null,"Optional. An ",(0,i.kt)("a",{parentName:"p",href:"../types/AtomConfig"},"AtomConfig")," object. If it isn't passed, ",(0,i.kt)("inlineCode",{parentName:"p"},"ttl")," will default to -1, which means the atom never dies."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"ion('key', getter, { ttl: 0 })\n")),(0,i.kt)("h2",{id:"typescript"},"Typescript"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ion")," can be given 3 generics:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"State - the type of the state this atom holds. Can be absolutely anything. Does not have to be serializable."),(0,i.kt)("li",{parentName:"ul"},"Params - the tuple of parameters the evaluator function accepts. Must be an array or tuple type. These are the parameters ",(0,i.kt)("em",{parentName:"li"},"after")," the ",(0,i.kt)("a",{parentName:"li",href:"../types/AtomGetters"},"getters object"),"."),(0,i.kt)("li",{parentName:"ul"},"Exports - the object of properties this atom exports. Must be a record (object) type.")),(0,i.kt)("p",null,"You typically shouldn't need to specify any of these. They're all inferred."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { api, atom, injectStore } from '@zedux/react'\n\nconst inferredIon = ion('inferred', ({ get }, one: string, two: number) => {\n  const store = injectStore(one + two) // string + number = string\n\n  return api(store).setExports({\n    getOne: () => one,\n    getTwo: () => two,\n  })\n})\n\ninferredIon\n// Ion<\n//   string,\n//   [one: string, two: number],\n//   { getOne: () => string; getTwo: () => number }\n// >\n")))}h.isMDXComponent=!0}}]);