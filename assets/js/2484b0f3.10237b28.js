"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[9059],{3368:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return l},metadata:function(){return m},toc:function(){return u},default:function(){return d}});var a=n(3117),s=n(102),r=(n(7294),n(3905)),i=n(3052),o=["components"],c={id:"injectGet",title:"injectGet"},l=void 0,m={unversionedId:"api/injectors/injectGet",id:"api/injectors/injectGet",isDocsHomePage:!1,title:"injectGet",description:"An injector that returns a get function. This get function returns the values of other atom instances. It's similar to the .get() method on ecosystems but it has one extra superpower:",source:"@site/docs/api/injectors/injectGet.mdx",sourceDirName:"api/injectors",slug:"/api/injectors/injectGet",permalink:"/zedux/docs/api/injectors/injectGet",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/injectors/injectGet.mdx",tags:[],version:"current",frontMatter:{id:"injectGet",title:"injectGet"},sidebar:"react",previous:{title:"injectEffect",permalink:"/zedux/docs/api/injectors/injectEffect"},next:{title:"injectGetInstance",permalink:"/zedux/docs/api/injectors/injectGetInstance"}},u=[{value:"Examples",id:"examples",children:[],level:2},{value:"Signature",id:"signature",children:[{value:"<code>atom</code>",id:"atom",children:[],level:3},{value:"<code>params</code>",id:"params",children:[],level:3},{value:"<code>instance</code>",id:"instance",children:[],level:3}],level:2}],p={toc:u};function d(e){var t=e.components,n=(0,s.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { injectGet } from '@zedux/react'\n")),(0,r.kt)("p",null,"An ",(0,r.kt)("a",{parentName:"p",href:"../glossary#injector"},"injector")," that returns a ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," function. This ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," function returns the values of other atom instances. It's similar to ",(0,r.kt)("a",{parentName:"p",href:"../classes/Ecosystem#get"},"the ",(0,r.kt)("inlineCode",{parentName:"a"},".get()")," method on ecosystems")," but it has one extra superpower:"),(0,r.kt)("p",null,"When called synchronously during atom evaluation, this function will register a ",(0,r.kt)("a",{parentName:"p",href:"../glossary#dynamic-graph-dependency"},"dynamic graph dependency")," on the resolved atom instance. In this way, ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," is like ",(0,r.kt)("a",{parentName:"p",href:"injectAtomValue"},(0,r.kt)("inlineCode",{parentName:"a"},"injectAtomValue()")),". However, unlike ",(0,r.kt)("inlineCode",{parentName:"p"},"injectAtomValue"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," is not an injector. This means it can be called in loops or if statements or even asynchronously."),(0,r.kt)("p",null,"When called asynchronously, ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," is really just an alias for ",(0,r.kt)("inlineCode",{parentName:"p"},"ecosystem.get()"),". It doesn't register any graph dependencies; it simply returns the current value of the resolved atom instance."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"../classes/Ion"},"Ions")," use this injector internally to provide the ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," function as part of their ",(0,r.kt)("a",{parentName:"p",href:"../types/AtomGetters"},"AtomGetters")," and ",(0,r.kt)("a",{parentName:"p",href:"../types/AtomSetters"},"AtomSetters")," objects."),(0,r.kt)("h2",{id:"examples"},"Examples"),(0,r.kt)(i.u,{resultVar:"Seconds",mdxType:"LiveEditor"},"\nconst secondsAtom = atom('seconds', (startingNumber: number) => {\n  const store = injectStore(startingNumber)\n\n  injectEffect(() => {\n    const intervalId = setInterval(\n      () => store.setState(val => val + 1),\n      1000\n    )\n\n    return () => clearInterval(intervalId)\n  }, [])\n\n  return store\n})\n\nconst sumAtom = atom('sum', (...nums: number[]) => {\n  const get = injectGet()\n\n  // loops are fine!\n  return nums.reduce((sum, num) => sum + get(secondsAtom, [num]), 0)\n})\n\nfunction Seconds() {\n  const sum = useAtomValue(sumAtom, [1, 10, 100])\n\n  return <div>Sum of 3 counters, starting at 1, 10, and 100: {sum}</div>\n}\n"),(0,r.kt)("p",null,"Miscellaneous:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const get = injectGet()\n\nconst dynamicVal = get(myAtom)\nconst withParams = get(myAtom, ['param 1', 'param 2'])\n\n// in a loop\nfor (const id of ids) {\n  const val = get(myAtom, [id])\n}\n\n// .. any kind of loop\nids.map(id => get(myAtom, [id]))\n\n// in control flow statements\nconst val = useAtomA ? get(atomA) : defaultVal\n\n// asynchronously: (`get` isn't technically a stable reference. But it doesn't\n// reference anything unstable, so not passing it as a dependency is fine)\ninjectEffect(() => {\n  const currentVal = get(myAtom)\n}, []) // don't have to pass `get`\n\n// passing an instance (also registers a dynamic dependency during evaluation):\nconst fromInstance = get(instance)\n")),(0,r.kt)("h2",{id:"signature"},"Signature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"injectGet() => get\n")),(0,r.kt)("p",null,"The injector itself doesn't take any params. The returned ",(0,r.kt)("inlineCode",{parentName:"p"},"get")," function's signature is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"get(atom, params?) => currentState\n")),(0,r.kt)("p",null,"There is an overload for passing instances:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"get(instance) => currentState\n")),(0,r.kt)("h3",{id:"atom"},(0,r.kt)("inlineCode",{parentName:"h3"},"atom")),(0,r.kt)("p",null,"Required. An ",(0,r.kt)("a",{parentName:"p",href:"../classes/Atom"},"atom"),"."),(0,r.kt)("h3",{id:"params"},(0,r.kt)("inlineCode",{parentName:"h3"},"params")),(0,r.kt)("p",null,"Optional. An array of parameters that identify this atom instance. These params will be passed to the atom's ",(0,r.kt)("a",{parentName:"p",href:"../glossary#evaluator"},"evaluator function"),"."),(0,r.kt)("p",null,"TS users will be required to pass this for atoms that take params. If you don't use TS ... just don't forget to pass them."),(0,r.kt)("h3",{id:"instance"},(0,r.kt)("inlineCode",{parentName:"h3"},"instance")),(0,r.kt)("p",null,"Required (in this overload). An ",(0,r.kt)("a",{parentName:"p",href:"../classes/AtomInstance"},"atom instance"),"."))}d.isMDXComponent=!0}}]);