"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[4832],{4533:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return m},toc:function(){return d},default:function(){return p}});var o=n(3117),s=n(102),a=(n(7294),n(3905)),r=n(3052),i=["components"],l={id:"AtomSelector",title:"AtomSelector"},c=void 0,m={unversionedId:"api/types/AtomSelector",id:"api/types/AtomSelector",isDocsHomePage:!1,title:"AtomSelector",description:"A function that receives an AtomGetters object as its first parameter. It can take any number of other parameters and can return anything. It can use the AtomGetters to get atom values and run other AtomSelectors.",source:"@site/docs/api/types/AtomSelector.mdx",sourceDirName:"api/types",slug:"/api/types/AtomSelector",permalink:"/zedux/docs/api/types/AtomSelector",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/types/AtomSelector.mdx",tags:[],version:"current",frontMatter:{id:"AtomSelector",title:"AtomSelector"},sidebar:"react",previous:{title:"AtomInstanceTtl",permalink:"/zedux/docs/api/types/AtomInstanceTtl"},next:{title:"AtomSetters",permalink:"/zedux/docs/api/types/AtomSetters"}},d=[{value:"Definition",id:"definition",children:[],level:2},{value:"Examples",id:"examples",children:[],level:2},{value:"When Not to Use",id:"when-not-to-use",children:[{value:"Converting AtomSelectors",id:"converting-atomselectors",children:[],level:3}],level:2},{value:"Generic AtomSelectors",id:"generic-atomselectors",children:[],level:2},{value:"AtomSelectorConfig",id:"atomselectorconfig",children:[],level:2}],u={toc:d};function p(e){var t=e.components,n=(0,s.Z)(e,i);return(0,a.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A function that receives an ",(0,a.kt)("a",{parentName:"p",href:"AtomGetters"},"AtomGetters")," object as its first parameter. It can take any number of other parameters and can return anything. It can use the AtomGetters to get atom values and run other AtomSelectors."),(0,a.kt)("p",null,"This is the most basic tool for deriving state in Zedux. The ",(0,a.kt)("a",{parentName:"p",href:"../../walkthrough/selectors"},"selectors walkthrough")," teaches the basics of AtomSelectors. This page will only cover a few things the walkthrough doesn't."),(0,a.kt)("p",null,"AtomSelectors define a blueprint for pulling data from atoms. Similar to ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/reduxjs/reselect#api"},"reselect selectors"),', they don\'t do anything until someone calls them. You "call" them by passing them to various functions:'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../hooks/useAtomSelector"},(0,a.kt)("inlineCode",{parentName:"a"},"useAtomSelector()"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../injectors/injectAtomSelector"},(0,a.kt)("inlineCode",{parentName:"a"},"injectAtomSelector()"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../classes/Ecosystem#select"},(0,a.kt)("inlineCode",{parentName:"a"},"ecosystem.select()"))),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("inlineCode",{parentName:"li"},"select")," function of other AtomSelectors (composition!)")),(0,a.kt)("p",null,"You can also call them directly, passing an AtomGetters object. There is ",(0,a.kt)("a",{parentName:"p",href:"#generic-atomselectors"},"one situation")," where this can be necessary"),(0,a.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"Use AtomSelectors for:"),(0,a.kt)("ul",{parentName:"div"},(0,a.kt)("li",{parentName:"ul"},"Dynamically registering graph edges in components"),(0,a.kt)("li",{parentName:"ul"},"Getting part of an atom instance's state"),(0,a.kt)("li",{parentName:"ul"},"Simple calculations that don't need memoization")))),(0,a.kt)("h2",{id:"definition"},"Definition"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"type AtomSelector<T = any, Args extends any[] = []> = (\n  getters: AtomGetters,\n  ...args: Args\n) => T\n\ninterface AtomSelectorConfig<T = any, Args extends any[] = []> {\n  argsAreEqual?: (newArgs: Args, oldArgs: Args) => boolean\n  resultsAreEqual?: (newResult: T, oldResult: T) => boolean\n  selector: AtomSelector<T, Args>\n}\n\ntype AtomSelectorOrConfig<T = any, Args extends any[] = []> =\n  | AtomSelector<T, Args>\n  | AtomSelectorConfig<T, Args>\n")),(0,a.kt)("h2",{id:"examples"},"Examples"),(0,a.kt)("p",null,"AtomSelectors are extremely flexible. They can be used and composed in many ways."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// basic derivation\nconst finishedTodos = ({ get }) => get(todosAtom).filter(todo => todo.isDone)\nconst uninishedTodos = ({ get }) => get(todosAtom).filter(todo => !todo.isDone)\n\n// composition using select()\nconst separatedTodos = ({ select }) => {\n  const finished = select(finishedTodos)\n  const unfinished = select(unfinishedTodos)\n\n  return { finished, unfinished }\n}\n\n// passing params\nconst getTodos = ({ select }, isDone) => {\n  const todos = select(isDone ? finishedTodos : unfinishedTodos)\n}\n\nconst separatedTodosWithParams = ({ select }) => {\n  const finished = select(getTodos, true)\n  const unfinished = select(getTodos, false)\n\n  return { finished, unfinished }\n}\n\n// in useAtomSelector()\nconst withHook = useAtomSelector(finishedTodos)\n\n// in injectAtomSelector()\nconst withInjector = injectAtomSelector(finishedTodos)\n\n// in ecosystem.select()\nconst staticViaEcosystem = ecosystem.select(finishedTodos)\n\n// directly in ion body (not recommended)\nconst exampleIon = ion('example', getters => {\n  const todos = finishedTodos(getters)\n})\n\n// only run selector once\nconst stateSnapshot = useAtomSelector({\n  // argsAreEqual isn't called on the first run\n  argsAreEqual: () => true,\n  selector: mySelector,\n})\n\n// only run the selector if the new args don't deep match the old args\nconst limitedRuns = useAtomSelector(\n  {\n    areArgsEqual: (newArgs, oldArgs) => _.isEqual(newArgs, oldArgs),\n    selector: mySelector,\n  },\n  arg1,\n  arg2\n)\n\n// only trigger updates if the new result doesn't deep match the old result\nconst limitedUpdates = useAtomSelector({\n  areResultsEqual: (newResult, oldResult) => _.isEqual(newResult, oldResult),\n  selector: mySelector,\n})\n")),(0,a.kt)("h2",{id:"when-not-to-use"},"When Not to Use"),(0,a.kt)("p",null,"AtomSelectors aren't atoms. As such, you can't use ",(0,a.kt)("a",{parentName:"p",href:"../glossary#injector"},"injectors")," in them. ",(0,a.kt)("a",{parentName:"p",href:"../classes/Ion"},"Ions")," (or other atoms) should be preferred when you need:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"To memoize anything - use an atom with ",(0,a.kt)("a",{parentName:"li",href:"../injectors/injectMemo"},(0,a.kt)("inlineCode",{parentName:"a"},"injectMemo()"))),(0,a.kt)("li",{parentName:"ul"},"To create and update a new store - use an atom with ",(0,a.kt)("a",{parentName:"li",href:"../injectors/injectStore"},(0,a.kt)("inlineCode",{parentName:"a"},"injectStore()"))),(0,a.kt)("li",{parentName:"ul"},"To run side effects based on state updates - use an atom with ",(0,a.kt)("a",{parentName:"li",href:"../injectors/injectEffect"},(0,a.kt)("inlineCode",{parentName:"a"},"injectEffect()")))),(0,a.kt)("h3",{id:"converting-atomselectors"},"Converting AtomSelectors"),(0,a.kt)("p",null,"AtomSelectors are simple and have little overhead, hence it's usually desirable to try an AtomSelector first for most tasks. However, sometimes you'll find out later that an AtomSelector needs functionality only atoms have."),(0,a.kt)("p",null,"Since AtomSelectors are so similar to ions, it's easy to convert an AtomSelector to an ion or a hook or injector."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// before:\nconst getSortedList = ({ get }: AtomGetters) => [...get(listAtom)].sort()\n\n// after (as ion):\nconst sortedList = ion('sortedList', ({ get }) => {\n  const list = get(listAtom)\n  return injectMemo(() => [...list].sort(), [list]) // now we can memoize!\n})\n\n// after (as injector):\nconst injectTruthy = ({ get }: AtomGetters) => {\n  const list = get(listAtom)\n  return injectMemo(() => [...list].sort(), [list])\n}\n")),(0,a.kt)("p",null,"If refactoring the AtomSelector is too much work or too tedious or risky, you can also create an ion that simply wraps the existing AtomSelector:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// before\nconst getSortedList = ({ get }: AtomGetters) => [...get(listAtom)].sort()\n\n// (before usage):\nconst sortedList = useAtomSelector(getSortedList)\n\n// after\nconst getSortedListImpl = ({ get }: AtomGetters) => [...get(listAtom)].sort()\n\nconst getSortedList = ion('getSortedList', ({ select }) =>\n  select(getSortedListImpl)\n)\n\n// (after usage):\nconst sortedList = useAtomValue(getSortedList)\n")),(0,a.kt)("h2",{id:"generic-atomselectors"},"Generic AtomSelectors"),(0,a.kt)("p",null,"In TypeScript, AtomSelectors that take a generic may need to be called directly to get correct type inference."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"// with this AtomSelector:\nconst addExtraData = <T>({ get }: AtomGetters, list: T[]) => {\n  return list.map(item => ({\n    ...item,\n    extraData: get(extraDataAtom)[item.id],\n  }))\n}\n\n// it would be nice if you could:\nconst withExtraData = useAtomSelector(addExtraData, list)\n\n// but you probably need to:\nconst withExtraData = useAtomSelector(getters => addExtraData(getters, list))\n")),(0,a.kt)("h2",{id:"atomselectorconfig"},"AtomSelectorConfig"),(0,a.kt)("p",null,"Everywhere Zedux accepts an AtomSelector, it also accepts an AtomSelectorConfig object. This object has a required ",(0,a.kt)("inlineCode",{parentName:"p"},"selector")," field and optional ",(0,a.kt)("inlineCode",{parentName:"p"},"argsAreEqual")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"resultsAreEqual")," fields."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"selector")," - The AtomSelector whose args and result we're configuring.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"argsAreEqual")," - A function that accepts two parameters - the new args and old args - and should return a boolean. If this function returns true, Zedux will not run the AtomSelector again. This function is not called on the first run.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("inlineCode",{parentName:"p"},"resultsAreEqual")," - A function that accepts two parameters - the new result and old result - and should return a boolean. If this function returns true, Zedux will not trigger a component rerender (when used from ",(0,a.kt)("inlineCode",{parentName:"p"},"useAtomSelector"),") or an atom reevaluation (when used from ",(0,a.kt)("inlineCode",{parentName:"p"},"injectAtomSelector")," or ion's ",(0,a.kt)("inlineCode",{parentName:"p"},"select"),"). This function is not called after the first run."))),(0,a.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"AtomSelectorConfig options (other than ",(0,a.kt)("inlineCode",{parentName:"p"},"selector"),") are ignored when passed to ",(0,a.kt)("inlineCode",{parentName:"p"},"ecosystem.select()")," and nested ",(0,a.kt)("inlineCode",{parentName:"p"},"select()")," calls. They're accepted overloads for interop convenience."))),(0,a.kt)(r.u,{resultVar:"CountBy5",mdxType:"LiveEditor"},"\nconst counterAtom = atom('counter', 0)\n\nfunction CountBy5() {\n  const { setState } = useAtomInstance(counterAtom)\n  const counter = useAtomSelector({\n    resultsAreEqual: newCount => newCount % 5,\n    selector: ({ get }) => get(counterAtom)\n  })\n\n  return (\n    <>\n      <div>Value: {counter}</div>\n      <button onClick={() => setState(state => state + 1)}>\n        Increment (click me 5 times)\n      </button>\n    </>\n  )\n}\n"))}p.isMDXComponent=!0}}]);