(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[3249],{1626:function(e,t,r){"use strict";r.r(t),r.d(t,{frontMatter:function(){return i},metadata:function(){return o},toc:function(){return u},default:function(){return l}});var a=r(4034),n=r(9973),s=(r(7294),r(3905)),i={id:"react-query-comparison",title:"React Query Comparison"},o={unversionedId:"about/react-query-comparison",id:"about/react-query-comparison",isDocsHomePage:!1,title:"React Query Comparison",description:"While Zedux doesn't (yet!) handle query fetching, refetching, or special query types, Zedux is currently patterned after React Query more than any other library (yes, more than Redux or Recoil). React Query's cache management is unparalleled. So Zedux' atomic model borrows a lot of ideas from it.",source:"@site/docs/about/react-query-comparison.mdx",sourceDirName:"about",slug:"/about/react-query-comparison",permalink:"/zedux/docs/about/react-query-comparison",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/about/react-query-comparison.mdx",version:"current",frontMatter:{id:"react-query-comparison",title:"React Query Comparison"}},u=[{value:"Queries",id:"queries",children:[]},{value:"QueryClient",id:"queryclient",children:[]},{value:"Stream Support",id:"stream-support",children:[]}],c={toc:u};function l(e){var t=e.components,r=(0,n.Z)(e,["components"]);return(0,s.kt)("wrapper",(0,a.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"While Zedux doesn't (yet!) handle query fetching, refetching, or special query types, Zedux is currently patterned after React Query more than any other library (yes, more than Redux or Recoil). React Query's cache management is unparalleled. So Zedux' atomic model borrows a lot of ideas from it."),(0,s.kt)("p",null,"However, the purpose of Zedux is very different from React Query. React Query is designed around promises - managing their state, side effects, and result caches. Zedux is designed to manage both application state (a la Redux/Recoil) and cached server data."),(0,s.kt)("p",null,"Since the libraries are so different, this comparison will be short."),(0,s.kt)("h2",{id:"queries"},"Queries"),(0,s.kt)("p",null,"Structurally, Zedux ",(0,s.kt)("a",{parentName:"p",href:"../api/classes/Atom"},"atoms")," are very similar to React Query ",(0,s.kt)("a",{parentName:"p",href:"https://react-query.tanstack.com/guides/queries"},"queries"),"."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"For destroying stale instances: Atoms have ",(0,s.kt)("a",{parentName:"li",href:"../api/classes/Atom#ttl"},(0,s.kt)("inlineCode",{parentName:"a"},"ttl")),". Queries have ",(0,s.kt)("inlineCode",{parentName:"li"},"cacheTime"),"."),(0,s.kt)("li",{parentName:"ul"},"For suspense: Atoms have ",(0,s.kt)("a",{parentName:"li",href:"../api/classes/AtomApi#setpromise"},(0,s.kt)("inlineCode",{parentName:"a"},".setPromise()")),". Queries have ",(0,s.kt)("inlineCode",{parentName:"li"},"suspense"),"."),(0,s.kt)("li",{parentName:"ul"},"Queries track promise state by default. Atoms have ",(0,s.kt)("a",{parentName:"li",href:"../api/injectors/injectAsyncEffect"},(0,s.kt)("inlineCode",{parentName:"a"},"injectAsyncEffect()")),".")),(0,s.kt)("h2",{id:"queryclient"},"QueryClient"),(0,s.kt)("p",null,"Zedux ",(0,s.kt)("a",{parentName:"p",href:"../api/classes/Ecosystem"},"ecosystems")," are patterned after React Query's ",(0,s.kt)("a",{parentName:"p",href:"https://react-query.tanstack.com/reference/QueryClient"},"QueryClient"),"."),(0,s.kt)("h2",{id:"stream-support"},"Stream Support"),(0,s.kt)("p",null,"Zedux atoms are designed to support any asynchronous architecture. This means that (for now) Zedux doesn't provide any promise-specific helpers like React Query's ",(0,s.kt)("inlineCode",{parentName:"p"},"onSuccess"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"refetchOnWindowFocus"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"retryDelay"),", etc. The upside is, atoms aren't restricted to using promises."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"")))}l.isMDXComponent=!0}}]);