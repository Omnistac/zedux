"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[8105],{7915:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return l},metadata:function(){return u},toc:function(){return d},default:function(){return m}});var a=n(3117),r=n(102),o=(n(7294),n(3905)),i=n(3052),s=["components"],c={id:"injectStore",title:"injectStore"},l=void 0,u={unversionedId:"api/injectors/injectStore",id:"api/injectors/injectStore",isDocsHomePage:!1,title:"injectStore",description:"An injector that creates a stable Zedux store. This reference will not change on subsequent evaluations of this atom instance.",source:"@site/docs/api/injectors/injectStore.mdx",sourceDirName:"api/injectors",slug:"/api/injectors/injectStore",permalink:"/zedux/docs/api/injectors/injectStore",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/injectors/injectStore.mdx",tags:[],version:"current",frontMatter:{id:"injectStore",title:"injectStore"},sidebar:"react",previous:{title:"injectRef",permalink:"/zedux/docs/api/injectors/injectRef"},next:{title:"injectWhy",permalink:"/zedux/docs/api/injectors/injectWhy"}},d=[{value:"Examples",id:"examples",children:[],level:2},{value:"Signature",id:"signature",children:[{value:"Overloads",id:"overloads",children:[],level:3},{value:"<code>initialValue</code>",id:"initialvalue",children:[],level:3},{value:"<code>shouldSubscribe</code>",id:"shouldsubscribe",children:[],level:3},{value:"<code>createStore</code>",id:"createstore",children:[],level:3}],level:2}],p={toc:d};function m(e){var t=e.components,n=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { injectStore } from '@zedux/react'\n")),(0,o.kt)("p",null,"An ",(0,o.kt)("a",{parentName:"p",href:"../glossary#injector"},"injector")," that creates a stable ",(0,o.kt)("a",{parentName:"p",href:"../classes/Store"},"Zedux store"),". This reference will not change on subsequent evaluations of this atom instance."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"injectStore")," is the injector equivalent of both ",(0,o.kt)("inlineCode",{parentName:"p"},"useState")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"useReducer"),", since Zedux stores cover both use cases (and more)."),(0,o.kt)("h2",{id:"examples"},"Examples"),(0,o.kt)(i.u,{resultVar:"Seconds",mdxType:"LiveEditor"},"\nconst secondsAtom = atom('seconds', () => {\n  const store = injectStore(0)\n\n  injectEffect(() => {\n    const intervalId = setInterval(\n      () => store.setState(val => val + 1),\n      1000\n    )\n\n    return () => clearInterval(intervalId)\n  }, [])\n\n  return store\n})\n\nfunction Seconds() {\n  const state = useAtomValue(secondsAtom)\n\n  return <div>Seconds: {state}</div>\n}\n"),(0,o.kt)("p",null,"Miscellaneous:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { createStore, injectStore } from '@zedux/react'\n\nconst zeroConfigStore = injectStore('initial state')\nconst createdManually = injectStore(() => createStore(null, 'initial state'))\nconst configuredStore = injectStore(() => createStore(rootReducer))\n\nconst composedStore = injectStore(() =>\n  createStore({\n    zeroConfig: zeroConfigStore,\n    configured: configuredStore,\n  })\n)\n\nconst subscribingStore = injectStore('state', true)\n")),(0,o.kt)("h2",{id:"signature"},"Signature"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"injectStore(initialValue?, shouldSubscribe?) => Store\n")),(0,o.kt)("h3",{id:"overloads"},"Overloads"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"injectStore(createStore?, shouldSubscribe?) => Store\n")),(0,o.kt)("h3",{id:"initialvalue"},(0,o.kt)("inlineCode",{parentName:"h3"},"initialValue")),(0,o.kt)("p",null,"Optional. Can be anything but a function. This value will be set as the initial state of the store."),(0,o.kt)("p",null,"To set a function as the value, you must use the ",(0,o.kt)("a",{parentName:"p",href:"#createstore"},(0,o.kt)("inlineCode",{parentName:"a"},"createStore"))," overload:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"injectStore(() => createStore(null, myFunctionHere))\n")),(0,o.kt)("p",null,"Typically it isn't recommended to set a function as a store's value. But there are certainly use cases."),(0,o.kt)("h3",{id:"shouldsubscribe"},(0,o.kt)("inlineCode",{parentName:"h3"},"shouldSubscribe")),(0,o.kt)("p",null,"Optional. A boolean. Default ",(0,o.kt)("inlineCode",{parentName:"p"},"false"),". Indicates whether the current atom instance should subscribe to this store."),(0,o.kt)("p",null,"Why does this default to ",(0,o.kt)("inlineCode",{parentName:"p"},"false"),"?? Doesn't that make this fundamentally different from React's ",(0,o.kt)("inlineCode",{parentName:"p"},"useState")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"useReducer")," hooks? It may be a confusing change at first. And we certainly could change the default to ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,o.kt)("p",null,"Atom evaluations are much more predictable than React rerenders. The default is ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," to remind you that you have control! Many atoms won't need to reevaluate when their own store's state changes."),(0,o.kt)("h3",{id:"createstore"},(0,o.kt)("inlineCode",{parentName:"h3"},"createStore")),(0,o.kt)("p",null,"Optional. A function that returns a manually-created store by calling ",(0,o.kt)("a",{parentName:"p",href:"../factories/createStore"},(0,o.kt)("inlineCode",{parentName:"a"},"createStore()")),". This function will only be called once - when the atom instance is created."))}m.isMDXComponent=!0}}]);