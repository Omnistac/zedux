"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[1578],{78:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return d},toc:function(){return m},default:function(){return u}});var a=n(3117),o=n(102),s=(n(7294),n(3905)),i=n(3052),r=["components"],l={id:"dependency-injection",title:"Dependency Injection"},c=void 0,d={unversionedId:"walkthrough/dependency-injection",id:"walkthrough/dependency-injection",isDocsHomePage:!1,title:"Dependency Injection",description:"React creates a perfect environment for Inversion of Control. Yet this amazing technique is underused. Zedux aims to help bring Dependency Injection (DI) to the forefront of React workflows.",source:"@site/docs/walkthrough/dependency-injection.mdx",sourceDirName:"walkthrough",slug:"/walkthrough/dependency-injection",permalink:"/zedux/docs/walkthrough/dependency-injection",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/walkthrough/dependency-injection.mdx",tags:[],version:"current",frontMatter:{id:"dependency-injection",title:"Dependency Injection"},sidebar:"react",previous:{title:"Ecosystems",permalink:"/zedux/docs/walkthrough/ecosystems"},next:{title:"Selectors",permalink:"/zedux/docs/walkthrough/selectors"}},m=[{value:"Injection",id:"injection",children:[{value:"AtomGetters",id:"atomgetters",children:[],level:3},{value:"Instances as Params",id:"instances-as-params",children:[],level:3},{value:"The Graph",id:"the-graph",children:[{value:"What&#39;s the point of a static edge?",id:"whats-the-point-of-a-static-edge",children:[],level:4}],level:3}],level:2},{value:"Overrides",id:"overrides",children:[{value:"Creating",id:"creating",children:[],level:3},{value:"Using",id:"using",children:[],level:3},{value:"Updating",id:"updating",children:[],level:3}],level:2},{value:"Simple Example",id:"simple-example",children:[],level:2},{value:"Recap",id:"recap",children:[],level:2},{value:"Next Steps",id:"next-steps",children:[],level:2}],p={toc:m};function u(e){var t=e.components,n=(0,o.Z)(e,r);return(0,s.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"React creates a perfect environment for Inversion of Control. Yet this amazing technique is underused. Zedux aims to help bring Dependency Injection (DI) to the forefront of React workflows."),(0,s.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"you will learn")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"How to:"),(0,s.kt)("ul",{parentName:"div"},(0,s.kt)("li",{parentName:"ul"},'"Inject" atoms in other atoms to create a dependency graph'),(0,s.kt)("li",{parentName:"ul"},"Create an overridden version of an atom"),(0,s.kt)("li",{parentName:"ul"},"Swap out atoms and their overrides")))),(0,s.kt)("p",null,"There are 2 parts to DI:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Injection"),(0,s.kt)("li",{parentName:"ul"},"Overrides")),(0,s.kt)("h2",{id:"injection"},"Injection"),(0,s.kt)("p",null,"Any atom can be injected into any other atom."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { atom, injectAtomValue } from '@zedux/react'\n\nconst atomA = atom('a', 'a')\nconst atomB = atom('b', () => {\n  const a = injectAtomValue(atomA)\n\n  return a + 'b' // 'ab'\n})\n")),(0,s.kt)("h3",{id:"atomgetters"},"AtomGetters"),(0,s.kt)("p",null,'The word "inject" helps you know that there is Dependency Injection going on. But we can also "inject" dependencies using ',(0,s.kt)("a",{parentName:"p",href:"../api/types/AtomGetters"},"AtomGetters")," like ",(0,s.kt)("a",{parentName:"p",href:"../api/types/AtomGetters#get"},"ion's ",(0,s.kt)("inlineCode",{parentName:"a"},"get")),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { atom, ion } from '@zedux/react'\n\nconst usersAtom = atom('users', ['Joe', 'Sally', 'Jim', 'Ruth'])\n\nconst sortedUsersAtom = ion('sortedUsers', ({ get }) => {\n  return [...get(usersAtom)].sort()\n})\n")),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"get")," here is doing the exact same thing as ",(0,s.kt)("inlineCode",{parentName:"p"},"injectAtomValue"),". All AtomGetters have injector equivalents, but AtomGetters are more dynamic."),(0,s.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"Since ",(0,s.kt)("inlineCode",{parentName:"p"},"get")," and the other AtomGetters aren't injectors, they can be used in if statements, loops, and even asynchronously. When used asynchronously, they don't create dependencies."))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const myIon = ion('my', ({ get }) => {\n  // this `get` creates a dependency - this ion will update when atom1 changes\n  const dynamicValue = get(atom1)\n\n  injectEffect(() => {\n    // this `get` doesn't create any dependency\n    const staticValue = get(atom2)\n  }, [])\n})\n")),(0,s.kt)("p",null,"The AtomGetters are:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"get")," - returns the value of an atom instance. Registers a ",(0,s.kt)("a",{parentName:"p",href:"../api/glossary#dynamic-graph-dependency"},"dynamic dependency")," when called synchronously during atom evaluation. Injector equivalent: ",(0,s.kt)("inlineCode",{parentName:"p"},"injectAtomValue"),".")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"getInstance")," - returns an atom instance. Registers a ",(0,s.kt)("a",{parentName:"p",href:"../api/glossary#static-graph-dependency"},"static dependency")," when called synchronously during atom evaluation. Injector equivalent: ",(0,s.kt)("inlineCode",{parentName:"p"},"injectAtomInstance"),".")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"select")," - returns the selection result. Can register both kinds of dependencies. We'll cover these next in the ",(0,s.kt)("a",{parentName:"p",href:"selectors"},"selectors walkthrough"),". Injector equivalent: ",(0,s.kt)("inlineCode",{parentName:"p"},"injectAtomSelector"))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"ecosystem")," - a reference to the current ",(0,s.kt)("a",{parentName:"p",href:"../api/classes/Ecosystem"},"ecosystem"),". Ecosystems have ",(0,s.kt)("inlineCode",{parentName:"p"},"get"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"getInstance"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"select")," methods. These never register dependencies."))),(0,s.kt)("p",null,"Use ",(0,s.kt)("inlineCode",{parentName:"p"},"ecosystem"),"'s methods to get static values without creating dependencies during atom evaluation."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const myIon = ion('my', ({ ecosystem, get }) => {\n  // creates a dependency\n  const dynamicValue = get(atom1, ['some', 'params'])\n\n  // gets a static snapshot of atom2's current state\n  const staticValue = ecosystem.get(atom2, ['param'])\n})\n")),(0,s.kt)("h3",{id:"instances-as-params"},"Instances as Params"),(0,s.kt)("p",null,"As a general rule, all ",(0,s.kt)("a",{parentName:"p",href:"../api/classes/AtomInstance#params"},"atom params"),' must be serializable. There is one exception: You can pass an atom instance to another atom instance. This is another form of "Dependency Injection".'),(0,s.kt)(i.u,{resultVar:"Shout",mdxType:"LiveEditor"},"\nconst normalAtom = atom('normal', \"I'm just a little, black rain cloud\")\n\nconst shoutingAtom = atom(\n  'shouting',\n  (instance: AtomInstance<string>) => {\n    const val = injectAtomValue(instance) // subscribe to updates\n\n    return val.toUpperCase()\n  }\n)\n\nfunction Shout() {\n  const instance = useAtomInstance(normalAtom)\n  const shout = useAtomValue(shoutingAtom, [instance]) // just pass the instance\n\n  return <div>(In a Singing sort of voice): {shout}</div>\n}\n"),(0,s.kt)("p",null,"When an atom instance receives another atom instance via params, it doesn't create any kind of dependency on that instance. This is usually fine: Whoever passed the instance is probably already registering their own dependency on the instance they're passing."),(0,s.kt)("p",null,"In this example, we passed the instance to ",(0,s.kt)("inlineCode",{parentName:"p"},"injectAtomValue")," to create a dynamic dependency on the instance."),(0,s.kt)("p",null,"See ",(0,s.kt)("a",{parentName:"p",href:"../api/classes/AtomInstance#params"},"AtomInstance#params")," for more info."),(0,s.kt)("h3",{id:"the-graph"},"The Graph"),(0,s.kt)("p",null,"Detour! You can ",(0,s.kt)("a",{parentName:"p",href:"#overrides"},"skip this section"),". Proceed if ye dare:"),(0,s.kt)("p",null,"As you use atoms, Zedux creates and updates a graph of atom dependencies. The nodes of the graph are atom instances and consumers of atom instances. The edges of the graph are relationships between atom instances and their consumers."),(0,s.kt)("p",null,"Zedux provides several methods to inspect and manipulate this graph."),(0,s.kt)("p",null,'When we "inject an atom", what we\'re really doing is instructing Zedux to create an edge on the graph. There are 8 different types of edges, based on these 3 edge flags:'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"isExternal - whether the graph edge is between two atom instances or between an atom instance and something outside of Zedux - usually a React component."),(0,s.kt)("li",{parentName:"ul"},"isAsync - async edges are edges created and cleaned up manually, usually in a useEffect hook or injectEffect injector. There currently aren't any APIs to create these edges. We're working on it."),(0,s.kt)("li",{parentName:"ul"},"isStatic - whether the dependent should be notified of updates to the dependency's state (causing a dependent atom instance to reevaluate or a dependent component to rerender).")),(0,s.kt)("p",null,"Ignoring ",(0,s.kt)("inlineCode",{parentName:"p"},"isAsync"),", since there are no ways to create those edges currently, the 4 edge types you'll encounter are ",(0,s.kt)("inlineCode",{parentName:"p"},"external-static"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"external-dynamic"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"internal-static"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"internal-dynamic"),". There are many hooks and injectors for creating these 4 edge types:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"injectAtomValue")," - creates an ",(0,s.kt)("inlineCode",{parentName:"li"},"internal-dynamic")," edge."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"injectAtomState")," - creates an ",(0,s.kt)("inlineCode",{parentName:"li"},"internal-dynamic")," edge."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"injectAtomSelector")," - creates an ",(0,s.kt)("inlineCode",{parentName:"li"},"internal-dynamic")," edge that will only cause reevaluations when the selector's returned value changes."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"injectAtomInstance")," - creates an ",(0,s.kt)("inlineCode",{parentName:"li"},"internal-static")," edge."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"useAtomValue")," - creates an ",(0,s.kt)("inlineCode",{parentName:"li"},"external-dynamic")," edge."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"useAtomState")," - creates an ",(0,s.kt)("inlineCode",{parentName:"li"},"external-dynamic")," edge."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"useAtomSelector")," - creates an ",(0,s.kt)("inlineCode",{parentName:"li"},"external-dynamic")," edge that will only cause rerenders when the selector's returned value changes."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"useAtomInstance")," - creates an ",(0,s.kt)("inlineCode",{parentName:"li"},"external-static")," edge.")),(0,s.kt)("h4",{id:"whats-the-point-of-a-static-edge"},"What's the point of a static edge?"),(0,s.kt)("p",null,"Static edges don't trigger reevaluations or rerenders, so what's the point? There are 2 main reasons why static edges are important:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"They inform Zedux that someone is using the injected atom instance. As long as an atom instance has any graph edges, Zedux won't try to clean it up."),(0,s.kt)("li",{parentName:"ul"},"If an atom instance is force-destroyed while it has static dependents, those dependents will be informed of the destruction and actually will schedule a reevaluation or rerender to create a new instance.")),(0,s.kt)("h2",{id:"overrides"},"Overrides"),(0,s.kt)("p",null,"Now that we've got dependencies injected, we need a way to swap them out."),(0,s.kt)("h3",{id:"creating"},"Creating"),(0,s.kt)("p",null,"Atoms have a ",(0,s.kt)("a",{parentName:"p",href:"../api/classes/Atom#override"},(0,s.kt)("inlineCode",{parentName:"a"},".override()")," method")," which will create an exact clone of the atom, but with a different value."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const axiosAtom = atom('axios', axios)\n\nconst testAxiosAtom = axiosAtom.override({ post: jest.fn() })\n")),(0,s.kt)("p",null,"You don't have to use ",(0,s.kt)("inlineCode",{parentName:"p"},".override()"),". You can create a clone manually. The only requirement is that the override has the same ",(0,s.kt)("inlineCode",{parentName:"p"},"key"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const testAtom = atom('test', 'some state')\nconst testAtomOverride = atom('test', 'overridden state!', { ttl: 0 })\n")),(0,s.kt)("p",null,"The nice thing about ",(0,s.kt)("inlineCode",{parentName:"p"},".override()")," for TS users is that it will tell you if the override doesn't match the overridden atom's type."),(0,s.kt)("h3",{id:"using"},"Using"),(0,s.kt)("p",null,"These overridden atoms can then be supplied to an ",(0,s.kt)("inlineCode",{parentName:"p"},"ecosystem")," via the ",(0,s.kt)("inlineCode",{parentName:"p"},"overrides")," field:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},'function TestApp() {\n  return (\n    <EcosystemProvider id="test" overrides={[testAxiosAtom]}>\n      <Routes />\n    </EcosystemProvider>\n  )\n}\n')),(0,s.kt)("p",null,"Now this test ecosystem will use ",(0,s.kt)("inlineCode",{parentName:"p"},"testAxiosAtom")," everywhere ",(0,s.kt)("inlineCode",{parentName:"p"},"axiosAtom")," is used:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"function Routes {\n  const axios = useAtomValue(axiosAtom) // testAxiosAtom is used instead\n  ...\n}\n\nconst userAtom = ion('user', ({ get }) => {\n  const axios = get(axiosAtom) // testAxiosAtom is injected instead\n})\n")),(0,s.kt)("h3",{id:"updating"},"Updating"),(0,s.kt)("p",null,"Atom implementations can be swapped out dynamically using ",(0,s.kt)("a",{parentName:"p",href:"../api/classes/Ecosystem#setoverrides"},(0,s.kt)("inlineCode",{parentName:"a"},"ecosystem.setOverrides()")),". This is an extremely powerful feature of Zedux' DI model."),(0,s.kt)(i.u,{resultVar:"Swapper",mdxType:"LiveEditor"},"\nconst one = atom('common-key', () => 'Numero Uno')\nconst two = atom('common-key', () => 'I am the best')\nconst three = atom('common-key', () => 'Two is not the best')\n\nfunction Swapper() {\n  const ecosystem = useEcosystem()\n  const state = useAtomValue(one)\n\n  return (\n    <>\n      <div>Current State: {state}</div>\n      <button onClick={() => ecosystem.setOverrides([one])}>Use One</button>\n      <button onClick={() => ecosystem.setOverrides([two])}>Use Two</button>\n      <button onClick={() => ecosystem.setOverrides([three])}>Use Three</button>\n    </>\n  )\n}\n"),(0,s.kt)("p",null,"Use ",(0,s.kt)("a",{parentName:"p",href:"../api/classes/Ecosystem#addoverrides"},(0,s.kt)("inlineCode",{parentName:"a"},"ecosystem.addOverrides()"))," and ",(0,s.kt)("a",{parentName:"p",href:"../api/classes/Ecosystem#removeoverrides"},(0,s.kt)("inlineCode",{parentName:"a"},"ecosystem.removeOverrides()"))," to selectively update only certain overrides."),(0,s.kt)(i.u,{resultVar:"Overrider",mdxType:"LiveEditor"},"\nconst original = atom('common-key', () => 'Pick Me')\nconst override = atom('common-key', () => 'No, Me')\n\nfunction Overrider() {\n  const ecosystem = useEcosystem()\n  const state = useAtomValue(original)\n\n  return (\n    <>\n      <div>Current State: {state}</div>\n      <button onClick={() => ecosystem.addOverrides([override])}>Override</button>\n      <button onClick={() => ecosystem.removeOverrides([override])}>\n        Remove Override\n      </button>\n    </>\n  )\n}\n"),(0,s.kt)("h2",{id:"simple-example"},"Simple Example"),(0,s.kt)(i.u,{resultVar:"App",mdxType:"LiveEditor"},"\nconst textAtom = atom('text', 'the text!')\nconst betterTextAtom = textAtom.override('better text!')\n\nconst betterEcosystem = ecosystem({ overrides: [betterTextAtom] })\n\nfunction Child() {\n  const text = useAtomValue(textAtom)\n\n  return <div>{text}</div>\n}\n\nfunction App() {\n  return (\n    <>\n      <EcosystemProvider>\n        <Child />\n      </EcosystemProvider>\n      <EcosystemProvider ecosystem={betterEcosystem}>\n        <Child />\n      </EcosystemProvider>\n    </>\n  )\n}\n"),(0,s.kt)("h2",{id:"recap"},"Recap"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},'Atoms can be "injected" into other atoms with various injectors and the AtomGetters.'),(0,s.kt)("li",{parentName:"ul"},"Instances can be passed as params to other atoms."),(0,s.kt)("li",{parentName:"ul"},"Atom overrides can be created with ",(0,s.kt)("inlineCode",{parentName:"li"},"myAtom.override(newVal)"),"."),(0,s.kt)("li",{parentName:"ul"},"Atoms can be overridden by setting the ecosystem's overrides.")),(0,s.kt)("h2",{id:"next-steps"},"Next Steps"),(0,s.kt)("p",null,"Let's kick Dependency Injection into high gear with ",(0,s.kt)("a",{parentName:"p",href:"selectors"},"selectors"),"."))}u.isMDXComponent=!0}}]);