"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = 995;
exports.ids = [995];
exports.modules = {

/***/ 20995:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Fu),\n/* harmony export */   \"uriTransformer\": () => (/* binding */ gr)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(67294);\n/* harmony import */ var _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64359);\n\n\nconst ze = [\"http\", \"https\", \"mailto\", \"tel\"];\nfunction gr(n) {\n  const e = (n || \"\").trim(), t = e.charAt(0);\n  if (t === \"#\" || t === \"/\")\n    return e;\n  const r = e.indexOf(\":\");\n  if (r === -1)\n    return e;\n  let i = -1;\n  for (; ++i < ze.length; ) {\n    const l = ze[i];\n    if (r === l.length && e.slice(0, l.length).toLowerCase() === l)\n      return e;\n  }\n  return i = e.indexOf(\"?\"), i !== -1 && r > i || (i = e.indexOf(\"#\"), i !== -1 && r > i) ? e : \"javascript:void(0)\";\n}\n/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\nvar yr = function(e) {\n  return e != null && e.constructor != null && typeof e.constructor.isBuffer == \"function\" && e.constructor.isBuffer(e);\n};\nconst Pt = yr;\nfunction xr(n) {\n  return !n || typeof n != \"object\" ? \"\" : \"position\" in n || \"type\" in n ? Re(n.position) : \"start\" in n || \"end\" in n ? Re(n) : \"line\" in n || \"column\" in n ? he(n) : \"\";\n}\nfunction he(n) {\n  return _e(n && n.line) + \":\" + _e(n && n.column);\n}\nfunction Re(n) {\n  return he(n && n.start) + \"-\" + he(n && n.end);\n}\nfunction _e(n) {\n  return n && typeof n == \"number\" ? n : 1;\n}\nclass cn extends Error {\n  /**\n   * Create a message for `reason` at `place` from `origin`.\n   *\n   * When an error is passed in as `reason`, the `stack` is copied.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   *\n   *   > ðŸ‘‰ **Note**: you should use markdown.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns\n   *   Instance of `VFileMessage`.\n   */\n  // To do: next major: expose `undefined` everywhere instead of `null`.\n  constructor(e, t, r) {\n    const i = [null, null];\n    let l = {\n      // @ts-expect-error: we always follows the structure of `position`.\n      start: { line: null, column: null },\n      // @ts-expect-error: \"\n      end: { line: null, column: null }\n    };\n    if (super(), typeof t == \"string\" && (r = t, t = void 0), typeof r == \"string\") {\n      const o = r.indexOf(\":\");\n      o === -1 ? i[1] = r : (i[0] = r.slice(0, o), i[1] = r.slice(o + 1));\n    }\n    t && (\"type\" in t || \"position\" in t ? t.position && (l = t.position) : \"start\" in t || \"end\" in t ? l = t : (\"line\" in t || \"column\" in t) && (l.start = t)), this.name = xr(t) || \"1:1\", this.message = typeof e == \"object\" ? e.message : e, this.stack = \"\", typeof e == \"object\" && e.stack && (this.stack = e.stack), this.reason = this.message, this.fatal, this.line = l.start.line, this.column = l.start.column, this.position = l, this.source = i[0], this.ruleId = i[1], this.file, this.actual, this.expected, this.url, this.note;\n  }\n}\ncn.prototype.file = \"\";\ncn.prototype.name = \"\";\ncn.prototype.reason = \"\";\ncn.prototype.message = \"\";\ncn.prototype.stack = \"\";\ncn.prototype.fatal = null;\ncn.prototype.column = null;\ncn.prototype.line = null;\ncn.prototype.source = null;\ncn.prototype.ruleId = null;\ncn.prototype.position = null;\nconst mn = { basename: kr, dirname: br, extname: wr, join: Sr, sep: \"/\" };\nfunction kr(n, e) {\n  if (e !== void 0 && typeof e != \"string\")\n    throw new TypeError('\"ext\" argument must be a string');\n  Hn(n);\n  let t = 0, r = -1, i = n.length, l;\n  if (e === void 0 || e.length === 0 || e.length > n.length) {\n    for (; i--; )\n      if (n.charCodeAt(i) === 47) {\n        if (l) {\n          t = i + 1;\n          break;\n        }\n      } else\n        r < 0 && (l = !0, r = i + 1);\n    return r < 0 ? \"\" : n.slice(t, r);\n  }\n  if (e === n)\n    return \"\";\n  let o = -1, u = e.length - 1;\n  for (; i--; )\n    if (n.charCodeAt(i) === 47) {\n      if (l) {\n        t = i + 1;\n        break;\n      }\n    } else\n      o < 0 && (l = !0, o = i + 1), u > -1 && (n.charCodeAt(i) === e.charCodeAt(u--) ? u < 0 && (r = i) : (u = -1, r = o));\n  return t === r ? r = o : r < 0 && (r = n.length), n.slice(t, r);\n}\nfunction br(n) {\n  if (Hn(n), n.length === 0)\n    return \".\";\n  let e = -1, t = n.length, r;\n  for (; --t; )\n    if (n.charCodeAt(t) === 47) {\n      if (r) {\n        e = t;\n        break;\n      }\n    } else\n      r || (r = !0);\n  return e < 0 ? n.charCodeAt(0) === 47 ? \"/\" : \".\" : e === 1 && n.charCodeAt(0) === 47 ? \"//\" : n.slice(0, e);\n}\nfunction wr(n) {\n  Hn(n);\n  let e = n.length, t = -1, r = 0, i = -1, l = 0, o;\n  for (; e--; ) {\n    const u = n.charCodeAt(e);\n    if (u === 47) {\n      if (o) {\n        r = e + 1;\n        break;\n      }\n      continue;\n    }\n    t < 0 && (o = !0, t = e + 1), u === 46 ? i < 0 ? i = e : l !== 1 && (l = 1) : i > -1 && (l = -1);\n  }\n  return i < 0 || t < 0 || // We saw a non-dot character immediately before the dot.\n  l === 0 || // The (right-most) trimmed path component is exactly `..`.\n  l === 1 && i === t - 1 && i === r + 1 ? \"\" : n.slice(i, t);\n}\nfunction Sr(...n) {\n  let e = -1, t;\n  for (; ++e < n.length; )\n    Hn(n[e]), n[e] && (t = t === void 0 ? n[e] : t + \"/\" + n[e]);\n  return t === void 0 ? \".\" : Er(t);\n}\nfunction Er(n) {\n  Hn(n);\n  const e = n.charCodeAt(0) === 47;\n  let t = Cr(n, !e);\n  return t.length === 0 && !e && (t = \".\"), t.length > 0 && n.charCodeAt(n.length - 1) === 47 && (t += \"/\"), e ? \"/\" + t : t;\n}\nfunction Cr(n, e) {\n  let t = \"\", r = 0, i = -1, l = 0, o = -1, u, a;\n  for (; ++o <= n.length; ) {\n    if (o < n.length)\n      u = n.charCodeAt(o);\n    else {\n      if (u === 47)\n        break;\n      u = 47;\n    }\n    if (u === 47) {\n      if (!(i === o - 1 || l === 1))\n        if (i !== o - 1 && l === 2) {\n          if (t.length < 2 || r !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {\n            if (t.length > 2) {\n              if (a = t.lastIndexOf(\"/\"), a !== t.length - 1) {\n                a < 0 ? (t = \"\", r = 0) : (t = t.slice(0, a), r = t.length - 1 - t.lastIndexOf(\"/\")), i = o, l = 0;\n                continue;\n              }\n            } else if (t.length > 0) {\n              t = \"\", r = 0, i = o, l = 0;\n              continue;\n            }\n          }\n          e && (t = t.length > 0 ? t + \"/..\" : \"..\", r = 2);\n        } else\n          t.length > 0 ? t += \"/\" + n.slice(i + 1, o) : t = n.slice(i + 1, o), r = o - i - 1;\n      i = o, l = 0;\n    } else\n      u === 46 && l > -1 ? l++ : l = -1;\n  }\n  return t;\n}\nfunction Hn(n) {\n  if (typeof n != \"string\")\n    throw new TypeError(\n      \"Path must be a string. Received \" + JSON.stringify(n)\n    );\n}\nconst Ar = { cwd: Pr };\nfunction Pr() {\n  return \"/\";\n}\nfunction me(n) {\n  return n !== null && typeof n == \"object\" && // @ts-expect-error: indexable.\n  n.href && // @ts-expect-error: indexable.\n  n.origin;\n}\nfunction Fr(n) {\n  if (typeof n == \"string\")\n    n = new URL(n);\n  else if (!me(n)) {\n    const e = new TypeError(\n      'The \"path\" argument must be of type string or an instance of URL. Received `' + n + \"`\"\n    );\n    throw e.code = \"ERR_INVALID_ARG_TYPE\", e;\n  }\n  if (n.protocol !== \"file:\") {\n    const e = new TypeError(\"The URL must be of scheme file\");\n    throw e.code = \"ERR_INVALID_URL_SCHEME\", e;\n  }\n  return Tr(n);\n}\nfunction Tr(n) {\n  if (n.hostname !== \"\") {\n    const r = new TypeError(\n      'File URL host must be \"localhost\" or empty on darwin'\n    );\n    throw r.code = \"ERR_INVALID_FILE_URL_HOST\", r;\n  }\n  const e = n.pathname;\n  let t = -1;\n  for (; ++t < e.length; )\n    if (e.charCodeAt(t) === 37 && e.charCodeAt(t + 1) === 50) {\n      const r = e.charCodeAt(t + 2);\n      if (r === 70 || r === 102) {\n        const i = new TypeError(\n          \"File URL path must not include encoded / characters\"\n        );\n        throw i.code = \"ERR_INVALID_FILE_URL_PATH\", i;\n      }\n    }\n  return decodeURIComponent(e);\n}\nconst re = [\"history\", \"path\", \"basename\", \"stem\", \"extname\", \"dirname\"];\nclass Ft {\n  /**\n   * Create a new virtual file.\n   *\n   * `options` is treated as:\n   *\n   * *   `string` or `Buffer` â€” `{value: options}`\n   * *   `URL` â€” `{path: options}`\n   * *   `VFile` â€” shallow copies its data over to the new file\n   * *   `object` â€” all fields are shallow copied over to the new file\n   *\n   * Path related fields are set in the following order (least specific to\n   * most specific): `history`, `path`, `basename`, `stem`, `extname`,\n   * `dirname`.\n   *\n   * You cannot set `dirname` or `extname` without setting either `history`,\n   * `path`, `basename`, or `stem` too.\n   *\n   * @param {Compatible | null | undefined} [value]\n   *   File value.\n   * @returns\n   *   New instance.\n   */\n  constructor(e) {\n    let t;\n    e ? typeof e == \"string\" || Ir(e) ? t = { value: e } : me(e) ? t = { path: e } : t = e : t = {}, this.data = {}, this.messages = [], this.history = [], this.cwd = Ar.cwd(), this.value, this.stored, this.result, this.map;\n    let r = -1;\n    for (; ++r < re.length; ) {\n      const l = re[r];\n      l in t && t[l] !== void 0 && t[l] !== null && (this[l] = l === \"history\" ? [...t[l]] : t[l]);\n    }\n    let i;\n    for (i in t)\n      re.includes(i) || (this[i] = t[i]);\n  }\n  /**\n   * Get the full path (example: `'~/index.min.js'`).\n   *\n   * @returns {string}\n   */\n  get path() {\n    return this.history[this.history.length - 1];\n  }\n  /**\n   * Set the full path (example: `'~/index.min.js'`).\n   *\n   * Cannot be nullified.\n   * You can set a file URL (a `URL` object with a `file:` protocol) which will\n   * be turned into a path with `url.fileURLToPath`.\n   *\n   * @param {string | URL} path\n   */\n  set path(e) {\n    me(e) && (e = Fr(e)), le(e, \"path\"), this.path !== e && this.history.push(e);\n  }\n  /**\n   * Get the parent path (example: `'~'`).\n   */\n  get dirname() {\n    return typeof this.path == \"string\" ? mn.dirname(this.path) : void 0;\n  }\n  /**\n   * Set the parent path (example: `'~'`).\n   *\n   * Cannot be set if thereâ€™s no `path` yet.\n   */\n  set dirname(e) {\n    Me(this.basename, \"dirname\"), this.path = mn.join(e || \"\", this.basename);\n  }\n  /**\n   * Get the basename (including extname) (example: `'index.min.js'`).\n   */\n  get basename() {\n    return typeof this.path == \"string\" ? mn.basename(this.path) : void 0;\n  }\n  /**\n   * Set basename (including extname) (`'index.min.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set basename(e) {\n    le(e, \"basename\"), ie(e, \"basename\"), this.path = mn.join(this.dirname || \"\", e);\n  }\n  /**\n   * Get the extname (including dot) (example: `'.js'`).\n   */\n  get extname() {\n    return typeof this.path == \"string\" ? mn.extname(this.path) : void 0;\n  }\n  /**\n   * Set the extname (including dot) (example: `'.js'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be set if thereâ€™s no `path` yet.\n   */\n  set extname(e) {\n    if (ie(e, \"extname\"), Me(this.dirname, \"extname\"), e) {\n      if (e.charCodeAt(0) !== 46)\n        throw new Error(\"`extname` must start with `.`\");\n      if (e.includes(\".\", 1))\n        throw new Error(\"`extname` cannot contain multiple dots\");\n    }\n    this.path = mn.join(this.dirname, this.stem + (e || \"\"));\n  }\n  /**\n   * Get the stem (basename w/o extname) (example: `'index.min'`).\n   */\n  get stem() {\n    return typeof this.path == \"string\" ? mn.basename(this.path, this.extname) : void 0;\n  }\n  /**\n   * Set the stem (basename w/o extname) (example: `'index.min'`).\n   *\n   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\\'`\n   * on windows).\n   * Cannot be nullified (use `file.path = file.dirname` instead).\n   */\n  set stem(e) {\n    le(e, \"stem\"), ie(e, \"stem\"), this.path = mn.join(this.dirname || \"\", e + (this.extname || \"\"));\n  }\n  /**\n   * Serialize the file.\n   *\n   * @param {BufferEncoding | null | undefined} [encoding='utf8']\n   *   Character encoding to understand `value` as when itâ€™s a `Buffer`\n   *   (default: `'utf8'`).\n   * @returns {string}\n   *   Serialized file.\n   */\n  toString(e) {\n    return (this.value || \"\").toString(e || void 0);\n  }\n  /**\n   * Create a warning message associated with the file.\n   *\n   * Its `fatal` is set to `false` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  message(e, t, r) {\n    const i = new cn(e, t, r);\n    return this.path && (i.name = this.path + \":\" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;\n  }\n  /**\n   * Create an info message associated with the file.\n   *\n   * Its `fatal` is set to `null` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {VFileMessage}\n   *   Message.\n   */\n  info(e, t, r) {\n    const i = this.message(e, t, r);\n    return i.fatal = null, i;\n  }\n  /**\n   * Create a fatal error associated with the file.\n   *\n   * Its `fatal` is set to `true` and `file` is set to the current file path.\n   * Its added to `file.messages`.\n   *\n   * > ðŸ‘‰ **Note**: a fatal error means that a file is no longer processable.\n   *\n   * @param {string | Error | VFileMessage} reason\n   *   Reason for message, uses the stack and message of the error if given.\n   * @param {Node | NodeLike | Position | Point | null | undefined} [place]\n   *   Place in file where the message occurred.\n   * @param {string | null | undefined} [origin]\n   *   Place in code where the message originates (example:\n   *   `'my-package:my-rule'` or `'my-rule'`).\n   * @returns {never}\n   *   Message.\n   * @throws {VFileMessage}\n   *   Message.\n   */\n  fail(e, t, r) {\n    const i = this.message(e, t, r);\n    throw i.fatal = !0, i;\n  }\n}\nfunction ie(n, e) {\n  if (n && n.includes(mn.sep))\n    throw new Error(\n      \"`\" + e + \"` cannot be a path: did not expect `\" + mn.sep + \"`\"\n    );\n}\nfunction le(n, e) {\n  if (!n)\n    throw new Error(\"`\" + e + \"` cannot be empty\");\n}\nfunction Me(n, e) {\n  if (!n)\n    throw new Error(\"Setting `\" + e + \"` requires `path` to be set too\");\n}\nfunction Ir(n) {\n  return Pt(n);\n}\nfunction Be(n) {\n  if (n)\n    throw n;\n}\nvar Yn = Object.prototype.hasOwnProperty, Tt = Object.prototype.toString, Ne = Object.defineProperty, je = Object.getOwnPropertyDescriptor, $e = function(e) {\n  return typeof Array.isArray == \"function\" ? Array.isArray(e) : Tt.call(e) === \"[object Array]\";\n}, He = function(e) {\n  if (!e || Tt.call(e) !== \"[object Object]\")\n    return !1;\n  var t = Yn.call(e, \"constructor\"), r = e.constructor && e.constructor.prototype && Yn.call(e.constructor.prototype, \"isPrototypeOf\");\n  if (e.constructor && !t && !r)\n    return !1;\n  var i;\n  for (i in e)\n    ;\n  return typeof i > \"u\" || Yn.call(e, i);\n}, Ue = function(e, t) {\n  Ne && t.name === \"__proto__\" ? Ne(e, t.name, {\n    enumerable: !0,\n    configurable: !0,\n    value: t.newValue,\n    writable: !0\n  }) : e[t.name] = t.newValue;\n}, Ve = function(e, t) {\n  if (t === \"__proto__\")\n    if (Yn.call(e, t)) {\n      if (je)\n        return je(e, t).value;\n    } else\n      return;\n  return e[t];\n}, qe = function n() {\n  var e, t, r, i, l, o, u = arguments[0], a = 1, c = arguments.length, s = !1;\n  for (typeof u == \"boolean\" && (s = u, u = arguments[1] || {}, a = 2), (u == null || typeof u != \"object\" && typeof u != \"function\") && (u = {}); a < c; ++a)\n    if (e = arguments[a], e != null)\n      for (t in e)\n        r = Ve(u, t), i = Ve(e, t), u !== i && (s && i && (He(i) || (l = $e(i))) ? (l ? (l = !1, o = r && $e(r) ? r : []) : o = r && He(r) ? r : {}, Ue(u, { name: t, newValue: n(s, o, i) })) : typeof i < \"u\" && Ue(u, { name: t, newValue: i }));\n  return u;\n};\nfunction de(n) {\n  if (typeof n != \"object\" || n === null)\n    return !1;\n  const e = Object.getPrototypeOf(n);\n  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n);\n}\nfunction Or() {\n  const n = [], e = { run: t, use: r };\n  return e;\n  function t(...i) {\n    let l = -1;\n    const o = i.pop();\n    if (typeof o != \"function\")\n      throw new TypeError(\"Expected function as last argument, not \" + o);\n    u(null, ...i);\n    function u(a, ...c) {\n      const s = n[++l];\n      let h = -1;\n      if (a) {\n        o(a);\n        return;\n      }\n      for (; ++h < i.length; )\n        (c[h] === null || c[h] === void 0) && (c[h] = i[h]);\n      i = c, s ? Lr(s, u)(...c) : o(null, ...c);\n    }\n  }\n  function r(i) {\n    if (typeof i != \"function\")\n      throw new TypeError(\n        \"Expected `middelware` to be a function, not \" + i\n      );\n    return n.push(i), e;\n  }\n}\nfunction Lr(n, e) {\n  let t;\n  return r;\n  function r(...o) {\n    const u = n.length > o.length;\n    let a;\n    u && o.push(i);\n    try {\n      a = n.apply(this, o);\n    } catch (c) {\n      const s = (\n        /** @type {Error} */\n        c\n      );\n      if (u && t)\n        throw s;\n      return i(s);\n    }\n    u || (a instanceof Promise ? a.then(l, i) : a instanceof Error ? i(a) : l(a));\n  }\n  function i(o, ...u) {\n    t || (t = !0, e(o, ...u));\n  }\n  function l(o) {\n    i(null, o);\n  }\n}\nconst Dr = Ot().freeze(), It = {}.hasOwnProperty;\nfunction Ot() {\n  const n = Or(), e = [];\n  let t = {}, r, i = -1;\n  return l.data = o, l.Parser = void 0, l.Compiler = void 0, l.freeze = u, l.attachers = e, l.use = a, l.parse = c, l.stringify = s, l.run = h, l.runSync = g, l.process = d, l.processSync = m, l;\n  function l() {\n    const y = Ot();\n    let x = -1;\n    for (; ++x < e.length; )\n      y.use(...e[x]);\n    return y.data(qe(!0, {}, t)), y;\n  }\n  function o(y, x) {\n    return typeof y == \"string\" ? arguments.length === 2 ? (ae(\"data\", r), t[y] = x, l) : It.call(t, y) && t[y] || null : y ? (ae(\"data\", r), t = y, l) : t;\n  }\n  function u() {\n    if (r)\n      return l;\n    for (; ++i < e.length; ) {\n      const [y, ...x] = e[i];\n      if (x[0] === !1)\n        continue;\n      x[0] === !0 && (x[0] = void 0);\n      const w = y.call(l, ...x);\n      typeof w == \"function\" && n.use(w);\n    }\n    return r = !0, i = Number.POSITIVE_INFINITY, l;\n  }\n  function a(y, ...x) {\n    let w;\n    if (ae(\"use\", r), y != null)\n      if (typeof y == \"function\")\n        T(y, ...x);\n      else if (typeof y == \"object\")\n        Array.isArray(y) ? _(y) : A(y);\n      else\n        throw new TypeError(\"Expected usable value, not `\" + y + \"`\");\n    return w && (t.settings = Object.assign(t.settings || {}, w)), l;\n    function v(b) {\n      if (typeof b == \"function\")\n        T(b);\n      else if (typeof b == \"object\")\n        if (Array.isArray(b)) {\n          const [I, ...R] = b;\n          T(I, ...R);\n        } else\n          A(b);\n      else\n        throw new TypeError(\"Expected usable value, not `\" + b + \"`\");\n    }\n    function A(b) {\n      _(b.plugins), b.settings && (w = Object.assign(w || {}, b.settings));\n    }\n    function _(b) {\n      let I = -1;\n      if (b != null)\n        if (Array.isArray(b))\n          for (; ++I < b.length; ) {\n            const R = b[I];\n            v(R);\n          }\n        else\n          throw new TypeError(\"Expected a list of plugins, not `\" + b + \"`\");\n    }\n    function T(b, I) {\n      let R = -1, M;\n      for (; ++R < e.length; )\n        if (e[R][0] === b) {\n          M = e[R];\n          break;\n        }\n      M ? (de(M[1]) && de(I) && (I = qe(!0, M[1], I)), M[1] = I) : e.push([...arguments]);\n    }\n  }\n  function c(y) {\n    l.freeze();\n    const x = jn(y), w = l.Parser;\n    return oe(\"parse\", w), We(w, \"parse\") ? new w(String(x), x).parse() : w(String(x), x);\n  }\n  function s(y, x) {\n    l.freeze();\n    const w = jn(x), v = l.Compiler;\n    return ue(\"stringify\", v), Ye(y), We(v, \"compile\") ? new v(y, w).compile() : v(y, w);\n  }\n  function h(y, x, w) {\n    if (Ye(y), l.freeze(), !w && typeof x == \"function\" && (w = x, x = void 0), !w)\n      return new Promise(v);\n    v(null, w);\n    function v(A, _) {\n      n.run(y, jn(x), T);\n      function T(b, I, R) {\n        I = I || y, b ? _(b) : A ? A(I) : w(null, I, R);\n      }\n    }\n  }\n  function g(y, x) {\n    let w, v;\n    return l.run(y, x, A), Qe(\"runSync\", \"run\", v), w;\n    function A(_, T) {\n      Be(_), w = T, v = !0;\n    }\n  }\n  function d(y, x) {\n    if (l.freeze(), oe(\"process\", l.Parser), ue(\"process\", l.Compiler), !x)\n      return new Promise(w);\n    w(null, x);\n    function w(v, A) {\n      const _ = jn(y);\n      l.run(l.parse(_), _, (b, I, R) => {\n        if (b || !I || !R)\n          T(b);\n        else {\n          const M = l.stringify(I, R);\n          M == null || (Rr(M) ? R.value = M : R.result = M), T(b, R);\n        }\n      });\n      function T(b, I) {\n        b || !I ? A(b) : v ? v(I) : x(null, I);\n      }\n    }\n  }\n  function m(y) {\n    let x;\n    l.freeze(), oe(\"processSync\", l.Parser), ue(\"processSync\", l.Compiler);\n    const w = jn(y);\n    return l.process(w, v), Qe(\"processSync\", \"process\", x), w;\n    function v(A) {\n      x = !0, Be(A);\n    }\n  }\n}\nfunction We(n, e) {\n  return typeof n == \"function\" && // Prototypes do exist.\n  // type-coverage:ignore-next-line\n  n.prototype && // A function with keys in its prototype is probably a constructor.\n  // Classesâ€™ prototype methods are not enumerable, so we check if some value\n  // exists in the prototype.\n  // type-coverage:ignore-next-line\n  (vr(n.prototype) || e in n.prototype);\n}\nfunction vr(n) {\n  let e;\n  for (e in n)\n    if (It.call(n, e))\n      return !0;\n  return !1;\n}\nfunction oe(n, e) {\n  if (typeof e != \"function\")\n    throw new TypeError(\"Cannot `\" + n + \"` without `Parser`\");\n}\nfunction ue(n, e) {\n  if (typeof e != \"function\")\n    throw new TypeError(\"Cannot `\" + n + \"` without `Compiler`\");\n}\nfunction ae(n, e) {\n  if (e)\n    throw new Error(\n      \"Cannot call `\" + n + \"` on a frozen processor.\\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.\"\n    );\n}\nfunction Ye(n) {\n  if (!de(n) || typeof n.type != \"string\")\n    throw new TypeError(\"Expected node, got `\" + n + \"`\");\n}\nfunction Qe(n, e, t) {\n  if (!t)\n    throw new Error(\n      \"`\" + n + \"` finished async. Use `\" + e + \"` instead\"\n    );\n}\nfunction jn(n) {\n  return zr(n) ? n : new Ft(n);\n}\nfunction zr(n) {\n  return !!(n && typeof n == \"object\" && \"message\" in n && \"messages\" in n);\n}\nfunction Rr(n) {\n  return typeof n == \"string\" || Pt(n);\n}\nfunction _r(n, e) {\n  const t = (e || {}).includeImageAlt;\n  return Lt(\n    n,\n    typeof t == \"boolean\" ? t : !0\n  );\n}\nfunction Lt(n, e) {\n  return Mr(n) && (\"value\" in n && n.value || e && \"alt\" in n && n.alt || \"children\" in n && Xe(n.children, e)) || Array.isArray(n) && Xe(n, e) || \"\";\n}\nfunction Xe(n, e) {\n  const t = [];\n  let r = -1;\n  for (; ++r < n.length; )\n    t[r] = Lt(n[r], e);\n  return t.join(\"\");\n}\nfunction Mr(n) {\n  return !!(n && typeof n == \"object\");\n}\nfunction gn(n, e, t, r) {\n  const i = n.length;\n  let l = 0, o;\n  if (e < 0 ? e = -e > i ? 0 : i + e : e = e > i ? i : e, t = t > 0 ? t : 0, r.length < 1e4)\n    o = Array.from(r), o.unshift(e, t), [].splice.apply(n, o);\n  else\n    for (t && [].splice.apply(n, [e, t]); l < r.length; )\n      o = r.slice(l, l + 1e4), o.unshift(e, 0), [].splice.apply(n, o), l += 1e4, e += 1e4;\n}\nfunction an(n, e) {\n  return n.length > 0 ? (gn(n, n.length, 0, e), n) : e;\n}\nconst Ke = {}.hasOwnProperty;\nfunction Br(n) {\n  const e = {};\n  let t = -1;\n  for (; ++t < n.length; )\n    Nr(e, n[t]);\n  return e;\n}\nfunction Nr(n, e) {\n  let t;\n  for (t in e) {\n    const i = (Ke.call(n, t) ? n[t] : void 0) || (n[t] = {}), l = e[t];\n    let o;\n    for (o in l) {\n      Ke.call(i, o) || (i[o] = []);\n      const u = l[o];\n      jr(\n        // @ts-expect-error Looks like a list.\n        i[o],\n        Array.isArray(u) ? u : u ? [u] : []\n      );\n    }\n  }\n}\nfunction jr(n, e) {\n  let t = -1;\n  const r = [];\n  for (; ++t < e.length; )\n    (e[t].add === \"after\" ? n : r).push(e[t]);\n  gn(n, 0, 0, r);\n}\nconst $r = /[!-/:-@[-`{-~\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u09FD\\u0A76\\u0AF0\\u0C77\\u0C84\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2308-\\u230B\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E4F\\u2E52\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA8FC\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/, dn = An(/[A-Za-z]/), ge = An(/\\d/), Hr = An(/[\\dA-Fa-f]/), on = An(/[\\dA-Za-z]/), Ur = An(/[!-/:-@[-`{-~]/), Ge = An(/[#-'*+\\--9=?A-Z^-~]/);\nfunction ye(n) {\n  return (\n    // Special whitespace codes (which have negative values), C0 and Control\n    // character DEL\n    n !== null && (n < 32 || n === 127)\n  );\n}\nfunction sn(n) {\n  return n !== null && (n < 0 || n === 32);\n}\nfunction L(n) {\n  return n !== null && n < -2;\n}\nfunction G(n) {\n  return n === -2 || n === -1 || n === 32;\n}\nconst Vr = An(/\\s/), qr = An($r);\nfunction An(n) {\n  return e;\n  function e(t) {\n    return t !== null && n.test(String.fromCharCode(t));\n  }\n}\nfunction U(n, e, t, r) {\n  const i = r ? r - 1 : Number.POSITIVE_INFINITY;\n  let l = 0;\n  return o;\n  function o(a) {\n    return G(a) ? (n.enter(t), u(a)) : e(a);\n  }\n  function u(a) {\n    return G(a) && l++ < i ? (n.consume(a), u) : (n.exit(t), e(a));\n  }\n}\nconst Wr = {\n  tokenize: Yr\n};\nfunction Yr(n) {\n  const e = n.attempt(\n    this.parser.constructs.contentInitial,\n    r,\n    i\n  );\n  let t;\n  return e;\n  function r(u) {\n    if (u === null) {\n      n.consume(u);\n      return;\n    }\n    return n.enter(\"lineEnding\"), n.consume(u), n.exit(\"lineEnding\"), U(n, e, \"linePrefix\");\n  }\n  function i(u) {\n    return n.enter(\"paragraph\"), l(u);\n  }\n  function l(u) {\n    const a = n.enter(\"chunkText\", {\n      contentType: \"text\",\n      previous: t\n    });\n    return t && (t.next = a), t = a, o(u);\n  }\n  function o(u) {\n    if (u === null) {\n      n.exit(\"chunkText\"), n.exit(\"paragraph\"), n.consume(u);\n      return;\n    }\n    return L(u) ? (n.consume(u), n.exit(\"chunkText\"), l) : (n.consume(u), o);\n  }\n}\nconst Qr = {\n  tokenize: Xr\n}, Ze = {\n  tokenize: Kr\n};\nfunction Xr(n) {\n  const e = this, t = [];\n  let r = 0, i, l, o;\n  return u;\n  function u(A) {\n    if (r < t.length) {\n      const _ = t[r];\n      return e.containerState = _[1], n.attempt(\n        _[0].continuation,\n        a,\n        c\n      )(A);\n    }\n    return c(A);\n  }\n  function a(A) {\n    if (r++, e.containerState._closeFlow) {\n      e.containerState._closeFlow = void 0, i && v();\n      const _ = e.events.length;\n      let T = _, b;\n      for (; T--; )\n        if (e.events[T][0] === \"exit\" && e.events[T][1].type === \"chunkFlow\") {\n          b = e.events[T][1].end;\n          break;\n        }\n      w(r);\n      let I = _;\n      for (; I < e.events.length; )\n        e.events[I][1].end = Object.assign({}, b), I++;\n      return gn(\n        e.events,\n        T + 1,\n        0,\n        e.events.slice(_)\n      ), e.events.length = I, c(A);\n    }\n    return u(A);\n  }\n  function c(A) {\n    if (r === t.length) {\n      if (!i)\n        return g(A);\n      if (i.currentConstruct && i.currentConstruct.concrete)\n        return m(A);\n      e.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);\n    }\n    return e.containerState = {}, n.check(\n      Ze,\n      s,\n      h\n    )(A);\n  }\n  function s(A) {\n    return i && v(), w(r), g(A);\n  }\n  function h(A) {\n    return e.parser.lazy[e.now().line] = r !== t.length, o = e.now().offset, m(A);\n  }\n  function g(A) {\n    return e.containerState = {}, n.attempt(\n      Ze,\n      d,\n      m\n    )(A);\n  }\n  function d(A) {\n    return r++, t.push([e.currentConstruct, e.containerState]), g(A);\n  }\n  function m(A) {\n    if (A === null) {\n      i && v(), w(0), n.consume(A);\n      return;\n    }\n    return i = i || e.parser.flow(e.now()), n.enter(\"chunkFlow\", {\n      contentType: \"flow\",\n      previous: l,\n      _tokenizer: i\n    }), y(A);\n  }\n  function y(A) {\n    if (A === null) {\n      x(n.exit(\"chunkFlow\"), !0), w(0), n.consume(A);\n      return;\n    }\n    return L(A) ? (n.consume(A), x(n.exit(\"chunkFlow\")), r = 0, e.interrupt = void 0, u) : (n.consume(A), y);\n  }\n  function x(A, _) {\n    const T = e.sliceStream(A);\n    if (_ && T.push(null), A.previous = l, l && (l.next = A), l = A, i.defineSkip(A.start), i.write(T), e.parser.lazy[A.start.line]) {\n      let b = i.events.length;\n      for (; b--; )\n        if (\n          // The token starts before the line endingâ€¦\n          i.events[b][1].start.offset < o && // â€¦and either is not ended yetâ€¦\n          (!i.events[b][1].end || // â€¦or ends after it.\n          i.events[b][1].end.offset > o)\n        )\n          return;\n      const I = e.events.length;\n      let R = I, M, X;\n      for (; R--; )\n        if (e.events[R][0] === \"exit\" && e.events[R][1].type === \"chunkFlow\") {\n          if (M) {\n            X = e.events[R][1].end;\n            break;\n          }\n          M = !0;\n        }\n      for (w(r), b = I; b < e.events.length; )\n        e.events[b][1].end = Object.assign({}, X), b++;\n      gn(\n        e.events,\n        R + 1,\n        0,\n        e.events.slice(I)\n      ), e.events.length = b;\n    }\n  }\n  function w(A) {\n    let _ = t.length;\n    for (; _-- > A; ) {\n      const T = t[_];\n      e.containerState = T[1], T[0].exit.call(e, n);\n    }\n    t.length = A;\n  }\n  function v() {\n    i.write([null]), l = void 0, i = void 0, e.containerState._closeFlow = void 0;\n  }\n}\nfunction Kr(n, e, t) {\n  return U(\n    n,\n    n.attempt(this.parser.constructs.document, e, t),\n    \"linePrefix\",\n    this.parser.constructs.disable.null.includes(\"codeIndented\") ? void 0 : 4\n  );\n}\nfunction Je(n) {\n  if (n === null || sn(n) || Vr(n))\n    return 1;\n  if (qr(n))\n    return 2;\n}\nfunction Ce(n, e, t) {\n  const r = [];\n  let i = -1;\n  for (; ++i < n.length; ) {\n    const l = n[i].resolveAll;\n    l && !r.includes(l) && (e = l(e, t), r.push(l));\n  }\n  return e;\n}\nconst xe = {\n  name: \"attention\",\n  tokenize: Zr,\n  resolveAll: Gr\n};\nfunction Gr(n, e) {\n  let t = -1, r, i, l, o, u, a, c, s;\n  for (; ++t < n.length; )\n    if (n[t][0] === \"enter\" && n[t][1].type === \"attentionSequence\" && n[t][1]._close) {\n      for (r = t; r--; )\n        if (n[r][0] === \"exit\" && n[r][1].type === \"attentionSequence\" && n[r][1]._open && // If the markers are the same:\n        e.sliceSerialize(n[r][1]).charCodeAt(0) === e.sliceSerialize(n[t][1]).charCodeAt(0)) {\n          if ((n[r][1]._close || n[t][1]._open) && (n[t][1].end.offset - n[t][1].start.offset) % 3 && !((n[r][1].end.offset - n[r][1].start.offset + n[t][1].end.offset - n[t][1].start.offset) % 3))\n            continue;\n          a = n[r][1].end.offset - n[r][1].start.offset > 1 && n[t][1].end.offset - n[t][1].start.offset > 1 ? 2 : 1;\n          const h = Object.assign({}, n[r][1].end), g = Object.assign({}, n[t][1].start);\n          nt(h, -a), nt(g, a), o = {\n            type: a > 1 ? \"strongSequence\" : \"emphasisSequence\",\n            start: h,\n            end: Object.assign({}, n[r][1].end)\n          }, u = {\n            type: a > 1 ? \"strongSequence\" : \"emphasisSequence\",\n            start: Object.assign({}, n[t][1].start),\n            end: g\n          }, l = {\n            type: a > 1 ? \"strongText\" : \"emphasisText\",\n            start: Object.assign({}, n[r][1].end),\n            end: Object.assign({}, n[t][1].start)\n          }, i = {\n            type: a > 1 ? \"strong\" : \"emphasis\",\n            start: Object.assign({}, o.start),\n            end: Object.assign({}, u.end)\n          }, n[r][1].end = Object.assign({}, o.start), n[t][1].start = Object.assign({}, u.end), c = [], n[r][1].end.offset - n[r][1].start.offset && (c = an(c, [\n            [\"enter\", n[r][1], e],\n            [\"exit\", n[r][1], e]\n          ])), c = an(c, [\n            [\"enter\", i, e],\n            [\"enter\", o, e],\n            [\"exit\", o, e],\n            [\"enter\", l, e]\n          ]), c = an(\n            c,\n            Ce(\n              e.parser.constructs.insideSpan.null,\n              n.slice(r + 1, t),\n              e\n            )\n          ), c = an(c, [\n            [\"exit\", l, e],\n            [\"enter\", u, e],\n            [\"exit\", u, e],\n            [\"exit\", i, e]\n          ]), n[t][1].end.offset - n[t][1].start.offset ? (s = 2, c = an(c, [\n            [\"enter\", n[t][1], e],\n            [\"exit\", n[t][1], e]\n          ])) : s = 0, gn(n, r - 1, t - r + 3, c), t = r + c.length - s - 2;\n          break;\n        }\n    }\n  for (t = -1; ++t < n.length; )\n    n[t][1].type === \"attentionSequence\" && (n[t][1].type = \"data\");\n  return n;\n}\nfunction Zr(n, e) {\n  const t = this.parser.constructs.attentionMarkers.null, r = this.previous, i = Je(r);\n  let l;\n  return o;\n  function o(a) {\n    return n.enter(\"attentionSequence\"), l = a, u(a);\n  }\n  function u(a) {\n    if (a === l)\n      return n.consume(a), u;\n    const c = n.exit(\"attentionSequence\"), s = Je(a), h = !s || s === 2 && i || t.includes(a), g = !i || i === 2 && s || t.includes(r);\n    return c._open = !!(l === 42 ? h : h && (i || !g)), c._close = !!(l === 42 ? g : g && (s || !h)), e(a);\n  }\n}\nfunction nt(n, e) {\n  n.column += e, n.offset += e, n._bufferIndex += e;\n}\nconst Jr = {\n  name: \"autolink\",\n  tokenize: ni\n};\nfunction ni(n, e, t) {\n  let r = 1;\n  return i;\n  function i(m) {\n    return n.enter(\"autolink\"), n.enter(\"autolinkMarker\"), n.consume(m), n.exit(\"autolinkMarker\"), n.enter(\"autolinkProtocol\"), l;\n  }\n  function l(m) {\n    return dn(m) ? (n.consume(m), o) : Ge(m) ? c(m) : t(m);\n  }\n  function o(m) {\n    return m === 43 || m === 45 || m === 46 || on(m) ? u(m) : c(m);\n  }\n  function u(m) {\n    return m === 58 ? (n.consume(m), a) : (m === 43 || m === 45 || m === 46 || on(m)) && r++ < 32 ? (n.consume(m), u) : c(m);\n  }\n  function a(m) {\n    return m === 62 ? (n.exit(\"autolinkProtocol\"), d(m)) : m === null || m === 32 || m === 60 || ye(m) ? t(m) : (n.consume(m), a);\n  }\n  function c(m) {\n    return m === 64 ? (n.consume(m), r = 0, s) : Ge(m) ? (n.consume(m), c) : t(m);\n  }\n  function s(m) {\n    return on(m) ? h(m) : t(m);\n  }\n  function h(m) {\n    return m === 46 ? (n.consume(m), r = 0, s) : m === 62 ? (n.exit(\"autolinkProtocol\").type = \"autolinkEmail\", d(m)) : g(m);\n  }\n  function g(m) {\n    return (m === 45 || on(m)) && r++ < 63 ? (n.consume(m), m === 45 ? g : h) : t(m);\n  }\n  function d(m) {\n    return n.enter(\"autolinkMarker\"), n.consume(m), n.exit(\"autolinkMarker\"), n.exit(\"autolink\"), e;\n  }\n}\nconst Zn = {\n  tokenize: ei,\n  partial: !0\n};\nfunction ei(n, e, t) {\n  return U(n, r, \"linePrefix\");\n  function r(i) {\n    return i === null || L(i) ? e(i) : t(i);\n  }\n}\nconst Dt = {\n  name: \"blockQuote\",\n  tokenize: ti,\n  continuation: {\n    tokenize: ri\n  },\n  exit: ii\n};\nfunction ti(n, e, t) {\n  const r = this;\n  return i;\n  function i(o) {\n    if (o === 62) {\n      const u = r.containerState;\n      return u.open || (n.enter(\"blockQuote\", {\n        _container: !0\n      }), u.open = !0), n.enter(\"blockQuotePrefix\"), n.enter(\"blockQuoteMarker\"), n.consume(o), n.exit(\"blockQuoteMarker\"), l;\n    }\n    return t(o);\n  }\n  function l(o) {\n    return G(o) ? (n.enter(\"blockQuotePrefixWhitespace\"), n.consume(o), n.exit(\"blockQuotePrefixWhitespace\"), n.exit(\"blockQuotePrefix\"), e) : (n.exit(\"blockQuotePrefix\"), e(o));\n  }\n}\nfunction ri(n, e, t) {\n  return U(\n    n,\n    n.attempt(Dt, e, t),\n    \"linePrefix\",\n    this.parser.constructs.disable.null.includes(\"codeIndented\") ? void 0 : 4\n  );\n}\nfunction ii(n) {\n  n.exit(\"blockQuote\");\n}\nconst vt = {\n  name: \"characterEscape\",\n  tokenize: li\n};\nfunction li(n, e, t) {\n  return r;\n  function r(l) {\n    return n.enter(\"characterEscape\"), n.enter(\"escapeMarker\"), n.consume(l), n.exit(\"escapeMarker\"), i;\n  }\n  function i(l) {\n    return Ur(l) ? (n.enter(\"characterEscapeValue\"), n.consume(l), n.exit(\"characterEscapeValue\"), n.exit(\"characterEscape\"), e) : t(l);\n  }\n}\nconst et = document.createElement(\"i\");\nfunction Ae(n) {\n  const e = \"&\" + n + \";\";\n  et.innerHTML = e;\n  const t = et.textContent;\n  return t.charCodeAt(t.length - 1) === 59 && n !== \"semi\" || t === e ? !1 : t;\n}\nconst zt = {\n  name: \"characterReference\",\n  tokenize: oi\n};\nfunction oi(n, e, t) {\n  const r = this;\n  let i = 0, l, o;\n  return u;\n  function u(h) {\n    return n.enter(\"characterReference\"), n.enter(\"characterReferenceMarker\"), n.consume(h), n.exit(\"characterReferenceMarker\"), a;\n  }\n  function a(h) {\n    return h === 35 ? (n.enter(\"characterReferenceMarkerNumeric\"), n.consume(h), n.exit(\"characterReferenceMarkerNumeric\"), c) : (n.enter(\"characterReferenceValue\"), l = 31, o = on, s(h));\n  }\n  function c(h) {\n    return h === 88 || h === 120 ? (n.enter(\"characterReferenceMarkerHexadecimal\"), n.consume(h), n.exit(\"characterReferenceMarkerHexadecimal\"), n.enter(\"characterReferenceValue\"), l = 6, o = Hr, s) : (n.enter(\"characterReferenceValue\"), l = 7, o = ge, s(h));\n  }\n  function s(h) {\n    let g;\n    return h === 59 && i ? (g = n.exit(\"characterReferenceValue\"), o === on && !Ae(r.sliceSerialize(g)) ? t(h) : (n.enter(\"characterReferenceMarker\"), n.consume(h), n.exit(\"characterReferenceMarker\"), n.exit(\"characterReference\"), e)) : o(h) && i++ < l ? (n.consume(h), s) : t(h);\n  }\n}\nconst tt = {\n  name: \"codeFenced\",\n  tokenize: ui,\n  concrete: !0\n};\nfunction ui(n, e, t) {\n  const r = this, i = {\n    tokenize: T,\n    partial: !0\n  }, l = {\n    tokenize: _,\n    partial: !0\n  }, o = this.events[this.events.length - 1], u = o && o[1].type === \"linePrefix\" ? o[2].sliceSerialize(o[1], !0).length : 0;\n  let a = 0, c;\n  return s;\n  function s(b) {\n    return n.enter(\"codeFenced\"), n.enter(\"codeFencedFence\"), n.enter(\"codeFencedFenceSequence\"), c = b, h(b);\n  }\n  function h(b) {\n    return b === c ? (n.consume(b), a++, h) : (n.exit(\"codeFencedFenceSequence\"), a < 3 ? t(b) : U(n, g, \"whitespace\")(b));\n  }\n  function g(b) {\n    return b === null || L(b) ? x(b) : (n.enter(\"codeFencedFenceInfo\"), n.enter(\"chunkString\", {\n      contentType: \"string\"\n    }), d(b));\n  }\n  function d(b) {\n    return b === null || sn(b) ? (n.exit(\"chunkString\"), n.exit(\"codeFencedFenceInfo\"), U(n, m, \"whitespace\")(b)) : b === 96 && b === c ? t(b) : (n.consume(b), d);\n  }\n  function m(b) {\n    return b === null || L(b) ? x(b) : (n.enter(\"codeFencedFenceMeta\"), n.enter(\"chunkString\", {\n      contentType: \"string\"\n    }), y(b));\n  }\n  function y(b) {\n    return b === null || L(b) ? (n.exit(\"chunkString\"), n.exit(\"codeFencedFenceMeta\"), x(b)) : b === 96 && b === c ? t(b) : (n.consume(b), y);\n  }\n  function x(b) {\n    return n.exit(\"codeFencedFence\"), r.interrupt ? e(b) : w(b);\n  }\n  function w(b) {\n    return b === null ? A(b) : L(b) ? n.attempt(\n      l,\n      n.attempt(\n        i,\n        A,\n        u ? U(\n          n,\n          w,\n          \"linePrefix\",\n          u + 1\n        ) : w\n      ),\n      A\n    )(b) : (n.enter(\"codeFlowValue\"), v(b));\n  }\n  function v(b) {\n    return b === null || L(b) ? (n.exit(\"codeFlowValue\"), w(b)) : (n.consume(b), v);\n  }\n  function A(b) {\n    return n.exit(\"codeFenced\"), e(b);\n  }\n  function _(b, I, R) {\n    const M = this;\n    return X;\n    function X(F) {\n      return b.enter(\"lineEnding\"), b.consume(F), b.exit(\"lineEnding\"), C;\n    }\n    function C(F) {\n      return M.parser.lazy[M.now().line] ? R(F) : I(F);\n    }\n  }\n  function T(b, I, R) {\n    let M = 0;\n    return U(\n      b,\n      X,\n      \"linePrefix\",\n      this.parser.constructs.disable.null.includes(\"codeIndented\") ? void 0 : 4\n    );\n    function X(B) {\n      return b.enter(\"codeFencedFence\"), b.enter(\"codeFencedFenceSequence\"), C(B);\n    }\n    function C(B) {\n      return B === c ? (b.consume(B), M++, C) : M < a ? R(B) : (b.exit(\"codeFencedFenceSequence\"), U(b, F, \"whitespace\")(B));\n    }\n    function F(B) {\n      return B === null || L(B) ? (b.exit(\"codeFencedFence\"), I(B)) : R(B);\n    }\n  }\n}\nconst se = {\n  name: \"codeIndented\",\n  tokenize: si\n}, ai = {\n  tokenize: ci,\n  partial: !0\n};\nfunction si(n, e, t) {\n  const r = this;\n  return i;\n  function i(c) {\n    return n.enter(\"codeIndented\"), U(n, l, \"linePrefix\", 4 + 1)(c);\n  }\n  function l(c) {\n    const s = r.events[r.events.length - 1];\n    return s && s[1].type === \"linePrefix\" && s[2].sliceSerialize(s[1], !0).length >= 4 ? o(c) : t(c);\n  }\n  function o(c) {\n    return c === null ? a(c) : L(c) ? n.attempt(ai, o, a)(c) : (n.enter(\"codeFlowValue\"), u(c));\n  }\n  function u(c) {\n    return c === null || L(c) ? (n.exit(\"codeFlowValue\"), o(c)) : (n.consume(c), u);\n  }\n  function a(c) {\n    return n.exit(\"codeIndented\"), e(c);\n  }\n}\nfunction ci(n, e, t) {\n  const r = this;\n  return i;\n  function i(o) {\n    return r.parser.lazy[r.now().line] ? t(o) : L(o) ? (n.enter(\"lineEnding\"), n.consume(o), n.exit(\"lineEnding\"), i) : U(n, l, \"linePrefix\", 4 + 1)(o);\n  }\n  function l(o) {\n    const u = r.events[r.events.length - 1];\n    return u && u[1].type === \"linePrefix\" && u[2].sliceSerialize(u[1], !0).length >= 4 ? e(o) : L(o) ? i(o) : t(o);\n  }\n}\nconst pi = {\n  name: \"codeText\",\n  tokenize: mi,\n  resolve: fi,\n  previous: hi\n};\nfunction fi(n) {\n  let e = n.length - 4, t = 3, r, i;\n  if ((n[t][1].type === \"lineEnding\" || n[t][1].type === \"space\") && (n[e][1].type === \"lineEnding\" || n[e][1].type === \"space\")) {\n    for (r = t; ++r < e; )\n      if (n[r][1].type === \"codeTextData\") {\n        n[t][1].type = \"codeTextPadding\", n[e][1].type = \"codeTextPadding\", t += 2, e -= 2;\n        break;\n      }\n  }\n  for (r = t - 1, e++; ++r <= e; )\n    i === void 0 ? r !== e && n[r][1].type !== \"lineEnding\" && (i = r) : (r === e || n[r][1].type === \"lineEnding\") && (n[i][1].type = \"codeTextData\", r !== i + 2 && (n[i][1].end = n[r - 1][1].end, n.splice(i + 2, r - i - 2), e -= r - i - 2, r = i + 2), i = void 0);\n  return n;\n}\nfunction hi(n) {\n  return n !== 96 || this.events[this.events.length - 1][1].type === \"characterEscape\";\n}\nfunction mi(n, e, t) {\n  let r = 0, i, l;\n  return o;\n  function o(h) {\n    return n.enter(\"codeText\"), n.enter(\"codeTextSequence\"), u(h);\n  }\n  function u(h) {\n    return h === 96 ? (n.consume(h), r++, u) : (n.exit(\"codeTextSequence\"), a(h));\n  }\n  function a(h) {\n    return h === null ? t(h) : h === 96 ? (l = n.enter(\"codeTextSequence\"), i = 0, s(h)) : h === 32 ? (n.enter(\"space\"), n.consume(h), n.exit(\"space\"), a) : L(h) ? (n.enter(\"lineEnding\"), n.consume(h), n.exit(\"lineEnding\"), a) : (n.enter(\"codeTextData\"), c(h));\n  }\n  function c(h) {\n    return h === null || h === 32 || h === 96 || L(h) ? (n.exit(\"codeTextData\"), a(h)) : (n.consume(h), c);\n  }\n  function s(h) {\n    return h === 96 ? (n.consume(h), i++, s) : i === r ? (n.exit(\"codeTextSequence\"), n.exit(\"codeText\"), e(h)) : (l.type = \"codeTextData\", c(h));\n  }\n}\nfunction Rt(n) {\n  const e = {};\n  let t = -1, r, i, l, o, u, a, c;\n  for (; ++t < n.length; ) {\n    for (; t in e; )\n      t = e[t];\n    if (r = n[t], t && r[1].type === \"chunkFlow\" && n[t - 1][1].type === \"listItemPrefix\" && (a = r[1]._tokenizer.events, l = 0, l < a.length && a[l][1].type === \"lineEndingBlank\" && (l += 2), l < a.length && a[l][1].type === \"content\"))\n      for (; ++l < a.length && a[l][1].type !== \"content\"; )\n        a[l][1].type === \"chunkText\" && (a[l][1]._isInFirstContentOfListItem = !0, l++);\n    if (r[0] === \"enter\")\n      r[1].contentType && (Object.assign(e, di(n, t)), t = e[t], c = !0);\n    else if (r[1]._container) {\n      for (l = t, i = void 0; l-- && (o = n[l], o[1].type === \"lineEnding\" || o[1].type === \"lineEndingBlank\"); )\n        o[0] === \"enter\" && (i && (n[i][1].type = \"lineEndingBlank\"), o[1].type = \"lineEnding\", i = l);\n      i && (r[1].end = Object.assign({}, n[i][1].start), u = n.slice(i, t), u.unshift(r), gn(n, i, t - i + 1, u));\n    }\n  }\n  return !c;\n}\nfunction di(n, e) {\n  const t = n[e][1], r = n[e][2];\n  let i = e - 1;\n  const l = [], o = t._tokenizer || r.parser[t.contentType](t.start), u = o.events, a = [], c = {};\n  let s, h, g = -1, d = t, m = 0, y = 0;\n  const x = [y];\n  for (; d; ) {\n    for (; n[++i][1] !== d; )\n      ;\n    l.push(i), d._tokenizer || (s = r.sliceStream(d), d.next || s.push(null), h && o.defineSkip(d.start), d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(s), d._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), h = d, d = d.next;\n  }\n  for (d = t; ++g < u.length; )\n    // Find a void token that includes a break.\n    u[g][0] === \"exit\" && u[g - 1][0] === \"enter\" && u[g][1].type === u[g - 1][1].type && u[g][1].start.line !== u[g][1].end.line && (y = g + 1, x.push(y), d._tokenizer = void 0, d.previous = void 0, d = d.next);\n  for (o.events = [], d ? (d._tokenizer = void 0, d.previous = void 0) : x.pop(), g = x.length; g--; ) {\n    const w = u.slice(x[g], x[g + 1]), v = l.pop();\n    a.unshift([v, v + w.length - 1]), gn(n, v, 2, w);\n  }\n  for (g = -1; ++g < a.length; )\n    c[m + a[g][0]] = m + a[g][1], m += a[g][1] - a[g][0] - 1;\n  return c;\n}\nconst gi = {\n  tokenize: ki,\n  resolve: xi\n}, yi = {\n  tokenize: bi,\n  partial: !0\n};\nfunction xi(n) {\n  return Rt(n), n;\n}\nfunction ki(n, e) {\n  let t;\n  return r;\n  function r(u) {\n    return n.enter(\"content\"), t = n.enter(\"chunkContent\", {\n      contentType: \"content\"\n    }), i(u);\n  }\n  function i(u) {\n    return u === null ? l(u) : L(u) ? n.check(\n      yi,\n      o,\n      l\n    )(u) : (n.consume(u), i);\n  }\n  function l(u) {\n    return n.exit(\"chunkContent\"), n.exit(\"content\"), e(u);\n  }\n  function o(u) {\n    return n.consume(u), n.exit(\"chunkContent\"), t.next = n.enter(\"chunkContent\", {\n      contentType: \"content\",\n      previous: t\n    }), t = t.next, i;\n  }\n}\nfunction bi(n, e, t) {\n  const r = this;\n  return i;\n  function i(o) {\n    return n.exit(\"chunkContent\"), n.enter(\"lineEnding\"), n.consume(o), n.exit(\"lineEnding\"), U(n, l, \"linePrefix\");\n  }\n  function l(o) {\n    if (o === null || L(o))\n      return t(o);\n    const u = r.events[r.events.length - 1];\n    return !r.parser.constructs.disable.null.includes(\"codeIndented\") && u && u[1].type === \"linePrefix\" && u[2].sliceSerialize(u[1], !0).length >= 4 ? e(o) : n.interrupt(r.parser.constructs.flow, t, e)(o);\n  }\n}\nfunction _t(n, e, t, r, i, l, o, u, a) {\n  const c = a || Number.POSITIVE_INFINITY;\n  let s = 0;\n  return h;\n  function h(w) {\n    return w === 60 ? (n.enter(r), n.enter(i), n.enter(l), n.consume(w), n.exit(l), g) : w === null || w === 41 || ye(w) ? t(w) : (n.enter(r), n.enter(o), n.enter(u), n.enter(\"chunkString\", {\n      contentType: \"string\"\n    }), y(w));\n  }\n  function g(w) {\n    return w === 62 ? (n.enter(l), n.consume(w), n.exit(l), n.exit(i), n.exit(r), e) : (n.enter(u), n.enter(\"chunkString\", {\n      contentType: \"string\"\n    }), d(w));\n  }\n  function d(w) {\n    return w === 62 ? (n.exit(\"chunkString\"), n.exit(u), g(w)) : w === null || w === 60 || L(w) ? t(w) : (n.consume(w), w === 92 ? m : d);\n  }\n  function m(w) {\n    return w === 60 || w === 62 || w === 92 ? (n.consume(w), d) : d(w);\n  }\n  function y(w) {\n    return w === 40 ? ++s > c ? t(w) : (n.consume(w), y) : w === 41 ? s-- ? (n.consume(w), y) : (n.exit(\"chunkString\"), n.exit(u), n.exit(o), n.exit(r), e(w)) : w === null || sn(w) ? s ? t(w) : (n.exit(\"chunkString\"), n.exit(u), n.exit(o), n.exit(r), e(w)) : ye(w) ? t(w) : (n.consume(w), w === 92 ? x : y);\n  }\n  function x(w) {\n    return w === 40 || w === 41 || w === 92 ? (n.consume(w), y) : y(w);\n  }\n}\nfunction Mt(n, e, t, r, i, l) {\n  const o = this;\n  let u = 0, a;\n  return c;\n  function c(d) {\n    return n.enter(r), n.enter(i), n.consume(d), n.exit(i), n.enter(l), s;\n  }\n  function s(d) {\n    return d === null || d === 91 || d === 93 && !a || /* To do: remove in the future once weâ€™ve switched from\n     * `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,\n     * which doesnâ€™t need this */\n    /* Hidden footnotes hook */\n    /* c8 ignore next 3 */\n    d === 94 && !u && \"_hiddenFootnoteSupport\" in o.parser.constructs || u > 999 ? t(d) : d === 93 ? (n.exit(l), n.enter(i), n.consume(d), n.exit(i), n.exit(r), e) : L(d) ? (n.enter(\"lineEnding\"), n.consume(d), n.exit(\"lineEnding\"), s) : (n.enter(\"chunkString\", {\n      contentType: \"string\"\n    }), h(d));\n  }\n  function h(d) {\n    return d === null || d === 91 || d === 93 || L(d) || u++ > 999 ? (n.exit(\"chunkString\"), s(d)) : (n.consume(d), a = a || !G(d), d === 92 ? g : h);\n  }\n  function g(d) {\n    return d === 91 || d === 92 || d === 93 ? (n.consume(d), u++, h) : h(d);\n  }\n}\nfunction Bt(n, e, t, r, i, l) {\n  let o;\n  return u;\n  function u(g) {\n    return n.enter(r), n.enter(i), n.consume(g), n.exit(i), o = g === 40 ? 41 : g, a;\n  }\n  function a(g) {\n    return g === o ? (n.enter(i), n.consume(g), n.exit(i), n.exit(r), e) : (n.enter(l), c(g));\n  }\n  function c(g) {\n    return g === o ? (n.exit(l), a(o)) : g === null ? t(g) : L(g) ? (n.enter(\"lineEnding\"), n.consume(g), n.exit(\"lineEnding\"), U(n, c, \"linePrefix\")) : (n.enter(\"chunkString\", {\n      contentType: \"string\"\n    }), s(g));\n  }\n  function s(g) {\n    return g === o || g === null || L(g) ? (n.exit(\"chunkString\"), c(g)) : (n.consume(g), g === 92 ? h : s);\n  }\n  function h(g) {\n    return g === o || g === 92 ? (n.consume(g), s) : s(g);\n  }\n}\nfunction $n(n, e) {\n  let t;\n  return r;\n  function r(i) {\n    return L(i) ? (n.enter(\"lineEnding\"), n.consume(i), n.exit(\"lineEnding\"), t = !0, r) : G(i) ? U(\n      n,\n      r,\n      t ? \"linePrefix\" : \"lineSuffix\"\n    )(i) : e(i);\n  }\n}\nfunction Ln(n) {\n  return n.replace(/[\\t\\n\\r ]+/g, \" \").replace(/^ | $/g, \"\").toLowerCase().toUpperCase();\n}\nconst wi = {\n  name: \"definition\",\n  tokenize: Ei\n}, Si = {\n  tokenize: Ci,\n  partial: !0\n};\nfunction Ei(n, e, t) {\n  const r = this;\n  let i;\n  return l;\n  function l(a) {\n    return n.enter(\"definition\"), Mt.call(\n      r,\n      n,\n      o,\n      t,\n      \"definitionLabel\",\n      \"definitionLabelMarker\",\n      \"definitionLabelString\"\n    )(a);\n  }\n  function o(a) {\n    return i = Ln(\n      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)\n    ), a === 58 ? (n.enter(\"definitionMarker\"), n.consume(a), n.exit(\"definitionMarker\"), $n(\n      n,\n      _t(\n        n,\n        n.attempt(\n          Si,\n          U(n, u, \"whitespace\"),\n          U(n, u, \"whitespace\")\n        ),\n        t,\n        \"definitionDestination\",\n        \"definitionDestinationLiteral\",\n        \"definitionDestinationLiteralMarker\",\n        \"definitionDestinationRaw\",\n        \"definitionDestinationString\"\n      )\n    )) : t(a);\n  }\n  function u(a) {\n    return a === null || L(a) ? (n.exit(\"definition\"), r.parser.defined.includes(i) || r.parser.defined.push(i), e(a)) : t(a);\n  }\n}\nfunction Ci(n, e, t) {\n  return r;\n  function r(o) {\n    return sn(o) ? $n(n, i)(o) : t(o);\n  }\n  function i(o) {\n    return o === 34 || o === 39 || o === 40 ? Bt(\n      n,\n      U(n, l, \"whitespace\"),\n      t,\n      \"definitionTitle\",\n      \"definitionTitleMarker\",\n      \"definitionTitleString\"\n    )(o) : t(o);\n  }\n  function l(o) {\n    return o === null || L(o) ? e(o) : t(o);\n  }\n}\nconst Ai = {\n  name: \"hardBreakEscape\",\n  tokenize: Pi\n};\nfunction Pi(n, e, t) {\n  return r;\n  function r(l) {\n    return n.enter(\"hardBreakEscape\"), n.enter(\"escapeMarker\"), n.consume(l), i;\n  }\n  function i(l) {\n    return L(l) ? (n.exit(\"escapeMarker\"), n.exit(\"hardBreakEscape\"), e(l)) : t(l);\n  }\n}\nconst Fi = {\n  name: \"headingAtx\",\n  tokenize: Ii,\n  resolve: Ti\n};\nfunction Ti(n, e) {\n  let t = n.length - 2, r = 3, i, l;\n  return n[r][1].type === \"whitespace\" && (r += 2), t - 2 > r && n[t][1].type === \"whitespace\" && (t -= 2), n[t][1].type === \"atxHeadingSequence\" && (r === t - 1 || t - 4 > r && n[t - 2][1].type === \"whitespace\") && (t -= r + 1 === t ? 2 : 4), t > r && (i = {\n    type: \"atxHeadingText\",\n    start: n[r][1].start,\n    end: n[t][1].end\n  }, l = {\n    type: \"chunkText\",\n    start: n[r][1].start,\n    end: n[t][1].end,\n    // @ts-expect-error Constants are fine to assign.\n    contentType: \"text\"\n  }, gn(n, r, t - r + 1, [\n    [\"enter\", i, e],\n    [\"enter\", l, e],\n    [\"exit\", l, e],\n    [\"exit\", i, e]\n  ])), n;\n}\nfunction Ii(n, e, t) {\n  const r = this;\n  let i = 0;\n  return l;\n  function l(s) {\n    return n.enter(\"atxHeading\"), n.enter(\"atxHeadingSequence\"), o(s);\n  }\n  function o(s) {\n    return s === 35 && i++ < 6 ? (n.consume(s), o) : s === null || sn(s) ? (n.exit(\"atxHeadingSequence\"), r.interrupt ? e(s) : u(s)) : t(s);\n  }\n  function u(s) {\n    return s === 35 ? (n.enter(\"atxHeadingSequence\"), a(s)) : s === null || L(s) ? (n.exit(\"atxHeading\"), e(s)) : G(s) ? U(n, u, \"whitespace\")(s) : (n.enter(\"atxHeadingText\"), c(s));\n  }\n  function a(s) {\n    return s === 35 ? (n.consume(s), a) : (n.exit(\"atxHeadingSequence\"), u(s));\n  }\n  function c(s) {\n    return s === null || s === 35 || sn(s) ? (n.exit(\"atxHeadingText\"), u(s)) : (n.consume(s), c);\n  }\n}\nconst Oi = [\n  \"address\",\n  \"article\",\n  \"aside\",\n  \"base\",\n  \"basefont\",\n  \"blockquote\",\n  \"body\",\n  \"caption\",\n  \"center\",\n  \"col\",\n  \"colgroup\",\n  \"dd\",\n  \"details\",\n  \"dialog\",\n  \"dir\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"fieldset\",\n  \"figcaption\",\n  \"figure\",\n  \"footer\",\n  \"form\",\n  \"frame\",\n  \"frameset\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\",\n  \"head\",\n  \"header\",\n  \"hr\",\n  \"html\",\n  \"iframe\",\n  \"legend\",\n  \"li\",\n  \"link\",\n  \"main\",\n  \"menu\",\n  \"menuitem\",\n  \"nav\",\n  \"noframes\",\n  \"ol\",\n  \"optgroup\",\n  \"option\",\n  \"p\",\n  \"param\",\n  \"section\",\n  \"summary\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"title\",\n  \"tr\",\n  \"track\",\n  \"ul\"\n], rt = [\"pre\", \"script\", \"style\", \"textarea\"], Li = {\n  name: \"htmlFlow\",\n  tokenize: zi,\n  resolveTo: vi,\n  concrete: !0\n}, Di = {\n  tokenize: Ri,\n  partial: !0\n};\nfunction vi(n) {\n  let e = n.length;\n  for (; e-- && !(n[e][0] === \"enter\" && n[e][1].type === \"htmlFlow\"); )\n    ;\n  return e > 1 && n[e - 2][1].type === \"linePrefix\" && (n[e][1].start = n[e - 2][1].start, n[e + 1][1].start = n[e - 2][1].start, n.splice(e - 2, 2)), n;\n}\nfunction zi(n, e, t) {\n  const r = this;\n  let i, l, o, u, a;\n  return c;\n  function c(p) {\n    return n.enter(\"htmlFlow\"), n.enter(\"htmlFlowData\"), n.consume(p), s;\n  }\n  function s(p) {\n    return p === 33 ? (n.consume(p), h) : p === 47 ? (n.consume(p), m) : p === 63 ? (n.consume(p), i = 3, r.interrupt ? e : J) : dn(p) ? (n.consume(p), o = String.fromCharCode(p), l = !0, y) : t(p);\n  }\n  function h(p) {\n    return p === 45 ? (n.consume(p), i = 2, g) : p === 91 ? (n.consume(p), i = 5, o = \"CDATA[\", u = 0, d) : dn(p) ? (n.consume(p), i = 4, r.interrupt ? e : J) : t(p);\n  }\n  function g(p) {\n    return p === 45 ? (n.consume(p), r.interrupt ? e : J) : t(p);\n  }\n  function d(p) {\n    return p === o.charCodeAt(u++) ? (n.consume(p), u === o.length ? r.interrupt ? e : C : d) : t(p);\n  }\n  function m(p) {\n    return dn(p) ? (n.consume(p), o = String.fromCharCode(p), y) : t(p);\n  }\n  function y(p) {\n    return p === null || p === 47 || p === 62 || sn(p) ? p !== 47 && l && rt.includes(o.toLowerCase()) ? (i = 1, r.interrupt ? e(p) : C(p)) : Oi.includes(o.toLowerCase()) ? (i = 6, p === 47 ? (n.consume(p), x) : r.interrupt ? e(p) : C(p)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? t(p) : l ? v(p) : w(p)) : p === 45 || on(p) ? (n.consume(p), o += String.fromCharCode(p), y) : t(p);\n  }\n  function x(p) {\n    return p === 62 ? (n.consume(p), r.interrupt ? e : C) : t(p);\n  }\n  function w(p) {\n    return G(p) ? (n.consume(p), w) : M(p);\n  }\n  function v(p) {\n    return p === 47 ? (n.consume(p), M) : p === 58 || p === 95 || dn(p) ? (n.consume(p), A) : G(p) ? (n.consume(p), v) : M(p);\n  }\n  function A(p) {\n    return p === 45 || p === 46 || p === 58 || p === 95 || on(p) ? (n.consume(p), A) : _(p);\n  }\n  function _(p) {\n    return p === 61 ? (n.consume(p), T) : G(p) ? (n.consume(p), _) : v(p);\n  }\n  function T(p) {\n    return p === null || p === 60 || p === 61 || p === 62 || p === 96 ? t(p) : p === 34 || p === 39 ? (n.consume(p), a = p, b) : G(p) ? (n.consume(p), T) : (a = null, I(p));\n  }\n  function b(p) {\n    return p === null || L(p) ? t(p) : p === a ? (n.consume(p), R) : (n.consume(p), b);\n  }\n  function I(p) {\n    return p === null || p === 34 || p === 39 || p === 60 || p === 61 || p === 62 || p === 96 || sn(p) ? _(p) : (n.consume(p), I);\n  }\n  function R(p) {\n    return p === 47 || p === 62 || G(p) ? v(p) : t(p);\n  }\n  function M(p) {\n    return p === 62 ? (n.consume(p), X) : t(p);\n  }\n  function X(p) {\n    return G(p) ? (n.consume(p), X) : p === null || L(p) ? C(p) : t(p);\n  }\n  function C(p) {\n    return p === 45 && i === 2 ? (n.consume(p), en) : p === 60 && i === 1 ? (n.consume(p), un) : p === 62 && i === 4 ? (n.consume(p), W) : p === 63 && i === 3 ? (n.consume(p), J) : p === 93 && i === 5 ? (n.consume(p), q) : L(p) && (i === 6 || i === 7) ? n.check(\n      Di,\n      W,\n      F\n    )(p) : p === null || L(p) ? F(p) : (n.consume(p), C);\n  }\n  function F(p) {\n    return n.exit(\"htmlFlowData\"), B(p);\n  }\n  function B(p) {\n    return p === null ? f(p) : L(p) ? n.attempt(\n      {\n        tokenize: Z,\n        partial: !0\n      },\n      B,\n      f\n    )(p) : (n.enter(\"htmlFlowData\"), C(p));\n  }\n  function Z(p, kn, Pn) {\n    return bn;\n    function bn(rn) {\n      return p.enter(\"lineEnding\"), p.consume(rn), p.exit(\"lineEnding\"), Y;\n    }\n    function Y(rn) {\n      return r.parser.lazy[r.now().line] ? Pn(rn) : kn(rn);\n    }\n  }\n  function en(p) {\n    return p === 45 ? (n.consume(p), J) : C(p);\n  }\n  function un(p) {\n    return p === 47 ? (n.consume(p), o = \"\", tn) : C(p);\n  }\n  function tn(p) {\n    return p === 62 && rt.includes(o.toLowerCase()) ? (n.consume(p), W) : dn(p) && o.length < 8 ? (n.consume(p), o += String.fromCharCode(p), tn) : C(p);\n  }\n  function q(p) {\n    return p === 93 ? (n.consume(p), J) : C(p);\n  }\n  function J(p) {\n    return p === 62 ? (n.consume(p), W) : p === 45 && i === 2 ? (n.consume(p), J) : C(p);\n  }\n  function W(p) {\n    return p === null || L(p) ? (n.exit(\"htmlFlowData\"), f(p)) : (n.consume(p), W);\n  }\n  function f(p) {\n    return n.exit(\"htmlFlow\"), e(p);\n  }\n}\nfunction Ri(n, e, t) {\n  return r;\n  function r(i) {\n    return n.exit(\"htmlFlowData\"), n.enter(\"lineEndingBlank\"), n.consume(i), n.exit(\"lineEndingBlank\"), n.attempt(Zn, e, t);\n  }\n}\nconst _i = {\n  name: \"htmlText\",\n  tokenize: Mi\n};\nfunction Mi(n, e, t) {\n  const r = this;\n  let i, l, o, u;\n  return a;\n  function a(f) {\n    return n.enter(\"htmlText\"), n.enter(\"htmlTextData\"), n.consume(f), c;\n  }\n  function c(f) {\n    return f === 33 ? (n.consume(f), s) : f === 47 ? (n.consume(f), I) : f === 63 ? (n.consume(f), T) : dn(f) ? (n.consume(f), X) : t(f);\n  }\n  function s(f) {\n    return f === 45 ? (n.consume(f), h) : f === 91 ? (n.consume(f), l = \"CDATA[\", o = 0, x) : dn(f) ? (n.consume(f), _) : t(f);\n  }\n  function h(f) {\n    return f === 45 ? (n.consume(f), g) : t(f);\n  }\n  function g(f) {\n    return f === null || f === 62 ? t(f) : f === 45 ? (n.consume(f), d) : m(f);\n  }\n  function d(f) {\n    return f === null || f === 62 ? t(f) : m(f);\n  }\n  function m(f) {\n    return f === null ? t(f) : f === 45 ? (n.consume(f), y) : L(f) ? (u = m, q(f)) : (n.consume(f), m);\n  }\n  function y(f) {\n    return f === 45 ? (n.consume(f), W) : m(f);\n  }\n  function x(f) {\n    return f === l.charCodeAt(o++) ? (n.consume(f), o === l.length ? w : x) : t(f);\n  }\n  function w(f) {\n    return f === null ? t(f) : f === 93 ? (n.consume(f), v) : L(f) ? (u = w, q(f)) : (n.consume(f), w);\n  }\n  function v(f) {\n    return f === 93 ? (n.consume(f), A) : w(f);\n  }\n  function A(f) {\n    return f === 62 ? W(f) : f === 93 ? (n.consume(f), A) : w(f);\n  }\n  function _(f) {\n    return f === null || f === 62 ? W(f) : L(f) ? (u = _, q(f)) : (n.consume(f), _);\n  }\n  function T(f) {\n    return f === null ? t(f) : f === 63 ? (n.consume(f), b) : L(f) ? (u = T, q(f)) : (n.consume(f), T);\n  }\n  function b(f) {\n    return f === 62 ? W(f) : T(f);\n  }\n  function I(f) {\n    return dn(f) ? (n.consume(f), R) : t(f);\n  }\n  function R(f) {\n    return f === 45 || on(f) ? (n.consume(f), R) : M(f);\n  }\n  function M(f) {\n    return L(f) ? (u = M, q(f)) : G(f) ? (n.consume(f), M) : W(f);\n  }\n  function X(f) {\n    return f === 45 || on(f) ? (n.consume(f), X) : f === 47 || f === 62 || sn(f) ? C(f) : t(f);\n  }\n  function C(f) {\n    return f === 47 ? (n.consume(f), W) : f === 58 || f === 95 || dn(f) ? (n.consume(f), F) : L(f) ? (u = C, q(f)) : G(f) ? (n.consume(f), C) : W(f);\n  }\n  function F(f) {\n    return f === 45 || f === 46 || f === 58 || f === 95 || on(f) ? (n.consume(f), F) : B(f);\n  }\n  function B(f) {\n    return f === 61 ? (n.consume(f), Z) : L(f) ? (u = B, q(f)) : G(f) ? (n.consume(f), B) : C(f);\n  }\n  function Z(f) {\n    return f === null || f === 60 || f === 61 || f === 62 || f === 96 ? t(f) : f === 34 || f === 39 ? (n.consume(f), i = f, en) : L(f) ? (u = Z, q(f)) : G(f) ? (n.consume(f), Z) : (n.consume(f), i = void 0, tn);\n  }\n  function en(f) {\n    return f === i ? (n.consume(f), un) : f === null ? t(f) : L(f) ? (u = en, q(f)) : (n.consume(f), en);\n  }\n  function un(f) {\n    return f === 62 || f === 47 || sn(f) ? C(f) : t(f);\n  }\n  function tn(f) {\n    return f === null || f === 34 || f === 39 || f === 60 || f === 61 || f === 96 ? t(f) : f === 62 || sn(f) ? C(f) : (n.consume(f), tn);\n  }\n  function q(f) {\n    return n.exit(\"htmlTextData\"), n.enter(\"lineEnding\"), n.consume(f), n.exit(\"lineEnding\"), U(\n      n,\n      J,\n      \"linePrefix\",\n      r.parser.constructs.disable.null.includes(\"codeIndented\") ? void 0 : 4\n    );\n  }\n  function J(f) {\n    return n.enter(\"htmlTextData\"), u(f);\n  }\n  function W(f) {\n    return f === 62 ? (n.consume(f), n.exit(\"htmlTextData\"), n.exit(\"htmlText\"), e) : t(f);\n  }\n}\nconst Pe = {\n  name: \"labelEnd\",\n  tokenize: Ui,\n  resolveTo: Hi,\n  resolveAll: $i\n}, Bi = {\n  tokenize: Vi\n}, Ni = {\n  tokenize: qi\n}, ji = {\n  tokenize: Wi\n};\nfunction $i(n) {\n  let e = -1, t;\n  for (; ++e < n.length; )\n    t = n[e][1], (t.type === \"labelImage\" || t.type === \"labelLink\" || t.type === \"labelEnd\") && (n.splice(e + 1, t.type === \"labelImage\" ? 4 : 2), t.type = \"data\", e++);\n  return n;\n}\nfunction Hi(n, e) {\n  let t = n.length, r = 0, i, l, o, u;\n  for (; t--; )\n    if (i = n[t][1], l) {\n      if (i.type === \"link\" || i.type === \"labelLink\" && i._inactive)\n        break;\n      n[t][0] === \"enter\" && i.type === \"labelLink\" && (i._inactive = !0);\n    } else if (o) {\n      if (n[t][0] === \"enter\" && (i.type === \"labelImage\" || i.type === \"labelLink\") && !i._balanced && (l = t, i.type !== \"labelLink\")) {\n        r = 2;\n        break;\n      }\n    } else\n      i.type === \"labelEnd\" && (o = t);\n  const a = {\n    type: n[l][1].type === \"labelLink\" ? \"link\" : \"image\",\n    start: Object.assign({}, n[l][1].start),\n    end: Object.assign({}, n[n.length - 1][1].end)\n  }, c = {\n    type: \"label\",\n    start: Object.assign({}, n[l][1].start),\n    end: Object.assign({}, n[o][1].end)\n  }, s = {\n    type: \"labelText\",\n    start: Object.assign({}, n[l + r + 2][1].end),\n    end: Object.assign({}, n[o - 2][1].start)\n  };\n  return u = [\n    [\"enter\", a, e],\n    [\"enter\", c, e]\n  ], u = an(u, n.slice(l + 1, l + r + 3)), u = an(u, [[\"enter\", s, e]]), u = an(\n    u,\n    Ce(\n      e.parser.constructs.insideSpan.null,\n      n.slice(l + r + 4, o - 3),\n      e\n    )\n  ), u = an(u, [\n    [\"exit\", s, e],\n    n[o - 2],\n    n[o - 1],\n    [\"exit\", c, e]\n  ]), u = an(u, n.slice(o + 1)), u = an(u, [[\"exit\", a, e]]), gn(n, l, n.length, u), n;\n}\nfunction Ui(n, e, t) {\n  const r = this;\n  let i = r.events.length, l, o;\n  for (; i--; )\n    if ((r.events[i][1].type === \"labelImage\" || r.events[i][1].type === \"labelLink\") && !r.events[i][1]._balanced) {\n      l = r.events[i][1];\n      break;\n    }\n  return u;\n  function u(s) {\n    return l ? l._inactive ? c(s) : (o = r.parser.defined.includes(\n      Ln(\n        r.sliceSerialize({\n          start: l.end,\n          end: r.now()\n        })\n      )\n    ), n.enter(\"labelEnd\"), n.enter(\"labelMarker\"), n.consume(s), n.exit(\"labelMarker\"), n.exit(\"labelEnd\"), a) : t(s);\n  }\n  function a(s) {\n    return s === 40 ? n.attempt(\n      Bi,\n      e,\n      o ? e : c\n    )(s) : s === 91 ? n.attempt(\n      Ni,\n      e,\n      o ? n.attempt(ji, e, c) : c\n    )(s) : o ? e(s) : c(s);\n  }\n  function c(s) {\n    return l._balanced = !0, t(s);\n  }\n}\nfunction Vi(n, e, t) {\n  return r;\n  function r(a) {\n    return n.enter(\"resource\"), n.enter(\"resourceMarker\"), n.consume(a), n.exit(\"resourceMarker\"), $n(n, i);\n  }\n  function i(a) {\n    return a === 41 ? u(a) : _t(\n      n,\n      l,\n      t,\n      \"resourceDestination\",\n      \"resourceDestinationLiteral\",\n      \"resourceDestinationLiteralMarker\",\n      \"resourceDestinationRaw\",\n      \"resourceDestinationString\",\n      32\n    )(a);\n  }\n  function l(a) {\n    return sn(a) ? $n(n, o)(a) : u(a);\n  }\n  function o(a) {\n    return a === 34 || a === 39 || a === 40 ? Bt(\n      n,\n      $n(n, u),\n      t,\n      \"resourceTitle\",\n      \"resourceTitleMarker\",\n      \"resourceTitleString\"\n    )(a) : u(a);\n  }\n  function u(a) {\n    return a === 41 ? (n.enter(\"resourceMarker\"), n.consume(a), n.exit(\"resourceMarker\"), n.exit(\"resource\"), e) : t(a);\n  }\n}\nfunction qi(n, e, t) {\n  const r = this;\n  return i;\n  function i(o) {\n    return Mt.call(\n      r,\n      n,\n      l,\n      t,\n      \"reference\",\n      \"referenceMarker\",\n      \"referenceString\"\n    )(o);\n  }\n  function l(o) {\n    return r.parser.defined.includes(\n      Ln(\n        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)\n      )\n    ) ? e(o) : t(o);\n  }\n}\nfunction Wi(n, e, t) {\n  return r;\n  function r(l) {\n    return n.enter(\"reference\"), n.enter(\"referenceMarker\"), n.consume(l), n.exit(\"referenceMarker\"), i;\n  }\n  function i(l) {\n    return l === 93 ? (n.enter(\"referenceMarker\"), n.consume(l), n.exit(\"referenceMarker\"), n.exit(\"reference\"), e) : t(l);\n  }\n}\nconst Yi = {\n  name: \"labelStartImage\",\n  tokenize: Qi,\n  resolveAll: Pe.resolveAll\n};\nfunction Qi(n, e, t) {\n  const r = this;\n  return i;\n  function i(u) {\n    return n.enter(\"labelImage\"), n.enter(\"labelImageMarker\"), n.consume(u), n.exit(\"labelImageMarker\"), l;\n  }\n  function l(u) {\n    return u === 91 ? (n.enter(\"labelMarker\"), n.consume(u), n.exit(\"labelMarker\"), n.exit(\"labelImage\"), o) : t(u);\n  }\n  function o(u) {\n    return u === 94 && \"_hiddenFootnoteSupport\" in r.parser.constructs ? t(u) : e(u);\n  }\n}\nconst Xi = {\n  name: \"labelStartLink\",\n  tokenize: Ki,\n  resolveAll: Pe.resolveAll\n};\nfunction Ki(n, e, t) {\n  const r = this;\n  return i;\n  function i(o) {\n    return n.enter(\"labelLink\"), n.enter(\"labelMarker\"), n.consume(o), n.exit(\"labelMarker\"), n.exit(\"labelLink\"), l;\n  }\n  function l(o) {\n    return o === 94 && \"_hiddenFootnoteSupport\" in r.parser.constructs ? t(o) : e(o);\n  }\n}\nconst ce = {\n  name: \"lineEnding\",\n  tokenize: Gi\n};\nfunction Gi(n, e) {\n  return t;\n  function t(r) {\n    return n.enter(\"lineEnding\"), n.consume(r), n.exit(\"lineEnding\"), U(n, e, \"linePrefix\");\n  }\n}\nconst Qn = {\n  name: \"thematicBreak\",\n  tokenize: Zi\n};\nfunction Zi(n, e, t) {\n  let r = 0, i;\n  return l;\n  function l(a) {\n    return n.enter(\"thematicBreak\"), i = a, o(a);\n  }\n  function o(a) {\n    return a === i ? (n.enter(\"thematicBreakSequence\"), u(a)) : G(a) ? U(n, o, \"whitespace\")(a) : r < 3 || a !== null && !L(a) ? t(a) : (n.exit(\"thematicBreak\"), e(a));\n  }\n  function u(a) {\n    return a === i ? (n.consume(a), r++, u) : (n.exit(\"thematicBreakSequence\"), o(a));\n  }\n}\nconst nn = {\n  name: \"list\",\n  tokenize: el,\n  continuation: {\n    tokenize: tl\n  },\n  exit: il\n}, Ji = {\n  tokenize: ll,\n  partial: !0\n}, nl = {\n  tokenize: rl,\n  partial: !0\n};\nfunction el(n, e, t) {\n  const r = this, i = r.events[r.events.length - 1];\n  let l = i && i[1].type === \"linePrefix\" ? i[2].sliceSerialize(i[1], !0).length : 0, o = 0;\n  return u;\n  function u(d) {\n    const m = r.containerState.type || (d === 42 || d === 43 || d === 45 ? \"listUnordered\" : \"listOrdered\");\n    if (m === \"listUnordered\" ? !r.containerState.marker || d === r.containerState.marker : ge(d)) {\n      if (r.containerState.type || (r.containerState.type = m, n.enter(m, {\n        _container: !0\n      })), m === \"listUnordered\")\n        return n.enter(\"listItemPrefix\"), d === 42 || d === 45 ? n.check(Qn, t, c)(d) : c(d);\n      if (!r.interrupt || d === 49)\n        return n.enter(\"listItemPrefix\"), n.enter(\"listItemValue\"), a(d);\n    }\n    return t(d);\n  }\n  function a(d) {\n    return ge(d) && ++o < 10 ? (n.consume(d), a) : (!r.interrupt || o < 2) && (r.containerState.marker ? d === r.containerState.marker : d === 41 || d === 46) ? (n.exit(\"listItemValue\"), c(d)) : t(d);\n  }\n  function c(d) {\n    return n.enter(\"listItemMarker\"), n.consume(d), n.exit(\"listItemMarker\"), r.containerState.marker = r.containerState.marker || d, n.check(\n      Zn,\n      // Canâ€™t be empty when interrupting.\n      r.interrupt ? t : s,\n      n.attempt(\n        Ji,\n        g,\n        h\n      )\n    );\n  }\n  function s(d) {\n    return r.containerState.initialBlankLine = !0, l++, g(d);\n  }\n  function h(d) {\n    return G(d) ? (n.enter(\"listItemPrefixWhitespace\"), n.consume(d), n.exit(\"listItemPrefixWhitespace\"), g) : t(d);\n  }\n  function g(d) {\n    return r.containerState.size = l + r.sliceSerialize(n.exit(\"listItemPrefix\"), !0).length, e(d);\n  }\n}\nfunction tl(n, e, t) {\n  const r = this;\n  return r.containerState._closeFlow = void 0, n.check(Zn, i, l);\n  function i(u) {\n    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, U(\n      n,\n      e,\n      \"listItemIndent\",\n      r.containerState.size + 1\n    )(u);\n  }\n  function l(u) {\n    return r.containerState.furtherBlankLines || !G(u) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, o(u)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, n.attempt(nl, e, o)(u));\n  }\n  function o(u) {\n    return r.containerState._closeFlow = !0, r.interrupt = void 0, U(\n      n,\n      n.attempt(nn, e, t),\n      \"linePrefix\",\n      r.parser.constructs.disable.null.includes(\"codeIndented\") ? void 0 : 4\n    )(u);\n  }\n}\nfunction rl(n, e, t) {\n  const r = this;\n  return U(\n    n,\n    i,\n    \"listItemIndent\",\n    r.containerState.size + 1\n  );\n  function i(l) {\n    const o = r.events[r.events.length - 1];\n    return o && o[1].type === \"listItemIndent\" && o[2].sliceSerialize(o[1], !0).length === r.containerState.size ? e(l) : t(l);\n  }\n}\nfunction il(n) {\n  n.exit(this.containerState.type);\n}\nfunction ll(n, e, t) {\n  const r = this;\n  return U(\n    n,\n    i,\n    \"listItemPrefixWhitespace\",\n    r.parser.constructs.disable.null.includes(\"codeIndented\") ? void 0 : 4 + 1\n  );\n  function i(l) {\n    const o = r.events[r.events.length - 1];\n    return !G(l) && o && o[1].type === \"listItemPrefixWhitespace\" ? e(l) : t(l);\n  }\n}\nconst it = {\n  name: \"setextUnderline\",\n  tokenize: ul,\n  resolveTo: ol\n};\nfunction ol(n, e) {\n  let t = n.length, r, i, l;\n  for (; t--; )\n    if (n[t][0] === \"enter\") {\n      if (n[t][1].type === \"content\") {\n        r = t;\n        break;\n      }\n      n[t][1].type === \"paragraph\" && (i = t);\n    } else\n      n[t][1].type === \"content\" && n.splice(t, 1), !l && n[t][1].type === \"definition\" && (l = t);\n  const o = {\n    type: \"setextHeading\",\n    start: Object.assign({}, n[i][1].start),\n    end: Object.assign({}, n[n.length - 1][1].end)\n  };\n  return n[i][1].type = \"setextHeadingText\", l ? (n.splice(i, 0, [\"enter\", o, e]), n.splice(l + 1, 0, [\"exit\", n[r][1], e]), n[r][1].end = Object.assign({}, n[l][1].end)) : n[r][1] = o, n.push([\"exit\", o, e]), n;\n}\nfunction ul(n, e, t) {\n  const r = this;\n  let i = r.events.length, l, o;\n  for (; i--; )\n    if (r.events[i][1].type !== \"lineEnding\" && r.events[i][1].type !== \"linePrefix\" && r.events[i][1].type !== \"content\") {\n      o = r.events[i][1].type === \"paragraph\";\n      break;\n    }\n  return u;\n  function u(s) {\n    return !r.parser.lazy[r.now().line] && (r.interrupt || o) ? (n.enter(\"setextHeadingLine\"), n.enter(\"setextHeadingLineSequence\"), l = s, a(s)) : t(s);\n  }\n  function a(s) {\n    return s === l ? (n.consume(s), a) : (n.exit(\"setextHeadingLineSequence\"), U(n, c, \"lineSuffix\")(s));\n  }\n  function c(s) {\n    return s === null || L(s) ? (n.exit(\"setextHeadingLine\"), e(s)) : t(s);\n  }\n}\nconst al = {\n  tokenize: sl\n};\nfunction sl(n) {\n  const e = this, t = n.attempt(\n    // Try to parse a blank line.\n    Zn,\n    r,\n    // Try to parse initial flow (essentially, only code).\n    n.attempt(\n      this.parser.constructs.flowInitial,\n      i,\n      U(\n        n,\n        n.attempt(\n          this.parser.constructs.flow,\n          i,\n          n.attempt(gi, i)\n        ),\n        \"linePrefix\"\n      )\n    )\n  );\n  return t;\n  function r(l) {\n    if (l === null) {\n      n.consume(l);\n      return;\n    }\n    return n.enter(\"lineEndingBlank\"), n.consume(l), n.exit(\"lineEndingBlank\"), e.currentConstruct = void 0, t;\n  }\n  function i(l) {\n    if (l === null) {\n      n.consume(l);\n      return;\n    }\n    return n.enter(\"lineEnding\"), n.consume(l), n.exit(\"lineEnding\"), e.currentConstruct = void 0, t;\n  }\n}\nconst cl = {\n  resolveAll: jt()\n}, pl = Nt(\"string\"), fl = Nt(\"text\");\nfunction Nt(n) {\n  return {\n    tokenize: e,\n    resolveAll: jt(\n      n === \"text\" ? hl : void 0\n    )\n  };\n  function e(t) {\n    const r = this, i = this.parser.constructs[n], l = t.attempt(i, o, u);\n    return o;\n    function o(s) {\n      return c(s) ? l(s) : u(s);\n    }\n    function u(s) {\n      if (s === null) {\n        t.consume(s);\n        return;\n      }\n      return t.enter(\"data\"), t.consume(s), a;\n    }\n    function a(s) {\n      return c(s) ? (t.exit(\"data\"), l(s)) : (t.consume(s), a);\n    }\n    function c(s) {\n      if (s === null)\n        return !0;\n      const h = i[s];\n      let g = -1;\n      if (h)\n        for (; ++g < h.length; ) {\n          const d = h[g];\n          if (!d.previous || d.previous.call(r, r.previous))\n            return !0;\n        }\n      return !1;\n    }\n  }\n}\nfunction jt(n) {\n  return e;\n  function e(t, r) {\n    let i = -1, l;\n    for (; ++i <= t.length; )\n      l === void 0 ? t[i] && t[i][1].type === \"data\" && (l = i, i++) : (!t[i] || t[i][1].type !== \"data\") && (i !== l + 2 && (t[l][1].end = t[i - 1][1].end, t.splice(l + 2, i - l - 2), i = l + 2), l = void 0);\n    return n ? n(t, r) : t;\n  }\n}\nfunction hl(n, e) {\n  let t = 0;\n  for (; ++t <= n.length; )\n    if ((t === n.length || n[t][1].type === \"lineEnding\") && n[t - 1][1].type === \"data\") {\n      const r = n[t - 1][1], i = e.sliceStream(r);\n      let l = i.length, o = -1, u = 0, a;\n      for (; l--; ) {\n        const c = i[l];\n        if (typeof c == \"string\") {\n          for (o = c.length; c.charCodeAt(o - 1) === 32; )\n            u++, o--;\n          if (o)\n            break;\n          o = -1;\n        } else if (c === -2)\n          a = !0, u++;\n        else if (c !== -1) {\n          l++;\n          break;\n        }\n      }\n      if (u) {\n        const c = {\n          type: t === n.length || a || u < 2 ? \"lineSuffix\" : \"hardBreakTrailing\",\n          start: {\n            line: r.end.line,\n            column: r.end.column - u,\n            offset: r.end.offset - u,\n            _index: r.start._index + l,\n            _bufferIndex: l ? o : r.start._bufferIndex + o\n          },\n          end: Object.assign({}, r.end)\n        };\n        r.end = Object.assign({}, c.start), r.start.offset === r.end.offset ? Object.assign(r, c) : (n.splice(\n          t,\n          0,\n          [\"enter\", c, e],\n          [\"exit\", c, e]\n        ), t += 2);\n      }\n      t++;\n    }\n  return n;\n}\nfunction ml(n, e, t) {\n  let r = Object.assign(\n    t ? Object.assign({}, t) : {\n      line: 1,\n      column: 1,\n      offset: 0\n    },\n    {\n      _index: 0,\n      _bufferIndex: -1\n    }\n  );\n  const i = {}, l = [];\n  let o = [], u = [];\n  const a = {\n    consume: v,\n    enter: A,\n    exit: _,\n    attempt: I(T),\n    check: I(b),\n    interrupt: I(b, {\n      interrupt: !0\n    })\n  }, c = {\n    previous: null,\n    code: null,\n    containerState: {},\n    events: [],\n    parser: n,\n    sliceStream: d,\n    sliceSerialize: g,\n    now: m,\n    defineSkip: y,\n    write: h\n  };\n  let s = e.tokenize.call(c, a);\n  return e.resolveAll && l.push(e), c;\n  function h(C) {\n    return o = an(o, C), x(), o[o.length - 1] !== null ? [] : (R(e, 0), c.events = Ce(l, c.events, c), c.events);\n  }\n  function g(C, F) {\n    return gl(d(C), F);\n  }\n  function d(C) {\n    return dl(o, C);\n  }\n  function m() {\n    return Object.assign({}, r);\n  }\n  function y(C) {\n    i[C.line] = C.column, X();\n  }\n  function x() {\n    let C;\n    for (; r._index < o.length; ) {\n      const F = o[r._index];\n      if (typeof F == \"string\")\n        for (C = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === C && r._bufferIndex < F.length; )\n          w(F.charCodeAt(r._bufferIndex));\n      else\n        w(F);\n    }\n  }\n  function w(C) {\n    s = s(C);\n  }\n  function v(C) {\n    L(C) ? (r.line++, r.column = 1, r.offset += C === -3 ? 2 : 1, X()) : C !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === o[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = C;\n  }\n  function A(C, F) {\n    const B = F || {};\n    return B.type = C, B.start = m(), c.events.push([\"enter\", B, c]), u.push(B), B;\n  }\n  function _(C) {\n    const F = u.pop();\n    return F.end = m(), c.events.push([\"exit\", F, c]), F;\n  }\n  function T(C, F) {\n    R(C, F.from);\n  }\n  function b(C, F) {\n    F.restore();\n  }\n  function I(C, F) {\n    return B;\n    function B(Z, en, un) {\n      let tn, q, J, W;\n      return Array.isArray(Z) ? (\n        /* c8 ignore next 1 */\n        p(Z)\n      ) : \"tokenize\" in Z ? p([Z]) : f(Z);\n      function f(Y) {\n        return rn;\n        function rn(hn) {\n          const wn = hn !== null && Y[hn], Sn = hn !== null && Y.null, Rn = [\n            // To do: add more extension tests.\n            /* c8 ignore next 2 */\n            ...Array.isArray(wn) ? wn : wn ? [wn] : [],\n            ...Array.isArray(Sn) ? Sn : Sn ? [Sn] : []\n          ];\n          return p(Rn)(hn);\n        }\n      }\n      function p(Y) {\n        return tn = Y, q = 0, Y.length === 0 ? un : kn(Y[q]);\n      }\n      function kn(Y) {\n        return rn;\n        function rn(hn) {\n          return W = M(), J = Y, Y.partial || (c.currentConstruct = Y), Y.name && c.parser.constructs.disable.null.includes(Y.name) ? bn() : Y.tokenize.call(\n            // If we do have fields, create an object w/ `context` as its\n            // prototype.\n            // This allows a â€œlive bindingâ€, which is needed for `interrupt`.\n            F ? Object.assign(Object.create(c), F) : c,\n            a,\n            Pn,\n            bn\n          )(hn);\n        }\n      }\n      function Pn(Y) {\n        return C(J, W), en;\n      }\n      function bn(Y) {\n        return W.restore(), ++q < tn.length ? kn(tn[q]) : un;\n      }\n    }\n  }\n  function R(C, F) {\n    C.resolveAll && !l.includes(C) && l.push(C), C.resolve && gn(\n      c.events,\n      F,\n      c.events.length - F,\n      C.resolve(c.events.slice(F), c)\n    ), C.resolveTo && (c.events = C.resolveTo(c.events, c));\n  }\n  function M() {\n    const C = m(), F = c.previous, B = c.currentConstruct, Z = c.events.length, en = Array.from(u);\n    return {\n      restore: un,\n      from: Z\n    };\n    function un() {\n      r = C, c.previous = F, c.currentConstruct = B, c.events.length = Z, u = en, X();\n    }\n  }\n  function X() {\n    r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1);\n  }\n}\nfunction dl(n, e) {\n  const t = e.start._index, r = e.start._bufferIndex, i = e.end._index, l = e.end._bufferIndex;\n  let o;\n  return t === i ? o = [n[t].slice(r, l)] : (o = n.slice(t, i), r > -1 && (o[0] = o[0].slice(r)), l > 0 && o.push(n[i].slice(0, l))), o;\n}\nfunction gl(n, e) {\n  let t = -1;\n  const r = [];\n  let i;\n  for (; ++t < n.length; ) {\n    const l = n[t];\n    let o;\n    if (typeof l == \"string\")\n      o = l;\n    else\n      switch (l) {\n        case -5: {\n          o = \"\\r\";\n          break;\n        }\n        case -4: {\n          o = `\n`;\n          break;\n        }\n        case -3: {\n          o = `\\r\n`;\n          break;\n        }\n        case -2: {\n          o = e ? \" \" : \"\t\";\n          break;\n        }\n        case -1: {\n          if (!e && i)\n            continue;\n          o = \" \";\n          break;\n        }\n        default:\n          o = String.fromCharCode(l);\n      }\n    i = l === -2, r.push(o);\n  }\n  return r.join(\"\");\n}\nconst yl = {\n  [42]: nn,\n  [43]: nn,\n  [45]: nn,\n  [48]: nn,\n  [49]: nn,\n  [50]: nn,\n  [51]: nn,\n  [52]: nn,\n  [53]: nn,\n  [54]: nn,\n  [55]: nn,\n  [56]: nn,\n  [57]: nn,\n  [62]: Dt\n}, xl = {\n  [91]: wi\n}, kl = {\n  [-2]: se,\n  [-1]: se,\n  [32]: se\n}, bl = {\n  [35]: Fi,\n  [42]: Qn,\n  [45]: [it, Qn],\n  [60]: Li,\n  [61]: it,\n  [95]: Qn,\n  [96]: tt,\n  [126]: tt\n}, wl = {\n  [38]: zt,\n  [92]: vt\n}, Sl = {\n  [-5]: ce,\n  [-4]: ce,\n  [-3]: ce,\n  [33]: Yi,\n  [38]: zt,\n  [42]: xe,\n  [60]: [Jr, _i],\n  [91]: Xi,\n  [92]: [Ai, vt],\n  [93]: Pe,\n  [95]: xe,\n  [96]: pi\n}, El = {\n  null: [xe, cl]\n}, Cl = {\n  null: [42, 95]\n}, Al = {\n  null: []\n}, Pl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  attentionMarkers: Cl,\n  contentInitial: xl,\n  disable: Al,\n  document: yl,\n  flow: bl,\n  flowInitial: kl,\n  insideSpan: El,\n  string: wl,\n  text: Sl\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction Fl(n = {}) {\n  const e = Br(\n    // @ts-expect-error Same as above.\n    [Pl].concat(n.extensions || [])\n  ), t = {\n    defined: [],\n    lazy: {},\n    constructs: e,\n    content: r(Wr),\n    document: r(Qr),\n    flow: r(al),\n    string: r(pl),\n    text: r(fl)\n  };\n  return t;\n  function r(i) {\n    return l;\n    function l(o) {\n      return ml(t, i, o);\n    }\n  }\n}\nconst lt = /[\\0\\t\\n\\r]/g;\nfunction Tl() {\n  let n = 1, e = \"\", t = !0, r;\n  return i;\n  function i(l, o, u) {\n    const a = [];\n    let c, s, h, g, d;\n    for (l = e + l.toString(o), h = 0, e = \"\", t && (l.charCodeAt(0) === 65279 && h++, t = void 0); h < l.length; ) {\n      if (lt.lastIndex = h, c = lt.exec(l), g = c && c.index !== void 0 ? c.index : l.length, d = l.charCodeAt(g), !c) {\n        e = l.slice(h);\n        break;\n      }\n      if (d === 10 && h === g && r)\n        a.push(-3), r = void 0;\n      else\n        switch (r && (a.push(-5), r = void 0), h < g && (a.push(l.slice(h, g)), n += g - h), d) {\n          case 0: {\n            a.push(65533), n++;\n            break;\n          }\n          case 9: {\n            for (s = Math.ceil(n / 4) * 4, a.push(-2); n++ < s; )\n              a.push(-1);\n            break;\n          }\n          case 10: {\n            a.push(-4), n = 1;\n            break;\n          }\n          default:\n            r = !0, n = 1;\n        }\n      h = g + 1;\n    }\n    return u && (r && a.push(-5), e && a.push(e), a.push(null)), a;\n  }\n}\nfunction Il(n) {\n  for (; !Rt(n); )\n    ;\n  return n;\n}\nfunction $t(n, e) {\n  const t = Number.parseInt(n, e);\n  return (\n    // C0 except for HT, LF, FF, CR, space\n    t < 9 || t === 11 || t > 13 && t < 32 || // Control character (DEL) of the basic block and C1 controls.\n    t > 126 && t < 160 || // Lone high surrogates and low surrogates.\n    t > 55295 && t < 57344 || // Noncharacters.\n    t > 64975 && t < 65008 || (t & 65535) === 65535 || (t & 65535) === 65534 || // Out of range\n    t > 1114111 ? \"ï¿½\" : String.fromCharCode(t)\n  );\n}\nconst Ol = /\\\\([!-/:-@[-`{-~])|&(#(?:\\d{1,7}|x[\\da-f]{1,6})|[\\da-z]{1,31});/gi;\nfunction Ll(n) {\n  return n.replace(Ol, Dl);\n}\nfunction Dl(n, e, t) {\n  if (e)\n    return e;\n  if (t.charCodeAt(0) === 35) {\n    const i = t.charCodeAt(1), l = i === 120 || i === 88;\n    return $t(t.slice(l ? 2 : 1), l ? 16 : 10);\n  }\n  return Ae(t) || n;\n}\nfunction Xn(n) {\n  return !n || typeof n != \"object\" ? \"\" : \"position\" in n || \"type\" in n ? ot(n.position) : \"start\" in n || \"end\" in n ? ot(n) : \"line\" in n || \"column\" in n ? ke(n) : \"\";\n}\nfunction ke(n) {\n  return ut(n && n.line) + \":\" + ut(n && n.column);\n}\nfunction ot(n) {\n  return ke(n && n.start) + \"-\" + ke(n && n.end);\n}\nfunction ut(n) {\n  return n && typeof n == \"number\" ? n : 1;\n}\nconst Ht = {}.hasOwnProperty, vl = (\n  /**\n   * @type {(\n   *   ((value: Value, encoding: Encoding, options?: Options | null | undefined) => Root) &\n   *   ((value: Value, options?: Options | null | undefined) => Root)\n   * )}\n   */\n  /**\n   * @param {Value} value\n   * @param {Encoding | Options | null | undefined} [encoding]\n   * @param {Options | null | undefined} [options]\n   * @returns {Root}\n   */\n  function(n, e, t) {\n    return typeof e != \"string\" && (t = e, e = void 0), zl(t)(\n      Il(\n        // @ts-expect-error: micromark types need to accept `null`.\n        Fl(t).document().write(Tl()(n, e, !0))\n      )\n    );\n  }\n);\nfunction zl(n) {\n  const e = {\n    transforms: [],\n    canContainEols: [\"emphasis\", \"fragment\", \"heading\", \"paragraph\", \"strong\"],\n    enter: {\n      autolink: u(De),\n      autolinkProtocol: C,\n      autolinkEmail: C,\n      atxHeading: u(Fn),\n      blockQuote: u(Rn),\n      characterEscape: C,\n      characterReference: C,\n      codeFenced: u(Vn),\n      codeFencedFenceInfo: a,\n      codeFencedFenceMeta: a,\n      codeIndented: u(Vn, a),\n      codeText: u(ee, a),\n      codeTextData: C,\n      data: C,\n      codeFlowValue: C,\n      definition: u(P),\n      definitionDestinationString: a,\n      definitionLabelString: a,\n      definitionTitleString: a,\n      emphasis: u(_n),\n      hardBreakEscape: u(Mn),\n      hardBreakTrailing: u(Mn),\n      htmlFlow: u(Le, a),\n      htmlFlowData: C,\n      htmlText: u(Le, a),\n      htmlTextData: C,\n      image: u(sr),\n      label: a,\n      link: u(De),\n      listItem: u(cr),\n      listItemValue: m,\n      listOrdered: u(ve, d),\n      listUnordered: u(ve),\n      paragraph: u(pr),\n      reference: bn,\n      referenceString: a,\n      resourceDestinationString: a,\n      resourceTitleString: a,\n      setextHeading: u(Fn),\n      strong: u(fr),\n      thematicBreak: u(mr)\n    },\n    exit: {\n      atxHeading: s(),\n      atxHeadingSequence: I,\n      autolink: s(),\n      autolinkEmail: Sn,\n      autolinkProtocol: wn,\n      blockQuote: s(),\n      characterEscapeValue: F,\n      characterReferenceMarkerHexadecimal: rn,\n      characterReferenceMarkerNumeric: rn,\n      characterReferenceValue: hn,\n      codeFenced: s(v),\n      codeFencedFence: w,\n      codeFencedFenceInfo: y,\n      codeFencedFenceMeta: x,\n      codeFlowValue: F,\n      codeIndented: s(A),\n      codeText: s(tn),\n      codeTextData: F,\n      data: F,\n      definition: s(),\n      definitionDestinationString: b,\n      definitionLabelString: _,\n      definitionTitleString: T,\n      emphasis: s(),\n      hardBreakEscape: s(Z),\n      hardBreakTrailing: s(Z),\n      htmlFlow: s(en),\n      htmlFlowData: F,\n      htmlText: s(un),\n      htmlTextData: F,\n      image: s(J),\n      label: f,\n      labelText: W,\n      lineEnding: B,\n      link: s(q),\n      listItem: s(),\n      listOrdered: s(),\n      listUnordered: s(),\n      paragraph: s(),\n      referenceString: Y,\n      resourceDestinationString: p,\n      resourceTitleString: kn,\n      resource: Pn,\n      setextHeading: s(X),\n      setextHeadingLineSequence: M,\n      setextHeadingText: R,\n      strong: s(),\n      thematicBreak: s()\n    }\n  };\n  Ut(e, (n || {}).mdastExtensions || []);\n  const t = {};\n  return r;\n  function r(k) {\n    let E = {\n      type: \"root\",\n      children: []\n    };\n    const O = {\n      stack: [E],\n      tokenStack: [],\n      config: e,\n      enter: c,\n      exit: h,\n      buffer: a,\n      resume: g,\n      setData: l,\n      getData: o\n    }, $ = [];\n    let H = -1;\n    for (; ++H < k.length; )\n      if (k[H][1].type === \"listOrdered\" || k[H][1].type === \"listUnordered\")\n        if (k[H][0] === \"enter\")\n          $.push(H);\n        else {\n          const fn = $.pop();\n          H = i(k, fn, H);\n        }\n    for (H = -1; ++H < k.length; ) {\n      const fn = e[k[H][0]];\n      Ht.call(fn, k[H][1].type) && fn[k[H][1].type].call(\n        Object.assign(\n          {\n            sliceSerialize: k[H][2].sliceSerialize\n          },\n          O\n        ),\n        k[H][1]\n      );\n    }\n    if (O.tokenStack.length > 0) {\n      const fn = O.tokenStack[O.tokenStack.length - 1];\n      (fn[1] || at).call(O, void 0, fn[0]);\n    }\n    for (E.position = {\n      start: Cn(\n        k.length > 0 ? k[0][1].start : {\n          line: 1,\n          column: 1,\n          offset: 0\n        }\n      ),\n      end: Cn(\n        k.length > 0 ? k[k.length - 2][1].end : {\n          line: 1,\n          column: 1,\n          offset: 0\n        }\n      )\n    }, H = -1; ++H < e.transforms.length; )\n      E = e.transforms[H](E) || E;\n    return E;\n  }\n  function i(k, E, O) {\n    let $ = E - 1, H = -1, fn = !1, En, yn, Bn, Nn;\n    for (; ++$ <= O; ) {\n      const Q = k[$];\n      if (Q[1].type === \"listUnordered\" || Q[1].type === \"listOrdered\" || Q[1].type === \"blockQuote\" ? (Q[0] === \"enter\" ? H++ : H--, Nn = void 0) : Q[1].type === \"lineEndingBlank\" ? Q[0] === \"enter\" && (En && !Nn && !H && !Bn && (Bn = $), Nn = void 0) : Q[1].type === \"linePrefix\" || Q[1].type === \"listItemValue\" || Q[1].type === \"listItemMarker\" || Q[1].type === \"listItemPrefix\" || Q[1].type === \"listItemPrefixWhitespace\" || (Nn = void 0), !H && Q[0] === \"enter\" && Q[1].type === \"listItemPrefix\" || H === -1 && Q[0] === \"exit\" && (Q[1].type === \"listUnordered\" || Q[1].type === \"listOrdered\")) {\n        if (En) {\n          let te = $;\n          for (yn = void 0; te--; ) {\n            const xn = k[te];\n            if (xn[1].type === \"lineEnding\" || xn[1].type === \"lineEndingBlank\") {\n              if (xn[0] === \"exit\")\n                continue;\n              yn && (k[yn][1].type = \"lineEndingBlank\", fn = !0), xn[1].type = \"lineEnding\", yn = te;\n            } else if (!(xn[1].type === \"linePrefix\" || xn[1].type === \"blockQuotePrefix\" || xn[1].type === \"blockQuotePrefixWhitespace\" || xn[1].type === \"blockQuoteMarker\" || xn[1].type === \"listItemIndent\"))\n              break;\n          }\n          Bn && (!yn || Bn < yn) && (En._spread = !0), En.end = Object.assign(\n            {},\n            yn ? k[yn][1].start : Q[1].end\n          ), k.splice(yn || $, 0, [\"exit\", En, Q[2]]), $++, O++;\n        }\n        Q[1].type === \"listItemPrefix\" && (En = {\n          type: \"listItem\",\n          // @ts-expect-error Patched\n          _spread: !1,\n          start: Object.assign({}, Q[1].start)\n        }, k.splice($, 0, [\"enter\", En, Q[2]]), $++, O++, Bn = void 0, Nn = !0);\n      }\n    }\n    return k[E][1]._spread = fn, O;\n  }\n  function l(k, E) {\n    t[k] = E;\n  }\n  function o(k) {\n    return t[k];\n  }\n  function u(k, E) {\n    return O;\n    function O($) {\n      c.call(this, k($), $), E && E.call(this, $);\n    }\n  }\n  function a() {\n    this.stack.push({\n      type: \"fragment\",\n      children: []\n    });\n  }\n  function c(k, E, O) {\n    return this.stack[this.stack.length - 1].children.push(k), this.stack.push(k), this.tokenStack.push([E, O]), k.position = {\n      start: Cn(E.start)\n    }, k;\n  }\n  function s(k) {\n    return E;\n    function E(O) {\n      k && k.call(this, O), h.call(this, O);\n    }\n  }\n  function h(k, E) {\n    const O = this.stack.pop(), $ = this.tokenStack.pop();\n    if ($)\n      $[0].type !== k.type && (E ? E.call(this, k, $[0]) : ($[1] || at).call(this, k, $[0]));\n    else\n      throw new Error(\n        \"Cannot close `\" + k.type + \"` (\" + Xn({\n          start: k.start,\n          end: k.end\n        }) + \"): itâ€™s not open\"\n      );\n    return O.position.end = Cn(k.end), O;\n  }\n  function g() {\n    return _r(this.stack.pop());\n  }\n  function d() {\n    l(\"expectingFirstListItemValue\", !0);\n  }\n  function m(k) {\n    if (o(\"expectingFirstListItemValue\")) {\n      const E = this.stack[this.stack.length - 2];\n      E.start = Number.parseInt(this.sliceSerialize(k), 10), l(\"expectingFirstListItemValue\");\n    }\n  }\n  function y() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.lang = k;\n  }\n  function x() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.meta = k;\n  }\n  function w() {\n    o(\"flowCodeInside\") || (this.buffer(), l(\"flowCodeInside\", !0));\n  }\n  function v() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.value = k.replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, \"\"), l(\"flowCodeInside\");\n  }\n  function A() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.value = k.replace(/(\\r?\\n|\\r)$/g, \"\");\n  }\n  function _(k) {\n    const E = this.resume(), O = this.stack[this.stack.length - 1];\n    O.label = E, O.identifier = Ln(\n      this.sliceSerialize(k)\n    ).toLowerCase();\n  }\n  function T() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.title = k;\n  }\n  function b() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.url = k;\n  }\n  function I(k) {\n    const E = this.stack[this.stack.length - 1];\n    if (!E.depth) {\n      const O = this.sliceSerialize(k).length;\n      E.depth = O;\n    }\n  }\n  function R() {\n    l(\"setextHeadingSlurpLineEnding\", !0);\n  }\n  function M(k) {\n    const E = this.stack[this.stack.length - 1];\n    E.depth = this.sliceSerialize(k).charCodeAt(0) === 61 ? 1 : 2;\n  }\n  function X() {\n    l(\"setextHeadingSlurpLineEnding\");\n  }\n  function C(k) {\n    const E = this.stack[this.stack.length - 1];\n    let O = E.children[E.children.length - 1];\n    (!O || O.type !== \"text\") && (O = hr(), O.position = {\n      start: Cn(k.start)\n    }, E.children.push(O)), this.stack.push(O);\n  }\n  function F(k) {\n    const E = this.stack.pop();\n    E.value += this.sliceSerialize(k), E.position.end = Cn(k.end);\n  }\n  function B(k) {\n    const E = this.stack[this.stack.length - 1];\n    if (o(\"atHardBreak\")) {\n      const O = E.children[E.children.length - 1];\n      O.position.end = Cn(k.end), l(\"atHardBreak\");\n      return;\n    }\n    !o(\"setextHeadingSlurpLineEnding\") && e.canContainEols.includes(E.type) && (C.call(this, k), F.call(this, k));\n  }\n  function Z() {\n    l(\"atHardBreak\", !0);\n  }\n  function en() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.value = k;\n  }\n  function un() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.value = k;\n  }\n  function tn() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.value = k;\n  }\n  function q() {\n    const k = this.stack[this.stack.length - 1];\n    if (o(\"inReference\")) {\n      const E = o(\"referenceType\") || \"shortcut\";\n      k.type += \"Reference\", k.referenceType = E, delete k.url, delete k.title;\n    } else\n      delete k.identifier, delete k.label;\n    l(\"referenceType\");\n  }\n  function J() {\n    const k = this.stack[this.stack.length - 1];\n    if (o(\"inReference\")) {\n      const E = o(\"referenceType\") || \"shortcut\";\n      k.type += \"Reference\", k.referenceType = E, delete k.url, delete k.title;\n    } else\n      delete k.identifier, delete k.label;\n    l(\"referenceType\");\n  }\n  function W(k) {\n    const E = this.sliceSerialize(k), O = this.stack[this.stack.length - 2];\n    O.label = Ll(E), O.identifier = Ln(E).toLowerCase();\n  }\n  function f() {\n    const k = this.stack[this.stack.length - 1], E = this.resume(), O = this.stack[this.stack.length - 1];\n    if (l(\"inReference\", !0), O.type === \"link\") {\n      const $ = k.children;\n      O.children = $;\n    } else\n      O.alt = E;\n  }\n  function p() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.url = k;\n  }\n  function kn() {\n    const k = this.resume(), E = this.stack[this.stack.length - 1];\n    E.title = k;\n  }\n  function Pn() {\n    l(\"inReference\");\n  }\n  function bn() {\n    l(\"referenceType\", \"collapsed\");\n  }\n  function Y(k) {\n    const E = this.resume(), O = this.stack[this.stack.length - 1];\n    O.label = E, O.identifier = Ln(\n      this.sliceSerialize(k)\n    ).toLowerCase(), l(\"referenceType\", \"full\");\n  }\n  function rn(k) {\n    l(\"characterReferenceType\", k.type);\n  }\n  function hn(k) {\n    const E = this.sliceSerialize(k), O = o(\"characterReferenceType\");\n    let $;\n    O ? ($ = $t(\n      E,\n      O === \"characterReferenceMarkerNumeric\" ? 10 : 16\n    ), l(\"characterReferenceType\")) : $ = Ae(E);\n    const H = this.stack.pop();\n    H.value += $, H.position.end = Cn(k.end);\n  }\n  function wn(k) {\n    F.call(this, k);\n    const E = this.stack[this.stack.length - 1];\n    E.url = this.sliceSerialize(k);\n  }\n  function Sn(k) {\n    F.call(this, k);\n    const E = this.stack[this.stack.length - 1];\n    E.url = \"mailto:\" + this.sliceSerialize(k);\n  }\n  function Rn() {\n    return {\n      type: \"blockquote\",\n      children: []\n    };\n  }\n  function Vn() {\n    return {\n      type: \"code\",\n      lang: null,\n      meta: null,\n      value: \"\"\n    };\n  }\n  function ee() {\n    return {\n      type: \"inlineCode\",\n      value: \"\"\n    };\n  }\n  function P() {\n    return {\n      type: \"definition\",\n      identifier: \"\",\n      label: null,\n      title: null,\n      url: \"\"\n    };\n  }\n  function _n() {\n    return {\n      type: \"emphasis\",\n      children: []\n    };\n  }\n  function Fn() {\n    return {\n      type: \"heading\",\n      depth: void 0,\n      children: []\n    };\n  }\n  function Mn() {\n    return {\n      type: \"break\"\n    };\n  }\n  function Le() {\n    return {\n      type: \"html\",\n      value: \"\"\n    };\n  }\n  function sr() {\n    return {\n      type: \"image\",\n      title: null,\n      url: \"\",\n      alt: null\n    };\n  }\n  function De() {\n    return {\n      type: \"link\",\n      title: null,\n      url: \"\",\n      children: []\n    };\n  }\n  function ve(k) {\n    return {\n      type: \"list\",\n      ordered: k.type === \"listOrdered\",\n      start: null,\n      // @ts-expect-error Patched.\n      spread: k._spread,\n      children: []\n    };\n  }\n  function cr(k) {\n    return {\n      type: \"listItem\",\n      // @ts-expect-error Patched.\n      spread: k._spread,\n      checked: null,\n      children: []\n    };\n  }\n  function pr() {\n    return {\n      type: \"paragraph\",\n      children: []\n    };\n  }\n  function fr() {\n    return {\n      type: \"strong\",\n      children: []\n    };\n  }\n  function hr() {\n    return {\n      type: \"text\",\n      value: \"\"\n    };\n  }\n  function mr() {\n    return {\n      type: \"thematicBreak\"\n    };\n  }\n}\nfunction Cn(n) {\n  return {\n    line: n.line,\n    column: n.column,\n    offset: n.offset\n  };\n}\nfunction Ut(n, e) {\n  let t = -1;\n  for (; ++t < e.length; ) {\n    const r = e[t];\n    Array.isArray(r) ? Ut(n, r) : Rl(n, r);\n  }\n}\nfunction Rl(n, e) {\n  let t;\n  for (t in e)\n    if (Ht.call(e, t)) {\n      if (t === \"canContainEols\") {\n        const r = e[t];\n        r && n[t].push(...r);\n      } else if (t === \"transforms\") {\n        const r = e[t];\n        r && n[t].push(...r);\n      } else if (t === \"enter\" || t === \"exit\") {\n        const r = e[t];\n        r && Object.assign(n[t], r);\n      }\n    }\n}\nfunction at(n, e) {\n  throw n ? new Error(\n    \"Cannot close `\" + n.type + \"` (\" + Xn({\n      start: n.start,\n      end: n.end\n    }) + \"): a different token (`\" + e.type + \"`, \" + Xn({\n      start: e.start,\n      end: e.end\n    }) + \") is open\"\n  ) : new Error(\n    \"Cannot close document, a token (`\" + e.type + \"`, \" + Xn({\n      start: e.start,\n      end: e.end\n    }) + \") is still open\"\n  );\n}\nfunction _l(n) {\n  Object.assign(this, { Parser: (t) => {\n    const r = (\n      /** @type {Options} */\n      this.data(\"settings\")\n    );\n    return vl(\n      t,\n      Object.assign({}, r, n, {\n        // Note: these options are not in the readme.\n        // The goal is for them to be set by plugins on `data` instead of being\n        // passed by users.\n        extensions: this.data(\"micromarkExtensions\") || [],\n        mdastExtensions: this.data(\"fromMarkdownExtensions\") || []\n      })\n    );\n  } });\n}\nfunction Ml(n, e) {\n  const t = {\n    type: \"element\",\n    tagName: \"blockquote\",\n    properties: {},\n    children: n.wrap(n.all(e), !0)\n  };\n  return n.patch(e, t), n.applyData(e, t);\n}\nfunction Bl(n, e) {\n  const t = { type: \"element\", tagName: \"br\", properties: {}, children: [] };\n  return n.patch(e, t), [n.applyData(e, t), { type: \"text\", value: `\n` }];\n}\nfunction Nl(n, e) {\n  const t = e.value ? e.value + `\n` : \"\", r = e.lang ? e.lang.match(/^[^ \\t]+(?=[ \\t]|$)/) : null, i = {};\n  r && (i.className = [\"language-\" + r]);\n  let l = {\n    type: \"element\",\n    tagName: \"code\",\n    properties: i,\n    children: [{ type: \"text\", value: t }]\n  };\n  return e.meta && (l.data = { meta: e.meta }), n.patch(e, l), l = n.applyData(e, l), l = { type: \"element\", tagName: \"pre\", properties: {}, children: [l] }, n.patch(e, l), l;\n}\nfunction jl(n, e) {\n  const t = {\n    type: \"element\",\n    tagName: \"del\",\n    properties: {},\n    children: n.all(e)\n  };\n  return n.patch(e, t), n.applyData(e, t);\n}\nfunction $l(n, e) {\n  const t = {\n    type: \"element\",\n    tagName: \"em\",\n    properties: {},\n    children: n.all(e)\n  };\n  return n.patch(e, t), n.applyData(e, t);\n}\nfunction vn(n) {\n  const e = [];\n  let t = -1, r = 0, i = 0;\n  for (; ++t < n.length; ) {\n    const l = n.charCodeAt(t);\n    let o = \"\";\n    if (l === 37 && on(n.charCodeAt(t + 1)) && on(n.charCodeAt(t + 2)))\n      i = 2;\n    else if (l < 128)\n      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(l)) || (o = String.fromCharCode(l));\n    else if (l > 55295 && l < 57344) {\n      const u = n.charCodeAt(t + 1);\n      l < 56320 && u > 56319 && u < 57344 ? (o = String.fromCharCode(l, u), i = 1) : o = \"ï¿½\";\n    } else\n      o = String.fromCharCode(l);\n    o && (e.push(n.slice(r, t), encodeURIComponent(o)), r = t + i + 1, o = \"\"), i && (t += i, i = 0);\n  }\n  return e.join(\"\") + n.slice(r);\n}\nfunction Vt(n, e) {\n  const t = String(e.identifier).toUpperCase(), r = vn(t.toLowerCase()), i = n.footnoteOrder.indexOf(t);\n  let l;\n  i === -1 ? (n.footnoteOrder.push(t), n.footnoteCounts[t] = 1, l = n.footnoteOrder.length) : (n.footnoteCounts[t]++, l = i + 1);\n  const o = n.footnoteCounts[t], u = {\n    type: \"element\",\n    tagName: \"a\",\n    properties: {\n      href: \"#\" + n.clobberPrefix + \"fn-\" + r,\n      id: n.clobberPrefix + \"fnref-\" + r + (o > 1 ? \"-\" + o : \"\"),\n      dataFootnoteRef: !0,\n      ariaDescribedBy: [\"footnote-label\"]\n    },\n    children: [{ type: \"text\", value: String(l) }]\n  };\n  n.patch(e, u);\n  const a = {\n    type: \"element\",\n    tagName: \"sup\",\n    properties: {},\n    children: [u]\n  };\n  return n.patch(e, a), n.applyData(e, a);\n}\nfunction Hl(n, e) {\n  const t = n.footnoteById;\n  let r = 1;\n  for (; r in t; )\n    r++;\n  const i = String(r);\n  return t[i] = {\n    type: \"footnoteDefinition\",\n    identifier: i,\n    children: [{ type: \"paragraph\", children: e.children }],\n    position: e.position\n  }, Vt(n, {\n    type: \"footnoteReference\",\n    identifier: i,\n    position: e.position\n  });\n}\nfunction Ul(n, e) {\n  const t = {\n    type: \"element\",\n    tagName: \"h\" + e.depth,\n    properties: {},\n    children: n.all(e)\n  };\n  return n.patch(e, t), n.applyData(e, t);\n}\nfunction Vl(n, e) {\n  if (n.dangerous) {\n    const t = { type: \"raw\", value: e.value };\n    return n.patch(e, t), n.applyData(e, t);\n  }\n  return null;\n}\nfunction qt(n, e) {\n  const t = e.referenceType;\n  let r = \"]\";\n  if (t === \"collapsed\" ? r += \"[]\" : t === \"full\" && (r += \"[\" + (e.label || e.identifier) + \"]\"), e.type === \"imageReference\")\n    return { type: \"text\", value: \"![\" + e.alt + r };\n  const i = n.all(e), l = i[0];\n  l && l.type === \"text\" ? l.value = \"[\" + l.value : i.unshift({ type: \"text\", value: \"[\" });\n  const o = i[i.length - 1];\n  return o && o.type === \"text\" ? o.value += r : i.push({ type: \"text\", value: r }), i;\n}\nfunction ql(n, e) {\n  const t = n.definition(e.identifier);\n  if (!t)\n    return qt(n, e);\n  const r = { src: vn(t.url || \"\"), alt: e.alt };\n  t.title !== null && t.title !== void 0 && (r.title = t.title);\n  const i = { type: \"element\", tagName: \"img\", properties: r, children: [] };\n  return n.patch(e, i), n.applyData(e, i);\n}\nfunction Wl(n, e) {\n  const t = { src: vn(e.url) };\n  e.alt !== null && e.alt !== void 0 && (t.alt = e.alt), e.title !== null && e.title !== void 0 && (t.title = e.title);\n  const r = { type: \"element\", tagName: \"img\", properties: t, children: [] };\n  return n.patch(e, r), n.applyData(e, r);\n}\nfunction Yl(n, e) {\n  const t = { type: \"text\", value: e.value.replace(/\\r?\\n|\\r/g, \" \") };\n  n.patch(e, t);\n  const r = {\n    type: \"element\",\n    tagName: \"code\",\n    properties: {},\n    children: [t]\n  };\n  return n.patch(e, r), n.applyData(e, r);\n}\nfunction Ql(n, e) {\n  const t = n.definition(e.identifier);\n  if (!t)\n    return qt(n, e);\n  const r = { href: vn(t.url || \"\") };\n  t.title !== null && t.title !== void 0 && (r.title = t.title);\n  const i = {\n    type: \"element\",\n    tagName: \"a\",\n    properties: r,\n    children: n.all(e)\n  };\n  return n.patch(e, i), n.applyData(e, i);\n}\nfunction Xl(n, e) {\n  const t = { href: vn(e.url) };\n  e.title !== null && e.title !== void 0 && (t.title = e.title);\n  const r = {\n    type: \"element\",\n    tagName: \"a\",\n    properties: t,\n    children: n.all(e)\n  };\n  return n.patch(e, r), n.applyData(e, r);\n}\nfunction Kl(n, e, t) {\n  const r = n.all(e), i = t ? Gl(t) : Wt(e), l = {}, o = [];\n  if (typeof e.checked == \"boolean\") {\n    const s = r[0];\n    let h;\n    s && s.type === \"element\" && s.tagName === \"p\" ? h = s : (h = { type: \"element\", tagName: \"p\", properties: {}, children: [] }, r.unshift(h)), h.children.length > 0 && h.children.unshift({ type: \"text\", value: \" \" }), h.children.unshift({\n      type: \"element\",\n      tagName: \"input\",\n      properties: { type: \"checkbox\", checked: e.checked, disabled: !0 },\n      children: []\n    }), l.className = [\"task-list-item\"];\n  }\n  let u = -1;\n  for (; ++u < r.length; ) {\n    const s = r[u];\n    (i || u !== 0 || s.type !== \"element\" || s.tagName !== \"p\") && o.push({ type: \"text\", value: `\n` }), s.type === \"element\" && s.tagName === \"p\" && !i ? o.push(...s.children) : o.push(s);\n  }\n  const a = r[r.length - 1];\n  a && (i || a.type !== \"element\" || a.tagName !== \"p\") && o.push({ type: \"text\", value: `\n` });\n  const c = { type: \"element\", tagName: \"li\", properties: l, children: o };\n  return n.patch(e, c), n.applyData(e, c);\n}\nfunction Gl(n) {\n  let e = !1;\n  if (n.type === \"list\") {\n    e = n.spread || !1;\n    const t = n.children;\n    let r = -1;\n    for (; !e && ++r < t.length; )\n      e = Wt(t[r]);\n  }\n  return e;\n}\nfunction Wt(n) {\n  const e = n.spread;\n  return e ?? n.children.length > 1;\n}\nfunction Zl(n, e) {\n  const t = {}, r = n.all(e);\n  let i = -1;\n  for (typeof e.start == \"number\" && e.start !== 1 && (t.start = e.start); ++i < r.length; ) {\n    const o = r[i];\n    if (o.type === \"element\" && o.tagName === \"li\" && o.properties && Array.isArray(o.properties.className) && o.properties.className.includes(\"task-list-item\")) {\n      t.className = [\"contains-task-list\"];\n      break;\n    }\n  }\n  const l = {\n    type: \"element\",\n    tagName: e.ordered ? \"ol\" : \"ul\",\n    properties: t,\n    children: n.wrap(r, !0)\n  };\n  return n.patch(e, l), n.applyData(e, l);\n}\nfunction Jl(n, e) {\n  const t = {\n    type: \"element\",\n    tagName: \"p\",\n    properties: {},\n    children: n.all(e)\n  };\n  return n.patch(e, t), n.applyData(e, t);\n}\nfunction no(n, e) {\n  const t = { type: \"root\", children: n.wrap(n.all(e)) };\n  return n.patch(e, t), n.applyData(e, t);\n}\nfunction eo(n, e) {\n  const t = {\n    type: \"element\",\n    tagName: \"strong\",\n    properties: {},\n    children: n.all(e)\n  };\n  return n.patch(e, t), n.applyData(e, t);\n}\nconst Fe = Yt(\"start\"), Te = Yt(\"end\");\nfunction to(n) {\n  return { start: Fe(n), end: Te(n) };\n}\nfunction Yt(n) {\n  return e;\n  function e(t) {\n    const r = t && t.position && t.position[n] || {};\n    return {\n      // @ts-expect-error: in practice, null is allowed.\n      line: r.line || null,\n      // @ts-expect-error: in practice, null is allowed.\n      column: r.column || null,\n      // @ts-expect-error: in practice, null is allowed.\n      offset: r.offset > -1 ? r.offset : null\n    };\n  }\n}\nfunction ro(n, e) {\n  const t = n.all(e), r = t.shift(), i = [];\n  if (r) {\n    const o = {\n      type: \"element\",\n      tagName: \"thead\",\n      properties: {},\n      children: n.wrap([r], !0)\n    };\n    n.patch(e.children[0], o), i.push(o);\n  }\n  if (t.length > 0) {\n    const o = {\n      type: \"element\",\n      tagName: \"tbody\",\n      properties: {},\n      children: n.wrap(t, !0)\n    }, u = Fe(e.children[1]), a = Te(e.children[e.children.length - 1]);\n    u.line && a.line && (o.position = { start: u, end: a }), i.push(o);\n  }\n  const l = {\n    type: \"element\",\n    tagName: \"table\",\n    properties: {},\n    children: n.wrap(i, !0)\n  };\n  return n.patch(e, l), n.applyData(e, l);\n}\nfunction io(n, e, t) {\n  const r = t ? t.children : void 0, l = (r ? r.indexOf(e) : 1) === 0 ? \"th\" : \"td\", o = t && t.type === \"table\" ? t.align : void 0, u = o ? o.length : e.children.length;\n  let a = -1;\n  const c = [];\n  for (; ++a < u; ) {\n    const h = e.children[a], g = {}, d = o ? o[a] : void 0;\n    d && (g.align = d);\n    let m = { type: \"element\", tagName: l, properties: g, children: [] };\n    h && (m.children = n.all(h), n.patch(h, m), m = n.applyData(e, m)), c.push(m);\n  }\n  const s = {\n    type: \"element\",\n    tagName: \"tr\",\n    properties: {},\n    children: n.wrap(c, !0)\n  };\n  return n.patch(e, s), n.applyData(e, s);\n}\nfunction lo(n, e) {\n  const t = {\n    type: \"element\",\n    tagName: \"td\",\n    // Assume body cell.\n    properties: {},\n    children: n.all(e)\n  };\n  return n.patch(e, t), n.applyData(e, t);\n}\nconst st = 9, ct = 32;\nfunction oo(n) {\n  const e = String(n), t = /\\r?\\n|\\r/g;\n  let r = t.exec(e), i = 0;\n  const l = [];\n  for (; r; )\n    l.push(\n      pt(e.slice(i, r.index), i > 0, !0),\n      r[0]\n    ), i = r.index + r[0].length, r = t.exec(e);\n  return l.push(pt(e.slice(i), i > 0, !1)), l.join(\"\");\n}\nfunction pt(n, e, t) {\n  let r = 0, i = n.length;\n  if (e) {\n    let l = n.codePointAt(r);\n    for (; l === st || l === ct; )\n      r++, l = n.codePointAt(r);\n  }\n  if (t) {\n    let l = n.codePointAt(i - 1);\n    for (; l === st || l === ct; )\n      i--, l = n.codePointAt(i - 1);\n  }\n  return i > r ? n.slice(r, i) : \"\";\n}\nfunction uo(n, e) {\n  const t = { type: \"text\", value: oo(String(e.value)) };\n  return n.patch(e, t), n.applyData(e, t);\n}\nfunction ao(n, e) {\n  const t = {\n    type: \"element\",\n    tagName: \"hr\",\n    properties: {},\n    children: []\n  };\n  return n.patch(e, t), n.applyData(e, t);\n}\nconst so = {\n  blockquote: Ml,\n  break: Bl,\n  code: Nl,\n  delete: jl,\n  emphasis: $l,\n  footnoteReference: Vt,\n  footnote: Hl,\n  heading: Ul,\n  html: Vl,\n  imageReference: ql,\n  image: Wl,\n  inlineCode: Yl,\n  linkReference: Ql,\n  link: Xl,\n  listItem: Kl,\n  list: Zl,\n  paragraph: Jl,\n  root: no,\n  strong: eo,\n  table: ro,\n  tableCell: lo,\n  tableRow: io,\n  text: uo,\n  thematicBreak: ao,\n  toml: qn,\n  yaml: qn,\n  definition: qn,\n  footnoteDefinition: qn\n};\nfunction qn() {\n  return null;\n}\nconst Qt = (\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  /**\n   * @param {Test} [test]\n   * @returns {AssertAnything}\n   */\n  function(n) {\n    if (n == null)\n      return ho;\n    if (typeof n == \"string\")\n      return fo(n);\n    if (typeof n == \"object\")\n      return Array.isArray(n) ? co(n) : po(n);\n    if (typeof n == \"function\")\n      return Jn(n);\n    throw new Error(\"Expected function, string, or object as test\");\n  }\n);\nfunction co(n) {\n  const e = [];\n  let t = -1;\n  for (; ++t < n.length; )\n    e[t] = Qt(n[t]);\n  return Jn(r);\n  function r(...i) {\n    let l = -1;\n    for (; ++l < e.length; )\n      if (e[l].call(this, ...i))\n        return !0;\n    return !1;\n  }\n}\nfunction po(n) {\n  return Jn(e);\n  function e(t) {\n    let r;\n    for (r in n)\n      if (t[r] !== n[r])\n        return !1;\n    return !0;\n  }\n}\nfunction fo(n) {\n  return Jn(e);\n  function e(t) {\n    return t && t.type === n;\n  }\n}\nfunction Jn(n) {\n  return e;\n  function e(t, ...r) {\n    return !!(t && typeof t == \"object\" && \"type\" in t && n.call(this, t, ...r));\n  }\n}\nfunction ho() {\n  return !0;\n}\nconst mo = !0, ft = !1, go = \"skip\", yo = (\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  /**\n   * @param {Node} tree\n   * @param {Test} test\n   * @param {Visitor<Node>} visitor\n   * @param {boolean | null | undefined} [reverse]\n   * @returns {void}\n   */\n  function(n, e, t, r) {\n    typeof e == \"function\" && typeof t != \"function\" && (r = t, t = e, e = null);\n    const i = Qt(e), l = r ? -1 : 1;\n    o(n, void 0, [])();\n    function o(u, a, c) {\n      const s = u && typeof u == \"object\" ? u : {};\n      if (typeof s.type == \"string\") {\n        const g = (\n          // `hast`\n          typeof s.tagName == \"string\" ? s.tagName : (\n            // `xast`\n            typeof s.name == \"string\" ? s.name : void 0\n          )\n        );\n        Object.defineProperty(h, \"name\", {\n          value: \"node (\" + (u.type + (g ? \"<\" + g + \">\" : \"\")) + \")\"\n        });\n      }\n      return h;\n      function h() {\n        let g = [], d, m, y;\n        if ((!e || i(u, a, c[c.length - 1] || null)) && (g = xo(t(u, c)), g[0] === ft))\n          return g;\n        if (u.children && g[0] !== go)\n          for (m = (r ? u.children.length : -1) + l, y = c.concat(u); m > -1 && m < u.children.length; ) {\n            if (d = o(u.children[m], m, y)(), d[0] === ft)\n              return d;\n            m = typeof d[1] == \"number\" ? d[1] : m + l;\n          }\n        return g;\n      }\n    }\n  }\n);\nfunction xo(n) {\n  return Array.isArray(n) ? n : typeof n == \"number\" ? [mo, n] : [n];\n}\nconst Xt = (\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  /**\n   * @param {Node} tree\n   * @param {Test} test\n   * @param {Visitor} visitor\n   * @param {boolean | null | undefined} [reverse]\n   * @returns {void}\n   */\n  function(n, e, t, r) {\n    typeof e == \"function\" && typeof t != \"function\" && (r = t, t = e, e = null), yo(n, e, i, r);\n    function i(l, o) {\n      const u = o[o.length - 1];\n      return t(\n        l,\n        u ? u.children.indexOf(l) : null,\n        u\n      );\n    }\n  }\n);\nfunction ko(n) {\n  return !n || !n.position || !n.position.start || !n.position.start.line || !n.position.start.column || !n.position.end || !n.position.end.line || !n.position.end.column;\n}\nconst ht = {}.hasOwnProperty;\nfunction bo(n) {\n  const e = /* @__PURE__ */ Object.create(null);\n  if (!n || !n.type)\n    throw new Error(\"mdast-util-definitions expected node\");\n  return Xt(n, \"definition\", (r) => {\n    const i = mt(r.identifier);\n    i && !ht.call(e, i) && (e[i] = r);\n  }), t;\n  function t(r) {\n    const i = mt(r);\n    return i && ht.call(e, i) ? e[i] : null;\n  }\n}\nfunction mt(n) {\n  return String(n || \"\").toUpperCase();\n}\nconst Kn = {}.hasOwnProperty;\nfunction wo(n, e) {\n  const t = e || {}, r = t.allowDangerousHtml || !1, i = {};\n  return o.dangerous = r, o.clobberPrefix = t.clobberPrefix === void 0 || t.clobberPrefix === null ? \"user-content-\" : t.clobberPrefix, o.footnoteLabel = t.footnoteLabel || \"Footnotes\", o.footnoteLabelTagName = t.footnoteLabelTagName || \"h2\", o.footnoteLabelProperties = t.footnoteLabelProperties || {\n    className: [\"sr-only\"]\n  }, o.footnoteBackLabel = t.footnoteBackLabel || \"Back to content\", o.unknownHandler = t.unknownHandler, o.passThrough = t.passThrough, o.handlers = { ...so, ...t.handlers }, o.definition = bo(n), o.footnoteById = i, o.footnoteOrder = [], o.footnoteCounts = {}, o.patch = So, o.applyData = Eo, o.one = u, o.all = a, o.wrap = Ao, o.augment = l, Xt(n, \"footnoteDefinition\", (c) => {\n    const s = String(c.identifier).toUpperCase();\n    Kn.call(i, s) || (i[s] = c);\n  }), o;\n  function l(c, s) {\n    if (c && \"data\" in c && c.data) {\n      const h = c.data;\n      h.hName && (s.type !== \"element\" && (s = {\n        type: \"element\",\n        tagName: \"\",\n        properties: {},\n        children: []\n      }), s.tagName = h.hName), s.type === \"element\" && h.hProperties && (s.properties = { ...s.properties, ...h.hProperties }), \"children\" in s && s.children && h.hChildren && (s.children = h.hChildren);\n    }\n    if (c) {\n      const h = \"type\" in c ? c : { position: c };\n      ko(h) || (s.position = { start: Fe(h), end: Te(h) });\n    }\n    return s;\n  }\n  function o(c, s, h, g) {\n    return Array.isArray(h) && (g = h, h = {}), l(c, {\n      type: \"element\",\n      tagName: s,\n      properties: h || {},\n      children: g || []\n    });\n  }\n  function u(c, s) {\n    return Kt(o, c, s);\n  }\n  function a(c) {\n    return Ie(o, c);\n  }\n}\nfunction So(n, e) {\n  n.position && (e.position = to(n));\n}\nfunction Eo(n, e) {\n  let t = e;\n  if (n && n.data) {\n    const r = n.data.hName, i = n.data.hChildren, l = n.data.hProperties;\n    typeof r == \"string\" && (t.type === \"element\" ? t.tagName = r : t = {\n      type: \"element\",\n      tagName: r,\n      properties: {},\n      children: []\n    }), t.type === \"element\" && l && (t.properties = { ...t.properties, ...l }), \"children\" in t && t.children && i !== null && i !== void 0 && (t.children = i);\n  }\n  return t;\n}\nfunction Kt(n, e, t) {\n  const r = e && e.type;\n  if (!r)\n    throw new Error(\"Expected node, got `\" + e + \"`\");\n  return Kn.call(n.handlers, r) ? n.handlers[r](n, e, t) : n.passThrough && n.passThrough.includes(r) ? \"children\" in e ? { ...e, children: Ie(n, e) } : e : n.unknownHandler ? n.unknownHandler(n, e, t) : Co(n, e);\n}\nfunction Ie(n, e) {\n  const t = [];\n  if (\"children\" in e) {\n    const r = e.children;\n    let i = -1;\n    for (; ++i < r.length; ) {\n      const l = Kt(n, r[i], e);\n      if (l) {\n        if (i && r[i - 1].type === \"break\" && (!Array.isArray(l) && l.type === \"text\" && (l.value = l.value.replace(/^\\s+/, \"\")), !Array.isArray(l) && l.type === \"element\")) {\n          const o = l.children[0];\n          o && o.type === \"text\" && (o.value = o.value.replace(/^\\s+/, \"\"));\n        }\n        Array.isArray(l) ? t.push(...l) : t.push(l);\n      }\n    }\n  }\n  return t;\n}\nfunction Co(n, e) {\n  const t = e.data || {}, r = \"value\" in e && !(Kn.call(t, \"hProperties\") || Kn.call(t, \"hChildren\")) ? { type: \"text\", value: e.value } : {\n    type: \"element\",\n    tagName: \"div\",\n    properties: {},\n    children: Ie(n, e)\n  };\n  return n.patch(e, r), n.applyData(e, r);\n}\nfunction Ao(n, e) {\n  const t = [];\n  let r = -1;\n  for (e && t.push({ type: \"text\", value: `\n` }); ++r < n.length; )\n    r && t.push({ type: \"text\", value: `\n` }), t.push(n[r]);\n  return e && n.length > 0 && t.push({ type: \"text\", value: `\n` }), t;\n}\nfunction Po(n) {\n  const e = [];\n  let t = -1;\n  for (; ++t < n.footnoteOrder.length; ) {\n    const r = n.footnoteById[n.footnoteOrder[t]];\n    if (!r)\n      continue;\n    const i = n.all(r), l = String(r.identifier).toUpperCase(), o = vn(l.toLowerCase());\n    let u = 0;\n    const a = [];\n    for (; ++u <= n.footnoteCounts[l]; ) {\n      const h = {\n        type: \"element\",\n        tagName: \"a\",\n        properties: {\n          href: \"#\" + n.clobberPrefix + \"fnref-\" + o + (u > 1 ? \"-\" + u : \"\"),\n          dataFootnoteBackref: !0,\n          className: [\"data-footnote-backref\"],\n          ariaLabel: n.footnoteBackLabel\n        },\n        children: [{ type: \"text\", value: \"â†©\" }]\n      };\n      u > 1 && h.children.push({\n        type: \"element\",\n        tagName: \"sup\",\n        children: [{ type: \"text\", value: String(u) }]\n      }), a.length > 0 && a.push({ type: \"text\", value: \" \" }), a.push(h);\n    }\n    const c = i[i.length - 1];\n    if (c && c.type === \"element\" && c.tagName === \"p\") {\n      const h = c.children[c.children.length - 1];\n      h && h.type === \"text\" ? h.value += \" \" : c.children.push({ type: \"text\", value: \" \" }), c.children.push(...a);\n    } else\n      i.push(...a);\n    const s = {\n      type: \"element\",\n      tagName: \"li\",\n      properties: { id: n.clobberPrefix + \"fn-\" + o },\n      children: n.wrap(i, !0)\n    };\n    n.patch(r, s), e.push(s);\n  }\n  if (e.length !== 0)\n    return {\n      type: \"element\",\n      tagName: \"section\",\n      properties: { dataFootnotes: !0, className: [\"footnotes\"] },\n      children: [\n        {\n          type: \"element\",\n          tagName: n.footnoteLabelTagName,\n          properties: {\n            // To do: use structured clone.\n            ...JSON.parse(JSON.stringify(n.footnoteLabelProperties)),\n            id: \"footnote-label\"\n          },\n          children: [{ type: \"text\", value: n.footnoteLabel }]\n        },\n        { type: \"text\", value: `\n` },\n        {\n          type: \"element\",\n          tagName: \"ol\",\n          properties: {},\n          children: n.wrap(e, !0)\n        },\n        { type: \"text\", value: `\n` }\n      ]\n    };\n}\nfunction Gt(n, e) {\n  const t = wo(n, e), r = t.one(n, null), i = Po(t);\n  return i && r.children.push({ type: \"text\", value: `\n` }, i), Array.isArray(r) ? { type: \"root\", children: r } : r;\n}\nconst Fo = (\n  /** @type {(import('unified').Plugin<[Processor, Options?]|[null|undefined, Options?]|[Options]|[], MdastRoot>)} */\n  function(n, e) {\n    return n && \"run\" in n ? Io(n, e) : Oo(n || e);\n  }\n), To = Fo;\nfunction Io(n, e) {\n  return (t, r, i) => {\n    n.run(Gt(t, e), r, (l) => {\n      i(l);\n    });\n  };\n}\nfunction Oo(n) {\n  return (e) => Gt(e, n);\n}\nclass Un {\n  /**\n   * @constructor\n   * @param {Properties} property\n   * @param {Normal} normal\n   * @param {string} [space]\n   */\n  constructor(e, t, r) {\n    this.property = e, this.normal = t, r && (this.space = r);\n  }\n}\nUn.prototype.property = {};\nUn.prototype.normal = {};\nUn.prototype.space = null;\nfunction Zt(n, e) {\n  const t = {}, r = {};\n  let i = -1;\n  for (; ++i < n.length; )\n    Object.assign(t, n[i].property), Object.assign(r, n[i].normal);\n  return new Un(t, r, e);\n}\nfunction be(n) {\n  return n.toLowerCase();\n}\nclass pn {\n  /**\n   * @constructor\n   * @param {string} property\n   * @param {string} attribute\n   */\n  constructor(e, t) {\n    this.property = e, this.attribute = t;\n  }\n}\npn.prototype.space = null;\npn.prototype.boolean = !1;\npn.prototype.booleanish = !1;\npn.prototype.overloadedBoolean = !1;\npn.prototype.number = !1;\npn.prototype.commaSeparated = !1;\npn.prototype.spaceSeparated = !1;\npn.prototype.commaOrSpaceSeparated = !1;\npn.prototype.mustUseProperty = !1;\npn.prototype.defined = !1;\nlet Lo = 0;\nconst z = In(), K = In(), Jt = In(), S = In(), V = In(), Dn = In(), ln = In();\nfunction In() {\n  return 2 ** ++Lo;\n}\nconst we = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  boolean: z,\n  booleanish: K,\n  commaOrSpaceSeparated: ln,\n  commaSeparated: Dn,\n  number: S,\n  overloadedBoolean: Jt,\n  spaceSeparated: V\n}, Symbol.toStringTag, { value: \"Module\" })), pe = Object.keys(we);\nclass Oe extends pn {\n  /**\n   * @constructor\n   * @param {string} property\n   * @param {string} attribute\n   * @param {number|null} [mask]\n   * @param {string} [space]\n   */\n  constructor(e, t, r, i) {\n    let l = -1;\n    if (super(e, t), dt(this, \"space\", i), typeof r == \"number\")\n      for (; ++l < pe.length; ) {\n        const o = pe[l];\n        dt(this, pe[l], (r & we[o]) === we[o]);\n      }\n  }\n}\nOe.prototype.defined = !0;\nfunction dt(n, e, t) {\n  t && (n[e] = t);\n}\nconst Do = {}.hasOwnProperty;\nfunction zn(n) {\n  const e = {}, t = {};\n  let r;\n  for (r in n.properties)\n    if (Do.call(n.properties, r)) {\n      const i = n.properties[r], l = new Oe(\n        r,\n        n.transform(n.attributes || {}, r),\n        i,\n        n.space\n      );\n      n.mustUseProperty && n.mustUseProperty.includes(r) && (l.mustUseProperty = !0), e[r] = l, t[be(r)] = r, t[be(l.attribute)] = r;\n    }\n  return new Un(e, t, n.space);\n}\nconst nr = zn({\n  space: \"xlink\",\n  transform(n, e) {\n    return \"xlink:\" + e.slice(5).toLowerCase();\n  },\n  properties: {\n    xLinkActuate: null,\n    xLinkArcRole: null,\n    xLinkHref: null,\n    xLinkRole: null,\n    xLinkShow: null,\n    xLinkTitle: null,\n    xLinkType: null\n  }\n}), er = zn({\n  space: \"xml\",\n  transform(n, e) {\n    return \"xml:\" + e.slice(3).toLowerCase();\n  },\n  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }\n});\nfunction tr(n, e) {\n  return e in n ? n[e] : e;\n}\nfunction rr(n, e) {\n  return tr(n, e.toLowerCase());\n}\nconst ir = zn({\n  space: \"xmlns\",\n  attributes: { xmlnsxlink: \"xmlns:xlink\" },\n  transform: rr,\n  properties: { xmlns: null, xmlnsXLink: null }\n}), lr = zn({\n  transform(n, e) {\n    return e === \"role\" ? e : \"aria-\" + e.slice(4).toLowerCase();\n  },\n  properties: {\n    ariaActiveDescendant: null,\n    ariaAtomic: K,\n    ariaAutoComplete: null,\n    ariaBusy: K,\n    ariaChecked: K,\n    ariaColCount: S,\n    ariaColIndex: S,\n    ariaColSpan: S,\n    ariaControls: V,\n    ariaCurrent: null,\n    ariaDescribedBy: V,\n    ariaDetails: null,\n    ariaDisabled: K,\n    ariaDropEffect: V,\n    ariaErrorMessage: null,\n    ariaExpanded: K,\n    ariaFlowTo: V,\n    ariaGrabbed: K,\n    ariaHasPopup: null,\n    ariaHidden: K,\n    ariaInvalid: null,\n    ariaKeyShortcuts: null,\n    ariaLabel: null,\n    ariaLabelledBy: V,\n    ariaLevel: S,\n    ariaLive: null,\n    ariaModal: K,\n    ariaMultiLine: K,\n    ariaMultiSelectable: K,\n    ariaOrientation: null,\n    ariaOwns: V,\n    ariaPlaceholder: null,\n    ariaPosInSet: S,\n    ariaPressed: K,\n    ariaReadOnly: K,\n    ariaRelevant: null,\n    ariaRequired: K,\n    ariaRoleDescription: V,\n    ariaRowCount: S,\n    ariaRowIndex: S,\n    ariaRowSpan: S,\n    ariaSelected: K,\n    ariaSetSize: S,\n    ariaSort: null,\n    ariaValueMax: S,\n    ariaValueMin: S,\n    ariaValueNow: S,\n    ariaValueText: null,\n    role: null\n  }\n}), vo = zn({\n  space: \"html\",\n  attributes: {\n    acceptcharset: \"accept-charset\",\n    classname: \"class\",\n    htmlfor: \"for\",\n    httpequiv: \"http-equiv\"\n  },\n  transform: rr,\n  mustUseProperty: [\"checked\", \"multiple\", \"muted\", \"selected\"],\n  properties: {\n    // Standard Properties.\n    abbr: null,\n    accept: Dn,\n    acceptCharset: V,\n    accessKey: V,\n    action: null,\n    allow: null,\n    allowFullScreen: z,\n    allowPaymentRequest: z,\n    allowUserMedia: z,\n    alt: null,\n    as: null,\n    async: z,\n    autoCapitalize: null,\n    autoComplete: V,\n    autoFocus: z,\n    autoPlay: z,\n    capture: z,\n    charSet: null,\n    checked: z,\n    cite: null,\n    className: V,\n    cols: S,\n    colSpan: null,\n    content: null,\n    contentEditable: K,\n    controls: z,\n    controlsList: V,\n    coords: S | Dn,\n    crossOrigin: null,\n    data: null,\n    dateTime: null,\n    decoding: null,\n    default: z,\n    defer: z,\n    dir: null,\n    dirName: null,\n    disabled: z,\n    download: Jt,\n    draggable: K,\n    encType: null,\n    enterKeyHint: null,\n    form: null,\n    formAction: null,\n    formEncType: null,\n    formMethod: null,\n    formNoValidate: z,\n    formTarget: null,\n    headers: V,\n    height: S,\n    hidden: z,\n    high: S,\n    href: null,\n    hrefLang: null,\n    htmlFor: V,\n    httpEquiv: V,\n    id: null,\n    imageSizes: null,\n    imageSrcSet: null,\n    inputMode: null,\n    integrity: null,\n    is: null,\n    isMap: z,\n    itemId: null,\n    itemProp: V,\n    itemRef: V,\n    itemScope: z,\n    itemType: V,\n    kind: null,\n    label: null,\n    lang: null,\n    language: null,\n    list: null,\n    loading: null,\n    loop: z,\n    low: S,\n    manifest: null,\n    max: null,\n    maxLength: S,\n    media: null,\n    method: null,\n    min: null,\n    minLength: S,\n    multiple: z,\n    muted: z,\n    name: null,\n    nonce: null,\n    noModule: z,\n    noValidate: z,\n    onAbort: null,\n    onAfterPrint: null,\n    onAuxClick: null,\n    onBeforeMatch: null,\n    onBeforePrint: null,\n    onBeforeUnload: null,\n    onBlur: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onContextLost: null,\n    onContextMenu: null,\n    onContextRestored: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFormData: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLanguageChange: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadEnd: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMessageError: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRejectionHandled: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onScrollEnd: null,\n    onSecurityPolicyViolation: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onSlotChange: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnhandledRejection: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onWheel: null,\n    open: z,\n    optimum: S,\n    pattern: null,\n    ping: V,\n    placeholder: null,\n    playsInline: z,\n    poster: null,\n    preload: null,\n    readOnly: z,\n    referrerPolicy: null,\n    rel: V,\n    required: z,\n    reversed: z,\n    rows: S,\n    rowSpan: S,\n    sandbox: V,\n    scope: null,\n    scoped: z,\n    seamless: z,\n    selected: z,\n    shape: null,\n    size: S,\n    sizes: null,\n    slot: null,\n    span: S,\n    spellCheck: K,\n    src: null,\n    srcDoc: null,\n    srcLang: null,\n    srcSet: null,\n    start: S,\n    step: null,\n    style: null,\n    tabIndex: S,\n    target: null,\n    title: null,\n    translate: null,\n    type: null,\n    typeMustMatch: z,\n    useMap: null,\n    value: K,\n    width: S,\n    wrap: null,\n    // Legacy.\n    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis\n    align: null,\n    // Several. Use CSS `text-align` instead,\n    aLink: null,\n    // `<body>`. Use CSS `a:active {color}` instead\n    archive: V,\n    // `<object>`. List of URIs to archives\n    axis: null,\n    // `<td>` and `<th>`. Use `scope` on `<th>`\n    background: null,\n    // `<body>`. Use CSS `background-image` instead\n    bgColor: null,\n    // `<body>` and table elements. Use CSS `background-color` instead\n    border: S,\n    // `<table>`. Use CSS `border-width` instead,\n    borderColor: null,\n    // `<table>`. Use CSS `border-color` instead,\n    bottomMargin: S,\n    // `<body>`\n    cellPadding: null,\n    // `<table>`\n    cellSpacing: null,\n    // `<table>`\n    char: null,\n    // Several table elements. When `align=char`, sets the character to align on\n    charOff: null,\n    // Several table elements. When `char`, offsets the alignment\n    classId: null,\n    // `<object>`\n    clear: null,\n    // `<br>`. Use CSS `clear` instead\n    code: null,\n    // `<object>`\n    codeBase: null,\n    // `<object>`\n    codeType: null,\n    // `<object>`\n    color: null,\n    // `<font>` and `<hr>`. Use CSS instead\n    compact: z,\n    // Lists. Use CSS to reduce space between items instead\n    declare: z,\n    // `<object>`\n    event: null,\n    // `<script>`\n    face: null,\n    // `<font>`. Use CSS instead\n    frame: null,\n    // `<table>`\n    frameBorder: null,\n    // `<iframe>`. Use CSS `border` instead\n    hSpace: S,\n    // `<img>` and `<object>`\n    leftMargin: S,\n    // `<body>`\n    link: null,\n    // `<body>`. Use CSS `a:link {color: *}` instead\n    longDesc: null,\n    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`\n    lowSrc: null,\n    // `<img>`. Use a `<picture>`\n    marginHeight: S,\n    // `<body>`\n    marginWidth: S,\n    // `<body>`\n    noResize: z,\n    // `<frame>`\n    noHref: z,\n    // `<area>`. Use no href instead of an explicit `nohref`\n    noShade: z,\n    // `<hr>`. Use background-color and height instead of borders\n    noWrap: z,\n    // `<td>` and `<th>`\n    object: null,\n    // `<applet>`\n    profile: null,\n    // `<head>`\n    prompt: null,\n    // `<isindex>`\n    rev: null,\n    // `<link>`\n    rightMargin: S,\n    // `<body>`\n    rules: null,\n    // `<table>`\n    scheme: null,\n    // `<meta>`\n    scrolling: K,\n    // `<frame>`. Use overflow in the child context\n    standby: null,\n    // `<object>`\n    summary: null,\n    // `<table>`\n    text: null,\n    // `<body>`. Use CSS `color` instead\n    topMargin: S,\n    // `<body>`\n    valueType: null,\n    // `<param>`\n    version: null,\n    // `<html>`. Use a doctype.\n    vAlign: null,\n    // Several. Use CSS `vertical-align` instead\n    vLink: null,\n    // `<body>`. Use CSS `a:visited {color}` instead\n    vSpace: S,\n    // `<img>` and `<object>`\n    // Non-standard Properties.\n    allowTransparency: null,\n    autoCorrect: null,\n    autoSave: null,\n    disablePictureInPicture: z,\n    disableRemotePlayback: z,\n    prefix: null,\n    property: null,\n    results: S,\n    security: null,\n    unselectable: null\n  }\n}), zo = zn({\n  space: \"svg\",\n  attributes: {\n    accentHeight: \"accent-height\",\n    alignmentBaseline: \"alignment-baseline\",\n    arabicForm: \"arabic-form\",\n    baselineShift: \"baseline-shift\",\n    capHeight: \"cap-height\",\n    className: \"class\",\n    clipPath: \"clip-path\",\n    clipRule: \"clip-rule\",\n    colorInterpolation: \"color-interpolation\",\n    colorInterpolationFilters: \"color-interpolation-filters\",\n    colorProfile: \"color-profile\",\n    colorRendering: \"color-rendering\",\n    crossOrigin: \"crossorigin\",\n    dataType: \"datatype\",\n    dominantBaseline: \"dominant-baseline\",\n    enableBackground: \"enable-background\",\n    fillOpacity: \"fill-opacity\",\n    fillRule: \"fill-rule\",\n    floodColor: \"flood-color\",\n    floodOpacity: \"flood-opacity\",\n    fontFamily: \"font-family\",\n    fontSize: \"font-size\",\n    fontSizeAdjust: \"font-size-adjust\",\n    fontStretch: \"font-stretch\",\n    fontStyle: \"font-style\",\n    fontVariant: \"font-variant\",\n    fontWeight: \"font-weight\",\n    glyphName: \"glyph-name\",\n    glyphOrientationHorizontal: \"glyph-orientation-horizontal\",\n    glyphOrientationVertical: \"glyph-orientation-vertical\",\n    hrefLang: \"hreflang\",\n    horizAdvX: \"horiz-adv-x\",\n    horizOriginX: \"horiz-origin-x\",\n    horizOriginY: \"horiz-origin-y\",\n    imageRendering: \"image-rendering\",\n    letterSpacing: \"letter-spacing\",\n    lightingColor: \"lighting-color\",\n    markerEnd: \"marker-end\",\n    markerMid: \"marker-mid\",\n    markerStart: \"marker-start\",\n    navDown: \"nav-down\",\n    navDownLeft: \"nav-down-left\",\n    navDownRight: \"nav-down-right\",\n    navLeft: \"nav-left\",\n    navNext: \"nav-next\",\n    navPrev: \"nav-prev\",\n    navRight: \"nav-right\",\n    navUp: \"nav-up\",\n    navUpLeft: \"nav-up-left\",\n    navUpRight: \"nav-up-right\",\n    onAbort: \"onabort\",\n    onActivate: \"onactivate\",\n    onAfterPrint: \"onafterprint\",\n    onBeforePrint: \"onbeforeprint\",\n    onBegin: \"onbegin\",\n    onCancel: \"oncancel\",\n    onCanPlay: \"oncanplay\",\n    onCanPlayThrough: \"oncanplaythrough\",\n    onChange: \"onchange\",\n    onClick: \"onclick\",\n    onClose: \"onclose\",\n    onCopy: \"oncopy\",\n    onCueChange: \"oncuechange\",\n    onCut: \"oncut\",\n    onDblClick: \"ondblclick\",\n    onDrag: \"ondrag\",\n    onDragEnd: \"ondragend\",\n    onDragEnter: \"ondragenter\",\n    onDragExit: \"ondragexit\",\n    onDragLeave: \"ondragleave\",\n    onDragOver: \"ondragover\",\n    onDragStart: \"ondragstart\",\n    onDrop: \"ondrop\",\n    onDurationChange: \"ondurationchange\",\n    onEmptied: \"onemptied\",\n    onEnd: \"onend\",\n    onEnded: \"onended\",\n    onError: \"onerror\",\n    onFocus: \"onfocus\",\n    onFocusIn: \"onfocusin\",\n    onFocusOut: \"onfocusout\",\n    onHashChange: \"onhashchange\",\n    onInput: \"oninput\",\n    onInvalid: \"oninvalid\",\n    onKeyDown: \"onkeydown\",\n    onKeyPress: \"onkeypress\",\n    onKeyUp: \"onkeyup\",\n    onLoad: \"onload\",\n    onLoadedData: \"onloadeddata\",\n    onLoadedMetadata: \"onloadedmetadata\",\n    onLoadStart: \"onloadstart\",\n    onMessage: \"onmessage\",\n    onMouseDown: \"onmousedown\",\n    onMouseEnter: \"onmouseenter\",\n    onMouseLeave: \"onmouseleave\",\n    onMouseMove: \"onmousemove\",\n    onMouseOut: \"onmouseout\",\n    onMouseOver: \"onmouseover\",\n    onMouseUp: \"onmouseup\",\n    onMouseWheel: \"onmousewheel\",\n    onOffline: \"onoffline\",\n    onOnline: \"ononline\",\n    onPageHide: \"onpagehide\",\n    onPageShow: \"onpageshow\",\n    onPaste: \"onpaste\",\n    onPause: \"onpause\",\n    onPlay: \"onplay\",\n    onPlaying: \"onplaying\",\n    onPopState: \"onpopstate\",\n    onProgress: \"onprogress\",\n    onRateChange: \"onratechange\",\n    onRepeat: \"onrepeat\",\n    onReset: \"onreset\",\n    onResize: \"onresize\",\n    onScroll: \"onscroll\",\n    onSeeked: \"onseeked\",\n    onSeeking: \"onseeking\",\n    onSelect: \"onselect\",\n    onShow: \"onshow\",\n    onStalled: \"onstalled\",\n    onStorage: \"onstorage\",\n    onSubmit: \"onsubmit\",\n    onSuspend: \"onsuspend\",\n    onTimeUpdate: \"ontimeupdate\",\n    onToggle: \"ontoggle\",\n    onUnload: \"onunload\",\n    onVolumeChange: \"onvolumechange\",\n    onWaiting: \"onwaiting\",\n    onZoom: \"onzoom\",\n    overlinePosition: \"overline-position\",\n    overlineThickness: \"overline-thickness\",\n    paintOrder: \"paint-order\",\n    panose1: \"panose-1\",\n    pointerEvents: \"pointer-events\",\n    referrerPolicy: \"referrerpolicy\",\n    renderingIntent: \"rendering-intent\",\n    shapeRendering: \"shape-rendering\",\n    stopColor: \"stop-color\",\n    stopOpacity: \"stop-opacity\",\n    strikethroughPosition: \"strikethrough-position\",\n    strikethroughThickness: \"strikethrough-thickness\",\n    strokeDashArray: \"stroke-dasharray\",\n    strokeDashOffset: \"stroke-dashoffset\",\n    strokeLineCap: \"stroke-linecap\",\n    strokeLineJoin: \"stroke-linejoin\",\n    strokeMiterLimit: \"stroke-miterlimit\",\n    strokeOpacity: \"stroke-opacity\",\n    strokeWidth: \"stroke-width\",\n    tabIndex: \"tabindex\",\n    textAnchor: \"text-anchor\",\n    textDecoration: \"text-decoration\",\n    textRendering: \"text-rendering\",\n    typeOf: \"typeof\",\n    underlinePosition: \"underline-position\",\n    underlineThickness: \"underline-thickness\",\n    unicodeBidi: \"unicode-bidi\",\n    unicodeRange: \"unicode-range\",\n    unitsPerEm: \"units-per-em\",\n    vAlphabetic: \"v-alphabetic\",\n    vHanging: \"v-hanging\",\n    vIdeographic: \"v-ideographic\",\n    vMathematical: \"v-mathematical\",\n    vectorEffect: \"vector-effect\",\n    vertAdvY: \"vert-adv-y\",\n    vertOriginX: \"vert-origin-x\",\n    vertOriginY: \"vert-origin-y\",\n    wordSpacing: \"word-spacing\",\n    writingMode: \"writing-mode\",\n    xHeight: \"x-height\",\n    // These were camelcased in Tiny. Now lowercased in SVG 2\n    playbackOrder: \"playbackorder\",\n    timelineBegin: \"timelinebegin\"\n  },\n  transform: tr,\n  properties: {\n    about: ln,\n    accentHeight: S,\n    accumulate: null,\n    additive: null,\n    alignmentBaseline: null,\n    alphabetic: S,\n    amplitude: S,\n    arabicForm: null,\n    ascent: S,\n    attributeName: null,\n    attributeType: null,\n    azimuth: S,\n    bandwidth: null,\n    baselineShift: null,\n    baseFrequency: null,\n    baseProfile: null,\n    bbox: null,\n    begin: null,\n    bias: S,\n    by: null,\n    calcMode: null,\n    capHeight: S,\n    className: V,\n    clip: null,\n    clipPath: null,\n    clipPathUnits: null,\n    clipRule: null,\n    color: null,\n    colorInterpolation: null,\n    colorInterpolationFilters: null,\n    colorProfile: null,\n    colorRendering: null,\n    content: null,\n    contentScriptType: null,\n    contentStyleType: null,\n    crossOrigin: null,\n    cursor: null,\n    cx: null,\n    cy: null,\n    d: null,\n    dataType: null,\n    defaultAction: null,\n    descent: S,\n    diffuseConstant: S,\n    direction: null,\n    display: null,\n    dur: null,\n    divisor: S,\n    dominantBaseline: null,\n    download: z,\n    dx: null,\n    dy: null,\n    edgeMode: null,\n    editable: null,\n    elevation: S,\n    enableBackground: null,\n    end: null,\n    event: null,\n    exponent: S,\n    externalResourcesRequired: null,\n    fill: null,\n    fillOpacity: S,\n    fillRule: null,\n    filter: null,\n    filterRes: null,\n    filterUnits: null,\n    floodColor: null,\n    floodOpacity: null,\n    focusable: null,\n    focusHighlight: null,\n    fontFamily: null,\n    fontSize: null,\n    fontSizeAdjust: null,\n    fontStretch: null,\n    fontStyle: null,\n    fontVariant: null,\n    fontWeight: null,\n    format: null,\n    fr: null,\n    from: null,\n    fx: null,\n    fy: null,\n    g1: Dn,\n    g2: Dn,\n    glyphName: Dn,\n    glyphOrientationHorizontal: null,\n    glyphOrientationVertical: null,\n    glyphRef: null,\n    gradientTransform: null,\n    gradientUnits: null,\n    handler: null,\n    hanging: S,\n    hatchContentUnits: null,\n    hatchUnits: null,\n    height: null,\n    href: null,\n    hrefLang: null,\n    horizAdvX: S,\n    horizOriginX: S,\n    horizOriginY: S,\n    id: null,\n    ideographic: S,\n    imageRendering: null,\n    initialVisibility: null,\n    in: null,\n    in2: null,\n    intercept: S,\n    k: S,\n    k1: S,\n    k2: S,\n    k3: S,\n    k4: S,\n    kernelMatrix: ln,\n    kernelUnitLength: null,\n    keyPoints: null,\n    // SEMI_COLON_SEPARATED\n    keySplines: null,\n    // SEMI_COLON_SEPARATED\n    keyTimes: null,\n    // SEMI_COLON_SEPARATED\n    kerning: null,\n    lang: null,\n    lengthAdjust: null,\n    letterSpacing: null,\n    lightingColor: null,\n    limitingConeAngle: S,\n    local: null,\n    markerEnd: null,\n    markerMid: null,\n    markerStart: null,\n    markerHeight: null,\n    markerUnits: null,\n    markerWidth: null,\n    mask: null,\n    maskContentUnits: null,\n    maskUnits: null,\n    mathematical: null,\n    max: null,\n    media: null,\n    mediaCharacterEncoding: null,\n    mediaContentEncodings: null,\n    mediaSize: S,\n    mediaTime: null,\n    method: null,\n    min: null,\n    mode: null,\n    name: null,\n    navDown: null,\n    navDownLeft: null,\n    navDownRight: null,\n    navLeft: null,\n    navNext: null,\n    navPrev: null,\n    navRight: null,\n    navUp: null,\n    navUpLeft: null,\n    navUpRight: null,\n    numOctaves: null,\n    observer: null,\n    offset: null,\n    onAbort: null,\n    onActivate: null,\n    onAfterPrint: null,\n    onBeforePrint: null,\n    onBegin: null,\n    onCancel: null,\n    onCanPlay: null,\n    onCanPlayThrough: null,\n    onChange: null,\n    onClick: null,\n    onClose: null,\n    onCopy: null,\n    onCueChange: null,\n    onCut: null,\n    onDblClick: null,\n    onDrag: null,\n    onDragEnd: null,\n    onDragEnter: null,\n    onDragExit: null,\n    onDragLeave: null,\n    onDragOver: null,\n    onDragStart: null,\n    onDrop: null,\n    onDurationChange: null,\n    onEmptied: null,\n    onEnd: null,\n    onEnded: null,\n    onError: null,\n    onFocus: null,\n    onFocusIn: null,\n    onFocusOut: null,\n    onHashChange: null,\n    onInput: null,\n    onInvalid: null,\n    onKeyDown: null,\n    onKeyPress: null,\n    onKeyUp: null,\n    onLoad: null,\n    onLoadedData: null,\n    onLoadedMetadata: null,\n    onLoadStart: null,\n    onMessage: null,\n    onMouseDown: null,\n    onMouseEnter: null,\n    onMouseLeave: null,\n    onMouseMove: null,\n    onMouseOut: null,\n    onMouseOver: null,\n    onMouseUp: null,\n    onMouseWheel: null,\n    onOffline: null,\n    onOnline: null,\n    onPageHide: null,\n    onPageShow: null,\n    onPaste: null,\n    onPause: null,\n    onPlay: null,\n    onPlaying: null,\n    onPopState: null,\n    onProgress: null,\n    onRateChange: null,\n    onRepeat: null,\n    onReset: null,\n    onResize: null,\n    onScroll: null,\n    onSeeked: null,\n    onSeeking: null,\n    onSelect: null,\n    onShow: null,\n    onStalled: null,\n    onStorage: null,\n    onSubmit: null,\n    onSuspend: null,\n    onTimeUpdate: null,\n    onToggle: null,\n    onUnload: null,\n    onVolumeChange: null,\n    onWaiting: null,\n    onZoom: null,\n    opacity: null,\n    operator: null,\n    order: null,\n    orient: null,\n    orientation: null,\n    origin: null,\n    overflow: null,\n    overlay: null,\n    overlinePosition: S,\n    overlineThickness: S,\n    paintOrder: null,\n    panose1: null,\n    path: null,\n    pathLength: S,\n    patternContentUnits: null,\n    patternTransform: null,\n    patternUnits: null,\n    phase: null,\n    ping: V,\n    pitch: null,\n    playbackOrder: null,\n    pointerEvents: null,\n    points: null,\n    pointsAtX: S,\n    pointsAtY: S,\n    pointsAtZ: S,\n    preserveAlpha: null,\n    preserveAspectRatio: null,\n    primitiveUnits: null,\n    propagate: null,\n    property: ln,\n    r: null,\n    radius: null,\n    referrerPolicy: null,\n    refX: null,\n    refY: null,\n    rel: ln,\n    rev: ln,\n    renderingIntent: null,\n    repeatCount: null,\n    repeatDur: null,\n    requiredExtensions: ln,\n    requiredFeatures: ln,\n    requiredFonts: ln,\n    requiredFormats: ln,\n    resource: null,\n    restart: null,\n    result: null,\n    rotate: null,\n    rx: null,\n    ry: null,\n    scale: null,\n    seed: null,\n    shapeRendering: null,\n    side: null,\n    slope: null,\n    snapshotTime: null,\n    specularConstant: S,\n    specularExponent: S,\n    spreadMethod: null,\n    spacing: null,\n    startOffset: null,\n    stdDeviation: null,\n    stemh: null,\n    stemv: null,\n    stitchTiles: null,\n    stopColor: null,\n    stopOpacity: null,\n    strikethroughPosition: S,\n    strikethroughThickness: S,\n    string: null,\n    stroke: null,\n    strokeDashArray: ln,\n    strokeDashOffset: null,\n    strokeLineCap: null,\n    strokeLineJoin: null,\n    strokeMiterLimit: S,\n    strokeOpacity: S,\n    strokeWidth: null,\n    style: null,\n    surfaceScale: S,\n    syncBehavior: null,\n    syncBehaviorDefault: null,\n    syncMaster: null,\n    syncTolerance: null,\n    syncToleranceDefault: null,\n    systemLanguage: ln,\n    tabIndex: S,\n    tableValues: null,\n    target: null,\n    targetX: S,\n    targetY: S,\n    textAnchor: null,\n    textDecoration: null,\n    textRendering: null,\n    textLength: null,\n    timelineBegin: null,\n    title: null,\n    transformBehavior: null,\n    type: null,\n    typeOf: ln,\n    to: null,\n    transform: null,\n    u1: null,\n    u2: null,\n    underlinePosition: S,\n    underlineThickness: S,\n    unicode: null,\n    unicodeBidi: null,\n    unicodeRange: null,\n    unitsPerEm: S,\n    values: null,\n    vAlphabetic: S,\n    vMathematical: S,\n    vectorEffect: null,\n    vHanging: S,\n    vIdeographic: S,\n    version: null,\n    vertAdvY: S,\n    vertOriginX: S,\n    vertOriginY: S,\n    viewBox: null,\n    viewTarget: null,\n    visibility: null,\n    width: null,\n    widths: null,\n    wordSpacing: null,\n    writingMode: null,\n    x: null,\n    x1: null,\n    x2: null,\n    xChannelSelector: null,\n    xHeight: S,\n    y: null,\n    y1: null,\n    y2: null,\n    yChannelSelector: null,\n    z: null,\n    zoomAndPan: null\n  }\n}), Ro = /^data[-\\w.:]+$/i, gt = /-[a-z]/g, _o = /[A-Z]/g;\nfunction Mo(n, e) {\n  const t = be(e);\n  let r = e, i = pn;\n  if (t in n.normal)\n    return n.property[n.normal[t]];\n  if (t.length > 4 && t.slice(0, 4) === \"data\" && Ro.test(e)) {\n    if (e.charAt(4) === \"-\") {\n      const l = e.slice(5).replace(gt, No);\n      r = \"data\" + l.charAt(0).toUpperCase() + l.slice(1);\n    } else {\n      const l = e.slice(4);\n      if (!gt.test(l)) {\n        let o = l.replace(_o, Bo);\n        o.charAt(0) !== \"-\" && (o = \"-\" + o), e = \"data\" + o;\n      }\n    }\n    i = Oe;\n  }\n  return new i(r, e);\n}\nfunction Bo(n) {\n  return \"-\" + n.toLowerCase();\n}\nfunction No(n) {\n  return n.charAt(1).toUpperCase();\n}\nconst yt = {\n  classId: \"classID\",\n  dataType: \"datatype\",\n  itemId: \"itemID\",\n  strokeDashArray: \"strokeDasharray\",\n  strokeDashOffset: \"strokeDashoffset\",\n  strokeLineCap: \"strokeLinecap\",\n  strokeLineJoin: \"strokeLinejoin\",\n  strokeMiterLimit: \"strokeMiterlimit\",\n  typeOf: \"typeof\",\n  xLinkActuate: \"xlinkActuate\",\n  xLinkArcRole: \"xlinkArcrole\",\n  xLinkHref: \"xlinkHref\",\n  xLinkRole: \"xlinkRole\",\n  xLinkShow: \"xlinkShow\",\n  xLinkTitle: \"xlinkTitle\",\n  xLinkType: \"xlinkType\",\n  xmlnsXLink: \"xmlnsXlink\"\n}, jo = Zt([er, nr, ir, lr, vo], \"html\"), $o = Zt([er, nr, ir, lr, zo], \"svg\"), or = (\n  /**\n   * @type {(\n   *   (<Kind extends Node>(test: PredicateTest<Kind>) => AssertPredicate<Kind>) &\n   *   ((test?: Test) => AssertAnything)\n   * )}\n   */\n  /**\n   * @param {Test} [test]\n   * @returns {AssertAnything}\n   */\n  function(n) {\n    if (n == null)\n      return qo;\n    if (typeof n == \"string\")\n      return Vo(n);\n    if (typeof n == \"object\")\n      return Array.isArray(n) ? Ho(n) : Uo(n);\n    if (typeof n == \"function\")\n      return ne(n);\n    throw new Error(\"Expected function, string, or object as test\");\n  }\n);\nfunction Ho(n) {\n  const e = [];\n  let t = -1;\n  for (; ++t < n.length; )\n    e[t] = or(n[t]);\n  return ne(r);\n  function r(...i) {\n    let l = -1;\n    for (; ++l < e.length; )\n      if (e[l].call(this, ...i))\n        return !0;\n    return !1;\n  }\n}\nfunction Uo(n) {\n  return ne(e);\n  function e(t) {\n    let r;\n    for (r in n)\n      if (t[r] !== n[r])\n        return !1;\n    return !0;\n  }\n}\nfunction Vo(n) {\n  return ne(e);\n  function e(t) {\n    return t && t.type === n;\n  }\n}\nfunction ne(n) {\n  return e;\n  function e(t, ...r) {\n    return !!(t && typeof t == \"object\" && \"type\" in t && n.call(this, t, ...r));\n  }\n}\nfunction qo() {\n  return !0;\n}\nconst Wo = !0, xt = !1, Yo = \"skip\", Qo = (\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  /**\n   * @param {Node} tree\n   * @param {Test} test\n   * @param {Visitor<Node>} visitor\n   * @param {boolean | null | undefined} [reverse]\n   * @returns {void}\n   */\n  function(n, e, t, r) {\n    typeof e == \"function\" && typeof t != \"function\" && (r = t, t = e, e = null);\n    const i = or(e), l = r ? -1 : 1;\n    o(n, void 0, [])();\n    function o(u, a, c) {\n      const s = u && typeof u == \"object\" ? u : {};\n      if (typeof s.type == \"string\") {\n        const g = (\n          // `hast`\n          typeof s.tagName == \"string\" ? s.tagName : (\n            // `xast`\n            typeof s.name == \"string\" ? s.name : void 0\n          )\n        );\n        Object.defineProperty(h, \"name\", {\n          value: \"node (\" + (u.type + (g ? \"<\" + g + \">\" : \"\")) + \")\"\n        });\n      }\n      return h;\n      function h() {\n        let g = [], d, m, y;\n        if ((!e || i(u, a, c[c.length - 1] || null)) && (g = Xo(t(u, c)), g[0] === xt))\n          return g;\n        if (u.children && g[0] !== Yo)\n          for (m = (r ? u.children.length : -1) + l, y = c.concat(u); m > -1 && m < u.children.length; ) {\n            if (d = o(u.children[m], m, y)(), d[0] === xt)\n              return d;\n            m = typeof d[1] == \"number\" ? d[1] : m + l;\n          }\n        return g;\n      }\n    }\n  }\n);\nfunction Xo(n) {\n  return Array.isArray(n) ? n : typeof n == \"number\" ? [Wo, n] : [n];\n}\nconst Ko = (\n  /**\n   * @type {(\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: BuildVisitor<Tree, Check>, reverse?: boolean | null | undefined) => void) &\n   *   (<Tree extends Node>(tree: Tree, visitor: BuildVisitor<Tree>, reverse?: boolean | null | undefined) => void)\n   * )}\n   */\n  /**\n   * @param {Node} tree\n   * @param {Test} test\n   * @param {Visitor} visitor\n   * @param {boolean | null | undefined} [reverse]\n   * @returns {void}\n   */\n  function(n, e, t, r) {\n    typeof e == \"function\" && typeof t != \"function\" && (r = t, t = e, e = null), Qo(n, e, i, r);\n    function i(l, o) {\n      const u = o[o.length - 1];\n      return t(\n        l,\n        u ? u.children.indexOf(l) : null,\n        u\n      );\n    }\n  }\n);\nfunction Go(n) {\n  if (n.allowedElements && n.disallowedElements)\n    throw new TypeError(\n      \"Only one of `allowedElements` and `disallowedElements` should be defined\"\n    );\n  if (n.allowedElements || n.disallowedElements || n.allowElement)\n    return (e) => {\n      Ko(e, \"element\", (t, r, i) => {\n        const l = (\n          /** @type {Element|Root} */\n          i\n        );\n        let o;\n        if (n.allowedElements ? o = !n.allowedElements.includes(t.tagName) : n.disallowedElements && (o = n.disallowedElements.includes(t.tagName)), !o && n.allowElement && typeof r == \"number\" && (o = !n.allowElement(t, r, l)), o && typeof r == \"number\")\n          return n.unwrapDisallowed && t.children ? l.children.splice(r, 1, ...t.children) : l.children.splice(r, 1), r;\n      });\n    };\n}\nvar Se = {}, Zo = {\n  get exports() {\n    return Se;\n  },\n  set exports(n) {\n    Se = n;\n  }\n}, N = {};\n/**\n * @license React\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar kt;\nfunction Jo() {\n  if (kt)\n    return N;\n  kt = 1;\n  var n = Symbol.for(\"react.element\"), e = Symbol.for(\"react.portal\"), t = Symbol.for(\"react.fragment\"), r = Symbol.for(\"react.strict_mode\"), i = Symbol.for(\"react.profiler\"), l = Symbol.for(\"react.provider\"), o = Symbol.for(\"react.context\"), u = Symbol.for(\"react.server_context\"), a = Symbol.for(\"react.forward_ref\"), c = Symbol.for(\"react.suspense\"), s = Symbol.for(\"react.suspense_list\"), h = Symbol.for(\"react.memo\"), g = Symbol.for(\"react.lazy\"), d = Symbol.for(\"react.offscreen\"), m;\n  m = Symbol.for(\"react.module.reference\");\n  function y(x) {\n    if (typeof x == \"object\" && x !== null) {\n      var w = x.$$typeof;\n      switch (w) {\n        case n:\n          switch (x = x.type, x) {\n            case t:\n            case i:\n            case r:\n            case c:\n            case s:\n              return x;\n            default:\n              switch (x = x && x.$$typeof, x) {\n                case u:\n                case o:\n                case a:\n                case g:\n                case h:\n                case l:\n                  return x;\n                default:\n                  return w;\n              }\n          }\n        case e:\n          return w;\n      }\n    }\n  }\n  return N.ContextConsumer = o, N.ContextProvider = l, N.Element = n, N.ForwardRef = a, N.Fragment = t, N.Lazy = g, N.Memo = h, N.Portal = e, N.Profiler = i, N.StrictMode = r, N.Suspense = c, N.SuspenseList = s, N.isAsyncMode = function() {\n    return !1;\n  }, N.isConcurrentMode = function() {\n    return !1;\n  }, N.isContextConsumer = function(x) {\n    return y(x) === o;\n  }, N.isContextProvider = function(x) {\n    return y(x) === l;\n  }, N.isElement = function(x) {\n    return typeof x == \"object\" && x !== null && x.$$typeof === n;\n  }, N.isForwardRef = function(x) {\n    return y(x) === a;\n  }, N.isFragment = function(x) {\n    return y(x) === t;\n  }, N.isLazy = function(x) {\n    return y(x) === g;\n  }, N.isMemo = function(x) {\n    return y(x) === h;\n  }, N.isPortal = function(x) {\n    return y(x) === e;\n  }, N.isProfiler = function(x) {\n    return y(x) === i;\n  }, N.isStrictMode = function(x) {\n    return y(x) === r;\n  }, N.isSuspense = function(x) {\n    return y(x) === c;\n  }, N.isSuspenseList = function(x) {\n    return y(x) === s;\n  }, N.isValidElementType = function(x) {\n    return typeof x == \"string\" || typeof x == \"function\" || x === t || x === i || x === r || x === c || x === s || x === d || typeof x == \"object\" && x !== null && (x.$$typeof === g || x.$$typeof === h || x.$$typeof === l || x.$$typeof === o || x.$$typeof === a || x.$$typeof === m || x.getModuleId !== void 0);\n  }, N.typeOf = y, N;\n}\nvar j = {};\n/**\n * @license React\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar bt;\nfunction nu() {\n  return bt || (bt = 1,  false && 0), j;\n}\n(function(n) {\n   true ? n.exports = Jo() : 0;\n})(Zo);\nconst eu = /* @__PURE__ */ (0,_index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.g)(Se);\nfunction tu(n) {\n  const e = (\n    // @ts-expect-error looks like a node.\n    n && typeof n == \"object\" && n.type === \"text\" ? (\n      // @ts-expect-error looks like a text.\n      n.value || \"\"\n    ) : n\n  );\n  return typeof e == \"string\" && e.replace(/[ \\t\\n\\f\\r]/g, \"\") === \"\";\n}\nfunction ru(n) {\n  return n.join(\" \").trim();\n}\nfunction iu(n, e) {\n  const t = e || {};\n  return (n[n.length - 1] === \"\" ? [...n, \"\"] : n).join(\n    (t.padRight ? \" \" : \"\") + \",\" + (t.padLeft === !1 ? \"\" : \" \")\n  ).trim();\n}\nvar Gn = {}, lu = {\n  get exports() {\n    return Gn;\n  },\n  set exports(n) {\n    Gn = n;\n  }\n}, wt = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g, ou = /\\n/g, uu = /^\\s*/, au = /^(\\*?[-#/*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/, su = /^:\\s*/, cu = /^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^)]*?\\)|[^};])+)/, pu = /^[;\\s]*/, fu = /^\\s+|\\s+$/g, hu = `\n`, St = \"/\", Et = \"*\", Tn = \"\", mu = \"comment\", du = \"declaration\", gu = function(n, e) {\n  if (typeof n != \"string\")\n    throw new TypeError(\"First argument must be a string\");\n  if (!n)\n    return [];\n  e = e || {};\n  var t = 1, r = 1;\n  function i(m) {\n    var y = m.match(ou);\n    y && (t += y.length);\n    var x = m.lastIndexOf(hu);\n    r = ~x ? m.length - x : r + m.length;\n  }\n  function l() {\n    var m = { line: t, column: r };\n    return function(y) {\n      return y.position = new o(m), c(), y;\n    };\n  }\n  function o(m) {\n    this.start = m, this.end = { line: t, column: r }, this.source = e.source;\n  }\n  o.prototype.content = n;\n  function u(m) {\n    var y = new Error(\n      e.source + \":\" + t + \":\" + r + \": \" + m\n    );\n    if (y.reason = m, y.filename = e.source, y.line = t, y.column = r, y.source = n, !e.silent)\n      throw y;\n  }\n  function a(m) {\n    var y = m.exec(n);\n    if (y) {\n      var x = y[0];\n      return i(x), n = n.slice(x.length), y;\n    }\n  }\n  function c() {\n    a(uu);\n  }\n  function s(m) {\n    var y;\n    for (m = m || []; y = h(); )\n      y !== !1 && m.push(y);\n    return m;\n  }\n  function h() {\n    var m = l();\n    if (!(St != n.charAt(0) || Et != n.charAt(1))) {\n      for (var y = 2; Tn != n.charAt(y) && (Et != n.charAt(y) || St != n.charAt(y + 1)); )\n        ++y;\n      if (y += 2, Tn === n.charAt(y - 1))\n        return u(\"End of comment missing\");\n      var x = n.slice(2, y - 2);\n      return r += 2, i(x), n = n.slice(y), r += 2, m({\n        type: mu,\n        comment: x\n      });\n    }\n  }\n  function g() {\n    var m = l(), y = a(au);\n    if (y) {\n      if (h(), !a(su))\n        return u(\"property missing ':'\");\n      var x = a(cu), w = m({\n        type: du,\n        property: Ct(y[0].replace(wt, Tn)),\n        value: x ? Ct(x[0].replace(wt, Tn)) : Tn\n      });\n      return a(pu), w;\n    }\n  }\n  function d() {\n    var m = [];\n    s(m);\n    for (var y; y = g(); )\n      y !== !1 && (m.push(y), s(m));\n    return m;\n  }\n  return c(), d();\n};\nfunction Ct(n) {\n  return n ? n.replace(fu, Tn) : Tn;\n}\nvar yu = gu;\nfunction ur(n, e) {\n  var t = null;\n  if (!n || typeof n != \"string\")\n    return t;\n  for (var r, i = yu(n), l = typeof e == \"function\", o, u, a = 0, c = i.length; a < c; a++)\n    r = i[a], o = r.property, u = r.value, l ? e(o, u, r) : u && (t || (t = {}), t[o] = u);\n  return t;\n}\nlu.exports = ur;\nGn.default = ur;\nconst xu = Gn, Ee = {}.hasOwnProperty, ku = /* @__PURE__ */ new Set([\"table\", \"thead\", \"tbody\", \"tfoot\", \"tr\"]);\nfunction ar(n, e) {\n  const t = [];\n  let r = -1, i;\n  for (; ++r < e.children.length; )\n    i = e.children[r], i.type === \"element\" ? t.push(bu(n, i, r, e)) : i.type === \"text\" ? (e.type !== \"element\" || !ku.has(e.tagName) || !tu(i)) && t.push(i.value) : i.type === \"raw\" && !n.options.skipHtml && t.push(i.value);\n  return t;\n}\nfunction bu(n, e, t, r) {\n  const i = n.options, l = i.transformLinkUri === void 0 ? gr : i.transformLinkUri, o = n.schema, u = e.tagName, a = {};\n  let c = o, s;\n  if (o.space === \"html\" && u === \"svg\" && (c = $o, n.schema = c), e.properties)\n    for (s in e.properties)\n      Ee.call(e.properties, s) && Su(a, s, e.properties[s], n);\n  (u === \"ol\" || u === \"ul\") && n.listDepth++;\n  const h = ar(n, e);\n  (u === \"ol\" || u === \"ul\") && n.listDepth--, n.schema = o;\n  const g = e.position || {\n    start: { line: null, column: null, offset: null },\n    end: { line: null, column: null, offset: null }\n  }, d = i.components && Ee.call(i.components, u) ? i.components[u] : u, m = typeof d == \"string\" || d === react__WEBPACK_IMPORTED_MODULE_0__.Fragment;\n  if (!eu.isValidElementType(d))\n    throw new TypeError(\n      `Component for name \\`${u}\\` not defined or is not renderable`\n    );\n  if (a.key = [\n    u,\n    g.start.line,\n    g.start.column,\n    t\n  ].join(\"-\"), u === \"a\" && i.linkTarget && (a.target = typeof i.linkTarget == \"function\" ? i.linkTarget(\n    String(a.href || \"\"),\n    e.children,\n    typeof a.title == \"string\" ? a.title : null\n  ) : i.linkTarget), u === \"a\" && l && (a.href = l(\n    String(a.href || \"\"),\n    e.children,\n    typeof a.title == \"string\" ? a.title : null\n  )), !m && u === \"code\" && r.type === \"element\" && r.tagName !== \"pre\" && (a.inline = !0), !m && (u === \"h1\" || u === \"h2\" || u === \"h3\" || u === \"h4\" || u === \"h5\" || u === \"h6\") && (a.level = Number.parseInt(u.charAt(1), 10)), u === \"img\" && i.transformImageUri && (a.src = i.transformImageUri(\n    String(a.src || \"\"),\n    String(a.alt || \"\"),\n    typeof a.title == \"string\" ? a.title : null\n  )), !m && u === \"li\" && r.type === \"element\") {\n    const y = wu(e);\n    a.checked = y && y.properties ? !!y.properties.checked : null, a.index = fe(r, e), a.ordered = r.tagName === \"ol\";\n  }\n  return !m && (u === \"ol\" || u === \"ul\") && (a.ordered = u === \"ol\", a.depth = n.listDepth), (u === \"td\" || u === \"th\") && (a.align && (a.style || (a.style = {}), a.style.textAlign = a.align, delete a.align), m || (a.isHeader = u === \"th\")), !m && u === \"tr\" && r.type === \"element\" && (a.isHeader = r.tagName === \"thead\"), i.sourcePos && (a[\"data-sourcepos\"] = Au(g)), !m && i.rawSourcePos && (a.sourcePosition = e.position), !m && i.includeElementIndex && (a.index = fe(r, e), a.siblingCount = fe(r)), m || (a.node = e), h.length > 0 ? react__WEBPACK_IMPORTED_MODULE_0__.createElement(d, a, h) : react__WEBPACK_IMPORTED_MODULE_0__.createElement(d, a);\n}\nfunction wu(n) {\n  let e = -1;\n  for (; ++e < n.children.length; ) {\n    const t = n.children[e];\n    if (t.type === \"element\" && t.tagName === \"input\")\n      return t;\n  }\n  return null;\n}\nfunction fe(n, e) {\n  let t = -1, r = 0;\n  for (; ++t < n.children.length && n.children[t] !== e; )\n    n.children[t].type === \"element\" && r++;\n  return r;\n}\nfunction Su(n, e, t, r) {\n  const i = Mo(r.schema, e);\n  let l = t;\n  l == null || l !== l || (Array.isArray(l) && (l = i.commaSeparated ? iu(l) : ru(l)), i.property === \"style\" && typeof l == \"string\" && (l = Eu(l)), i.space && i.property ? n[Ee.call(yt, i.property) ? yt[i.property] : i.property] = l : i.attribute && (n[i.attribute] = l));\n}\nfunction Eu(n) {\n  const e = {};\n  try {\n    xu(n, t);\n  } catch {\n  }\n  return e;\n  function t(r, i) {\n    const l = r.slice(0, 4) === \"-ms-\" ? `ms-${r.slice(4)}` : r;\n    e[l.replace(/-([a-z])/g, Cu)] = i;\n  }\n}\nfunction Cu(n, e) {\n  return e.toUpperCase();\n}\nfunction Au(n) {\n  return [\n    n.start.line,\n    \":\",\n    n.start.column,\n    \"-\",\n    n.end.line,\n    \":\",\n    n.end.column\n  ].map(String).join(\"\");\n}\nconst At = {}.hasOwnProperty, Pu = \"https://github.com/remarkjs/react-markdown/blob/main/changelog.md\", Wn = {\n  plugins: { to: \"remarkPlugins\", id: \"change-plugins-to-remarkplugins\" },\n  renderers: { to: \"components\", id: \"change-renderers-to-components\" },\n  astPlugins: { id: \"remove-buggy-html-in-markdown-parser\" },\n  allowDangerousHtml: { id: \"remove-buggy-html-in-markdown-parser\" },\n  escapeHtml: { id: \"remove-buggy-html-in-markdown-parser\" },\n  source: { to: \"children\", id: \"change-source-to-children\" },\n  allowNode: {\n    to: \"allowElement\",\n    id: \"replace-allownode-allowedtypes-and-disallowedtypes\"\n  },\n  allowedTypes: {\n    to: \"allowedElements\",\n    id: \"replace-allownode-allowedtypes-and-disallowedtypes\"\n  },\n  disallowedTypes: {\n    to: \"disallowedElements\",\n    id: \"replace-allownode-allowedtypes-and-disallowedtypes\"\n  },\n  includeNodeIndex: {\n    to: \"includeElementIndex\",\n    id: \"change-includenodeindex-to-includeelementindex\"\n  }\n};\nfunction Fu(n) {\n  for (const l in Wn)\n    if (At.call(Wn, l) && At.call(n, l)) {\n      const o = Wn[l];\n      console.warn(\n        `[react-markdown] Warning: please ${o.to ? `use \\`${o.to}\\` instead of` : \"remove\"} \\`${l}\\` (see <${Pu}#${o.id}> for more info)`\n      ), delete Wn[l];\n    }\n  const e = Dr().use(_l).use(n.remarkPlugins || []).use(To, {\n    ...n.remarkRehypeOptions,\n    allowDangerousHtml: !0\n  }).use(n.rehypePlugins || []).use(Go, n), t = new Ft();\n  typeof n.children == \"string\" ? t.value = n.children : n.children !== void 0 && n.children !== null && console.warn(\n    `[react-markdown] Warning: please pass a string as \\`children\\` (not: \\`${n.children}\\`)`\n  );\n  const r = e.runSync(e.parse(t), t);\n  if (r.type !== \"root\")\n    throw new TypeError(\"Expected a `root` node\");\n  let i = react__WEBPACK_IMPORTED_MODULE_0__.createElement(\n    react__WEBPACK_IMPORTED_MODULE_0__.Fragment,\n    {},\n    ar({ options: n, schema: jo, listDepth: 0 }, r)\n  );\n  return n.className && (i = react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: n.className }, i)), i;\n}\nFu.propTypes = {\n  // Core options:\n  children: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.string,\n  // Layout options:\n  className: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.string,\n  // Filter options:\n  allowElement: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.func,\n  allowedElements: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.arrayOf(_index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.string),\n  disallowedElements: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.arrayOf(_index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.string),\n  unwrapDisallowed: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.bool,\n  // Plugin options:\n  remarkPlugins: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.arrayOf(\n    _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.oneOfType([\n      _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.object,\n      _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.func,\n      _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.arrayOf(\n        _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.oneOfType([\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.bool,\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.string,\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.object,\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.func,\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.arrayOf(\n            // prettier-ignore\n            // type-coverage:ignore-next-line\n            _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.any\n          )\n        ])\n      )\n    ])\n  ),\n  rehypePlugins: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.arrayOf(\n    _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.oneOfType([\n      _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.object,\n      _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.func,\n      _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.arrayOf(\n        _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.oneOfType([\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.bool,\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.string,\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.object,\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.func,\n          _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.arrayOf(\n            // prettier-ignore\n            // type-coverage:ignore-next-line\n            _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.any\n          )\n        ])\n      )\n    ])\n  ),\n  // Transform options:\n  sourcePos: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.bool,\n  rawSourcePos: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.bool,\n  skipHtml: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.bool,\n  includeElementIndex: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.bool,\n  transformLinkUri: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.oneOfType([_index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.func, _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.bool]),\n  linkTarget: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.oneOfType([_index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.func, _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.string]),\n  transformImageUri: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.func,\n  components: _index_a2491bf3_js__WEBPACK_IMPORTED_MODULE_1__.p.object\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQjtBQUN6QixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLGFBQWEsOENBQThDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtGQUFrRjtBQUNoSDtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRztBQUNaLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQSxnR0FBZ0csS0FBSztBQUNyRztBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBOEQ7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBSztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQix5QkFBeUI7QUFDekIsR0FBRztBQUNIO0FBQ0EsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6QixHQUFHO0FBQ0g7QUFDQSwyQkFBMkI7QUFDM0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBSztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLHlCQUF5QjtBQUN6QjtBQUNBLDJKQUEySjtBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBSztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtBQUNBO0FBQ0EsNkJBQTZCLDRCQUE0QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0JBQStCO0FBQy9CO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQztBQUNBO0FBQ0EsdUVBQXVFLDZDQUE2QztBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQkFBZ0I7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssVUFBVSwyQkFBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsZ0JBQWdCO0FBQ2hCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBLGdCQUFnQjtBQUNoQixDQUFDO0FBQ0Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsU0FBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE1BQU07QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CLGFBQWEsTUFBTTtBQUNuQixhQUFhLGVBQWU7QUFDNUIsYUFBYSw0QkFBNEI7QUFDekMsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsaUNBQWlDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQixhQUFhLE1BQU07QUFDbkIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsNEJBQTRCO0FBQ3pDLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBcUMsSUFBSSxDQXNGNUQ7QUFDTDtBQUNBO0FBQ0EsRUFBRSxLQUFxQyxzQkFBc0IsQ0FBZ0I7QUFDN0UsQ0FBQztBQUNELDJCQUEyQixxREFBRTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0xBQXNMLGdCQUFnQjtBQUN2TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsb0JBQW9CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtRUFBbUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRixPQUFPO0FBQ3ZGLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0NBQXdDO0FBQ3JELFdBQVc7QUFDWCxHQUFHLHdHQUF3RywyQ0FBVztBQUN0SDtBQUNBO0FBQ0EsOEJBQThCLEVBQUU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpS0FBaUssMFhBQTBYLGdEQUFnQixZQUFZLGdEQUFnQjtBQUN2a0I7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5QkFBeUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0RBQWdEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsV0FBVztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWEsNERBQTREO0FBQ3pFLGVBQWUsd0RBQXdEO0FBQ3ZFLGdCQUFnQiw0Q0FBNEM7QUFDNUQsd0JBQXdCLDRDQUE0QztBQUNwRSxnQkFBZ0IsNENBQTRDO0FBQzVELFlBQVksaURBQWlEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQixLQUFLLDJCQUEyQixJQUFJLEVBQUUsV0FBVyxHQUFHLEdBQUcsS0FBSztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsOEVBQThFLFdBQVc7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdEQUFnQjtBQUMxQixJQUFJLDJDQUFXO0FBQ2YsTUFBTTtBQUNOLFNBQVMsc0NBQXNDO0FBQy9DO0FBQ0EsNkJBQTZCLGdEQUFnQixVQUFVLHdCQUF3QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUFRO0FBQ3BCO0FBQ0EsYUFBYSx3REFBUTtBQUNyQjtBQUNBLGdCQUFnQixzREFBTTtBQUN0QixtQkFBbUIseURBQVMsQ0FBQyx3REFBUTtBQUNyQyxzQkFBc0IseURBQVMsQ0FBQyx3REFBUTtBQUN4QyxvQkFBb0Isc0RBQU07QUFDMUI7QUFDQSxpQkFBaUIseURBQVM7QUFDMUIsSUFBSSwyREFBVztBQUNmLE1BQU0sd0RBQVE7QUFDZCxNQUFNLHNEQUFNO0FBQ1osTUFBTSx5REFBUztBQUNmLFFBQVEsMkRBQVc7QUFDbkIsVUFBVSxzREFBTTtBQUNoQixVQUFVLHdEQUFRO0FBQ2xCLFVBQVUsd0RBQVE7QUFDbEIsVUFBVSxzREFBTTtBQUNoQixVQUFVLHlEQUFTO0FBQ25CO0FBQ0E7QUFDQSxZQUFZLHFEQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseURBQVM7QUFDMUIsSUFBSSwyREFBVztBQUNmLE1BQU0sd0RBQVE7QUFDZCxNQUFNLHNEQUFNO0FBQ1osTUFBTSx5REFBUztBQUNmLFFBQVEsMkRBQVc7QUFDbkIsVUFBVSxzREFBTTtBQUNoQixVQUFVLHdEQUFRO0FBQ2xCLFVBQVUsd0RBQVE7QUFDbEIsVUFBVSxzREFBTTtBQUNoQixVQUFVLHlEQUFTO0FBQ25CO0FBQ0E7QUFDQSxZQUFZLHFEQUFLO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsc0RBQU07QUFDbkIsZ0JBQWdCLHNEQUFNO0FBQ3RCLFlBQVksc0RBQU07QUFDbEIsdUJBQXVCLHNEQUFNO0FBQzdCLG9CQUFvQiwyREFBVyxFQUFFLHNEQUFNLEVBQUUsc0RBQU07QUFDL0MsY0FBYywyREFBVyxFQUFFLHNEQUFNLEVBQUUsd0RBQVE7QUFDM0MscUJBQXFCLHNEQUFNO0FBQzNCLGNBQWMsd0RBQVE7QUFDdEI7QUFJRSIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvZW5oYW5jZWRvY3Mtc2VhcmNoL2Rpc3QvaW5kZXgtNWY0Y2VkYjIuanM/ZmM2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgT24gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBnIGFzIGRyLCBwIGFzIEQgfSBmcm9tIFwiLi9pbmRleC1hMjQ5MWJmMy5qc1wiO1xuY29uc3QgemUgPSBbXCJodHRwXCIsIFwiaHR0cHNcIiwgXCJtYWlsdG9cIiwgXCJ0ZWxcIl07XG5mdW5jdGlvbiBncihuKSB7XG4gIGNvbnN0IGUgPSAobiB8fCBcIlwiKS50cmltKCksIHQgPSBlLmNoYXJBdCgwKTtcbiAgaWYgKHQgPT09IFwiI1wiIHx8IHQgPT09IFwiL1wiKVxuICAgIHJldHVybiBlO1xuICBjb25zdCByID0gZS5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKHIgPT09IC0xKVxuICAgIHJldHVybiBlO1xuICBsZXQgaSA9IC0xO1xuICBmb3IgKDsgKytpIDwgemUubGVuZ3RoOyApIHtcbiAgICBjb25zdCBsID0gemVbaV07XG4gICAgaWYgKHIgPT09IGwubGVuZ3RoICYmIGUuc2xpY2UoMCwgbC5sZW5ndGgpLnRvTG93ZXJDYXNlKCkgPT09IGwpXG4gICAgICByZXR1cm4gZTtcbiAgfVxuICByZXR1cm4gaSA9IGUuaW5kZXhPZihcIj9cIiksIGkgIT09IC0xICYmIHIgPiBpIHx8IChpID0gZS5pbmRleE9mKFwiI1wiKSwgaSAhPT0gLTEgJiYgciA+IGkpID8gZSA6IFwiamF2YXNjcmlwdDp2b2lkKDApXCI7XG59XG4vKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG52YXIgeXIgPSBmdW5jdGlvbihlKSB7XG4gIHJldHVybiBlICE9IG51bGwgJiYgZS5jb25zdHJ1Y3RvciAhPSBudWxsICYmIHR5cGVvZiBlLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09IFwiZnVuY3Rpb25cIiAmJiBlLmNvbnN0cnVjdG9yLmlzQnVmZmVyKGUpO1xufTtcbmNvbnN0IFB0ID0geXI7XG5mdW5jdGlvbiB4cihuKSB7XG4gIHJldHVybiAhbiB8fCB0eXBlb2YgbiAhPSBcIm9iamVjdFwiID8gXCJcIiA6IFwicG9zaXRpb25cIiBpbiBuIHx8IFwidHlwZVwiIGluIG4gPyBSZShuLnBvc2l0aW9uKSA6IFwic3RhcnRcIiBpbiBuIHx8IFwiZW5kXCIgaW4gbiA/IFJlKG4pIDogXCJsaW5lXCIgaW4gbiB8fCBcImNvbHVtblwiIGluIG4gPyBoZShuKSA6IFwiXCI7XG59XG5mdW5jdGlvbiBoZShuKSB7XG4gIHJldHVybiBfZShuICYmIG4ubGluZSkgKyBcIjpcIiArIF9lKG4gJiYgbi5jb2x1bW4pO1xufVxuZnVuY3Rpb24gUmUobikge1xuICByZXR1cm4gaGUobiAmJiBuLnN0YXJ0KSArIFwiLVwiICsgaGUobiAmJiBuLmVuZCk7XG59XG5mdW5jdGlvbiBfZShuKSB7XG4gIHJldHVybiBuICYmIHR5cGVvZiBuID09IFwibnVtYmVyXCIgPyBuIDogMTtcbn1cbmNsYXNzIGNuIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlIGEgbWVzc2FnZSBmb3IgYHJlYXNvbmAgYXQgYHBsYWNlYCBmcm9tIGBvcmlnaW5gLlxuICAgKlxuICAgKiBXaGVuIGFuIGVycm9yIGlzIHBhc3NlZCBpbiBhcyBgcmVhc29uYCwgdGhlIGBzdGFja2AgaXMgY29waWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IEVycm9yIHwgVkZpbGVNZXNzYWdlfSByZWFzb25cbiAgICogICBSZWFzb24gZm9yIG1lc3NhZ2UsIHVzZXMgdGhlIHN0YWNrIGFuZCBtZXNzYWdlIG9mIHRoZSBlcnJvciBpZiBnaXZlbi5cbiAgICpcbiAgICogICA+IPCfkYkgKipOb3RlKio6IHlvdSBzaG91bGQgdXNlIG1hcmtkb3duLlxuICAgKiBAcGFyYW0ge05vZGUgfCBOb2RlTGlrZSB8IFBvc2l0aW9uIHwgUG9pbnQgfCBudWxsIHwgdW5kZWZpbmVkfSBbcGxhY2VdXG4gICAqICAgUGxhY2UgaW4gZmlsZSB3aGVyZSB0aGUgbWVzc2FnZSBvY2N1cnJlZC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXVxuICAgKiAgIFBsYWNlIGluIGNvZGUgd2hlcmUgdGhlIG1lc3NhZ2Ugb3JpZ2luYXRlcyAoZXhhbXBsZTpcbiAgICogICBgJ215LXBhY2thZ2U6bXktcnVsZSdgIG9yIGAnbXktcnVsZSdgKS5cbiAgICogQHJldHVybnNcbiAgICogICBJbnN0YW5jZSBvZiBgVkZpbGVNZXNzYWdlYC5cbiAgICovXG4gIC8vIFRvIGRvOiBuZXh0IG1ham9yOiBleHBvc2UgYHVuZGVmaW5lZGAgZXZlcnl3aGVyZSBpbnN0ZWFkIG9mIGBudWxsYC5cbiAgY29uc3RydWN0b3IoZSwgdCwgcikge1xuICAgIGNvbnN0IGkgPSBbbnVsbCwgbnVsbF07XG4gICAgbGV0IGwgPSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiB3ZSBhbHdheXMgZm9sbG93cyB0aGUgc3RydWN0dXJlIG9mIGBwb3NpdGlvbmAuXG4gICAgICBzdGFydDogeyBsaW5lOiBudWxsLCBjb2x1bW46IG51bGwgfSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IFwiXG4gICAgICBlbmQ6IHsgbGluZTogbnVsbCwgY29sdW1uOiBudWxsIH1cbiAgICB9O1xuICAgIGlmIChzdXBlcigpLCB0eXBlb2YgdCA9PSBcInN0cmluZ1wiICYmIChyID0gdCwgdCA9IHZvaWQgMCksIHR5cGVvZiByID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IG8gPSByLmluZGV4T2YoXCI6XCIpO1xuICAgICAgbyA9PT0gLTEgPyBpWzFdID0gciA6IChpWzBdID0gci5zbGljZSgwLCBvKSwgaVsxXSA9IHIuc2xpY2UobyArIDEpKTtcbiAgICB9XG4gICAgdCAmJiAoXCJ0eXBlXCIgaW4gdCB8fCBcInBvc2l0aW9uXCIgaW4gdCA/IHQucG9zaXRpb24gJiYgKGwgPSB0LnBvc2l0aW9uKSA6IFwic3RhcnRcIiBpbiB0IHx8IFwiZW5kXCIgaW4gdCA/IGwgPSB0IDogKFwibGluZVwiIGluIHQgfHwgXCJjb2x1bW5cIiBpbiB0KSAmJiAobC5zdGFydCA9IHQpKSwgdGhpcy5uYW1lID0geHIodCkgfHwgXCIxOjFcIiwgdGhpcy5tZXNzYWdlID0gdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUubWVzc2FnZSA6IGUsIHRoaXMuc3RhY2sgPSBcIlwiLCB0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUuc3RhY2sgJiYgKHRoaXMuc3RhY2sgPSBlLnN0YWNrKSwgdGhpcy5yZWFzb24gPSB0aGlzLm1lc3NhZ2UsIHRoaXMuZmF0YWwsIHRoaXMubGluZSA9IGwuc3RhcnQubGluZSwgdGhpcy5jb2x1bW4gPSBsLnN0YXJ0LmNvbHVtbiwgdGhpcy5wb3NpdGlvbiA9IGwsIHRoaXMuc291cmNlID0gaVswXSwgdGhpcy5ydWxlSWQgPSBpWzFdLCB0aGlzLmZpbGUsIHRoaXMuYWN0dWFsLCB0aGlzLmV4cGVjdGVkLCB0aGlzLnVybCwgdGhpcy5ub3RlO1xuICB9XG59XG5jbi5wcm90b3R5cGUuZmlsZSA9IFwiXCI7XG5jbi5wcm90b3R5cGUubmFtZSA9IFwiXCI7XG5jbi5wcm90b3R5cGUucmVhc29uID0gXCJcIjtcbmNuLnByb3RvdHlwZS5tZXNzYWdlID0gXCJcIjtcbmNuLnByb3RvdHlwZS5zdGFjayA9IFwiXCI7XG5jbi5wcm90b3R5cGUuZmF0YWwgPSBudWxsO1xuY24ucHJvdG90eXBlLmNvbHVtbiA9IG51bGw7XG5jbi5wcm90b3R5cGUubGluZSA9IG51bGw7XG5jbi5wcm90b3R5cGUuc291cmNlID0gbnVsbDtcbmNuLnByb3RvdHlwZS5ydWxlSWQgPSBudWxsO1xuY24ucHJvdG90eXBlLnBvc2l0aW9uID0gbnVsbDtcbmNvbnN0IG1uID0geyBiYXNlbmFtZToga3IsIGRpcm5hbWU6IGJyLCBleHRuYW1lOiB3ciwgam9pbjogU3IsIHNlcDogXCIvXCIgfTtcbmZ1bmN0aW9uIGtyKG4sIGUpIHtcbiAgaWYgKGUgIT09IHZvaWQgMCAmJiB0eXBlb2YgZSAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXh0XCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO1xuICBIbihuKTtcbiAgbGV0IHQgPSAwLCByID0gLTEsIGkgPSBuLmxlbmd0aCwgbDtcbiAgaWYgKGUgPT09IHZvaWQgMCB8fCBlLmxlbmd0aCA9PT0gMCB8fCBlLmxlbmd0aCA+IG4ubGVuZ3RoKSB7XG4gICAgZm9yICg7IGktLTsgKVxuICAgICAgaWYgKG4uY2hhckNvZGVBdChpKSA9PT0gNDcpIHtcbiAgICAgICAgaWYgKGwpIHtcbiAgICAgICAgICB0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICByIDwgMCAmJiAobCA9ICEwLCByID0gaSArIDEpO1xuICAgIHJldHVybiByIDwgMCA/IFwiXCIgOiBuLnNsaWNlKHQsIHIpO1xuICB9XG4gIGlmIChlID09PSBuKVxuICAgIHJldHVybiBcIlwiO1xuICBsZXQgbyA9IC0xLCB1ID0gZS5sZW5ndGggLSAxO1xuICBmb3IgKDsgaS0tOyApXG4gICAgaWYgKG4uY2hhckNvZGVBdChpKSA9PT0gNDcpIHtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIHQgPSBpICsgMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlXG4gICAgICBvIDwgMCAmJiAobCA9ICEwLCBvID0gaSArIDEpLCB1ID4gLTEgJiYgKG4uY2hhckNvZGVBdChpKSA9PT0gZS5jaGFyQ29kZUF0KHUtLSkgPyB1IDwgMCAmJiAociA9IGkpIDogKHUgPSAtMSwgciA9IG8pKTtcbiAgcmV0dXJuIHQgPT09IHIgPyByID0gbyA6IHIgPCAwICYmIChyID0gbi5sZW5ndGgpLCBuLnNsaWNlKHQsIHIpO1xufVxuZnVuY3Rpb24gYnIobikge1xuICBpZiAoSG4obiksIG4ubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBcIi5cIjtcbiAgbGV0IGUgPSAtMSwgdCA9IG4ubGVuZ3RoLCByO1xuICBmb3IgKDsgLS10OyApXG4gICAgaWYgKG4uY2hhckNvZGVBdCh0KSA9PT0gNDcpIHtcbiAgICAgIGlmIChyKSB7XG4gICAgICAgIGUgPSB0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIHIgfHwgKHIgPSAhMCk7XG4gIHJldHVybiBlIDwgMCA/IG4uY2hhckNvZGVBdCgwKSA9PT0gNDcgPyBcIi9cIiA6IFwiLlwiIDogZSA9PT0gMSAmJiBuLmNoYXJDb2RlQXQoMCkgPT09IDQ3ID8gXCIvL1wiIDogbi5zbGljZSgwLCBlKTtcbn1cbmZ1bmN0aW9uIHdyKG4pIHtcbiAgSG4obik7XG4gIGxldCBlID0gbi5sZW5ndGgsIHQgPSAtMSwgciA9IDAsIGkgPSAtMSwgbCA9IDAsIG87XG4gIGZvciAoOyBlLS07ICkge1xuICAgIGNvbnN0IHUgPSBuLmNoYXJDb2RlQXQoZSk7XG4gICAgaWYgKHUgPT09IDQ3KSB7XG4gICAgICBpZiAobykge1xuICAgICAgICByID0gZSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHQgPCAwICYmIChvID0gITAsIHQgPSBlICsgMSksIHUgPT09IDQ2ID8gaSA8IDAgPyBpID0gZSA6IGwgIT09IDEgJiYgKGwgPSAxKSA6IGkgPiAtMSAmJiAobCA9IC0xKTtcbiAgfVxuICByZXR1cm4gaSA8IDAgfHwgdCA8IDAgfHwgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3QuXG4gIGwgPT09IDAgfHwgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgYC4uYC5cbiAgbCA9PT0gMSAmJiBpID09PSB0IC0gMSAmJiBpID09PSByICsgMSA/IFwiXCIgOiBuLnNsaWNlKGksIHQpO1xufVxuZnVuY3Rpb24gU3IoLi4ubikge1xuICBsZXQgZSA9IC0xLCB0O1xuICBmb3IgKDsgKytlIDwgbi5sZW5ndGg7IClcbiAgICBIbihuW2VdKSwgbltlXSAmJiAodCA9IHQgPT09IHZvaWQgMCA/IG5bZV0gOiB0ICsgXCIvXCIgKyBuW2VdKTtcbiAgcmV0dXJuIHQgPT09IHZvaWQgMCA/IFwiLlwiIDogRXIodCk7XG59XG5mdW5jdGlvbiBFcihuKSB7XG4gIEhuKG4pO1xuICBjb25zdCBlID0gbi5jaGFyQ29kZUF0KDApID09PSA0NztcbiAgbGV0IHQgPSBDcihuLCAhZSk7XG4gIHJldHVybiB0Lmxlbmd0aCA9PT0gMCAmJiAhZSAmJiAodCA9IFwiLlwiKSwgdC5sZW5ndGggPiAwICYmIG4uY2hhckNvZGVBdChuLmxlbmd0aCAtIDEpID09PSA0NyAmJiAodCArPSBcIi9cIiksIGUgPyBcIi9cIiArIHQgOiB0O1xufVxuZnVuY3Rpb24gQ3IobiwgZSkge1xuICBsZXQgdCA9IFwiXCIsIHIgPSAwLCBpID0gLTEsIGwgPSAwLCBvID0gLTEsIHUsIGE7XG4gIGZvciAoOyArK28gPD0gbi5sZW5ndGg7ICkge1xuICAgIGlmIChvIDwgbi5sZW5ndGgpXG4gICAgICB1ID0gbi5jaGFyQ29kZUF0KG8pO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKHUgPT09IDQ3KVxuICAgICAgICBicmVhaztcbiAgICAgIHUgPSA0NztcbiAgICB9XG4gICAgaWYgKHUgPT09IDQ3KSB7XG4gICAgICBpZiAoIShpID09PSBvIC0gMSB8fCBsID09PSAxKSlcbiAgICAgICAgaWYgKGkgIT09IG8gLSAxICYmIGwgPT09IDIpIHtcbiAgICAgICAgICBpZiAodC5sZW5ndGggPCAyIHx8IHIgIT09IDIgfHwgdC5jaGFyQ29kZUF0KHQubGVuZ3RoIC0gMSkgIT09IDQ2IHx8IHQuY2hhckNvZGVBdCh0Lmxlbmd0aCAtIDIpICE9PSA0Nikge1xuICAgICAgICAgICAgaWYgKHQubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgICBpZiAoYSA9IHQubGFzdEluZGV4T2YoXCIvXCIpLCBhICE9PSB0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBhIDwgMCA/ICh0ID0gXCJcIiwgciA9IDApIDogKHQgPSB0LnNsaWNlKDAsIGEpLCByID0gdC5sZW5ndGggLSAxIC0gdC5sYXN0SW5kZXhPZihcIi9cIikpLCBpID0gbywgbCA9IDA7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHQgPSBcIlwiLCByID0gMCwgaSA9IG8sIGwgPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZSAmJiAodCA9IHQubGVuZ3RoID4gMCA/IHQgKyBcIi8uLlwiIDogXCIuLlwiLCByID0gMik7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHQubGVuZ3RoID4gMCA/IHQgKz0gXCIvXCIgKyBuLnNsaWNlKGkgKyAxLCBvKSA6IHQgPSBuLnNsaWNlKGkgKyAxLCBvKSwgciA9IG8gLSBpIC0gMTtcbiAgICAgIGkgPSBvLCBsID0gMDtcbiAgICB9IGVsc2VcbiAgICAgIHUgPT09IDQ2ICYmIGwgPiAtMSA/IGwrKyA6IGwgPSAtMTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIEhuKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiUGF0aCBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCBcIiArIEpTT04uc3RyaW5naWZ5KG4pXG4gICAgKTtcbn1cbmNvbnN0IEFyID0geyBjd2Q6IFByIH07XG5mdW5jdGlvbiBQcigpIHtcbiAgcmV0dXJuIFwiL1wiO1xufVxuZnVuY3Rpb24gbWUobikge1xuICByZXR1cm4gbiAhPT0gbnVsbCAmJiB0eXBlb2YgbiA9PSBcIm9iamVjdFwiICYmIC8vIEB0cy1leHBlY3QtZXJyb3I6IGluZGV4YWJsZS5cbiAgbi5ocmVmICYmIC8vIEB0cy1leHBlY3QtZXJyb3I6IGluZGV4YWJsZS5cbiAgbi5vcmlnaW47XG59XG5mdW5jdGlvbiBGcihuKSB7XG4gIGlmICh0eXBlb2YgbiA9PSBcInN0cmluZ1wiKVxuICAgIG4gPSBuZXcgVVJMKG4pO1xuICBlbHNlIGlmICghbWUobikpIHtcbiAgICBjb25zdCBlID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJwYXRoXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZyBvciBhbiBpbnN0YW5jZSBvZiBVUkwuIFJlY2VpdmVkIGAnICsgbiArIFwiYFwiXG4gICAgKTtcbiAgICB0aHJvdyBlLmNvZGUgPSBcIkVSUl9JTlZBTElEX0FSR19UWVBFXCIsIGU7XG4gIH1cbiAgaWYgKG4ucHJvdG9jb2wgIT09IFwiZmlsZTpcIikge1xuICAgIGNvbnN0IGUgPSBuZXcgVHlwZUVycm9yKFwiVGhlIFVSTCBtdXN0IGJlIG9mIHNjaGVtZSBmaWxlXCIpO1xuICAgIHRocm93IGUuY29kZSA9IFwiRVJSX0lOVkFMSURfVVJMX1NDSEVNRVwiLCBlO1xuICB9XG4gIHJldHVybiBUcihuKTtcbn1cbmZ1bmN0aW9uIFRyKG4pIHtcbiAgaWYgKG4uaG9zdG5hbWUgIT09IFwiXCIpIHtcbiAgICBjb25zdCByID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICdGaWxlIFVSTCBob3N0IG11c3QgYmUgXCJsb2NhbGhvc3RcIiBvciBlbXB0eSBvbiBkYXJ3aW4nXG4gICAgKTtcbiAgICB0aHJvdyByLmNvZGUgPSBcIkVSUl9JTlZBTElEX0ZJTEVfVVJMX0hPU1RcIiwgcjtcbiAgfVxuICBjb25zdCBlID0gbi5wYXRobmFtZTtcbiAgbGV0IHQgPSAtMTtcbiAgZm9yICg7ICsrdCA8IGUubGVuZ3RoOyApXG4gICAgaWYgKGUuY2hhckNvZGVBdCh0KSA9PT0gMzcgJiYgZS5jaGFyQ29kZUF0KHQgKyAxKSA9PT0gNTApIHtcbiAgICAgIGNvbnN0IHIgPSBlLmNoYXJDb2RlQXQodCArIDIpO1xuICAgICAgaWYgKHIgPT09IDcwIHx8IHIgPT09IDEwMikge1xuICAgICAgICBjb25zdCBpID0gbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIkZpbGUgVVJMIHBhdGggbXVzdCBub3QgaW5jbHVkZSBlbmNvZGVkIC8gY2hhcmFjdGVyc1wiXG4gICAgICAgICk7XG4gICAgICAgIHRocm93IGkuY29kZSA9IFwiRVJSX0lOVkFMSURfRklMRV9VUkxfUEFUSFwiLCBpO1xuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlKTtcbn1cbmNvbnN0IHJlID0gW1wiaGlzdG9yeVwiLCBcInBhdGhcIiwgXCJiYXNlbmFtZVwiLCBcInN0ZW1cIiwgXCJleHRuYW1lXCIsIFwiZGlybmFtZVwiXTtcbmNsYXNzIEZ0IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyB2aXJ0dWFsIGZpbGUuXG4gICAqXG4gICAqIGBvcHRpb25zYCBpcyB0cmVhdGVkIGFzOlxuICAgKlxuICAgKiAqICAgYHN0cmluZ2Agb3IgYEJ1ZmZlcmAg4oCUIGB7dmFsdWU6IG9wdGlvbnN9YFxuICAgKiAqICAgYFVSTGAg4oCUIGB7cGF0aDogb3B0aW9uc31gXG4gICAqICogICBgVkZpbGVgIOKAlCBzaGFsbG93IGNvcGllcyBpdHMgZGF0YSBvdmVyIHRvIHRoZSBuZXcgZmlsZVxuICAgKiAqICAgYG9iamVjdGAg4oCUIGFsbCBmaWVsZHMgYXJlIHNoYWxsb3cgY29waWVkIG92ZXIgdG8gdGhlIG5ldyBmaWxlXG4gICAqXG4gICAqIFBhdGggcmVsYXRlZCBmaWVsZHMgYXJlIHNldCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyIChsZWFzdCBzcGVjaWZpYyB0b1xuICAgKiBtb3N0IHNwZWNpZmljKTogYGhpc3RvcnlgLCBgcGF0aGAsIGBiYXNlbmFtZWAsIGBzdGVtYCwgYGV4dG5hbWVgLFxuICAgKiBgZGlybmFtZWAuXG4gICAqXG4gICAqIFlvdSBjYW5ub3Qgc2V0IGBkaXJuYW1lYCBvciBgZXh0bmFtZWAgd2l0aG91dCBzZXR0aW5nIGVpdGhlciBgaGlzdG9yeWAsXG4gICAqIGBwYXRoYCwgYGJhc2VuYW1lYCwgb3IgYHN0ZW1gIHRvby5cbiAgICpcbiAgICogQHBhcmFtIHtDb21wYXRpYmxlIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3ZhbHVlXVxuICAgKiAgIEZpbGUgdmFsdWUuXG4gICAqIEByZXR1cm5zXG4gICAqICAgTmV3IGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGxldCB0O1xuICAgIGUgPyB0eXBlb2YgZSA9PSBcInN0cmluZ1wiIHx8IElyKGUpID8gdCA9IHsgdmFsdWU6IGUgfSA6IG1lKGUpID8gdCA9IHsgcGF0aDogZSB9IDogdCA9IGUgOiB0ID0ge30sIHRoaXMuZGF0YSA9IHt9LCB0aGlzLm1lc3NhZ2VzID0gW10sIHRoaXMuaGlzdG9yeSA9IFtdLCB0aGlzLmN3ZCA9IEFyLmN3ZCgpLCB0aGlzLnZhbHVlLCB0aGlzLnN0b3JlZCwgdGhpcy5yZXN1bHQsIHRoaXMubWFwO1xuICAgIGxldCByID0gLTE7XG4gICAgZm9yICg7ICsrciA8IHJlLmxlbmd0aDsgKSB7XG4gICAgICBjb25zdCBsID0gcmVbcl07XG4gICAgICBsIGluIHQgJiYgdFtsXSAhPT0gdm9pZCAwICYmIHRbbF0gIT09IG51bGwgJiYgKHRoaXNbbF0gPSBsID09PSBcImhpc3RvcnlcIiA/IFsuLi50W2xdXSA6IHRbbF0pO1xuICAgIH1cbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgaW4gdClcbiAgICAgIHJlLmluY2x1ZGVzKGkpIHx8ICh0aGlzW2ldID0gdFtpXSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZnVsbCBwYXRoIChleGFtcGxlOiBgJ34vaW5kZXgubWluLmpzJ2ApLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0IHBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlzdG9yeVt0aGlzLmhpc3RvcnkubGVuZ3RoIC0gMV07XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgZnVsbCBwYXRoIChleGFtcGxlOiBgJ34vaW5kZXgubWluLmpzJ2ApLlxuICAgKlxuICAgKiBDYW5ub3QgYmUgbnVsbGlmaWVkLlxuICAgKiBZb3UgY2FuIHNldCBhIGZpbGUgVVJMIChhIGBVUkxgIG9iamVjdCB3aXRoIGEgYGZpbGU6YCBwcm90b2NvbCkgd2hpY2ggd2lsbFxuICAgKiBiZSB0dXJuZWQgaW50byBhIHBhdGggd2l0aCBgdXJsLmZpbGVVUkxUb1BhdGhgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IFVSTH0gcGF0aFxuICAgKi9cbiAgc2V0IHBhdGgoZSkge1xuICAgIG1lKGUpICYmIChlID0gRnIoZSkpLCBsZShlLCBcInBhdGhcIiksIHRoaXMucGF0aCAhPT0gZSAmJiB0aGlzLmhpc3RvcnkucHVzaChlKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBwYXJlbnQgcGF0aCAoZXhhbXBsZTogYCd+J2ApLlxuICAgKi9cbiAgZ2V0IGRpcm5hbWUoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLnBhdGggPT0gXCJzdHJpbmdcIiA/IG1uLmRpcm5hbWUodGhpcy5wYXRoKSA6IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBwYXJlbnQgcGF0aCAoZXhhbXBsZTogYCd+J2ApLlxuICAgKlxuICAgKiBDYW5ub3QgYmUgc2V0IGlmIHRoZXJl4oCZcyBubyBgcGF0aGAgeWV0LlxuICAgKi9cbiAgc2V0IGRpcm5hbWUoZSkge1xuICAgIE1lKHRoaXMuYmFzZW5hbWUsIFwiZGlybmFtZVwiKSwgdGhpcy5wYXRoID0gbW4uam9pbihlIHx8IFwiXCIsIHRoaXMuYmFzZW5hbWUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGJhc2VuYW1lIChpbmNsdWRpbmcgZXh0bmFtZSkgKGV4YW1wbGU6IGAnaW5kZXgubWluLmpzJ2ApLlxuICAgKi9cbiAgZ2V0IGJhc2VuYW1lKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5wYXRoID09IFwic3RyaW5nXCIgPyBtbi5iYXNlbmFtZSh0aGlzLnBhdGgpIDogdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYmFzZW5hbWUgKGluY2x1ZGluZyBleHRuYW1lKSAoYCdpbmRleC5taW4uanMnYCkuXG4gICAqXG4gICAqIENhbm5vdCBjb250YWluIHBhdGggc2VwYXJhdG9ycyAoYCcvJ2Agb24gdW5peCwgbWFjT1MsIGFuZCBicm93c2VycywgYCdcXCdgXG4gICAqIG9uIHdpbmRvd3MpLlxuICAgKiBDYW5ub3QgYmUgbnVsbGlmaWVkICh1c2UgYGZpbGUucGF0aCA9IGZpbGUuZGlybmFtZWAgaW5zdGVhZCkuXG4gICAqL1xuICBzZXQgYmFzZW5hbWUoZSkge1xuICAgIGxlKGUsIFwiYmFzZW5hbWVcIiksIGllKGUsIFwiYmFzZW5hbWVcIiksIHRoaXMucGF0aCA9IG1uLmpvaW4odGhpcy5kaXJuYW1lIHx8IFwiXCIsIGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGV4dG5hbWUgKGluY2x1ZGluZyBkb3QpIChleGFtcGxlOiBgJy5qcydgKS5cbiAgICovXG4gIGdldCBleHRuYW1lKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5wYXRoID09IFwic3RyaW5nXCIgPyBtbi5leHRuYW1lKHRoaXMucGF0aCkgOiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICAqIFNldCB0aGUgZXh0bmFtZSAoaW5jbHVkaW5nIGRvdCkgKGV4YW1wbGU6IGAnLmpzJ2ApLlxuICAgKlxuICAgKiBDYW5ub3QgY29udGFpbiBwYXRoIHNlcGFyYXRvcnMgKGAnLydgIG9uIHVuaXgsIG1hY09TLCBhbmQgYnJvd3NlcnMsIGAnXFwnYFxuICAgKiBvbiB3aW5kb3dzKS5cbiAgICogQ2Fubm90IGJlIHNldCBpZiB0aGVyZeKAmXMgbm8gYHBhdGhgIHlldC5cbiAgICovXG4gIHNldCBleHRuYW1lKGUpIHtcbiAgICBpZiAoaWUoZSwgXCJleHRuYW1lXCIpLCBNZSh0aGlzLmRpcm5hbWUsIFwiZXh0bmFtZVwiKSwgZSkge1xuICAgICAgaWYgKGUuY2hhckNvZGVBdCgwKSAhPT0gNDYpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBleHRuYW1lYCBtdXN0IHN0YXJ0IHdpdGggYC5gXCIpO1xuICAgICAgaWYgKGUuaW5jbHVkZXMoXCIuXCIsIDEpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZXh0bmFtZWAgY2Fubm90IGNvbnRhaW4gbXVsdGlwbGUgZG90c1wiKTtcbiAgICB9XG4gICAgdGhpcy5wYXRoID0gbW4uam9pbih0aGlzLmRpcm5hbWUsIHRoaXMuc3RlbSArIChlIHx8IFwiXCIpKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdGVtIChiYXNlbmFtZSB3L28gZXh0bmFtZSkgKGV4YW1wbGU6IGAnaW5kZXgubWluJ2ApLlxuICAgKi9cbiAgZ2V0IHN0ZW0oKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLnBhdGggPT0gXCJzdHJpbmdcIiA/IG1uLmJhc2VuYW1lKHRoaXMucGF0aCwgdGhpcy5leHRuYW1lKSA6IHZvaWQgMDtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBzdGVtIChiYXNlbmFtZSB3L28gZXh0bmFtZSkgKGV4YW1wbGU6IGAnaW5kZXgubWluJ2ApLlxuICAgKlxuICAgKiBDYW5ub3QgY29udGFpbiBwYXRoIHNlcGFyYXRvcnMgKGAnLydgIG9uIHVuaXgsIG1hY09TLCBhbmQgYnJvd3NlcnMsIGAnXFwnYFxuICAgKiBvbiB3aW5kb3dzKS5cbiAgICogQ2Fubm90IGJlIG51bGxpZmllZCAodXNlIGBmaWxlLnBhdGggPSBmaWxlLmRpcm5hbWVgIGluc3RlYWQpLlxuICAgKi9cbiAgc2V0IHN0ZW0oZSkge1xuICAgIGxlKGUsIFwic3RlbVwiKSwgaWUoZSwgXCJzdGVtXCIpLCB0aGlzLnBhdGggPSBtbi5qb2luKHRoaXMuZGlybmFtZSB8fCBcIlwiLCBlICsgKHRoaXMuZXh0bmFtZSB8fCBcIlwiKSk7XG4gIH1cbiAgLyoqXG4gICAqIFNlcmlhbGl6ZSB0aGUgZmlsZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJFbmNvZGluZyB8IG51bGwgfCB1bmRlZmluZWR9IFtlbmNvZGluZz0ndXRmOCddXG4gICAqICAgQ2hhcmFjdGVyIGVuY29kaW5nIHRvIHVuZGVyc3RhbmQgYHZhbHVlYCBhcyB3aGVuIGl04oCZcyBhIGBCdWZmZXJgXG4gICAqICAgKGRlZmF1bHQ6IGAndXRmOCdgKS5cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICogICBTZXJpYWxpemVkIGZpbGUuXG4gICAqL1xuICB0b1N0cmluZyhlKSB7XG4gICAgcmV0dXJuICh0aGlzLnZhbHVlIHx8IFwiXCIpLnRvU3RyaW5nKGUgfHwgdm9pZCAwKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgd2FybmluZyBtZXNzYWdlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmlsZS5cbiAgICpcbiAgICogSXRzIGBmYXRhbGAgaXMgc2V0IHRvIGBmYWxzZWAgYW5kIGBmaWxlYCBpcyBzZXQgdG8gdGhlIGN1cnJlbnQgZmlsZSBwYXRoLlxuICAgKiBJdHMgYWRkZWQgdG8gYGZpbGUubWVzc2FnZXNgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IEVycm9yIHwgVkZpbGVNZXNzYWdlfSByZWFzb25cbiAgICogICBSZWFzb24gZm9yIG1lc3NhZ2UsIHVzZXMgdGhlIHN0YWNrIGFuZCBtZXNzYWdlIG9mIHRoZSBlcnJvciBpZiBnaXZlbi5cbiAgICogQHBhcmFtIHtOb2RlIHwgTm9kZUxpa2UgfCBQb3NpdGlvbiB8IFBvaW50IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3BsYWNlXVxuICAgKiAgIFBsYWNlIGluIGZpbGUgd2hlcmUgdGhlIG1lc3NhZ2Ugb2NjdXJyZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gW29yaWdpbl1cbiAgICogICBQbGFjZSBpbiBjb2RlIHdoZXJlIHRoZSBtZXNzYWdlIG9yaWdpbmF0ZXMgKGV4YW1wbGU6XG4gICAqICAgYCdteS1wYWNrYWdlOm15LXJ1bGUnYCBvciBgJ215LXJ1bGUnYCkuXG4gICAqIEByZXR1cm5zIHtWRmlsZU1lc3NhZ2V9XG4gICAqICAgTWVzc2FnZS5cbiAgICovXG4gIG1lc3NhZ2UoZSwgdCwgcikge1xuICAgIGNvbnN0IGkgPSBuZXcgY24oZSwgdCwgcik7XG4gICAgcmV0dXJuIHRoaXMucGF0aCAmJiAoaS5uYW1lID0gdGhpcy5wYXRoICsgXCI6XCIgKyBpLm5hbWUsIGkuZmlsZSA9IHRoaXMucGF0aCksIGkuZmF0YWwgPSAhMSwgdGhpcy5tZXNzYWdlcy5wdXNoKGkpLCBpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5mbyBtZXNzYWdlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmlsZS5cbiAgICpcbiAgICogSXRzIGBmYXRhbGAgaXMgc2V0IHRvIGBudWxsYCBhbmQgYGZpbGVgIGlzIHNldCB0byB0aGUgY3VycmVudCBmaWxlIHBhdGguXG4gICAqIEl0cyBhZGRlZCB0byBgZmlsZS5tZXNzYWdlc2AuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgRXJyb3IgfCBWRmlsZU1lc3NhZ2V9IHJlYXNvblxuICAgKiAgIFJlYXNvbiBmb3IgbWVzc2FnZSwgdXNlcyB0aGUgc3RhY2sgYW5kIG1lc3NhZ2Ugb2YgdGhlIGVycm9yIGlmIGdpdmVuLlxuICAgKiBAcGFyYW0ge05vZGUgfCBOb2RlTGlrZSB8IFBvc2l0aW9uIHwgUG9pbnQgfCBudWxsIHwgdW5kZWZpbmVkfSBbcGxhY2VdXG4gICAqICAgUGxhY2UgaW4gZmlsZSB3aGVyZSB0aGUgbWVzc2FnZSBvY2N1cnJlZC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXVxuICAgKiAgIFBsYWNlIGluIGNvZGUgd2hlcmUgdGhlIG1lc3NhZ2Ugb3JpZ2luYXRlcyAoZXhhbXBsZTpcbiAgICogICBgJ215LXBhY2thZ2U6bXktcnVsZSdgIG9yIGAnbXktcnVsZSdgKS5cbiAgICogQHJldHVybnMge1ZGaWxlTWVzc2FnZX1cbiAgICogICBNZXNzYWdlLlxuICAgKi9cbiAgaW5mbyhlLCB0LCByKSB7XG4gICAgY29uc3QgaSA9IHRoaXMubWVzc2FnZShlLCB0LCByKTtcbiAgICByZXR1cm4gaS5mYXRhbCA9IG51bGwsIGk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGZhdGFsIGVycm9yIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmlsZS5cbiAgICpcbiAgICogSXRzIGBmYXRhbGAgaXMgc2V0IHRvIGB0cnVlYCBhbmQgYGZpbGVgIGlzIHNldCB0byB0aGUgY3VycmVudCBmaWxlIHBhdGguXG4gICAqIEl0cyBhZGRlZCB0byBgZmlsZS5tZXNzYWdlc2AuXG4gICAqXG4gICAqID4g8J+RiSAqKk5vdGUqKjogYSBmYXRhbCBlcnJvciBtZWFucyB0aGF0IGEgZmlsZSBpcyBubyBsb25nZXIgcHJvY2Vzc2FibGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgRXJyb3IgfCBWRmlsZU1lc3NhZ2V9IHJlYXNvblxuICAgKiAgIFJlYXNvbiBmb3IgbWVzc2FnZSwgdXNlcyB0aGUgc3RhY2sgYW5kIG1lc3NhZ2Ugb2YgdGhlIGVycm9yIGlmIGdpdmVuLlxuICAgKiBAcGFyYW0ge05vZGUgfCBOb2RlTGlrZSB8IFBvc2l0aW9uIHwgUG9pbnQgfCBudWxsIHwgdW5kZWZpbmVkfSBbcGxhY2VdXG4gICAqICAgUGxhY2UgaW4gZmlsZSB3aGVyZSB0aGUgbWVzc2FnZSBvY2N1cnJlZC5cbiAgICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3JpZ2luXVxuICAgKiAgIFBsYWNlIGluIGNvZGUgd2hlcmUgdGhlIG1lc3NhZ2Ugb3JpZ2luYXRlcyAoZXhhbXBsZTpcbiAgICogICBgJ215LXBhY2thZ2U6bXktcnVsZSdgIG9yIGAnbXktcnVsZSdgKS5cbiAgICogQHJldHVybnMge25ldmVyfVxuICAgKiAgIE1lc3NhZ2UuXG4gICAqIEB0aHJvd3Mge1ZGaWxlTWVzc2FnZX1cbiAgICogICBNZXNzYWdlLlxuICAgKi9cbiAgZmFpbChlLCB0LCByKSB7XG4gICAgY29uc3QgaSA9IHRoaXMubWVzc2FnZShlLCB0LCByKTtcbiAgICB0aHJvdyBpLmZhdGFsID0gITAsIGk7XG4gIH1cbn1cbmZ1bmN0aW9uIGllKG4sIGUpIHtcbiAgaWYgKG4gJiYgbi5pbmNsdWRlcyhtbi5zZXApKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiYFwiICsgZSArIFwiYCBjYW5ub3QgYmUgYSBwYXRoOiBkaWQgbm90IGV4cGVjdCBgXCIgKyBtbi5zZXAgKyBcImBcIlxuICAgICk7XG59XG5mdW5jdGlvbiBsZShuLCBlKSB7XG4gIGlmICghbilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgXCIgKyBlICsgXCJgIGNhbm5vdCBiZSBlbXB0eVwiKTtcbn1cbmZ1bmN0aW9uIE1lKG4sIGUpIHtcbiAgaWYgKCFuKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlNldHRpbmcgYFwiICsgZSArIFwiYCByZXF1aXJlcyBgcGF0aGAgdG8gYmUgc2V0IHRvb1wiKTtcbn1cbmZ1bmN0aW9uIElyKG4pIHtcbiAgcmV0dXJuIFB0KG4pO1xufVxuZnVuY3Rpb24gQmUobikge1xuICBpZiAobilcbiAgICB0aHJvdyBuO1xufVxudmFyIFluID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgVHQgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLCBOZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgamUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCAkZSA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBBcnJheS5pc0FycmF5ID09IFwiZnVuY3Rpb25cIiA/IEFycmF5LmlzQXJyYXkoZSkgOiBUdC5jYWxsKGUpID09PSBcIltvYmplY3QgQXJyYXldXCI7XG59LCBIZSA9IGZ1bmN0aW9uKGUpIHtcbiAgaWYgKCFlIHx8IFR0LmNhbGwoZSkgIT09IFwiW29iamVjdCBPYmplY3RdXCIpXG4gICAgcmV0dXJuICExO1xuICB2YXIgdCA9IFluLmNhbGwoZSwgXCJjb25zdHJ1Y3RvclwiKSwgciA9IGUuY29uc3RydWN0b3IgJiYgZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgJiYgWW4uY2FsbChlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgXCJpc1Byb3RvdHlwZU9mXCIpO1xuICBpZiAoZS5jb25zdHJ1Y3RvciAmJiAhdCAmJiAhcilcbiAgICByZXR1cm4gITE7XG4gIHZhciBpO1xuICBmb3IgKGkgaW4gZSlcbiAgICA7XG4gIHJldHVybiB0eXBlb2YgaSA+IFwidVwiIHx8IFluLmNhbGwoZSwgaSk7XG59LCBVZSA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgTmUgJiYgdC5uYW1lID09PSBcIl9fcHJvdG9fX1wiID8gTmUoZSwgdC5uYW1lLCB7XG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICB2YWx1ZTogdC5uZXdWYWx1ZSxcbiAgICB3cml0YWJsZTogITBcbiAgfSkgOiBlW3QubmFtZV0gPSB0Lm5ld1ZhbHVlO1xufSwgVmUgPSBmdW5jdGlvbihlLCB0KSB7XG4gIGlmICh0ID09PSBcIl9fcHJvdG9fX1wiKVxuICAgIGlmIChZbi5jYWxsKGUsIHQpKSB7XG4gICAgICBpZiAoamUpXG4gICAgICAgIHJldHVybiBqZShlLCB0KS52YWx1ZTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybjtcbiAgcmV0dXJuIGVbdF07XG59LCBxZSA9IGZ1bmN0aW9uIG4oKSB7XG4gIHZhciBlLCB0LCByLCBpLCBsLCBvLCB1ID0gYXJndW1lbnRzWzBdLCBhID0gMSwgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHMgPSAhMTtcbiAgZm9yICh0eXBlb2YgdSA9PSBcImJvb2xlYW5cIiAmJiAocyA9IHUsIHUgPSBhcmd1bWVudHNbMV0gfHwge30sIGEgPSAyKSwgKHUgPT0gbnVsbCB8fCB0eXBlb2YgdSAhPSBcIm9iamVjdFwiICYmIHR5cGVvZiB1ICE9IFwiZnVuY3Rpb25cIikgJiYgKHUgPSB7fSk7IGEgPCBjOyArK2EpXG4gICAgaWYgKGUgPSBhcmd1bWVudHNbYV0sIGUgIT0gbnVsbClcbiAgICAgIGZvciAodCBpbiBlKVxuICAgICAgICByID0gVmUodSwgdCksIGkgPSBWZShlLCB0KSwgdSAhPT0gaSAmJiAocyAmJiBpICYmIChIZShpKSB8fCAobCA9ICRlKGkpKSkgPyAobCA/IChsID0gITEsIG8gPSByICYmICRlKHIpID8gciA6IFtdKSA6IG8gPSByICYmIEhlKHIpID8gciA6IHt9LCBVZSh1LCB7IG5hbWU6IHQsIG5ld1ZhbHVlOiBuKHMsIG8sIGkpIH0pKSA6IHR5cGVvZiBpIDwgXCJ1XCIgJiYgVWUodSwgeyBuYW1lOiB0LCBuZXdWYWx1ZTogaSB9KSk7XG4gIHJldHVybiB1O1xufTtcbmZ1bmN0aW9uIGRlKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9IFwib2JqZWN0XCIgfHwgbiA9PT0gbnVsbClcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobik7XG4gIHJldHVybiAoZSA9PT0gbnVsbCB8fCBlID09PSBPYmplY3QucHJvdG90eXBlIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gbikgJiYgIShTeW1ib2wuaXRlcmF0b3IgaW4gbik7XG59XG5mdW5jdGlvbiBPcigpIHtcbiAgY29uc3QgbiA9IFtdLCBlID0geyBydW46IHQsIHVzZTogciB9O1xuICByZXR1cm4gZTtcbiAgZnVuY3Rpb24gdCguLi5pKSB7XG4gICAgbGV0IGwgPSAtMTtcbiAgICBjb25zdCBvID0gaS5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG8gIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGZ1bmN0aW9uIGFzIGxhc3QgYXJndW1lbnQsIG5vdCBcIiArIG8pO1xuICAgIHUobnVsbCwgLi4uaSk7XG4gICAgZnVuY3Rpb24gdShhLCAuLi5jKSB7XG4gICAgICBjb25zdCBzID0gblsrK2xdO1xuICAgICAgbGV0IGggPSAtMTtcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIG8oYSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoOyArK2ggPCBpLmxlbmd0aDsgKVxuICAgICAgICAoY1toXSA9PT0gbnVsbCB8fCBjW2hdID09PSB2b2lkIDApICYmIChjW2hdID0gaVtoXSk7XG4gICAgICBpID0gYywgcyA/IExyKHMsIHUpKC4uLmMpIDogbyhudWxsLCAuLi5jKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcihpKSB7XG4gICAgaWYgKHR5cGVvZiBpICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiRXhwZWN0ZWQgYG1pZGRlbHdhcmVgIHRvIGJlIGEgZnVuY3Rpb24sIG5vdCBcIiArIGlcbiAgICAgICk7XG4gICAgcmV0dXJuIG4ucHVzaChpKSwgZTtcbiAgfVxufVxuZnVuY3Rpb24gTHIobiwgZSkge1xuICBsZXQgdDtcbiAgcmV0dXJuIHI7XG4gIGZ1bmN0aW9uIHIoLi4ubykge1xuICAgIGNvbnN0IHUgPSBuLmxlbmd0aCA+IG8ubGVuZ3RoO1xuICAgIGxldCBhO1xuICAgIHUgJiYgby5wdXNoKGkpO1xuICAgIHRyeSB7XG4gICAgICBhID0gbi5hcHBseSh0aGlzLCBvKTtcbiAgICB9IGNhdGNoIChjKSB7XG4gICAgICBjb25zdCBzID0gKFxuICAgICAgICAvKiogQHR5cGUge0Vycm9yfSAqL1xuICAgICAgICBjXG4gICAgICApO1xuICAgICAgaWYgKHUgJiYgdClcbiAgICAgICAgdGhyb3cgcztcbiAgICAgIHJldHVybiBpKHMpO1xuICAgIH1cbiAgICB1IHx8IChhIGluc3RhbmNlb2YgUHJvbWlzZSA/IGEudGhlbihsLCBpKSA6IGEgaW5zdGFuY2VvZiBFcnJvciA/IGkoYSkgOiBsKGEpKTtcbiAgfVxuICBmdW5jdGlvbiBpKG8sIC4uLnUpIHtcbiAgICB0IHx8ICh0ID0gITAsIGUobywgLi4udSkpO1xuICB9XG4gIGZ1bmN0aW9uIGwobykge1xuICAgIGkobnVsbCwgbyk7XG4gIH1cbn1cbmNvbnN0IERyID0gT3QoKS5mcmVlemUoKSwgSXQgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIE90KCkge1xuICBjb25zdCBuID0gT3IoKSwgZSA9IFtdO1xuICBsZXQgdCA9IHt9LCByLCBpID0gLTE7XG4gIHJldHVybiBsLmRhdGEgPSBvLCBsLlBhcnNlciA9IHZvaWQgMCwgbC5Db21waWxlciA9IHZvaWQgMCwgbC5mcmVlemUgPSB1LCBsLmF0dGFjaGVycyA9IGUsIGwudXNlID0gYSwgbC5wYXJzZSA9IGMsIGwuc3RyaW5naWZ5ID0gcywgbC5ydW4gPSBoLCBsLnJ1blN5bmMgPSBnLCBsLnByb2Nlc3MgPSBkLCBsLnByb2Nlc3NTeW5jID0gbSwgbDtcbiAgZnVuY3Rpb24gbCgpIHtcbiAgICBjb25zdCB5ID0gT3QoKTtcbiAgICBsZXQgeCA9IC0xO1xuICAgIGZvciAoOyArK3ggPCBlLmxlbmd0aDsgKVxuICAgICAgeS51c2UoLi4uZVt4XSk7XG4gICAgcmV0dXJuIHkuZGF0YShxZSghMCwge30sIHQpKSwgeTtcbiAgfVxuICBmdW5jdGlvbiBvKHksIHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHkgPT0gXCJzdHJpbmdcIiA/IGFyZ3VtZW50cy5sZW5ndGggPT09IDIgPyAoYWUoXCJkYXRhXCIsIHIpLCB0W3ldID0geCwgbCkgOiBJdC5jYWxsKHQsIHkpICYmIHRbeV0gfHwgbnVsbCA6IHkgPyAoYWUoXCJkYXRhXCIsIHIpLCB0ID0geSwgbCkgOiB0O1xuICB9XG4gIGZ1bmN0aW9uIHUoKSB7XG4gICAgaWYgKHIpXG4gICAgICByZXR1cm4gbDtcbiAgICBmb3IgKDsgKytpIDwgZS5sZW5ndGg7ICkge1xuICAgICAgY29uc3QgW3ksIC4uLnhdID0gZVtpXTtcbiAgICAgIGlmICh4WzBdID09PSAhMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB4WzBdID09PSAhMCAmJiAoeFswXSA9IHZvaWQgMCk7XG4gICAgICBjb25zdCB3ID0geS5jYWxsKGwsIC4uLngpO1xuICAgICAgdHlwZW9mIHcgPT0gXCJmdW5jdGlvblwiICYmIG4udXNlKHcpO1xuICAgIH1cbiAgICByZXR1cm4gciA9ICEwLCBpID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBsO1xuICB9XG4gIGZ1bmN0aW9uIGEoeSwgLi4ueCkge1xuICAgIGxldCB3O1xuICAgIGlmIChhZShcInVzZVwiLCByKSwgeSAhPSBudWxsKVxuICAgICAgaWYgKHR5cGVvZiB5ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgVCh5LCAuLi54KTtcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiB5ID09IFwib2JqZWN0XCIpXG4gICAgICAgIEFycmF5LmlzQXJyYXkoeSkgPyBfKHkpIDogQSh5KTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHVzYWJsZSB2YWx1ZSwgbm90IGBcIiArIHkgKyBcImBcIik7XG4gICAgcmV0dXJuIHcgJiYgKHQuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHQuc2V0dGluZ3MgfHwge30sIHcpKSwgbDtcbiAgICBmdW5jdGlvbiB2KGIpIHtcbiAgICAgIGlmICh0eXBlb2YgYiA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIFQoYik7XG4gICAgICBlbHNlIGlmICh0eXBlb2YgYiA9PSBcIm9iamVjdFwiKVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICAgIGNvbnN0IFtJLCAuLi5SXSA9IGI7XG4gICAgICAgICAgVChJLCAuLi5SKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgQShiKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIHVzYWJsZSB2YWx1ZSwgbm90IGBcIiArIGIgKyBcImBcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEEoYikge1xuICAgICAgXyhiLnBsdWdpbnMpLCBiLnNldHRpbmdzICYmICh3ID0gT2JqZWN0LmFzc2lnbih3IHx8IHt9LCBiLnNldHRpbmdzKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF8oYikge1xuICAgICAgbGV0IEkgPSAtMTtcbiAgICAgIGlmIChiICE9IG51bGwpXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGIpKVxuICAgICAgICAgIGZvciAoOyArK0kgPCBiLmxlbmd0aDsgKSB7XG4gICAgICAgICAgICBjb25zdCBSID0gYltJXTtcbiAgICAgICAgICAgIHYoUik7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbGlzdCBvZiBwbHVnaW5zLCBub3QgYFwiICsgYiArIFwiYFwiKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVChiLCBJKSB7XG4gICAgICBsZXQgUiA9IC0xLCBNO1xuICAgICAgZm9yICg7ICsrUiA8IGUubGVuZ3RoOyApXG4gICAgICAgIGlmIChlW1JdWzBdID09PSBiKSB7XG4gICAgICAgICAgTSA9IGVbUl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIE0gPyAoZGUoTVsxXSkgJiYgZGUoSSkgJiYgKEkgPSBxZSghMCwgTVsxXSwgSSkpLCBNWzFdID0gSSkgOiBlLnB1c2goWy4uLmFyZ3VtZW50c10pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjKHkpIHtcbiAgICBsLmZyZWV6ZSgpO1xuICAgIGNvbnN0IHggPSBqbih5KSwgdyA9IGwuUGFyc2VyO1xuICAgIHJldHVybiBvZShcInBhcnNlXCIsIHcpLCBXZSh3LCBcInBhcnNlXCIpID8gbmV3IHcoU3RyaW5nKHgpLCB4KS5wYXJzZSgpIDogdyhTdHJpbmcoeCksIHgpO1xuICB9XG4gIGZ1bmN0aW9uIHMoeSwgeCkge1xuICAgIGwuZnJlZXplKCk7XG4gICAgY29uc3QgdyA9IGpuKHgpLCB2ID0gbC5Db21waWxlcjtcbiAgICByZXR1cm4gdWUoXCJzdHJpbmdpZnlcIiwgdiksIFllKHkpLCBXZSh2LCBcImNvbXBpbGVcIikgPyBuZXcgdih5LCB3KS5jb21waWxlKCkgOiB2KHksIHcpO1xuICB9XG4gIGZ1bmN0aW9uIGgoeSwgeCwgdykge1xuICAgIGlmIChZZSh5KSwgbC5mcmVlemUoKSwgIXcgJiYgdHlwZW9mIHggPT0gXCJmdW5jdGlvblwiICYmICh3ID0geCwgeCA9IHZvaWQgMCksICF3KVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHYpO1xuICAgIHYobnVsbCwgdyk7XG4gICAgZnVuY3Rpb24gdihBLCBfKSB7XG4gICAgICBuLnJ1bih5LCBqbih4KSwgVCk7XG4gICAgICBmdW5jdGlvbiBUKGIsIEksIFIpIHtcbiAgICAgICAgSSA9IEkgfHwgeSwgYiA/IF8oYikgOiBBID8gQShJKSA6IHcobnVsbCwgSSwgUik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGcoeSwgeCkge1xuICAgIGxldCB3LCB2O1xuICAgIHJldHVybiBsLnJ1bih5LCB4LCBBKSwgUWUoXCJydW5TeW5jXCIsIFwicnVuXCIsIHYpLCB3O1xuICAgIGZ1bmN0aW9uIEEoXywgVCkge1xuICAgICAgQmUoXyksIHcgPSBULCB2ID0gITA7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQoeSwgeCkge1xuICAgIGlmIChsLmZyZWV6ZSgpLCBvZShcInByb2Nlc3NcIiwgbC5QYXJzZXIpLCB1ZShcInByb2Nlc3NcIiwgbC5Db21waWxlciksICF4KVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHcpO1xuICAgIHcobnVsbCwgeCk7XG4gICAgZnVuY3Rpb24gdyh2LCBBKSB7XG4gICAgICBjb25zdCBfID0gam4oeSk7XG4gICAgICBsLnJ1bihsLnBhcnNlKF8pLCBfLCAoYiwgSSwgUikgPT4ge1xuICAgICAgICBpZiAoYiB8fCAhSSB8fCAhUilcbiAgICAgICAgICBUKGIpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBNID0gbC5zdHJpbmdpZnkoSSwgUik7XG4gICAgICAgICAgTSA9PSBudWxsIHx8IChScihNKSA/IFIudmFsdWUgPSBNIDogUi5yZXN1bHQgPSBNKSwgVChiLCBSKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBmdW5jdGlvbiBUKGIsIEkpIHtcbiAgICAgICAgYiB8fCAhSSA/IEEoYikgOiB2ID8gdihJKSA6IHgobnVsbCwgSSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG0oeSkge1xuICAgIGxldCB4O1xuICAgIGwuZnJlZXplKCksIG9lKFwicHJvY2Vzc1N5bmNcIiwgbC5QYXJzZXIpLCB1ZShcInByb2Nlc3NTeW5jXCIsIGwuQ29tcGlsZXIpO1xuICAgIGNvbnN0IHcgPSBqbih5KTtcbiAgICByZXR1cm4gbC5wcm9jZXNzKHcsIHYpLCBRZShcInByb2Nlc3NTeW5jXCIsIFwicHJvY2Vzc1wiLCB4KSwgdztcbiAgICBmdW5jdGlvbiB2KEEpIHtcbiAgICAgIHggPSAhMCwgQmUoQSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBXZShuLCBlKSB7XG4gIHJldHVybiB0eXBlb2YgbiA9PSBcImZ1bmN0aW9uXCIgJiYgLy8gUHJvdG90eXBlcyBkbyBleGlzdC5cbiAgLy8gdHlwZS1jb3ZlcmFnZTppZ25vcmUtbmV4dC1saW5lXG4gIG4ucHJvdG90eXBlICYmIC8vIEEgZnVuY3Rpb24gd2l0aCBrZXlzIGluIGl0cyBwcm90b3R5cGUgaXMgcHJvYmFibHkgYSBjb25zdHJ1Y3Rvci5cbiAgLy8gQ2xhc3Nlc+KAmSBwcm90b3R5cGUgbWV0aG9kcyBhcmUgbm90IGVudW1lcmFibGUsIHNvIHdlIGNoZWNrIGlmIHNvbWUgdmFsdWVcbiAgLy8gZXhpc3RzIGluIHRoZSBwcm90b3R5cGUuXG4gIC8vIHR5cGUtY292ZXJhZ2U6aWdub3JlLW5leHQtbGluZVxuICAodnIobi5wcm90b3R5cGUpIHx8IGUgaW4gbi5wcm90b3R5cGUpO1xufVxuZnVuY3Rpb24gdnIobikge1xuICBsZXQgZTtcbiAgZm9yIChlIGluIG4pXG4gICAgaWYgKEl0LmNhbGwobiwgZSkpXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIG9lKG4sIGUpIHtcbiAgaWYgKHR5cGVvZiBlICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGBcIiArIG4gKyBcImAgd2l0aG91dCBgUGFyc2VyYFwiKTtcbn1cbmZ1bmN0aW9uIHVlKG4sIGUpIHtcbiAgaWYgKHR5cGVvZiBlICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGBcIiArIG4gKyBcImAgd2l0aG91dCBgQ29tcGlsZXJgXCIpO1xufVxuZnVuY3Rpb24gYWUobiwgZSkge1xuICBpZiAoZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkNhbm5vdCBjYWxsIGBcIiArIG4gKyBcImAgb24gYSBmcm96ZW4gcHJvY2Vzc29yLlxcbkNyZWF0ZSBhIG5ldyBwcm9jZXNzb3IgZmlyc3QsIGJ5IGNhbGxpbmcgaXQ6IHVzZSBgcHJvY2Vzc29yKClgIGluc3RlYWQgb2YgYHByb2Nlc3NvcmAuXCJcbiAgICApO1xufVxuZnVuY3Rpb24gWWUobikge1xuICBpZiAoIWRlKG4pIHx8IHR5cGVvZiBuLnR5cGUgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgbm9kZSwgZ290IGBcIiArIG4gKyBcImBcIik7XG59XG5mdW5jdGlvbiBRZShuLCBlLCB0KSB7XG4gIGlmICghdClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcImBcIiArIG4gKyBcImAgZmluaXNoZWQgYXN5bmMuIFVzZSBgXCIgKyBlICsgXCJgIGluc3RlYWRcIlxuICAgICk7XG59XG5mdW5jdGlvbiBqbihuKSB7XG4gIHJldHVybiB6cihuKSA/IG4gOiBuZXcgRnQobik7XG59XG5mdW5jdGlvbiB6cihuKSB7XG4gIHJldHVybiAhIShuICYmIHR5cGVvZiBuID09IFwib2JqZWN0XCIgJiYgXCJtZXNzYWdlXCIgaW4gbiAmJiBcIm1lc3NhZ2VzXCIgaW4gbik7XG59XG5mdW5jdGlvbiBScihuKSB7XG4gIHJldHVybiB0eXBlb2YgbiA9PSBcInN0cmluZ1wiIHx8IFB0KG4pO1xufVxuZnVuY3Rpb24gX3IobiwgZSkge1xuICBjb25zdCB0ID0gKGUgfHwge30pLmluY2x1ZGVJbWFnZUFsdDtcbiAgcmV0dXJuIEx0KFxuICAgIG4sXG4gICAgdHlwZW9mIHQgPT0gXCJib29sZWFuXCIgPyB0IDogITBcbiAgKTtcbn1cbmZ1bmN0aW9uIEx0KG4sIGUpIHtcbiAgcmV0dXJuIE1yKG4pICYmIChcInZhbHVlXCIgaW4gbiAmJiBuLnZhbHVlIHx8IGUgJiYgXCJhbHRcIiBpbiBuICYmIG4uYWx0IHx8IFwiY2hpbGRyZW5cIiBpbiBuICYmIFhlKG4uY2hpbGRyZW4sIGUpKSB8fCBBcnJheS5pc0FycmF5KG4pICYmIFhlKG4sIGUpIHx8IFwiXCI7XG59XG5mdW5jdGlvbiBYZShuLCBlKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgbGV0IHIgPSAtMTtcbiAgZm9yICg7ICsrciA8IG4ubGVuZ3RoOyApXG4gICAgdFtyXSA9IEx0KG5bcl0sIGUpO1xuICByZXR1cm4gdC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gTXIobikge1xuICByZXR1cm4gISEobiAmJiB0eXBlb2YgbiA9PSBcIm9iamVjdFwiKTtcbn1cbmZ1bmN0aW9uIGduKG4sIGUsIHQsIHIpIHtcbiAgY29uc3QgaSA9IG4ubGVuZ3RoO1xuICBsZXQgbCA9IDAsIG87XG4gIGlmIChlIDwgMCA/IGUgPSAtZSA+IGkgPyAwIDogaSArIGUgOiBlID0gZSA+IGkgPyBpIDogZSwgdCA9IHQgPiAwID8gdCA6IDAsIHIubGVuZ3RoIDwgMWU0KVxuICAgIG8gPSBBcnJheS5mcm9tKHIpLCBvLnVuc2hpZnQoZSwgdCksIFtdLnNwbGljZS5hcHBseShuLCBvKTtcbiAgZWxzZVxuICAgIGZvciAodCAmJiBbXS5zcGxpY2UuYXBwbHkobiwgW2UsIHRdKTsgbCA8IHIubGVuZ3RoOyApXG4gICAgICBvID0gci5zbGljZShsLCBsICsgMWU0KSwgby51bnNoaWZ0KGUsIDApLCBbXS5zcGxpY2UuYXBwbHkobiwgbyksIGwgKz0gMWU0LCBlICs9IDFlNDtcbn1cbmZ1bmN0aW9uIGFuKG4sIGUpIHtcbiAgcmV0dXJuIG4ubGVuZ3RoID4gMCA/IChnbihuLCBuLmxlbmd0aCwgMCwgZSksIG4pIDogZTtcbn1cbmNvbnN0IEtlID0ge30uaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBCcihuKSB7XG4gIGNvbnN0IGUgPSB7fTtcbiAgbGV0IHQgPSAtMTtcbiAgZm9yICg7ICsrdCA8IG4ubGVuZ3RoOyApXG4gICAgTnIoZSwgblt0XSk7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gTnIobiwgZSkge1xuICBsZXQgdDtcbiAgZm9yICh0IGluIGUpIHtcbiAgICBjb25zdCBpID0gKEtlLmNhbGwobiwgdCkgPyBuW3RdIDogdm9pZCAwKSB8fCAoblt0XSA9IHt9KSwgbCA9IGVbdF07XG4gICAgbGV0IG87XG4gICAgZm9yIChvIGluIGwpIHtcbiAgICAgIEtlLmNhbGwoaSwgbykgfHwgKGlbb10gPSBbXSk7XG4gICAgICBjb25zdCB1ID0gbFtvXTtcbiAgICAgIGpyKFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIExvb2tzIGxpa2UgYSBsaXN0LlxuICAgICAgICBpW29dLFxuICAgICAgICBBcnJheS5pc0FycmF5KHUpID8gdSA6IHUgPyBbdV0gOiBbXVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGpyKG4sIGUpIHtcbiAgbGV0IHQgPSAtMTtcbiAgY29uc3QgciA9IFtdO1xuICBmb3IgKDsgKyt0IDwgZS5sZW5ndGg7IClcbiAgICAoZVt0XS5hZGQgPT09IFwiYWZ0ZXJcIiA/IG4gOiByKS5wdXNoKGVbdF0pO1xuICBnbihuLCAwLCAwLCByKTtcbn1cbmNvbnN0ICRyID0gL1shLS86LUBbLWB7LX5cXHUwMEExXFx1MDBBN1xcdTAwQUJcXHUwMEI2XFx1MDBCN1xcdTAwQkJcXHUwMEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTA5RkRcXHUwQTc2XFx1MEFGMFxcdTBDNzdcXHUwQzg0XFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzA4LVxcdTIzMEJcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFNEZcXHUyRTUyXFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE4RkNcXHVBOTJFXFx1QTkyRlxcdUE5NUZcXHVBOUMxLVxcdUE5Q0RcXHVBOURFXFx1QTlERlxcdUFBNUMtXFx1QUE1RlxcdUFBREVcXHVBQURGXFx1QUFGMFxcdUFBRjFcXHVBQkVCXFx1RkQzRVxcdUZEM0ZcXHVGRTEwLVxcdUZFMTlcXHVGRTMwLVxcdUZFNTJcXHVGRTU0LVxcdUZFNjFcXHVGRTYzXFx1RkU2OFxcdUZFNkFcXHVGRTZCXFx1RkYwMS1cXHVGRjAzXFx1RkYwNS1cXHVGRjBBXFx1RkYwQy1cXHVGRjBGXFx1RkYxQVxcdUZGMUJcXHVGRjFGXFx1RkYyMFxcdUZGM0ItXFx1RkYzRFxcdUZGM0ZcXHVGRjVCXFx1RkY1RFxcdUZGNUYtXFx1RkY2NV0vLCBkbiA9IEFuKC9bQS1aYS16XS8pLCBnZSA9IEFuKC9cXGQvKSwgSHIgPSBBbigvW1xcZEEtRmEtZl0vKSwgb24gPSBBbigvW1xcZEEtWmEtel0vKSwgVXIgPSBBbigvWyEtLzotQFstYHstfl0vKSwgR2UgPSBBbigvWyMtJyorXFwtLTk9P0EtWl4tfl0vKTtcbmZ1bmN0aW9uIHllKG4pIHtcbiAgcmV0dXJuIChcbiAgICAvLyBTcGVjaWFsIHdoaXRlc3BhY2UgY29kZXMgKHdoaWNoIGhhdmUgbmVnYXRpdmUgdmFsdWVzKSwgQzAgYW5kIENvbnRyb2xcbiAgICAvLyBjaGFyYWN0ZXIgREVMXG4gICAgbiAhPT0gbnVsbCAmJiAobiA8IDMyIHx8IG4gPT09IDEyNylcbiAgKTtcbn1cbmZ1bmN0aW9uIHNuKG4pIHtcbiAgcmV0dXJuIG4gIT09IG51bGwgJiYgKG4gPCAwIHx8IG4gPT09IDMyKTtcbn1cbmZ1bmN0aW9uIEwobikge1xuICByZXR1cm4gbiAhPT0gbnVsbCAmJiBuIDwgLTI7XG59XG5mdW5jdGlvbiBHKG4pIHtcbiAgcmV0dXJuIG4gPT09IC0yIHx8IG4gPT09IC0xIHx8IG4gPT09IDMyO1xufVxuY29uc3QgVnIgPSBBbigvXFxzLyksIHFyID0gQW4oJHIpO1xuZnVuY3Rpb24gQW4obikge1xuICByZXR1cm4gZTtcbiAgZnVuY3Rpb24gZSh0KSB7XG4gICAgcmV0dXJuIHQgIT09IG51bGwgJiYgbi50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUodCkpO1xuICB9XG59XG5mdW5jdGlvbiBVKG4sIGUsIHQsIHIpIHtcbiAgY29uc3QgaSA9IHIgPyByIC0gMSA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgbGV0IGwgPSAwO1xuICByZXR1cm4gbztcbiAgZnVuY3Rpb24gbyhhKSB7XG4gICAgcmV0dXJuIEcoYSkgPyAobi5lbnRlcih0KSwgdShhKSkgOiBlKGEpO1xuICB9XG4gIGZ1bmN0aW9uIHUoYSkge1xuICAgIHJldHVybiBHKGEpICYmIGwrKyA8IGkgPyAobi5jb25zdW1lKGEpLCB1KSA6IChuLmV4aXQodCksIGUoYSkpO1xuICB9XG59XG5jb25zdCBXciA9IHtcbiAgdG9rZW5pemU6IFlyXG59O1xuZnVuY3Rpb24gWXIobikge1xuICBjb25zdCBlID0gbi5hdHRlbXB0KFxuICAgIHRoaXMucGFyc2VyLmNvbnN0cnVjdHMuY29udGVudEluaXRpYWwsXG4gICAgcixcbiAgICBpXG4gICk7XG4gIGxldCB0O1xuICByZXR1cm4gZTtcbiAgZnVuY3Rpb24gcih1KSB7XG4gICAgaWYgKHUgPT09IG51bGwpIHtcbiAgICAgIG4uY29uc3VtZSh1KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJsaW5lRW5kaW5nXCIpLCBuLmNvbnN1bWUodSksIG4uZXhpdChcImxpbmVFbmRpbmdcIiksIFUobiwgZSwgXCJsaW5lUHJlZml4XCIpO1xuICB9XG4gIGZ1bmN0aW9uIGkodSkge1xuICAgIHJldHVybiBuLmVudGVyKFwicGFyYWdyYXBoXCIpLCBsKHUpO1xuICB9XG4gIGZ1bmN0aW9uIGwodSkge1xuICAgIGNvbnN0IGEgPSBuLmVudGVyKFwiY2h1bmtUZXh0XCIsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiBcInRleHRcIixcbiAgICAgIHByZXZpb3VzOiB0XG4gICAgfSk7XG4gICAgcmV0dXJuIHQgJiYgKHQubmV4dCA9IGEpLCB0ID0gYSwgbyh1KTtcbiAgfVxuICBmdW5jdGlvbiBvKHUpIHtcbiAgICBpZiAodSA9PT0gbnVsbCkge1xuICAgICAgbi5leGl0KFwiY2h1bmtUZXh0XCIpLCBuLmV4aXQoXCJwYXJhZ3JhcGhcIiksIG4uY29uc3VtZSh1KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIEwodSkgPyAobi5jb25zdW1lKHUpLCBuLmV4aXQoXCJjaHVua1RleHRcIiksIGwpIDogKG4uY29uc3VtZSh1KSwgbyk7XG4gIH1cbn1cbmNvbnN0IFFyID0ge1xuICB0b2tlbml6ZTogWHJcbn0sIFplID0ge1xuICB0b2tlbml6ZTogS3Jcbn07XG5mdW5jdGlvbiBYcihuKSB7XG4gIGNvbnN0IGUgPSB0aGlzLCB0ID0gW107XG4gIGxldCByID0gMCwgaSwgbCwgbztcbiAgcmV0dXJuIHU7XG4gIGZ1bmN0aW9uIHUoQSkge1xuICAgIGlmIChyIDwgdC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IF8gPSB0W3JdO1xuICAgICAgcmV0dXJuIGUuY29udGFpbmVyU3RhdGUgPSBfWzFdLCBuLmF0dGVtcHQoXG4gICAgICAgIF9bMF0uY29udGludWF0aW9uLFxuICAgICAgICBhLFxuICAgICAgICBjXG4gICAgICApKEEpO1xuICAgIH1cbiAgICByZXR1cm4gYyhBKTtcbiAgfVxuICBmdW5jdGlvbiBhKEEpIHtcbiAgICBpZiAocisrLCBlLmNvbnRhaW5lclN0YXRlLl9jbG9zZUZsb3cpIHtcbiAgICAgIGUuY29udGFpbmVyU3RhdGUuX2Nsb3NlRmxvdyA9IHZvaWQgMCwgaSAmJiB2KCk7XG4gICAgICBjb25zdCBfID0gZS5ldmVudHMubGVuZ3RoO1xuICAgICAgbGV0IFQgPSBfLCBiO1xuICAgICAgZm9yICg7IFQtLTsgKVxuICAgICAgICBpZiAoZS5ldmVudHNbVF1bMF0gPT09IFwiZXhpdFwiICYmIGUuZXZlbnRzW1RdWzFdLnR5cGUgPT09IFwiY2h1bmtGbG93XCIpIHtcbiAgICAgICAgICBiID0gZS5ldmVudHNbVF1bMV0uZW5kO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB3KHIpO1xuICAgICAgbGV0IEkgPSBfO1xuICAgICAgZm9yICg7IEkgPCBlLmV2ZW50cy5sZW5ndGg7IClcbiAgICAgICAgZS5ldmVudHNbSV1bMV0uZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgYiksIEkrKztcbiAgICAgIHJldHVybiBnbihcbiAgICAgICAgZS5ldmVudHMsXG4gICAgICAgIFQgKyAxLFxuICAgICAgICAwLFxuICAgICAgICBlLmV2ZW50cy5zbGljZShfKVxuICAgICAgKSwgZS5ldmVudHMubGVuZ3RoID0gSSwgYyhBKTtcbiAgICB9XG4gICAgcmV0dXJuIHUoQSk7XG4gIH1cbiAgZnVuY3Rpb24gYyhBKSB7XG4gICAgaWYgKHIgPT09IHQubGVuZ3RoKSB7XG4gICAgICBpZiAoIWkpXG4gICAgICAgIHJldHVybiBnKEEpO1xuICAgICAgaWYgKGkuY3VycmVudENvbnN0cnVjdCAmJiBpLmN1cnJlbnRDb25zdHJ1Y3QuY29uY3JldGUpXG4gICAgICAgIHJldHVybiBtKEEpO1xuICAgICAgZS5pbnRlcnJ1cHQgPSAhIShpLmN1cnJlbnRDb25zdHJ1Y3QgJiYgIWkuX2dmbVRhYmxlRHluYW1pY0ludGVycnVwdEhhY2spO1xuICAgIH1cbiAgICByZXR1cm4gZS5jb250YWluZXJTdGF0ZSA9IHt9LCBuLmNoZWNrKFxuICAgICAgWmUsXG4gICAgICBzLFxuICAgICAgaFxuICAgICkoQSk7XG4gIH1cbiAgZnVuY3Rpb24gcyhBKSB7XG4gICAgcmV0dXJuIGkgJiYgdigpLCB3KHIpLCBnKEEpO1xuICB9XG4gIGZ1bmN0aW9uIGgoQSkge1xuICAgIHJldHVybiBlLnBhcnNlci5sYXp5W2Uubm93KCkubGluZV0gPSByICE9PSB0Lmxlbmd0aCwgbyA9IGUubm93KCkub2Zmc2V0LCBtKEEpO1xuICB9XG4gIGZ1bmN0aW9uIGcoQSkge1xuICAgIHJldHVybiBlLmNvbnRhaW5lclN0YXRlID0ge30sIG4uYXR0ZW1wdChcbiAgICAgIFplLFxuICAgICAgZCxcbiAgICAgIG1cbiAgICApKEEpO1xuICB9XG4gIGZ1bmN0aW9uIGQoQSkge1xuICAgIHJldHVybiByKyssIHQucHVzaChbZS5jdXJyZW50Q29uc3RydWN0LCBlLmNvbnRhaW5lclN0YXRlXSksIGcoQSk7XG4gIH1cbiAgZnVuY3Rpb24gbShBKSB7XG4gICAgaWYgKEEgPT09IG51bGwpIHtcbiAgICAgIGkgJiYgdigpLCB3KDApLCBuLmNvbnN1bWUoQSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBpID0gaSB8fCBlLnBhcnNlci5mbG93KGUubm93KCkpLCBuLmVudGVyKFwiY2h1bmtGbG93XCIsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiBcImZsb3dcIixcbiAgICAgIHByZXZpb3VzOiBsLFxuICAgICAgX3Rva2VuaXplcjogaVxuICAgIH0pLCB5KEEpO1xuICB9XG4gIGZ1bmN0aW9uIHkoQSkge1xuICAgIGlmIChBID09PSBudWxsKSB7XG4gICAgICB4KG4uZXhpdChcImNodW5rRmxvd1wiKSwgITApLCB3KDApLCBuLmNvbnN1bWUoQSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBMKEEpID8gKG4uY29uc3VtZShBKSwgeChuLmV4aXQoXCJjaHVua0Zsb3dcIikpLCByID0gMCwgZS5pbnRlcnJ1cHQgPSB2b2lkIDAsIHUpIDogKG4uY29uc3VtZShBKSwgeSk7XG4gIH1cbiAgZnVuY3Rpb24geChBLCBfKSB7XG4gICAgY29uc3QgVCA9IGUuc2xpY2VTdHJlYW0oQSk7XG4gICAgaWYgKF8gJiYgVC5wdXNoKG51bGwpLCBBLnByZXZpb3VzID0gbCwgbCAmJiAobC5uZXh0ID0gQSksIGwgPSBBLCBpLmRlZmluZVNraXAoQS5zdGFydCksIGkud3JpdGUoVCksIGUucGFyc2VyLmxhenlbQS5zdGFydC5saW5lXSkge1xuICAgICAgbGV0IGIgPSBpLmV2ZW50cy5sZW5ndGg7XG4gICAgICBmb3IgKDsgYi0tOyApXG4gICAgICAgIGlmIChcbiAgICAgICAgICAvLyBUaGUgdG9rZW4gc3RhcnRzIGJlZm9yZSB0aGUgbGluZSBlbmRpbmfigKZcbiAgICAgICAgICBpLmV2ZW50c1tiXVsxXS5zdGFydC5vZmZzZXQgPCBvICYmIC8vIOKApmFuZCBlaXRoZXIgaXMgbm90IGVuZGVkIHlldOKAplxuICAgICAgICAgICghaS5ldmVudHNbYl1bMV0uZW5kIHx8IC8vIOKApm9yIGVuZHMgYWZ0ZXIgaXQuXG4gICAgICAgICAgaS5ldmVudHNbYl1bMV0uZW5kLm9mZnNldCA+IG8pXG4gICAgICAgIClcbiAgICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBJID0gZS5ldmVudHMubGVuZ3RoO1xuICAgICAgbGV0IFIgPSBJLCBNLCBYO1xuICAgICAgZm9yICg7IFItLTsgKVxuICAgICAgICBpZiAoZS5ldmVudHNbUl1bMF0gPT09IFwiZXhpdFwiICYmIGUuZXZlbnRzW1JdWzFdLnR5cGUgPT09IFwiY2h1bmtGbG93XCIpIHtcbiAgICAgICAgICBpZiAoTSkge1xuICAgICAgICAgICAgWCA9IGUuZXZlbnRzW1JdWzFdLmVuZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBNID0gITA7XG4gICAgICAgIH1cbiAgICAgIGZvciAodyhyKSwgYiA9IEk7IGIgPCBlLmV2ZW50cy5sZW5ndGg7IClcbiAgICAgICAgZS5ldmVudHNbYl1bMV0uZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgWCksIGIrKztcbiAgICAgIGduKFxuICAgICAgICBlLmV2ZW50cyxcbiAgICAgICAgUiArIDEsXG4gICAgICAgIDAsXG4gICAgICAgIGUuZXZlbnRzLnNsaWNlKEkpXG4gICAgICApLCBlLmV2ZW50cy5sZW5ndGggPSBiO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiB3KEEpIHtcbiAgICBsZXQgXyA9IHQubGVuZ3RoO1xuICAgIGZvciAoOyBfLS0gPiBBOyApIHtcbiAgICAgIGNvbnN0IFQgPSB0W19dO1xuICAgICAgZS5jb250YWluZXJTdGF0ZSA9IFRbMV0sIFRbMF0uZXhpdC5jYWxsKGUsIG4pO1xuICAgIH1cbiAgICB0Lmxlbmd0aCA9IEE7XG4gIH1cbiAgZnVuY3Rpb24gdigpIHtcbiAgICBpLndyaXRlKFtudWxsXSksIGwgPSB2b2lkIDAsIGkgPSB2b2lkIDAsIGUuY29udGFpbmVyU3RhdGUuX2Nsb3NlRmxvdyA9IHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gS3IobiwgZSwgdCkge1xuICByZXR1cm4gVShcbiAgICBuLFxuICAgIG4uYXR0ZW1wdCh0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmRvY3VtZW50LCBlLCB0KSxcbiAgICBcImxpbmVQcmVmaXhcIixcbiAgICB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcyhcImNvZGVJbmRlbnRlZFwiKSA/IHZvaWQgMCA6IDRcbiAgKTtcbn1cbmZ1bmN0aW9uIEplKG4pIHtcbiAgaWYgKG4gPT09IG51bGwgfHwgc24obikgfHwgVnIobikpXG4gICAgcmV0dXJuIDE7XG4gIGlmIChxcihuKSlcbiAgICByZXR1cm4gMjtcbn1cbmZ1bmN0aW9uIENlKG4sIGUsIHQpIHtcbiAgY29uc3QgciA9IFtdO1xuICBsZXQgaSA9IC0xO1xuICBmb3IgKDsgKytpIDwgbi5sZW5ndGg7ICkge1xuICAgIGNvbnN0IGwgPSBuW2ldLnJlc29sdmVBbGw7XG4gICAgbCAmJiAhci5pbmNsdWRlcyhsKSAmJiAoZSA9IGwoZSwgdCksIHIucHVzaChsKSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5jb25zdCB4ZSA9IHtcbiAgbmFtZTogXCJhdHRlbnRpb25cIixcbiAgdG9rZW5pemU6IFpyLFxuICByZXNvbHZlQWxsOiBHclxufTtcbmZ1bmN0aW9uIEdyKG4sIGUpIHtcbiAgbGV0IHQgPSAtMSwgciwgaSwgbCwgbywgdSwgYSwgYywgcztcbiAgZm9yICg7ICsrdCA8IG4ubGVuZ3RoOyApXG4gICAgaWYgKG5bdF1bMF0gPT09IFwiZW50ZXJcIiAmJiBuW3RdWzFdLnR5cGUgPT09IFwiYXR0ZW50aW9uU2VxdWVuY2VcIiAmJiBuW3RdWzFdLl9jbG9zZSkge1xuICAgICAgZm9yIChyID0gdDsgci0tOyApXG4gICAgICAgIGlmIChuW3JdWzBdID09PSBcImV4aXRcIiAmJiBuW3JdWzFdLnR5cGUgPT09IFwiYXR0ZW50aW9uU2VxdWVuY2VcIiAmJiBuW3JdWzFdLl9vcGVuICYmIC8vIElmIHRoZSBtYXJrZXJzIGFyZSB0aGUgc2FtZTpcbiAgICAgICAgZS5zbGljZVNlcmlhbGl6ZShuW3JdWzFdKS5jaGFyQ29kZUF0KDApID09PSBlLnNsaWNlU2VyaWFsaXplKG5bdF1bMV0pLmNoYXJDb2RlQXQoMCkpIHtcbiAgICAgICAgICBpZiAoKG5bcl1bMV0uX2Nsb3NlIHx8IG5bdF1bMV0uX29wZW4pICYmIChuW3RdWzFdLmVuZC5vZmZzZXQgLSBuW3RdWzFdLnN0YXJ0Lm9mZnNldCkgJSAzICYmICEoKG5bcl1bMV0uZW5kLm9mZnNldCAtIG5bcl1bMV0uc3RhcnQub2Zmc2V0ICsgblt0XVsxXS5lbmQub2Zmc2V0IC0gblt0XVsxXS5zdGFydC5vZmZzZXQpICUgMykpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBhID0gbltyXVsxXS5lbmQub2Zmc2V0IC0gbltyXVsxXS5zdGFydC5vZmZzZXQgPiAxICYmIG5bdF1bMV0uZW5kLm9mZnNldCAtIG5bdF1bMV0uc3RhcnQub2Zmc2V0ID4gMSA/IDIgOiAxO1xuICAgICAgICAgIGNvbnN0IGggPSBPYmplY3QuYXNzaWduKHt9LCBuW3JdWzFdLmVuZCksIGcgPSBPYmplY3QuYXNzaWduKHt9LCBuW3RdWzFdLnN0YXJ0KTtcbiAgICAgICAgICBudChoLCAtYSksIG50KGcsIGEpLCBvID0ge1xuICAgICAgICAgICAgdHlwZTogYSA+IDEgPyBcInN0cm9uZ1NlcXVlbmNlXCIgOiBcImVtcGhhc2lzU2VxdWVuY2VcIixcbiAgICAgICAgICAgIHN0YXJ0OiBoLFxuICAgICAgICAgICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBuW3JdWzFdLmVuZClcbiAgICAgICAgICB9LCB1ID0ge1xuICAgICAgICAgICAgdHlwZTogYSA+IDEgPyBcInN0cm9uZ1NlcXVlbmNlXCIgOiBcImVtcGhhc2lzU2VxdWVuY2VcIixcbiAgICAgICAgICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBuW3RdWzFdLnN0YXJ0KSxcbiAgICAgICAgICAgIGVuZDogZ1xuICAgICAgICAgIH0sIGwgPSB7XG4gICAgICAgICAgICB0eXBlOiBhID4gMSA/IFwic3Ryb25nVGV4dFwiIDogXCJlbXBoYXNpc1RleHRcIixcbiAgICAgICAgICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBuW3JdWzFdLmVuZCksXG4gICAgICAgICAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIG5bdF1bMV0uc3RhcnQpXG4gICAgICAgICAgfSwgaSA9IHtcbiAgICAgICAgICAgIHR5cGU6IGEgPiAxID8gXCJzdHJvbmdcIiA6IFwiZW1waGFzaXNcIixcbiAgICAgICAgICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBvLnN0YXJ0KSxcbiAgICAgICAgICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgdS5lbmQpXG4gICAgICAgICAgfSwgbltyXVsxXS5lbmQgPSBPYmplY3QuYXNzaWduKHt9LCBvLnN0YXJ0KSwgblt0XVsxXS5zdGFydCA9IE9iamVjdC5hc3NpZ24oe30sIHUuZW5kKSwgYyA9IFtdLCBuW3JdWzFdLmVuZC5vZmZzZXQgLSBuW3JdWzFdLnN0YXJ0Lm9mZnNldCAmJiAoYyA9IGFuKGMsIFtcbiAgICAgICAgICAgIFtcImVudGVyXCIsIG5bcl1bMV0sIGVdLFxuICAgICAgICAgICAgW1wiZXhpdFwiLCBuW3JdWzFdLCBlXVxuICAgICAgICAgIF0pKSwgYyA9IGFuKGMsIFtcbiAgICAgICAgICAgIFtcImVudGVyXCIsIGksIGVdLFxuICAgICAgICAgICAgW1wiZW50ZXJcIiwgbywgZV0sXG4gICAgICAgICAgICBbXCJleGl0XCIsIG8sIGVdLFxuICAgICAgICAgICAgW1wiZW50ZXJcIiwgbCwgZV1cbiAgICAgICAgICBdKSwgYyA9IGFuKFxuICAgICAgICAgICAgYyxcbiAgICAgICAgICAgIENlKFxuICAgICAgICAgICAgICBlLnBhcnNlci5jb25zdHJ1Y3RzLmluc2lkZVNwYW4ubnVsbCxcbiAgICAgICAgICAgICAgbi5zbGljZShyICsgMSwgdCksXG4gICAgICAgICAgICAgIGVcbiAgICAgICAgICAgIClcbiAgICAgICAgICApLCBjID0gYW4oYywgW1xuICAgICAgICAgICAgW1wiZXhpdFwiLCBsLCBlXSxcbiAgICAgICAgICAgIFtcImVudGVyXCIsIHUsIGVdLFxuICAgICAgICAgICAgW1wiZXhpdFwiLCB1LCBlXSxcbiAgICAgICAgICAgIFtcImV4aXRcIiwgaSwgZV1cbiAgICAgICAgICBdKSwgblt0XVsxXS5lbmQub2Zmc2V0IC0gblt0XVsxXS5zdGFydC5vZmZzZXQgPyAocyA9IDIsIGMgPSBhbihjLCBbXG4gICAgICAgICAgICBbXCJlbnRlclwiLCBuW3RdWzFdLCBlXSxcbiAgICAgICAgICAgIFtcImV4aXRcIiwgblt0XVsxXSwgZV1cbiAgICAgICAgICBdKSkgOiBzID0gMCwgZ24obiwgciAtIDEsIHQgLSByICsgMywgYyksIHQgPSByICsgYy5sZW5ndGggLSBzIC0gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgZm9yICh0ID0gLTE7ICsrdCA8IG4ubGVuZ3RoOyApXG4gICAgblt0XVsxXS50eXBlID09PSBcImF0dGVudGlvblNlcXVlbmNlXCIgJiYgKG5bdF1bMV0udHlwZSA9IFwiZGF0YVwiKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBacihuLCBlKSB7XG4gIGNvbnN0IHQgPSB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmF0dGVudGlvbk1hcmtlcnMubnVsbCwgciA9IHRoaXMucHJldmlvdXMsIGkgPSBKZShyKTtcbiAgbGV0IGw7XG4gIHJldHVybiBvO1xuICBmdW5jdGlvbiBvKGEpIHtcbiAgICByZXR1cm4gbi5lbnRlcihcImF0dGVudGlvblNlcXVlbmNlXCIpLCBsID0gYSwgdShhKTtcbiAgfVxuICBmdW5jdGlvbiB1KGEpIHtcbiAgICBpZiAoYSA9PT0gbClcbiAgICAgIHJldHVybiBuLmNvbnN1bWUoYSksIHU7XG4gICAgY29uc3QgYyA9IG4uZXhpdChcImF0dGVudGlvblNlcXVlbmNlXCIpLCBzID0gSmUoYSksIGggPSAhcyB8fCBzID09PSAyICYmIGkgfHwgdC5pbmNsdWRlcyhhKSwgZyA9ICFpIHx8IGkgPT09IDIgJiYgcyB8fCB0LmluY2x1ZGVzKHIpO1xuICAgIHJldHVybiBjLl9vcGVuID0gISEobCA9PT0gNDIgPyBoIDogaCAmJiAoaSB8fCAhZykpLCBjLl9jbG9zZSA9ICEhKGwgPT09IDQyID8gZyA6IGcgJiYgKHMgfHwgIWgpKSwgZShhKTtcbiAgfVxufVxuZnVuY3Rpb24gbnQobiwgZSkge1xuICBuLmNvbHVtbiArPSBlLCBuLm9mZnNldCArPSBlLCBuLl9idWZmZXJJbmRleCArPSBlO1xufVxuY29uc3QgSnIgPSB7XG4gIG5hbWU6IFwiYXV0b2xpbmtcIixcbiAgdG9rZW5pemU6IG5pXG59O1xuZnVuY3Rpb24gbmkobiwgZSwgdCkge1xuICBsZXQgciA9IDE7XG4gIHJldHVybiBpO1xuICBmdW5jdGlvbiBpKG0pIHtcbiAgICByZXR1cm4gbi5lbnRlcihcImF1dG9saW5rXCIpLCBuLmVudGVyKFwiYXV0b2xpbmtNYXJrZXJcIiksIG4uY29uc3VtZShtKSwgbi5leGl0KFwiYXV0b2xpbmtNYXJrZXJcIiksIG4uZW50ZXIoXCJhdXRvbGlua1Byb3RvY29sXCIpLCBsO1xuICB9XG4gIGZ1bmN0aW9uIGwobSkge1xuICAgIHJldHVybiBkbihtKSA/IChuLmNvbnN1bWUobSksIG8pIDogR2UobSkgPyBjKG0pIDogdChtKTtcbiAgfVxuICBmdW5jdGlvbiBvKG0pIHtcbiAgICByZXR1cm4gbSA9PT0gNDMgfHwgbSA9PT0gNDUgfHwgbSA9PT0gNDYgfHwgb24obSkgPyB1KG0pIDogYyhtKTtcbiAgfVxuICBmdW5jdGlvbiB1KG0pIHtcbiAgICByZXR1cm4gbSA9PT0gNTggPyAobi5jb25zdW1lKG0pLCBhKSA6IChtID09PSA0MyB8fCBtID09PSA0NSB8fCBtID09PSA0NiB8fCBvbihtKSkgJiYgcisrIDwgMzIgPyAobi5jb25zdW1lKG0pLCB1KSA6IGMobSk7XG4gIH1cbiAgZnVuY3Rpb24gYShtKSB7XG4gICAgcmV0dXJuIG0gPT09IDYyID8gKG4uZXhpdChcImF1dG9saW5rUHJvdG9jb2xcIiksIGQobSkpIDogbSA9PT0gbnVsbCB8fCBtID09PSAzMiB8fCBtID09PSA2MCB8fCB5ZShtKSA/IHQobSkgOiAobi5jb25zdW1lKG0pLCBhKTtcbiAgfVxuICBmdW5jdGlvbiBjKG0pIHtcbiAgICByZXR1cm4gbSA9PT0gNjQgPyAobi5jb25zdW1lKG0pLCByID0gMCwgcykgOiBHZShtKSA/IChuLmNvbnN1bWUobSksIGMpIDogdChtKTtcbiAgfVxuICBmdW5jdGlvbiBzKG0pIHtcbiAgICByZXR1cm4gb24obSkgPyBoKG0pIDogdChtKTtcbiAgfVxuICBmdW5jdGlvbiBoKG0pIHtcbiAgICByZXR1cm4gbSA9PT0gNDYgPyAobi5jb25zdW1lKG0pLCByID0gMCwgcykgOiBtID09PSA2MiA/IChuLmV4aXQoXCJhdXRvbGlua1Byb3RvY29sXCIpLnR5cGUgPSBcImF1dG9saW5rRW1haWxcIiwgZChtKSkgOiBnKG0pO1xuICB9XG4gIGZ1bmN0aW9uIGcobSkge1xuICAgIHJldHVybiAobSA9PT0gNDUgfHwgb24obSkpICYmIHIrKyA8IDYzID8gKG4uY29uc3VtZShtKSwgbSA9PT0gNDUgPyBnIDogaCkgOiB0KG0pO1xuICB9XG4gIGZ1bmN0aW9uIGQobSkge1xuICAgIHJldHVybiBuLmVudGVyKFwiYXV0b2xpbmtNYXJrZXJcIiksIG4uY29uc3VtZShtKSwgbi5leGl0KFwiYXV0b2xpbmtNYXJrZXJcIiksIG4uZXhpdChcImF1dG9saW5rXCIpLCBlO1xuICB9XG59XG5jb25zdCBabiA9IHtcbiAgdG9rZW5pemU6IGVpLFxuICBwYXJ0aWFsOiAhMFxufTtcbmZ1bmN0aW9uIGVpKG4sIGUsIHQpIHtcbiAgcmV0dXJuIFUobiwgciwgXCJsaW5lUHJlZml4XCIpO1xuICBmdW5jdGlvbiByKGkpIHtcbiAgICByZXR1cm4gaSA9PT0gbnVsbCB8fCBMKGkpID8gZShpKSA6IHQoaSk7XG4gIH1cbn1cbmNvbnN0IER0ID0ge1xuICBuYW1lOiBcImJsb2NrUXVvdGVcIixcbiAgdG9rZW5pemU6IHRpLFxuICBjb250aW51YXRpb246IHtcbiAgICB0b2tlbml6ZTogcmlcbiAgfSxcbiAgZXhpdDogaWlcbn07XG5mdW5jdGlvbiB0aShuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB0aGlzO1xuICByZXR1cm4gaTtcbiAgZnVuY3Rpb24gaShvKSB7XG4gICAgaWYgKG8gPT09IDYyKSB7XG4gICAgICBjb25zdCB1ID0gci5jb250YWluZXJTdGF0ZTtcbiAgICAgIHJldHVybiB1Lm9wZW4gfHwgKG4uZW50ZXIoXCJibG9ja1F1b3RlXCIsIHtcbiAgICAgICAgX2NvbnRhaW5lcjogITBcbiAgICAgIH0pLCB1Lm9wZW4gPSAhMCksIG4uZW50ZXIoXCJibG9ja1F1b3RlUHJlZml4XCIpLCBuLmVudGVyKFwiYmxvY2tRdW90ZU1hcmtlclwiKSwgbi5jb25zdW1lKG8pLCBuLmV4aXQoXCJibG9ja1F1b3RlTWFya2VyXCIpLCBsO1xuICAgIH1cbiAgICByZXR1cm4gdChvKTtcbiAgfVxuICBmdW5jdGlvbiBsKG8pIHtcbiAgICByZXR1cm4gRyhvKSA/IChuLmVudGVyKFwiYmxvY2tRdW90ZVByZWZpeFdoaXRlc3BhY2VcIiksIG4uY29uc3VtZShvKSwgbi5leGl0KFwiYmxvY2tRdW90ZVByZWZpeFdoaXRlc3BhY2VcIiksIG4uZXhpdChcImJsb2NrUXVvdGVQcmVmaXhcIiksIGUpIDogKG4uZXhpdChcImJsb2NrUXVvdGVQcmVmaXhcIiksIGUobykpO1xuICB9XG59XG5mdW5jdGlvbiByaShuLCBlLCB0KSB7XG4gIHJldHVybiBVKFxuICAgIG4sXG4gICAgbi5hdHRlbXB0KER0LCBlLCB0KSxcbiAgICBcImxpbmVQcmVmaXhcIixcbiAgICB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcyhcImNvZGVJbmRlbnRlZFwiKSA/IHZvaWQgMCA6IDRcbiAgKTtcbn1cbmZ1bmN0aW9uIGlpKG4pIHtcbiAgbi5leGl0KFwiYmxvY2tRdW90ZVwiKTtcbn1cbmNvbnN0IHZ0ID0ge1xuICBuYW1lOiBcImNoYXJhY3RlckVzY2FwZVwiLFxuICB0b2tlbml6ZTogbGlcbn07XG5mdW5jdGlvbiBsaShuLCBlLCB0KSB7XG4gIHJldHVybiByO1xuICBmdW5jdGlvbiByKGwpIHtcbiAgICByZXR1cm4gbi5lbnRlcihcImNoYXJhY3RlckVzY2FwZVwiKSwgbi5lbnRlcihcImVzY2FwZU1hcmtlclwiKSwgbi5jb25zdW1lKGwpLCBuLmV4aXQoXCJlc2NhcGVNYXJrZXJcIiksIGk7XG4gIH1cbiAgZnVuY3Rpb24gaShsKSB7XG4gICAgcmV0dXJuIFVyKGwpID8gKG4uZW50ZXIoXCJjaGFyYWN0ZXJFc2NhcGVWYWx1ZVwiKSwgbi5jb25zdW1lKGwpLCBuLmV4aXQoXCJjaGFyYWN0ZXJFc2NhcGVWYWx1ZVwiKSwgbi5leGl0KFwiY2hhcmFjdGVyRXNjYXBlXCIpLCBlKSA6IHQobCk7XG4gIH1cbn1cbmNvbnN0IGV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlcIik7XG5mdW5jdGlvbiBBZShuKSB7XG4gIGNvbnN0IGUgPSBcIiZcIiArIG4gKyBcIjtcIjtcbiAgZXQuaW5uZXJIVE1MID0gZTtcbiAgY29uc3QgdCA9IGV0LnRleHRDb250ZW50O1xuICByZXR1cm4gdC5jaGFyQ29kZUF0KHQubGVuZ3RoIC0gMSkgPT09IDU5ICYmIG4gIT09IFwic2VtaVwiIHx8IHQgPT09IGUgPyAhMSA6IHQ7XG59XG5jb25zdCB6dCA9IHtcbiAgbmFtZTogXCJjaGFyYWN0ZXJSZWZlcmVuY2VcIixcbiAgdG9rZW5pemU6IG9pXG59O1xuZnVuY3Rpb24gb2kobiwgZSwgdCkge1xuICBjb25zdCByID0gdGhpcztcbiAgbGV0IGkgPSAwLCBsLCBvO1xuICByZXR1cm4gdTtcbiAgZnVuY3Rpb24gdShoKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJjaGFyYWN0ZXJSZWZlcmVuY2VcIiksIG4uZW50ZXIoXCJjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJcIiksIG4uY29uc3VtZShoKSwgbi5leGl0KFwiY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyXCIpLCBhO1xuICB9XG4gIGZ1bmN0aW9uIGEoaCkge1xuICAgIHJldHVybiBoID09PSAzNSA/IChuLmVudGVyKFwiY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyTnVtZXJpY1wiKSwgbi5jb25zdW1lKGgpLCBuLmV4aXQoXCJjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljXCIpLCBjKSA6IChuLmVudGVyKFwiY2hhcmFjdGVyUmVmZXJlbmNlVmFsdWVcIiksIGwgPSAzMSwgbyA9IG9uLCBzKGgpKTtcbiAgfVxuICBmdW5jdGlvbiBjKGgpIHtcbiAgICByZXR1cm4gaCA9PT0gODggfHwgaCA9PT0gMTIwID8gKG4uZW50ZXIoXCJjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJIZXhhZGVjaW1hbFwiKSwgbi5jb25zdW1lKGgpLCBuLmV4aXQoXCJjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJIZXhhZGVjaW1hbFwiKSwgbi5lbnRlcihcImNoYXJhY3RlclJlZmVyZW5jZVZhbHVlXCIpLCBsID0gNiwgbyA9IEhyLCBzKSA6IChuLmVudGVyKFwiY2hhcmFjdGVyUmVmZXJlbmNlVmFsdWVcIiksIGwgPSA3LCBvID0gZ2UsIHMoaCkpO1xuICB9XG4gIGZ1bmN0aW9uIHMoaCkge1xuICAgIGxldCBnO1xuICAgIHJldHVybiBoID09PSA1OSAmJiBpID8gKGcgPSBuLmV4aXQoXCJjaGFyYWN0ZXJSZWZlcmVuY2VWYWx1ZVwiKSwgbyA9PT0gb24gJiYgIUFlKHIuc2xpY2VTZXJpYWxpemUoZykpID8gdChoKSA6IChuLmVudGVyKFwiY2hhcmFjdGVyUmVmZXJlbmNlTWFya2VyXCIpLCBuLmNvbnN1bWUoaCksIG4uZXhpdChcImNoYXJhY3RlclJlZmVyZW5jZU1hcmtlclwiKSwgbi5leGl0KFwiY2hhcmFjdGVyUmVmZXJlbmNlXCIpLCBlKSkgOiBvKGgpICYmIGkrKyA8IGwgPyAobi5jb25zdW1lKGgpLCBzKSA6IHQoaCk7XG4gIH1cbn1cbmNvbnN0IHR0ID0ge1xuICBuYW1lOiBcImNvZGVGZW5jZWRcIixcbiAgdG9rZW5pemU6IHVpLFxuICBjb25jcmV0ZTogITBcbn07XG5mdW5jdGlvbiB1aShuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB0aGlzLCBpID0ge1xuICAgIHRva2VuaXplOiBULFxuICAgIHBhcnRpYWw6ICEwXG4gIH0sIGwgPSB7XG4gICAgdG9rZW5pemU6IF8sXG4gICAgcGFydGlhbDogITBcbiAgfSwgbyA9IHRoaXMuZXZlbnRzW3RoaXMuZXZlbnRzLmxlbmd0aCAtIDFdLCB1ID0gbyAmJiBvWzFdLnR5cGUgPT09IFwibGluZVByZWZpeFwiID8gb1syXS5zbGljZVNlcmlhbGl6ZShvWzFdLCAhMCkubGVuZ3RoIDogMDtcbiAgbGV0IGEgPSAwLCBjO1xuICByZXR1cm4gcztcbiAgZnVuY3Rpb24gcyhiKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJjb2RlRmVuY2VkXCIpLCBuLmVudGVyKFwiY29kZUZlbmNlZEZlbmNlXCIpLCBuLmVudGVyKFwiY29kZUZlbmNlZEZlbmNlU2VxdWVuY2VcIiksIGMgPSBiLCBoKGIpO1xuICB9XG4gIGZ1bmN0aW9uIGgoYikge1xuICAgIHJldHVybiBiID09PSBjID8gKG4uY29uc3VtZShiKSwgYSsrLCBoKSA6IChuLmV4aXQoXCJjb2RlRmVuY2VkRmVuY2VTZXF1ZW5jZVwiKSwgYSA8IDMgPyB0KGIpIDogVShuLCBnLCBcIndoaXRlc3BhY2VcIikoYikpO1xuICB9XG4gIGZ1bmN0aW9uIGcoYikge1xuICAgIHJldHVybiBiID09PSBudWxsIHx8IEwoYikgPyB4KGIpIDogKG4uZW50ZXIoXCJjb2RlRmVuY2VkRmVuY2VJbmZvXCIpLCBuLmVudGVyKFwiY2h1bmtTdHJpbmdcIiwge1xuICAgICAgY29udGVudFR5cGU6IFwic3RyaW5nXCJcbiAgICB9KSwgZChiKSk7XG4gIH1cbiAgZnVuY3Rpb24gZChiKSB7XG4gICAgcmV0dXJuIGIgPT09IG51bGwgfHwgc24oYikgPyAobi5leGl0KFwiY2h1bmtTdHJpbmdcIiksIG4uZXhpdChcImNvZGVGZW5jZWRGZW5jZUluZm9cIiksIFUobiwgbSwgXCJ3aGl0ZXNwYWNlXCIpKGIpKSA6IGIgPT09IDk2ICYmIGIgPT09IGMgPyB0KGIpIDogKG4uY29uc3VtZShiKSwgZCk7XG4gIH1cbiAgZnVuY3Rpb24gbShiKSB7XG4gICAgcmV0dXJuIGIgPT09IG51bGwgfHwgTChiKSA/IHgoYikgOiAobi5lbnRlcihcImNvZGVGZW5jZWRGZW5jZU1ldGFcIiksIG4uZW50ZXIoXCJjaHVua1N0cmluZ1wiLCB7XG4gICAgICBjb250ZW50VHlwZTogXCJzdHJpbmdcIlxuICAgIH0pLCB5KGIpKTtcbiAgfVxuICBmdW5jdGlvbiB5KGIpIHtcbiAgICByZXR1cm4gYiA9PT0gbnVsbCB8fCBMKGIpID8gKG4uZXhpdChcImNodW5rU3RyaW5nXCIpLCBuLmV4aXQoXCJjb2RlRmVuY2VkRmVuY2VNZXRhXCIpLCB4KGIpKSA6IGIgPT09IDk2ICYmIGIgPT09IGMgPyB0KGIpIDogKG4uY29uc3VtZShiKSwgeSk7XG4gIH1cbiAgZnVuY3Rpb24geChiKSB7XG4gICAgcmV0dXJuIG4uZXhpdChcImNvZGVGZW5jZWRGZW5jZVwiKSwgci5pbnRlcnJ1cHQgPyBlKGIpIDogdyhiKTtcbiAgfVxuICBmdW5jdGlvbiB3KGIpIHtcbiAgICByZXR1cm4gYiA9PT0gbnVsbCA/IEEoYikgOiBMKGIpID8gbi5hdHRlbXB0KFxuICAgICAgbCxcbiAgICAgIG4uYXR0ZW1wdChcbiAgICAgICAgaSxcbiAgICAgICAgQSxcbiAgICAgICAgdSA/IFUoXG4gICAgICAgICAgbixcbiAgICAgICAgICB3LFxuICAgICAgICAgIFwibGluZVByZWZpeFwiLFxuICAgICAgICAgIHUgKyAxXG4gICAgICAgICkgOiB3XG4gICAgICApLFxuICAgICAgQVxuICAgICkoYikgOiAobi5lbnRlcihcImNvZGVGbG93VmFsdWVcIiksIHYoYikpO1xuICB9XG4gIGZ1bmN0aW9uIHYoYikge1xuICAgIHJldHVybiBiID09PSBudWxsIHx8IEwoYikgPyAobi5leGl0KFwiY29kZUZsb3dWYWx1ZVwiKSwgdyhiKSkgOiAobi5jb25zdW1lKGIpLCB2KTtcbiAgfVxuICBmdW5jdGlvbiBBKGIpIHtcbiAgICByZXR1cm4gbi5leGl0KFwiY29kZUZlbmNlZFwiKSwgZShiKTtcbiAgfVxuICBmdW5jdGlvbiBfKGIsIEksIFIpIHtcbiAgICBjb25zdCBNID0gdGhpcztcbiAgICByZXR1cm4gWDtcbiAgICBmdW5jdGlvbiBYKEYpIHtcbiAgICAgIHJldHVybiBiLmVudGVyKFwibGluZUVuZGluZ1wiKSwgYi5jb25zdW1lKEYpLCBiLmV4aXQoXCJsaW5lRW5kaW5nXCIpLCBDO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDKEYpIHtcbiAgICAgIHJldHVybiBNLnBhcnNlci5sYXp5W00ubm93KCkubGluZV0gPyBSKEYpIDogSShGKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gVChiLCBJLCBSKSB7XG4gICAgbGV0IE0gPSAwO1xuICAgIHJldHVybiBVKFxuICAgICAgYixcbiAgICAgIFgsXG4gICAgICBcImxpbmVQcmVmaXhcIixcbiAgICAgIHRoaXMucGFyc2VyLmNvbnN0cnVjdHMuZGlzYWJsZS5udWxsLmluY2x1ZGVzKFwiY29kZUluZGVudGVkXCIpID8gdm9pZCAwIDogNFxuICAgICk7XG4gICAgZnVuY3Rpb24gWChCKSB7XG4gICAgICByZXR1cm4gYi5lbnRlcihcImNvZGVGZW5jZWRGZW5jZVwiKSwgYi5lbnRlcihcImNvZGVGZW5jZWRGZW5jZVNlcXVlbmNlXCIpLCBDKEIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBDKEIpIHtcbiAgICAgIHJldHVybiBCID09PSBjID8gKGIuY29uc3VtZShCKSwgTSsrLCBDKSA6IE0gPCBhID8gUihCKSA6IChiLmV4aXQoXCJjb2RlRmVuY2VkRmVuY2VTZXF1ZW5jZVwiKSwgVShiLCBGLCBcIndoaXRlc3BhY2VcIikoQikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBGKEIpIHtcbiAgICAgIHJldHVybiBCID09PSBudWxsIHx8IEwoQikgPyAoYi5leGl0KFwiY29kZUZlbmNlZEZlbmNlXCIpLCBJKEIpKSA6IFIoQik7XG4gICAgfVxuICB9XG59XG5jb25zdCBzZSA9IHtcbiAgbmFtZTogXCJjb2RlSW5kZW50ZWRcIixcbiAgdG9rZW5pemU6IHNpXG59LCBhaSA9IHtcbiAgdG9rZW5pemU6IGNpLFxuICBwYXJ0aWFsOiAhMFxufTtcbmZ1bmN0aW9uIHNpKG4sIGUsIHQpIHtcbiAgY29uc3QgciA9IHRoaXM7XG4gIHJldHVybiBpO1xuICBmdW5jdGlvbiBpKGMpIHtcbiAgICByZXR1cm4gbi5lbnRlcihcImNvZGVJbmRlbnRlZFwiKSwgVShuLCBsLCBcImxpbmVQcmVmaXhcIiwgNCArIDEpKGMpO1xuICB9XG4gIGZ1bmN0aW9uIGwoYykge1xuICAgIGNvbnN0IHMgPSByLmV2ZW50c1tyLmV2ZW50cy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gcyAmJiBzWzFdLnR5cGUgPT09IFwibGluZVByZWZpeFwiICYmIHNbMl0uc2xpY2VTZXJpYWxpemUoc1sxXSwgITApLmxlbmd0aCA+PSA0ID8gbyhjKSA6IHQoYyk7XG4gIH1cbiAgZnVuY3Rpb24gbyhjKSB7XG4gICAgcmV0dXJuIGMgPT09IG51bGwgPyBhKGMpIDogTChjKSA/IG4uYXR0ZW1wdChhaSwgbywgYSkoYykgOiAobi5lbnRlcihcImNvZGVGbG93VmFsdWVcIiksIHUoYykpO1xuICB9XG4gIGZ1bmN0aW9uIHUoYykge1xuICAgIHJldHVybiBjID09PSBudWxsIHx8IEwoYykgPyAobi5leGl0KFwiY29kZUZsb3dWYWx1ZVwiKSwgbyhjKSkgOiAobi5jb25zdW1lKGMpLCB1KTtcbiAgfVxuICBmdW5jdGlvbiBhKGMpIHtcbiAgICByZXR1cm4gbi5leGl0KFwiY29kZUluZGVudGVkXCIpLCBlKGMpO1xuICB9XG59XG5mdW5jdGlvbiBjaShuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB0aGlzO1xuICByZXR1cm4gaTtcbiAgZnVuY3Rpb24gaShvKSB7XG4gICAgcmV0dXJuIHIucGFyc2VyLmxhenlbci5ub3coKS5saW5lXSA/IHQobykgOiBMKG8pID8gKG4uZW50ZXIoXCJsaW5lRW5kaW5nXCIpLCBuLmNvbnN1bWUobyksIG4uZXhpdChcImxpbmVFbmRpbmdcIiksIGkpIDogVShuLCBsLCBcImxpbmVQcmVmaXhcIiwgNCArIDEpKG8pO1xuICB9XG4gIGZ1bmN0aW9uIGwobykge1xuICAgIGNvbnN0IHUgPSByLmV2ZW50c1tyLmV2ZW50cy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gdSAmJiB1WzFdLnR5cGUgPT09IFwibGluZVByZWZpeFwiICYmIHVbMl0uc2xpY2VTZXJpYWxpemUodVsxXSwgITApLmxlbmd0aCA+PSA0ID8gZShvKSA6IEwobykgPyBpKG8pIDogdChvKTtcbiAgfVxufVxuY29uc3QgcGkgPSB7XG4gIG5hbWU6IFwiY29kZVRleHRcIixcbiAgdG9rZW5pemU6IG1pLFxuICByZXNvbHZlOiBmaSxcbiAgcHJldmlvdXM6IGhpXG59O1xuZnVuY3Rpb24gZmkobikge1xuICBsZXQgZSA9IG4ubGVuZ3RoIC0gNCwgdCA9IDMsIHIsIGk7XG4gIGlmICgoblt0XVsxXS50eXBlID09PSBcImxpbmVFbmRpbmdcIiB8fCBuW3RdWzFdLnR5cGUgPT09IFwic3BhY2VcIikgJiYgKG5bZV1bMV0udHlwZSA9PT0gXCJsaW5lRW5kaW5nXCIgfHwgbltlXVsxXS50eXBlID09PSBcInNwYWNlXCIpKSB7XG4gICAgZm9yIChyID0gdDsgKytyIDwgZTsgKVxuICAgICAgaWYgKG5bcl1bMV0udHlwZSA9PT0gXCJjb2RlVGV4dERhdGFcIikge1xuICAgICAgICBuW3RdWzFdLnR5cGUgPSBcImNvZGVUZXh0UGFkZGluZ1wiLCBuW2VdWzFdLnR5cGUgPSBcImNvZGVUZXh0UGFkZGluZ1wiLCB0ICs9IDIsIGUgLT0gMjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbiAgZm9yIChyID0gdCAtIDEsIGUrKzsgKytyIDw9IGU7IClcbiAgICBpID09PSB2b2lkIDAgPyByICE9PSBlICYmIG5bcl1bMV0udHlwZSAhPT0gXCJsaW5lRW5kaW5nXCIgJiYgKGkgPSByKSA6IChyID09PSBlIHx8IG5bcl1bMV0udHlwZSA9PT0gXCJsaW5lRW5kaW5nXCIpICYmIChuW2ldWzFdLnR5cGUgPSBcImNvZGVUZXh0RGF0YVwiLCByICE9PSBpICsgMiAmJiAobltpXVsxXS5lbmQgPSBuW3IgLSAxXVsxXS5lbmQsIG4uc3BsaWNlKGkgKyAyLCByIC0gaSAtIDIpLCBlIC09IHIgLSBpIC0gMiwgciA9IGkgKyAyKSwgaSA9IHZvaWQgMCk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gaGkobikge1xuICByZXR1cm4gbiAhPT0gOTYgfHwgdGhpcy5ldmVudHNbdGhpcy5ldmVudHMubGVuZ3RoIC0gMV1bMV0udHlwZSA9PT0gXCJjaGFyYWN0ZXJFc2NhcGVcIjtcbn1cbmZ1bmN0aW9uIG1pKG4sIGUsIHQpIHtcbiAgbGV0IHIgPSAwLCBpLCBsO1xuICByZXR1cm4gbztcbiAgZnVuY3Rpb24gbyhoKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJjb2RlVGV4dFwiKSwgbi5lbnRlcihcImNvZGVUZXh0U2VxdWVuY2VcIiksIHUoaCk7XG4gIH1cbiAgZnVuY3Rpb24gdShoKSB7XG4gICAgcmV0dXJuIGggPT09IDk2ID8gKG4uY29uc3VtZShoKSwgcisrLCB1KSA6IChuLmV4aXQoXCJjb2RlVGV4dFNlcXVlbmNlXCIpLCBhKGgpKTtcbiAgfVxuICBmdW5jdGlvbiBhKGgpIHtcbiAgICByZXR1cm4gaCA9PT0gbnVsbCA/IHQoaCkgOiBoID09PSA5NiA/IChsID0gbi5lbnRlcihcImNvZGVUZXh0U2VxdWVuY2VcIiksIGkgPSAwLCBzKGgpKSA6IGggPT09IDMyID8gKG4uZW50ZXIoXCJzcGFjZVwiKSwgbi5jb25zdW1lKGgpLCBuLmV4aXQoXCJzcGFjZVwiKSwgYSkgOiBMKGgpID8gKG4uZW50ZXIoXCJsaW5lRW5kaW5nXCIpLCBuLmNvbnN1bWUoaCksIG4uZXhpdChcImxpbmVFbmRpbmdcIiksIGEpIDogKG4uZW50ZXIoXCJjb2RlVGV4dERhdGFcIiksIGMoaCkpO1xuICB9XG4gIGZ1bmN0aW9uIGMoaCkge1xuICAgIHJldHVybiBoID09PSBudWxsIHx8IGggPT09IDMyIHx8IGggPT09IDk2IHx8IEwoaCkgPyAobi5leGl0KFwiY29kZVRleHREYXRhXCIpLCBhKGgpKSA6IChuLmNvbnN1bWUoaCksIGMpO1xuICB9XG4gIGZ1bmN0aW9uIHMoaCkge1xuICAgIHJldHVybiBoID09PSA5NiA/IChuLmNvbnN1bWUoaCksIGkrKywgcykgOiBpID09PSByID8gKG4uZXhpdChcImNvZGVUZXh0U2VxdWVuY2VcIiksIG4uZXhpdChcImNvZGVUZXh0XCIpLCBlKGgpKSA6IChsLnR5cGUgPSBcImNvZGVUZXh0RGF0YVwiLCBjKGgpKTtcbiAgfVxufVxuZnVuY3Rpb24gUnQobikge1xuICBjb25zdCBlID0ge307XG4gIGxldCB0ID0gLTEsIHIsIGksIGwsIG8sIHUsIGEsIGM7XG4gIGZvciAoOyArK3QgPCBuLmxlbmd0aDsgKSB7XG4gICAgZm9yICg7IHQgaW4gZTsgKVxuICAgICAgdCA9IGVbdF07XG4gICAgaWYgKHIgPSBuW3RdLCB0ICYmIHJbMV0udHlwZSA9PT0gXCJjaHVua0Zsb3dcIiAmJiBuW3QgLSAxXVsxXS50eXBlID09PSBcImxpc3RJdGVtUHJlZml4XCIgJiYgKGEgPSByWzFdLl90b2tlbml6ZXIuZXZlbnRzLCBsID0gMCwgbCA8IGEubGVuZ3RoICYmIGFbbF1bMV0udHlwZSA9PT0gXCJsaW5lRW5kaW5nQmxhbmtcIiAmJiAobCArPSAyKSwgbCA8IGEubGVuZ3RoICYmIGFbbF1bMV0udHlwZSA9PT0gXCJjb250ZW50XCIpKVxuICAgICAgZm9yICg7ICsrbCA8IGEubGVuZ3RoICYmIGFbbF1bMV0udHlwZSAhPT0gXCJjb250ZW50XCI7IClcbiAgICAgICAgYVtsXVsxXS50eXBlID09PSBcImNodW5rVGV4dFwiICYmIChhW2xdWzFdLl9pc0luRmlyc3RDb250ZW50T2ZMaXN0SXRlbSA9ICEwLCBsKyspO1xuICAgIGlmIChyWzBdID09PSBcImVudGVyXCIpXG4gICAgICByWzFdLmNvbnRlbnRUeXBlICYmIChPYmplY3QuYXNzaWduKGUsIGRpKG4sIHQpKSwgdCA9IGVbdF0sIGMgPSAhMCk7XG4gICAgZWxzZSBpZiAoclsxXS5fY29udGFpbmVyKSB7XG4gICAgICBmb3IgKGwgPSB0LCBpID0gdm9pZCAwOyBsLS0gJiYgKG8gPSBuW2xdLCBvWzFdLnR5cGUgPT09IFwibGluZUVuZGluZ1wiIHx8IG9bMV0udHlwZSA9PT0gXCJsaW5lRW5kaW5nQmxhbmtcIik7IClcbiAgICAgICAgb1swXSA9PT0gXCJlbnRlclwiICYmIChpICYmIChuW2ldWzFdLnR5cGUgPSBcImxpbmVFbmRpbmdCbGFua1wiKSwgb1sxXS50eXBlID0gXCJsaW5lRW5kaW5nXCIsIGkgPSBsKTtcbiAgICAgIGkgJiYgKHJbMV0uZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgbltpXVsxXS5zdGFydCksIHUgPSBuLnNsaWNlKGksIHQpLCB1LnVuc2hpZnQociksIGduKG4sIGksIHQgLSBpICsgMSwgdSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gIWM7XG59XG5mdW5jdGlvbiBkaShuLCBlKSB7XG4gIGNvbnN0IHQgPSBuW2VdWzFdLCByID0gbltlXVsyXTtcbiAgbGV0IGkgPSBlIC0gMTtcbiAgY29uc3QgbCA9IFtdLCBvID0gdC5fdG9rZW5pemVyIHx8IHIucGFyc2VyW3QuY29udGVudFR5cGVdKHQuc3RhcnQpLCB1ID0gby5ldmVudHMsIGEgPSBbXSwgYyA9IHt9O1xuICBsZXQgcywgaCwgZyA9IC0xLCBkID0gdCwgbSA9IDAsIHkgPSAwO1xuICBjb25zdCB4ID0gW3ldO1xuICBmb3IgKDsgZDsgKSB7XG4gICAgZm9yICg7IG5bKytpXVsxXSAhPT0gZDsgKVxuICAgICAgO1xuICAgIGwucHVzaChpKSwgZC5fdG9rZW5pemVyIHx8IChzID0gci5zbGljZVN0cmVhbShkKSwgZC5uZXh0IHx8IHMucHVzaChudWxsKSwgaCAmJiBvLmRlZmluZVNraXAoZC5zdGFydCksIGQuX2lzSW5GaXJzdENvbnRlbnRPZkxpc3RJdGVtICYmIChvLl9nZm1UYXNrbGlzdEZpcnN0Q29udGVudE9mTGlzdEl0ZW0gPSAhMCksIG8ud3JpdGUocyksIGQuX2lzSW5GaXJzdENvbnRlbnRPZkxpc3RJdGVtICYmIChvLl9nZm1UYXNrbGlzdEZpcnN0Q29udGVudE9mTGlzdEl0ZW0gPSB2b2lkIDApKSwgaCA9IGQsIGQgPSBkLm5leHQ7XG4gIH1cbiAgZm9yIChkID0gdDsgKytnIDwgdS5sZW5ndGg7IClcbiAgICAvLyBGaW5kIGEgdm9pZCB0b2tlbiB0aGF0IGluY2x1ZGVzIGEgYnJlYWsuXG4gICAgdVtnXVswXSA9PT0gXCJleGl0XCIgJiYgdVtnIC0gMV1bMF0gPT09IFwiZW50ZXJcIiAmJiB1W2ddWzFdLnR5cGUgPT09IHVbZyAtIDFdWzFdLnR5cGUgJiYgdVtnXVsxXS5zdGFydC5saW5lICE9PSB1W2ddWzFdLmVuZC5saW5lICYmICh5ID0gZyArIDEsIHgucHVzaCh5KSwgZC5fdG9rZW5pemVyID0gdm9pZCAwLCBkLnByZXZpb3VzID0gdm9pZCAwLCBkID0gZC5uZXh0KTtcbiAgZm9yIChvLmV2ZW50cyA9IFtdLCBkID8gKGQuX3Rva2VuaXplciA9IHZvaWQgMCwgZC5wcmV2aW91cyA9IHZvaWQgMCkgOiB4LnBvcCgpLCBnID0geC5sZW5ndGg7IGctLTsgKSB7XG4gICAgY29uc3QgdyA9IHUuc2xpY2UoeFtnXSwgeFtnICsgMV0pLCB2ID0gbC5wb3AoKTtcbiAgICBhLnVuc2hpZnQoW3YsIHYgKyB3Lmxlbmd0aCAtIDFdKSwgZ24obiwgdiwgMiwgdyk7XG4gIH1cbiAgZm9yIChnID0gLTE7ICsrZyA8IGEubGVuZ3RoOyApXG4gICAgY1ttICsgYVtnXVswXV0gPSBtICsgYVtnXVsxXSwgbSArPSBhW2ddWzFdIC0gYVtnXVswXSAtIDE7XG4gIHJldHVybiBjO1xufVxuY29uc3QgZ2kgPSB7XG4gIHRva2VuaXplOiBraSxcbiAgcmVzb2x2ZTogeGlcbn0sIHlpID0ge1xuICB0b2tlbml6ZTogYmksXG4gIHBhcnRpYWw6ICEwXG59O1xuZnVuY3Rpb24geGkobikge1xuICByZXR1cm4gUnQobiksIG47XG59XG5mdW5jdGlvbiBraShuLCBlKSB7XG4gIGxldCB0O1xuICByZXR1cm4gcjtcbiAgZnVuY3Rpb24gcih1KSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJjb250ZW50XCIpLCB0ID0gbi5lbnRlcihcImNodW5rQ29udGVudFwiLCB7XG4gICAgICBjb250ZW50VHlwZTogXCJjb250ZW50XCJcbiAgICB9KSwgaSh1KTtcbiAgfVxuICBmdW5jdGlvbiBpKHUpIHtcbiAgICByZXR1cm4gdSA9PT0gbnVsbCA/IGwodSkgOiBMKHUpID8gbi5jaGVjayhcbiAgICAgIHlpLFxuICAgICAgbyxcbiAgICAgIGxcbiAgICApKHUpIDogKG4uY29uc3VtZSh1KSwgaSk7XG4gIH1cbiAgZnVuY3Rpb24gbCh1KSB7XG4gICAgcmV0dXJuIG4uZXhpdChcImNodW5rQ29udGVudFwiKSwgbi5leGl0KFwiY29udGVudFwiKSwgZSh1KTtcbiAgfVxuICBmdW5jdGlvbiBvKHUpIHtcbiAgICByZXR1cm4gbi5jb25zdW1lKHUpLCBuLmV4aXQoXCJjaHVua0NvbnRlbnRcIiksIHQubmV4dCA9IG4uZW50ZXIoXCJjaHVua0NvbnRlbnRcIiwge1xuICAgICAgY29udGVudFR5cGU6IFwiY29udGVudFwiLFxuICAgICAgcHJldmlvdXM6IHRcbiAgICB9KSwgdCA9IHQubmV4dCwgaTtcbiAgfVxufVxuZnVuY3Rpb24gYmkobiwgZSwgdCkge1xuICBjb25zdCByID0gdGhpcztcbiAgcmV0dXJuIGk7XG4gIGZ1bmN0aW9uIGkobykge1xuICAgIHJldHVybiBuLmV4aXQoXCJjaHVua0NvbnRlbnRcIiksIG4uZW50ZXIoXCJsaW5lRW5kaW5nXCIpLCBuLmNvbnN1bWUobyksIG4uZXhpdChcImxpbmVFbmRpbmdcIiksIFUobiwgbCwgXCJsaW5lUHJlZml4XCIpO1xuICB9XG4gIGZ1bmN0aW9uIGwobykge1xuICAgIGlmIChvID09PSBudWxsIHx8IEwobykpXG4gICAgICByZXR1cm4gdChvKTtcbiAgICBjb25zdCB1ID0gci5ldmVudHNbci5ldmVudHMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuICFyLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcyhcImNvZGVJbmRlbnRlZFwiKSAmJiB1ICYmIHVbMV0udHlwZSA9PT0gXCJsaW5lUHJlZml4XCIgJiYgdVsyXS5zbGljZVNlcmlhbGl6ZSh1WzFdLCAhMCkubGVuZ3RoID49IDQgPyBlKG8pIDogbi5pbnRlcnJ1cHQoci5wYXJzZXIuY29uc3RydWN0cy5mbG93LCB0LCBlKShvKTtcbiAgfVxufVxuZnVuY3Rpb24gX3QobiwgZSwgdCwgciwgaSwgbCwgbywgdSwgYSkge1xuICBjb25zdCBjID0gYSB8fCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGxldCBzID0gMDtcbiAgcmV0dXJuIGg7XG4gIGZ1bmN0aW9uIGgodykge1xuICAgIHJldHVybiB3ID09PSA2MCA/IChuLmVudGVyKHIpLCBuLmVudGVyKGkpLCBuLmVudGVyKGwpLCBuLmNvbnN1bWUodyksIG4uZXhpdChsKSwgZykgOiB3ID09PSBudWxsIHx8IHcgPT09IDQxIHx8IHllKHcpID8gdCh3KSA6IChuLmVudGVyKHIpLCBuLmVudGVyKG8pLCBuLmVudGVyKHUpLCBuLmVudGVyKFwiY2h1bmtTdHJpbmdcIiwge1xuICAgICAgY29udGVudFR5cGU6IFwic3RyaW5nXCJcbiAgICB9KSwgeSh3KSk7XG4gIH1cbiAgZnVuY3Rpb24gZyh3KSB7XG4gICAgcmV0dXJuIHcgPT09IDYyID8gKG4uZW50ZXIobCksIG4uY29uc3VtZSh3KSwgbi5leGl0KGwpLCBuLmV4aXQoaSksIG4uZXhpdChyKSwgZSkgOiAobi5lbnRlcih1KSwgbi5lbnRlcihcImNodW5rU3RyaW5nXCIsIHtcbiAgICAgIGNvbnRlbnRUeXBlOiBcInN0cmluZ1wiXG4gICAgfSksIGQodykpO1xuICB9XG4gIGZ1bmN0aW9uIGQodykge1xuICAgIHJldHVybiB3ID09PSA2MiA/IChuLmV4aXQoXCJjaHVua1N0cmluZ1wiKSwgbi5leGl0KHUpLCBnKHcpKSA6IHcgPT09IG51bGwgfHwgdyA9PT0gNjAgfHwgTCh3KSA/IHQodykgOiAobi5jb25zdW1lKHcpLCB3ID09PSA5MiA/IG0gOiBkKTtcbiAgfVxuICBmdW5jdGlvbiBtKHcpIHtcbiAgICByZXR1cm4gdyA9PT0gNjAgfHwgdyA9PT0gNjIgfHwgdyA9PT0gOTIgPyAobi5jb25zdW1lKHcpLCBkKSA6IGQodyk7XG4gIH1cbiAgZnVuY3Rpb24geSh3KSB7XG4gICAgcmV0dXJuIHcgPT09IDQwID8gKytzID4gYyA/IHQodykgOiAobi5jb25zdW1lKHcpLCB5KSA6IHcgPT09IDQxID8gcy0tID8gKG4uY29uc3VtZSh3KSwgeSkgOiAobi5leGl0KFwiY2h1bmtTdHJpbmdcIiksIG4uZXhpdCh1KSwgbi5leGl0KG8pLCBuLmV4aXQociksIGUodykpIDogdyA9PT0gbnVsbCB8fCBzbih3KSA/IHMgPyB0KHcpIDogKG4uZXhpdChcImNodW5rU3RyaW5nXCIpLCBuLmV4aXQodSksIG4uZXhpdChvKSwgbi5leGl0KHIpLCBlKHcpKSA6IHllKHcpID8gdCh3KSA6IChuLmNvbnN1bWUodyksIHcgPT09IDkyID8geCA6IHkpO1xuICB9XG4gIGZ1bmN0aW9uIHgodykge1xuICAgIHJldHVybiB3ID09PSA0MCB8fCB3ID09PSA0MSB8fCB3ID09PSA5MiA/IChuLmNvbnN1bWUodyksIHkpIDogeSh3KTtcbiAgfVxufVxuZnVuY3Rpb24gTXQobiwgZSwgdCwgciwgaSwgbCkge1xuICBjb25zdCBvID0gdGhpcztcbiAgbGV0IHUgPSAwLCBhO1xuICByZXR1cm4gYztcbiAgZnVuY3Rpb24gYyhkKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIociksIG4uZW50ZXIoaSksIG4uY29uc3VtZShkKSwgbi5leGl0KGkpLCBuLmVudGVyKGwpLCBzO1xuICB9XG4gIGZ1bmN0aW9uIHMoZCkge1xuICAgIHJldHVybiBkID09PSBudWxsIHx8IGQgPT09IDkxIHx8IGQgPT09IDkzICYmICFhIHx8IC8qIFRvIGRvOiByZW1vdmUgaW4gdGhlIGZ1dHVyZSBvbmNlIHdl4oCZdmUgc3dpdGNoZWQgZnJvbVxuICAgICAqIGBtaWNyb21hcmstZXh0ZW5zaW9uLWZvb3Rub3RlYCB0byBgbWljcm9tYXJrLWV4dGVuc2lvbi1nZm0tZm9vdG5vdGVgLFxuICAgICAqIHdoaWNoIGRvZXNu4oCZdCBuZWVkIHRoaXMgKi9cbiAgICAvKiBIaWRkZW4gZm9vdG5vdGVzIGhvb2sgKi9cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAzICovXG4gICAgZCA9PT0gOTQgJiYgIXUgJiYgXCJfaGlkZGVuRm9vdG5vdGVTdXBwb3J0XCIgaW4gby5wYXJzZXIuY29uc3RydWN0cyB8fCB1ID4gOTk5ID8gdChkKSA6IGQgPT09IDkzID8gKG4uZXhpdChsKSwgbi5lbnRlcihpKSwgbi5jb25zdW1lKGQpLCBuLmV4aXQoaSksIG4uZXhpdChyKSwgZSkgOiBMKGQpID8gKG4uZW50ZXIoXCJsaW5lRW5kaW5nXCIpLCBuLmNvbnN1bWUoZCksIG4uZXhpdChcImxpbmVFbmRpbmdcIiksIHMpIDogKG4uZW50ZXIoXCJjaHVua1N0cmluZ1wiLCB7XG4gICAgICBjb250ZW50VHlwZTogXCJzdHJpbmdcIlxuICAgIH0pLCBoKGQpKTtcbiAgfVxuICBmdW5jdGlvbiBoKGQpIHtcbiAgICByZXR1cm4gZCA9PT0gbnVsbCB8fCBkID09PSA5MSB8fCBkID09PSA5MyB8fCBMKGQpIHx8IHUrKyA+IDk5OSA/IChuLmV4aXQoXCJjaHVua1N0cmluZ1wiKSwgcyhkKSkgOiAobi5jb25zdW1lKGQpLCBhID0gYSB8fCAhRyhkKSwgZCA9PT0gOTIgPyBnIDogaCk7XG4gIH1cbiAgZnVuY3Rpb24gZyhkKSB7XG4gICAgcmV0dXJuIGQgPT09IDkxIHx8IGQgPT09IDkyIHx8IGQgPT09IDkzID8gKG4uY29uc3VtZShkKSwgdSsrLCBoKSA6IGgoZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIEJ0KG4sIGUsIHQsIHIsIGksIGwpIHtcbiAgbGV0IG87XG4gIHJldHVybiB1O1xuICBmdW5jdGlvbiB1KGcpIHtcbiAgICByZXR1cm4gbi5lbnRlcihyKSwgbi5lbnRlcihpKSwgbi5jb25zdW1lKGcpLCBuLmV4aXQoaSksIG8gPSBnID09PSA0MCA/IDQxIDogZywgYTtcbiAgfVxuICBmdW5jdGlvbiBhKGcpIHtcbiAgICByZXR1cm4gZyA9PT0gbyA/IChuLmVudGVyKGkpLCBuLmNvbnN1bWUoZyksIG4uZXhpdChpKSwgbi5leGl0KHIpLCBlKSA6IChuLmVudGVyKGwpLCBjKGcpKTtcbiAgfVxuICBmdW5jdGlvbiBjKGcpIHtcbiAgICByZXR1cm4gZyA9PT0gbyA/IChuLmV4aXQobCksIGEobykpIDogZyA9PT0gbnVsbCA/IHQoZykgOiBMKGcpID8gKG4uZW50ZXIoXCJsaW5lRW5kaW5nXCIpLCBuLmNvbnN1bWUoZyksIG4uZXhpdChcImxpbmVFbmRpbmdcIiksIFUobiwgYywgXCJsaW5lUHJlZml4XCIpKSA6IChuLmVudGVyKFwiY2h1bmtTdHJpbmdcIiwge1xuICAgICAgY29udGVudFR5cGU6IFwic3RyaW5nXCJcbiAgICB9KSwgcyhnKSk7XG4gIH1cbiAgZnVuY3Rpb24gcyhnKSB7XG4gICAgcmV0dXJuIGcgPT09IG8gfHwgZyA9PT0gbnVsbCB8fCBMKGcpID8gKG4uZXhpdChcImNodW5rU3RyaW5nXCIpLCBjKGcpKSA6IChuLmNvbnN1bWUoZyksIGcgPT09IDkyID8gaCA6IHMpO1xuICB9XG4gIGZ1bmN0aW9uIGgoZykge1xuICAgIHJldHVybiBnID09PSBvIHx8IGcgPT09IDkyID8gKG4uY29uc3VtZShnKSwgcykgOiBzKGcpO1xuICB9XG59XG5mdW5jdGlvbiAkbihuLCBlKSB7XG4gIGxldCB0O1xuICByZXR1cm4gcjtcbiAgZnVuY3Rpb24gcihpKSB7XG4gICAgcmV0dXJuIEwoaSkgPyAobi5lbnRlcihcImxpbmVFbmRpbmdcIiksIG4uY29uc3VtZShpKSwgbi5leGl0KFwibGluZUVuZGluZ1wiKSwgdCA9ICEwLCByKSA6IEcoaSkgPyBVKFxuICAgICAgbixcbiAgICAgIHIsXG4gICAgICB0ID8gXCJsaW5lUHJlZml4XCIgOiBcImxpbmVTdWZmaXhcIlxuICAgICkoaSkgOiBlKGkpO1xuICB9XG59XG5mdW5jdGlvbiBMbihuKSB7XG4gIHJldHVybiBuLnJlcGxhY2UoL1tcXHRcXG5cXHIgXSsvZywgXCIgXCIpLnJlcGxhY2UoL14gfCAkL2csIFwiXCIpLnRvTG93ZXJDYXNlKCkudG9VcHBlckNhc2UoKTtcbn1cbmNvbnN0IHdpID0ge1xuICBuYW1lOiBcImRlZmluaXRpb25cIixcbiAgdG9rZW5pemU6IEVpXG59LCBTaSA9IHtcbiAgdG9rZW5pemU6IENpLFxuICBwYXJ0aWFsOiAhMFxufTtcbmZ1bmN0aW9uIEVpKG4sIGUsIHQpIHtcbiAgY29uc3QgciA9IHRoaXM7XG4gIGxldCBpO1xuICByZXR1cm4gbDtcbiAgZnVuY3Rpb24gbChhKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJkZWZpbml0aW9uXCIpLCBNdC5jYWxsKFxuICAgICAgcixcbiAgICAgIG4sXG4gICAgICBvLFxuICAgICAgdCxcbiAgICAgIFwiZGVmaW5pdGlvbkxhYmVsXCIsXG4gICAgICBcImRlZmluaXRpb25MYWJlbE1hcmtlclwiLFxuICAgICAgXCJkZWZpbml0aW9uTGFiZWxTdHJpbmdcIlxuICAgICkoYSk7XG4gIH1cbiAgZnVuY3Rpb24gbyhhKSB7XG4gICAgcmV0dXJuIGkgPSBMbihcbiAgICAgIHIuc2xpY2VTZXJpYWxpemUoci5ldmVudHNbci5ldmVudHMubGVuZ3RoIC0gMV1bMV0pLnNsaWNlKDEsIC0xKVxuICAgICksIGEgPT09IDU4ID8gKG4uZW50ZXIoXCJkZWZpbml0aW9uTWFya2VyXCIpLCBuLmNvbnN1bWUoYSksIG4uZXhpdChcImRlZmluaXRpb25NYXJrZXJcIiksICRuKFxuICAgICAgbixcbiAgICAgIF90KFxuICAgICAgICBuLFxuICAgICAgICBuLmF0dGVtcHQoXG4gICAgICAgICAgU2ksXG4gICAgICAgICAgVShuLCB1LCBcIndoaXRlc3BhY2VcIiksXG4gICAgICAgICAgVShuLCB1LCBcIndoaXRlc3BhY2VcIilcbiAgICAgICAgKSxcbiAgICAgICAgdCxcbiAgICAgICAgXCJkZWZpbml0aW9uRGVzdGluYXRpb25cIixcbiAgICAgICAgXCJkZWZpbml0aW9uRGVzdGluYXRpb25MaXRlcmFsXCIsXG4gICAgICAgIFwiZGVmaW5pdGlvbkRlc3RpbmF0aW9uTGl0ZXJhbE1hcmtlclwiLFxuICAgICAgICBcImRlZmluaXRpb25EZXN0aW5hdGlvblJhd1wiLFxuICAgICAgICBcImRlZmluaXRpb25EZXN0aW5hdGlvblN0cmluZ1wiXG4gICAgICApXG4gICAgKSkgOiB0KGEpO1xuICB9XG4gIGZ1bmN0aW9uIHUoYSkge1xuICAgIHJldHVybiBhID09PSBudWxsIHx8IEwoYSkgPyAobi5leGl0KFwiZGVmaW5pdGlvblwiKSwgci5wYXJzZXIuZGVmaW5lZC5pbmNsdWRlcyhpKSB8fCByLnBhcnNlci5kZWZpbmVkLnB1c2goaSksIGUoYSkpIDogdChhKTtcbiAgfVxufVxuZnVuY3Rpb24gQ2kobiwgZSwgdCkge1xuICByZXR1cm4gcjtcbiAgZnVuY3Rpb24gcihvKSB7XG4gICAgcmV0dXJuIHNuKG8pID8gJG4obiwgaSkobykgOiB0KG8pO1xuICB9XG4gIGZ1bmN0aW9uIGkobykge1xuICAgIHJldHVybiBvID09PSAzNCB8fCBvID09PSAzOSB8fCBvID09PSA0MCA/IEJ0KFxuICAgICAgbixcbiAgICAgIFUobiwgbCwgXCJ3aGl0ZXNwYWNlXCIpLFxuICAgICAgdCxcbiAgICAgIFwiZGVmaW5pdGlvblRpdGxlXCIsXG4gICAgICBcImRlZmluaXRpb25UaXRsZU1hcmtlclwiLFxuICAgICAgXCJkZWZpbml0aW9uVGl0bGVTdHJpbmdcIlxuICAgICkobykgOiB0KG8pO1xuICB9XG4gIGZ1bmN0aW9uIGwobykge1xuICAgIHJldHVybiBvID09PSBudWxsIHx8IEwobykgPyBlKG8pIDogdChvKTtcbiAgfVxufVxuY29uc3QgQWkgPSB7XG4gIG5hbWU6IFwiaGFyZEJyZWFrRXNjYXBlXCIsXG4gIHRva2VuaXplOiBQaVxufTtcbmZ1bmN0aW9uIFBpKG4sIGUsIHQpIHtcbiAgcmV0dXJuIHI7XG4gIGZ1bmN0aW9uIHIobCkge1xuICAgIHJldHVybiBuLmVudGVyKFwiaGFyZEJyZWFrRXNjYXBlXCIpLCBuLmVudGVyKFwiZXNjYXBlTWFya2VyXCIpLCBuLmNvbnN1bWUobCksIGk7XG4gIH1cbiAgZnVuY3Rpb24gaShsKSB7XG4gICAgcmV0dXJuIEwobCkgPyAobi5leGl0KFwiZXNjYXBlTWFya2VyXCIpLCBuLmV4aXQoXCJoYXJkQnJlYWtFc2NhcGVcIiksIGUobCkpIDogdChsKTtcbiAgfVxufVxuY29uc3QgRmkgPSB7XG4gIG5hbWU6IFwiaGVhZGluZ0F0eFwiLFxuICB0b2tlbml6ZTogSWksXG4gIHJlc29sdmU6IFRpXG59O1xuZnVuY3Rpb24gVGkobiwgZSkge1xuICBsZXQgdCA9IG4ubGVuZ3RoIC0gMiwgciA9IDMsIGksIGw7XG4gIHJldHVybiBuW3JdWzFdLnR5cGUgPT09IFwid2hpdGVzcGFjZVwiICYmIChyICs9IDIpLCB0IC0gMiA+IHIgJiYgblt0XVsxXS50eXBlID09PSBcIndoaXRlc3BhY2VcIiAmJiAodCAtPSAyKSwgblt0XVsxXS50eXBlID09PSBcImF0eEhlYWRpbmdTZXF1ZW5jZVwiICYmIChyID09PSB0IC0gMSB8fCB0IC0gNCA+IHIgJiYgblt0IC0gMl1bMV0udHlwZSA9PT0gXCJ3aGl0ZXNwYWNlXCIpICYmICh0IC09IHIgKyAxID09PSB0ID8gMiA6IDQpLCB0ID4gciAmJiAoaSA9IHtcbiAgICB0eXBlOiBcImF0eEhlYWRpbmdUZXh0XCIsXG4gICAgc3RhcnQ6IG5bcl1bMV0uc3RhcnQsXG4gICAgZW5kOiBuW3RdWzFdLmVuZFxuICB9LCBsID0ge1xuICAgIHR5cGU6IFwiY2h1bmtUZXh0XCIsXG4gICAgc3RhcnQ6IG5bcl1bMV0uc3RhcnQsXG4gICAgZW5kOiBuW3RdWzFdLmVuZCxcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIENvbnN0YW50cyBhcmUgZmluZSB0byBhc3NpZ24uXG4gICAgY29udGVudFR5cGU6IFwidGV4dFwiXG4gIH0sIGduKG4sIHIsIHQgLSByICsgMSwgW1xuICAgIFtcImVudGVyXCIsIGksIGVdLFxuICAgIFtcImVudGVyXCIsIGwsIGVdLFxuICAgIFtcImV4aXRcIiwgbCwgZV0sXG4gICAgW1wiZXhpdFwiLCBpLCBlXVxuICBdKSksIG47XG59XG5mdW5jdGlvbiBJaShuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB0aGlzO1xuICBsZXQgaSA9IDA7XG4gIHJldHVybiBsO1xuICBmdW5jdGlvbiBsKHMpIHtcbiAgICByZXR1cm4gbi5lbnRlcihcImF0eEhlYWRpbmdcIiksIG4uZW50ZXIoXCJhdHhIZWFkaW5nU2VxdWVuY2VcIiksIG8ocyk7XG4gIH1cbiAgZnVuY3Rpb24gbyhzKSB7XG4gICAgcmV0dXJuIHMgPT09IDM1ICYmIGkrKyA8IDYgPyAobi5jb25zdW1lKHMpLCBvKSA6IHMgPT09IG51bGwgfHwgc24ocykgPyAobi5leGl0KFwiYXR4SGVhZGluZ1NlcXVlbmNlXCIpLCByLmludGVycnVwdCA/IGUocykgOiB1KHMpKSA6IHQocyk7XG4gIH1cbiAgZnVuY3Rpb24gdShzKSB7XG4gICAgcmV0dXJuIHMgPT09IDM1ID8gKG4uZW50ZXIoXCJhdHhIZWFkaW5nU2VxdWVuY2VcIiksIGEocykpIDogcyA9PT0gbnVsbCB8fCBMKHMpID8gKG4uZXhpdChcImF0eEhlYWRpbmdcIiksIGUocykpIDogRyhzKSA/IFUobiwgdSwgXCJ3aGl0ZXNwYWNlXCIpKHMpIDogKG4uZW50ZXIoXCJhdHhIZWFkaW5nVGV4dFwiKSwgYyhzKSk7XG4gIH1cbiAgZnVuY3Rpb24gYShzKSB7XG4gICAgcmV0dXJuIHMgPT09IDM1ID8gKG4uY29uc3VtZShzKSwgYSkgOiAobi5leGl0KFwiYXR4SGVhZGluZ1NlcXVlbmNlXCIpLCB1KHMpKTtcbiAgfVxuICBmdW5jdGlvbiBjKHMpIHtcbiAgICByZXR1cm4gcyA9PT0gbnVsbCB8fCBzID09PSAzNSB8fCBzbihzKSA/IChuLmV4aXQoXCJhdHhIZWFkaW5nVGV4dFwiKSwgdShzKSkgOiAobi5jb25zdW1lKHMpLCBjKTtcbiAgfVxufVxuY29uc3QgT2kgPSBbXG4gIFwiYWRkcmVzc1wiLFxuICBcImFydGljbGVcIixcbiAgXCJhc2lkZVwiLFxuICBcImJhc2VcIixcbiAgXCJiYXNlZm9udFwiLFxuICBcImJsb2NrcXVvdGVcIixcbiAgXCJib2R5XCIsXG4gIFwiY2FwdGlvblwiLFxuICBcImNlbnRlclwiLFxuICBcImNvbFwiLFxuICBcImNvbGdyb3VwXCIsXG4gIFwiZGRcIixcbiAgXCJkZXRhaWxzXCIsXG4gIFwiZGlhbG9nXCIsXG4gIFwiZGlyXCIsXG4gIFwiZGl2XCIsXG4gIFwiZGxcIixcbiAgXCJkdFwiLFxuICBcImZpZWxkc2V0XCIsXG4gIFwiZmlnY2FwdGlvblwiLFxuICBcImZpZ3VyZVwiLFxuICBcImZvb3RlclwiLFxuICBcImZvcm1cIixcbiAgXCJmcmFtZVwiLFxuICBcImZyYW1lc2V0XCIsXG4gIFwiaDFcIixcbiAgXCJoMlwiLFxuICBcImgzXCIsXG4gIFwiaDRcIixcbiAgXCJoNVwiLFxuICBcImg2XCIsXG4gIFwiaGVhZFwiLFxuICBcImhlYWRlclwiLFxuICBcImhyXCIsXG4gIFwiaHRtbFwiLFxuICBcImlmcmFtZVwiLFxuICBcImxlZ2VuZFwiLFxuICBcImxpXCIsXG4gIFwibGlua1wiLFxuICBcIm1haW5cIixcbiAgXCJtZW51XCIsXG4gIFwibWVudWl0ZW1cIixcbiAgXCJuYXZcIixcbiAgXCJub2ZyYW1lc1wiLFxuICBcIm9sXCIsXG4gIFwib3B0Z3JvdXBcIixcbiAgXCJvcHRpb25cIixcbiAgXCJwXCIsXG4gIFwicGFyYW1cIixcbiAgXCJzZWN0aW9uXCIsXG4gIFwic3VtbWFyeVwiLFxuICBcInRhYmxlXCIsXG4gIFwidGJvZHlcIixcbiAgXCJ0ZFwiLFxuICBcInRmb290XCIsXG4gIFwidGhcIixcbiAgXCJ0aGVhZFwiLFxuICBcInRpdGxlXCIsXG4gIFwidHJcIixcbiAgXCJ0cmFja1wiLFxuICBcInVsXCJcbl0sIHJ0ID0gW1wicHJlXCIsIFwic2NyaXB0XCIsIFwic3R5bGVcIiwgXCJ0ZXh0YXJlYVwiXSwgTGkgPSB7XG4gIG5hbWU6IFwiaHRtbEZsb3dcIixcbiAgdG9rZW5pemU6IHppLFxuICByZXNvbHZlVG86IHZpLFxuICBjb25jcmV0ZTogITBcbn0sIERpID0ge1xuICB0b2tlbml6ZTogUmksXG4gIHBhcnRpYWw6ICEwXG59O1xuZnVuY3Rpb24gdmkobikge1xuICBsZXQgZSA9IG4ubGVuZ3RoO1xuICBmb3IgKDsgZS0tICYmICEobltlXVswXSA9PT0gXCJlbnRlclwiICYmIG5bZV1bMV0udHlwZSA9PT0gXCJodG1sRmxvd1wiKTsgKVxuICAgIDtcbiAgcmV0dXJuIGUgPiAxICYmIG5bZSAtIDJdWzFdLnR5cGUgPT09IFwibGluZVByZWZpeFwiICYmIChuW2VdWzFdLnN0YXJ0ID0gbltlIC0gMl1bMV0uc3RhcnQsIG5bZSArIDFdWzFdLnN0YXJ0ID0gbltlIC0gMl1bMV0uc3RhcnQsIG4uc3BsaWNlKGUgLSAyLCAyKSksIG47XG59XG5mdW5jdGlvbiB6aShuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB0aGlzO1xuICBsZXQgaSwgbCwgbywgdSwgYTtcbiAgcmV0dXJuIGM7XG4gIGZ1bmN0aW9uIGMocCkge1xuICAgIHJldHVybiBuLmVudGVyKFwiaHRtbEZsb3dcIiksIG4uZW50ZXIoXCJodG1sRmxvd0RhdGFcIiksIG4uY29uc3VtZShwKSwgcztcbiAgfVxuICBmdW5jdGlvbiBzKHApIHtcbiAgICByZXR1cm4gcCA9PT0gMzMgPyAobi5jb25zdW1lKHApLCBoKSA6IHAgPT09IDQ3ID8gKG4uY29uc3VtZShwKSwgbSkgOiBwID09PSA2MyA/IChuLmNvbnN1bWUocCksIGkgPSAzLCByLmludGVycnVwdCA/IGUgOiBKKSA6IGRuKHApID8gKG4uY29uc3VtZShwKSwgbyA9IFN0cmluZy5mcm9tQ2hhckNvZGUocCksIGwgPSAhMCwgeSkgOiB0KHApO1xuICB9XG4gIGZ1bmN0aW9uIGgocCkge1xuICAgIHJldHVybiBwID09PSA0NSA/IChuLmNvbnN1bWUocCksIGkgPSAyLCBnKSA6IHAgPT09IDkxID8gKG4uY29uc3VtZShwKSwgaSA9IDUsIG8gPSBcIkNEQVRBW1wiLCB1ID0gMCwgZCkgOiBkbihwKSA/IChuLmNvbnN1bWUocCksIGkgPSA0LCByLmludGVycnVwdCA/IGUgOiBKKSA6IHQocCk7XG4gIH1cbiAgZnVuY3Rpb24gZyhwKSB7XG4gICAgcmV0dXJuIHAgPT09IDQ1ID8gKG4uY29uc3VtZShwKSwgci5pbnRlcnJ1cHQgPyBlIDogSikgOiB0KHApO1xuICB9XG4gIGZ1bmN0aW9uIGQocCkge1xuICAgIHJldHVybiBwID09PSBvLmNoYXJDb2RlQXQodSsrKSA/IChuLmNvbnN1bWUocCksIHUgPT09IG8ubGVuZ3RoID8gci5pbnRlcnJ1cHQgPyBlIDogQyA6IGQpIDogdChwKTtcbiAgfVxuICBmdW5jdGlvbiBtKHApIHtcbiAgICByZXR1cm4gZG4ocCkgPyAobi5jb25zdW1lKHApLCBvID0gU3RyaW5nLmZyb21DaGFyQ29kZShwKSwgeSkgOiB0KHApO1xuICB9XG4gIGZ1bmN0aW9uIHkocCkge1xuICAgIHJldHVybiBwID09PSBudWxsIHx8IHAgPT09IDQ3IHx8IHAgPT09IDYyIHx8IHNuKHApID8gcCAhPT0gNDcgJiYgbCAmJiBydC5pbmNsdWRlcyhvLnRvTG93ZXJDYXNlKCkpID8gKGkgPSAxLCByLmludGVycnVwdCA/IGUocCkgOiBDKHApKSA6IE9pLmluY2x1ZGVzKG8udG9Mb3dlckNhc2UoKSkgPyAoaSA9IDYsIHAgPT09IDQ3ID8gKG4uY29uc3VtZShwKSwgeCkgOiByLmludGVycnVwdCA/IGUocCkgOiBDKHApKSA6IChpID0gNywgci5pbnRlcnJ1cHQgJiYgIXIucGFyc2VyLmxhenlbci5ub3coKS5saW5lXSA/IHQocCkgOiBsID8gdihwKSA6IHcocCkpIDogcCA9PT0gNDUgfHwgb24ocCkgPyAobi5jb25zdW1lKHApLCBvICs9IFN0cmluZy5mcm9tQ2hhckNvZGUocCksIHkpIDogdChwKTtcbiAgfVxuICBmdW5jdGlvbiB4KHApIHtcbiAgICByZXR1cm4gcCA9PT0gNjIgPyAobi5jb25zdW1lKHApLCByLmludGVycnVwdCA/IGUgOiBDKSA6IHQocCk7XG4gIH1cbiAgZnVuY3Rpb24gdyhwKSB7XG4gICAgcmV0dXJuIEcocCkgPyAobi5jb25zdW1lKHApLCB3KSA6IE0ocCk7XG4gIH1cbiAgZnVuY3Rpb24gdihwKSB7XG4gICAgcmV0dXJuIHAgPT09IDQ3ID8gKG4uY29uc3VtZShwKSwgTSkgOiBwID09PSA1OCB8fCBwID09PSA5NSB8fCBkbihwKSA/IChuLmNvbnN1bWUocCksIEEpIDogRyhwKSA/IChuLmNvbnN1bWUocCksIHYpIDogTShwKTtcbiAgfVxuICBmdW5jdGlvbiBBKHApIHtcbiAgICByZXR1cm4gcCA9PT0gNDUgfHwgcCA9PT0gNDYgfHwgcCA9PT0gNTggfHwgcCA9PT0gOTUgfHwgb24ocCkgPyAobi5jb25zdW1lKHApLCBBKSA6IF8ocCk7XG4gIH1cbiAgZnVuY3Rpb24gXyhwKSB7XG4gICAgcmV0dXJuIHAgPT09IDYxID8gKG4uY29uc3VtZShwKSwgVCkgOiBHKHApID8gKG4uY29uc3VtZShwKSwgXykgOiB2KHApO1xuICB9XG4gIGZ1bmN0aW9uIFQocCkge1xuICAgIHJldHVybiBwID09PSBudWxsIHx8IHAgPT09IDYwIHx8IHAgPT09IDYxIHx8IHAgPT09IDYyIHx8IHAgPT09IDk2ID8gdChwKSA6IHAgPT09IDM0IHx8IHAgPT09IDM5ID8gKG4uY29uc3VtZShwKSwgYSA9IHAsIGIpIDogRyhwKSA/IChuLmNvbnN1bWUocCksIFQpIDogKGEgPSBudWxsLCBJKHApKTtcbiAgfVxuICBmdW5jdGlvbiBiKHApIHtcbiAgICByZXR1cm4gcCA9PT0gbnVsbCB8fCBMKHApID8gdChwKSA6IHAgPT09IGEgPyAobi5jb25zdW1lKHApLCBSKSA6IChuLmNvbnN1bWUocCksIGIpO1xuICB9XG4gIGZ1bmN0aW9uIEkocCkge1xuICAgIHJldHVybiBwID09PSBudWxsIHx8IHAgPT09IDM0IHx8IHAgPT09IDM5IHx8IHAgPT09IDYwIHx8IHAgPT09IDYxIHx8IHAgPT09IDYyIHx8IHAgPT09IDk2IHx8IHNuKHApID8gXyhwKSA6IChuLmNvbnN1bWUocCksIEkpO1xuICB9XG4gIGZ1bmN0aW9uIFIocCkge1xuICAgIHJldHVybiBwID09PSA0NyB8fCBwID09PSA2MiB8fCBHKHApID8gdihwKSA6IHQocCk7XG4gIH1cbiAgZnVuY3Rpb24gTShwKSB7XG4gICAgcmV0dXJuIHAgPT09IDYyID8gKG4uY29uc3VtZShwKSwgWCkgOiB0KHApO1xuICB9XG4gIGZ1bmN0aW9uIFgocCkge1xuICAgIHJldHVybiBHKHApID8gKG4uY29uc3VtZShwKSwgWCkgOiBwID09PSBudWxsIHx8IEwocCkgPyBDKHApIDogdChwKTtcbiAgfVxuICBmdW5jdGlvbiBDKHApIHtcbiAgICByZXR1cm4gcCA9PT0gNDUgJiYgaSA9PT0gMiA/IChuLmNvbnN1bWUocCksIGVuKSA6IHAgPT09IDYwICYmIGkgPT09IDEgPyAobi5jb25zdW1lKHApLCB1bikgOiBwID09PSA2MiAmJiBpID09PSA0ID8gKG4uY29uc3VtZShwKSwgVykgOiBwID09PSA2MyAmJiBpID09PSAzID8gKG4uY29uc3VtZShwKSwgSikgOiBwID09PSA5MyAmJiBpID09PSA1ID8gKG4uY29uc3VtZShwKSwgcSkgOiBMKHApICYmIChpID09PSA2IHx8IGkgPT09IDcpID8gbi5jaGVjayhcbiAgICAgIERpLFxuICAgICAgVyxcbiAgICAgIEZcbiAgICApKHApIDogcCA9PT0gbnVsbCB8fCBMKHApID8gRihwKSA6IChuLmNvbnN1bWUocCksIEMpO1xuICB9XG4gIGZ1bmN0aW9uIEYocCkge1xuICAgIHJldHVybiBuLmV4aXQoXCJodG1sRmxvd0RhdGFcIiksIEIocCk7XG4gIH1cbiAgZnVuY3Rpb24gQihwKSB7XG4gICAgcmV0dXJuIHAgPT09IG51bGwgPyBmKHApIDogTChwKSA/IG4uYXR0ZW1wdChcbiAgICAgIHtcbiAgICAgICAgdG9rZW5pemU6IFosXG4gICAgICAgIHBhcnRpYWw6ICEwXG4gICAgICB9LFxuICAgICAgQixcbiAgICAgIGZcbiAgICApKHApIDogKG4uZW50ZXIoXCJodG1sRmxvd0RhdGFcIiksIEMocCkpO1xuICB9XG4gIGZ1bmN0aW9uIFoocCwga24sIFBuKSB7XG4gICAgcmV0dXJuIGJuO1xuICAgIGZ1bmN0aW9uIGJuKHJuKSB7XG4gICAgICByZXR1cm4gcC5lbnRlcihcImxpbmVFbmRpbmdcIiksIHAuY29uc3VtZShybiksIHAuZXhpdChcImxpbmVFbmRpbmdcIiksIFk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFkocm4pIHtcbiAgICAgIHJldHVybiByLnBhcnNlci5sYXp5W3Iubm93KCkubGluZV0gPyBQbihybikgOiBrbihybik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGVuKHApIHtcbiAgICByZXR1cm4gcCA9PT0gNDUgPyAobi5jb25zdW1lKHApLCBKKSA6IEMocCk7XG4gIH1cbiAgZnVuY3Rpb24gdW4ocCkge1xuICAgIHJldHVybiBwID09PSA0NyA/IChuLmNvbnN1bWUocCksIG8gPSBcIlwiLCB0bikgOiBDKHApO1xuICB9XG4gIGZ1bmN0aW9uIHRuKHApIHtcbiAgICByZXR1cm4gcCA9PT0gNjIgJiYgcnQuaW5jbHVkZXMoby50b0xvd2VyQ2FzZSgpKSA/IChuLmNvbnN1bWUocCksIFcpIDogZG4ocCkgJiYgby5sZW5ndGggPCA4ID8gKG4uY29uc3VtZShwKSwgbyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHApLCB0bikgOiBDKHApO1xuICB9XG4gIGZ1bmN0aW9uIHEocCkge1xuICAgIHJldHVybiBwID09PSA5MyA/IChuLmNvbnN1bWUocCksIEopIDogQyhwKTtcbiAgfVxuICBmdW5jdGlvbiBKKHApIHtcbiAgICByZXR1cm4gcCA9PT0gNjIgPyAobi5jb25zdW1lKHApLCBXKSA6IHAgPT09IDQ1ICYmIGkgPT09IDIgPyAobi5jb25zdW1lKHApLCBKKSA6IEMocCk7XG4gIH1cbiAgZnVuY3Rpb24gVyhwKSB7XG4gICAgcmV0dXJuIHAgPT09IG51bGwgfHwgTChwKSA/IChuLmV4aXQoXCJodG1sRmxvd0RhdGFcIiksIGYocCkpIDogKG4uY29uc3VtZShwKSwgVyk7XG4gIH1cbiAgZnVuY3Rpb24gZihwKSB7XG4gICAgcmV0dXJuIG4uZXhpdChcImh0bWxGbG93XCIpLCBlKHApO1xuICB9XG59XG5mdW5jdGlvbiBSaShuLCBlLCB0KSB7XG4gIHJldHVybiByO1xuICBmdW5jdGlvbiByKGkpIHtcbiAgICByZXR1cm4gbi5leGl0KFwiaHRtbEZsb3dEYXRhXCIpLCBuLmVudGVyKFwibGluZUVuZGluZ0JsYW5rXCIpLCBuLmNvbnN1bWUoaSksIG4uZXhpdChcImxpbmVFbmRpbmdCbGFua1wiKSwgbi5hdHRlbXB0KFpuLCBlLCB0KTtcbiAgfVxufVxuY29uc3QgX2kgPSB7XG4gIG5hbWU6IFwiaHRtbFRleHRcIixcbiAgdG9rZW5pemU6IE1pXG59O1xuZnVuY3Rpb24gTWkobiwgZSwgdCkge1xuICBjb25zdCByID0gdGhpcztcbiAgbGV0IGksIGwsIG8sIHU7XG4gIHJldHVybiBhO1xuICBmdW5jdGlvbiBhKGYpIHtcbiAgICByZXR1cm4gbi5lbnRlcihcImh0bWxUZXh0XCIpLCBuLmVudGVyKFwiaHRtbFRleHREYXRhXCIpLCBuLmNvbnN1bWUoZiksIGM7XG4gIH1cbiAgZnVuY3Rpb24gYyhmKSB7XG4gICAgcmV0dXJuIGYgPT09IDMzID8gKG4uY29uc3VtZShmKSwgcykgOiBmID09PSA0NyA/IChuLmNvbnN1bWUoZiksIEkpIDogZiA9PT0gNjMgPyAobi5jb25zdW1lKGYpLCBUKSA6IGRuKGYpID8gKG4uY29uc3VtZShmKSwgWCkgOiB0KGYpO1xuICB9XG4gIGZ1bmN0aW9uIHMoZikge1xuICAgIHJldHVybiBmID09PSA0NSA/IChuLmNvbnN1bWUoZiksIGgpIDogZiA9PT0gOTEgPyAobi5jb25zdW1lKGYpLCBsID0gXCJDREFUQVtcIiwgbyA9IDAsIHgpIDogZG4oZikgPyAobi5jb25zdW1lKGYpLCBfKSA6IHQoZik7XG4gIH1cbiAgZnVuY3Rpb24gaChmKSB7XG4gICAgcmV0dXJuIGYgPT09IDQ1ID8gKG4uY29uc3VtZShmKSwgZykgOiB0KGYpO1xuICB9XG4gIGZ1bmN0aW9uIGcoZikge1xuICAgIHJldHVybiBmID09PSBudWxsIHx8IGYgPT09IDYyID8gdChmKSA6IGYgPT09IDQ1ID8gKG4uY29uc3VtZShmKSwgZCkgOiBtKGYpO1xuICB9XG4gIGZ1bmN0aW9uIGQoZikge1xuICAgIHJldHVybiBmID09PSBudWxsIHx8IGYgPT09IDYyID8gdChmKSA6IG0oZik7XG4gIH1cbiAgZnVuY3Rpb24gbShmKSB7XG4gICAgcmV0dXJuIGYgPT09IG51bGwgPyB0KGYpIDogZiA9PT0gNDUgPyAobi5jb25zdW1lKGYpLCB5KSA6IEwoZikgPyAodSA9IG0sIHEoZikpIDogKG4uY29uc3VtZShmKSwgbSk7XG4gIH1cbiAgZnVuY3Rpb24geShmKSB7XG4gICAgcmV0dXJuIGYgPT09IDQ1ID8gKG4uY29uc3VtZShmKSwgVykgOiBtKGYpO1xuICB9XG4gIGZ1bmN0aW9uIHgoZikge1xuICAgIHJldHVybiBmID09PSBsLmNoYXJDb2RlQXQobysrKSA/IChuLmNvbnN1bWUoZiksIG8gPT09IGwubGVuZ3RoID8gdyA6IHgpIDogdChmKTtcbiAgfVxuICBmdW5jdGlvbiB3KGYpIHtcbiAgICByZXR1cm4gZiA9PT0gbnVsbCA/IHQoZikgOiBmID09PSA5MyA/IChuLmNvbnN1bWUoZiksIHYpIDogTChmKSA/ICh1ID0gdywgcShmKSkgOiAobi5jb25zdW1lKGYpLCB3KTtcbiAgfVxuICBmdW5jdGlvbiB2KGYpIHtcbiAgICByZXR1cm4gZiA9PT0gOTMgPyAobi5jb25zdW1lKGYpLCBBKSA6IHcoZik7XG4gIH1cbiAgZnVuY3Rpb24gQShmKSB7XG4gICAgcmV0dXJuIGYgPT09IDYyID8gVyhmKSA6IGYgPT09IDkzID8gKG4uY29uc3VtZShmKSwgQSkgOiB3KGYpO1xuICB9XG4gIGZ1bmN0aW9uIF8oZikge1xuICAgIHJldHVybiBmID09PSBudWxsIHx8IGYgPT09IDYyID8gVyhmKSA6IEwoZikgPyAodSA9IF8sIHEoZikpIDogKG4uY29uc3VtZShmKSwgXyk7XG4gIH1cbiAgZnVuY3Rpb24gVChmKSB7XG4gICAgcmV0dXJuIGYgPT09IG51bGwgPyB0KGYpIDogZiA9PT0gNjMgPyAobi5jb25zdW1lKGYpLCBiKSA6IEwoZikgPyAodSA9IFQsIHEoZikpIDogKG4uY29uc3VtZShmKSwgVCk7XG4gIH1cbiAgZnVuY3Rpb24gYihmKSB7XG4gICAgcmV0dXJuIGYgPT09IDYyID8gVyhmKSA6IFQoZik7XG4gIH1cbiAgZnVuY3Rpb24gSShmKSB7XG4gICAgcmV0dXJuIGRuKGYpID8gKG4uY29uc3VtZShmKSwgUikgOiB0KGYpO1xuICB9XG4gIGZ1bmN0aW9uIFIoZikge1xuICAgIHJldHVybiBmID09PSA0NSB8fCBvbihmKSA/IChuLmNvbnN1bWUoZiksIFIpIDogTShmKTtcbiAgfVxuICBmdW5jdGlvbiBNKGYpIHtcbiAgICByZXR1cm4gTChmKSA/ICh1ID0gTSwgcShmKSkgOiBHKGYpID8gKG4uY29uc3VtZShmKSwgTSkgOiBXKGYpO1xuICB9XG4gIGZ1bmN0aW9uIFgoZikge1xuICAgIHJldHVybiBmID09PSA0NSB8fCBvbihmKSA/IChuLmNvbnN1bWUoZiksIFgpIDogZiA9PT0gNDcgfHwgZiA9PT0gNjIgfHwgc24oZikgPyBDKGYpIDogdChmKTtcbiAgfVxuICBmdW5jdGlvbiBDKGYpIHtcbiAgICByZXR1cm4gZiA9PT0gNDcgPyAobi5jb25zdW1lKGYpLCBXKSA6IGYgPT09IDU4IHx8IGYgPT09IDk1IHx8IGRuKGYpID8gKG4uY29uc3VtZShmKSwgRikgOiBMKGYpID8gKHUgPSBDLCBxKGYpKSA6IEcoZikgPyAobi5jb25zdW1lKGYpLCBDKSA6IFcoZik7XG4gIH1cbiAgZnVuY3Rpb24gRihmKSB7XG4gICAgcmV0dXJuIGYgPT09IDQ1IHx8IGYgPT09IDQ2IHx8IGYgPT09IDU4IHx8IGYgPT09IDk1IHx8IG9uKGYpID8gKG4uY29uc3VtZShmKSwgRikgOiBCKGYpO1xuICB9XG4gIGZ1bmN0aW9uIEIoZikge1xuICAgIHJldHVybiBmID09PSA2MSA/IChuLmNvbnN1bWUoZiksIFopIDogTChmKSA/ICh1ID0gQiwgcShmKSkgOiBHKGYpID8gKG4uY29uc3VtZShmKSwgQikgOiBDKGYpO1xuICB9XG4gIGZ1bmN0aW9uIFooZikge1xuICAgIHJldHVybiBmID09PSBudWxsIHx8IGYgPT09IDYwIHx8IGYgPT09IDYxIHx8IGYgPT09IDYyIHx8IGYgPT09IDk2ID8gdChmKSA6IGYgPT09IDM0IHx8IGYgPT09IDM5ID8gKG4uY29uc3VtZShmKSwgaSA9IGYsIGVuKSA6IEwoZikgPyAodSA9IFosIHEoZikpIDogRyhmKSA/IChuLmNvbnN1bWUoZiksIFopIDogKG4uY29uc3VtZShmKSwgaSA9IHZvaWQgMCwgdG4pO1xuICB9XG4gIGZ1bmN0aW9uIGVuKGYpIHtcbiAgICByZXR1cm4gZiA9PT0gaSA/IChuLmNvbnN1bWUoZiksIHVuKSA6IGYgPT09IG51bGwgPyB0KGYpIDogTChmKSA/ICh1ID0gZW4sIHEoZikpIDogKG4uY29uc3VtZShmKSwgZW4pO1xuICB9XG4gIGZ1bmN0aW9uIHVuKGYpIHtcbiAgICByZXR1cm4gZiA9PT0gNjIgfHwgZiA9PT0gNDcgfHwgc24oZikgPyBDKGYpIDogdChmKTtcbiAgfVxuICBmdW5jdGlvbiB0bihmKSB7XG4gICAgcmV0dXJuIGYgPT09IG51bGwgfHwgZiA9PT0gMzQgfHwgZiA9PT0gMzkgfHwgZiA9PT0gNjAgfHwgZiA9PT0gNjEgfHwgZiA9PT0gOTYgPyB0KGYpIDogZiA9PT0gNjIgfHwgc24oZikgPyBDKGYpIDogKG4uY29uc3VtZShmKSwgdG4pO1xuICB9XG4gIGZ1bmN0aW9uIHEoZikge1xuICAgIHJldHVybiBuLmV4aXQoXCJodG1sVGV4dERhdGFcIiksIG4uZW50ZXIoXCJsaW5lRW5kaW5nXCIpLCBuLmNvbnN1bWUoZiksIG4uZXhpdChcImxpbmVFbmRpbmdcIiksIFUoXG4gICAgICBuLFxuICAgICAgSixcbiAgICAgIFwibGluZVByZWZpeFwiLFxuICAgICAgci5wYXJzZXIuY29uc3RydWN0cy5kaXNhYmxlLm51bGwuaW5jbHVkZXMoXCJjb2RlSW5kZW50ZWRcIikgPyB2b2lkIDAgOiA0XG4gICAgKTtcbiAgfVxuICBmdW5jdGlvbiBKKGYpIHtcbiAgICByZXR1cm4gbi5lbnRlcihcImh0bWxUZXh0RGF0YVwiKSwgdShmKTtcbiAgfVxuICBmdW5jdGlvbiBXKGYpIHtcbiAgICByZXR1cm4gZiA9PT0gNjIgPyAobi5jb25zdW1lKGYpLCBuLmV4aXQoXCJodG1sVGV4dERhdGFcIiksIG4uZXhpdChcImh0bWxUZXh0XCIpLCBlKSA6IHQoZik7XG4gIH1cbn1cbmNvbnN0IFBlID0ge1xuICBuYW1lOiBcImxhYmVsRW5kXCIsXG4gIHRva2VuaXplOiBVaSxcbiAgcmVzb2x2ZVRvOiBIaSxcbiAgcmVzb2x2ZUFsbDogJGlcbn0sIEJpID0ge1xuICB0b2tlbml6ZTogVmlcbn0sIE5pID0ge1xuICB0b2tlbml6ZTogcWlcbn0sIGppID0ge1xuICB0b2tlbml6ZTogV2lcbn07XG5mdW5jdGlvbiAkaShuKSB7XG4gIGxldCBlID0gLTEsIHQ7XG4gIGZvciAoOyArK2UgPCBuLmxlbmd0aDsgKVxuICAgIHQgPSBuW2VdWzFdLCAodC50eXBlID09PSBcImxhYmVsSW1hZ2VcIiB8fCB0LnR5cGUgPT09IFwibGFiZWxMaW5rXCIgfHwgdC50eXBlID09PSBcImxhYmVsRW5kXCIpICYmIChuLnNwbGljZShlICsgMSwgdC50eXBlID09PSBcImxhYmVsSW1hZ2VcIiA/IDQgOiAyKSwgdC50eXBlID0gXCJkYXRhXCIsIGUrKyk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gSGkobiwgZSkge1xuICBsZXQgdCA9IG4ubGVuZ3RoLCByID0gMCwgaSwgbCwgbywgdTtcbiAgZm9yICg7IHQtLTsgKVxuICAgIGlmIChpID0gblt0XVsxXSwgbCkge1xuICAgICAgaWYgKGkudHlwZSA9PT0gXCJsaW5rXCIgfHwgaS50eXBlID09PSBcImxhYmVsTGlua1wiICYmIGkuX2luYWN0aXZlKVxuICAgICAgICBicmVhaztcbiAgICAgIG5bdF1bMF0gPT09IFwiZW50ZXJcIiAmJiBpLnR5cGUgPT09IFwibGFiZWxMaW5rXCIgJiYgKGkuX2luYWN0aXZlID0gITApO1xuICAgIH0gZWxzZSBpZiAobykge1xuICAgICAgaWYgKG5bdF1bMF0gPT09IFwiZW50ZXJcIiAmJiAoaS50eXBlID09PSBcImxhYmVsSW1hZ2VcIiB8fCBpLnR5cGUgPT09IFwibGFiZWxMaW5rXCIpICYmICFpLl9iYWxhbmNlZCAmJiAobCA9IHQsIGkudHlwZSAhPT0gXCJsYWJlbExpbmtcIikpIHtcbiAgICAgICAgciA9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgaS50eXBlID09PSBcImxhYmVsRW5kXCIgJiYgKG8gPSB0KTtcbiAgY29uc3QgYSA9IHtcbiAgICB0eXBlOiBuW2xdWzFdLnR5cGUgPT09IFwibGFiZWxMaW5rXCIgPyBcImxpbmtcIiA6IFwiaW1hZ2VcIixcbiAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgbltsXVsxXS5zdGFydCksXG4gICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBuW24ubGVuZ3RoIC0gMV1bMV0uZW5kKVxuICB9LCBjID0ge1xuICAgIHR5cGU6IFwibGFiZWxcIixcbiAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgbltsXVsxXS5zdGFydCksXG4gICAgZW5kOiBPYmplY3QuYXNzaWduKHt9LCBuW29dWzFdLmVuZClcbiAgfSwgcyA9IHtcbiAgICB0eXBlOiBcImxhYmVsVGV4dFwiLFxuICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBuW2wgKyByICsgMl1bMV0uZW5kKSxcbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIG5bbyAtIDJdWzFdLnN0YXJ0KVxuICB9O1xuICByZXR1cm4gdSA9IFtcbiAgICBbXCJlbnRlclwiLCBhLCBlXSxcbiAgICBbXCJlbnRlclwiLCBjLCBlXVxuICBdLCB1ID0gYW4odSwgbi5zbGljZShsICsgMSwgbCArIHIgKyAzKSksIHUgPSBhbih1LCBbW1wiZW50ZXJcIiwgcywgZV1dKSwgdSA9IGFuKFxuICAgIHUsXG4gICAgQ2UoXG4gICAgICBlLnBhcnNlci5jb25zdHJ1Y3RzLmluc2lkZVNwYW4ubnVsbCxcbiAgICAgIG4uc2xpY2UobCArIHIgKyA0LCBvIC0gMyksXG4gICAgICBlXG4gICAgKVxuICApLCB1ID0gYW4odSwgW1xuICAgIFtcImV4aXRcIiwgcywgZV0sXG4gICAgbltvIC0gMl0sXG4gICAgbltvIC0gMV0sXG4gICAgW1wiZXhpdFwiLCBjLCBlXVxuICBdKSwgdSA9IGFuKHUsIG4uc2xpY2UobyArIDEpKSwgdSA9IGFuKHUsIFtbXCJleGl0XCIsIGEsIGVdXSksIGduKG4sIGwsIG4ubGVuZ3RoLCB1KSwgbjtcbn1cbmZ1bmN0aW9uIFVpKG4sIGUsIHQpIHtcbiAgY29uc3QgciA9IHRoaXM7XG4gIGxldCBpID0gci5ldmVudHMubGVuZ3RoLCBsLCBvO1xuICBmb3IgKDsgaS0tOyApXG4gICAgaWYgKChyLmV2ZW50c1tpXVsxXS50eXBlID09PSBcImxhYmVsSW1hZ2VcIiB8fCByLmV2ZW50c1tpXVsxXS50eXBlID09PSBcImxhYmVsTGlua1wiKSAmJiAhci5ldmVudHNbaV1bMV0uX2JhbGFuY2VkKSB7XG4gICAgICBsID0gci5ldmVudHNbaV1bMV07XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiB1O1xuICBmdW5jdGlvbiB1KHMpIHtcbiAgICByZXR1cm4gbCA/IGwuX2luYWN0aXZlID8gYyhzKSA6IChvID0gci5wYXJzZXIuZGVmaW5lZC5pbmNsdWRlcyhcbiAgICAgIExuKFxuICAgICAgICByLnNsaWNlU2VyaWFsaXplKHtcbiAgICAgICAgICBzdGFydDogbC5lbmQsXG4gICAgICAgICAgZW5kOiByLm5vdygpXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgKSwgbi5lbnRlcihcImxhYmVsRW5kXCIpLCBuLmVudGVyKFwibGFiZWxNYXJrZXJcIiksIG4uY29uc3VtZShzKSwgbi5leGl0KFwibGFiZWxNYXJrZXJcIiksIG4uZXhpdChcImxhYmVsRW5kXCIpLCBhKSA6IHQocyk7XG4gIH1cbiAgZnVuY3Rpb24gYShzKSB7XG4gICAgcmV0dXJuIHMgPT09IDQwID8gbi5hdHRlbXB0KFxuICAgICAgQmksXG4gICAgICBlLFxuICAgICAgbyA/IGUgOiBjXG4gICAgKShzKSA6IHMgPT09IDkxID8gbi5hdHRlbXB0KFxuICAgICAgTmksXG4gICAgICBlLFxuICAgICAgbyA/IG4uYXR0ZW1wdChqaSwgZSwgYykgOiBjXG4gICAgKShzKSA6IG8gPyBlKHMpIDogYyhzKTtcbiAgfVxuICBmdW5jdGlvbiBjKHMpIHtcbiAgICByZXR1cm4gbC5fYmFsYW5jZWQgPSAhMCwgdChzKTtcbiAgfVxufVxuZnVuY3Rpb24gVmkobiwgZSwgdCkge1xuICByZXR1cm4gcjtcbiAgZnVuY3Rpb24gcihhKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJyZXNvdXJjZVwiKSwgbi5lbnRlcihcInJlc291cmNlTWFya2VyXCIpLCBuLmNvbnN1bWUoYSksIG4uZXhpdChcInJlc291cmNlTWFya2VyXCIpLCAkbihuLCBpKTtcbiAgfVxuICBmdW5jdGlvbiBpKGEpIHtcbiAgICByZXR1cm4gYSA9PT0gNDEgPyB1KGEpIDogX3QoXG4gICAgICBuLFxuICAgICAgbCxcbiAgICAgIHQsXG4gICAgICBcInJlc291cmNlRGVzdGluYXRpb25cIixcbiAgICAgIFwicmVzb3VyY2VEZXN0aW5hdGlvbkxpdGVyYWxcIixcbiAgICAgIFwicmVzb3VyY2VEZXN0aW5hdGlvbkxpdGVyYWxNYXJrZXJcIixcbiAgICAgIFwicmVzb3VyY2VEZXN0aW5hdGlvblJhd1wiLFxuICAgICAgXCJyZXNvdXJjZURlc3RpbmF0aW9uU3RyaW5nXCIsXG4gICAgICAzMlxuICAgICkoYSk7XG4gIH1cbiAgZnVuY3Rpb24gbChhKSB7XG4gICAgcmV0dXJuIHNuKGEpID8gJG4obiwgbykoYSkgOiB1KGEpO1xuICB9XG4gIGZ1bmN0aW9uIG8oYSkge1xuICAgIHJldHVybiBhID09PSAzNCB8fCBhID09PSAzOSB8fCBhID09PSA0MCA/IEJ0KFxuICAgICAgbixcbiAgICAgICRuKG4sIHUpLFxuICAgICAgdCxcbiAgICAgIFwicmVzb3VyY2VUaXRsZVwiLFxuICAgICAgXCJyZXNvdXJjZVRpdGxlTWFya2VyXCIsXG4gICAgICBcInJlc291cmNlVGl0bGVTdHJpbmdcIlxuICAgICkoYSkgOiB1KGEpO1xuICB9XG4gIGZ1bmN0aW9uIHUoYSkge1xuICAgIHJldHVybiBhID09PSA0MSA/IChuLmVudGVyKFwicmVzb3VyY2VNYXJrZXJcIiksIG4uY29uc3VtZShhKSwgbi5leGl0KFwicmVzb3VyY2VNYXJrZXJcIiksIG4uZXhpdChcInJlc291cmNlXCIpLCBlKSA6IHQoYSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHFpKG4sIGUsIHQpIHtcbiAgY29uc3QgciA9IHRoaXM7XG4gIHJldHVybiBpO1xuICBmdW5jdGlvbiBpKG8pIHtcbiAgICByZXR1cm4gTXQuY2FsbChcbiAgICAgIHIsXG4gICAgICBuLFxuICAgICAgbCxcbiAgICAgIHQsXG4gICAgICBcInJlZmVyZW5jZVwiLFxuICAgICAgXCJyZWZlcmVuY2VNYXJrZXJcIixcbiAgICAgIFwicmVmZXJlbmNlU3RyaW5nXCJcbiAgICApKG8pO1xuICB9XG4gIGZ1bmN0aW9uIGwobykge1xuICAgIHJldHVybiByLnBhcnNlci5kZWZpbmVkLmluY2x1ZGVzKFxuICAgICAgTG4oXG4gICAgICAgIHIuc2xpY2VTZXJpYWxpemUoci5ldmVudHNbci5ldmVudHMubGVuZ3RoIC0gMV1bMV0pLnNsaWNlKDEsIC0xKVxuICAgICAgKVxuICAgICkgPyBlKG8pIDogdChvKTtcbiAgfVxufVxuZnVuY3Rpb24gV2kobiwgZSwgdCkge1xuICByZXR1cm4gcjtcbiAgZnVuY3Rpb24gcihsKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJyZWZlcmVuY2VcIiksIG4uZW50ZXIoXCJyZWZlcmVuY2VNYXJrZXJcIiksIG4uY29uc3VtZShsKSwgbi5leGl0KFwicmVmZXJlbmNlTWFya2VyXCIpLCBpO1xuICB9XG4gIGZ1bmN0aW9uIGkobCkge1xuICAgIHJldHVybiBsID09PSA5MyA/IChuLmVudGVyKFwicmVmZXJlbmNlTWFya2VyXCIpLCBuLmNvbnN1bWUobCksIG4uZXhpdChcInJlZmVyZW5jZU1hcmtlclwiKSwgbi5leGl0KFwicmVmZXJlbmNlXCIpLCBlKSA6IHQobCk7XG4gIH1cbn1cbmNvbnN0IFlpID0ge1xuICBuYW1lOiBcImxhYmVsU3RhcnRJbWFnZVwiLFxuICB0b2tlbml6ZTogUWksXG4gIHJlc29sdmVBbGw6IFBlLnJlc29sdmVBbGxcbn07XG5mdW5jdGlvbiBRaShuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB0aGlzO1xuICByZXR1cm4gaTtcbiAgZnVuY3Rpb24gaSh1KSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJsYWJlbEltYWdlXCIpLCBuLmVudGVyKFwibGFiZWxJbWFnZU1hcmtlclwiKSwgbi5jb25zdW1lKHUpLCBuLmV4aXQoXCJsYWJlbEltYWdlTWFya2VyXCIpLCBsO1xuICB9XG4gIGZ1bmN0aW9uIGwodSkge1xuICAgIHJldHVybiB1ID09PSA5MSA/IChuLmVudGVyKFwibGFiZWxNYXJrZXJcIiksIG4uY29uc3VtZSh1KSwgbi5leGl0KFwibGFiZWxNYXJrZXJcIiksIG4uZXhpdChcImxhYmVsSW1hZ2VcIiksIG8pIDogdCh1KTtcbiAgfVxuICBmdW5jdGlvbiBvKHUpIHtcbiAgICByZXR1cm4gdSA9PT0gOTQgJiYgXCJfaGlkZGVuRm9vdG5vdGVTdXBwb3J0XCIgaW4gci5wYXJzZXIuY29uc3RydWN0cyA/IHQodSkgOiBlKHUpO1xuICB9XG59XG5jb25zdCBYaSA9IHtcbiAgbmFtZTogXCJsYWJlbFN0YXJ0TGlua1wiLFxuICB0b2tlbml6ZTogS2ksXG4gIHJlc29sdmVBbGw6IFBlLnJlc29sdmVBbGxcbn07XG5mdW5jdGlvbiBLaShuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB0aGlzO1xuICByZXR1cm4gaTtcbiAgZnVuY3Rpb24gaShvKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJsYWJlbExpbmtcIiksIG4uZW50ZXIoXCJsYWJlbE1hcmtlclwiKSwgbi5jb25zdW1lKG8pLCBuLmV4aXQoXCJsYWJlbE1hcmtlclwiKSwgbi5leGl0KFwibGFiZWxMaW5rXCIpLCBsO1xuICB9XG4gIGZ1bmN0aW9uIGwobykge1xuICAgIHJldHVybiBvID09PSA5NCAmJiBcIl9oaWRkZW5Gb290bm90ZVN1cHBvcnRcIiBpbiByLnBhcnNlci5jb25zdHJ1Y3RzID8gdChvKSA6IGUobyk7XG4gIH1cbn1cbmNvbnN0IGNlID0ge1xuICBuYW1lOiBcImxpbmVFbmRpbmdcIixcbiAgdG9rZW5pemU6IEdpXG59O1xuZnVuY3Rpb24gR2kobiwgZSkge1xuICByZXR1cm4gdDtcbiAgZnVuY3Rpb24gdChyKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJsaW5lRW5kaW5nXCIpLCBuLmNvbnN1bWUociksIG4uZXhpdChcImxpbmVFbmRpbmdcIiksIFUobiwgZSwgXCJsaW5lUHJlZml4XCIpO1xuICB9XG59XG5jb25zdCBRbiA9IHtcbiAgbmFtZTogXCJ0aGVtYXRpY0JyZWFrXCIsXG4gIHRva2VuaXplOiBaaVxufTtcbmZ1bmN0aW9uIFppKG4sIGUsIHQpIHtcbiAgbGV0IHIgPSAwLCBpO1xuICByZXR1cm4gbDtcbiAgZnVuY3Rpb24gbChhKSB7XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJ0aGVtYXRpY0JyZWFrXCIpLCBpID0gYSwgbyhhKTtcbiAgfVxuICBmdW5jdGlvbiBvKGEpIHtcbiAgICByZXR1cm4gYSA9PT0gaSA/IChuLmVudGVyKFwidGhlbWF0aWNCcmVha1NlcXVlbmNlXCIpLCB1KGEpKSA6IEcoYSkgPyBVKG4sIG8sIFwid2hpdGVzcGFjZVwiKShhKSA6IHIgPCAzIHx8IGEgIT09IG51bGwgJiYgIUwoYSkgPyB0KGEpIDogKG4uZXhpdChcInRoZW1hdGljQnJlYWtcIiksIGUoYSkpO1xuICB9XG4gIGZ1bmN0aW9uIHUoYSkge1xuICAgIHJldHVybiBhID09PSBpID8gKG4uY29uc3VtZShhKSwgcisrLCB1KSA6IChuLmV4aXQoXCJ0aGVtYXRpY0JyZWFrU2VxdWVuY2VcIiksIG8oYSkpO1xuICB9XG59XG5jb25zdCBubiA9IHtcbiAgbmFtZTogXCJsaXN0XCIsXG4gIHRva2VuaXplOiBlbCxcbiAgY29udGludWF0aW9uOiB7XG4gICAgdG9rZW5pemU6IHRsXG4gIH0sXG4gIGV4aXQ6IGlsXG59LCBKaSA9IHtcbiAgdG9rZW5pemU6IGxsLFxuICBwYXJ0aWFsOiAhMFxufSwgbmwgPSB7XG4gIHRva2VuaXplOiBybCxcbiAgcGFydGlhbDogITBcbn07XG5mdW5jdGlvbiBlbChuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB0aGlzLCBpID0gci5ldmVudHNbci5ldmVudHMubGVuZ3RoIC0gMV07XG4gIGxldCBsID0gaSAmJiBpWzFdLnR5cGUgPT09IFwibGluZVByZWZpeFwiID8gaVsyXS5zbGljZVNlcmlhbGl6ZShpWzFdLCAhMCkubGVuZ3RoIDogMCwgbyA9IDA7XG4gIHJldHVybiB1O1xuICBmdW5jdGlvbiB1KGQpIHtcbiAgICBjb25zdCBtID0gci5jb250YWluZXJTdGF0ZS50eXBlIHx8IChkID09PSA0MiB8fCBkID09PSA0MyB8fCBkID09PSA0NSA/IFwibGlzdFVub3JkZXJlZFwiIDogXCJsaXN0T3JkZXJlZFwiKTtcbiAgICBpZiAobSA9PT0gXCJsaXN0VW5vcmRlcmVkXCIgPyAhci5jb250YWluZXJTdGF0ZS5tYXJrZXIgfHwgZCA9PT0gci5jb250YWluZXJTdGF0ZS5tYXJrZXIgOiBnZShkKSkge1xuICAgICAgaWYgKHIuY29udGFpbmVyU3RhdGUudHlwZSB8fCAoci5jb250YWluZXJTdGF0ZS50eXBlID0gbSwgbi5lbnRlcihtLCB7XG4gICAgICAgIF9jb250YWluZXI6ICEwXG4gICAgICB9KSksIG0gPT09IFwibGlzdFVub3JkZXJlZFwiKVxuICAgICAgICByZXR1cm4gbi5lbnRlcihcImxpc3RJdGVtUHJlZml4XCIpLCBkID09PSA0MiB8fCBkID09PSA0NSA/IG4uY2hlY2soUW4sIHQsIGMpKGQpIDogYyhkKTtcbiAgICAgIGlmICghci5pbnRlcnJ1cHQgfHwgZCA9PT0gNDkpXG4gICAgICAgIHJldHVybiBuLmVudGVyKFwibGlzdEl0ZW1QcmVmaXhcIiksIG4uZW50ZXIoXCJsaXN0SXRlbVZhbHVlXCIpLCBhKGQpO1xuICAgIH1cbiAgICByZXR1cm4gdChkKTtcbiAgfVxuICBmdW5jdGlvbiBhKGQpIHtcbiAgICByZXR1cm4gZ2UoZCkgJiYgKytvIDwgMTAgPyAobi5jb25zdW1lKGQpLCBhKSA6ICghci5pbnRlcnJ1cHQgfHwgbyA8IDIpICYmIChyLmNvbnRhaW5lclN0YXRlLm1hcmtlciA/IGQgPT09IHIuY29udGFpbmVyU3RhdGUubWFya2VyIDogZCA9PT0gNDEgfHwgZCA9PT0gNDYpID8gKG4uZXhpdChcImxpc3RJdGVtVmFsdWVcIiksIGMoZCkpIDogdChkKTtcbiAgfVxuICBmdW5jdGlvbiBjKGQpIHtcbiAgICByZXR1cm4gbi5lbnRlcihcImxpc3RJdGVtTWFya2VyXCIpLCBuLmNvbnN1bWUoZCksIG4uZXhpdChcImxpc3RJdGVtTWFya2VyXCIpLCByLmNvbnRhaW5lclN0YXRlLm1hcmtlciA9IHIuY29udGFpbmVyU3RhdGUubWFya2VyIHx8IGQsIG4uY2hlY2soXG4gICAgICBabixcbiAgICAgIC8vIENhbuKAmXQgYmUgZW1wdHkgd2hlbiBpbnRlcnJ1cHRpbmcuXG4gICAgICByLmludGVycnVwdCA/IHQgOiBzLFxuICAgICAgbi5hdHRlbXB0KFxuICAgICAgICBKaSxcbiAgICAgICAgZyxcbiAgICAgICAgaFxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgZnVuY3Rpb24gcyhkKSB7XG4gICAgcmV0dXJuIHIuY29udGFpbmVyU3RhdGUuaW5pdGlhbEJsYW5rTGluZSA9ICEwLCBsKyssIGcoZCk7XG4gIH1cbiAgZnVuY3Rpb24gaChkKSB7XG4gICAgcmV0dXJuIEcoZCkgPyAobi5lbnRlcihcImxpc3RJdGVtUHJlZml4V2hpdGVzcGFjZVwiKSwgbi5jb25zdW1lKGQpLCBuLmV4aXQoXCJsaXN0SXRlbVByZWZpeFdoaXRlc3BhY2VcIiksIGcpIDogdChkKTtcbiAgfVxuICBmdW5jdGlvbiBnKGQpIHtcbiAgICByZXR1cm4gci5jb250YWluZXJTdGF0ZS5zaXplID0gbCArIHIuc2xpY2VTZXJpYWxpemUobi5leGl0KFwibGlzdEl0ZW1QcmVmaXhcIiksICEwKS5sZW5ndGgsIGUoZCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRsKG4sIGUsIHQpIHtcbiAgY29uc3QgciA9IHRoaXM7XG4gIHJldHVybiByLmNvbnRhaW5lclN0YXRlLl9jbG9zZUZsb3cgPSB2b2lkIDAsIG4uY2hlY2soWm4sIGksIGwpO1xuICBmdW5jdGlvbiBpKHUpIHtcbiAgICByZXR1cm4gci5jb250YWluZXJTdGF0ZS5mdXJ0aGVyQmxhbmtMaW5lcyA9IHIuY29udGFpbmVyU3RhdGUuZnVydGhlckJsYW5rTGluZXMgfHwgci5jb250YWluZXJTdGF0ZS5pbml0aWFsQmxhbmtMaW5lLCBVKFxuICAgICAgbixcbiAgICAgIGUsXG4gICAgICBcImxpc3RJdGVtSW5kZW50XCIsXG4gICAgICByLmNvbnRhaW5lclN0YXRlLnNpemUgKyAxXG4gICAgKSh1KTtcbiAgfVxuICBmdW5jdGlvbiBsKHUpIHtcbiAgICByZXR1cm4gci5jb250YWluZXJTdGF0ZS5mdXJ0aGVyQmxhbmtMaW5lcyB8fCAhRyh1KSA/IChyLmNvbnRhaW5lclN0YXRlLmZ1cnRoZXJCbGFua0xpbmVzID0gdm9pZCAwLCByLmNvbnRhaW5lclN0YXRlLmluaXRpYWxCbGFua0xpbmUgPSB2b2lkIDAsIG8odSkpIDogKHIuY29udGFpbmVyU3RhdGUuZnVydGhlckJsYW5rTGluZXMgPSB2b2lkIDAsIHIuY29udGFpbmVyU3RhdGUuaW5pdGlhbEJsYW5rTGluZSA9IHZvaWQgMCwgbi5hdHRlbXB0KG5sLCBlLCBvKSh1KSk7XG4gIH1cbiAgZnVuY3Rpb24gbyh1KSB7XG4gICAgcmV0dXJuIHIuY29udGFpbmVyU3RhdGUuX2Nsb3NlRmxvdyA9ICEwLCByLmludGVycnVwdCA9IHZvaWQgMCwgVShcbiAgICAgIG4sXG4gICAgICBuLmF0dGVtcHQobm4sIGUsIHQpLFxuICAgICAgXCJsaW5lUHJlZml4XCIsXG4gICAgICByLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcyhcImNvZGVJbmRlbnRlZFwiKSA/IHZvaWQgMCA6IDRcbiAgICApKHUpO1xuICB9XG59XG5mdW5jdGlvbiBybChuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB0aGlzO1xuICByZXR1cm4gVShcbiAgICBuLFxuICAgIGksXG4gICAgXCJsaXN0SXRlbUluZGVudFwiLFxuICAgIHIuY29udGFpbmVyU3RhdGUuc2l6ZSArIDFcbiAgKTtcbiAgZnVuY3Rpb24gaShsKSB7XG4gICAgY29uc3QgbyA9IHIuZXZlbnRzW3IuZXZlbnRzLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBvICYmIG9bMV0udHlwZSA9PT0gXCJsaXN0SXRlbUluZGVudFwiICYmIG9bMl0uc2xpY2VTZXJpYWxpemUob1sxXSwgITApLmxlbmd0aCA9PT0gci5jb250YWluZXJTdGF0ZS5zaXplID8gZShsKSA6IHQobCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlsKG4pIHtcbiAgbi5leGl0KHRoaXMuY29udGFpbmVyU3RhdGUudHlwZSk7XG59XG5mdW5jdGlvbiBsbChuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB0aGlzO1xuICByZXR1cm4gVShcbiAgICBuLFxuICAgIGksXG4gICAgXCJsaXN0SXRlbVByZWZpeFdoaXRlc3BhY2VcIixcbiAgICByLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcyhcImNvZGVJbmRlbnRlZFwiKSA/IHZvaWQgMCA6IDQgKyAxXG4gICk7XG4gIGZ1bmN0aW9uIGkobCkge1xuICAgIGNvbnN0IG8gPSByLmV2ZW50c1tyLmV2ZW50cy5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gIUcobCkgJiYgbyAmJiBvWzFdLnR5cGUgPT09IFwibGlzdEl0ZW1QcmVmaXhXaGl0ZXNwYWNlXCIgPyBlKGwpIDogdChsKTtcbiAgfVxufVxuY29uc3QgaXQgPSB7XG4gIG5hbWU6IFwic2V0ZXh0VW5kZXJsaW5lXCIsXG4gIHRva2VuaXplOiB1bCxcbiAgcmVzb2x2ZVRvOiBvbFxufTtcbmZ1bmN0aW9uIG9sKG4sIGUpIHtcbiAgbGV0IHQgPSBuLmxlbmd0aCwgciwgaSwgbDtcbiAgZm9yICg7IHQtLTsgKVxuICAgIGlmIChuW3RdWzBdID09PSBcImVudGVyXCIpIHtcbiAgICAgIGlmIChuW3RdWzFdLnR5cGUgPT09IFwiY29udGVudFwiKSB7XG4gICAgICAgIHIgPSB0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5bdF1bMV0udHlwZSA9PT0gXCJwYXJhZ3JhcGhcIiAmJiAoaSA9IHQpO1xuICAgIH0gZWxzZVxuICAgICAgblt0XVsxXS50eXBlID09PSBcImNvbnRlbnRcIiAmJiBuLnNwbGljZSh0LCAxKSwgIWwgJiYgblt0XVsxXS50eXBlID09PSBcImRlZmluaXRpb25cIiAmJiAobCA9IHQpO1xuICBjb25zdCBvID0ge1xuICAgIHR5cGU6IFwic2V0ZXh0SGVhZGluZ1wiLFxuICAgIHN0YXJ0OiBPYmplY3QuYXNzaWduKHt9LCBuW2ldWzFdLnN0YXJ0KSxcbiAgICBlbmQ6IE9iamVjdC5hc3NpZ24oe30sIG5bbi5sZW5ndGggLSAxXVsxXS5lbmQpXG4gIH07XG4gIHJldHVybiBuW2ldWzFdLnR5cGUgPSBcInNldGV4dEhlYWRpbmdUZXh0XCIsIGwgPyAobi5zcGxpY2UoaSwgMCwgW1wiZW50ZXJcIiwgbywgZV0pLCBuLnNwbGljZShsICsgMSwgMCwgW1wiZXhpdFwiLCBuW3JdWzFdLCBlXSksIG5bcl1bMV0uZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgbltsXVsxXS5lbmQpKSA6IG5bcl1bMV0gPSBvLCBuLnB1c2goW1wiZXhpdFwiLCBvLCBlXSksIG47XG59XG5mdW5jdGlvbiB1bChuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB0aGlzO1xuICBsZXQgaSA9IHIuZXZlbnRzLmxlbmd0aCwgbCwgbztcbiAgZm9yICg7IGktLTsgKVxuICAgIGlmIChyLmV2ZW50c1tpXVsxXS50eXBlICE9PSBcImxpbmVFbmRpbmdcIiAmJiByLmV2ZW50c1tpXVsxXS50eXBlICE9PSBcImxpbmVQcmVmaXhcIiAmJiByLmV2ZW50c1tpXVsxXS50eXBlICE9PSBcImNvbnRlbnRcIikge1xuICAgICAgbyA9IHIuZXZlbnRzW2ldWzFdLnR5cGUgPT09IFwicGFyYWdyYXBoXCI7XG4gICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiB1O1xuICBmdW5jdGlvbiB1KHMpIHtcbiAgICByZXR1cm4gIXIucGFyc2VyLmxhenlbci5ub3coKS5saW5lXSAmJiAoci5pbnRlcnJ1cHQgfHwgbykgPyAobi5lbnRlcihcInNldGV4dEhlYWRpbmdMaW5lXCIpLCBuLmVudGVyKFwic2V0ZXh0SGVhZGluZ0xpbmVTZXF1ZW5jZVwiKSwgbCA9IHMsIGEocykpIDogdChzKTtcbiAgfVxuICBmdW5jdGlvbiBhKHMpIHtcbiAgICByZXR1cm4gcyA9PT0gbCA/IChuLmNvbnN1bWUocyksIGEpIDogKG4uZXhpdChcInNldGV4dEhlYWRpbmdMaW5lU2VxdWVuY2VcIiksIFUobiwgYywgXCJsaW5lU3VmZml4XCIpKHMpKTtcbiAgfVxuICBmdW5jdGlvbiBjKHMpIHtcbiAgICByZXR1cm4gcyA9PT0gbnVsbCB8fCBMKHMpID8gKG4uZXhpdChcInNldGV4dEhlYWRpbmdMaW5lXCIpLCBlKHMpKSA6IHQocyk7XG4gIH1cbn1cbmNvbnN0IGFsID0ge1xuICB0b2tlbml6ZTogc2xcbn07XG5mdW5jdGlvbiBzbChuKSB7XG4gIGNvbnN0IGUgPSB0aGlzLCB0ID0gbi5hdHRlbXB0KFxuICAgIC8vIFRyeSB0byBwYXJzZSBhIGJsYW5rIGxpbmUuXG4gICAgWm4sXG4gICAgcixcbiAgICAvLyBUcnkgdG8gcGFyc2UgaW5pdGlhbCBmbG93IChlc3NlbnRpYWxseSwgb25seSBjb2RlKS5cbiAgICBuLmF0dGVtcHQoXG4gICAgICB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmZsb3dJbml0aWFsLFxuICAgICAgaSxcbiAgICAgIFUoXG4gICAgICAgIG4sXG4gICAgICAgIG4uYXR0ZW1wdChcbiAgICAgICAgICB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzLmZsb3csXG4gICAgICAgICAgaSxcbiAgICAgICAgICBuLmF0dGVtcHQoZ2ksIGkpXG4gICAgICAgICksXG4gICAgICAgIFwibGluZVByZWZpeFwiXG4gICAgICApXG4gICAgKVxuICApO1xuICByZXR1cm4gdDtcbiAgZnVuY3Rpb24gcihsKSB7XG4gICAgaWYgKGwgPT09IG51bGwpIHtcbiAgICAgIG4uY29uc3VtZShsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJsaW5lRW5kaW5nQmxhbmtcIiksIG4uY29uc3VtZShsKSwgbi5leGl0KFwibGluZUVuZGluZ0JsYW5rXCIpLCBlLmN1cnJlbnRDb25zdHJ1Y3QgPSB2b2lkIDAsIHQ7XG4gIH1cbiAgZnVuY3Rpb24gaShsKSB7XG4gICAgaWYgKGwgPT09IG51bGwpIHtcbiAgICAgIG4uY29uc3VtZShsKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIG4uZW50ZXIoXCJsaW5lRW5kaW5nXCIpLCBuLmNvbnN1bWUobCksIG4uZXhpdChcImxpbmVFbmRpbmdcIiksIGUuY3VycmVudENvbnN0cnVjdCA9IHZvaWQgMCwgdDtcbiAgfVxufVxuY29uc3QgY2wgPSB7XG4gIHJlc29sdmVBbGw6IGp0KClcbn0sIHBsID0gTnQoXCJzdHJpbmdcIiksIGZsID0gTnQoXCJ0ZXh0XCIpO1xuZnVuY3Rpb24gTnQobikge1xuICByZXR1cm4ge1xuICAgIHRva2VuaXplOiBlLFxuICAgIHJlc29sdmVBbGw6IGp0KFxuICAgICAgbiA9PT0gXCJ0ZXh0XCIgPyBobCA6IHZvaWQgMFxuICAgIClcbiAgfTtcbiAgZnVuY3Rpb24gZSh0KSB7XG4gICAgY29uc3QgciA9IHRoaXMsIGkgPSB0aGlzLnBhcnNlci5jb25zdHJ1Y3RzW25dLCBsID0gdC5hdHRlbXB0KGksIG8sIHUpO1xuICAgIHJldHVybiBvO1xuICAgIGZ1bmN0aW9uIG8ocykge1xuICAgICAgcmV0dXJuIGMocykgPyBsKHMpIDogdShzKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdShzKSB7XG4gICAgICBpZiAocyA9PT0gbnVsbCkge1xuICAgICAgICB0LmNvbnN1bWUocyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0LmVudGVyKFwiZGF0YVwiKSwgdC5jb25zdW1lKHMpLCBhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhKHMpIHtcbiAgICAgIHJldHVybiBjKHMpID8gKHQuZXhpdChcImRhdGFcIiksIGwocykpIDogKHQuY29uc3VtZShzKSwgYSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGMocykge1xuICAgICAgaWYgKHMgPT09IG51bGwpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGNvbnN0IGggPSBpW3NdO1xuICAgICAgbGV0IGcgPSAtMTtcbiAgICAgIGlmIChoKVxuICAgICAgICBmb3IgKDsgKytnIDwgaC5sZW5ndGg7ICkge1xuICAgICAgICAgIGNvbnN0IGQgPSBoW2ddO1xuICAgICAgICAgIGlmICghZC5wcmV2aW91cyB8fCBkLnByZXZpb3VzLmNhbGwociwgci5wcmV2aW91cykpXG4gICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGp0KG4pIHtcbiAgcmV0dXJuIGU7XG4gIGZ1bmN0aW9uIGUodCwgcikge1xuICAgIGxldCBpID0gLTEsIGw7XG4gICAgZm9yICg7ICsraSA8PSB0Lmxlbmd0aDsgKVxuICAgICAgbCA9PT0gdm9pZCAwID8gdFtpXSAmJiB0W2ldWzFdLnR5cGUgPT09IFwiZGF0YVwiICYmIChsID0gaSwgaSsrKSA6ICghdFtpXSB8fCB0W2ldWzFdLnR5cGUgIT09IFwiZGF0YVwiKSAmJiAoaSAhPT0gbCArIDIgJiYgKHRbbF1bMV0uZW5kID0gdFtpIC0gMV1bMV0uZW5kLCB0LnNwbGljZShsICsgMiwgaSAtIGwgLSAyKSwgaSA9IGwgKyAyKSwgbCA9IHZvaWQgMCk7XG4gICAgcmV0dXJuIG4gPyBuKHQsIHIpIDogdDtcbiAgfVxufVxuZnVuY3Rpb24gaGwobiwgZSkge1xuICBsZXQgdCA9IDA7XG4gIGZvciAoOyArK3QgPD0gbi5sZW5ndGg7IClcbiAgICBpZiAoKHQgPT09IG4ubGVuZ3RoIHx8IG5bdF1bMV0udHlwZSA9PT0gXCJsaW5lRW5kaW5nXCIpICYmIG5bdCAtIDFdWzFdLnR5cGUgPT09IFwiZGF0YVwiKSB7XG4gICAgICBjb25zdCByID0gblt0IC0gMV1bMV0sIGkgPSBlLnNsaWNlU3RyZWFtKHIpO1xuICAgICAgbGV0IGwgPSBpLmxlbmd0aCwgbyA9IC0xLCB1ID0gMCwgYTtcbiAgICAgIGZvciAoOyBsLS07ICkge1xuICAgICAgICBjb25zdCBjID0gaVtsXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBmb3IgKG8gPSBjLmxlbmd0aDsgYy5jaGFyQ29kZUF0KG8gLSAxKSA9PT0gMzI7IClcbiAgICAgICAgICAgIHUrKywgby0tO1xuICAgICAgICAgIGlmIChvKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgbyA9IC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT09IC0yKVxuICAgICAgICAgIGEgPSAhMCwgdSsrO1xuICAgICAgICBlbHNlIGlmIChjICE9PSAtMSkge1xuICAgICAgICAgIGwrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHUpIHtcbiAgICAgICAgY29uc3QgYyA9IHtcbiAgICAgICAgICB0eXBlOiB0ID09PSBuLmxlbmd0aCB8fCBhIHx8IHUgPCAyID8gXCJsaW5lU3VmZml4XCIgOiBcImhhcmRCcmVha1RyYWlsaW5nXCIsXG4gICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgIGxpbmU6IHIuZW5kLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IHIuZW5kLmNvbHVtbiAtIHUsXG4gICAgICAgICAgICBvZmZzZXQ6IHIuZW5kLm9mZnNldCAtIHUsXG4gICAgICAgICAgICBfaW5kZXg6IHIuc3RhcnQuX2luZGV4ICsgbCxcbiAgICAgICAgICAgIF9idWZmZXJJbmRleDogbCA/IG8gOiByLnN0YXJ0Ll9idWZmZXJJbmRleCArIG9cbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZDogT2JqZWN0LmFzc2lnbih7fSwgci5lbmQpXG4gICAgICAgIH07XG4gICAgICAgIHIuZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgYy5zdGFydCksIHIuc3RhcnQub2Zmc2V0ID09PSByLmVuZC5vZmZzZXQgPyBPYmplY3QuYXNzaWduKHIsIGMpIDogKG4uc3BsaWNlKFxuICAgICAgICAgIHQsXG4gICAgICAgICAgMCxcbiAgICAgICAgICBbXCJlbnRlclwiLCBjLCBlXSxcbiAgICAgICAgICBbXCJleGl0XCIsIGMsIGVdXG4gICAgICAgICksIHQgKz0gMik7XG4gICAgICB9XG4gICAgICB0Kys7XG4gICAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIG1sKG4sIGUsIHQpIHtcbiAgbGV0IHIgPSBPYmplY3QuYXNzaWduKFxuICAgIHQgPyBPYmplY3QuYXNzaWduKHt9LCB0KSA6IHtcbiAgICAgIGxpbmU6IDEsXG4gICAgICBjb2x1bW46IDEsXG4gICAgICBvZmZzZXQ6IDBcbiAgICB9LFxuICAgIHtcbiAgICAgIF9pbmRleDogMCxcbiAgICAgIF9idWZmZXJJbmRleDogLTFcbiAgICB9XG4gICk7XG4gIGNvbnN0IGkgPSB7fSwgbCA9IFtdO1xuICBsZXQgbyA9IFtdLCB1ID0gW107XG4gIGNvbnN0IGEgPSB7XG4gICAgY29uc3VtZTogdixcbiAgICBlbnRlcjogQSxcbiAgICBleGl0OiBfLFxuICAgIGF0dGVtcHQ6IEkoVCksXG4gICAgY2hlY2s6IEkoYiksXG4gICAgaW50ZXJydXB0OiBJKGIsIHtcbiAgICAgIGludGVycnVwdDogITBcbiAgICB9KVxuICB9LCBjID0ge1xuICAgIHByZXZpb3VzOiBudWxsLFxuICAgIGNvZGU6IG51bGwsXG4gICAgY29udGFpbmVyU3RhdGU6IHt9LFxuICAgIGV2ZW50czogW10sXG4gICAgcGFyc2VyOiBuLFxuICAgIHNsaWNlU3RyZWFtOiBkLFxuICAgIHNsaWNlU2VyaWFsaXplOiBnLFxuICAgIG5vdzogbSxcbiAgICBkZWZpbmVTa2lwOiB5LFxuICAgIHdyaXRlOiBoXG4gIH07XG4gIGxldCBzID0gZS50b2tlbml6ZS5jYWxsKGMsIGEpO1xuICByZXR1cm4gZS5yZXNvbHZlQWxsICYmIGwucHVzaChlKSwgYztcbiAgZnVuY3Rpb24gaChDKSB7XG4gICAgcmV0dXJuIG8gPSBhbihvLCBDKSwgeCgpLCBvW28ubGVuZ3RoIC0gMV0gIT09IG51bGwgPyBbXSA6IChSKGUsIDApLCBjLmV2ZW50cyA9IENlKGwsIGMuZXZlbnRzLCBjKSwgYy5ldmVudHMpO1xuICB9XG4gIGZ1bmN0aW9uIGcoQywgRikge1xuICAgIHJldHVybiBnbChkKEMpLCBGKTtcbiAgfVxuICBmdW5jdGlvbiBkKEMpIHtcbiAgICByZXR1cm4gZGwobywgQyk7XG4gIH1cbiAgZnVuY3Rpb24gbSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcik7XG4gIH1cbiAgZnVuY3Rpb24geShDKSB7XG4gICAgaVtDLmxpbmVdID0gQy5jb2x1bW4sIFgoKTtcbiAgfVxuICBmdW5jdGlvbiB4KCkge1xuICAgIGxldCBDO1xuICAgIGZvciAoOyByLl9pbmRleCA8IG8ubGVuZ3RoOyApIHtcbiAgICAgIGNvbnN0IEYgPSBvW3IuX2luZGV4XTtcbiAgICAgIGlmICh0eXBlb2YgRiA9PSBcInN0cmluZ1wiKVxuICAgICAgICBmb3IgKEMgPSByLl9pbmRleCwgci5fYnVmZmVySW5kZXggPCAwICYmIChyLl9idWZmZXJJbmRleCA9IDApOyByLl9pbmRleCA9PT0gQyAmJiByLl9idWZmZXJJbmRleCA8IEYubGVuZ3RoOyApXG4gICAgICAgICAgdyhGLmNoYXJDb2RlQXQoci5fYnVmZmVySW5kZXgpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdyhGKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdyhDKSB7XG4gICAgcyA9IHMoQyk7XG4gIH1cbiAgZnVuY3Rpb24gdihDKSB7XG4gICAgTChDKSA/IChyLmxpbmUrKywgci5jb2x1bW4gPSAxLCByLm9mZnNldCArPSBDID09PSAtMyA/IDIgOiAxLCBYKCkpIDogQyAhPT0gLTEgJiYgKHIuY29sdW1uKyssIHIub2Zmc2V0KyspLCByLl9idWZmZXJJbmRleCA8IDAgPyByLl9pbmRleCsrIDogKHIuX2J1ZmZlckluZGV4KyssIHIuX2J1ZmZlckluZGV4ID09PSBvW3IuX2luZGV4XS5sZW5ndGggJiYgKHIuX2J1ZmZlckluZGV4ID0gLTEsIHIuX2luZGV4KyspKSwgYy5wcmV2aW91cyA9IEM7XG4gIH1cbiAgZnVuY3Rpb24gQShDLCBGKSB7XG4gICAgY29uc3QgQiA9IEYgfHwge307XG4gICAgcmV0dXJuIEIudHlwZSA9IEMsIEIuc3RhcnQgPSBtKCksIGMuZXZlbnRzLnB1c2goW1wiZW50ZXJcIiwgQiwgY10pLCB1LnB1c2goQiksIEI7XG4gIH1cbiAgZnVuY3Rpb24gXyhDKSB7XG4gICAgY29uc3QgRiA9IHUucG9wKCk7XG4gICAgcmV0dXJuIEYuZW5kID0gbSgpLCBjLmV2ZW50cy5wdXNoKFtcImV4aXRcIiwgRiwgY10pLCBGO1xuICB9XG4gIGZ1bmN0aW9uIFQoQywgRikge1xuICAgIFIoQywgRi5mcm9tKTtcbiAgfVxuICBmdW5jdGlvbiBiKEMsIEYpIHtcbiAgICBGLnJlc3RvcmUoKTtcbiAgfVxuICBmdW5jdGlvbiBJKEMsIEYpIHtcbiAgICByZXR1cm4gQjtcbiAgICBmdW5jdGlvbiBCKFosIGVuLCB1bikge1xuICAgICAgbGV0IHRuLCBxLCBKLCBXO1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoWikgPyAoXG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDEgKi9cbiAgICAgICAgcChaKVxuICAgICAgKSA6IFwidG9rZW5pemVcIiBpbiBaID8gcChbWl0pIDogZihaKTtcbiAgICAgIGZ1bmN0aW9uIGYoWSkge1xuICAgICAgICByZXR1cm4gcm47XG4gICAgICAgIGZ1bmN0aW9uIHJuKGhuKSB7XG4gICAgICAgICAgY29uc3Qgd24gPSBobiAhPT0gbnVsbCAmJiBZW2huXSwgU24gPSBobiAhPT0gbnVsbCAmJiBZLm51bGwsIFJuID0gW1xuICAgICAgICAgICAgLy8gVG8gZG86IGFkZCBtb3JlIGV4dGVuc2lvbiB0ZXN0cy5cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbiAgICAgICAgICAgIC4uLkFycmF5LmlzQXJyYXkod24pID8gd24gOiB3biA/IFt3bl0gOiBbXSxcbiAgICAgICAgICAgIC4uLkFycmF5LmlzQXJyYXkoU24pID8gU24gOiBTbiA/IFtTbl0gOiBbXVxuICAgICAgICAgIF07XG4gICAgICAgICAgcmV0dXJuIHAoUm4pKGhuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcChZKSB7XG4gICAgICAgIHJldHVybiB0biA9IFksIHEgPSAwLCBZLmxlbmd0aCA9PT0gMCA/IHVuIDoga24oWVtxXSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBrbihZKSB7XG4gICAgICAgIHJldHVybiBybjtcbiAgICAgICAgZnVuY3Rpb24gcm4oaG4pIHtcbiAgICAgICAgICByZXR1cm4gVyA9IE0oKSwgSiA9IFksIFkucGFydGlhbCB8fCAoYy5jdXJyZW50Q29uc3RydWN0ID0gWSksIFkubmFtZSAmJiBjLnBhcnNlci5jb25zdHJ1Y3RzLmRpc2FibGUubnVsbC5pbmNsdWRlcyhZLm5hbWUpID8gYm4oKSA6IFkudG9rZW5pemUuY2FsbChcbiAgICAgICAgICAgIC8vIElmIHdlIGRvIGhhdmUgZmllbGRzLCBjcmVhdGUgYW4gb2JqZWN0IHcvIGBjb250ZXh0YCBhcyBpdHNcbiAgICAgICAgICAgIC8vIHByb3RvdHlwZS5cbiAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIGEg4oCcbGl2ZSBiaW5kaW5n4oCdLCB3aGljaCBpcyBuZWVkZWQgZm9yIGBpbnRlcnJ1cHRgLlxuICAgICAgICAgICAgRiA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShjKSwgRikgOiBjLFxuICAgICAgICAgICAgYSxcbiAgICAgICAgICAgIFBuLFxuICAgICAgICAgICAgYm5cbiAgICAgICAgICApKGhuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gUG4oWSkge1xuICAgICAgICByZXR1cm4gQyhKLCBXKSwgZW47XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBibihZKSB7XG4gICAgICAgIHJldHVybiBXLnJlc3RvcmUoKSwgKytxIDwgdG4ubGVuZ3RoID8ga24odG5bcV0pIDogdW47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIFIoQywgRikge1xuICAgIEMucmVzb2x2ZUFsbCAmJiAhbC5pbmNsdWRlcyhDKSAmJiBsLnB1c2goQyksIEMucmVzb2x2ZSAmJiBnbihcbiAgICAgIGMuZXZlbnRzLFxuICAgICAgRixcbiAgICAgIGMuZXZlbnRzLmxlbmd0aCAtIEYsXG4gICAgICBDLnJlc29sdmUoYy5ldmVudHMuc2xpY2UoRiksIGMpXG4gICAgKSwgQy5yZXNvbHZlVG8gJiYgKGMuZXZlbnRzID0gQy5yZXNvbHZlVG8oYy5ldmVudHMsIGMpKTtcbiAgfVxuICBmdW5jdGlvbiBNKCkge1xuICAgIGNvbnN0IEMgPSBtKCksIEYgPSBjLnByZXZpb3VzLCBCID0gYy5jdXJyZW50Q29uc3RydWN0LCBaID0gYy5ldmVudHMubGVuZ3RoLCBlbiA9IEFycmF5LmZyb20odSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RvcmU6IHVuLFxuICAgICAgZnJvbTogWlxuICAgIH07XG4gICAgZnVuY3Rpb24gdW4oKSB7XG4gICAgICByID0gQywgYy5wcmV2aW91cyA9IEYsIGMuY3VycmVudENvbnN0cnVjdCA9IEIsIGMuZXZlbnRzLmxlbmd0aCA9IFosIHUgPSBlbiwgWCgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBYKCkge1xuICAgIHIubGluZSBpbiBpICYmIHIuY29sdW1uIDwgMiAmJiAoci5jb2x1bW4gPSBpW3IubGluZV0sIHIub2Zmc2V0ICs9IGlbci5saW5lXSAtIDEpO1xuICB9XG59XG5mdW5jdGlvbiBkbChuLCBlKSB7XG4gIGNvbnN0IHQgPSBlLnN0YXJ0Ll9pbmRleCwgciA9IGUuc3RhcnQuX2J1ZmZlckluZGV4LCBpID0gZS5lbmQuX2luZGV4LCBsID0gZS5lbmQuX2J1ZmZlckluZGV4O1xuICBsZXQgbztcbiAgcmV0dXJuIHQgPT09IGkgPyBvID0gW25bdF0uc2xpY2UociwgbCldIDogKG8gPSBuLnNsaWNlKHQsIGkpLCByID4gLTEgJiYgKG9bMF0gPSBvWzBdLnNsaWNlKHIpKSwgbCA+IDAgJiYgby5wdXNoKG5baV0uc2xpY2UoMCwgbCkpKSwgbztcbn1cbmZ1bmN0aW9uIGdsKG4sIGUpIHtcbiAgbGV0IHQgPSAtMTtcbiAgY29uc3QgciA9IFtdO1xuICBsZXQgaTtcbiAgZm9yICg7ICsrdCA8IG4ubGVuZ3RoOyApIHtcbiAgICBjb25zdCBsID0gblt0XTtcbiAgICBsZXQgbztcbiAgICBpZiAodHlwZW9mIGwgPT0gXCJzdHJpbmdcIilcbiAgICAgIG8gPSBsO1xuICAgIGVsc2VcbiAgICAgIHN3aXRjaCAobCkge1xuICAgICAgICBjYXNlIC01OiB7XG4gICAgICAgICAgbyA9IFwiXFxyXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAtNDoge1xuICAgICAgICAgIG8gPSBgXG5gO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgLTM6IHtcbiAgICAgICAgICBvID0gYFxcclxuYDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIC0yOiB7XG4gICAgICAgICAgbyA9IGUgPyBcIiBcIiA6IFwiXHRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIC0xOiB7XG4gICAgICAgICAgaWYgKCFlICYmIGkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBvID0gXCIgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvID0gU3RyaW5nLmZyb21DaGFyQ29kZShsKTtcbiAgICAgIH1cbiAgICBpID0gbCA9PT0gLTIsIHIucHVzaChvKTtcbiAgfVxuICByZXR1cm4gci5qb2luKFwiXCIpO1xufVxuY29uc3QgeWwgPSB7XG4gIFs0Ml06IG5uLFxuICBbNDNdOiBubixcbiAgWzQ1XTogbm4sXG4gIFs0OF06IG5uLFxuICBbNDldOiBubixcbiAgWzUwXTogbm4sXG4gIFs1MV06IG5uLFxuICBbNTJdOiBubixcbiAgWzUzXTogbm4sXG4gIFs1NF06IG5uLFxuICBbNTVdOiBubixcbiAgWzU2XTogbm4sXG4gIFs1N106IG5uLFxuICBbNjJdOiBEdFxufSwgeGwgPSB7XG4gIFs5MV06IHdpXG59LCBrbCA9IHtcbiAgWy0yXTogc2UsXG4gIFstMV06IHNlLFxuICBbMzJdOiBzZVxufSwgYmwgPSB7XG4gIFszNV06IEZpLFxuICBbNDJdOiBRbixcbiAgWzQ1XTogW2l0LCBRbl0sXG4gIFs2MF06IExpLFxuICBbNjFdOiBpdCxcbiAgWzk1XTogUW4sXG4gIFs5Nl06IHR0LFxuICBbMTI2XTogdHRcbn0sIHdsID0ge1xuICBbMzhdOiB6dCxcbiAgWzkyXTogdnRcbn0sIFNsID0ge1xuICBbLTVdOiBjZSxcbiAgWy00XTogY2UsXG4gIFstM106IGNlLFxuICBbMzNdOiBZaSxcbiAgWzM4XTogenQsXG4gIFs0Ml06IHhlLFxuICBbNjBdOiBbSnIsIF9pXSxcbiAgWzkxXTogWGksXG4gIFs5Ml06IFtBaSwgdnRdLFxuICBbOTNdOiBQZSxcbiAgWzk1XTogeGUsXG4gIFs5Nl06IHBpXG59LCBFbCA9IHtcbiAgbnVsbDogW3hlLCBjbF1cbn0sIENsID0ge1xuICBudWxsOiBbNDIsIDk1XVxufSwgQWwgPSB7XG4gIG51bGw6IFtdXG59LCBQbCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGF0dGVudGlvbk1hcmtlcnM6IENsLFxuICBjb250ZW50SW5pdGlhbDogeGwsXG4gIGRpc2FibGU6IEFsLFxuICBkb2N1bWVudDogeWwsXG4gIGZsb3c6IGJsLFxuICBmbG93SW5pdGlhbDoga2wsXG4gIGluc2lkZVNwYW46IEVsLFxuICBzdHJpbmc6IHdsLFxuICB0ZXh0OiBTbFxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbmZ1bmN0aW9uIEZsKG4gPSB7fSkge1xuICBjb25zdCBlID0gQnIoXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBTYW1lIGFzIGFib3ZlLlxuICAgIFtQbF0uY29uY2F0KG4uZXh0ZW5zaW9ucyB8fCBbXSlcbiAgKSwgdCA9IHtcbiAgICBkZWZpbmVkOiBbXSxcbiAgICBsYXp5OiB7fSxcbiAgICBjb25zdHJ1Y3RzOiBlLFxuICAgIGNvbnRlbnQ6IHIoV3IpLFxuICAgIGRvY3VtZW50OiByKFFyKSxcbiAgICBmbG93OiByKGFsKSxcbiAgICBzdHJpbmc6IHIocGwpLFxuICAgIHRleHQ6IHIoZmwpXG4gIH07XG4gIHJldHVybiB0O1xuICBmdW5jdGlvbiByKGkpIHtcbiAgICByZXR1cm4gbDtcbiAgICBmdW5jdGlvbiBsKG8pIHtcbiAgICAgIHJldHVybiBtbCh0LCBpLCBvKTtcbiAgICB9XG4gIH1cbn1cbmNvbnN0IGx0ID0gL1tcXDBcXHRcXG5cXHJdL2c7XG5mdW5jdGlvbiBUbCgpIHtcbiAgbGV0IG4gPSAxLCBlID0gXCJcIiwgdCA9ICEwLCByO1xuICByZXR1cm4gaTtcbiAgZnVuY3Rpb24gaShsLCBvLCB1KSB7XG4gICAgY29uc3QgYSA9IFtdO1xuICAgIGxldCBjLCBzLCBoLCBnLCBkO1xuICAgIGZvciAobCA9IGUgKyBsLnRvU3RyaW5nKG8pLCBoID0gMCwgZSA9IFwiXCIsIHQgJiYgKGwuY2hhckNvZGVBdCgwKSA9PT0gNjUyNzkgJiYgaCsrLCB0ID0gdm9pZCAwKTsgaCA8IGwubGVuZ3RoOyApIHtcbiAgICAgIGlmIChsdC5sYXN0SW5kZXggPSBoLCBjID0gbHQuZXhlYyhsKSwgZyA9IGMgJiYgYy5pbmRleCAhPT0gdm9pZCAwID8gYy5pbmRleCA6IGwubGVuZ3RoLCBkID0gbC5jaGFyQ29kZUF0KGcpLCAhYykge1xuICAgICAgICBlID0gbC5zbGljZShoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZCA9PT0gMTAgJiYgaCA9PT0gZyAmJiByKVxuICAgICAgICBhLnB1c2goLTMpLCByID0gdm9pZCAwO1xuICAgICAgZWxzZVxuICAgICAgICBzd2l0Y2ggKHIgJiYgKGEucHVzaCgtNSksIHIgPSB2b2lkIDApLCBoIDwgZyAmJiAoYS5wdXNoKGwuc2xpY2UoaCwgZykpLCBuICs9IGcgLSBoKSwgZCkge1xuICAgICAgICAgIGNhc2UgMDoge1xuICAgICAgICAgICAgYS5wdXNoKDY1NTMzKSwgbisrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgOToge1xuICAgICAgICAgICAgZm9yIChzID0gTWF0aC5jZWlsKG4gLyA0KSAqIDQsIGEucHVzaCgtMik7IG4rKyA8IHM7IClcbiAgICAgICAgICAgICAgYS5wdXNoKC0xKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDEwOiB7XG4gICAgICAgICAgICBhLnB1c2goLTQpLCBuID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgciA9ICEwLCBuID0gMTtcbiAgICAgICAgfVxuICAgICAgaCA9IGcgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gdSAmJiAociAmJiBhLnB1c2goLTUpLCBlICYmIGEucHVzaChlKSwgYS5wdXNoKG51bGwpKSwgYTtcbiAgfVxufVxuZnVuY3Rpb24gSWwobikge1xuICBmb3IgKDsgIVJ0KG4pOyApXG4gICAgO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uICR0KG4sIGUpIHtcbiAgY29uc3QgdCA9IE51bWJlci5wYXJzZUludChuLCBlKTtcbiAgcmV0dXJuIChcbiAgICAvLyBDMCBleGNlcHQgZm9yIEhULCBMRiwgRkYsIENSLCBzcGFjZVxuICAgIHQgPCA5IHx8IHQgPT09IDExIHx8IHQgPiAxMyAmJiB0IDwgMzIgfHwgLy8gQ29udHJvbCBjaGFyYWN0ZXIgKERFTCkgb2YgdGhlIGJhc2ljIGJsb2NrIGFuZCBDMSBjb250cm9scy5cbiAgICB0ID4gMTI2ICYmIHQgPCAxNjAgfHwgLy8gTG9uZSBoaWdoIHN1cnJvZ2F0ZXMgYW5kIGxvdyBzdXJyb2dhdGVzLlxuICAgIHQgPiA1NTI5NSAmJiB0IDwgNTczNDQgfHwgLy8gTm9uY2hhcmFjdGVycy5cbiAgICB0ID4gNjQ5NzUgJiYgdCA8IDY1MDA4IHx8ICh0ICYgNjU1MzUpID09PSA2NTUzNSB8fCAodCAmIDY1NTM1KSA9PT0gNjU1MzQgfHwgLy8gT3V0IG9mIHJhbmdlXG4gICAgdCA+IDExMTQxMTEgPyBcIu+/vVwiIDogU3RyaW5nLmZyb21DaGFyQ29kZSh0KVxuICApO1xufVxuY29uc3QgT2wgPSAvXFxcXChbIS0vOi1AWy1gey1+XSl8JigjKD86XFxkezEsN318eFtcXGRhLWZdezEsNn0pfFtcXGRhLXpdezEsMzF9KTsvZ2k7XG5mdW5jdGlvbiBMbChuKSB7XG4gIHJldHVybiBuLnJlcGxhY2UoT2wsIERsKTtcbn1cbmZ1bmN0aW9uIERsKG4sIGUsIHQpIHtcbiAgaWYgKGUpXG4gICAgcmV0dXJuIGU7XG4gIGlmICh0LmNoYXJDb2RlQXQoMCkgPT09IDM1KSB7XG4gICAgY29uc3QgaSA9IHQuY2hhckNvZGVBdCgxKSwgbCA9IGkgPT09IDEyMCB8fCBpID09PSA4ODtcbiAgICByZXR1cm4gJHQodC5zbGljZShsID8gMiA6IDEpLCBsID8gMTYgOiAxMCk7XG4gIH1cbiAgcmV0dXJuIEFlKHQpIHx8IG47XG59XG5mdW5jdGlvbiBYbihuKSB7XG4gIHJldHVybiAhbiB8fCB0eXBlb2YgbiAhPSBcIm9iamVjdFwiID8gXCJcIiA6IFwicG9zaXRpb25cIiBpbiBuIHx8IFwidHlwZVwiIGluIG4gPyBvdChuLnBvc2l0aW9uKSA6IFwic3RhcnRcIiBpbiBuIHx8IFwiZW5kXCIgaW4gbiA/IG90KG4pIDogXCJsaW5lXCIgaW4gbiB8fCBcImNvbHVtblwiIGluIG4gPyBrZShuKSA6IFwiXCI7XG59XG5mdW5jdGlvbiBrZShuKSB7XG4gIHJldHVybiB1dChuICYmIG4ubGluZSkgKyBcIjpcIiArIHV0KG4gJiYgbi5jb2x1bW4pO1xufVxuZnVuY3Rpb24gb3Qobikge1xuICByZXR1cm4ga2UobiAmJiBuLnN0YXJ0KSArIFwiLVwiICsga2UobiAmJiBuLmVuZCk7XG59XG5mdW5jdGlvbiB1dChuKSB7XG4gIHJldHVybiBuICYmIHR5cGVvZiBuID09IFwibnVtYmVyXCIgPyBuIDogMTtcbn1cbmNvbnN0IEh0ID0ge30uaGFzT3duUHJvcGVydHksIHZsID0gKFxuICAvKipcbiAgICogQHR5cGUgeyhcbiAgICogICAoKHZhbHVlOiBWYWx1ZSwgZW5jb2Rpbmc6IEVuY29kaW5nLCBvcHRpb25zPzogT3B0aW9ucyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFJvb3QpICZcbiAgICogICAoKHZhbHVlOiBWYWx1ZSwgb3B0aW9ucz86IE9wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBSb290KVxuICAgKiApfVxuICAgKi9cbiAgLyoqXG4gICAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlXG4gICAqIEBwYXJhbSB7RW5jb2RpbmcgfCBPcHRpb25zIHwgbnVsbCB8IHVuZGVmaW5lZH0gW2VuY29kaW5nXVxuICAgKiBAcGFyYW0ge09wdGlvbnMgfCBudWxsIHwgdW5kZWZpbmVkfSBbb3B0aW9uc11cbiAgICogQHJldHVybnMge1Jvb3R9XG4gICAqL1xuICBmdW5jdGlvbihuLCBlLCB0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlICE9IFwic3RyaW5nXCIgJiYgKHQgPSBlLCBlID0gdm9pZCAwKSwgemwodCkoXG4gICAgICBJbChcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogbWljcm9tYXJrIHR5cGVzIG5lZWQgdG8gYWNjZXB0IGBudWxsYC5cbiAgICAgICAgRmwodCkuZG9jdW1lbnQoKS53cml0ZShUbCgpKG4sIGUsICEwKSlcbiAgICAgIClcbiAgICApO1xuICB9XG4pO1xuZnVuY3Rpb24gemwobikge1xuICBjb25zdCBlID0ge1xuICAgIHRyYW5zZm9ybXM6IFtdLFxuICAgIGNhbkNvbnRhaW5Fb2xzOiBbXCJlbXBoYXNpc1wiLCBcImZyYWdtZW50XCIsIFwiaGVhZGluZ1wiLCBcInBhcmFncmFwaFwiLCBcInN0cm9uZ1wiXSxcbiAgICBlbnRlcjoge1xuICAgICAgYXV0b2xpbms6IHUoRGUpLFxuICAgICAgYXV0b2xpbmtQcm90b2NvbDogQyxcbiAgICAgIGF1dG9saW5rRW1haWw6IEMsXG4gICAgICBhdHhIZWFkaW5nOiB1KEZuKSxcbiAgICAgIGJsb2NrUXVvdGU6IHUoUm4pLFxuICAgICAgY2hhcmFjdGVyRXNjYXBlOiBDLFxuICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlOiBDLFxuICAgICAgY29kZUZlbmNlZDogdShWbiksXG4gICAgICBjb2RlRmVuY2VkRmVuY2VJbmZvOiBhLFxuICAgICAgY29kZUZlbmNlZEZlbmNlTWV0YTogYSxcbiAgICAgIGNvZGVJbmRlbnRlZDogdShWbiwgYSksXG4gICAgICBjb2RlVGV4dDogdShlZSwgYSksXG4gICAgICBjb2RlVGV4dERhdGE6IEMsXG4gICAgICBkYXRhOiBDLFxuICAgICAgY29kZUZsb3dWYWx1ZTogQyxcbiAgICAgIGRlZmluaXRpb246IHUoUCksXG4gICAgICBkZWZpbml0aW9uRGVzdGluYXRpb25TdHJpbmc6IGEsXG4gICAgICBkZWZpbml0aW9uTGFiZWxTdHJpbmc6IGEsXG4gICAgICBkZWZpbml0aW9uVGl0bGVTdHJpbmc6IGEsXG4gICAgICBlbXBoYXNpczogdShfbiksXG4gICAgICBoYXJkQnJlYWtFc2NhcGU6IHUoTW4pLFxuICAgICAgaGFyZEJyZWFrVHJhaWxpbmc6IHUoTW4pLFxuICAgICAgaHRtbEZsb3c6IHUoTGUsIGEpLFxuICAgICAgaHRtbEZsb3dEYXRhOiBDLFxuICAgICAgaHRtbFRleHQ6IHUoTGUsIGEpLFxuICAgICAgaHRtbFRleHREYXRhOiBDLFxuICAgICAgaW1hZ2U6IHUoc3IpLFxuICAgICAgbGFiZWw6IGEsXG4gICAgICBsaW5rOiB1KERlKSxcbiAgICAgIGxpc3RJdGVtOiB1KGNyKSxcbiAgICAgIGxpc3RJdGVtVmFsdWU6IG0sXG4gICAgICBsaXN0T3JkZXJlZDogdSh2ZSwgZCksXG4gICAgICBsaXN0VW5vcmRlcmVkOiB1KHZlKSxcbiAgICAgIHBhcmFncmFwaDogdShwciksXG4gICAgICByZWZlcmVuY2U6IGJuLFxuICAgICAgcmVmZXJlbmNlU3RyaW5nOiBhLFxuICAgICAgcmVzb3VyY2VEZXN0aW5hdGlvblN0cmluZzogYSxcbiAgICAgIHJlc291cmNlVGl0bGVTdHJpbmc6IGEsXG4gICAgICBzZXRleHRIZWFkaW5nOiB1KEZuKSxcbiAgICAgIHN0cm9uZzogdShmciksXG4gICAgICB0aGVtYXRpY0JyZWFrOiB1KG1yKVxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgYXR4SGVhZGluZzogcygpLFxuICAgICAgYXR4SGVhZGluZ1NlcXVlbmNlOiBJLFxuICAgICAgYXV0b2xpbms6IHMoKSxcbiAgICAgIGF1dG9saW5rRW1haWw6IFNuLFxuICAgICAgYXV0b2xpbmtQcm90b2NvbDogd24sXG4gICAgICBibG9ja1F1b3RlOiBzKCksXG4gICAgICBjaGFyYWN0ZXJFc2NhcGVWYWx1ZTogRixcbiAgICAgIGNoYXJhY3RlclJlZmVyZW5jZU1hcmtlckhleGFkZWNpbWFsOiBybixcbiAgICAgIGNoYXJhY3RlclJlZmVyZW5jZU1hcmtlck51bWVyaWM6IHJuLFxuICAgICAgY2hhcmFjdGVyUmVmZXJlbmNlVmFsdWU6IGhuLFxuICAgICAgY29kZUZlbmNlZDogcyh2KSxcbiAgICAgIGNvZGVGZW5jZWRGZW5jZTogdyxcbiAgICAgIGNvZGVGZW5jZWRGZW5jZUluZm86IHksXG4gICAgICBjb2RlRmVuY2VkRmVuY2VNZXRhOiB4LFxuICAgICAgY29kZUZsb3dWYWx1ZTogRixcbiAgICAgIGNvZGVJbmRlbnRlZDogcyhBKSxcbiAgICAgIGNvZGVUZXh0OiBzKHRuKSxcbiAgICAgIGNvZGVUZXh0RGF0YTogRixcbiAgICAgIGRhdGE6IEYsXG4gICAgICBkZWZpbml0aW9uOiBzKCksXG4gICAgICBkZWZpbml0aW9uRGVzdGluYXRpb25TdHJpbmc6IGIsXG4gICAgICBkZWZpbml0aW9uTGFiZWxTdHJpbmc6IF8sXG4gICAgICBkZWZpbml0aW9uVGl0bGVTdHJpbmc6IFQsXG4gICAgICBlbXBoYXNpczogcygpLFxuICAgICAgaGFyZEJyZWFrRXNjYXBlOiBzKFopLFxuICAgICAgaGFyZEJyZWFrVHJhaWxpbmc6IHMoWiksXG4gICAgICBodG1sRmxvdzogcyhlbiksXG4gICAgICBodG1sRmxvd0RhdGE6IEYsXG4gICAgICBodG1sVGV4dDogcyh1biksXG4gICAgICBodG1sVGV4dERhdGE6IEYsXG4gICAgICBpbWFnZTogcyhKKSxcbiAgICAgIGxhYmVsOiBmLFxuICAgICAgbGFiZWxUZXh0OiBXLFxuICAgICAgbGluZUVuZGluZzogQixcbiAgICAgIGxpbms6IHMocSksXG4gICAgICBsaXN0SXRlbTogcygpLFxuICAgICAgbGlzdE9yZGVyZWQ6IHMoKSxcbiAgICAgIGxpc3RVbm9yZGVyZWQ6IHMoKSxcbiAgICAgIHBhcmFncmFwaDogcygpLFxuICAgICAgcmVmZXJlbmNlU3RyaW5nOiBZLFxuICAgICAgcmVzb3VyY2VEZXN0aW5hdGlvblN0cmluZzogcCxcbiAgICAgIHJlc291cmNlVGl0bGVTdHJpbmc6IGtuLFxuICAgICAgcmVzb3VyY2U6IFBuLFxuICAgICAgc2V0ZXh0SGVhZGluZzogcyhYKSxcbiAgICAgIHNldGV4dEhlYWRpbmdMaW5lU2VxdWVuY2U6IE0sXG4gICAgICBzZXRleHRIZWFkaW5nVGV4dDogUixcbiAgICAgIHN0cm9uZzogcygpLFxuICAgICAgdGhlbWF0aWNCcmVhazogcygpXG4gICAgfVxuICB9O1xuICBVdChlLCAobiB8fCB7fSkubWRhc3RFeHRlbnNpb25zIHx8IFtdKTtcbiAgY29uc3QgdCA9IHt9O1xuICByZXR1cm4gcjtcbiAgZnVuY3Rpb24gcihrKSB7XG4gICAgbGV0IEUgPSB7XG4gICAgICB0eXBlOiBcInJvb3RcIixcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH07XG4gICAgY29uc3QgTyA9IHtcbiAgICAgIHN0YWNrOiBbRV0sXG4gICAgICB0b2tlblN0YWNrOiBbXSxcbiAgICAgIGNvbmZpZzogZSxcbiAgICAgIGVudGVyOiBjLFxuICAgICAgZXhpdDogaCxcbiAgICAgIGJ1ZmZlcjogYSxcbiAgICAgIHJlc3VtZTogZyxcbiAgICAgIHNldERhdGE6IGwsXG4gICAgICBnZXREYXRhOiBvXG4gICAgfSwgJCA9IFtdO1xuICAgIGxldCBIID0gLTE7XG4gICAgZm9yICg7ICsrSCA8IGsubGVuZ3RoOyApXG4gICAgICBpZiAoa1tIXVsxXS50eXBlID09PSBcImxpc3RPcmRlcmVkXCIgfHwga1tIXVsxXS50eXBlID09PSBcImxpc3RVbm9yZGVyZWRcIilcbiAgICAgICAgaWYgKGtbSF1bMF0gPT09IFwiZW50ZXJcIilcbiAgICAgICAgICAkLnB1c2goSCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGZuID0gJC5wb3AoKTtcbiAgICAgICAgICBIID0gaShrLCBmbiwgSCk7XG4gICAgICAgIH1cbiAgICBmb3IgKEggPSAtMTsgKytIIDwgay5sZW5ndGg7ICkge1xuICAgICAgY29uc3QgZm4gPSBlW2tbSF1bMF1dO1xuICAgICAgSHQuY2FsbChmbiwga1tIXVsxXS50eXBlKSAmJiBmbltrW0hdWzFdLnR5cGVdLmNhbGwoXG4gICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAge1xuICAgICAgICAgICAgc2xpY2VTZXJpYWxpemU6IGtbSF1bMl0uc2xpY2VTZXJpYWxpemVcbiAgICAgICAgICB9LFxuICAgICAgICAgIE9cbiAgICAgICAgKSxcbiAgICAgICAga1tIXVsxXVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKE8udG9rZW5TdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBmbiA9IE8udG9rZW5TdGFja1tPLnRva2VuU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAoZm5bMV0gfHwgYXQpLmNhbGwoTywgdm9pZCAwLCBmblswXSk7XG4gICAgfVxuICAgIGZvciAoRS5wb3NpdGlvbiA9IHtcbiAgICAgIHN0YXJ0OiBDbihcbiAgICAgICAgay5sZW5ndGggPiAwID8ga1swXVsxXS5zdGFydCA6IHtcbiAgICAgICAgICBsaW5lOiAxLFxuICAgICAgICAgIGNvbHVtbjogMSxcbiAgICAgICAgICBvZmZzZXQ6IDBcbiAgICAgICAgfVxuICAgICAgKSxcbiAgICAgIGVuZDogQ24oXG4gICAgICAgIGsubGVuZ3RoID4gMCA/IGtbay5sZW5ndGggLSAyXVsxXS5lbmQgOiB7XG4gICAgICAgICAgbGluZTogMSxcbiAgICAgICAgICBjb2x1bW46IDEsXG4gICAgICAgICAgb2Zmc2V0OiAwXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9LCBIID0gLTE7ICsrSCA8IGUudHJhbnNmb3Jtcy5sZW5ndGg7IClcbiAgICAgIEUgPSBlLnRyYW5zZm9ybXNbSF0oRSkgfHwgRTtcbiAgICByZXR1cm4gRTtcbiAgfVxuICBmdW5jdGlvbiBpKGssIEUsIE8pIHtcbiAgICBsZXQgJCA9IEUgLSAxLCBIID0gLTEsIGZuID0gITEsIEVuLCB5biwgQm4sIE5uO1xuICAgIGZvciAoOyArKyQgPD0gTzsgKSB7XG4gICAgICBjb25zdCBRID0ga1skXTtcbiAgICAgIGlmIChRWzFdLnR5cGUgPT09IFwibGlzdFVub3JkZXJlZFwiIHx8IFFbMV0udHlwZSA9PT0gXCJsaXN0T3JkZXJlZFwiIHx8IFFbMV0udHlwZSA9PT0gXCJibG9ja1F1b3RlXCIgPyAoUVswXSA9PT0gXCJlbnRlclwiID8gSCsrIDogSC0tLCBObiA9IHZvaWQgMCkgOiBRWzFdLnR5cGUgPT09IFwibGluZUVuZGluZ0JsYW5rXCIgPyBRWzBdID09PSBcImVudGVyXCIgJiYgKEVuICYmICFObiAmJiAhSCAmJiAhQm4gJiYgKEJuID0gJCksIE5uID0gdm9pZCAwKSA6IFFbMV0udHlwZSA9PT0gXCJsaW5lUHJlZml4XCIgfHwgUVsxXS50eXBlID09PSBcImxpc3RJdGVtVmFsdWVcIiB8fCBRWzFdLnR5cGUgPT09IFwibGlzdEl0ZW1NYXJrZXJcIiB8fCBRWzFdLnR5cGUgPT09IFwibGlzdEl0ZW1QcmVmaXhcIiB8fCBRWzFdLnR5cGUgPT09IFwibGlzdEl0ZW1QcmVmaXhXaGl0ZXNwYWNlXCIgfHwgKE5uID0gdm9pZCAwKSwgIUggJiYgUVswXSA9PT0gXCJlbnRlclwiICYmIFFbMV0udHlwZSA9PT0gXCJsaXN0SXRlbVByZWZpeFwiIHx8IEggPT09IC0xICYmIFFbMF0gPT09IFwiZXhpdFwiICYmIChRWzFdLnR5cGUgPT09IFwibGlzdFVub3JkZXJlZFwiIHx8IFFbMV0udHlwZSA9PT0gXCJsaXN0T3JkZXJlZFwiKSkge1xuICAgICAgICBpZiAoRW4pIHtcbiAgICAgICAgICBsZXQgdGUgPSAkO1xuICAgICAgICAgIGZvciAoeW4gPSB2b2lkIDA7IHRlLS07ICkge1xuICAgICAgICAgICAgY29uc3QgeG4gPSBrW3RlXTtcbiAgICAgICAgICAgIGlmICh4blsxXS50eXBlID09PSBcImxpbmVFbmRpbmdcIiB8fCB4blsxXS50eXBlID09PSBcImxpbmVFbmRpbmdCbGFua1wiKSB7XG4gICAgICAgICAgICAgIGlmICh4blswXSA9PT0gXCJleGl0XCIpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIHluICYmIChrW3luXVsxXS50eXBlID0gXCJsaW5lRW5kaW5nQmxhbmtcIiwgZm4gPSAhMCksIHhuWzFdLnR5cGUgPSBcImxpbmVFbmRpbmdcIiwgeW4gPSB0ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoISh4blsxXS50eXBlID09PSBcImxpbmVQcmVmaXhcIiB8fCB4blsxXS50eXBlID09PSBcImJsb2NrUXVvdGVQcmVmaXhcIiB8fCB4blsxXS50eXBlID09PSBcImJsb2NrUXVvdGVQcmVmaXhXaGl0ZXNwYWNlXCIgfHwgeG5bMV0udHlwZSA9PT0gXCJibG9ja1F1b3RlTWFya2VyXCIgfHwgeG5bMV0udHlwZSA9PT0gXCJsaXN0SXRlbUluZGVudFwiKSlcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIEJuICYmICgheW4gfHwgQm4gPCB5bikgJiYgKEVuLl9zcHJlYWQgPSAhMCksIEVuLmVuZCA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIHluID8ga1t5bl1bMV0uc3RhcnQgOiBRWzFdLmVuZFxuICAgICAgICAgICksIGsuc3BsaWNlKHluIHx8ICQsIDAsIFtcImV4aXRcIiwgRW4sIFFbMl1dKSwgJCsrLCBPKys7XG4gICAgICAgIH1cbiAgICAgICAgUVsxXS50eXBlID09PSBcImxpc3RJdGVtUHJlZml4XCIgJiYgKEVuID0ge1xuICAgICAgICAgIHR5cGU6IFwibGlzdEl0ZW1cIixcbiAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFBhdGNoZWRcbiAgICAgICAgICBfc3ByZWFkOiAhMSxcbiAgICAgICAgICBzdGFydDogT2JqZWN0LmFzc2lnbih7fSwgUVsxXS5zdGFydClcbiAgICAgICAgfSwgay5zcGxpY2UoJCwgMCwgW1wiZW50ZXJcIiwgRW4sIFFbMl1dKSwgJCsrLCBPKyssIEJuID0gdm9pZCAwLCBObiA9ICEwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtbRV1bMV0uX3NwcmVhZCA9IGZuLCBPO1xuICB9XG4gIGZ1bmN0aW9uIGwoaywgRSkge1xuICAgIHRba10gPSBFO1xuICB9XG4gIGZ1bmN0aW9uIG8oaykge1xuICAgIHJldHVybiB0W2tdO1xuICB9XG4gIGZ1bmN0aW9uIHUoaywgRSkge1xuICAgIHJldHVybiBPO1xuICAgIGZ1bmN0aW9uIE8oJCkge1xuICAgICAgYy5jYWxsKHRoaXMsIGsoJCksICQpLCBFICYmIEUuY2FsbCh0aGlzLCAkKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYSgpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goe1xuICAgICAgdHlwZTogXCJmcmFnbWVudFwiLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYyhrLCBFLCBPKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXS5jaGlsZHJlbi5wdXNoKGspLCB0aGlzLnN0YWNrLnB1c2goayksIHRoaXMudG9rZW5TdGFjay5wdXNoKFtFLCBPXSksIGsucG9zaXRpb24gPSB7XG4gICAgICBzdGFydDogQ24oRS5zdGFydClcbiAgICB9LCBrO1xuICB9XG4gIGZ1bmN0aW9uIHMoaykge1xuICAgIHJldHVybiBFO1xuICAgIGZ1bmN0aW9uIEUoTykge1xuICAgICAgayAmJiBrLmNhbGwodGhpcywgTyksIGguY2FsbCh0aGlzLCBPKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaChrLCBFKSB7XG4gICAgY29uc3QgTyA9IHRoaXMuc3RhY2sucG9wKCksICQgPSB0aGlzLnRva2VuU3RhY2sucG9wKCk7XG4gICAgaWYgKCQpXG4gICAgICAkWzBdLnR5cGUgIT09IGsudHlwZSAmJiAoRSA/IEUuY2FsbCh0aGlzLCBrLCAkWzBdKSA6ICgkWzFdIHx8IGF0KS5jYWxsKHRoaXMsIGssICRbMF0pKTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IGNsb3NlIGBcIiArIGsudHlwZSArIFwiYCAoXCIgKyBYbih7XG4gICAgICAgICAgc3RhcnQ6IGsuc3RhcnQsXG4gICAgICAgICAgZW5kOiBrLmVuZFxuICAgICAgICB9KSArIFwiKTogaXTigJlzIG5vdCBvcGVuXCJcbiAgICAgICk7XG4gICAgcmV0dXJuIE8ucG9zaXRpb24uZW5kID0gQ24oay5lbmQpLCBPO1xuICB9XG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgcmV0dXJuIF9yKHRoaXMuc3RhY2sucG9wKCkpO1xuICB9XG4gIGZ1bmN0aW9uIGQoKSB7XG4gICAgbChcImV4cGVjdGluZ0ZpcnN0TGlzdEl0ZW1WYWx1ZVwiLCAhMCk7XG4gIH1cbiAgZnVuY3Rpb24gbShrKSB7XG4gICAgaWYgKG8oXCJleHBlY3RpbmdGaXJzdExpc3RJdGVtVmFsdWVcIikpIHtcbiAgICAgIGNvbnN0IEUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMl07XG4gICAgICBFLnN0YXJ0ID0gTnVtYmVyLnBhcnNlSW50KHRoaXMuc2xpY2VTZXJpYWxpemUoayksIDEwKSwgbChcImV4cGVjdGluZ0ZpcnN0TGlzdEl0ZW1WYWx1ZVwiKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24geSgpIHtcbiAgICBjb25zdCBrID0gdGhpcy5yZXN1bWUoKSwgRSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICBFLmxhbmcgPSBrO1xuICB9XG4gIGZ1bmN0aW9uIHgoKSB7XG4gICAgY29uc3QgayA9IHRoaXMucmVzdW1lKCksIEUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgRS5tZXRhID0gaztcbiAgfVxuICBmdW5jdGlvbiB3KCkge1xuICAgIG8oXCJmbG93Q29kZUluc2lkZVwiKSB8fCAodGhpcy5idWZmZXIoKSwgbChcImZsb3dDb2RlSW5zaWRlXCIsICEwKSk7XG4gIH1cbiAgZnVuY3Rpb24gdigpIHtcbiAgICBjb25zdCBrID0gdGhpcy5yZXN1bWUoKSwgRSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICBFLnZhbHVlID0gay5yZXBsYWNlKC9eKFxccj9cXG58XFxyKXwoXFxyP1xcbnxcXHIpJC9nLCBcIlwiKSwgbChcImZsb3dDb2RlSW5zaWRlXCIpO1xuICB9XG4gIGZ1bmN0aW9uIEEoKSB7XG4gICAgY29uc3QgayA9IHRoaXMucmVzdW1lKCksIEUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgRS52YWx1ZSA9IGsucmVwbGFjZSgvKFxccj9cXG58XFxyKSQvZywgXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gXyhrKSB7XG4gICAgY29uc3QgRSA9IHRoaXMucmVzdW1lKCksIE8gPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgTy5sYWJlbCA9IEUsIE8uaWRlbnRpZmllciA9IExuKFxuICAgICAgdGhpcy5zbGljZVNlcmlhbGl6ZShrKVxuICAgICkudG9Mb3dlckNhc2UoKTtcbiAgfVxuICBmdW5jdGlvbiBUKCkge1xuICAgIGNvbnN0IGsgPSB0aGlzLnJlc3VtZSgpLCBFID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIEUudGl0bGUgPSBrO1xuICB9XG4gIGZ1bmN0aW9uIGIoKSB7XG4gICAgY29uc3QgayA9IHRoaXMucmVzdW1lKCksIEUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgRS51cmwgPSBrO1xuICB9XG4gIGZ1bmN0aW9uIEkoaykge1xuICAgIGNvbnN0IEUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgaWYgKCFFLmRlcHRoKSB7XG4gICAgICBjb25zdCBPID0gdGhpcy5zbGljZVNlcmlhbGl6ZShrKS5sZW5ndGg7XG4gICAgICBFLmRlcHRoID0gTztcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gUigpIHtcbiAgICBsKFwic2V0ZXh0SGVhZGluZ1NsdXJwTGluZUVuZGluZ1wiLCAhMCk7XG4gIH1cbiAgZnVuY3Rpb24gTShrKSB7XG4gICAgY29uc3QgRSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICBFLmRlcHRoID0gdGhpcy5zbGljZVNlcmlhbGl6ZShrKS5jaGFyQ29kZUF0KDApID09PSA2MSA/IDEgOiAyO1xuICB9XG4gIGZ1bmN0aW9uIFgoKSB7XG4gICAgbChcInNldGV4dEhlYWRpbmdTbHVycExpbmVFbmRpbmdcIik7XG4gIH1cbiAgZnVuY3Rpb24gQyhrKSB7XG4gICAgY29uc3QgRSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICBsZXQgTyA9IEUuY2hpbGRyZW5bRS5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAoIU8gfHwgTy50eXBlICE9PSBcInRleHRcIikgJiYgKE8gPSBocigpLCBPLnBvc2l0aW9uID0ge1xuICAgICAgc3RhcnQ6IENuKGsuc3RhcnQpXG4gICAgfSwgRS5jaGlsZHJlbi5wdXNoKE8pKSwgdGhpcy5zdGFjay5wdXNoKE8pO1xuICB9XG4gIGZ1bmN0aW9uIEYoaykge1xuICAgIGNvbnN0IEUgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIEUudmFsdWUgKz0gdGhpcy5zbGljZVNlcmlhbGl6ZShrKSwgRS5wb3NpdGlvbi5lbmQgPSBDbihrLmVuZCk7XG4gIH1cbiAgZnVuY3Rpb24gQihrKSB7XG4gICAgY29uc3QgRSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAobyhcImF0SGFyZEJyZWFrXCIpKSB7XG4gICAgICBjb25zdCBPID0gRS5jaGlsZHJlbltFLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgTy5wb3NpdGlvbi5lbmQgPSBDbihrLmVuZCksIGwoXCJhdEhhcmRCcmVha1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgIW8oXCJzZXRleHRIZWFkaW5nU2x1cnBMaW5lRW5kaW5nXCIpICYmIGUuY2FuQ29udGFpbkVvbHMuaW5jbHVkZXMoRS50eXBlKSAmJiAoQy5jYWxsKHRoaXMsIGspLCBGLmNhbGwodGhpcywgaykpO1xuICB9XG4gIGZ1bmN0aW9uIFooKSB7XG4gICAgbChcImF0SGFyZEJyZWFrXCIsICEwKTtcbiAgfVxuICBmdW5jdGlvbiBlbigpIHtcbiAgICBjb25zdCBrID0gdGhpcy5yZXN1bWUoKSwgRSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICBFLnZhbHVlID0gaztcbiAgfVxuICBmdW5jdGlvbiB1bigpIHtcbiAgICBjb25zdCBrID0gdGhpcy5yZXN1bWUoKSwgRSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICBFLnZhbHVlID0gaztcbiAgfVxuICBmdW5jdGlvbiB0bigpIHtcbiAgICBjb25zdCBrID0gdGhpcy5yZXN1bWUoKSwgRSA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICBFLnZhbHVlID0gaztcbiAgfVxuICBmdW5jdGlvbiBxKCkge1xuICAgIGNvbnN0IGsgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgaWYgKG8oXCJpblJlZmVyZW5jZVwiKSkge1xuICAgICAgY29uc3QgRSA9IG8oXCJyZWZlcmVuY2VUeXBlXCIpIHx8IFwic2hvcnRjdXRcIjtcbiAgICAgIGsudHlwZSArPSBcIlJlZmVyZW5jZVwiLCBrLnJlZmVyZW5jZVR5cGUgPSBFLCBkZWxldGUgay51cmwsIGRlbGV0ZSBrLnRpdGxlO1xuICAgIH0gZWxzZVxuICAgICAgZGVsZXRlIGsuaWRlbnRpZmllciwgZGVsZXRlIGsubGFiZWw7XG4gICAgbChcInJlZmVyZW5jZVR5cGVcIik7XG4gIH1cbiAgZnVuY3Rpb24gSigpIHtcbiAgICBjb25zdCBrID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmIChvKFwiaW5SZWZlcmVuY2VcIikpIHtcbiAgICAgIGNvbnN0IEUgPSBvKFwicmVmZXJlbmNlVHlwZVwiKSB8fCBcInNob3J0Y3V0XCI7XG4gICAgICBrLnR5cGUgKz0gXCJSZWZlcmVuY2VcIiwgay5yZWZlcmVuY2VUeXBlID0gRSwgZGVsZXRlIGsudXJsLCBkZWxldGUgay50aXRsZTtcbiAgICB9IGVsc2VcbiAgICAgIGRlbGV0ZSBrLmlkZW50aWZpZXIsIGRlbGV0ZSBrLmxhYmVsO1xuICAgIGwoXCJyZWZlcmVuY2VUeXBlXCIpO1xuICB9XG4gIGZ1bmN0aW9uIFcoaykge1xuICAgIGNvbnN0IEUgPSB0aGlzLnNsaWNlU2VyaWFsaXplKGspLCBPID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDJdO1xuICAgIE8ubGFiZWwgPSBMbChFKSwgTy5pZGVudGlmaWVyID0gTG4oRSkudG9Mb3dlckNhc2UoKTtcbiAgfVxuICBmdW5jdGlvbiBmKCkge1xuICAgIGNvbnN0IGsgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV0sIEUgPSB0aGlzLnJlc3VtZSgpLCBPID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIGlmIChsKFwiaW5SZWZlcmVuY2VcIiwgITApLCBPLnR5cGUgPT09IFwibGlua1wiKSB7XG4gICAgICBjb25zdCAkID0gay5jaGlsZHJlbjtcbiAgICAgIE8uY2hpbGRyZW4gPSAkO1xuICAgIH0gZWxzZVxuICAgICAgTy5hbHQgPSBFO1xuICB9XG4gIGZ1bmN0aW9uIHAoKSB7XG4gICAgY29uc3QgayA9IHRoaXMucmVzdW1lKCksIEUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgRS51cmwgPSBrO1xuICB9XG4gIGZ1bmN0aW9uIGtuKCkge1xuICAgIGNvbnN0IGsgPSB0aGlzLnJlc3VtZSgpLCBFID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIEUudGl0bGUgPSBrO1xuICB9XG4gIGZ1bmN0aW9uIFBuKCkge1xuICAgIGwoXCJpblJlZmVyZW5jZVwiKTtcbiAgfVxuICBmdW5jdGlvbiBibigpIHtcbiAgICBsKFwicmVmZXJlbmNlVHlwZVwiLCBcImNvbGxhcHNlZFwiKTtcbiAgfVxuICBmdW5jdGlvbiBZKGspIHtcbiAgICBjb25zdCBFID0gdGhpcy5yZXN1bWUoKSwgTyA9IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICBPLmxhYmVsID0gRSwgTy5pZGVudGlmaWVyID0gTG4oXG4gICAgICB0aGlzLnNsaWNlU2VyaWFsaXplKGspXG4gICAgKS50b0xvd2VyQ2FzZSgpLCBsKFwicmVmZXJlbmNlVHlwZVwiLCBcImZ1bGxcIik7XG4gIH1cbiAgZnVuY3Rpb24gcm4oaykge1xuICAgIGwoXCJjaGFyYWN0ZXJSZWZlcmVuY2VUeXBlXCIsIGsudHlwZSk7XG4gIH1cbiAgZnVuY3Rpb24gaG4oaykge1xuICAgIGNvbnN0IEUgPSB0aGlzLnNsaWNlU2VyaWFsaXplKGspLCBPID0gbyhcImNoYXJhY3RlclJlZmVyZW5jZVR5cGVcIik7XG4gICAgbGV0ICQ7XG4gICAgTyA/ICgkID0gJHQoXG4gICAgICBFLFxuICAgICAgTyA9PT0gXCJjaGFyYWN0ZXJSZWZlcmVuY2VNYXJrZXJOdW1lcmljXCIgPyAxMCA6IDE2XG4gICAgKSwgbChcImNoYXJhY3RlclJlZmVyZW5jZVR5cGVcIikpIDogJCA9IEFlKEUpO1xuICAgIGNvbnN0IEggPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIEgudmFsdWUgKz0gJCwgSC5wb3NpdGlvbi5lbmQgPSBDbihrLmVuZCk7XG4gIH1cbiAgZnVuY3Rpb24gd24oaykge1xuICAgIEYuY2FsbCh0aGlzLCBrKTtcbiAgICBjb25zdCBFID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICAgIEUudXJsID0gdGhpcy5zbGljZVNlcmlhbGl6ZShrKTtcbiAgfVxuICBmdW5jdGlvbiBTbihrKSB7XG4gICAgRi5jYWxsKHRoaXMsIGspO1xuICAgIGNvbnN0IEUgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gMV07XG4gICAgRS51cmwgPSBcIm1haWx0bzpcIiArIHRoaXMuc2xpY2VTZXJpYWxpemUoayk7XG4gIH1cbiAgZnVuY3Rpb24gUm4oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYmxvY2txdW90ZVwiLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBWbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJjb2RlXCIsXG4gICAgICBsYW5nOiBudWxsLFxuICAgICAgbWV0YTogbnVsbCxcbiAgICAgIHZhbHVlOiBcIlwiXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBlZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJpbmxpbmVDb2RlXCIsXG4gICAgICB2YWx1ZTogXCJcIlxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gUCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJkZWZpbml0aW9uXCIsXG4gICAgICBpZGVudGlmaWVyOiBcIlwiLFxuICAgICAgbGFiZWw6IG51bGwsXG4gICAgICB0aXRsZTogbnVsbCxcbiAgICAgIHVybDogXCJcIlxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gX24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZW1waGFzaXNcIixcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gRm4oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaGVhZGluZ1wiLFxuICAgICAgZGVwdGg6IHZvaWQgMCxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gTW4oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYnJlYWtcIlxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gTGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiaHRtbFwiLFxuICAgICAgdmFsdWU6IFwiXCJcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHNyKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICB0aXRsZTogbnVsbCxcbiAgICAgIHVybDogXCJcIixcbiAgICAgIGFsdDogbnVsbFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gRGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwibGlua1wiLFxuICAgICAgdGl0bGU6IG51bGwsXG4gICAgICB1cmw6IFwiXCIsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIHZlKGspIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsaXN0XCIsXG4gICAgICBvcmRlcmVkOiBrLnR5cGUgPT09IFwibGlzdE9yZGVyZWRcIixcbiAgICAgIHN0YXJ0OiBudWxsLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBQYXRjaGVkLlxuICAgICAgc3ByZWFkOiBrLl9zcHJlYWQsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGNyKGspIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJsaXN0SXRlbVwiLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBQYXRjaGVkLlxuICAgICAgc3ByZWFkOiBrLl9zcHJlYWQsXG4gICAgICBjaGVja2VkOiBudWxsLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBwcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJwYXJhZ3JhcGhcIixcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZnIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3Ryb25nXCIsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGhyKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIHZhbHVlOiBcIlwiXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBtcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0aGVtYXRpY0JyZWFrXCJcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBDbihuKSB7XG4gIHJldHVybiB7XG4gICAgbGluZTogbi5saW5lLFxuICAgIGNvbHVtbjogbi5jb2x1bW4sXG4gICAgb2Zmc2V0OiBuLm9mZnNldFxuICB9O1xufVxuZnVuY3Rpb24gVXQobiwgZSkge1xuICBsZXQgdCA9IC0xO1xuICBmb3IgKDsgKyt0IDwgZS5sZW5ndGg7ICkge1xuICAgIGNvbnN0IHIgPSBlW3RdO1xuICAgIEFycmF5LmlzQXJyYXkocikgPyBVdChuLCByKSA6IFJsKG4sIHIpO1xuICB9XG59XG5mdW5jdGlvbiBSbChuLCBlKSB7XG4gIGxldCB0O1xuICBmb3IgKHQgaW4gZSlcbiAgICBpZiAoSHQuY2FsbChlLCB0KSkge1xuICAgICAgaWYgKHQgPT09IFwiY2FuQ29udGFpbkVvbHNcIikge1xuICAgICAgICBjb25zdCByID0gZVt0XTtcbiAgICAgICAgciAmJiBuW3RdLnB1c2goLi4ucik7XG4gICAgICB9IGVsc2UgaWYgKHQgPT09IFwidHJhbnNmb3Jtc1wiKSB7XG4gICAgICAgIGNvbnN0IHIgPSBlW3RdO1xuICAgICAgICByICYmIG5bdF0ucHVzaCguLi5yKTtcbiAgICAgIH0gZWxzZSBpZiAodCA9PT0gXCJlbnRlclwiIHx8IHQgPT09IFwiZXhpdFwiKSB7XG4gICAgICAgIGNvbnN0IHIgPSBlW3RdO1xuICAgICAgICByICYmIE9iamVjdC5hc3NpZ24oblt0XSwgcik7XG4gICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXQobiwgZSkge1xuICB0aHJvdyBuID8gbmV3IEVycm9yKFxuICAgIFwiQ2Fubm90IGNsb3NlIGBcIiArIG4udHlwZSArIFwiYCAoXCIgKyBYbih7XG4gICAgICBzdGFydDogbi5zdGFydCxcbiAgICAgIGVuZDogbi5lbmRcbiAgICB9KSArIFwiKTogYSBkaWZmZXJlbnQgdG9rZW4gKGBcIiArIGUudHlwZSArIFwiYCwgXCIgKyBYbih7XG4gICAgICBzdGFydDogZS5zdGFydCxcbiAgICAgIGVuZDogZS5lbmRcbiAgICB9KSArIFwiKSBpcyBvcGVuXCJcbiAgKSA6IG5ldyBFcnJvcihcbiAgICBcIkNhbm5vdCBjbG9zZSBkb2N1bWVudCwgYSB0b2tlbiAoYFwiICsgZS50eXBlICsgXCJgLCBcIiArIFhuKHtcbiAgICAgIHN0YXJ0OiBlLnN0YXJ0LFxuICAgICAgZW5kOiBlLmVuZFxuICAgIH0pICsgXCIpIGlzIHN0aWxsIG9wZW5cIlxuICApO1xufVxuZnVuY3Rpb24gX2wobikge1xuICBPYmplY3QuYXNzaWduKHRoaXMsIHsgUGFyc2VyOiAodCkgPT4ge1xuICAgIGNvbnN0IHIgPSAoXG4gICAgICAvKiogQHR5cGUge09wdGlvbnN9ICovXG4gICAgICB0aGlzLmRhdGEoXCJzZXR0aW5nc1wiKVxuICAgICk7XG4gICAgcmV0dXJuIHZsKFxuICAgICAgdCxcbiAgICAgIE9iamVjdC5hc3NpZ24oe30sIHIsIG4sIHtcbiAgICAgICAgLy8gTm90ZTogdGhlc2Ugb3B0aW9ucyBhcmUgbm90IGluIHRoZSByZWFkbWUuXG4gICAgICAgIC8vIFRoZSBnb2FsIGlzIGZvciB0aGVtIHRvIGJlIHNldCBieSBwbHVnaW5zIG9uIGBkYXRhYCBpbnN0ZWFkIG9mIGJlaW5nXG4gICAgICAgIC8vIHBhc3NlZCBieSB1c2Vycy5cbiAgICAgICAgZXh0ZW5zaW9uczogdGhpcy5kYXRhKFwibWljcm9tYXJrRXh0ZW5zaW9uc1wiKSB8fCBbXSxcbiAgICAgICAgbWRhc3RFeHRlbnNpb25zOiB0aGlzLmRhdGEoXCJmcm9tTWFya2Rvd25FeHRlbnNpb25zXCIpIHx8IFtdXG4gICAgICB9KVxuICAgICk7XG4gIH0gfSk7XG59XG5mdW5jdGlvbiBNbChuLCBlKSB7XG4gIGNvbnN0IHQgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJibG9ja3F1b3RlXCIsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgY2hpbGRyZW46IG4ud3JhcChuLmFsbChlKSwgITApXG4gIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIHQpLCBuLmFwcGx5RGF0YShlLCB0KTtcbn1cbmZ1bmN0aW9uIEJsKG4sIGUpIHtcbiAgY29uc3QgdCA9IHsgdHlwZTogXCJlbGVtZW50XCIsIHRhZ05hbWU6IFwiYnJcIiwgcHJvcGVydGllczoge30sIGNoaWxkcmVuOiBbXSB9O1xuICByZXR1cm4gbi5wYXRjaChlLCB0KSwgW24uYXBwbHlEYXRhKGUsIHQpLCB7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogYFxuYCB9XTtcbn1cbmZ1bmN0aW9uIE5sKG4sIGUpIHtcbiAgY29uc3QgdCA9IGUudmFsdWUgPyBlLnZhbHVlICsgYFxuYCA6IFwiXCIsIHIgPSBlLmxhbmcgPyBlLmxhbmcubWF0Y2goL15bXiBcXHRdKyg/PVsgXFx0XXwkKS8pIDogbnVsbCwgaSA9IHt9O1xuICByICYmIChpLmNsYXNzTmFtZSA9IFtcImxhbmd1YWdlLVwiICsgcl0pO1xuICBsZXQgbCA9IHtcbiAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICB0YWdOYW1lOiBcImNvZGVcIixcbiAgICBwcm9wZXJ0aWVzOiBpLFxuICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IHQgfV1cbiAgfTtcbiAgcmV0dXJuIGUubWV0YSAmJiAobC5kYXRhID0geyBtZXRhOiBlLm1ldGEgfSksIG4ucGF0Y2goZSwgbCksIGwgPSBuLmFwcGx5RGF0YShlLCBsKSwgbCA9IHsgdHlwZTogXCJlbGVtZW50XCIsIHRhZ05hbWU6IFwicHJlXCIsIHByb3BlcnRpZXM6IHt9LCBjaGlsZHJlbjogW2xdIH0sIG4ucGF0Y2goZSwgbCksIGw7XG59XG5mdW5jdGlvbiBqbChuLCBlKSB7XG4gIGNvbnN0IHQgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJkZWxcIixcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBjaGlsZHJlbjogbi5hbGwoZSlcbiAgfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgdCksIG4uYXBwbHlEYXRhKGUsIHQpO1xufVxuZnVuY3Rpb24gJGwobiwgZSkge1xuICBjb25zdCB0ID0ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IFwiZW1cIixcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBjaGlsZHJlbjogbi5hbGwoZSlcbiAgfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgdCksIG4uYXBwbHlEYXRhKGUsIHQpO1xufVxuZnVuY3Rpb24gdm4obikge1xuICBjb25zdCBlID0gW107XG4gIGxldCB0ID0gLTEsIHIgPSAwLCBpID0gMDtcbiAgZm9yICg7ICsrdCA8IG4ubGVuZ3RoOyApIHtcbiAgICBjb25zdCBsID0gbi5jaGFyQ29kZUF0KHQpO1xuICAgIGxldCBvID0gXCJcIjtcbiAgICBpZiAobCA9PT0gMzcgJiYgb24obi5jaGFyQ29kZUF0KHQgKyAxKSkgJiYgb24obi5jaGFyQ29kZUF0KHQgKyAyKSkpXG4gICAgICBpID0gMjtcbiAgICBlbHNlIGlmIChsIDwgMTI4KVxuICAgICAgL1shIyQmLTs9Py1aX2Eten5dLy50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUobCkpIHx8IChvID0gU3RyaW5nLmZyb21DaGFyQ29kZShsKSk7XG4gICAgZWxzZSBpZiAobCA+IDU1Mjk1ICYmIGwgPCA1NzM0NCkge1xuICAgICAgY29uc3QgdSA9IG4uY2hhckNvZGVBdCh0ICsgMSk7XG4gICAgICBsIDwgNTYzMjAgJiYgdSA+IDU2MzE5ICYmIHUgPCA1NzM0NCA/IChvID0gU3RyaW5nLmZyb21DaGFyQ29kZShsLCB1KSwgaSA9IDEpIDogbyA9IFwi77+9XCI7XG4gICAgfSBlbHNlXG4gICAgICBvID0gU3RyaW5nLmZyb21DaGFyQ29kZShsKTtcbiAgICBvICYmIChlLnB1c2gobi5zbGljZShyLCB0KSwgZW5jb2RlVVJJQ29tcG9uZW50KG8pKSwgciA9IHQgKyBpICsgMSwgbyA9IFwiXCIpLCBpICYmICh0ICs9IGksIGkgPSAwKTtcbiAgfVxuICByZXR1cm4gZS5qb2luKFwiXCIpICsgbi5zbGljZShyKTtcbn1cbmZ1bmN0aW9uIFZ0KG4sIGUpIHtcbiAgY29uc3QgdCA9IFN0cmluZyhlLmlkZW50aWZpZXIpLnRvVXBwZXJDYXNlKCksIHIgPSB2bih0LnRvTG93ZXJDYXNlKCkpLCBpID0gbi5mb290bm90ZU9yZGVyLmluZGV4T2YodCk7XG4gIGxldCBsO1xuICBpID09PSAtMSA/IChuLmZvb3Rub3RlT3JkZXIucHVzaCh0KSwgbi5mb290bm90ZUNvdW50c1t0XSA9IDEsIGwgPSBuLmZvb3Rub3RlT3JkZXIubGVuZ3RoKSA6IChuLmZvb3Rub3RlQ291bnRzW3RdKyssIGwgPSBpICsgMSk7XG4gIGNvbnN0IG8gPSBuLmZvb3Rub3RlQ291bnRzW3RdLCB1ID0ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IFwiYVwiLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGhyZWY6IFwiI1wiICsgbi5jbG9iYmVyUHJlZml4ICsgXCJmbi1cIiArIHIsXG4gICAgICBpZDogbi5jbG9iYmVyUHJlZml4ICsgXCJmbnJlZi1cIiArIHIgKyAobyA+IDEgPyBcIi1cIiArIG8gOiBcIlwiKSxcbiAgICAgIGRhdGFGb290bm90ZVJlZjogITAsXG4gICAgICBhcmlhRGVzY3JpYmVkQnk6IFtcImZvb3Rub3RlLWxhYmVsXCJdXG4gICAgfSxcbiAgICBjaGlsZHJlbjogW3sgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBTdHJpbmcobCkgfV1cbiAgfTtcbiAgbi5wYXRjaChlLCB1KTtcbiAgY29uc3QgYSA9IHtcbiAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICB0YWdOYW1lOiBcInN1cFwiLFxuICAgIHByb3BlcnRpZXM6IHt9LFxuICAgIGNoaWxkcmVuOiBbdV1cbiAgfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgYSksIG4uYXBwbHlEYXRhKGUsIGEpO1xufVxuZnVuY3Rpb24gSGwobiwgZSkge1xuICBjb25zdCB0ID0gbi5mb290bm90ZUJ5SWQ7XG4gIGxldCByID0gMTtcbiAgZm9yICg7IHIgaW4gdDsgKVxuICAgIHIrKztcbiAgY29uc3QgaSA9IFN0cmluZyhyKTtcbiAgcmV0dXJuIHRbaV0gPSB7XG4gICAgdHlwZTogXCJmb290bm90ZURlZmluaXRpb25cIixcbiAgICBpZGVudGlmaWVyOiBpLFxuICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInBhcmFncmFwaFwiLCBjaGlsZHJlbjogZS5jaGlsZHJlbiB9XSxcbiAgICBwb3NpdGlvbjogZS5wb3NpdGlvblxuICB9LCBWdChuLCB7XG4gICAgdHlwZTogXCJmb290bm90ZVJlZmVyZW5jZVwiLFxuICAgIGlkZW50aWZpZXI6IGksXG4gICAgcG9zaXRpb246IGUucG9zaXRpb25cbiAgfSk7XG59XG5mdW5jdGlvbiBVbChuLCBlKSB7XG4gIGNvbnN0IHQgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJoXCIgKyBlLmRlcHRoLFxuICAgIHByb3BlcnRpZXM6IHt9LFxuICAgIGNoaWxkcmVuOiBuLmFsbChlKVxuICB9O1xuICByZXR1cm4gbi5wYXRjaChlLCB0KSwgbi5hcHBseURhdGEoZSwgdCk7XG59XG5mdW5jdGlvbiBWbChuLCBlKSB7XG4gIGlmIChuLmRhbmdlcm91cykge1xuICAgIGNvbnN0IHQgPSB7IHR5cGU6IFwicmF3XCIsIHZhbHVlOiBlLnZhbHVlIH07XG4gICAgcmV0dXJuIG4ucGF0Y2goZSwgdCksIG4uYXBwbHlEYXRhKGUsIHQpO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcXQobiwgZSkge1xuICBjb25zdCB0ID0gZS5yZWZlcmVuY2VUeXBlO1xuICBsZXQgciA9IFwiXVwiO1xuICBpZiAodCA9PT0gXCJjb2xsYXBzZWRcIiA/IHIgKz0gXCJbXVwiIDogdCA9PT0gXCJmdWxsXCIgJiYgKHIgKz0gXCJbXCIgKyAoZS5sYWJlbCB8fCBlLmlkZW50aWZpZXIpICsgXCJdXCIpLCBlLnR5cGUgPT09IFwiaW1hZ2VSZWZlcmVuY2VcIilcbiAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IFwiIVtcIiArIGUuYWx0ICsgciB9O1xuICBjb25zdCBpID0gbi5hbGwoZSksIGwgPSBpWzBdO1xuICBsICYmIGwudHlwZSA9PT0gXCJ0ZXh0XCIgPyBsLnZhbHVlID0gXCJbXCIgKyBsLnZhbHVlIDogaS51bnNoaWZ0KHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBcIltcIiB9KTtcbiAgY29uc3QgbyA9IGlbaS5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIG8gJiYgby50eXBlID09PSBcInRleHRcIiA/IG8udmFsdWUgKz0gciA6IGkucHVzaCh7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogciB9KSwgaTtcbn1cbmZ1bmN0aW9uIHFsKG4sIGUpIHtcbiAgY29uc3QgdCA9IG4uZGVmaW5pdGlvbihlLmlkZW50aWZpZXIpO1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIHF0KG4sIGUpO1xuICBjb25zdCByID0geyBzcmM6IHZuKHQudXJsIHx8IFwiXCIpLCBhbHQ6IGUuYWx0IH07XG4gIHQudGl0bGUgIT09IG51bGwgJiYgdC50aXRsZSAhPT0gdm9pZCAwICYmIChyLnRpdGxlID0gdC50aXRsZSk7XG4gIGNvbnN0IGkgPSB7IHR5cGU6IFwiZWxlbWVudFwiLCB0YWdOYW1lOiBcImltZ1wiLCBwcm9wZXJ0aWVzOiByLCBjaGlsZHJlbjogW10gfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgaSksIG4uYXBwbHlEYXRhKGUsIGkpO1xufVxuZnVuY3Rpb24gV2wobiwgZSkge1xuICBjb25zdCB0ID0geyBzcmM6IHZuKGUudXJsKSB9O1xuICBlLmFsdCAhPT0gbnVsbCAmJiBlLmFsdCAhPT0gdm9pZCAwICYmICh0LmFsdCA9IGUuYWx0KSwgZS50aXRsZSAhPT0gbnVsbCAmJiBlLnRpdGxlICE9PSB2b2lkIDAgJiYgKHQudGl0bGUgPSBlLnRpdGxlKTtcbiAgY29uc3QgciA9IHsgdHlwZTogXCJlbGVtZW50XCIsIHRhZ05hbWU6IFwiaW1nXCIsIHByb3BlcnRpZXM6IHQsIGNoaWxkcmVuOiBbXSB9O1xuICByZXR1cm4gbi5wYXRjaChlLCByKSwgbi5hcHBseURhdGEoZSwgcik7XG59XG5mdW5jdGlvbiBZbChuLCBlKSB7XG4gIGNvbnN0IHQgPSB7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogZS52YWx1ZS5yZXBsYWNlKC9cXHI/XFxufFxcci9nLCBcIiBcIikgfTtcbiAgbi5wYXRjaChlLCB0KTtcbiAgY29uc3QgciA9IHtcbiAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICB0YWdOYW1lOiBcImNvZGVcIixcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBjaGlsZHJlbjogW3RdXG4gIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIHIpLCBuLmFwcGx5RGF0YShlLCByKTtcbn1cbmZ1bmN0aW9uIFFsKG4sIGUpIHtcbiAgY29uc3QgdCA9IG4uZGVmaW5pdGlvbihlLmlkZW50aWZpZXIpO1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIHF0KG4sIGUpO1xuICBjb25zdCByID0geyBocmVmOiB2bih0LnVybCB8fCBcIlwiKSB9O1xuICB0LnRpdGxlICE9PSBudWxsICYmIHQudGl0bGUgIT09IHZvaWQgMCAmJiAoci50aXRsZSA9IHQudGl0bGUpO1xuICBjb25zdCBpID0ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IFwiYVwiLFxuICAgIHByb3BlcnRpZXM6IHIsXG4gICAgY2hpbGRyZW46IG4uYWxsKGUpXG4gIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIGkpLCBuLmFwcGx5RGF0YShlLCBpKTtcbn1cbmZ1bmN0aW9uIFhsKG4sIGUpIHtcbiAgY29uc3QgdCA9IHsgaHJlZjogdm4oZS51cmwpIH07XG4gIGUudGl0bGUgIT09IG51bGwgJiYgZS50aXRsZSAhPT0gdm9pZCAwICYmICh0LnRpdGxlID0gZS50aXRsZSk7XG4gIGNvbnN0IHIgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJhXCIsXG4gICAgcHJvcGVydGllczogdCxcbiAgICBjaGlsZHJlbjogbi5hbGwoZSlcbiAgfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgciksIG4uYXBwbHlEYXRhKGUsIHIpO1xufVxuZnVuY3Rpb24gS2wobiwgZSwgdCkge1xuICBjb25zdCByID0gbi5hbGwoZSksIGkgPSB0ID8gR2wodCkgOiBXdChlKSwgbCA9IHt9LCBvID0gW107XG4gIGlmICh0eXBlb2YgZS5jaGVja2VkID09IFwiYm9vbGVhblwiKSB7XG4gICAgY29uc3QgcyA9IHJbMF07XG4gICAgbGV0IGg7XG4gICAgcyAmJiBzLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIHMudGFnTmFtZSA9PT0gXCJwXCIgPyBoID0gcyA6IChoID0geyB0eXBlOiBcImVsZW1lbnRcIiwgdGFnTmFtZTogXCJwXCIsIHByb3BlcnRpZXM6IHt9LCBjaGlsZHJlbjogW10gfSwgci51bnNoaWZ0KGgpKSwgaC5jaGlsZHJlbi5sZW5ndGggPiAwICYmIGguY2hpbGRyZW4udW5zaGlmdCh7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogXCIgXCIgfSksIGguY2hpbGRyZW4udW5zaGlmdCh7XG4gICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgIHRhZ05hbWU6IFwiaW5wdXRcIixcbiAgICAgIHByb3BlcnRpZXM6IHsgdHlwZTogXCJjaGVja2JveFwiLCBjaGVja2VkOiBlLmNoZWNrZWQsIGRpc2FibGVkOiAhMCB9LFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSksIGwuY2xhc3NOYW1lID0gW1widGFzay1saXN0LWl0ZW1cIl07XG4gIH1cbiAgbGV0IHUgPSAtMTtcbiAgZm9yICg7ICsrdSA8IHIubGVuZ3RoOyApIHtcbiAgICBjb25zdCBzID0gclt1XTtcbiAgICAoaSB8fCB1ICE9PSAwIHx8IHMudHlwZSAhPT0gXCJlbGVtZW50XCIgfHwgcy50YWdOYW1lICE9PSBcInBcIikgJiYgby5wdXNoKHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBgXG5gIH0pLCBzLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIHMudGFnTmFtZSA9PT0gXCJwXCIgJiYgIWkgPyBvLnB1c2goLi4ucy5jaGlsZHJlbikgOiBvLnB1c2gocyk7XG4gIH1cbiAgY29uc3QgYSA9IHJbci5sZW5ndGggLSAxXTtcbiAgYSAmJiAoaSB8fCBhLnR5cGUgIT09IFwiZWxlbWVudFwiIHx8IGEudGFnTmFtZSAhPT0gXCJwXCIpICYmIG8ucHVzaCh7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogYFxuYCB9KTtcbiAgY29uc3QgYyA9IHsgdHlwZTogXCJlbGVtZW50XCIsIHRhZ05hbWU6IFwibGlcIiwgcHJvcGVydGllczogbCwgY2hpbGRyZW46IG8gfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgYyksIG4uYXBwbHlEYXRhKGUsIGMpO1xufVxuZnVuY3Rpb24gR2wobikge1xuICBsZXQgZSA9ICExO1xuICBpZiAobi50eXBlID09PSBcImxpc3RcIikge1xuICAgIGUgPSBuLnNwcmVhZCB8fCAhMTtcbiAgICBjb25zdCB0ID0gbi5jaGlsZHJlbjtcbiAgICBsZXQgciA9IC0xO1xuICAgIGZvciAoOyAhZSAmJiArK3IgPCB0Lmxlbmd0aDsgKVxuICAgICAgZSA9IFd0KHRbcl0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gV3Qobikge1xuICBjb25zdCBlID0gbi5zcHJlYWQ7XG4gIHJldHVybiBlID8/IG4uY2hpbGRyZW4ubGVuZ3RoID4gMTtcbn1cbmZ1bmN0aW9uIFpsKG4sIGUpIHtcbiAgY29uc3QgdCA9IHt9LCByID0gbi5hbGwoZSk7XG4gIGxldCBpID0gLTE7XG4gIGZvciAodHlwZW9mIGUuc3RhcnQgPT0gXCJudW1iZXJcIiAmJiBlLnN0YXJ0ICE9PSAxICYmICh0LnN0YXJ0ID0gZS5zdGFydCk7ICsraSA8IHIubGVuZ3RoOyApIHtcbiAgICBjb25zdCBvID0gcltpXTtcbiAgICBpZiAoby50eXBlID09PSBcImVsZW1lbnRcIiAmJiBvLnRhZ05hbWUgPT09IFwibGlcIiAmJiBvLnByb3BlcnRpZXMgJiYgQXJyYXkuaXNBcnJheShvLnByb3BlcnRpZXMuY2xhc3NOYW1lKSAmJiBvLnByb3BlcnRpZXMuY2xhc3NOYW1lLmluY2x1ZGVzKFwidGFzay1saXN0LWl0ZW1cIikpIHtcbiAgICAgIHQuY2xhc3NOYW1lID0gW1wiY29udGFpbnMtdGFzay1saXN0XCJdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGNvbnN0IGwgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogZS5vcmRlcmVkID8gXCJvbFwiIDogXCJ1bFwiLFxuICAgIHByb3BlcnRpZXM6IHQsXG4gICAgY2hpbGRyZW46IG4ud3JhcChyLCAhMClcbiAgfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgbCksIG4uYXBwbHlEYXRhKGUsIGwpO1xufVxuZnVuY3Rpb24gSmwobiwgZSkge1xuICBjb25zdCB0ID0ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IFwicFwiLFxuICAgIHByb3BlcnRpZXM6IHt9LFxuICAgIGNoaWxkcmVuOiBuLmFsbChlKVxuICB9O1xuICByZXR1cm4gbi5wYXRjaChlLCB0KSwgbi5hcHBseURhdGEoZSwgdCk7XG59XG5mdW5jdGlvbiBubyhuLCBlKSB7XG4gIGNvbnN0IHQgPSB7IHR5cGU6IFwicm9vdFwiLCBjaGlsZHJlbjogbi53cmFwKG4uYWxsKGUpKSB9O1xuICByZXR1cm4gbi5wYXRjaChlLCB0KSwgbi5hcHBseURhdGEoZSwgdCk7XG59XG5mdW5jdGlvbiBlbyhuLCBlKSB7XG4gIGNvbnN0IHQgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJzdHJvbmdcIixcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBjaGlsZHJlbjogbi5hbGwoZSlcbiAgfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgdCksIG4uYXBwbHlEYXRhKGUsIHQpO1xufVxuY29uc3QgRmUgPSBZdChcInN0YXJ0XCIpLCBUZSA9IFl0KFwiZW5kXCIpO1xuZnVuY3Rpb24gdG8obikge1xuICByZXR1cm4geyBzdGFydDogRmUobiksIGVuZDogVGUobikgfTtcbn1cbmZ1bmN0aW9uIFl0KG4pIHtcbiAgcmV0dXJuIGU7XG4gIGZ1bmN0aW9uIGUodCkge1xuICAgIGNvbnN0IHIgPSB0ICYmIHQucG9zaXRpb24gJiYgdC5wb3NpdGlvbltuXSB8fCB7fTtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW4gcHJhY3RpY2UsIG51bGwgaXMgYWxsb3dlZC5cbiAgICAgIGxpbmU6IHIubGluZSB8fCBudWxsLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW4gcHJhY3RpY2UsIG51bGwgaXMgYWxsb3dlZC5cbiAgICAgIGNvbHVtbjogci5jb2x1bW4gfHwgbnVsbCxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGluIHByYWN0aWNlLCBudWxsIGlzIGFsbG93ZWQuXG4gICAgICBvZmZzZXQ6IHIub2Zmc2V0ID4gLTEgPyByLm9mZnNldCA6IG51bGxcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBybyhuLCBlKSB7XG4gIGNvbnN0IHQgPSBuLmFsbChlKSwgciA9IHQuc2hpZnQoKSwgaSA9IFtdO1xuICBpZiAocikge1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgIHRhZ05hbWU6IFwidGhlYWRcIixcbiAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgY2hpbGRyZW46IG4ud3JhcChbcl0sICEwKVxuICAgIH07XG4gICAgbi5wYXRjaChlLmNoaWxkcmVuWzBdLCBvKSwgaS5wdXNoKG8pO1xuICB9XG4gIGlmICh0Lmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBvID0ge1xuICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICB0YWdOYW1lOiBcInRib2R5XCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgIGNoaWxkcmVuOiBuLndyYXAodCwgITApXG4gICAgfSwgdSA9IEZlKGUuY2hpbGRyZW5bMV0pLCBhID0gVGUoZS5jaGlsZHJlbltlLmNoaWxkcmVuLmxlbmd0aCAtIDFdKTtcbiAgICB1LmxpbmUgJiYgYS5saW5lICYmIChvLnBvc2l0aW9uID0geyBzdGFydDogdSwgZW5kOiBhIH0pLCBpLnB1c2gobyk7XG4gIH1cbiAgY29uc3QgbCA9IHtcbiAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICB0YWdOYW1lOiBcInRhYmxlXCIsXG4gICAgcHJvcGVydGllczoge30sXG4gICAgY2hpbGRyZW46IG4ud3JhcChpLCAhMClcbiAgfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgbCksIG4uYXBwbHlEYXRhKGUsIGwpO1xufVxuZnVuY3Rpb24gaW8obiwgZSwgdCkge1xuICBjb25zdCByID0gdCA/IHQuY2hpbGRyZW4gOiB2b2lkIDAsIGwgPSAociA/IHIuaW5kZXhPZihlKSA6IDEpID09PSAwID8gXCJ0aFwiIDogXCJ0ZFwiLCBvID0gdCAmJiB0LnR5cGUgPT09IFwidGFibGVcIiA/IHQuYWxpZ24gOiB2b2lkIDAsIHUgPSBvID8gby5sZW5ndGggOiBlLmNoaWxkcmVuLmxlbmd0aDtcbiAgbGV0IGEgPSAtMTtcbiAgY29uc3QgYyA9IFtdO1xuICBmb3IgKDsgKythIDwgdTsgKSB7XG4gICAgY29uc3QgaCA9IGUuY2hpbGRyZW5bYV0sIGcgPSB7fSwgZCA9IG8gPyBvW2FdIDogdm9pZCAwO1xuICAgIGQgJiYgKGcuYWxpZ24gPSBkKTtcbiAgICBsZXQgbSA9IHsgdHlwZTogXCJlbGVtZW50XCIsIHRhZ05hbWU6IGwsIHByb3BlcnRpZXM6IGcsIGNoaWxkcmVuOiBbXSB9O1xuICAgIGggJiYgKG0uY2hpbGRyZW4gPSBuLmFsbChoKSwgbi5wYXRjaChoLCBtKSwgbSA9IG4uYXBwbHlEYXRhKGUsIG0pKSwgYy5wdXNoKG0pO1xuICB9XG4gIGNvbnN0IHMgPSB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJ0clwiLFxuICAgIHByb3BlcnRpZXM6IHt9LFxuICAgIGNoaWxkcmVuOiBuLndyYXAoYywgITApXG4gIH07XG4gIHJldHVybiBuLnBhdGNoKGUsIHMpLCBuLmFwcGx5RGF0YShlLCBzKTtcbn1cbmZ1bmN0aW9uIGxvKG4sIGUpIHtcbiAgY29uc3QgdCA9IHtcbiAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICB0YWdOYW1lOiBcInRkXCIsXG4gICAgLy8gQXNzdW1lIGJvZHkgY2VsbC5cbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBjaGlsZHJlbjogbi5hbGwoZSlcbiAgfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgdCksIG4uYXBwbHlEYXRhKGUsIHQpO1xufVxuY29uc3Qgc3QgPSA5LCBjdCA9IDMyO1xuZnVuY3Rpb24gb28obikge1xuICBjb25zdCBlID0gU3RyaW5nKG4pLCB0ID0gL1xccj9cXG58XFxyL2c7XG4gIGxldCByID0gdC5leGVjKGUpLCBpID0gMDtcbiAgY29uc3QgbCA9IFtdO1xuICBmb3IgKDsgcjsgKVxuICAgIGwucHVzaChcbiAgICAgIHB0KGUuc2xpY2UoaSwgci5pbmRleCksIGkgPiAwLCAhMCksXG4gICAgICByWzBdXG4gICAgKSwgaSA9IHIuaW5kZXggKyByWzBdLmxlbmd0aCwgciA9IHQuZXhlYyhlKTtcbiAgcmV0dXJuIGwucHVzaChwdChlLnNsaWNlKGkpLCBpID4gMCwgITEpKSwgbC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gcHQobiwgZSwgdCkge1xuICBsZXQgciA9IDAsIGkgPSBuLmxlbmd0aDtcbiAgaWYgKGUpIHtcbiAgICBsZXQgbCA9IG4uY29kZVBvaW50QXQocik7XG4gICAgZm9yICg7IGwgPT09IHN0IHx8IGwgPT09IGN0OyApXG4gICAgICByKyssIGwgPSBuLmNvZGVQb2ludEF0KHIpO1xuICB9XG4gIGlmICh0KSB7XG4gICAgbGV0IGwgPSBuLmNvZGVQb2ludEF0KGkgLSAxKTtcbiAgICBmb3IgKDsgbCA9PT0gc3QgfHwgbCA9PT0gY3Q7IClcbiAgICAgIGktLSwgbCA9IG4uY29kZVBvaW50QXQoaSAtIDEpO1xuICB9XG4gIHJldHVybiBpID4gciA/IG4uc2xpY2UociwgaSkgOiBcIlwiO1xufVxuZnVuY3Rpb24gdW8obiwgZSkge1xuICBjb25zdCB0ID0geyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IG9vKFN0cmluZyhlLnZhbHVlKSkgfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgdCksIG4uYXBwbHlEYXRhKGUsIHQpO1xufVxuZnVuY3Rpb24gYW8obiwgZSkge1xuICBjb25zdCB0ID0ge1xuICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgIHRhZ05hbWU6IFwiaHJcIixcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBjaGlsZHJlbjogW11cbiAgfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgdCksIG4uYXBwbHlEYXRhKGUsIHQpO1xufVxuY29uc3Qgc28gPSB7XG4gIGJsb2NrcXVvdGU6IE1sLFxuICBicmVhazogQmwsXG4gIGNvZGU6IE5sLFxuICBkZWxldGU6IGpsLFxuICBlbXBoYXNpczogJGwsXG4gIGZvb3Rub3RlUmVmZXJlbmNlOiBWdCxcbiAgZm9vdG5vdGU6IEhsLFxuICBoZWFkaW5nOiBVbCxcbiAgaHRtbDogVmwsXG4gIGltYWdlUmVmZXJlbmNlOiBxbCxcbiAgaW1hZ2U6IFdsLFxuICBpbmxpbmVDb2RlOiBZbCxcbiAgbGlua1JlZmVyZW5jZTogUWwsXG4gIGxpbms6IFhsLFxuICBsaXN0SXRlbTogS2wsXG4gIGxpc3Q6IFpsLFxuICBwYXJhZ3JhcGg6IEpsLFxuICByb290OiBubyxcbiAgc3Ryb25nOiBlbyxcbiAgdGFibGU6IHJvLFxuICB0YWJsZUNlbGw6IGxvLFxuICB0YWJsZVJvdzogaW8sXG4gIHRleHQ6IHVvLFxuICB0aGVtYXRpY0JyZWFrOiBhbyxcbiAgdG9tbDogcW4sXG4gIHlhbWw6IHFuLFxuICBkZWZpbml0aW9uOiBxbixcbiAgZm9vdG5vdGVEZWZpbml0aW9uOiBxblxufTtcbmZ1bmN0aW9uIHFuKCkge1xuICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IFF0ID0gKFxuICAvKipcbiAgICogQHR5cGUgeyhcbiAgICogICAoPEtpbmQgZXh0ZW5kcyBOb2RlPih0ZXN0OiBQcmVkaWNhdGVUZXN0PEtpbmQ+KSA9PiBBc3NlcnRQcmVkaWNhdGU8S2luZD4pICZcbiAgICogICAoKHRlc3Q/OiBUZXN0KSA9PiBBc3NlcnRBbnl0aGluZylcbiAgICogKX1cbiAgICovXG4gIC8qKlxuICAgKiBAcGFyYW0ge1Rlc3R9IFt0ZXN0XVxuICAgKiBAcmV0dXJucyB7QXNzZXJ0QW55dGhpbmd9XG4gICAqL1xuICBmdW5jdGlvbihuKSB7XG4gICAgaWYgKG4gPT0gbnVsbClcbiAgICAgIHJldHVybiBobztcbiAgICBpZiAodHlwZW9mIG4gPT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiBmbyhuKTtcbiAgICBpZiAodHlwZW9mIG4gPT0gXCJvYmplY3RcIilcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KG4pID8gY28obikgOiBwbyhuKTtcbiAgICBpZiAodHlwZW9mIG4gPT0gXCJmdW5jdGlvblwiKVxuICAgICAgcmV0dXJuIEpuKG4pO1xuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGZ1bmN0aW9uLCBzdHJpbmcsIG9yIG9iamVjdCBhcyB0ZXN0XCIpO1xuICB9XG4pO1xuZnVuY3Rpb24gY28obikge1xuICBjb25zdCBlID0gW107XG4gIGxldCB0ID0gLTE7XG4gIGZvciAoOyArK3QgPCBuLmxlbmd0aDsgKVxuICAgIGVbdF0gPSBRdChuW3RdKTtcbiAgcmV0dXJuIEpuKHIpO1xuICBmdW5jdGlvbiByKC4uLmkpIHtcbiAgICBsZXQgbCA9IC0xO1xuICAgIGZvciAoOyArK2wgPCBlLmxlbmd0aDsgKVxuICAgICAgaWYgKGVbbF0uY2FsbCh0aGlzLCAuLi5pKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gcG8obikge1xuICByZXR1cm4gSm4oZSk7XG4gIGZ1bmN0aW9uIGUodCkge1xuICAgIGxldCByO1xuICAgIGZvciAociBpbiBuKVxuICAgICAgaWYgKHRbcl0gIT09IG5bcl0pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICByZXR1cm4gITA7XG4gIH1cbn1cbmZ1bmN0aW9uIGZvKG4pIHtcbiAgcmV0dXJuIEpuKGUpO1xuICBmdW5jdGlvbiBlKHQpIHtcbiAgICByZXR1cm4gdCAmJiB0LnR5cGUgPT09IG47XG4gIH1cbn1cbmZ1bmN0aW9uIEpuKG4pIHtcbiAgcmV0dXJuIGU7XG4gIGZ1bmN0aW9uIGUodCwgLi4ucikge1xuICAgIHJldHVybiAhISh0ICYmIHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgXCJ0eXBlXCIgaW4gdCAmJiBuLmNhbGwodGhpcywgdCwgLi4ucikpO1xuICB9XG59XG5mdW5jdGlvbiBobygpIHtcbiAgcmV0dXJuICEwO1xufVxuY29uc3QgbW8gPSAhMCwgZnQgPSAhMSwgZ28gPSBcInNraXBcIiwgeW8gPSAoXG4gIC8qKlxuICAgKiBAdHlwZSB7KFxuICAgKiAgICg8VHJlZSBleHRlbmRzIE5vZGUsIENoZWNrIGV4dGVuZHMgVGVzdD4odHJlZTogVHJlZSwgdGVzdDogQ2hlY2ssIHZpc2l0b3I6IEJ1aWxkVmlzaXRvcjxUcmVlLCBDaGVjaz4sIHJldmVyc2U/OiBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gdm9pZCkgJlxuICAgKiAgICg8VHJlZSBleHRlbmRzIE5vZGU+KHRyZWU6IFRyZWUsIHZpc2l0b3I6IEJ1aWxkVmlzaXRvcjxUcmVlPiwgcmV2ZXJzZT86IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB2b2lkKVxuICAgKiApfVxuICAgKi9cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdHJlZVxuICAgKiBAcGFyYW0ge1Rlc3R9IHRlc3RcbiAgICogQHBhcmFtIHtWaXNpdG9yPE5vZGU+fSB2aXNpdG9yXG4gICAqIEBwYXJhbSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtyZXZlcnNlXVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uKG4sIGUsIHQsIHIpIHtcbiAgICB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiICYmIChyID0gdCwgdCA9IGUsIGUgPSBudWxsKTtcbiAgICBjb25zdCBpID0gUXQoZSksIGwgPSByID8gLTEgOiAxO1xuICAgIG8obiwgdm9pZCAwLCBbXSkoKTtcbiAgICBmdW5jdGlvbiBvKHUsIGEsIGMpIHtcbiAgICAgIGNvbnN0IHMgPSB1ICYmIHR5cGVvZiB1ID09IFwib2JqZWN0XCIgPyB1IDoge307XG4gICAgICBpZiAodHlwZW9mIHMudHlwZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGcgPSAoXG4gICAgICAgICAgLy8gYGhhc3RgXG4gICAgICAgICAgdHlwZW9mIHMudGFnTmFtZSA9PSBcInN0cmluZ1wiID8gcy50YWdOYW1lIDogKFxuICAgICAgICAgICAgLy8gYHhhc3RgXG4gICAgICAgICAgICB0eXBlb2Ygcy5uYW1lID09IFwic3RyaW5nXCIgPyBzLm5hbWUgOiB2b2lkIDBcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShoLCBcIm5hbWVcIiwge1xuICAgICAgICAgIHZhbHVlOiBcIm5vZGUgKFwiICsgKHUudHlwZSArIChnID8gXCI8XCIgKyBnICsgXCI+XCIgOiBcIlwiKSkgKyBcIilcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBoO1xuICAgICAgZnVuY3Rpb24gaCgpIHtcbiAgICAgICAgbGV0IGcgPSBbXSwgZCwgbSwgeTtcbiAgICAgICAgaWYgKCghZSB8fCBpKHUsIGEsIGNbYy5sZW5ndGggLSAxXSB8fCBudWxsKSkgJiYgKGcgPSB4byh0KHUsIGMpKSwgZ1swXSA9PT0gZnQpKVxuICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICBpZiAodS5jaGlsZHJlbiAmJiBnWzBdICE9PSBnbylcbiAgICAgICAgICBmb3IgKG0gPSAociA/IHUuY2hpbGRyZW4ubGVuZ3RoIDogLTEpICsgbCwgeSA9IGMuY29uY2F0KHUpOyBtID4gLTEgJiYgbSA8IHUuY2hpbGRyZW4ubGVuZ3RoOyApIHtcbiAgICAgICAgICAgIGlmIChkID0gbyh1LmNoaWxkcmVuW21dLCBtLCB5KSgpLCBkWzBdID09PSBmdClcbiAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICBtID0gdHlwZW9mIGRbMV0gPT0gXCJudW1iZXJcIiA/IGRbMV0gOiBtICsgbDtcbiAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuKTtcbmZ1bmN0aW9uIHhvKG4pIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkobikgPyBuIDogdHlwZW9mIG4gPT0gXCJudW1iZXJcIiA/IFttbywgbl0gOiBbbl07XG59XG5jb25zdCBYdCA9IChcbiAgLyoqXG4gICAqIEB0eXBlIHsoXG4gICAqICAgKDxUcmVlIGV4dGVuZHMgTm9kZSwgQ2hlY2sgZXh0ZW5kcyBUZXN0Pih0cmVlOiBUcmVlLCB0ZXN0OiBDaGVjaywgdmlzaXRvcjogQnVpbGRWaXNpdG9yPFRyZWUsIENoZWNrPiwgcmV2ZXJzZT86IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB2b2lkKSAmXG4gICAqICAgKDxUcmVlIGV4dGVuZHMgTm9kZT4odHJlZTogVHJlZSwgdmlzaXRvcjogQnVpbGRWaXNpdG9yPFRyZWU+LCByZXZlcnNlPzogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQpID0+IHZvaWQpXG4gICAqICl9XG4gICAqL1xuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSB0cmVlXG4gICAqIEBwYXJhbSB7VGVzdH0gdGVzdFxuICAgKiBAcGFyYW0ge1Zpc2l0b3J9IHZpc2l0b3JcbiAgICogQHBhcmFtIHtib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZH0gW3JldmVyc2VdXG4gICAqIEByZXR1cm5zIHt2b2lkfVxuICAgKi9cbiAgZnVuY3Rpb24obiwgZSwgdCwgcikge1xuICAgIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgdCAhPSBcImZ1bmN0aW9uXCIgJiYgKHIgPSB0LCB0ID0gZSwgZSA9IG51bGwpLCB5byhuLCBlLCBpLCByKTtcbiAgICBmdW5jdGlvbiBpKGwsIG8pIHtcbiAgICAgIGNvbnN0IHUgPSBvW28ubGVuZ3RoIC0gMV07XG4gICAgICByZXR1cm4gdChcbiAgICAgICAgbCxcbiAgICAgICAgdSA/IHUuY2hpbGRyZW4uaW5kZXhPZihsKSA6IG51bGwsXG4gICAgICAgIHVcbiAgICAgICk7XG4gICAgfVxuICB9XG4pO1xuZnVuY3Rpb24ga28obikge1xuICByZXR1cm4gIW4gfHwgIW4ucG9zaXRpb24gfHwgIW4ucG9zaXRpb24uc3RhcnQgfHwgIW4ucG9zaXRpb24uc3RhcnQubGluZSB8fCAhbi5wb3NpdGlvbi5zdGFydC5jb2x1bW4gfHwgIW4ucG9zaXRpb24uZW5kIHx8ICFuLnBvc2l0aW9uLmVuZC5saW5lIHx8ICFuLnBvc2l0aW9uLmVuZC5jb2x1bW47XG59XG5jb25zdCBodCA9IHt9Lmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gYm8obikge1xuICBjb25zdCBlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghbiB8fCAhbi50eXBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcIm1kYXN0LXV0aWwtZGVmaW5pdGlvbnMgZXhwZWN0ZWQgbm9kZVwiKTtcbiAgcmV0dXJuIFh0KG4sIFwiZGVmaW5pdGlvblwiLCAocikgPT4ge1xuICAgIGNvbnN0IGkgPSBtdChyLmlkZW50aWZpZXIpO1xuICAgIGkgJiYgIWh0LmNhbGwoZSwgaSkgJiYgKGVbaV0gPSByKTtcbiAgfSksIHQ7XG4gIGZ1bmN0aW9uIHQocikge1xuICAgIGNvbnN0IGkgPSBtdChyKTtcbiAgICByZXR1cm4gaSAmJiBodC5jYWxsKGUsIGkpID8gZVtpXSA6IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIG10KG4pIHtcbiAgcmV0dXJuIFN0cmluZyhuIHx8IFwiXCIpLnRvVXBwZXJDYXNlKCk7XG59XG5jb25zdCBLbiA9IHt9Lmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gd28obiwgZSkge1xuICBjb25zdCB0ID0gZSB8fCB7fSwgciA9IHQuYWxsb3dEYW5nZXJvdXNIdG1sIHx8ICExLCBpID0ge307XG4gIHJldHVybiBvLmRhbmdlcm91cyA9IHIsIG8uY2xvYmJlclByZWZpeCA9IHQuY2xvYmJlclByZWZpeCA9PT0gdm9pZCAwIHx8IHQuY2xvYmJlclByZWZpeCA9PT0gbnVsbCA/IFwidXNlci1jb250ZW50LVwiIDogdC5jbG9iYmVyUHJlZml4LCBvLmZvb3Rub3RlTGFiZWwgPSB0LmZvb3Rub3RlTGFiZWwgfHwgXCJGb290bm90ZXNcIiwgby5mb290bm90ZUxhYmVsVGFnTmFtZSA9IHQuZm9vdG5vdGVMYWJlbFRhZ05hbWUgfHwgXCJoMlwiLCBvLmZvb3Rub3RlTGFiZWxQcm9wZXJ0aWVzID0gdC5mb290bm90ZUxhYmVsUHJvcGVydGllcyB8fCB7XG4gICAgY2xhc3NOYW1lOiBbXCJzci1vbmx5XCJdXG4gIH0sIG8uZm9vdG5vdGVCYWNrTGFiZWwgPSB0LmZvb3Rub3RlQmFja0xhYmVsIHx8IFwiQmFjayB0byBjb250ZW50XCIsIG8udW5rbm93bkhhbmRsZXIgPSB0LnVua25vd25IYW5kbGVyLCBvLnBhc3NUaHJvdWdoID0gdC5wYXNzVGhyb3VnaCwgby5oYW5kbGVycyA9IHsgLi4uc28sIC4uLnQuaGFuZGxlcnMgfSwgby5kZWZpbml0aW9uID0gYm8obiksIG8uZm9vdG5vdGVCeUlkID0gaSwgby5mb290bm90ZU9yZGVyID0gW10sIG8uZm9vdG5vdGVDb3VudHMgPSB7fSwgby5wYXRjaCA9IFNvLCBvLmFwcGx5RGF0YSA9IEVvLCBvLm9uZSA9IHUsIG8uYWxsID0gYSwgby53cmFwID0gQW8sIG8uYXVnbWVudCA9IGwsIFh0KG4sIFwiZm9vdG5vdGVEZWZpbml0aW9uXCIsIChjKSA9PiB7XG4gICAgY29uc3QgcyA9IFN0cmluZyhjLmlkZW50aWZpZXIpLnRvVXBwZXJDYXNlKCk7XG4gICAgS24uY2FsbChpLCBzKSB8fCAoaVtzXSA9IGMpO1xuICB9KSwgbztcbiAgZnVuY3Rpb24gbChjLCBzKSB7XG4gICAgaWYgKGMgJiYgXCJkYXRhXCIgaW4gYyAmJiBjLmRhdGEpIHtcbiAgICAgIGNvbnN0IGggPSBjLmRhdGE7XG4gICAgICBoLmhOYW1lICYmIChzLnR5cGUgIT09IFwiZWxlbWVudFwiICYmIChzID0ge1xuICAgICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgICAgdGFnTmFtZTogXCJcIixcbiAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgfSksIHMudGFnTmFtZSA9IGguaE5hbWUpLCBzLnR5cGUgPT09IFwiZWxlbWVudFwiICYmIGguaFByb3BlcnRpZXMgJiYgKHMucHJvcGVydGllcyA9IHsgLi4ucy5wcm9wZXJ0aWVzLCAuLi5oLmhQcm9wZXJ0aWVzIH0pLCBcImNoaWxkcmVuXCIgaW4gcyAmJiBzLmNoaWxkcmVuICYmIGguaENoaWxkcmVuICYmIChzLmNoaWxkcmVuID0gaC5oQ2hpbGRyZW4pO1xuICAgIH1cbiAgICBpZiAoYykge1xuICAgICAgY29uc3QgaCA9IFwidHlwZVwiIGluIGMgPyBjIDogeyBwb3NpdGlvbjogYyB9O1xuICAgICAga28oaCkgfHwgKHMucG9zaXRpb24gPSB7IHN0YXJ0OiBGZShoKSwgZW5kOiBUZShoKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgZnVuY3Rpb24gbyhjLCBzLCBoLCBnKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaCkgJiYgKGcgPSBoLCBoID0ge30pLCBsKGMsIHtcbiAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgdGFnTmFtZTogcyxcbiAgICAgIHByb3BlcnRpZXM6IGggfHwge30sXG4gICAgICBjaGlsZHJlbjogZyB8fCBbXVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHUoYywgcykge1xuICAgIHJldHVybiBLdChvLCBjLCBzKTtcbiAgfVxuICBmdW5jdGlvbiBhKGMpIHtcbiAgICByZXR1cm4gSWUobywgYyk7XG4gIH1cbn1cbmZ1bmN0aW9uIFNvKG4sIGUpIHtcbiAgbi5wb3NpdGlvbiAmJiAoZS5wb3NpdGlvbiA9IHRvKG4pKTtcbn1cbmZ1bmN0aW9uIEVvKG4sIGUpIHtcbiAgbGV0IHQgPSBlO1xuICBpZiAobiAmJiBuLmRhdGEpIHtcbiAgICBjb25zdCByID0gbi5kYXRhLmhOYW1lLCBpID0gbi5kYXRhLmhDaGlsZHJlbiwgbCA9IG4uZGF0YS5oUHJvcGVydGllcztcbiAgICB0eXBlb2YgciA9PSBcInN0cmluZ1wiICYmICh0LnR5cGUgPT09IFwiZWxlbWVudFwiID8gdC50YWdOYW1lID0gciA6IHQgPSB7XG4gICAgICB0eXBlOiBcImVsZW1lbnRcIixcbiAgICAgIHRhZ05hbWU6IHIsXG4gICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgIGNoaWxkcmVuOiBbXVxuICAgIH0pLCB0LnR5cGUgPT09IFwiZWxlbWVudFwiICYmIGwgJiYgKHQucHJvcGVydGllcyA9IHsgLi4udC5wcm9wZXJ0aWVzLCAuLi5sIH0pLCBcImNoaWxkcmVuXCIgaW4gdCAmJiB0LmNoaWxkcmVuICYmIGkgIT09IG51bGwgJiYgaSAhPT0gdm9pZCAwICYmICh0LmNoaWxkcmVuID0gaSk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBLdChuLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSBlICYmIGUudHlwZTtcbiAgaWYgKCFyKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG5vZGUsIGdvdCBgXCIgKyBlICsgXCJgXCIpO1xuICByZXR1cm4gS24uY2FsbChuLmhhbmRsZXJzLCByKSA/IG4uaGFuZGxlcnNbcl0obiwgZSwgdCkgOiBuLnBhc3NUaHJvdWdoICYmIG4ucGFzc1Rocm91Z2guaW5jbHVkZXMocikgPyBcImNoaWxkcmVuXCIgaW4gZSA/IHsgLi4uZSwgY2hpbGRyZW46IEllKG4sIGUpIH0gOiBlIDogbi51bmtub3duSGFuZGxlciA/IG4udW5rbm93bkhhbmRsZXIobiwgZSwgdCkgOiBDbyhuLCBlKTtcbn1cbmZ1bmN0aW9uIEllKG4sIGUpIHtcbiAgY29uc3QgdCA9IFtdO1xuICBpZiAoXCJjaGlsZHJlblwiIGluIGUpIHtcbiAgICBjb25zdCByID0gZS5jaGlsZHJlbjtcbiAgICBsZXQgaSA9IC0xO1xuICAgIGZvciAoOyArK2kgPCByLmxlbmd0aDsgKSB7XG4gICAgICBjb25zdCBsID0gS3QobiwgcltpXSwgZSk7XG4gICAgICBpZiAobCkge1xuICAgICAgICBpZiAoaSAmJiByW2kgLSAxXS50eXBlID09PSBcImJyZWFrXCIgJiYgKCFBcnJheS5pc0FycmF5KGwpICYmIGwudHlwZSA9PT0gXCJ0ZXh0XCIgJiYgKGwudmFsdWUgPSBsLnZhbHVlLnJlcGxhY2UoL15cXHMrLywgXCJcIikpLCAhQXJyYXkuaXNBcnJheShsKSAmJiBsLnR5cGUgPT09IFwiZWxlbWVudFwiKSkge1xuICAgICAgICAgIGNvbnN0IG8gPSBsLmNoaWxkcmVuWzBdO1xuICAgICAgICAgIG8gJiYgby50eXBlID09PSBcInRleHRcIiAmJiAoby52YWx1ZSA9IG8udmFsdWUucmVwbGFjZSgvXlxccysvLCBcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgQXJyYXkuaXNBcnJheShsKSA/IHQucHVzaCguLi5sKSA6IHQucHVzaChsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBDbyhuLCBlKSB7XG4gIGNvbnN0IHQgPSBlLmRhdGEgfHwge30sIHIgPSBcInZhbHVlXCIgaW4gZSAmJiAhKEtuLmNhbGwodCwgXCJoUHJvcGVydGllc1wiKSB8fCBLbi5jYWxsKHQsIFwiaENoaWxkcmVuXCIpKSA/IHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBlLnZhbHVlIH0gOiB7XG4gICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgdGFnTmFtZTogXCJkaXZcIixcbiAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICBjaGlsZHJlbjogSWUobiwgZSlcbiAgfTtcbiAgcmV0dXJuIG4ucGF0Y2goZSwgciksIG4uYXBwbHlEYXRhKGUsIHIpO1xufVxuZnVuY3Rpb24gQW8obiwgZSkge1xuICBjb25zdCB0ID0gW107XG4gIGxldCByID0gLTE7XG4gIGZvciAoZSAmJiB0LnB1c2goeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IGBcbmAgfSk7ICsrciA8IG4ubGVuZ3RoOyApXG4gICAgciAmJiB0LnB1c2goeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IGBcbmAgfSksIHQucHVzaChuW3JdKTtcbiAgcmV0dXJuIGUgJiYgbi5sZW5ndGggPiAwICYmIHQucHVzaCh7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogYFxuYCB9KSwgdDtcbn1cbmZ1bmN0aW9uIFBvKG4pIHtcbiAgY29uc3QgZSA9IFtdO1xuICBsZXQgdCA9IC0xO1xuICBmb3IgKDsgKyt0IDwgbi5mb290bm90ZU9yZGVyLmxlbmd0aDsgKSB7XG4gICAgY29uc3QgciA9IG4uZm9vdG5vdGVCeUlkW24uZm9vdG5vdGVPcmRlclt0XV07XG4gICAgaWYgKCFyKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgaSA9IG4uYWxsKHIpLCBsID0gU3RyaW5nKHIuaWRlbnRpZmllcikudG9VcHBlckNhc2UoKSwgbyA9IHZuKGwudG9Mb3dlckNhc2UoKSk7XG4gICAgbGV0IHUgPSAwO1xuICAgIGNvbnN0IGEgPSBbXTtcbiAgICBmb3IgKDsgKyt1IDw9IG4uZm9vdG5vdGVDb3VudHNbbF07ICkge1xuICAgICAgY29uc3QgaCA9IHtcbiAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgIHRhZ05hbWU6IFwiYVwiLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgaHJlZjogXCIjXCIgKyBuLmNsb2JiZXJQcmVmaXggKyBcImZucmVmLVwiICsgbyArICh1ID4gMSA/IFwiLVwiICsgdSA6IFwiXCIpLFxuICAgICAgICAgIGRhdGFGb290bm90ZUJhY2tyZWY6ICEwLFxuICAgICAgICAgIGNsYXNzTmFtZTogW1wiZGF0YS1mb290bm90ZS1iYWNrcmVmXCJdLFxuICAgICAgICAgIGFyaWFMYWJlbDogbi5mb290bm90ZUJhY2tMYWJlbFxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogW3sgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBcIuKGqVwiIH1dXG4gICAgICB9O1xuICAgICAgdSA+IDEgJiYgaC5jaGlsZHJlbi5wdXNoKHtcbiAgICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICAgIHRhZ05hbWU6IFwic3VwXCIsXG4gICAgICAgIGNoaWxkcmVuOiBbeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IFN0cmluZyh1KSB9XVxuICAgICAgfSksIGEubGVuZ3RoID4gMCAmJiBhLnB1c2goeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IFwiIFwiIH0pLCBhLnB1c2goaCk7XG4gICAgfVxuICAgIGNvbnN0IGMgPSBpW2kubGVuZ3RoIC0gMV07XG4gICAgaWYgKGMgJiYgYy50eXBlID09PSBcImVsZW1lbnRcIiAmJiBjLnRhZ05hbWUgPT09IFwicFwiKSB7XG4gICAgICBjb25zdCBoID0gYy5jaGlsZHJlbltjLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgaCAmJiBoLnR5cGUgPT09IFwidGV4dFwiID8gaC52YWx1ZSArPSBcIiBcIiA6IGMuY2hpbGRyZW4ucHVzaCh7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogXCIgXCIgfSksIGMuY2hpbGRyZW4ucHVzaCguLi5hKTtcbiAgICB9IGVsc2VcbiAgICAgIGkucHVzaCguLi5hKTtcbiAgICBjb25zdCBzID0ge1xuICAgICAgdHlwZTogXCJlbGVtZW50XCIsXG4gICAgICB0YWdOYW1lOiBcImxpXCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7IGlkOiBuLmNsb2JiZXJQcmVmaXggKyBcImZuLVwiICsgbyB9LFxuICAgICAgY2hpbGRyZW46IG4ud3JhcChpLCAhMClcbiAgICB9O1xuICAgIG4ucGF0Y2gociwgcyksIGUucHVzaChzKTtcbiAgfVxuICBpZiAoZS5sZW5ndGggIT09IDApXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgdGFnTmFtZTogXCJzZWN0aW9uXCIsXG4gICAgICBwcm9wZXJ0aWVzOiB7IGRhdGFGb290bm90ZXM6ICEwLCBjbGFzc05hbWU6IFtcImZvb3Rub3Rlc1wiXSB9LFxuICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICAgIHRhZ05hbWU6IG4uZm9vdG5vdGVMYWJlbFRhZ05hbWUsXG4gICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgLy8gVG8gZG86IHVzZSBzdHJ1Y3R1cmVkIGNsb25lLlxuICAgICAgICAgICAgLi4uSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShuLmZvb3Rub3RlTGFiZWxQcm9wZXJ0aWVzKSksXG4gICAgICAgICAgICBpZDogXCJmb290bm90ZS1sYWJlbFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogW3sgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBuLmZvb3Rub3RlTGFiZWwgfV1cbiAgICAgICAgfSxcbiAgICAgICAgeyB0eXBlOiBcInRleHRcIiwgdmFsdWU6IGBcbmAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiZWxlbWVudFwiLFxuICAgICAgICAgIHRhZ05hbWU6IFwib2xcIixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgICBjaGlsZHJlbjogbi53cmFwKGUsICEwKVxuICAgICAgICB9LFxuICAgICAgICB7IHR5cGU6IFwidGV4dFwiLCB2YWx1ZTogYFxuYCB9XG4gICAgICBdXG4gICAgfTtcbn1cbmZ1bmN0aW9uIEd0KG4sIGUpIHtcbiAgY29uc3QgdCA9IHdvKG4sIGUpLCByID0gdC5vbmUobiwgbnVsbCksIGkgPSBQbyh0KTtcbiAgcmV0dXJuIGkgJiYgci5jaGlsZHJlbi5wdXNoKHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlOiBgXG5gIH0sIGkpLCBBcnJheS5pc0FycmF5KHIpID8geyB0eXBlOiBcInJvb3RcIiwgY2hpbGRyZW46IHIgfSA6IHI7XG59XG5jb25zdCBGbyA9IChcbiAgLyoqIEB0eXBlIHsoaW1wb3J0KCd1bmlmaWVkJykuUGx1Z2luPFtQcm9jZXNzb3IsIE9wdGlvbnM/XXxbbnVsbHx1bmRlZmluZWQsIE9wdGlvbnM/XXxbT3B0aW9uc118W10sIE1kYXN0Um9vdD4pfSAqL1xuICBmdW5jdGlvbihuLCBlKSB7XG4gICAgcmV0dXJuIG4gJiYgXCJydW5cIiBpbiBuID8gSW8obiwgZSkgOiBPbyhuIHx8IGUpO1xuICB9XG4pLCBUbyA9IEZvO1xuZnVuY3Rpb24gSW8obiwgZSkge1xuICByZXR1cm4gKHQsIHIsIGkpID0+IHtcbiAgICBuLnJ1bihHdCh0LCBlKSwgciwgKGwpID0+IHtcbiAgICAgIGkobCk7XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBPbyhuKSB7XG4gIHJldHVybiAoZSkgPT4gR3QoZSwgbik7XG59XG5jbGFzcyBVbiB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtQcm9wZXJ0aWVzfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge05vcm1hbH0gbm9ybWFsXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3BhY2VdXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlLCB0LCByKSB7XG4gICAgdGhpcy5wcm9wZXJ0eSA9IGUsIHRoaXMubm9ybWFsID0gdCwgciAmJiAodGhpcy5zcGFjZSA9IHIpO1xuICB9XG59XG5Vbi5wcm90b3R5cGUucHJvcGVydHkgPSB7fTtcblVuLnByb3RvdHlwZS5ub3JtYWwgPSB7fTtcblVuLnByb3RvdHlwZS5zcGFjZSA9IG51bGw7XG5mdW5jdGlvbiBadChuLCBlKSB7XG4gIGNvbnN0IHQgPSB7fSwgciA9IHt9O1xuICBsZXQgaSA9IC0xO1xuICBmb3IgKDsgKytpIDwgbi5sZW5ndGg7IClcbiAgICBPYmplY3QuYXNzaWduKHQsIG5baV0ucHJvcGVydHkpLCBPYmplY3QuYXNzaWduKHIsIG5baV0ubm9ybWFsKTtcbiAgcmV0dXJuIG5ldyBVbih0LCByLCBlKTtcbn1cbmZ1bmN0aW9uIGJlKG4pIHtcbiAgcmV0dXJuIG4udG9Mb3dlckNhc2UoKTtcbn1cbmNsYXNzIHBuIHtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMucHJvcGVydHkgPSBlLCB0aGlzLmF0dHJpYnV0ZSA9IHQ7XG4gIH1cbn1cbnBuLnByb3RvdHlwZS5zcGFjZSA9IG51bGw7XG5wbi5wcm90b3R5cGUuYm9vbGVhbiA9ICExO1xucG4ucHJvdG90eXBlLmJvb2xlYW5pc2ggPSAhMTtcbnBuLnByb3RvdHlwZS5vdmVybG9hZGVkQm9vbGVhbiA9ICExO1xucG4ucHJvdG90eXBlLm51bWJlciA9ICExO1xucG4ucHJvdG90eXBlLmNvbW1hU2VwYXJhdGVkID0gITE7XG5wbi5wcm90b3R5cGUuc3BhY2VTZXBhcmF0ZWQgPSAhMTtcbnBuLnByb3RvdHlwZS5jb21tYU9yU3BhY2VTZXBhcmF0ZWQgPSAhMTtcbnBuLnByb3RvdHlwZS5tdXN0VXNlUHJvcGVydHkgPSAhMTtcbnBuLnByb3RvdHlwZS5kZWZpbmVkID0gITE7XG5sZXQgTG8gPSAwO1xuY29uc3QgeiA9IEluKCksIEsgPSBJbigpLCBKdCA9IEluKCksIFMgPSBJbigpLCBWID0gSW4oKSwgRG4gPSBJbigpLCBsbiA9IEluKCk7XG5mdW5jdGlvbiBJbigpIHtcbiAgcmV0dXJuIDIgKiogKytMbztcbn1cbmNvbnN0IHdlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYm9vbGVhbjogeixcbiAgYm9vbGVhbmlzaDogSyxcbiAgY29tbWFPclNwYWNlU2VwYXJhdGVkOiBsbixcbiAgY29tbWFTZXBhcmF0ZWQ6IERuLFxuICBudW1iZXI6IFMsXG4gIG92ZXJsb2FkZWRCb29sZWFuOiBKdCxcbiAgc3BhY2VTZXBhcmF0ZWQ6IFZcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIHBlID0gT2JqZWN0LmtleXMod2UpO1xuY2xhc3MgT2UgZXh0ZW5kcyBwbiB7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAgICogQHBhcmFtIHtudW1iZXJ8bnVsbH0gW21hc2tdXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbc3BhY2VdXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlLCB0LCByLCBpKSB7XG4gICAgbGV0IGwgPSAtMTtcbiAgICBpZiAoc3VwZXIoZSwgdCksIGR0KHRoaXMsIFwic3BhY2VcIiwgaSksIHR5cGVvZiByID09IFwibnVtYmVyXCIpXG4gICAgICBmb3IgKDsgKytsIDwgcGUubGVuZ3RoOyApIHtcbiAgICAgICAgY29uc3QgbyA9IHBlW2xdO1xuICAgICAgICBkdCh0aGlzLCBwZVtsXSwgKHIgJiB3ZVtvXSkgPT09IHdlW29dKTtcbiAgICAgIH1cbiAgfVxufVxuT2UucHJvdG90eXBlLmRlZmluZWQgPSAhMDtcbmZ1bmN0aW9uIGR0KG4sIGUsIHQpIHtcbiAgdCAmJiAobltlXSA9IHQpO1xufVxuY29uc3QgRG8gPSB7fS5oYXNPd25Qcm9wZXJ0eTtcbmZ1bmN0aW9uIHpuKG4pIHtcbiAgY29uc3QgZSA9IHt9LCB0ID0ge307XG4gIGxldCByO1xuICBmb3IgKHIgaW4gbi5wcm9wZXJ0aWVzKVxuICAgIGlmIChEby5jYWxsKG4ucHJvcGVydGllcywgcikpIHtcbiAgICAgIGNvbnN0IGkgPSBuLnByb3BlcnRpZXNbcl0sIGwgPSBuZXcgT2UoXG4gICAgICAgIHIsXG4gICAgICAgIG4udHJhbnNmb3JtKG4uYXR0cmlidXRlcyB8fCB7fSwgciksXG4gICAgICAgIGksXG4gICAgICAgIG4uc3BhY2VcbiAgICAgICk7XG4gICAgICBuLm11c3RVc2VQcm9wZXJ0eSAmJiBuLm11c3RVc2VQcm9wZXJ0eS5pbmNsdWRlcyhyKSAmJiAobC5tdXN0VXNlUHJvcGVydHkgPSAhMCksIGVbcl0gPSBsLCB0W2JlKHIpXSA9IHIsIHRbYmUobC5hdHRyaWJ1dGUpXSA9IHI7XG4gICAgfVxuICByZXR1cm4gbmV3IFVuKGUsIHQsIG4uc3BhY2UpO1xufVxuY29uc3QgbnIgPSB6bih7XG4gIHNwYWNlOiBcInhsaW5rXCIsXG4gIHRyYW5zZm9ybShuLCBlKSB7XG4gICAgcmV0dXJuIFwieGxpbms6XCIgKyBlLnNsaWNlKDUpLnRvTG93ZXJDYXNlKCk7XG4gIH0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB4TGlua0FjdHVhdGU6IG51bGwsXG4gICAgeExpbmtBcmNSb2xlOiBudWxsLFxuICAgIHhMaW5rSHJlZjogbnVsbCxcbiAgICB4TGlua1JvbGU6IG51bGwsXG4gICAgeExpbmtTaG93OiBudWxsLFxuICAgIHhMaW5rVGl0bGU6IG51bGwsXG4gICAgeExpbmtUeXBlOiBudWxsXG4gIH1cbn0pLCBlciA9IHpuKHtcbiAgc3BhY2U6IFwieG1sXCIsXG4gIHRyYW5zZm9ybShuLCBlKSB7XG4gICAgcmV0dXJuIFwieG1sOlwiICsgZS5zbGljZSgzKS50b0xvd2VyQ2FzZSgpO1xuICB9LFxuICBwcm9wZXJ0aWVzOiB7IHhtbExhbmc6IG51bGwsIHhtbEJhc2U6IG51bGwsIHhtbFNwYWNlOiBudWxsIH1cbn0pO1xuZnVuY3Rpb24gdHIobiwgZSkge1xuICByZXR1cm4gZSBpbiBuID8gbltlXSA6IGU7XG59XG5mdW5jdGlvbiBycihuLCBlKSB7XG4gIHJldHVybiB0cihuLCBlLnRvTG93ZXJDYXNlKCkpO1xufVxuY29uc3QgaXIgPSB6bih7XG4gIHNwYWNlOiBcInhtbG5zXCIsXG4gIGF0dHJpYnV0ZXM6IHsgeG1sbnN4bGluazogXCJ4bWxuczp4bGlua1wiIH0sXG4gIHRyYW5zZm9ybTogcnIsXG4gIHByb3BlcnRpZXM6IHsgeG1sbnM6IG51bGwsIHhtbG5zWExpbms6IG51bGwgfVxufSksIGxyID0gem4oe1xuICB0cmFuc2Zvcm0obiwgZSkge1xuICAgIHJldHVybiBlID09PSBcInJvbGVcIiA/IGUgOiBcImFyaWEtXCIgKyBlLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCk7XG4gIH0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICBhcmlhQWN0aXZlRGVzY2VuZGFudDogbnVsbCxcbiAgICBhcmlhQXRvbWljOiBLLFxuICAgIGFyaWFBdXRvQ29tcGxldGU6IG51bGwsXG4gICAgYXJpYUJ1c3k6IEssXG4gICAgYXJpYUNoZWNrZWQ6IEssXG4gICAgYXJpYUNvbENvdW50OiBTLFxuICAgIGFyaWFDb2xJbmRleDogUyxcbiAgICBhcmlhQ29sU3BhbjogUyxcbiAgICBhcmlhQ29udHJvbHM6IFYsXG4gICAgYXJpYUN1cnJlbnQ6IG51bGwsXG4gICAgYXJpYURlc2NyaWJlZEJ5OiBWLFxuICAgIGFyaWFEZXRhaWxzOiBudWxsLFxuICAgIGFyaWFEaXNhYmxlZDogSyxcbiAgICBhcmlhRHJvcEVmZmVjdDogVixcbiAgICBhcmlhRXJyb3JNZXNzYWdlOiBudWxsLFxuICAgIGFyaWFFeHBhbmRlZDogSyxcbiAgICBhcmlhRmxvd1RvOiBWLFxuICAgIGFyaWFHcmFiYmVkOiBLLFxuICAgIGFyaWFIYXNQb3B1cDogbnVsbCxcbiAgICBhcmlhSGlkZGVuOiBLLFxuICAgIGFyaWFJbnZhbGlkOiBudWxsLFxuICAgIGFyaWFLZXlTaG9ydGN1dHM6IG51bGwsXG4gICAgYXJpYUxhYmVsOiBudWxsLFxuICAgIGFyaWFMYWJlbGxlZEJ5OiBWLFxuICAgIGFyaWFMZXZlbDogUyxcbiAgICBhcmlhTGl2ZTogbnVsbCxcbiAgICBhcmlhTW9kYWw6IEssXG4gICAgYXJpYU11bHRpTGluZTogSyxcbiAgICBhcmlhTXVsdGlTZWxlY3RhYmxlOiBLLFxuICAgIGFyaWFPcmllbnRhdGlvbjogbnVsbCxcbiAgICBhcmlhT3duczogVixcbiAgICBhcmlhUGxhY2Vob2xkZXI6IG51bGwsXG4gICAgYXJpYVBvc0luU2V0OiBTLFxuICAgIGFyaWFQcmVzc2VkOiBLLFxuICAgIGFyaWFSZWFkT25seTogSyxcbiAgICBhcmlhUmVsZXZhbnQ6IG51bGwsXG4gICAgYXJpYVJlcXVpcmVkOiBLLFxuICAgIGFyaWFSb2xlRGVzY3JpcHRpb246IFYsXG4gICAgYXJpYVJvd0NvdW50OiBTLFxuICAgIGFyaWFSb3dJbmRleDogUyxcbiAgICBhcmlhUm93U3BhbjogUyxcbiAgICBhcmlhU2VsZWN0ZWQ6IEssXG4gICAgYXJpYVNldFNpemU6IFMsXG4gICAgYXJpYVNvcnQ6IG51bGwsXG4gICAgYXJpYVZhbHVlTWF4OiBTLFxuICAgIGFyaWFWYWx1ZU1pbjogUyxcbiAgICBhcmlhVmFsdWVOb3c6IFMsXG4gICAgYXJpYVZhbHVlVGV4dDogbnVsbCxcbiAgICByb2xlOiBudWxsXG4gIH1cbn0pLCB2byA9IHpuKHtcbiAgc3BhY2U6IFwiaHRtbFwiLFxuICBhdHRyaWJ1dGVzOiB7XG4gICAgYWNjZXB0Y2hhcnNldDogXCJhY2NlcHQtY2hhcnNldFwiLFxuICAgIGNsYXNzbmFtZTogXCJjbGFzc1wiLFxuICAgIGh0bWxmb3I6IFwiZm9yXCIsXG4gICAgaHR0cGVxdWl2OiBcImh0dHAtZXF1aXZcIlxuICB9LFxuICB0cmFuc2Zvcm06IHJyLFxuICBtdXN0VXNlUHJvcGVydHk6IFtcImNoZWNrZWRcIiwgXCJtdWx0aXBsZVwiLCBcIm11dGVkXCIsIFwic2VsZWN0ZWRcIl0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvLyBTdGFuZGFyZCBQcm9wZXJ0aWVzLlxuICAgIGFiYnI6IG51bGwsXG4gICAgYWNjZXB0OiBEbixcbiAgICBhY2NlcHRDaGFyc2V0OiBWLFxuICAgIGFjY2Vzc0tleTogVixcbiAgICBhY3Rpb246IG51bGwsXG4gICAgYWxsb3c6IG51bGwsXG4gICAgYWxsb3dGdWxsU2NyZWVuOiB6LFxuICAgIGFsbG93UGF5bWVudFJlcXVlc3Q6IHosXG4gICAgYWxsb3dVc2VyTWVkaWE6IHosXG4gICAgYWx0OiBudWxsLFxuICAgIGFzOiBudWxsLFxuICAgIGFzeW5jOiB6LFxuICAgIGF1dG9DYXBpdGFsaXplOiBudWxsLFxuICAgIGF1dG9Db21wbGV0ZTogVixcbiAgICBhdXRvRm9jdXM6IHosXG4gICAgYXV0b1BsYXk6IHosXG4gICAgY2FwdHVyZTogeixcbiAgICBjaGFyU2V0OiBudWxsLFxuICAgIGNoZWNrZWQ6IHosXG4gICAgY2l0ZTogbnVsbCxcbiAgICBjbGFzc05hbWU6IFYsXG4gICAgY29sczogUyxcbiAgICBjb2xTcGFuOiBudWxsLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgY29udGVudEVkaXRhYmxlOiBLLFxuICAgIGNvbnRyb2xzOiB6LFxuICAgIGNvbnRyb2xzTGlzdDogVixcbiAgICBjb29yZHM6IFMgfCBEbixcbiAgICBjcm9zc09yaWdpbjogbnVsbCxcbiAgICBkYXRhOiBudWxsLFxuICAgIGRhdGVUaW1lOiBudWxsLFxuICAgIGRlY29kaW5nOiBudWxsLFxuICAgIGRlZmF1bHQ6IHosXG4gICAgZGVmZXI6IHosXG4gICAgZGlyOiBudWxsLFxuICAgIGRpck5hbWU6IG51bGwsXG4gICAgZGlzYWJsZWQ6IHosXG4gICAgZG93bmxvYWQ6IEp0LFxuICAgIGRyYWdnYWJsZTogSyxcbiAgICBlbmNUeXBlOiBudWxsLFxuICAgIGVudGVyS2V5SGludDogbnVsbCxcbiAgICBmb3JtOiBudWxsLFxuICAgIGZvcm1BY3Rpb246IG51bGwsXG4gICAgZm9ybUVuY1R5cGU6IG51bGwsXG4gICAgZm9ybU1ldGhvZDogbnVsbCxcbiAgICBmb3JtTm9WYWxpZGF0ZTogeixcbiAgICBmb3JtVGFyZ2V0OiBudWxsLFxuICAgIGhlYWRlcnM6IFYsXG4gICAgaGVpZ2h0OiBTLFxuICAgIGhpZGRlbjogeixcbiAgICBoaWdoOiBTLFxuICAgIGhyZWY6IG51bGwsXG4gICAgaHJlZkxhbmc6IG51bGwsXG4gICAgaHRtbEZvcjogVixcbiAgICBodHRwRXF1aXY6IFYsXG4gICAgaWQ6IG51bGwsXG4gICAgaW1hZ2VTaXplczogbnVsbCxcbiAgICBpbWFnZVNyY1NldDogbnVsbCxcbiAgICBpbnB1dE1vZGU6IG51bGwsXG4gICAgaW50ZWdyaXR5OiBudWxsLFxuICAgIGlzOiBudWxsLFxuICAgIGlzTWFwOiB6LFxuICAgIGl0ZW1JZDogbnVsbCxcbiAgICBpdGVtUHJvcDogVixcbiAgICBpdGVtUmVmOiBWLFxuICAgIGl0ZW1TY29wZTogeixcbiAgICBpdGVtVHlwZTogVixcbiAgICBraW5kOiBudWxsLFxuICAgIGxhYmVsOiBudWxsLFxuICAgIGxhbmc6IG51bGwsXG4gICAgbGFuZ3VhZ2U6IG51bGwsXG4gICAgbGlzdDogbnVsbCxcbiAgICBsb2FkaW5nOiBudWxsLFxuICAgIGxvb3A6IHosXG4gICAgbG93OiBTLFxuICAgIG1hbmlmZXN0OiBudWxsLFxuICAgIG1heDogbnVsbCxcbiAgICBtYXhMZW5ndGg6IFMsXG4gICAgbWVkaWE6IG51bGwsXG4gICAgbWV0aG9kOiBudWxsLFxuICAgIG1pbjogbnVsbCxcbiAgICBtaW5MZW5ndGg6IFMsXG4gICAgbXVsdGlwbGU6IHosXG4gICAgbXV0ZWQ6IHosXG4gICAgbmFtZTogbnVsbCxcbiAgICBub25jZTogbnVsbCxcbiAgICBub01vZHVsZTogeixcbiAgICBub1ZhbGlkYXRlOiB6LFxuICAgIG9uQWJvcnQ6IG51bGwsXG4gICAgb25BZnRlclByaW50OiBudWxsLFxuICAgIG9uQXV4Q2xpY2s6IG51bGwsXG4gICAgb25CZWZvcmVNYXRjaDogbnVsbCxcbiAgICBvbkJlZm9yZVByaW50OiBudWxsLFxuICAgIG9uQmVmb3JlVW5sb2FkOiBudWxsLFxuICAgIG9uQmx1cjogbnVsbCxcbiAgICBvbkNhbmNlbDogbnVsbCxcbiAgICBvbkNhblBsYXk6IG51bGwsXG4gICAgb25DYW5QbGF5VGhyb3VnaDogbnVsbCxcbiAgICBvbkNoYW5nZTogbnVsbCxcbiAgICBvbkNsaWNrOiBudWxsLFxuICAgIG9uQ2xvc2U6IG51bGwsXG4gICAgb25Db250ZXh0TG9zdDogbnVsbCxcbiAgICBvbkNvbnRleHRNZW51OiBudWxsLFxuICAgIG9uQ29udGV4dFJlc3RvcmVkOiBudWxsLFxuICAgIG9uQ29weTogbnVsbCxcbiAgICBvbkN1ZUNoYW5nZTogbnVsbCxcbiAgICBvbkN1dDogbnVsbCxcbiAgICBvbkRibENsaWNrOiBudWxsLFxuICAgIG9uRHJhZzogbnVsbCxcbiAgICBvbkRyYWdFbmQ6IG51bGwsXG4gICAgb25EcmFnRW50ZXI6IG51bGwsXG4gICAgb25EcmFnRXhpdDogbnVsbCxcbiAgICBvbkRyYWdMZWF2ZTogbnVsbCxcbiAgICBvbkRyYWdPdmVyOiBudWxsLFxuICAgIG9uRHJhZ1N0YXJ0OiBudWxsLFxuICAgIG9uRHJvcDogbnVsbCxcbiAgICBvbkR1cmF0aW9uQ2hhbmdlOiBudWxsLFxuICAgIG9uRW1wdGllZDogbnVsbCxcbiAgICBvbkVuZGVkOiBudWxsLFxuICAgIG9uRXJyb3I6IG51bGwsXG4gICAgb25Gb2N1czogbnVsbCxcbiAgICBvbkZvcm1EYXRhOiBudWxsLFxuICAgIG9uSGFzaENoYW5nZTogbnVsbCxcbiAgICBvbklucHV0OiBudWxsLFxuICAgIG9uSW52YWxpZDogbnVsbCxcbiAgICBvbktleURvd246IG51bGwsXG4gICAgb25LZXlQcmVzczogbnVsbCxcbiAgICBvbktleVVwOiBudWxsLFxuICAgIG9uTGFuZ3VhZ2VDaGFuZ2U6IG51bGwsXG4gICAgb25Mb2FkOiBudWxsLFxuICAgIG9uTG9hZGVkRGF0YTogbnVsbCxcbiAgICBvbkxvYWRlZE1ldGFkYXRhOiBudWxsLFxuICAgIG9uTG9hZEVuZDogbnVsbCxcbiAgICBvbkxvYWRTdGFydDogbnVsbCxcbiAgICBvbk1lc3NhZ2U6IG51bGwsXG4gICAgb25NZXNzYWdlRXJyb3I6IG51bGwsXG4gICAgb25Nb3VzZURvd246IG51bGwsXG4gICAgb25Nb3VzZUVudGVyOiBudWxsLFxuICAgIG9uTW91c2VMZWF2ZTogbnVsbCxcbiAgICBvbk1vdXNlTW92ZTogbnVsbCxcbiAgICBvbk1vdXNlT3V0OiBudWxsLFxuICAgIG9uTW91c2VPdmVyOiBudWxsLFxuICAgIG9uTW91c2VVcDogbnVsbCxcbiAgICBvbk9mZmxpbmU6IG51bGwsXG4gICAgb25PbmxpbmU6IG51bGwsXG4gICAgb25QYWdlSGlkZTogbnVsbCxcbiAgICBvblBhZ2VTaG93OiBudWxsLFxuICAgIG9uUGFzdGU6IG51bGwsXG4gICAgb25QYXVzZTogbnVsbCxcbiAgICBvblBsYXk6IG51bGwsXG4gICAgb25QbGF5aW5nOiBudWxsLFxuICAgIG9uUG9wU3RhdGU6IG51bGwsXG4gICAgb25Qcm9ncmVzczogbnVsbCxcbiAgICBvblJhdGVDaGFuZ2U6IG51bGwsXG4gICAgb25SZWplY3Rpb25IYW5kbGVkOiBudWxsLFxuICAgIG9uUmVzZXQ6IG51bGwsXG4gICAgb25SZXNpemU6IG51bGwsXG4gICAgb25TY3JvbGw6IG51bGwsXG4gICAgb25TY3JvbGxFbmQ6IG51bGwsXG4gICAgb25TZWN1cml0eVBvbGljeVZpb2xhdGlvbjogbnVsbCxcbiAgICBvblNlZWtlZDogbnVsbCxcbiAgICBvblNlZWtpbmc6IG51bGwsXG4gICAgb25TZWxlY3Q6IG51bGwsXG4gICAgb25TbG90Q2hhbmdlOiBudWxsLFxuICAgIG9uU3RhbGxlZDogbnVsbCxcbiAgICBvblN0b3JhZ2U6IG51bGwsXG4gICAgb25TdWJtaXQ6IG51bGwsXG4gICAgb25TdXNwZW5kOiBudWxsLFxuICAgIG9uVGltZVVwZGF0ZTogbnVsbCxcbiAgICBvblRvZ2dsZTogbnVsbCxcbiAgICBvblVuaGFuZGxlZFJlamVjdGlvbjogbnVsbCxcbiAgICBvblVubG9hZDogbnVsbCxcbiAgICBvblZvbHVtZUNoYW5nZTogbnVsbCxcbiAgICBvbldhaXRpbmc6IG51bGwsXG4gICAgb25XaGVlbDogbnVsbCxcbiAgICBvcGVuOiB6LFxuICAgIG9wdGltdW06IFMsXG4gICAgcGF0dGVybjogbnVsbCxcbiAgICBwaW5nOiBWLFxuICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgIHBsYXlzSW5saW5lOiB6LFxuICAgIHBvc3RlcjogbnVsbCxcbiAgICBwcmVsb2FkOiBudWxsLFxuICAgIHJlYWRPbmx5OiB6LFxuICAgIHJlZmVycmVyUG9saWN5OiBudWxsLFxuICAgIHJlbDogVixcbiAgICByZXF1aXJlZDogeixcbiAgICByZXZlcnNlZDogeixcbiAgICByb3dzOiBTLFxuICAgIHJvd1NwYW46IFMsXG4gICAgc2FuZGJveDogVixcbiAgICBzY29wZTogbnVsbCxcbiAgICBzY29wZWQ6IHosXG4gICAgc2VhbWxlc3M6IHosXG4gICAgc2VsZWN0ZWQ6IHosXG4gICAgc2hhcGU6IG51bGwsXG4gICAgc2l6ZTogUyxcbiAgICBzaXplczogbnVsbCxcbiAgICBzbG90OiBudWxsLFxuICAgIHNwYW46IFMsXG4gICAgc3BlbGxDaGVjazogSyxcbiAgICBzcmM6IG51bGwsXG4gICAgc3JjRG9jOiBudWxsLFxuICAgIHNyY0xhbmc6IG51bGwsXG4gICAgc3JjU2V0OiBudWxsLFxuICAgIHN0YXJ0OiBTLFxuICAgIHN0ZXA6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgdGFiSW5kZXg6IFMsXG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIHRpdGxlOiBudWxsLFxuICAgIHRyYW5zbGF0ZTogbnVsbCxcbiAgICB0eXBlOiBudWxsLFxuICAgIHR5cGVNdXN0TWF0Y2g6IHosXG4gICAgdXNlTWFwOiBudWxsLFxuICAgIHZhbHVlOiBLLFxuICAgIHdpZHRoOiBTLFxuICAgIHdyYXA6IG51bGwsXG4gICAgLy8gTGVnYWN5LlxuICAgIC8vIFNlZTogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jb3RoZXItZWxlbWVudHMsLWF0dHJpYnV0ZXMtYW5kLWFwaXNcbiAgICBhbGlnbjogbnVsbCxcbiAgICAvLyBTZXZlcmFsLiBVc2UgQ1NTIGB0ZXh0LWFsaWduYCBpbnN0ZWFkLFxuICAgIGFMaW5rOiBudWxsLFxuICAgIC8vIGA8Ym9keT5gLiBVc2UgQ1NTIGBhOmFjdGl2ZSB7Y29sb3J9YCBpbnN0ZWFkXG4gICAgYXJjaGl2ZTogVixcbiAgICAvLyBgPG9iamVjdD5gLiBMaXN0IG9mIFVSSXMgdG8gYXJjaGl2ZXNcbiAgICBheGlzOiBudWxsLFxuICAgIC8vIGA8dGQ+YCBhbmQgYDx0aD5gLiBVc2UgYHNjb3BlYCBvbiBgPHRoPmBcbiAgICBiYWNrZ3JvdW5kOiBudWxsLFxuICAgIC8vIGA8Ym9keT5gLiBVc2UgQ1NTIGBiYWNrZ3JvdW5kLWltYWdlYCBpbnN0ZWFkXG4gICAgYmdDb2xvcjogbnVsbCxcbiAgICAvLyBgPGJvZHk+YCBhbmQgdGFibGUgZWxlbWVudHMuIFVzZSBDU1MgYGJhY2tncm91bmQtY29sb3JgIGluc3RlYWRcbiAgICBib3JkZXI6IFMsXG4gICAgLy8gYDx0YWJsZT5gLiBVc2UgQ1NTIGBib3JkZXItd2lkdGhgIGluc3RlYWQsXG4gICAgYm9yZGVyQ29sb3I6IG51bGwsXG4gICAgLy8gYDx0YWJsZT5gLiBVc2UgQ1NTIGBib3JkZXItY29sb3JgIGluc3RlYWQsXG4gICAgYm90dG9tTWFyZ2luOiBTLFxuICAgIC8vIGA8Ym9keT5gXG4gICAgY2VsbFBhZGRpbmc6IG51bGwsXG4gICAgLy8gYDx0YWJsZT5gXG4gICAgY2VsbFNwYWNpbmc6IG51bGwsXG4gICAgLy8gYDx0YWJsZT5gXG4gICAgY2hhcjogbnVsbCxcbiAgICAvLyBTZXZlcmFsIHRhYmxlIGVsZW1lbnRzLiBXaGVuIGBhbGlnbj1jaGFyYCwgc2V0cyB0aGUgY2hhcmFjdGVyIHRvIGFsaWduIG9uXG4gICAgY2hhck9mZjogbnVsbCxcbiAgICAvLyBTZXZlcmFsIHRhYmxlIGVsZW1lbnRzLiBXaGVuIGBjaGFyYCwgb2Zmc2V0cyB0aGUgYWxpZ25tZW50XG4gICAgY2xhc3NJZDogbnVsbCxcbiAgICAvLyBgPG9iamVjdD5gXG4gICAgY2xlYXI6IG51bGwsXG4gICAgLy8gYDxicj5gLiBVc2UgQ1NTIGBjbGVhcmAgaW5zdGVhZFxuICAgIGNvZGU6IG51bGwsXG4gICAgLy8gYDxvYmplY3Q+YFxuICAgIGNvZGVCYXNlOiBudWxsLFxuICAgIC8vIGA8b2JqZWN0PmBcbiAgICBjb2RlVHlwZTogbnVsbCxcbiAgICAvLyBgPG9iamVjdD5gXG4gICAgY29sb3I6IG51bGwsXG4gICAgLy8gYDxmb250PmAgYW5kIGA8aHI+YC4gVXNlIENTUyBpbnN0ZWFkXG4gICAgY29tcGFjdDogeixcbiAgICAvLyBMaXN0cy4gVXNlIENTUyB0byByZWR1Y2Ugc3BhY2UgYmV0d2VlbiBpdGVtcyBpbnN0ZWFkXG4gICAgZGVjbGFyZTogeixcbiAgICAvLyBgPG9iamVjdD5gXG4gICAgZXZlbnQ6IG51bGwsXG4gICAgLy8gYDxzY3JpcHQ+YFxuICAgIGZhY2U6IG51bGwsXG4gICAgLy8gYDxmb250PmAuIFVzZSBDU1MgaW5zdGVhZFxuICAgIGZyYW1lOiBudWxsLFxuICAgIC8vIGA8dGFibGU+YFxuICAgIGZyYW1lQm9yZGVyOiBudWxsLFxuICAgIC8vIGA8aWZyYW1lPmAuIFVzZSBDU1MgYGJvcmRlcmAgaW5zdGVhZFxuICAgIGhTcGFjZTogUyxcbiAgICAvLyBgPGltZz5gIGFuZCBgPG9iamVjdD5gXG4gICAgbGVmdE1hcmdpbjogUyxcbiAgICAvLyBgPGJvZHk+YFxuICAgIGxpbms6IG51bGwsXG4gICAgLy8gYDxib2R5PmAuIFVzZSBDU1MgYGE6bGluayB7Y29sb3I6ICp9YCBpbnN0ZWFkXG4gICAgbG9uZ0Rlc2M6IG51bGwsXG4gICAgLy8gYDxmcmFtZT5gLCBgPGlmcmFtZT5gLCBhbmQgYDxpbWc+YC4gVXNlIGFuIGA8YT5gXG4gICAgbG93U3JjOiBudWxsLFxuICAgIC8vIGA8aW1nPmAuIFVzZSBhIGA8cGljdHVyZT5gXG4gICAgbWFyZ2luSGVpZ2h0OiBTLFxuICAgIC8vIGA8Ym9keT5gXG4gICAgbWFyZ2luV2lkdGg6IFMsXG4gICAgLy8gYDxib2R5PmBcbiAgICBub1Jlc2l6ZTogeixcbiAgICAvLyBgPGZyYW1lPmBcbiAgICBub0hyZWY6IHosXG4gICAgLy8gYDxhcmVhPmAuIFVzZSBubyBocmVmIGluc3RlYWQgb2YgYW4gZXhwbGljaXQgYG5vaHJlZmBcbiAgICBub1NoYWRlOiB6LFxuICAgIC8vIGA8aHI+YC4gVXNlIGJhY2tncm91bmQtY29sb3IgYW5kIGhlaWdodCBpbnN0ZWFkIG9mIGJvcmRlcnNcbiAgICBub1dyYXA6IHosXG4gICAgLy8gYDx0ZD5gIGFuZCBgPHRoPmBcbiAgICBvYmplY3Q6IG51bGwsXG4gICAgLy8gYDxhcHBsZXQ+YFxuICAgIHByb2ZpbGU6IG51bGwsXG4gICAgLy8gYDxoZWFkPmBcbiAgICBwcm9tcHQ6IG51bGwsXG4gICAgLy8gYDxpc2luZGV4PmBcbiAgICByZXY6IG51bGwsXG4gICAgLy8gYDxsaW5rPmBcbiAgICByaWdodE1hcmdpbjogUyxcbiAgICAvLyBgPGJvZHk+YFxuICAgIHJ1bGVzOiBudWxsLFxuICAgIC8vIGA8dGFibGU+YFxuICAgIHNjaGVtZTogbnVsbCxcbiAgICAvLyBgPG1ldGE+YFxuICAgIHNjcm9sbGluZzogSyxcbiAgICAvLyBgPGZyYW1lPmAuIFVzZSBvdmVyZmxvdyBpbiB0aGUgY2hpbGQgY29udGV4dFxuICAgIHN0YW5kYnk6IG51bGwsXG4gICAgLy8gYDxvYmplY3Q+YFxuICAgIHN1bW1hcnk6IG51bGwsXG4gICAgLy8gYDx0YWJsZT5gXG4gICAgdGV4dDogbnVsbCxcbiAgICAvLyBgPGJvZHk+YC4gVXNlIENTUyBgY29sb3JgIGluc3RlYWRcbiAgICB0b3BNYXJnaW46IFMsXG4gICAgLy8gYDxib2R5PmBcbiAgICB2YWx1ZVR5cGU6IG51bGwsXG4gICAgLy8gYDxwYXJhbT5gXG4gICAgdmVyc2lvbjogbnVsbCxcbiAgICAvLyBgPGh0bWw+YC4gVXNlIGEgZG9jdHlwZS5cbiAgICB2QWxpZ246IG51bGwsXG4gICAgLy8gU2V2ZXJhbC4gVXNlIENTUyBgdmVydGljYWwtYWxpZ25gIGluc3RlYWRcbiAgICB2TGluazogbnVsbCxcbiAgICAvLyBgPGJvZHk+YC4gVXNlIENTUyBgYTp2aXNpdGVkIHtjb2xvcn1gIGluc3RlYWRcbiAgICB2U3BhY2U6IFMsXG4gICAgLy8gYDxpbWc+YCBhbmQgYDxvYmplY3Q+YFxuICAgIC8vIE5vbi1zdGFuZGFyZCBQcm9wZXJ0aWVzLlxuICAgIGFsbG93VHJhbnNwYXJlbmN5OiBudWxsLFxuICAgIGF1dG9Db3JyZWN0OiBudWxsLFxuICAgIGF1dG9TYXZlOiBudWxsLFxuICAgIGRpc2FibGVQaWN0dXJlSW5QaWN0dXJlOiB6LFxuICAgIGRpc2FibGVSZW1vdGVQbGF5YmFjazogeixcbiAgICBwcmVmaXg6IG51bGwsXG4gICAgcHJvcGVydHk6IG51bGwsXG4gICAgcmVzdWx0czogUyxcbiAgICBzZWN1cml0eTogbnVsbCxcbiAgICB1bnNlbGVjdGFibGU6IG51bGxcbiAgfVxufSksIHpvID0gem4oe1xuICBzcGFjZTogXCJzdmdcIixcbiAgYXR0cmlidXRlczoge1xuICAgIGFjY2VudEhlaWdodDogXCJhY2NlbnQtaGVpZ2h0XCIsXG4gICAgYWxpZ25tZW50QmFzZWxpbmU6IFwiYWxpZ25tZW50LWJhc2VsaW5lXCIsXG4gICAgYXJhYmljRm9ybTogXCJhcmFiaWMtZm9ybVwiLFxuICAgIGJhc2VsaW5lU2hpZnQ6IFwiYmFzZWxpbmUtc2hpZnRcIixcbiAgICBjYXBIZWlnaHQ6IFwiY2FwLWhlaWdodFwiLFxuICAgIGNsYXNzTmFtZTogXCJjbGFzc1wiLFxuICAgIGNsaXBQYXRoOiBcImNsaXAtcGF0aFwiLFxuICAgIGNsaXBSdWxlOiBcImNsaXAtcnVsZVwiLFxuICAgIGNvbG9ySW50ZXJwb2xhdGlvbjogXCJjb2xvci1pbnRlcnBvbGF0aW9uXCIsXG4gICAgY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVyczogXCJjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnNcIixcbiAgICBjb2xvclByb2ZpbGU6IFwiY29sb3ItcHJvZmlsZVwiLFxuICAgIGNvbG9yUmVuZGVyaW5nOiBcImNvbG9yLXJlbmRlcmluZ1wiLFxuICAgIGNyb3NzT3JpZ2luOiBcImNyb3Nzb3JpZ2luXCIsXG4gICAgZGF0YVR5cGU6IFwiZGF0YXR5cGVcIixcbiAgICBkb21pbmFudEJhc2VsaW5lOiBcImRvbWluYW50LWJhc2VsaW5lXCIsXG4gICAgZW5hYmxlQmFja2dyb3VuZDogXCJlbmFibGUtYmFja2dyb3VuZFwiLFxuICAgIGZpbGxPcGFjaXR5OiBcImZpbGwtb3BhY2l0eVwiLFxuICAgIGZpbGxSdWxlOiBcImZpbGwtcnVsZVwiLFxuICAgIGZsb29kQ29sb3I6IFwiZmxvb2QtY29sb3JcIixcbiAgICBmbG9vZE9wYWNpdHk6IFwiZmxvb2Qtb3BhY2l0eVwiLFxuICAgIGZvbnRGYW1pbHk6IFwiZm9udC1mYW1pbHlcIixcbiAgICBmb250U2l6ZTogXCJmb250LXNpemVcIixcbiAgICBmb250U2l6ZUFkanVzdDogXCJmb250LXNpemUtYWRqdXN0XCIsXG4gICAgZm9udFN0cmV0Y2g6IFwiZm9udC1zdHJldGNoXCIsXG4gICAgZm9udFN0eWxlOiBcImZvbnQtc3R5bGVcIixcbiAgICBmb250VmFyaWFudDogXCJmb250LXZhcmlhbnRcIixcbiAgICBmb250V2VpZ2h0OiBcImZvbnQtd2VpZ2h0XCIsXG4gICAgZ2x5cGhOYW1lOiBcImdseXBoLW5hbWVcIixcbiAgICBnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbDogXCJnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsXCIsXG4gICAgZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsOiBcImdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsXCIsXG4gICAgaHJlZkxhbmc6IFwiaHJlZmxhbmdcIixcbiAgICBob3JpekFkdlg6IFwiaG9yaXotYWR2LXhcIixcbiAgICBob3Jpek9yaWdpblg6IFwiaG9yaXotb3JpZ2luLXhcIixcbiAgICBob3Jpek9yaWdpblk6IFwiaG9yaXotb3JpZ2luLXlcIixcbiAgICBpbWFnZVJlbmRlcmluZzogXCJpbWFnZS1yZW5kZXJpbmdcIixcbiAgICBsZXR0ZXJTcGFjaW5nOiBcImxldHRlci1zcGFjaW5nXCIsXG4gICAgbGlnaHRpbmdDb2xvcjogXCJsaWdodGluZy1jb2xvclwiLFxuICAgIG1hcmtlckVuZDogXCJtYXJrZXItZW5kXCIsXG4gICAgbWFya2VyTWlkOiBcIm1hcmtlci1taWRcIixcbiAgICBtYXJrZXJTdGFydDogXCJtYXJrZXItc3RhcnRcIixcbiAgICBuYXZEb3duOiBcIm5hdi1kb3duXCIsXG4gICAgbmF2RG93bkxlZnQ6IFwibmF2LWRvd24tbGVmdFwiLFxuICAgIG5hdkRvd25SaWdodDogXCJuYXYtZG93bi1yaWdodFwiLFxuICAgIG5hdkxlZnQ6IFwibmF2LWxlZnRcIixcbiAgICBuYXZOZXh0OiBcIm5hdi1uZXh0XCIsXG4gICAgbmF2UHJldjogXCJuYXYtcHJldlwiLFxuICAgIG5hdlJpZ2h0OiBcIm5hdi1yaWdodFwiLFxuICAgIG5hdlVwOiBcIm5hdi11cFwiLFxuICAgIG5hdlVwTGVmdDogXCJuYXYtdXAtbGVmdFwiLFxuICAgIG5hdlVwUmlnaHQ6IFwibmF2LXVwLXJpZ2h0XCIsXG4gICAgb25BYm9ydDogXCJvbmFib3J0XCIsXG4gICAgb25BY3RpdmF0ZTogXCJvbmFjdGl2YXRlXCIsXG4gICAgb25BZnRlclByaW50OiBcIm9uYWZ0ZXJwcmludFwiLFxuICAgIG9uQmVmb3JlUHJpbnQ6IFwib25iZWZvcmVwcmludFwiLFxuICAgIG9uQmVnaW46IFwib25iZWdpblwiLFxuICAgIG9uQ2FuY2VsOiBcIm9uY2FuY2VsXCIsXG4gICAgb25DYW5QbGF5OiBcIm9uY2FucGxheVwiLFxuICAgIG9uQ2FuUGxheVRocm91Z2g6IFwib25jYW5wbGF5dGhyb3VnaFwiLFxuICAgIG9uQ2hhbmdlOiBcIm9uY2hhbmdlXCIsXG4gICAgb25DbGljazogXCJvbmNsaWNrXCIsXG4gICAgb25DbG9zZTogXCJvbmNsb3NlXCIsXG4gICAgb25Db3B5OiBcIm9uY29weVwiLFxuICAgIG9uQ3VlQ2hhbmdlOiBcIm9uY3VlY2hhbmdlXCIsXG4gICAgb25DdXQ6IFwib25jdXRcIixcbiAgICBvbkRibENsaWNrOiBcIm9uZGJsY2xpY2tcIixcbiAgICBvbkRyYWc6IFwib25kcmFnXCIsXG4gICAgb25EcmFnRW5kOiBcIm9uZHJhZ2VuZFwiLFxuICAgIG9uRHJhZ0VudGVyOiBcIm9uZHJhZ2VudGVyXCIsXG4gICAgb25EcmFnRXhpdDogXCJvbmRyYWdleGl0XCIsXG4gICAgb25EcmFnTGVhdmU6IFwib25kcmFnbGVhdmVcIixcbiAgICBvbkRyYWdPdmVyOiBcIm9uZHJhZ292ZXJcIixcbiAgICBvbkRyYWdTdGFydDogXCJvbmRyYWdzdGFydFwiLFxuICAgIG9uRHJvcDogXCJvbmRyb3BcIixcbiAgICBvbkR1cmF0aW9uQ2hhbmdlOiBcIm9uZHVyYXRpb25jaGFuZ2VcIixcbiAgICBvbkVtcHRpZWQ6IFwib25lbXB0aWVkXCIsXG4gICAgb25FbmQ6IFwib25lbmRcIixcbiAgICBvbkVuZGVkOiBcIm9uZW5kZWRcIixcbiAgICBvbkVycm9yOiBcIm9uZXJyb3JcIixcbiAgICBvbkZvY3VzOiBcIm9uZm9jdXNcIixcbiAgICBvbkZvY3VzSW46IFwib25mb2N1c2luXCIsXG4gICAgb25Gb2N1c091dDogXCJvbmZvY3Vzb3V0XCIsXG4gICAgb25IYXNoQ2hhbmdlOiBcIm9uaGFzaGNoYW5nZVwiLFxuICAgIG9uSW5wdXQ6IFwib25pbnB1dFwiLFxuICAgIG9uSW52YWxpZDogXCJvbmludmFsaWRcIixcbiAgICBvbktleURvd246IFwib25rZXlkb3duXCIsXG4gICAgb25LZXlQcmVzczogXCJvbmtleXByZXNzXCIsXG4gICAgb25LZXlVcDogXCJvbmtleXVwXCIsXG4gICAgb25Mb2FkOiBcIm9ubG9hZFwiLFxuICAgIG9uTG9hZGVkRGF0YTogXCJvbmxvYWRlZGRhdGFcIixcbiAgICBvbkxvYWRlZE1ldGFkYXRhOiBcIm9ubG9hZGVkbWV0YWRhdGFcIixcbiAgICBvbkxvYWRTdGFydDogXCJvbmxvYWRzdGFydFwiLFxuICAgIG9uTWVzc2FnZTogXCJvbm1lc3NhZ2VcIixcbiAgICBvbk1vdXNlRG93bjogXCJvbm1vdXNlZG93blwiLFxuICAgIG9uTW91c2VFbnRlcjogXCJvbm1vdXNlZW50ZXJcIixcbiAgICBvbk1vdXNlTGVhdmU6IFwib25tb3VzZWxlYXZlXCIsXG4gICAgb25Nb3VzZU1vdmU6IFwib25tb3VzZW1vdmVcIixcbiAgICBvbk1vdXNlT3V0OiBcIm9ubW91c2VvdXRcIixcbiAgICBvbk1vdXNlT3ZlcjogXCJvbm1vdXNlb3ZlclwiLFxuICAgIG9uTW91c2VVcDogXCJvbm1vdXNldXBcIixcbiAgICBvbk1vdXNlV2hlZWw6IFwib25tb3VzZXdoZWVsXCIsXG4gICAgb25PZmZsaW5lOiBcIm9ub2ZmbGluZVwiLFxuICAgIG9uT25saW5lOiBcIm9ub25saW5lXCIsXG4gICAgb25QYWdlSGlkZTogXCJvbnBhZ2VoaWRlXCIsXG4gICAgb25QYWdlU2hvdzogXCJvbnBhZ2VzaG93XCIsXG4gICAgb25QYXN0ZTogXCJvbnBhc3RlXCIsXG4gICAgb25QYXVzZTogXCJvbnBhdXNlXCIsXG4gICAgb25QbGF5OiBcIm9ucGxheVwiLFxuICAgIG9uUGxheWluZzogXCJvbnBsYXlpbmdcIixcbiAgICBvblBvcFN0YXRlOiBcIm9ucG9wc3RhdGVcIixcbiAgICBvblByb2dyZXNzOiBcIm9ucHJvZ3Jlc3NcIixcbiAgICBvblJhdGVDaGFuZ2U6IFwib25yYXRlY2hhbmdlXCIsXG4gICAgb25SZXBlYXQ6IFwib25yZXBlYXRcIixcbiAgICBvblJlc2V0OiBcIm9ucmVzZXRcIixcbiAgICBvblJlc2l6ZTogXCJvbnJlc2l6ZVwiLFxuICAgIG9uU2Nyb2xsOiBcIm9uc2Nyb2xsXCIsXG4gICAgb25TZWVrZWQ6IFwib25zZWVrZWRcIixcbiAgICBvblNlZWtpbmc6IFwib25zZWVraW5nXCIsXG4gICAgb25TZWxlY3Q6IFwib25zZWxlY3RcIixcbiAgICBvblNob3c6IFwib25zaG93XCIsXG4gICAgb25TdGFsbGVkOiBcIm9uc3RhbGxlZFwiLFxuICAgIG9uU3RvcmFnZTogXCJvbnN0b3JhZ2VcIixcbiAgICBvblN1Ym1pdDogXCJvbnN1Ym1pdFwiLFxuICAgIG9uU3VzcGVuZDogXCJvbnN1c3BlbmRcIixcbiAgICBvblRpbWVVcGRhdGU6IFwib250aW1ldXBkYXRlXCIsXG4gICAgb25Ub2dnbGU6IFwib250b2dnbGVcIixcbiAgICBvblVubG9hZDogXCJvbnVubG9hZFwiLFxuICAgIG9uVm9sdW1lQ2hhbmdlOiBcIm9udm9sdW1lY2hhbmdlXCIsXG4gICAgb25XYWl0aW5nOiBcIm9ud2FpdGluZ1wiLFxuICAgIG9uWm9vbTogXCJvbnpvb21cIixcbiAgICBvdmVybGluZVBvc2l0aW9uOiBcIm92ZXJsaW5lLXBvc2l0aW9uXCIsXG4gICAgb3ZlcmxpbmVUaGlja25lc3M6IFwib3ZlcmxpbmUtdGhpY2tuZXNzXCIsXG4gICAgcGFpbnRPcmRlcjogXCJwYWludC1vcmRlclwiLFxuICAgIHBhbm9zZTE6IFwicGFub3NlLTFcIixcbiAgICBwb2ludGVyRXZlbnRzOiBcInBvaW50ZXItZXZlbnRzXCIsXG4gICAgcmVmZXJyZXJQb2xpY3k6IFwicmVmZXJyZXJwb2xpY3lcIixcbiAgICByZW5kZXJpbmdJbnRlbnQ6IFwicmVuZGVyaW5nLWludGVudFwiLFxuICAgIHNoYXBlUmVuZGVyaW5nOiBcInNoYXBlLXJlbmRlcmluZ1wiLFxuICAgIHN0b3BDb2xvcjogXCJzdG9wLWNvbG9yXCIsXG4gICAgc3RvcE9wYWNpdHk6IFwic3RvcC1vcGFjaXR5XCIsXG4gICAgc3RyaWtldGhyb3VnaFBvc2l0aW9uOiBcInN0cmlrZXRocm91Z2gtcG9zaXRpb25cIixcbiAgICBzdHJpa2V0aHJvdWdoVGhpY2tuZXNzOiBcInN0cmlrZXRocm91Z2gtdGhpY2tuZXNzXCIsXG4gICAgc3Ryb2tlRGFzaEFycmF5OiBcInN0cm9rZS1kYXNoYXJyYXlcIixcbiAgICBzdHJva2VEYXNoT2Zmc2V0OiBcInN0cm9rZS1kYXNob2Zmc2V0XCIsXG4gICAgc3Ryb2tlTGluZUNhcDogXCJzdHJva2UtbGluZWNhcFwiLFxuICAgIHN0cm9rZUxpbmVKb2luOiBcInN0cm9rZS1saW5lam9pblwiLFxuICAgIHN0cm9rZU1pdGVyTGltaXQ6IFwic3Ryb2tlLW1pdGVybGltaXRcIixcbiAgICBzdHJva2VPcGFjaXR5OiBcInN0cm9rZS1vcGFjaXR5XCIsXG4gICAgc3Ryb2tlV2lkdGg6IFwic3Ryb2tlLXdpZHRoXCIsXG4gICAgdGFiSW5kZXg6IFwidGFiaW5kZXhcIixcbiAgICB0ZXh0QW5jaG9yOiBcInRleHQtYW5jaG9yXCIsXG4gICAgdGV4dERlY29yYXRpb246IFwidGV4dC1kZWNvcmF0aW9uXCIsXG4gICAgdGV4dFJlbmRlcmluZzogXCJ0ZXh0LXJlbmRlcmluZ1wiLFxuICAgIHR5cGVPZjogXCJ0eXBlb2ZcIixcbiAgICB1bmRlcmxpbmVQb3NpdGlvbjogXCJ1bmRlcmxpbmUtcG9zaXRpb25cIixcbiAgICB1bmRlcmxpbmVUaGlja25lc3M6IFwidW5kZXJsaW5lLXRoaWNrbmVzc1wiLFxuICAgIHVuaWNvZGVCaWRpOiBcInVuaWNvZGUtYmlkaVwiLFxuICAgIHVuaWNvZGVSYW5nZTogXCJ1bmljb2RlLXJhbmdlXCIsXG4gICAgdW5pdHNQZXJFbTogXCJ1bml0cy1wZXItZW1cIixcbiAgICB2QWxwaGFiZXRpYzogXCJ2LWFscGhhYmV0aWNcIixcbiAgICB2SGFuZ2luZzogXCJ2LWhhbmdpbmdcIixcbiAgICB2SWRlb2dyYXBoaWM6IFwidi1pZGVvZ3JhcGhpY1wiLFxuICAgIHZNYXRoZW1hdGljYWw6IFwidi1tYXRoZW1hdGljYWxcIixcbiAgICB2ZWN0b3JFZmZlY3Q6IFwidmVjdG9yLWVmZmVjdFwiLFxuICAgIHZlcnRBZHZZOiBcInZlcnQtYWR2LXlcIixcbiAgICB2ZXJ0T3JpZ2luWDogXCJ2ZXJ0LW9yaWdpbi14XCIsXG4gICAgdmVydE9yaWdpblk6IFwidmVydC1vcmlnaW4teVwiLFxuICAgIHdvcmRTcGFjaW5nOiBcIndvcmQtc3BhY2luZ1wiLFxuICAgIHdyaXRpbmdNb2RlOiBcIndyaXRpbmctbW9kZVwiLFxuICAgIHhIZWlnaHQ6IFwieC1oZWlnaHRcIixcbiAgICAvLyBUaGVzZSB3ZXJlIGNhbWVsY2FzZWQgaW4gVGlueS4gTm93IGxvd2VyY2FzZWQgaW4gU1ZHIDJcbiAgICBwbGF5YmFja09yZGVyOiBcInBsYXliYWNrb3JkZXJcIixcbiAgICB0aW1lbGluZUJlZ2luOiBcInRpbWVsaW5lYmVnaW5cIlxuICB9LFxuICB0cmFuc2Zvcm06IHRyLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgYWJvdXQ6IGxuLFxuICAgIGFjY2VudEhlaWdodDogUyxcbiAgICBhY2N1bXVsYXRlOiBudWxsLFxuICAgIGFkZGl0aXZlOiBudWxsLFxuICAgIGFsaWdubWVudEJhc2VsaW5lOiBudWxsLFxuICAgIGFscGhhYmV0aWM6IFMsXG4gICAgYW1wbGl0dWRlOiBTLFxuICAgIGFyYWJpY0Zvcm06IG51bGwsXG4gICAgYXNjZW50OiBTLFxuICAgIGF0dHJpYnV0ZU5hbWU6IG51bGwsXG4gICAgYXR0cmlidXRlVHlwZTogbnVsbCxcbiAgICBhemltdXRoOiBTLFxuICAgIGJhbmR3aWR0aDogbnVsbCxcbiAgICBiYXNlbGluZVNoaWZ0OiBudWxsLFxuICAgIGJhc2VGcmVxdWVuY3k6IG51bGwsXG4gICAgYmFzZVByb2ZpbGU6IG51bGwsXG4gICAgYmJveDogbnVsbCxcbiAgICBiZWdpbjogbnVsbCxcbiAgICBiaWFzOiBTLFxuICAgIGJ5OiBudWxsLFxuICAgIGNhbGNNb2RlOiBudWxsLFxuICAgIGNhcEhlaWdodDogUyxcbiAgICBjbGFzc05hbWU6IFYsXG4gICAgY2xpcDogbnVsbCxcbiAgICBjbGlwUGF0aDogbnVsbCxcbiAgICBjbGlwUGF0aFVuaXRzOiBudWxsLFxuICAgIGNsaXBSdWxlOiBudWxsLFxuICAgIGNvbG9yOiBudWxsLFxuICAgIGNvbG9ySW50ZXJwb2xhdGlvbjogbnVsbCxcbiAgICBjb2xvckludGVycG9sYXRpb25GaWx0ZXJzOiBudWxsLFxuICAgIGNvbG9yUHJvZmlsZTogbnVsbCxcbiAgICBjb2xvclJlbmRlcmluZzogbnVsbCxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGNvbnRlbnRTY3JpcHRUeXBlOiBudWxsLFxuICAgIGNvbnRlbnRTdHlsZVR5cGU6IG51bGwsXG4gICAgY3Jvc3NPcmlnaW46IG51bGwsXG4gICAgY3Vyc29yOiBudWxsLFxuICAgIGN4OiBudWxsLFxuICAgIGN5OiBudWxsLFxuICAgIGQ6IG51bGwsXG4gICAgZGF0YVR5cGU6IG51bGwsXG4gICAgZGVmYXVsdEFjdGlvbjogbnVsbCxcbiAgICBkZXNjZW50OiBTLFxuICAgIGRpZmZ1c2VDb25zdGFudDogUyxcbiAgICBkaXJlY3Rpb246IG51bGwsXG4gICAgZGlzcGxheTogbnVsbCxcbiAgICBkdXI6IG51bGwsXG4gICAgZGl2aXNvcjogUyxcbiAgICBkb21pbmFudEJhc2VsaW5lOiBudWxsLFxuICAgIGRvd25sb2FkOiB6LFxuICAgIGR4OiBudWxsLFxuICAgIGR5OiBudWxsLFxuICAgIGVkZ2VNb2RlOiBudWxsLFxuICAgIGVkaXRhYmxlOiBudWxsLFxuICAgIGVsZXZhdGlvbjogUyxcbiAgICBlbmFibGVCYWNrZ3JvdW5kOiBudWxsLFxuICAgIGVuZDogbnVsbCxcbiAgICBldmVudDogbnVsbCxcbiAgICBleHBvbmVudDogUyxcbiAgICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiBudWxsLFxuICAgIGZpbGw6IG51bGwsXG4gICAgZmlsbE9wYWNpdHk6IFMsXG4gICAgZmlsbFJ1bGU6IG51bGwsXG4gICAgZmlsdGVyOiBudWxsLFxuICAgIGZpbHRlclJlczogbnVsbCxcbiAgICBmaWx0ZXJVbml0czogbnVsbCxcbiAgICBmbG9vZENvbG9yOiBudWxsLFxuICAgIGZsb29kT3BhY2l0eTogbnVsbCxcbiAgICBmb2N1c2FibGU6IG51bGwsXG4gICAgZm9jdXNIaWdobGlnaHQ6IG51bGwsXG4gICAgZm9udEZhbWlseTogbnVsbCxcbiAgICBmb250U2l6ZTogbnVsbCxcbiAgICBmb250U2l6ZUFkanVzdDogbnVsbCxcbiAgICBmb250U3RyZXRjaDogbnVsbCxcbiAgICBmb250U3R5bGU6IG51bGwsXG4gICAgZm9udFZhcmlhbnQ6IG51bGwsXG4gICAgZm9udFdlaWdodDogbnVsbCxcbiAgICBmb3JtYXQ6IG51bGwsXG4gICAgZnI6IG51bGwsXG4gICAgZnJvbTogbnVsbCxcbiAgICBmeDogbnVsbCxcbiAgICBmeTogbnVsbCxcbiAgICBnMTogRG4sXG4gICAgZzI6IERuLFxuICAgIGdseXBoTmFtZTogRG4sXG4gICAgZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWw6IG51bGwsXG4gICAgZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsOiBudWxsLFxuICAgIGdseXBoUmVmOiBudWxsLFxuICAgIGdyYWRpZW50VHJhbnNmb3JtOiBudWxsLFxuICAgIGdyYWRpZW50VW5pdHM6IG51bGwsXG4gICAgaGFuZGxlcjogbnVsbCxcbiAgICBoYW5naW5nOiBTLFxuICAgIGhhdGNoQ29udGVudFVuaXRzOiBudWxsLFxuICAgIGhhdGNoVW5pdHM6IG51bGwsXG4gICAgaGVpZ2h0OiBudWxsLFxuICAgIGhyZWY6IG51bGwsXG4gICAgaHJlZkxhbmc6IG51bGwsXG4gICAgaG9yaXpBZHZYOiBTLFxuICAgIGhvcml6T3JpZ2luWDogUyxcbiAgICBob3Jpek9yaWdpblk6IFMsXG4gICAgaWQ6IG51bGwsXG4gICAgaWRlb2dyYXBoaWM6IFMsXG4gICAgaW1hZ2VSZW5kZXJpbmc6IG51bGwsXG4gICAgaW5pdGlhbFZpc2liaWxpdHk6IG51bGwsXG4gICAgaW46IG51bGwsXG4gICAgaW4yOiBudWxsLFxuICAgIGludGVyY2VwdDogUyxcbiAgICBrOiBTLFxuICAgIGsxOiBTLFxuICAgIGsyOiBTLFxuICAgIGszOiBTLFxuICAgIGs0OiBTLFxuICAgIGtlcm5lbE1hdHJpeDogbG4sXG4gICAga2VybmVsVW5pdExlbmd0aDogbnVsbCxcbiAgICBrZXlQb2ludHM6IG51bGwsXG4gICAgLy8gU0VNSV9DT0xPTl9TRVBBUkFURURcbiAgICBrZXlTcGxpbmVzOiBudWxsLFxuICAgIC8vIFNFTUlfQ09MT05fU0VQQVJBVEVEXG4gICAga2V5VGltZXM6IG51bGwsXG4gICAgLy8gU0VNSV9DT0xPTl9TRVBBUkFURURcbiAgICBrZXJuaW5nOiBudWxsLFxuICAgIGxhbmc6IG51bGwsXG4gICAgbGVuZ3RoQWRqdXN0OiBudWxsLFxuICAgIGxldHRlclNwYWNpbmc6IG51bGwsXG4gICAgbGlnaHRpbmdDb2xvcjogbnVsbCxcbiAgICBsaW1pdGluZ0NvbmVBbmdsZTogUyxcbiAgICBsb2NhbDogbnVsbCxcbiAgICBtYXJrZXJFbmQ6IG51bGwsXG4gICAgbWFya2VyTWlkOiBudWxsLFxuICAgIG1hcmtlclN0YXJ0OiBudWxsLFxuICAgIG1hcmtlckhlaWdodDogbnVsbCxcbiAgICBtYXJrZXJVbml0czogbnVsbCxcbiAgICBtYXJrZXJXaWR0aDogbnVsbCxcbiAgICBtYXNrOiBudWxsLFxuICAgIG1hc2tDb250ZW50VW5pdHM6IG51bGwsXG4gICAgbWFza1VuaXRzOiBudWxsLFxuICAgIG1hdGhlbWF0aWNhbDogbnVsbCxcbiAgICBtYXg6IG51bGwsXG4gICAgbWVkaWE6IG51bGwsXG4gICAgbWVkaWFDaGFyYWN0ZXJFbmNvZGluZzogbnVsbCxcbiAgICBtZWRpYUNvbnRlbnRFbmNvZGluZ3M6IG51bGwsXG4gICAgbWVkaWFTaXplOiBTLFxuICAgIG1lZGlhVGltZTogbnVsbCxcbiAgICBtZXRob2Q6IG51bGwsXG4gICAgbWluOiBudWxsLFxuICAgIG1vZGU6IG51bGwsXG4gICAgbmFtZTogbnVsbCxcbiAgICBuYXZEb3duOiBudWxsLFxuICAgIG5hdkRvd25MZWZ0OiBudWxsLFxuICAgIG5hdkRvd25SaWdodDogbnVsbCxcbiAgICBuYXZMZWZ0OiBudWxsLFxuICAgIG5hdk5leHQ6IG51bGwsXG4gICAgbmF2UHJldjogbnVsbCxcbiAgICBuYXZSaWdodDogbnVsbCxcbiAgICBuYXZVcDogbnVsbCxcbiAgICBuYXZVcExlZnQ6IG51bGwsXG4gICAgbmF2VXBSaWdodDogbnVsbCxcbiAgICBudW1PY3RhdmVzOiBudWxsLFxuICAgIG9ic2VydmVyOiBudWxsLFxuICAgIG9mZnNldDogbnVsbCxcbiAgICBvbkFib3J0OiBudWxsLFxuICAgIG9uQWN0aXZhdGU6IG51bGwsXG4gICAgb25BZnRlclByaW50OiBudWxsLFxuICAgIG9uQmVmb3JlUHJpbnQ6IG51bGwsXG4gICAgb25CZWdpbjogbnVsbCxcbiAgICBvbkNhbmNlbDogbnVsbCxcbiAgICBvbkNhblBsYXk6IG51bGwsXG4gICAgb25DYW5QbGF5VGhyb3VnaDogbnVsbCxcbiAgICBvbkNoYW5nZTogbnVsbCxcbiAgICBvbkNsaWNrOiBudWxsLFxuICAgIG9uQ2xvc2U6IG51bGwsXG4gICAgb25Db3B5OiBudWxsLFxuICAgIG9uQ3VlQ2hhbmdlOiBudWxsLFxuICAgIG9uQ3V0OiBudWxsLFxuICAgIG9uRGJsQ2xpY2s6IG51bGwsXG4gICAgb25EcmFnOiBudWxsLFxuICAgIG9uRHJhZ0VuZDogbnVsbCxcbiAgICBvbkRyYWdFbnRlcjogbnVsbCxcbiAgICBvbkRyYWdFeGl0OiBudWxsLFxuICAgIG9uRHJhZ0xlYXZlOiBudWxsLFxuICAgIG9uRHJhZ092ZXI6IG51bGwsXG4gICAgb25EcmFnU3RhcnQ6IG51bGwsXG4gICAgb25Ecm9wOiBudWxsLFxuICAgIG9uRHVyYXRpb25DaGFuZ2U6IG51bGwsXG4gICAgb25FbXB0aWVkOiBudWxsLFxuICAgIG9uRW5kOiBudWxsLFxuICAgIG9uRW5kZWQ6IG51bGwsXG4gICAgb25FcnJvcjogbnVsbCxcbiAgICBvbkZvY3VzOiBudWxsLFxuICAgIG9uRm9jdXNJbjogbnVsbCxcbiAgICBvbkZvY3VzT3V0OiBudWxsLFxuICAgIG9uSGFzaENoYW5nZTogbnVsbCxcbiAgICBvbklucHV0OiBudWxsLFxuICAgIG9uSW52YWxpZDogbnVsbCxcbiAgICBvbktleURvd246IG51bGwsXG4gICAgb25LZXlQcmVzczogbnVsbCxcbiAgICBvbktleVVwOiBudWxsLFxuICAgIG9uTG9hZDogbnVsbCxcbiAgICBvbkxvYWRlZERhdGE6IG51bGwsXG4gICAgb25Mb2FkZWRNZXRhZGF0YTogbnVsbCxcbiAgICBvbkxvYWRTdGFydDogbnVsbCxcbiAgICBvbk1lc3NhZ2U6IG51bGwsXG4gICAgb25Nb3VzZURvd246IG51bGwsXG4gICAgb25Nb3VzZUVudGVyOiBudWxsLFxuICAgIG9uTW91c2VMZWF2ZTogbnVsbCxcbiAgICBvbk1vdXNlTW92ZTogbnVsbCxcbiAgICBvbk1vdXNlT3V0OiBudWxsLFxuICAgIG9uTW91c2VPdmVyOiBudWxsLFxuICAgIG9uTW91c2VVcDogbnVsbCxcbiAgICBvbk1vdXNlV2hlZWw6IG51bGwsXG4gICAgb25PZmZsaW5lOiBudWxsLFxuICAgIG9uT25saW5lOiBudWxsLFxuICAgIG9uUGFnZUhpZGU6IG51bGwsXG4gICAgb25QYWdlU2hvdzogbnVsbCxcbiAgICBvblBhc3RlOiBudWxsLFxuICAgIG9uUGF1c2U6IG51bGwsXG4gICAgb25QbGF5OiBudWxsLFxuICAgIG9uUGxheWluZzogbnVsbCxcbiAgICBvblBvcFN0YXRlOiBudWxsLFxuICAgIG9uUHJvZ3Jlc3M6IG51bGwsXG4gICAgb25SYXRlQ2hhbmdlOiBudWxsLFxuICAgIG9uUmVwZWF0OiBudWxsLFxuICAgIG9uUmVzZXQ6IG51bGwsXG4gICAgb25SZXNpemU6IG51bGwsXG4gICAgb25TY3JvbGw6IG51bGwsXG4gICAgb25TZWVrZWQ6IG51bGwsXG4gICAgb25TZWVraW5nOiBudWxsLFxuICAgIG9uU2VsZWN0OiBudWxsLFxuICAgIG9uU2hvdzogbnVsbCxcbiAgICBvblN0YWxsZWQ6IG51bGwsXG4gICAgb25TdG9yYWdlOiBudWxsLFxuICAgIG9uU3VibWl0OiBudWxsLFxuICAgIG9uU3VzcGVuZDogbnVsbCxcbiAgICBvblRpbWVVcGRhdGU6IG51bGwsXG4gICAgb25Ub2dnbGU6IG51bGwsXG4gICAgb25VbmxvYWQ6IG51bGwsXG4gICAgb25Wb2x1bWVDaGFuZ2U6IG51bGwsXG4gICAgb25XYWl0aW5nOiBudWxsLFxuICAgIG9uWm9vbTogbnVsbCxcbiAgICBvcGFjaXR5OiBudWxsLFxuICAgIG9wZXJhdG9yOiBudWxsLFxuICAgIG9yZGVyOiBudWxsLFxuICAgIG9yaWVudDogbnVsbCxcbiAgICBvcmllbnRhdGlvbjogbnVsbCxcbiAgICBvcmlnaW46IG51bGwsXG4gICAgb3ZlcmZsb3c6IG51bGwsXG4gICAgb3ZlcmxheTogbnVsbCxcbiAgICBvdmVybGluZVBvc2l0aW9uOiBTLFxuICAgIG92ZXJsaW5lVGhpY2tuZXNzOiBTLFxuICAgIHBhaW50T3JkZXI6IG51bGwsXG4gICAgcGFub3NlMTogbnVsbCxcbiAgICBwYXRoOiBudWxsLFxuICAgIHBhdGhMZW5ndGg6IFMsXG4gICAgcGF0dGVybkNvbnRlbnRVbml0czogbnVsbCxcbiAgICBwYXR0ZXJuVHJhbnNmb3JtOiBudWxsLFxuICAgIHBhdHRlcm5Vbml0czogbnVsbCxcbiAgICBwaGFzZTogbnVsbCxcbiAgICBwaW5nOiBWLFxuICAgIHBpdGNoOiBudWxsLFxuICAgIHBsYXliYWNrT3JkZXI6IG51bGwsXG4gICAgcG9pbnRlckV2ZW50czogbnVsbCxcbiAgICBwb2ludHM6IG51bGwsXG4gICAgcG9pbnRzQXRYOiBTLFxuICAgIHBvaW50c0F0WTogUyxcbiAgICBwb2ludHNBdFo6IFMsXG4gICAgcHJlc2VydmVBbHBoYTogbnVsbCxcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiBudWxsLFxuICAgIHByaW1pdGl2ZVVuaXRzOiBudWxsLFxuICAgIHByb3BhZ2F0ZTogbnVsbCxcbiAgICBwcm9wZXJ0eTogbG4sXG4gICAgcjogbnVsbCxcbiAgICByYWRpdXM6IG51bGwsXG4gICAgcmVmZXJyZXJQb2xpY3k6IG51bGwsXG4gICAgcmVmWDogbnVsbCxcbiAgICByZWZZOiBudWxsLFxuICAgIHJlbDogbG4sXG4gICAgcmV2OiBsbixcbiAgICByZW5kZXJpbmdJbnRlbnQ6IG51bGwsXG4gICAgcmVwZWF0Q291bnQ6IG51bGwsXG4gICAgcmVwZWF0RHVyOiBudWxsLFxuICAgIHJlcXVpcmVkRXh0ZW5zaW9uczogbG4sXG4gICAgcmVxdWlyZWRGZWF0dXJlczogbG4sXG4gICAgcmVxdWlyZWRGb250czogbG4sXG4gICAgcmVxdWlyZWRGb3JtYXRzOiBsbixcbiAgICByZXNvdXJjZTogbnVsbCxcbiAgICByZXN0YXJ0OiBudWxsLFxuICAgIHJlc3VsdDogbnVsbCxcbiAgICByb3RhdGU6IG51bGwsXG4gICAgcng6IG51bGwsXG4gICAgcnk6IG51bGwsXG4gICAgc2NhbGU6IG51bGwsXG4gICAgc2VlZDogbnVsbCxcbiAgICBzaGFwZVJlbmRlcmluZzogbnVsbCxcbiAgICBzaWRlOiBudWxsLFxuICAgIHNsb3BlOiBudWxsLFxuICAgIHNuYXBzaG90VGltZTogbnVsbCxcbiAgICBzcGVjdWxhckNvbnN0YW50OiBTLFxuICAgIHNwZWN1bGFyRXhwb25lbnQ6IFMsXG4gICAgc3ByZWFkTWV0aG9kOiBudWxsLFxuICAgIHNwYWNpbmc6IG51bGwsXG4gICAgc3RhcnRPZmZzZXQ6IG51bGwsXG4gICAgc3RkRGV2aWF0aW9uOiBudWxsLFxuICAgIHN0ZW1oOiBudWxsLFxuICAgIHN0ZW12OiBudWxsLFxuICAgIHN0aXRjaFRpbGVzOiBudWxsLFxuICAgIHN0b3BDb2xvcjogbnVsbCxcbiAgICBzdG9wT3BhY2l0eTogbnVsbCxcbiAgICBzdHJpa2V0aHJvdWdoUG9zaXRpb246IFMsXG4gICAgc3RyaWtldGhyb3VnaFRoaWNrbmVzczogUyxcbiAgICBzdHJpbmc6IG51bGwsXG4gICAgc3Ryb2tlOiBudWxsLFxuICAgIHN0cm9rZURhc2hBcnJheTogbG4sXG4gICAgc3Ryb2tlRGFzaE9mZnNldDogbnVsbCxcbiAgICBzdHJva2VMaW5lQ2FwOiBudWxsLFxuICAgIHN0cm9rZUxpbmVKb2luOiBudWxsLFxuICAgIHN0cm9rZU1pdGVyTGltaXQ6IFMsXG4gICAgc3Ryb2tlT3BhY2l0eTogUyxcbiAgICBzdHJva2VXaWR0aDogbnVsbCxcbiAgICBzdHlsZTogbnVsbCxcbiAgICBzdXJmYWNlU2NhbGU6IFMsXG4gICAgc3luY0JlaGF2aW9yOiBudWxsLFxuICAgIHN5bmNCZWhhdmlvckRlZmF1bHQ6IG51bGwsXG4gICAgc3luY01hc3RlcjogbnVsbCxcbiAgICBzeW5jVG9sZXJhbmNlOiBudWxsLFxuICAgIHN5bmNUb2xlcmFuY2VEZWZhdWx0OiBudWxsLFxuICAgIHN5c3RlbUxhbmd1YWdlOiBsbixcbiAgICB0YWJJbmRleDogUyxcbiAgICB0YWJsZVZhbHVlczogbnVsbCxcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgdGFyZ2V0WDogUyxcbiAgICB0YXJnZXRZOiBTLFxuICAgIHRleHRBbmNob3I6IG51bGwsXG4gICAgdGV4dERlY29yYXRpb246IG51bGwsXG4gICAgdGV4dFJlbmRlcmluZzogbnVsbCxcbiAgICB0ZXh0TGVuZ3RoOiBudWxsLFxuICAgIHRpbWVsaW5lQmVnaW46IG51bGwsXG4gICAgdGl0bGU6IG51bGwsXG4gICAgdHJhbnNmb3JtQmVoYXZpb3I6IG51bGwsXG4gICAgdHlwZTogbnVsbCxcbiAgICB0eXBlT2Y6IGxuLFxuICAgIHRvOiBudWxsLFxuICAgIHRyYW5zZm9ybTogbnVsbCxcbiAgICB1MTogbnVsbCxcbiAgICB1MjogbnVsbCxcbiAgICB1bmRlcmxpbmVQb3NpdGlvbjogUyxcbiAgICB1bmRlcmxpbmVUaGlja25lc3M6IFMsXG4gICAgdW5pY29kZTogbnVsbCxcbiAgICB1bmljb2RlQmlkaTogbnVsbCxcbiAgICB1bmljb2RlUmFuZ2U6IG51bGwsXG4gICAgdW5pdHNQZXJFbTogUyxcbiAgICB2YWx1ZXM6IG51bGwsXG4gICAgdkFscGhhYmV0aWM6IFMsXG4gICAgdk1hdGhlbWF0aWNhbDogUyxcbiAgICB2ZWN0b3JFZmZlY3Q6IG51bGwsXG4gICAgdkhhbmdpbmc6IFMsXG4gICAgdklkZW9ncmFwaGljOiBTLFxuICAgIHZlcnNpb246IG51bGwsXG4gICAgdmVydEFkdlk6IFMsXG4gICAgdmVydE9yaWdpblg6IFMsXG4gICAgdmVydE9yaWdpblk6IFMsXG4gICAgdmlld0JveDogbnVsbCxcbiAgICB2aWV3VGFyZ2V0OiBudWxsLFxuICAgIHZpc2liaWxpdHk6IG51bGwsXG4gICAgd2lkdGg6IG51bGwsXG4gICAgd2lkdGhzOiBudWxsLFxuICAgIHdvcmRTcGFjaW5nOiBudWxsLFxuICAgIHdyaXRpbmdNb2RlOiBudWxsLFxuICAgIHg6IG51bGwsXG4gICAgeDE6IG51bGwsXG4gICAgeDI6IG51bGwsXG4gICAgeENoYW5uZWxTZWxlY3RvcjogbnVsbCxcbiAgICB4SGVpZ2h0OiBTLFxuICAgIHk6IG51bGwsXG4gICAgeTE6IG51bGwsXG4gICAgeTI6IG51bGwsXG4gICAgeUNoYW5uZWxTZWxlY3RvcjogbnVsbCxcbiAgICB6OiBudWxsLFxuICAgIHpvb21BbmRQYW46IG51bGxcbiAgfVxufSksIFJvID0gL15kYXRhWy1cXHcuOl0rJC9pLCBndCA9IC8tW2Etel0vZywgX28gPSAvW0EtWl0vZztcbmZ1bmN0aW9uIE1vKG4sIGUpIHtcbiAgY29uc3QgdCA9IGJlKGUpO1xuICBsZXQgciA9IGUsIGkgPSBwbjtcbiAgaWYgKHQgaW4gbi5ub3JtYWwpXG4gICAgcmV0dXJuIG4ucHJvcGVydHlbbi5ub3JtYWxbdF1dO1xuICBpZiAodC5sZW5ndGggPiA0ICYmIHQuc2xpY2UoMCwgNCkgPT09IFwiZGF0YVwiICYmIFJvLnRlc3QoZSkpIHtcbiAgICBpZiAoZS5jaGFyQXQoNCkgPT09IFwiLVwiKSB7XG4gICAgICBjb25zdCBsID0gZS5zbGljZSg1KS5yZXBsYWNlKGd0LCBObyk7XG4gICAgICByID0gXCJkYXRhXCIgKyBsLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgbC5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbCA9IGUuc2xpY2UoNCk7XG4gICAgICBpZiAoIWd0LnRlc3QobCkpIHtcbiAgICAgICAgbGV0IG8gPSBsLnJlcGxhY2UoX28sIEJvKTtcbiAgICAgICAgby5jaGFyQXQoMCkgIT09IFwiLVwiICYmIChvID0gXCItXCIgKyBvKSwgZSA9IFwiZGF0YVwiICsgbztcbiAgICAgIH1cbiAgICB9XG4gICAgaSA9IE9lO1xuICB9XG4gIHJldHVybiBuZXcgaShyLCBlKTtcbn1cbmZ1bmN0aW9uIEJvKG4pIHtcbiAgcmV0dXJuIFwiLVwiICsgbi50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gTm8obikge1xuICByZXR1cm4gbi5jaGFyQXQoMSkudG9VcHBlckNhc2UoKTtcbn1cbmNvbnN0IHl0ID0ge1xuICBjbGFzc0lkOiBcImNsYXNzSURcIixcbiAgZGF0YVR5cGU6IFwiZGF0YXR5cGVcIixcbiAgaXRlbUlkOiBcIml0ZW1JRFwiLFxuICBzdHJva2VEYXNoQXJyYXk6IFwic3Ryb2tlRGFzaGFycmF5XCIsXG4gIHN0cm9rZURhc2hPZmZzZXQ6IFwic3Ryb2tlRGFzaG9mZnNldFwiLFxuICBzdHJva2VMaW5lQ2FwOiBcInN0cm9rZUxpbmVjYXBcIixcbiAgc3Ryb2tlTGluZUpvaW46IFwic3Ryb2tlTGluZWpvaW5cIixcbiAgc3Ryb2tlTWl0ZXJMaW1pdDogXCJzdHJva2VNaXRlcmxpbWl0XCIsXG4gIHR5cGVPZjogXCJ0eXBlb2ZcIixcbiAgeExpbmtBY3R1YXRlOiBcInhsaW5rQWN0dWF0ZVwiLFxuICB4TGlua0FyY1JvbGU6IFwieGxpbmtBcmNyb2xlXCIsXG4gIHhMaW5rSHJlZjogXCJ4bGlua0hyZWZcIixcbiAgeExpbmtSb2xlOiBcInhsaW5rUm9sZVwiLFxuICB4TGlua1Nob3c6IFwieGxpbmtTaG93XCIsXG4gIHhMaW5rVGl0bGU6IFwieGxpbmtUaXRsZVwiLFxuICB4TGlua1R5cGU6IFwieGxpbmtUeXBlXCIsXG4gIHhtbG5zWExpbms6IFwieG1sbnNYbGlua1wiXG59LCBqbyA9IFp0KFtlciwgbnIsIGlyLCBsciwgdm9dLCBcImh0bWxcIiksICRvID0gWnQoW2VyLCBuciwgaXIsIGxyLCB6b10sIFwic3ZnXCIpLCBvciA9IChcbiAgLyoqXG4gICAqIEB0eXBlIHsoXG4gICAqICAgKDxLaW5kIGV4dGVuZHMgTm9kZT4odGVzdDogUHJlZGljYXRlVGVzdDxLaW5kPikgPT4gQXNzZXJ0UHJlZGljYXRlPEtpbmQ+KSAmXG4gICAqICAgKCh0ZXN0PzogVGVzdCkgPT4gQXNzZXJ0QW55dGhpbmcpXG4gICAqICl9XG4gICAqL1xuICAvKipcbiAgICogQHBhcmFtIHtUZXN0fSBbdGVzdF1cbiAgICogQHJldHVybnMge0Fzc2VydEFueXRoaW5nfVxuICAgKi9cbiAgZnVuY3Rpb24obikge1xuICAgIGlmIChuID09IG51bGwpXG4gICAgICByZXR1cm4gcW87XG4gICAgaWYgKHR5cGVvZiBuID09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4gVm8obik7XG4gICAgaWYgKHR5cGVvZiBuID09IFwib2JqZWN0XCIpXG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShuKSA/IEhvKG4pIDogVW8obik7XG4gICAgaWYgKHR5cGVvZiBuID09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybiBuZShuKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBmdW5jdGlvbiwgc3RyaW5nLCBvciBvYmplY3QgYXMgdGVzdFwiKTtcbiAgfVxuKTtcbmZ1bmN0aW9uIEhvKG4pIHtcbiAgY29uc3QgZSA9IFtdO1xuICBsZXQgdCA9IC0xO1xuICBmb3IgKDsgKyt0IDwgbi5sZW5ndGg7IClcbiAgICBlW3RdID0gb3Ioblt0XSk7XG4gIHJldHVybiBuZShyKTtcbiAgZnVuY3Rpb24gciguLi5pKSB7XG4gICAgbGV0IGwgPSAtMTtcbiAgICBmb3IgKDsgKytsIDwgZS5sZW5ndGg7IClcbiAgICAgIGlmIChlW2xdLmNhbGwodGhpcywgLi4uaSkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIFVvKG4pIHtcbiAgcmV0dXJuIG5lKGUpO1xuICBmdW5jdGlvbiBlKHQpIHtcbiAgICBsZXQgcjtcbiAgICBmb3IgKHIgaW4gbilcbiAgICAgIGlmICh0W3JdICE9PSBuW3JdKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgcmV0dXJuICEwO1xuICB9XG59XG5mdW5jdGlvbiBWbyhuKSB7XG4gIHJldHVybiBuZShlKTtcbiAgZnVuY3Rpb24gZSh0KSB7XG4gICAgcmV0dXJuIHQgJiYgdC50eXBlID09PSBuO1xuICB9XG59XG5mdW5jdGlvbiBuZShuKSB7XG4gIHJldHVybiBlO1xuICBmdW5jdGlvbiBlKHQsIC4uLnIpIHtcbiAgICByZXR1cm4gISEodCAmJiB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIFwidHlwZVwiIGluIHQgJiYgbi5jYWxsKHRoaXMsIHQsIC4uLnIpKTtcbiAgfVxufVxuZnVuY3Rpb24gcW8oKSB7XG4gIHJldHVybiAhMDtcbn1cbmNvbnN0IFdvID0gITAsIHh0ID0gITEsIFlvID0gXCJza2lwXCIsIFFvID0gKFxuICAvKipcbiAgICogQHR5cGUgeyhcbiAgICogICAoPFRyZWUgZXh0ZW5kcyBOb2RlLCBDaGVjayBleHRlbmRzIFRlc3Q+KHRyZWU6IFRyZWUsIHRlc3Q6IENoZWNrLCB2aXNpdG9yOiBCdWlsZFZpc2l0b3I8VHJlZSwgQ2hlY2s+LCByZXZlcnNlPzogYm9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWQpID0+IHZvaWQpICZcbiAgICogICAoPFRyZWUgZXh0ZW5kcyBOb2RlPih0cmVlOiBUcmVlLCB2aXNpdG9yOiBCdWlsZFZpc2l0b3I8VHJlZT4sIHJldmVyc2U/OiBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gdm9pZClcbiAgICogKX1cbiAgICovXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IHRyZWVcbiAgICogQHBhcmFtIHtUZXN0fSB0ZXN0XG4gICAqIEBwYXJhbSB7VmlzaXRvcjxOb2RlPn0gdmlzaXRvclxuICAgKiBAcGFyYW0ge2Jvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkfSBbcmV2ZXJzZV1cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBmdW5jdGlvbihuLCBlLCB0LCByKSB7XG4gICAgdHlwZW9mIGUgPT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiB0ICE9IFwiZnVuY3Rpb25cIiAmJiAociA9IHQsIHQgPSBlLCBlID0gbnVsbCk7XG4gICAgY29uc3QgaSA9IG9yKGUpLCBsID0gciA/IC0xIDogMTtcbiAgICBvKG4sIHZvaWQgMCwgW10pKCk7XG4gICAgZnVuY3Rpb24gbyh1LCBhLCBjKSB7XG4gICAgICBjb25zdCBzID0gdSAmJiB0eXBlb2YgdSA9PSBcIm9iamVjdFwiID8gdSA6IHt9O1xuICAgICAgaWYgKHR5cGVvZiBzLnR5cGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBnID0gKFxuICAgICAgICAgIC8vIGBoYXN0YFxuICAgICAgICAgIHR5cGVvZiBzLnRhZ05hbWUgPT0gXCJzdHJpbmdcIiA/IHMudGFnTmFtZSA6IChcbiAgICAgICAgICAgIC8vIGB4YXN0YFxuICAgICAgICAgICAgdHlwZW9mIHMubmFtZSA9PSBcInN0cmluZ1wiID8gcy5uYW1lIDogdm9pZCAwXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaCwgXCJuYW1lXCIsIHtcbiAgICAgICAgICB2YWx1ZTogXCJub2RlIChcIiArICh1LnR5cGUgKyAoZyA/IFwiPFwiICsgZyArIFwiPlwiIDogXCJcIikpICsgXCIpXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaDtcbiAgICAgIGZ1bmN0aW9uIGgoKSB7XG4gICAgICAgIGxldCBnID0gW10sIGQsIG0sIHk7XG4gICAgICAgIGlmICgoIWUgfHwgaSh1LCBhLCBjW2MubGVuZ3RoIC0gMV0gfHwgbnVsbCkpICYmIChnID0gWG8odCh1LCBjKSksIGdbMF0gPT09IHh0KSlcbiAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgaWYgKHUuY2hpbGRyZW4gJiYgZ1swXSAhPT0gWW8pXG4gICAgICAgICAgZm9yIChtID0gKHIgPyB1LmNoaWxkcmVuLmxlbmd0aCA6IC0xKSArIGwsIHkgPSBjLmNvbmNhdCh1KTsgbSA+IC0xICYmIG0gPCB1LmNoaWxkcmVuLmxlbmd0aDsgKSB7XG4gICAgICAgICAgICBpZiAoZCA9IG8odS5jaGlsZHJlblttXSwgbSwgeSkoKSwgZFswXSA9PT0geHQpXG4gICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgbSA9IHR5cGVvZiBkWzFdID09IFwibnVtYmVyXCIgPyBkWzFdIDogbSArIGw7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbik7XG5mdW5jdGlvbiBYbyhuKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KG4pID8gbiA6IHR5cGVvZiBuID09IFwibnVtYmVyXCIgPyBbV28sIG5dIDogW25dO1xufVxuY29uc3QgS28gPSAoXG4gIC8qKlxuICAgKiBAdHlwZSB7KFxuICAgKiAgICg8VHJlZSBleHRlbmRzIE5vZGUsIENoZWNrIGV4dGVuZHMgVGVzdD4odHJlZTogVHJlZSwgdGVzdDogQ2hlY2ssIHZpc2l0b3I6IEJ1aWxkVmlzaXRvcjxUcmVlLCBDaGVjaz4sIHJldmVyc2U/OiBib29sZWFuIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gdm9pZCkgJlxuICAgKiAgICg8VHJlZSBleHRlbmRzIE5vZGU+KHRyZWU6IFRyZWUsIHZpc2l0b3I6IEJ1aWxkVmlzaXRvcjxUcmVlPiwgcmV2ZXJzZT86IGJvb2xlYW4gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB2b2lkKVxuICAgKiApfVxuICAgKi9cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdHJlZVxuICAgKiBAcGFyYW0ge1Rlc3R9IHRlc3RcbiAgICogQHBhcmFtIHtWaXNpdG9yfSB2aXNpdG9yXG4gICAqIEBwYXJhbSB7Ym9vbGVhbiB8IG51bGwgfCB1bmRlZmluZWR9IFtyZXZlcnNlXVxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZ1bmN0aW9uKG4sIGUsIHQsIHIpIHtcbiAgICB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiICYmIChyID0gdCwgdCA9IGUsIGUgPSBudWxsKSwgUW8obiwgZSwgaSwgcik7XG4gICAgZnVuY3Rpb24gaShsLCBvKSB7XG4gICAgICBjb25zdCB1ID0gb1tvLmxlbmd0aCAtIDFdO1xuICAgICAgcmV0dXJuIHQoXG4gICAgICAgIGwsXG4gICAgICAgIHUgPyB1LmNoaWxkcmVuLmluZGV4T2YobCkgOiBudWxsLFxuICAgICAgICB1XG4gICAgICApO1xuICAgIH1cbiAgfVxuKTtcbmZ1bmN0aW9uIEdvKG4pIHtcbiAgaWYgKG4uYWxsb3dlZEVsZW1lbnRzICYmIG4uZGlzYWxsb3dlZEVsZW1lbnRzKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIk9ubHkgb25lIG9mIGBhbGxvd2VkRWxlbWVudHNgIGFuZCBgZGlzYWxsb3dlZEVsZW1lbnRzYCBzaG91bGQgYmUgZGVmaW5lZFwiXG4gICAgKTtcbiAgaWYgKG4uYWxsb3dlZEVsZW1lbnRzIHx8IG4uZGlzYWxsb3dlZEVsZW1lbnRzIHx8IG4uYWxsb3dFbGVtZW50KVxuICAgIHJldHVybiAoZSkgPT4ge1xuICAgICAgS28oZSwgXCJlbGVtZW50XCIsICh0LCByLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IGwgPSAoXG4gICAgICAgICAgLyoqIEB0eXBlIHtFbGVtZW50fFJvb3R9ICovXG4gICAgICAgICAgaVxuICAgICAgICApO1xuICAgICAgICBsZXQgbztcbiAgICAgICAgaWYgKG4uYWxsb3dlZEVsZW1lbnRzID8gbyA9ICFuLmFsbG93ZWRFbGVtZW50cy5pbmNsdWRlcyh0LnRhZ05hbWUpIDogbi5kaXNhbGxvd2VkRWxlbWVudHMgJiYgKG8gPSBuLmRpc2FsbG93ZWRFbGVtZW50cy5pbmNsdWRlcyh0LnRhZ05hbWUpKSwgIW8gJiYgbi5hbGxvd0VsZW1lbnQgJiYgdHlwZW9mIHIgPT0gXCJudW1iZXJcIiAmJiAobyA9ICFuLmFsbG93RWxlbWVudCh0LCByLCBsKSksIG8gJiYgdHlwZW9mIHIgPT0gXCJudW1iZXJcIilcbiAgICAgICAgICByZXR1cm4gbi51bndyYXBEaXNhbGxvd2VkICYmIHQuY2hpbGRyZW4gPyBsLmNoaWxkcmVuLnNwbGljZShyLCAxLCAuLi50LmNoaWxkcmVuKSA6IGwuY2hpbGRyZW4uc3BsaWNlKHIsIDEpLCByO1xuICAgICAgfSk7XG4gICAgfTtcbn1cbnZhciBTZSA9IHt9LCBabyA9IHtcbiAgZ2V0IGV4cG9ydHMoKSB7XG4gICAgcmV0dXJuIFNlO1xuICB9LFxuICBzZXQgZXhwb3J0cyhuKSB7XG4gICAgU2UgPSBuO1xuICB9XG59LCBOID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIga3Q7XG5mdW5jdGlvbiBKbygpIHtcbiAgaWYgKGt0KVxuICAgIHJldHVybiBOO1xuICBrdCA9IDE7XG4gIHZhciBuID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIGUgPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCB0ID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCByID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLCBpID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLCBsID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLCBvID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksIHUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc2VydmVyX2NvbnRleHRcIiksIGEgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksIGMgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksIHMgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSwgaCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLCBnID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksIGQgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLCBtO1xuICBtID0gU3ltYm9sLmZvcihcInJlYWN0Lm1vZHVsZS5yZWZlcmVuY2VcIik7XG4gIGZ1bmN0aW9uIHkoeCkge1xuICAgIGlmICh0eXBlb2YgeCA9PSBcIm9iamVjdFwiICYmIHggIT09IG51bGwpIHtcbiAgICAgIHZhciB3ID0geC4kJHR5cGVvZjtcbiAgICAgIHN3aXRjaCAodykge1xuICAgICAgICBjYXNlIG46XG4gICAgICAgICAgc3dpdGNoICh4ID0geC50eXBlLCB4KSB7XG4gICAgICAgICAgICBjYXNlIHQ6XG4gICAgICAgICAgICBjYXNlIGk6XG4gICAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgICBjYXNlIHM6XG4gICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgc3dpdGNoICh4ID0geCAmJiB4LiQkdHlwZW9mLCB4KSB7XG4gICAgICAgICAgICAgICAgY2FzZSB1OlxuICAgICAgICAgICAgICAgIGNhc2UgbzpcbiAgICAgICAgICAgICAgICBjYXNlIGE6XG4gICAgICAgICAgICAgICAgY2FzZSBnOlxuICAgICAgICAgICAgICAgIGNhc2UgaDpcbiAgICAgICAgICAgICAgICBjYXNlIGw6XG4gICAgICAgICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgZTpcbiAgICAgICAgICByZXR1cm4gdztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIE4uQ29udGV4dENvbnN1bWVyID0gbywgTi5Db250ZXh0UHJvdmlkZXIgPSBsLCBOLkVsZW1lbnQgPSBuLCBOLkZvcndhcmRSZWYgPSBhLCBOLkZyYWdtZW50ID0gdCwgTi5MYXp5ID0gZywgTi5NZW1vID0gaCwgTi5Qb3J0YWwgPSBlLCBOLlByb2ZpbGVyID0gaSwgTi5TdHJpY3RNb2RlID0gciwgTi5TdXNwZW5zZSA9IGMsIE4uU3VzcGVuc2VMaXN0ID0gcywgTi5pc0FzeW5jTW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhMTtcbiAgfSwgTi5pc0NvbmN1cnJlbnRNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICExO1xuICB9LCBOLmlzQ29udGV4dENvbnN1bWVyID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB5KHgpID09PSBvO1xuICB9LCBOLmlzQ29udGV4dFByb3ZpZGVyID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB5KHgpID09PSBsO1xuICB9LCBOLmlzRWxlbWVudCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJvYmplY3RcIiAmJiB4ICE9PSBudWxsICYmIHguJCR0eXBlb2YgPT09IG47XG4gIH0sIE4uaXNGb3J3YXJkUmVmID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB5KHgpID09PSBhO1xuICB9LCBOLmlzRnJhZ21lbnQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHkoeCkgPT09IHQ7XG4gIH0sIE4uaXNMYXp5ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB5KHgpID09PSBnO1xuICB9LCBOLmlzTWVtbyA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geSh4KSA9PT0gaDtcbiAgfSwgTi5pc1BvcnRhbCA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geSh4KSA9PT0gZTtcbiAgfSwgTi5pc1Byb2ZpbGVyID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB5KHgpID09PSBpO1xuICB9LCBOLmlzU3RyaWN0TW9kZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4geSh4KSA9PT0gcjtcbiAgfSwgTi5pc1N1c3BlbnNlID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB5KHgpID09PSBjO1xuICB9LCBOLmlzU3VzcGVuc2VMaXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB5KHgpID09PSBzO1xuICB9LCBOLmlzVmFsaWRFbGVtZW50VHlwZSA9IGZ1bmN0aW9uKHgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHggPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgeCA9PSBcImZ1bmN0aW9uXCIgfHwgeCA9PT0gdCB8fCB4ID09PSBpIHx8IHggPT09IHIgfHwgeCA9PT0gYyB8fCB4ID09PSBzIHx8IHggPT09IGQgfHwgdHlwZW9mIHggPT0gXCJvYmplY3RcIiAmJiB4ICE9PSBudWxsICYmICh4LiQkdHlwZW9mID09PSBnIHx8IHguJCR0eXBlb2YgPT09IGggfHwgeC4kJHR5cGVvZiA9PT0gbCB8fCB4LiQkdHlwZW9mID09PSBvIHx8IHguJCR0eXBlb2YgPT09IGEgfHwgeC4kJHR5cGVvZiA9PT0gbSB8fCB4LmdldE1vZHVsZUlkICE9PSB2b2lkIDApO1xuICB9LCBOLnR5cGVPZiA9IHksIE47XG59XG52YXIgaiA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIGJ0O1xuZnVuY3Rpb24gbnUoKSB7XG4gIHJldHVybiBidCB8fCAoYnQgPSAxLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIiksIHQgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIHIgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3RyaWN0X21vZGVcIiksIGkgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIiksIGwgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIiksIG8gPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSwgdSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zZXJ2ZXJfY29udGV4dFwiKSwgYSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mb3J3YXJkX3JlZlwiKSwgYyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZVwiKSwgcyA9IFN5bWJvbC5mb3IoXCJyZWFjdC5zdXNwZW5zZV9saXN0XCIpLCBoID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIiksIGcgPSBTeW1ib2wuZm9yKFwicmVhY3QubGF6eVwiKSwgZCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5vZmZzY3JlZW5cIiksIG0gPSAhMSwgeSA9ICExLCB4ID0gITEsIHcgPSAhMSwgdiA9ICExLCBBO1xuICAgIEEgPSBTeW1ib2wuZm9yKFwicmVhY3QubW9kdWxlLnJlZmVyZW5jZVwiKTtcbiAgICBmdW5jdGlvbiBfKFApIHtcbiAgICAgIHJldHVybiAhISh0eXBlb2YgUCA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBQID09IFwiZnVuY3Rpb25cIiB8fCBQID09PSB0IHx8IFAgPT09IGkgfHwgdiB8fCBQID09PSByIHx8IFAgPT09IGMgfHwgUCA9PT0gcyB8fCB3IHx8IFAgPT09IGQgfHwgbSB8fCB5IHx8IHggfHwgdHlwZW9mIFAgPT0gXCJvYmplY3RcIiAmJiBQICE9PSBudWxsICYmIChQLiQkdHlwZW9mID09PSBnIHx8IFAuJCR0eXBlb2YgPT09IGggfHwgUC4kJHR5cGVvZiA9PT0gbCB8fCBQLiQkdHlwZW9mID09PSBvIHx8IFAuJCR0eXBlb2YgPT09IGEgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgICAvLyB3aXRoLlxuICAgICAgUC4kJHR5cGVvZiA9PT0gQSB8fCBQLmdldE1vZHVsZUlkICE9PSB2b2lkIDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVChQKSB7XG4gICAgICBpZiAodHlwZW9mIFAgPT0gXCJvYmplY3RcIiAmJiBQICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfbiA9IFAuJCR0eXBlb2Y7XG4gICAgICAgIHN3aXRjaCAoX24pIHtcbiAgICAgICAgICBjYXNlIG46XG4gICAgICAgICAgICB2YXIgRm4gPSBQLnR5cGU7XG4gICAgICAgICAgICBzd2l0Y2ggKEZuKSB7XG4gICAgICAgICAgICAgIGNhc2UgdDpcbiAgICAgICAgICAgICAgY2FzZSBpOlxuICAgICAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICAgIGNhc2UgYzpcbiAgICAgICAgICAgICAgY2FzZSBzOlxuICAgICAgICAgICAgICAgIHJldHVybiBGbjtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB2YXIgTW4gPSBGbiAmJiBGbi4kJHR5cGVvZjtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKE1uKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIHU6XG4gICAgICAgICAgICAgICAgICBjYXNlIG86XG4gICAgICAgICAgICAgICAgICBjYXNlIGE6XG4gICAgICAgICAgICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgICAgICAgICBjYXNlIGg6XG4gICAgICAgICAgICAgICAgICBjYXNlIGw6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNbjtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBlOlxuICAgICAgICAgICAgcmV0dXJuIF9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBiID0gbywgSSA9IGwsIFIgPSBuLCBNID0gYSwgWCA9IHQsIEMgPSBnLCBGID0gaCwgQiA9IGUsIFogPSBpLCBlbiA9IHIsIHVuID0gYywgdG4gPSBzLCBxID0gITEsIEogPSAhMTtcbiAgICBmdW5jdGlvbiBXKFApIHtcbiAgICAgIHJldHVybiBxIHx8IChxID0gITAsIGNvbnNvbGUud2FybihcIlRoZSBSZWFjdElzLmlzQXN5bmNNb2RlKCkgYWxpYXMgaGFzIGJlZW4gZGVwcmVjYXRlZCwgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxOCsuXCIpKSwgITE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGYoUCkge1xuICAgICAgcmV0dXJuIEogfHwgKEogPSAhMCwgY29uc29sZS53YXJuKFwiVGhlIFJlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTgrLlwiKSksICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwKFApIHtcbiAgICAgIHJldHVybiBUKFApID09PSBvO1xuICAgIH1cbiAgICBmdW5jdGlvbiBrbihQKSB7XG4gICAgICByZXR1cm4gVChQKSA9PT0gbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUG4oUCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiBQID09IFwib2JqZWN0XCIgJiYgUCAhPT0gbnVsbCAmJiBQLiQkdHlwZW9mID09PSBuO1xuICAgIH1cbiAgICBmdW5jdGlvbiBibihQKSB7XG4gICAgICByZXR1cm4gVChQKSA9PT0gYTtcbiAgICB9XG4gICAgZnVuY3Rpb24gWShQKSB7XG4gICAgICByZXR1cm4gVChQKSA9PT0gdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gcm4oUCkge1xuICAgICAgcmV0dXJuIFQoUCkgPT09IGc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhuKFApIHtcbiAgICAgIHJldHVybiBUKFApID09PSBoO1xuICAgIH1cbiAgICBmdW5jdGlvbiB3bihQKSB7XG4gICAgICByZXR1cm4gVChQKSA9PT0gZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gU24oUCkge1xuICAgICAgcmV0dXJuIFQoUCkgPT09IGk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFJuKFApIHtcbiAgICAgIHJldHVybiBUKFApID09PSByO1xuICAgIH1cbiAgICBmdW5jdGlvbiBWbihQKSB7XG4gICAgICByZXR1cm4gVChQKSA9PT0gYztcbiAgICB9XG4gICAgZnVuY3Rpb24gZWUoUCkge1xuICAgICAgcmV0dXJuIFQoUCkgPT09IHM7XG4gICAgfVxuICAgIGouQ29udGV4dENvbnN1bWVyID0gYiwgai5Db250ZXh0UHJvdmlkZXIgPSBJLCBqLkVsZW1lbnQgPSBSLCBqLkZvcndhcmRSZWYgPSBNLCBqLkZyYWdtZW50ID0gWCwgai5MYXp5ID0gQywgai5NZW1vID0gRiwgai5Qb3J0YWwgPSBCLCBqLlByb2ZpbGVyID0gWiwgai5TdHJpY3RNb2RlID0gZW4sIGouU3VzcGVuc2UgPSB1biwgai5TdXNwZW5zZUxpc3QgPSB0biwgai5pc0FzeW5jTW9kZSA9IFcsIGouaXNDb25jdXJyZW50TW9kZSA9IGYsIGouaXNDb250ZXh0Q29uc3VtZXIgPSBwLCBqLmlzQ29udGV4dFByb3ZpZGVyID0ga24sIGouaXNFbGVtZW50ID0gUG4sIGouaXNGb3J3YXJkUmVmID0gYm4sIGouaXNGcmFnbWVudCA9IFksIGouaXNMYXp5ID0gcm4sIGouaXNNZW1vID0gaG4sIGouaXNQb3J0YWwgPSB3biwgai5pc1Byb2ZpbGVyID0gU24sIGouaXNTdHJpY3RNb2RlID0gUm4sIGouaXNTdXNwZW5zZSA9IFZuLCBqLmlzU3VzcGVuc2VMaXN0ID0gZWUsIGouaXNWYWxpZEVsZW1lbnRUeXBlID0gXywgai50eXBlT2YgPSBUO1xuICB9KCkpLCBqO1xufVxuKGZ1bmN0aW9uKG4pIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gbi5leHBvcnRzID0gSm8oKSA6IG4uZXhwb3J0cyA9IG51KCk7XG59KShabyk7XG5jb25zdCBldSA9IC8qIEBfX1BVUkVfXyAqLyBkcihTZSk7XG5mdW5jdGlvbiB0dShuKSB7XG4gIGNvbnN0IGUgPSAoXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsb29rcyBsaWtlIGEgbm9kZS5cbiAgICBuICYmIHR5cGVvZiBuID09IFwib2JqZWN0XCIgJiYgbi50eXBlID09PSBcInRleHRcIiA/IChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgbG9va3MgbGlrZSBhIHRleHQuXG4gICAgICBuLnZhbHVlIHx8IFwiXCJcbiAgICApIDogblxuICApO1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiBlLnJlcGxhY2UoL1sgXFx0XFxuXFxmXFxyXS9nLCBcIlwiKSA9PT0gXCJcIjtcbn1cbmZ1bmN0aW9uIHJ1KG4pIHtcbiAgcmV0dXJuIG4uam9pbihcIiBcIikudHJpbSgpO1xufVxuZnVuY3Rpb24gaXUobiwgZSkge1xuICBjb25zdCB0ID0gZSB8fCB7fTtcbiAgcmV0dXJuIChuW24ubGVuZ3RoIC0gMV0gPT09IFwiXCIgPyBbLi4ubiwgXCJcIl0gOiBuKS5qb2luKFxuICAgICh0LnBhZFJpZ2h0ID8gXCIgXCIgOiBcIlwiKSArIFwiLFwiICsgKHQucGFkTGVmdCA9PT0gITEgPyBcIlwiIDogXCIgXCIpXG4gICkudHJpbSgpO1xufVxudmFyIEduID0ge30sIGx1ID0ge1xuICBnZXQgZXhwb3J0cygpIHtcbiAgICByZXR1cm4gR247XG4gIH0sXG4gIHNldCBleHBvcnRzKG4pIHtcbiAgICBHbiA9IG47XG4gIH1cbn0sIHd0ID0gL1xcL1xcKlteKl0qXFwqKyhbXi8qXVteKl0qXFwqKykqXFwvL2csIG91ID0gL1xcbi9nLCB1dSA9IC9eXFxzKi8sIGF1ID0gL14oXFwqP1stIy8qXFxcXFxcd10rKFxcW1swLTlhLXpfLV0rXFxdKT8pXFxzKi8sIHN1ID0gL146XFxzKi8sIGN1ID0gL14oKD86Jyg/OlxcXFwnfC4pKj8nfFwiKD86XFxcXFwifC4pKj9cInxcXChbXildKj9cXCl8W159O10pKykvLCBwdSA9IC9eWztcXHNdKi8sIGZ1ID0gL15cXHMrfFxccyskL2csIGh1ID0gYFxuYCwgU3QgPSBcIi9cIiwgRXQgPSBcIipcIiwgVG4gPSBcIlwiLCBtdSA9IFwiY29tbWVudFwiLCBkdSA9IFwiZGVjbGFyYXRpb25cIiwgZ3UgPSBmdW5jdGlvbihuLCBlKSB7XG4gIGlmICh0eXBlb2YgbiAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICBpZiAoIW4pXG4gICAgcmV0dXJuIFtdO1xuICBlID0gZSB8fCB7fTtcbiAgdmFyIHQgPSAxLCByID0gMTtcbiAgZnVuY3Rpb24gaShtKSB7XG4gICAgdmFyIHkgPSBtLm1hdGNoKG91KTtcbiAgICB5ICYmICh0ICs9IHkubGVuZ3RoKTtcbiAgICB2YXIgeCA9IG0ubGFzdEluZGV4T2YoaHUpO1xuICAgIHIgPSB+eCA/IG0ubGVuZ3RoIC0geCA6IHIgKyBtLmxlbmd0aDtcbiAgfVxuICBmdW5jdGlvbiBsKCkge1xuICAgIHZhciBtID0geyBsaW5lOiB0LCBjb2x1bW46IHIgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oeSkge1xuICAgICAgcmV0dXJuIHkucG9zaXRpb24gPSBuZXcgbyhtKSwgYygpLCB5O1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gbyhtKSB7XG4gICAgdGhpcy5zdGFydCA9IG0sIHRoaXMuZW5kID0geyBsaW5lOiB0LCBjb2x1bW46IHIgfSwgdGhpcy5zb3VyY2UgPSBlLnNvdXJjZTtcbiAgfVxuICBvLnByb3RvdHlwZS5jb250ZW50ID0gbjtcbiAgZnVuY3Rpb24gdShtKSB7XG4gICAgdmFyIHkgPSBuZXcgRXJyb3IoXG4gICAgICBlLnNvdXJjZSArIFwiOlwiICsgdCArIFwiOlwiICsgciArIFwiOiBcIiArIG1cbiAgICApO1xuICAgIGlmICh5LnJlYXNvbiA9IG0sIHkuZmlsZW5hbWUgPSBlLnNvdXJjZSwgeS5saW5lID0gdCwgeS5jb2x1bW4gPSByLCB5LnNvdXJjZSA9IG4sICFlLnNpbGVudClcbiAgICAgIHRocm93IHk7XG4gIH1cbiAgZnVuY3Rpb24gYShtKSB7XG4gICAgdmFyIHkgPSBtLmV4ZWMobik7XG4gICAgaWYgKHkpIHtcbiAgICAgIHZhciB4ID0geVswXTtcbiAgICAgIHJldHVybiBpKHgpLCBuID0gbi5zbGljZSh4Lmxlbmd0aCksIHk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGMoKSB7XG4gICAgYSh1dSk7XG4gIH1cbiAgZnVuY3Rpb24gcyhtKSB7XG4gICAgdmFyIHk7XG4gICAgZm9yIChtID0gbSB8fCBbXTsgeSA9IGgoKTsgKVxuICAgICAgeSAhPT0gITEgJiYgbS5wdXNoKHkpO1xuICAgIHJldHVybiBtO1xuICB9XG4gIGZ1bmN0aW9uIGgoKSB7XG4gICAgdmFyIG0gPSBsKCk7XG4gICAgaWYgKCEoU3QgIT0gbi5jaGFyQXQoMCkgfHwgRXQgIT0gbi5jaGFyQXQoMSkpKSB7XG4gICAgICBmb3IgKHZhciB5ID0gMjsgVG4gIT0gbi5jaGFyQXQoeSkgJiYgKEV0ICE9IG4uY2hhckF0KHkpIHx8IFN0ICE9IG4uY2hhckF0KHkgKyAxKSk7IClcbiAgICAgICAgKyt5O1xuICAgICAgaWYgKHkgKz0gMiwgVG4gPT09IG4uY2hhckF0KHkgLSAxKSlcbiAgICAgICAgcmV0dXJuIHUoXCJFbmQgb2YgY29tbWVudCBtaXNzaW5nXCIpO1xuICAgICAgdmFyIHggPSBuLnNsaWNlKDIsIHkgLSAyKTtcbiAgICAgIHJldHVybiByICs9IDIsIGkoeCksIG4gPSBuLnNsaWNlKHkpLCByICs9IDIsIG0oe1xuICAgICAgICB0eXBlOiBtdSxcbiAgICAgICAgY29tbWVudDogeFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdmFyIG0gPSBsKCksIHkgPSBhKGF1KTtcbiAgICBpZiAoeSkge1xuICAgICAgaWYgKGgoKSwgIWEoc3UpKVxuICAgICAgICByZXR1cm4gdShcInByb3BlcnR5IG1pc3NpbmcgJzonXCIpO1xuICAgICAgdmFyIHggPSBhKGN1KSwgdyA9IG0oe1xuICAgICAgICB0eXBlOiBkdSxcbiAgICAgICAgcHJvcGVydHk6IEN0KHlbMF0ucmVwbGFjZSh3dCwgVG4pKSxcbiAgICAgICAgdmFsdWU6IHggPyBDdCh4WzBdLnJlcGxhY2Uod3QsIFRuKSkgOiBUblxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYShwdSksIHc7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQoKSB7XG4gICAgdmFyIG0gPSBbXTtcbiAgICBzKG0pO1xuICAgIGZvciAodmFyIHk7IHkgPSBnKCk7IClcbiAgICAgIHkgIT09ICExICYmIChtLnB1c2goeSksIHMobSkpO1xuICAgIHJldHVybiBtO1xuICB9XG4gIHJldHVybiBjKCksIGQoKTtcbn07XG5mdW5jdGlvbiBDdChuKSB7XG4gIHJldHVybiBuID8gbi5yZXBsYWNlKGZ1LCBUbikgOiBUbjtcbn1cbnZhciB5dSA9IGd1O1xuZnVuY3Rpb24gdXIobiwgZSkge1xuICB2YXIgdCA9IG51bGw7XG4gIGlmICghbiB8fCB0eXBlb2YgbiAhPSBcInN0cmluZ1wiKVxuICAgIHJldHVybiB0O1xuICBmb3IgKHZhciByLCBpID0geXUobiksIGwgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIsIG8sIHUsIGEgPSAwLCBjID0gaS5sZW5ndGg7IGEgPCBjOyBhKyspXG4gICAgciA9IGlbYV0sIG8gPSByLnByb3BlcnR5LCB1ID0gci52YWx1ZSwgbCA/IGUobywgdSwgcikgOiB1ICYmICh0IHx8ICh0ID0ge30pLCB0W29dID0gdSk7XG4gIHJldHVybiB0O1xufVxubHUuZXhwb3J0cyA9IHVyO1xuR24uZGVmYXVsdCA9IHVyO1xuY29uc3QgeHUgPSBHbiwgRWUgPSB7fS5oYXNPd25Qcm9wZXJ0eSwga3UgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJ0YWJsZVwiLCBcInRoZWFkXCIsIFwidGJvZHlcIiwgXCJ0Zm9vdFwiLCBcInRyXCJdKTtcbmZ1bmN0aW9uIGFyKG4sIGUpIHtcbiAgY29uc3QgdCA9IFtdO1xuICBsZXQgciA9IC0xLCBpO1xuICBmb3IgKDsgKytyIDwgZS5jaGlsZHJlbi5sZW5ndGg7IClcbiAgICBpID0gZS5jaGlsZHJlbltyXSwgaS50eXBlID09PSBcImVsZW1lbnRcIiA/IHQucHVzaChidShuLCBpLCByLCBlKSkgOiBpLnR5cGUgPT09IFwidGV4dFwiID8gKGUudHlwZSAhPT0gXCJlbGVtZW50XCIgfHwgIWt1LmhhcyhlLnRhZ05hbWUpIHx8ICF0dShpKSkgJiYgdC5wdXNoKGkudmFsdWUpIDogaS50eXBlID09PSBcInJhd1wiICYmICFuLm9wdGlvbnMuc2tpcEh0bWwgJiYgdC5wdXNoKGkudmFsdWUpO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIGJ1KG4sIGUsIHQsIHIpIHtcbiAgY29uc3QgaSA9IG4ub3B0aW9ucywgbCA9IGkudHJhbnNmb3JtTGlua1VyaSA9PT0gdm9pZCAwID8gZ3IgOiBpLnRyYW5zZm9ybUxpbmtVcmksIG8gPSBuLnNjaGVtYSwgdSA9IGUudGFnTmFtZSwgYSA9IHt9O1xuICBsZXQgYyA9IG8sIHM7XG4gIGlmIChvLnNwYWNlID09PSBcImh0bWxcIiAmJiB1ID09PSBcInN2Z1wiICYmIChjID0gJG8sIG4uc2NoZW1hID0gYyksIGUucHJvcGVydGllcylcbiAgICBmb3IgKHMgaW4gZS5wcm9wZXJ0aWVzKVxuICAgICAgRWUuY2FsbChlLnByb3BlcnRpZXMsIHMpICYmIFN1KGEsIHMsIGUucHJvcGVydGllc1tzXSwgbik7XG4gICh1ID09PSBcIm9sXCIgfHwgdSA9PT0gXCJ1bFwiKSAmJiBuLmxpc3REZXB0aCsrO1xuICBjb25zdCBoID0gYXIobiwgZSk7XG4gICh1ID09PSBcIm9sXCIgfHwgdSA9PT0gXCJ1bFwiKSAmJiBuLmxpc3REZXB0aC0tLCBuLnNjaGVtYSA9IG87XG4gIGNvbnN0IGcgPSBlLnBvc2l0aW9uIHx8IHtcbiAgICBzdGFydDogeyBsaW5lOiBudWxsLCBjb2x1bW46IG51bGwsIG9mZnNldDogbnVsbCB9LFxuICAgIGVuZDogeyBsaW5lOiBudWxsLCBjb2x1bW46IG51bGwsIG9mZnNldDogbnVsbCB9XG4gIH0sIGQgPSBpLmNvbXBvbmVudHMgJiYgRWUuY2FsbChpLmNvbXBvbmVudHMsIHUpID8gaS5jb21wb25lbnRzW3VdIDogdSwgbSA9IHR5cGVvZiBkID09IFwic3RyaW5nXCIgfHwgZCA9PT0gT24uRnJhZ21lbnQ7XG4gIGlmICghZXUuaXNWYWxpZEVsZW1lbnRUeXBlKGQpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBgQ29tcG9uZW50IGZvciBuYW1lIFxcYCR7dX1cXGAgbm90IGRlZmluZWQgb3IgaXMgbm90IHJlbmRlcmFibGVgXG4gICAgKTtcbiAgaWYgKGEua2V5ID0gW1xuICAgIHUsXG4gICAgZy5zdGFydC5saW5lLFxuICAgIGcuc3RhcnQuY29sdW1uLFxuICAgIHRcbiAgXS5qb2luKFwiLVwiKSwgdSA9PT0gXCJhXCIgJiYgaS5saW5rVGFyZ2V0ICYmIChhLnRhcmdldCA9IHR5cGVvZiBpLmxpbmtUYXJnZXQgPT0gXCJmdW5jdGlvblwiID8gaS5saW5rVGFyZ2V0KFxuICAgIFN0cmluZyhhLmhyZWYgfHwgXCJcIiksXG4gICAgZS5jaGlsZHJlbixcbiAgICB0eXBlb2YgYS50aXRsZSA9PSBcInN0cmluZ1wiID8gYS50aXRsZSA6IG51bGxcbiAgKSA6IGkubGlua1RhcmdldCksIHUgPT09IFwiYVwiICYmIGwgJiYgKGEuaHJlZiA9IGwoXG4gICAgU3RyaW5nKGEuaHJlZiB8fCBcIlwiKSxcbiAgICBlLmNoaWxkcmVuLFxuICAgIHR5cGVvZiBhLnRpdGxlID09IFwic3RyaW5nXCIgPyBhLnRpdGxlIDogbnVsbFxuICApKSwgIW0gJiYgdSA9PT0gXCJjb2RlXCIgJiYgci50eXBlID09PSBcImVsZW1lbnRcIiAmJiByLnRhZ05hbWUgIT09IFwicHJlXCIgJiYgKGEuaW5saW5lID0gITApLCAhbSAmJiAodSA9PT0gXCJoMVwiIHx8IHUgPT09IFwiaDJcIiB8fCB1ID09PSBcImgzXCIgfHwgdSA9PT0gXCJoNFwiIHx8IHUgPT09IFwiaDVcIiB8fCB1ID09PSBcImg2XCIpICYmIChhLmxldmVsID0gTnVtYmVyLnBhcnNlSW50KHUuY2hhckF0KDEpLCAxMCkpLCB1ID09PSBcImltZ1wiICYmIGkudHJhbnNmb3JtSW1hZ2VVcmkgJiYgKGEuc3JjID0gaS50cmFuc2Zvcm1JbWFnZVVyaShcbiAgICBTdHJpbmcoYS5zcmMgfHwgXCJcIiksXG4gICAgU3RyaW5nKGEuYWx0IHx8IFwiXCIpLFxuICAgIHR5cGVvZiBhLnRpdGxlID09IFwic3RyaW5nXCIgPyBhLnRpdGxlIDogbnVsbFxuICApKSwgIW0gJiYgdSA9PT0gXCJsaVwiICYmIHIudHlwZSA9PT0gXCJlbGVtZW50XCIpIHtcbiAgICBjb25zdCB5ID0gd3UoZSk7XG4gICAgYS5jaGVja2VkID0geSAmJiB5LnByb3BlcnRpZXMgPyAhIXkucHJvcGVydGllcy5jaGVja2VkIDogbnVsbCwgYS5pbmRleCA9IGZlKHIsIGUpLCBhLm9yZGVyZWQgPSByLnRhZ05hbWUgPT09IFwib2xcIjtcbiAgfVxuICByZXR1cm4gIW0gJiYgKHUgPT09IFwib2xcIiB8fCB1ID09PSBcInVsXCIpICYmIChhLm9yZGVyZWQgPSB1ID09PSBcIm9sXCIsIGEuZGVwdGggPSBuLmxpc3REZXB0aCksICh1ID09PSBcInRkXCIgfHwgdSA9PT0gXCJ0aFwiKSAmJiAoYS5hbGlnbiAmJiAoYS5zdHlsZSB8fCAoYS5zdHlsZSA9IHt9KSwgYS5zdHlsZS50ZXh0QWxpZ24gPSBhLmFsaWduLCBkZWxldGUgYS5hbGlnbiksIG0gfHwgKGEuaXNIZWFkZXIgPSB1ID09PSBcInRoXCIpKSwgIW0gJiYgdSA9PT0gXCJ0clwiICYmIHIudHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgKGEuaXNIZWFkZXIgPSByLnRhZ05hbWUgPT09IFwidGhlYWRcIiksIGkuc291cmNlUG9zICYmIChhW1wiZGF0YS1zb3VyY2Vwb3NcIl0gPSBBdShnKSksICFtICYmIGkucmF3U291cmNlUG9zICYmIChhLnNvdXJjZVBvc2l0aW9uID0gZS5wb3NpdGlvbiksICFtICYmIGkuaW5jbHVkZUVsZW1lbnRJbmRleCAmJiAoYS5pbmRleCA9IGZlKHIsIGUpLCBhLnNpYmxpbmdDb3VudCA9IGZlKHIpKSwgbSB8fCAoYS5ub2RlID0gZSksIGgubGVuZ3RoID4gMCA/IE9uLmNyZWF0ZUVsZW1lbnQoZCwgYSwgaCkgOiBPbi5jcmVhdGVFbGVtZW50KGQsIGEpO1xufVxuZnVuY3Rpb24gd3Uobikge1xuICBsZXQgZSA9IC0xO1xuICBmb3IgKDsgKytlIDwgbi5jaGlsZHJlbi5sZW5ndGg7ICkge1xuICAgIGNvbnN0IHQgPSBuLmNoaWxkcmVuW2VdO1xuICAgIGlmICh0LnR5cGUgPT09IFwiZWxlbWVudFwiICYmIHQudGFnTmFtZSA9PT0gXCJpbnB1dFwiKVxuICAgICAgcmV0dXJuIHQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmZShuLCBlKSB7XG4gIGxldCB0ID0gLTEsIHIgPSAwO1xuICBmb3IgKDsgKyt0IDwgbi5jaGlsZHJlbi5sZW5ndGggJiYgbi5jaGlsZHJlblt0XSAhPT0gZTsgKVxuICAgIG4uY2hpbGRyZW5bdF0udHlwZSA9PT0gXCJlbGVtZW50XCIgJiYgcisrO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIFN1KG4sIGUsIHQsIHIpIHtcbiAgY29uc3QgaSA9IE1vKHIuc2NoZW1hLCBlKTtcbiAgbGV0IGwgPSB0O1xuICBsID09IG51bGwgfHwgbCAhPT0gbCB8fCAoQXJyYXkuaXNBcnJheShsKSAmJiAobCA9IGkuY29tbWFTZXBhcmF0ZWQgPyBpdShsKSA6IHJ1KGwpKSwgaS5wcm9wZXJ0eSA9PT0gXCJzdHlsZVwiICYmIHR5cGVvZiBsID09IFwic3RyaW5nXCIgJiYgKGwgPSBFdShsKSksIGkuc3BhY2UgJiYgaS5wcm9wZXJ0eSA/IG5bRWUuY2FsbCh5dCwgaS5wcm9wZXJ0eSkgPyB5dFtpLnByb3BlcnR5XSA6IGkucHJvcGVydHldID0gbCA6IGkuYXR0cmlidXRlICYmIChuW2kuYXR0cmlidXRlXSA9IGwpKTtcbn1cbmZ1bmN0aW9uIEV1KG4pIHtcbiAgY29uc3QgZSA9IHt9O1xuICB0cnkge1xuICAgIHh1KG4sIHQpO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gZTtcbiAgZnVuY3Rpb24gdChyLCBpKSB7XG4gICAgY29uc3QgbCA9IHIuc2xpY2UoMCwgNCkgPT09IFwiLW1zLVwiID8gYG1zLSR7ci5zbGljZSg0KX1gIDogcjtcbiAgICBlW2wucmVwbGFjZSgvLShbYS16XSkvZywgQ3UpXSA9IGk7XG4gIH1cbn1cbmZ1bmN0aW9uIEN1KG4sIGUpIHtcbiAgcmV0dXJuIGUudG9VcHBlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIEF1KG4pIHtcbiAgcmV0dXJuIFtcbiAgICBuLnN0YXJ0LmxpbmUsXG4gICAgXCI6XCIsXG4gICAgbi5zdGFydC5jb2x1bW4sXG4gICAgXCItXCIsXG4gICAgbi5lbmQubGluZSxcbiAgICBcIjpcIixcbiAgICBuLmVuZC5jb2x1bW5cbiAgXS5tYXAoU3RyaW5nKS5qb2luKFwiXCIpO1xufVxuY29uc3QgQXQgPSB7fS5oYXNPd25Qcm9wZXJ0eSwgUHUgPSBcImh0dHBzOi8vZ2l0aHViLmNvbS9yZW1hcmtqcy9yZWFjdC1tYXJrZG93bi9ibG9iL21haW4vY2hhbmdlbG9nLm1kXCIsIFduID0ge1xuICBwbHVnaW5zOiB7IHRvOiBcInJlbWFya1BsdWdpbnNcIiwgaWQ6IFwiY2hhbmdlLXBsdWdpbnMtdG8tcmVtYXJrcGx1Z2luc1wiIH0sXG4gIHJlbmRlcmVyczogeyB0bzogXCJjb21wb25lbnRzXCIsIGlkOiBcImNoYW5nZS1yZW5kZXJlcnMtdG8tY29tcG9uZW50c1wiIH0sXG4gIGFzdFBsdWdpbnM6IHsgaWQ6IFwicmVtb3ZlLWJ1Z2d5LWh0bWwtaW4tbWFya2Rvd24tcGFyc2VyXCIgfSxcbiAgYWxsb3dEYW5nZXJvdXNIdG1sOiB7IGlkOiBcInJlbW92ZS1idWdneS1odG1sLWluLW1hcmtkb3duLXBhcnNlclwiIH0sXG4gIGVzY2FwZUh0bWw6IHsgaWQ6IFwicmVtb3ZlLWJ1Z2d5LWh0bWwtaW4tbWFya2Rvd24tcGFyc2VyXCIgfSxcbiAgc291cmNlOiB7IHRvOiBcImNoaWxkcmVuXCIsIGlkOiBcImNoYW5nZS1zb3VyY2UtdG8tY2hpbGRyZW5cIiB9LFxuICBhbGxvd05vZGU6IHtcbiAgICB0bzogXCJhbGxvd0VsZW1lbnRcIixcbiAgICBpZDogXCJyZXBsYWNlLWFsbG93bm9kZS1hbGxvd2VkdHlwZXMtYW5kLWRpc2FsbG93ZWR0eXBlc1wiXG4gIH0sXG4gIGFsbG93ZWRUeXBlczoge1xuICAgIHRvOiBcImFsbG93ZWRFbGVtZW50c1wiLFxuICAgIGlkOiBcInJlcGxhY2UtYWxsb3dub2RlLWFsbG93ZWR0eXBlcy1hbmQtZGlzYWxsb3dlZHR5cGVzXCJcbiAgfSxcbiAgZGlzYWxsb3dlZFR5cGVzOiB7XG4gICAgdG86IFwiZGlzYWxsb3dlZEVsZW1lbnRzXCIsXG4gICAgaWQ6IFwicmVwbGFjZS1hbGxvd25vZGUtYWxsb3dlZHR5cGVzLWFuZC1kaXNhbGxvd2VkdHlwZXNcIlxuICB9LFxuICBpbmNsdWRlTm9kZUluZGV4OiB7XG4gICAgdG86IFwiaW5jbHVkZUVsZW1lbnRJbmRleFwiLFxuICAgIGlkOiBcImNoYW5nZS1pbmNsdWRlbm9kZWluZGV4LXRvLWluY2x1ZGVlbGVtZW50aW5kZXhcIlxuICB9XG59O1xuZnVuY3Rpb24gRnUobikge1xuICBmb3IgKGNvbnN0IGwgaW4gV24pXG4gICAgaWYgKEF0LmNhbGwoV24sIGwpICYmIEF0LmNhbGwobiwgbCkpIHtcbiAgICAgIGNvbnN0IG8gPSBXbltsXTtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYFtyZWFjdC1tYXJrZG93bl0gV2FybmluZzogcGxlYXNlICR7by50byA/IGB1c2UgXFxgJHtvLnRvfVxcYCBpbnN0ZWFkIG9mYCA6IFwicmVtb3ZlXCJ9IFxcYCR7bH1cXGAgKHNlZSA8JHtQdX0jJHtvLmlkfT4gZm9yIG1vcmUgaW5mbylgXG4gICAgICApLCBkZWxldGUgV25bbF07XG4gICAgfVxuICBjb25zdCBlID0gRHIoKS51c2UoX2wpLnVzZShuLnJlbWFya1BsdWdpbnMgfHwgW10pLnVzZShUbywge1xuICAgIC4uLm4ucmVtYXJrUmVoeXBlT3B0aW9ucyxcbiAgICBhbGxvd0Rhbmdlcm91c0h0bWw6ICEwXG4gIH0pLnVzZShuLnJlaHlwZVBsdWdpbnMgfHwgW10pLnVzZShHbywgbiksIHQgPSBuZXcgRnQoKTtcbiAgdHlwZW9mIG4uY2hpbGRyZW4gPT0gXCJzdHJpbmdcIiA/IHQudmFsdWUgPSBuLmNoaWxkcmVuIDogbi5jaGlsZHJlbiAhPT0gdm9pZCAwICYmIG4uY2hpbGRyZW4gIT09IG51bGwgJiYgY29uc29sZS53YXJuKFxuICAgIGBbcmVhY3QtbWFya2Rvd25dIFdhcm5pbmc6IHBsZWFzZSBwYXNzIGEgc3RyaW5nIGFzIFxcYGNoaWxkcmVuXFxgIChub3Q6IFxcYCR7bi5jaGlsZHJlbn1cXGApYFxuICApO1xuICBjb25zdCByID0gZS5ydW5TeW5jKGUucGFyc2UodCksIHQpO1xuICBpZiAoci50eXBlICE9PSBcInJvb3RcIilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBgcm9vdGAgbm9kZVwiKTtcbiAgbGV0IGkgPSBPbi5jcmVhdGVFbGVtZW50KFxuICAgIE9uLkZyYWdtZW50LFxuICAgIHt9LFxuICAgIGFyKHsgb3B0aW9uczogbiwgc2NoZW1hOiBqbywgbGlzdERlcHRoOiAwIH0sIHIpXG4gICk7XG4gIHJldHVybiBuLmNsYXNzTmFtZSAmJiAoaSA9IE9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IG4uY2xhc3NOYW1lIH0sIGkpKSwgaTtcbn1cbkZ1LnByb3BUeXBlcyA9IHtcbiAgLy8gQ29yZSBvcHRpb25zOlxuICBjaGlsZHJlbjogRC5zdHJpbmcsXG4gIC8vIExheW91dCBvcHRpb25zOlxuICBjbGFzc05hbWU6IEQuc3RyaW5nLFxuICAvLyBGaWx0ZXIgb3B0aW9uczpcbiAgYWxsb3dFbGVtZW50OiBELmZ1bmMsXG4gIGFsbG93ZWRFbGVtZW50czogRC5hcnJheU9mKEQuc3RyaW5nKSxcbiAgZGlzYWxsb3dlZEVsZW1lbnRzOiBELmFycmF5T2YoRC5zdHJpbmcpLFxuICB1bndyYXBEaXNhbGxvd2VkOiBELmJvb2wsXG4gIC8vIFBsdWdpbiBvcHRpb25zOlxuICByZW1hcmtQbHVnaW5zOiBELmFycmF5T2YoXG4gICAgRC5vbmVPZlR5cGUoW1xuICAgICAgRC5vYmplY3QsXG4gICAgICBELmZ1bmMsXG4gICAgICBELmFycmF5T2YoXG4gICAgICAgIEQub25lT2ZUeXBlKFtcbiAgICAgICAgICBELmJvb2wsXG4gICAgICAgICAgRC5zdHJpbmcsXG4gICAgICAgICAgRC5vYmplY3QsXG4gICAgICAgICAgRC5mdW5jLFxuICAgICAgICAgIEQuYXJyYXlPZihcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgLy8gdHlwZS1jb3ZlcmFnZTppZ25vcmUtbmV4dC1saW5lXG4gICAgICAgICAgICBELmFueVxuICAgICAgICAgIClcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICBdKVxuICApLFxuICByZWh5cGVQbHVnaW5zOiBELmFycmF5T2YoXG4gICAgRC5vbmVPZlR5cGUoW1xuICAgICAgRC5vYmplY3QsXG4gICAgICBELmZ1bmMsXG4gICAgICBELmFycmF5T2YoXG4gICAgICAgIEQub25lT2ZUeXBlKFtcbiAgICAgICAgICBELmJvb2wsXG4gICAgICAgICAgRC5zdHJpbmcsXG4gICAgICAgICAgRC5vYmplY3QsXG4gICAgICAgICAgRC5mdW5jLFxuICAgICAgICAgIEQuYXJyYXlPZihcbiAgICAgICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgLy8gdHlwZS1jb3ZlcmFnZTppZ25vcmUtbmV4dC1saW5lXG4gICAgICAgICAgICBELmFueVxuICAgICAgICAgIClcbiAgICAgICAgXSlcbiAgICAgIClcbiAgICBdKVxuICApLFxuICAvLyBUcmFuc2Zvcm0gb3B0aW9uczpcbiAgc291cmNlUG9zOiBELmJvb2wsXG4gIHJhd1NvdXJjZVBvczogRC5ib29sLFxuICBza2lwSHRtbDogRC5ib29sLFxuICBpbmNsdWRlRWxlbWVudEluZGV4OiBELmJvb2wsXG4gIHRyYW5zZm9ybUxpbmtVcmk6IEQub25lT2ZUeXBlKFtELmZ1bmMsIEQuYm9vbF0pLFxuICBsaW5rVGFyZ2V0OiBELm9uZU9mVHlwZShbRC5mdW5jLCBELnN0cmluZ10pLFxuICB0cmFuc2Zvcm1JbWFnZVVyaTogRC5mdW5jLFxuICBjb21wb25lbnRzOiBELm9iamVjdFxufTtcbmV4cG9ydCB7XG4gIEZ1IGFzIGRlZmF1bHQsXG4gIGdyIGFzIHVyaVRyYW5zZm9ybWVyXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///20995\n");

/***/ })

};
;