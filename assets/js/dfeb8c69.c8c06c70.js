"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[6315],{1934:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return u},toc:function(){return d},default:function(){return p}});var n=a(3117),s=a(102),o=(a(7294),a(3905)),r=a(3052),i=["components"],l={id:"useAtomState",title:"useAtomState"},c=void 0,u={unversionedId:"api/hooks/useAtomState",id:"api/hooks/useAtomState",isDocsHomePage:!1,title:"useAtomState",description:"A React hook that accepts an atom and its params and registers a dynamic graph dependency on the resolved atom instance, returning a tuple of the current value and a state setter.",source:"@site/docs/api/hooks/useAtomState.mdx",sourceDirName:"api/hooks",slug:"/api/hooks/useAtomState",permalink:"/zedux/docs/api/hooks/useAtomState",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/hooks/useAtomState.mdx",tags:[],version:"current",frontMatter:{id:"useAtomState",title:"useAtomState"},sidebar:"react",previous:{title:"useAtomSelector",permalink:"/zedux/docs/api/hooks/useAtomSelector"},next:{title:"useAtomValue",permalink:"/zedux/docs/api/hooks/useAtomValue"}},d=[{value:"Example",id:"example",children:[],level:2},{value:"Signature",id:"signature",children:[{value:"Overloads",id:"overloads",children:[],level:3},{value:"<code>atom</code>",id:"atom",children:[],level:3},{value:"<code>params</code>",id:"params",children:[],level:3},{value:"<code>instance</code>",id:"instance",children:[],level:3}],level:2}],m={toc:d};function p(e){var t=e.components,a=(0,s.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { useAtomState } from '@zedux/react'\n")),(0,o.kt)("p",null,"A React hook that accepts an atom and its params and registers a ",(0,o.kt)("a",{parentName:"p",href:"../glossary#dynamic-graph-dependency"},"dynamic graph dependency")," on the resolved atom instance, returning a tuple of the current value and a state setter."),(0,o.kt)("p",null,"The component that uses this hook will rerender whenever the resolved atom instance's state changes."),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)(r.u,{resultVar:"Seconds",mdxType:"LiveEditor"},"\nconst secondsAtom = atom('seconds', () => {\n  const store = injectStore(0)\n\n  injectEffect(() => {\n    const intervalId = setInterval(\n      () => store.setState(val => val + 1),\n      1000\n    )\n\n    return () => clearInterval(intervalId)\n  }, [])\n\n  return store\n})\n\nfunction Seconds() {\n  const [state, setState] = useAtomState(secondsAtom)\n\n  return (\n    <>\n      <div>Seconds: {state}</div>\n      <button onClick={() => setState(val => val + 1)}>Increment</button>\n    </>\n  )\n}\n"),(0,o.kt)("p",null,"Miscellaneous:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const [val, setVal] = useAtomState(myAtom)\nconst [withParams, setter] = useAtomState(myAtom, ['param 1', 'param 2'])\nconst [fromInstance, setter] = useAtomState(instance)\n")),(0,o.kt)("h2",{id:"signature"},"Signature"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"useAtomState(atom, params?) => [state, setState]\n")),(0,o.kt)("p",null,"Uses the atom + params combo to find an existing atom instance. If no instance is found, creates one. Returns a tuple of the resolved atom instance's current state and ",(0,o.kt)("a",{parentName:"p",href:"../classes/AtomInstance#setstate"},"state setter"),"."),(0,o.kt)("h3",{id:"overloads"},"Overloads"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"useAtomState(instance) => [state, setState]\n")),(0,o.kt)("h3",{id:"atom"},(0,o.kt)("inlineCode",{parentName:"h3"},"atom")),(0,o.kt)("p",null,"Required. The ",(0,o.kt)("a",{parentName:"p",href:"../classes/Atom"},"atom")," object whose key will be used to find an existing atom instance and whose definition will be used to create an atom instance if none exist yet."),(0,o.kt)("h3",{id:"params"},(0,o.kt)("inlineCode",{parentName:"h3"},"params")),(0,o.kt)("p",null,"Optional. An array of parameters that identify this atom instance. These params will be passed to the atom's ",(0,o.kt)("a",{parentName:"p",href:"../glossary#evaluator"},"evaluator function"),"."),(0,o.kt)("p",null,"TS users will be required to pass this for atoms that take params. If you don't use TS ... just don't forget to pass them."),(0,o.kt)("h3",{id:"instance"},(0,o.kt)("inlineCode",{parentName:"h3"},"instance")),(0,o.kt)("p",null,"Required (in this overload). An ",(0,o.kt)("a",{parentName:"p",href:"../classes/AtomInstance"},"atom instance"),". Will register a dynamic dependency on the passed instance and return a tuple of the atom instance's current state and ",(0,o.kt)("inlineCode",{parentName:"p"},".setState")," function."))}p.isMDXComponent=!0}}]);