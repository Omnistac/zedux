"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[53],{1109:function(e){e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"react":[{"type":"category","label":"About","items":[{"type":"link","label":"Introducing Zedux","href":"/zedux/docs/about/introduction","docId":"about/introduction"},{"type":"link","label":"Overview","href":"/zedux/docs/about/overview","docId":"about/overview"},{"type":"link","label":"Recoil Comparison","href":"/zedux/docs/about/recoil-comparison","docId":"about/recoil-comparison"},{"type":"link","label":"Redux Comparison","href":"/zedux/docs/about/redux-comparison","docId":"about/redux-comparison"},{"type":"link","label":"React Query Comparison","href":"/zedux/docs/about/react-query-comparison","docId":"about/react-query-comparison"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Walkthrough","items":[{"type":"link","label":"Quick Start","href":"/zedux/docs/walkthrough/quick-start","docId":"walkthrough/quick-start"},{"type":"link","label":"Atom State","href":"/zedux/docs/walkthrough/atom-state","docId":"walkthrough/atom-state"},{"type":"link","label":"Atom Instances","href":"/zedux/docs/walkthrough/atom-instances","docId":"walkthrough/atom-instances"},{"type":"link","label":"Atom APIs","href":"/zedux/docs/walkthrough/atom-apis","docId":"walkthrough/atom-apis"},{"type":"link","label":"Ecosystems","href":"/zedux/docs/walkthrough/ecosystems","docId":"walkthrough/ecosystems"},{"type":"link","label":"The Graph","href":"/zedux/docs/walkthrough/the-graph","docId":"walkthrough/the-graph"},{"type":"link","label":"Overrides","href":"/zedux/docs/walkthrough/overrides","docId":"walkthrough/overrides"},{"type":"link","label":"Configuring Atoms","href":"/zedux/docs/walkthrough/configuring-atoms","docId":"walkthrough/configuring-atoms"},{"type":"link","label":"Atom Getters","href":"/zedux/docs/walkthrough/atom-getters","docId":"walkthrough/atom-getters"},{"type":"link","label":"Selectors","href":"/zedux/docs/walkthrough/selectors","docId":"walkthrough/selectors"},{"type":"link","label":"Destruction","href":"/zedux/docs/walkthrough/destruction","docId":"walkthrough/destruction"},{"type":"link","label":"React Context","href":"/zedux/docs/walkthrough/react-context","docId":"walkthrough/react-context"},{"type":"link","label":"Suspense","href":"/zedux/docs/walkthrough/suspense","docId":"walkthrough/suspense"},{"type":"link","label":"Query Atoms","href":"/zedux/docs/walkthrough/query-atoms","docId":"walkthrough/query-atoms"},{"type":"link","label":"Stores","href":"/zedux/docs/walkthrough/stores","docId":"walkthrough/stores"},{"type":"link","label":"Side Effects","href":"/zedux/docs/walkthrough/side-effects","docId":"walkthrough/side-effects"},{"type":"link","label":"Custom Injectors","href":"/zedux/docs/walkthrough/custom-injectors","docId":"walkthrough/custom-injectors"},{"type":"link","label":"Resets","href":"/zedux/docs/walkthrough/resets","docId":"walkthrough/resets"},{"type":"link","label":"State Machines","href":"/zedux/docs/walkthrough/state-machines","docId":"walkthrough/state-machines"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Advanced","items":[{"type":"link","label":"Complex Params","href":"/zedux/docs/advanced/complex-params","docId":"advanced/complex-params"},{"type":"link","label":"Time Travel","href":"/zedux/docs/advanced/time-travel","docId":"advanced/time-travel"},{"type":"link","label":"Plugins","href":"/zedux/docs/advanced/plugins","docId":"advanced/plugins"},{"type":"link","label":"Persistence","href":"/zedux/docs/advanced/persistence","docId":"advanced/persistence"},{"type":"link","label":"SSR","href":"/zedux/docs/advanced/ssr","docId":"advanced/ssr"},{"type":"link","label":"Store Composition","href":"/zedux/docs/advanced/store-composition","docId":"advanced/store-composition"}],"collapsed":true,"collapsible":true},{"type":"category","label":"API","items":[{"type":"category","label":"Classes","items":[{"type":"link","label":"Atom","href":"/zedux/docs/api/classes/Atom","docId":"api/classes/Atom"},{"type":"link","label":"AtomApi","href":"/zedux/docs/api/classes/AtomApi","docId":"api/classes/AtomApi"},{"type":"link","label":"AtomInstance","href":"/zedux/docs/api/classes/AtomInstance","docId":"api/classes/AtomInstance"},{"type":"link","label":"Ecosystem","href":"/zedux/docs/api/classes/Ecosystem","docId":"api/classes/Ecosystem"},{"type":"link","label":"Ion","href":"/zedux/docs/api/classes/Ion","docId":"api/classes/Ion"},{"type":"link","label":"Store","href":"/zedux/docs/api/classes/Store","docId":"api/classes/Store"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Components","items":[{"type":"link","label":"EcosystemProvider","href":"/zedux/docs/api/components/EcosystemProvider","docId":"api/components/EcosystemProvider"},{"type":"link","label":"AtomInstanceProvider","href":"/zedux/docs/api/components/AtomInstanceProvider","docId":"api/components/AtomInstanceProvider"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Constants","items":[{"type":"link","label":"metaTypes","href":"/zedux/docs/api/constants/metaTypes","docId":"api/constants/metaTypes"},{"type":"link","label":"zeduxGlobalStore","href":"/zedux/docs/api/constants/zeduxGlobalStore","docId":"api/constants/zeduxGlobalStore"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Factories","items":[{"type":"link","label":"actionFactory","href":"/zedux/docs/api/factories/actionFactory","docId":"api/factories/actionFactory"},{"type":"link","label":"api","href":"/zedux/docs/api/factories/api","docId":"api/factories/api"},{"type":"link","label":"atom","href":"/zedux/docs/api/factories/atom","docId":"api/factories/atom"},{"type":"link","label":"createEcosystem","href":"/zedux/docs/api/factories/createEcosystem","docId":"api/factories/createEcosystem"},{"type":"link","label":"createReducer","href":"/zedux/docs/api/factories/createReducer","docId":"api/factories/createReducer"},{"type":"link","label":"createStore","href":"/zedux/docs/api/factories/createStore","docId":"api/factories/createStore"},{"type":"link","label":"ion","href":"/zedux/docs/api/factories/ion","docId":"api/factories/ion"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Hooks","items":[{"type":"link","label":"useAtomConsumer","href":"/zedux/docs/api/hooks/useAtomConsumer","docId":"api/hooks/useAtomConsumer"},{"type":"link","label":"useAtomInstance","href":"/zedux/docs/api/hooks/useAtomInstance","docId":"api/hooks/useAtomInstance"},{"type":"link","label":"useAtomSelector","href":"/zedux/docs/api/hooks/useAtomSelector","docId":"api/hooks/useAtomSelector"},{"type":"link","label":"useAtomState","href":"/zedux/docs/api/hooks/useAtomState","docId":"api/hooks/useAtomState"},{"type":"link","label":"useAtomValue","href":"/zedux/docs/api/hooks/useAtomValue","docId":"api/hooks/useAtomValue"},{"type":"link","label":"useEcosystem","href":"/zedux/docs/api/hooks/useEcosystem","docId":"api/hooks/useEcosystem"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Injectors","items":[{"type":"link","label":"injectAtomGetters","href":"/zedux/docs/api/injectors/injectAtomGetters","docId":"api/injectors/injectAtomGetters"},{"type":"link","label":"injectAtomInstance","href":"/zedux/docs/api/injectors/injectAtomInstance","docId":"api/injectors/injectAtomInstance"},{"type":"link","label":"injectAtomSelector","href":"/zedux/docs/api/injectors/injectAtomSelector","docId":"api/injectors/injectAtomSelector"},{"type":"link","label":"injectAtomState","href":"/zedux/docs/api/injectors/injectAtomState","docId":"api/injectors/injectAtomState"},{"type":"link","label":"injectAtomValue","href":"/zedux/docs/api/injectors/injectAtomValue","docId":"api/injectors/injectAtomValue"},{"type":"link","label":"injectCallback","href":"/zedux/docs/api/injectors/injectCallback","docId":"api/injectors/injectCallback"},{"type":"link","label":"injectEffect","href":"/zedux/docs/api/injectors/injectEffect","docId":"api/injectors/injectEffect"},{"type":"link","label":"injectInvalidate","href":"/zedux/docs/api/injectors/injectInvalidate","docId":"api/injectors/injectInvalidate"},{"type":"link","label":"injectMachineStore","href":"/zedux/docs/api/injectors/injectMachineStore","docId":"api/injectors/injectMachineStore"},{"type":"link","label":"injectMemo","href":"/zedux/docs/api/injectors/injectMemo","docId":"api/injectors/injectMemo"},{"type":"link","label":"injectPromise","href":"/zedux/docs/api/injectors/injectPromise","docId":"api/injectors/injectPromise"},{"type":"link","label":"injectRef","href":"/zedux/docs/api/injectors/injectRef","docId":"api/injectors/injectRef"},{"type":"link","label":"injectStore","href":"/zedux/docs/api/injectors/injectStore","docId":"api/injectors/injectStore"},{"type":"link","label":"injectWhy","href":"/zedux/docs/api/injectors/injectWhy","docId":"api/injectors/injectWhy"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Types","items":[{"type":"link","label":"Action","href":"/zedux/docs/api/types/Action","docId":"api/types/Action"},{"type":"link","label":"ActionChain","href":"/zedux/docs/api/types/ActionChain","docId":"api/types/ActionChain"},{"type":"link","label":"ActionFactory","href":"/zedux/docs/api/types/ActionFactory","docId":"api/types/ActionFactory"},{"type":"link","label":"AtomConfig","href":"/zedux/docs/api/types/AtomConfig","docId":"api/types/AtomConfig"},{"type":"link","label":"AtomGetters","href":"/zedux/docs/api/types/AtomGetters","docId":"api/types/AtomGetters"},{"type":"link","label":"AtomInstanceTtl","href":"/zedux/docs/api/types/AtomInstanceTtl","docId":"api/types/AtomInstanceTtl"},{"type":"link","label":"AtomSelector","href":"/zedux/docs/api/types/AtomSelector","docId":"api/types/AtomSelector"},{"type":"link","label":"AtomSelectorConfig","href":"/zedux/docs/api/types/AtomSelectorConfig","docId":"api/types/AtomSelectorConfig"},{"type":"link","label":"AtomSetters","href":"/zedux/docs/api/types/AtomSetters","docId":"api/types/AtomSetters"},{"type":"link","label":"DispatchInterceptor","href":"/zedux/docs/api/types/DispatchInterceptor","docId":"api/types/DispatchInterceptor"},{"type":"link","label":"EcosystemConfig","href":"/zedux/docs/api/types/EcosystemConfig","docId":"api/types/EcosystemConfig"},{"type":"link","label":"EvaluationReason","href":"/zedux/docs/api/types/EvaluationReason","docId":"api/types/EvaluationReason"},{"type":"link","label":"HierarchyDescriptor","href":"/zedux/docs/api/types/HierarchyDescriptor","docId":"api/types/HierarchyDescriptor"},{"type":"link","label":"Reducer","href":"/zedux/docs/api/types/Reducer","docId":"api/types/Reducer"},{"type":"link","label":"ReducerBuilder","href":"/zedux/docs/api/types/ReducerBuilder","docId":"api/types/ReducerBuilder"},{"type":"link","label":"SetStateInterceptor","href":"/zedux/docs/api/types/SetStateInterceptor","docId":"api/types/SetStateInterceptor"},{"type":"link","label":"Settable","href":"/zedux/docs/api/types/Settable","docId":"api/types/Settable"},{"type":"link","label":"Subscriber","href":"/zedux/docs/api/types/Subscriber","docId":"api/types/Subscriber"},{"type":"link","label":"Subscription","href":"/zedux/docs/api/types/Subscription","docId":"api/types/Subscription"}],"collapsed":true,"collapsible":true},{"type":"link","label":"Glossary","href":"/zedux/docs/api/glossary","docId":"api/glossary"}],"collapsed":true,"collapsible":true}]},"docs":{"about/faq":{"id":"about/faq","title":"FAQ","description":""},"about/introduction":{"id":"about/introduction","title":"Introducing Zedux","description":"Zedux is a flexible, multi-paradigm state management tool for React. It\'s packed with features covering all aspects of state management.","sidebar":"react"},"about/overview":{"id":"about/overview","title":"Overview","description":"Buckle in for a quick description and contrived example of every key feature of Zedux. The walkthrough will walk through this list in much more detail.","sidebar":"react"},"about/react-query-comparison":{"id":"about/react-query-comparison","title":"React Query Comparison","description":"While Zedux doesn\'t (yet!) provide helpers for query operations (infinite scrolling, pagination, etc), Zedux is currently patterned after React Query more than any other library (yes, more than Redux or Recoil). React Query\'s cache management is unparalleled. So Zedux\' atomic model borrows a lot of ideas from it.","sidebar":"react"},"about/recoil-comparison":{"id":"about/recoil-comparison","title":"Recoil Comparison","description":"Zedux\' atomic model was born in 2020 shortly after Recoil started gaining traction. We liked Recoil, but were turned away mostly by its complexity and (then-)unstable effects model. By borrowing ideas from React Query and React itself and by using Zedux\' existing composable store model, we were able to create an atomic model that we\'ve found more beginner-friendly and powerful.","sidebar":"react"},"about/redux-comparison":{"id":"about/redux-comparison","title":"Redux Comparison","description":"Zedux is more comparable to Redux Toolkit (RTK) than raw Redux, so that\'s what we\'ll compare against.","sidebar":"react"},"advanced/complex-params":{"id":"advanced/complex-params","title":"Complex Params","description":"Atom params and Atom Selector params must be serializable (with the exception of atom instances). Though it isn\'t recommended, you can disable this requirement.","sidebar":"react"},"advanced/dev-tools":{"id":"advanced/dev-tools","title":"Dev Tools","description":"\ud83d\udea7 This page is under construction"},"advanced/persistence":{"id":"advanced/persistence","title":"Persistence","description":"There are many ways to persist and restore state \\"snapshots\\" in Zedux. It can be done at the atom instance, ecosystem, or plugin level.","sidebar":"react"},"advanced/plugins":{"id":"advanced/plugins","title":"Plugins","description":"While Zedux is designed to be extremely useful out of the box, that doesn\'t mean it handles everything. Plugins satisfy the extremes of hackability.","sidebar":"react"},"advanced/ssr":{"id":"advanced/ssr","title":"SSR","description":"In the persistence guide, we learned how to get an ecosystem\'s state snapshot and use it to rehydrate the entire ecosystem. There is only a little more to learn to get a full-fledged SSR setup going.","sidebar":"react"},"advanced/store-composition":{"id":"advanced/store-composition","title":"Store Composition","description":"ActionChains","sidebar":"react"},"advanced/time-travel":{"id":"advanced/time-travel","title":"Time Travel","description":"One of the great patterns that Redux popularized is the ability to undo and redo state updates in your app. Earlier flux models didn\'t have this capability because they split state up across multiple stores. Well Zedux reintroduces the concept of multiple stores, so does that mean it loses out on time travel?","sidebar":"react"},"api/classes/Atom":{"id":"api/classes/Atom","title":"Atom","description":"The standard, default atom type. Instances of this class are passed to most of Zedux\' hooks and injectors.","sidebar":"react"},"api/classes/AtomApi":{"id":"api/classes/AtomApi","title":"AtomApi","description":"Defines certain one-off properties of an atom. These properties do not fit well in the injector paradigm, as they define key characteristics of the atom itself that should only be set once.","sidebar":"react"},"api/classes/AtomInstance":{"id":"api/classes/AtomInstance","title":"AtomInstance","description":"All standard \\"atom instances\\" are actually instances of this class. When Zedux instantiates Ions and Standard Atoms, it\'s just creating instances of this class.","sidebar":"react"},"api/classes/Ecosystem":{"id":"api/classes/Ecosystem","title":"Ecosystem","description":"The ecosystem is an isolated atom environment. It creates a scheduler for running atom-related tasks and a graph that manages atom dependencies.","sidebar":"react"},"api/classes/Ion":{"id":"api/classes/Ion","title":"Ion","description":"Extends Atom.","sidebar":"react"},"api/classes/MachineStore":{"id":"api/classes/MachineStore","title":"MachineStore","description":"\ud83d\udea7 This page is under construction"},"api/classes/SelectorCache":{"id":"api/classes/SelectorCache","title":"SelectorCache","description":"\ud83d\udea7 This page is under construction"},"api/classes/SelectorCacheInstance":{"id":"api/classes/SelectorCacheInstance","title":"SelectorCacheInstance","description":"\ud83d\udea7 This page is under construction"},"api/classes/Store":{"id":"api/classes/Store","title":"Store","description":"The class returned from the createStore() factory. The store is the basic unit of state management.","sidebar":"react"},"api/components/AtomInstanceProvider":{"id":"api/components/AtomInstanceProvider","title":"AtomInstanceProvider","description":"A component that provides one or more atom instances over React context.","sidebar":"react"},"api/components/EcosystemProvider":{"id":"api/components/EcosystemProvider","title":"EcosystemProvider","description":"A component that provides an ecosystem. The provided ecosystem will take command of all atom usages in any child components.","sidebar":"react"},"api/constants/metaTypes":{"id":"api/constants/metaTypes","title":"metaTypes","description":"An object of the \\"metaType\\" values Zedux uses internally in its ActionChain objects. You may encounter these meta nodes in action chains passed to effects subscribers in composed stores. Use this object to identify them.","sidebar":"react"},"api/constants/zeduxGlobalStore":{"id":"api/constants/zeduxGlobalStore","title":"zeduxGlobalStore","description":"Zedux creates a store internally to keep track of all ecosystems. Ecosystems are mutable objects with functions and circular references and all sorts of non-Reduxy patterns. This is by design - for performance and efficiency. But it means you can\'t use this global store to track state changes like in a normal, immutable flow.","sidebar":"react"},"api/factories/actionFactory":{"id":"api/factories/actionFactory","title":"actionFactory","description":"A factory for creating action factories.","sidebar":"react"},"api/factories/api":{"id":"api/factories/api","title":"api","description":"A factory for creating AtomApis.","sidebar":"react"},"api/factories/atom":{"id":"api/factories/atom","title":"atom","description":"Where it all starts. atom() is a factory for creating normal, everyday atoms. These atoms are actually instances of the Atom class.","sidebar":"react"},"api/factories/createEcosystem":{"id":"api/factories/createEcosystem","title":"createEcosystem","description":"Creates an atom ecosystem.","sidebar":"react"},"api/factories/createReducer":{"id":"api/factories/createReducer","title":"createReducer","description":"A factory for creating Redux-style reducers. These reducers can then be passed to createStore() or used directly in React\'s useReducer() hooks.","sidebar":"react"},"api/factories/createStore":{"id":"api/factories/createStore","title":"createStore","description":"Creates a Zedux store.","sidebar":"react"},"api/factories/ion":{"id":"api/factories/ion","title":"ion","description":"ion() is a factory for creating Ions. Ions are a type of atom that specialize in selection and derivation operations.","sidebar":"react"},"api/glossary":{"id":"api/glossary","title":"Glossary","description":"Dynamic Graph Dependency","sidebar":"react"},"api/hooks/useAtomConsumer":{"id":"api/hooks/useAtomConsumer","title":"useAtomConsumer","description":"A React hook that accepts an atom and returns an instance of that atom that has been provided over React context via ``.","sidebar":"react"},"api/hooks/useAtomInstance":{"id":"api/hooks/useAtomInstance","title":"useAtomInstance","description":"A React hook that accepts an atom and its params and registers a static graph dependency on the resolved atom instance. Returns the resolved atom instance object.","sidebar":"react"},"api/hooks/useAtomSelector":{"id":"api/hooks/useAtomSelector","title":"useAtomSelector","description":"A React hook that accepts an AtomSelector and registers a dynamic graph dependency on the selector\'s cache.","sidebar":"react"},"api/hooks/useAtomState":{"id":"api/hooks/useAtomState","title":"useAtomState","description":"A React hook that accepts an atom and its params and registers a dynamic graph dependency on the resolved atom instance, returning a tuple of the current value and a state setter.","sidebar":"react"},"api/hooks/useAtomValue":{"id":"api/hooks/useAtomValue","title":"useAtomValue","description":"A React hook that accepts an atom and its params and registers a dynamic graph dependency on the resolved atom instance, returning the value.","sidebar":"react"},"api/hooks/useEcosystem":{"id":"api/hooks/useEcosystem","title":"useEcosystem","description":"A React hook that returns a reference to the nearest ecosystem that\'s been provided over React context via ``. If no ecosystem has been provided, Zedux will return the global ecosystem. If the global ecosystem hasn\'t been created yet, Zedux will create it.","sidebar":"react"},"api/injectors/injectAtomGetters":{"id":"api/injectors/injectAtomGetters","title":"injectAtomGetters","description":"An unrestricted injector that returns an AtomGetters object","sidebar":"react"},"api/injectors/injectAtomInstance":{"id":"api/injectors/injectAtomInstance","title":"injectAtomInstance","description":"An injector that accepts an atom and its params and registers a static graph dependency on the resolved atom instance. Returns the resolved atom instance object.","sidebar":"react"},"api/injectors/injectAtomSelector":{"id":"api/injectors/injectAtomSelector","title":"injectAtomSelector","description":"An injector that accepts an AtomSelector and registers a dynamic graph dependency on the selector\'s cache.","sidebar":"react"},"api/injectors/injectAtomState":{"id":"api/injectors/injectAtomState","title":"injectAtomState","description":"An injector that accepts an atom and its params and registers a dynamic graph dependency on the resolved atom instance. Returns a tuple of the instance\'s store\'s current value and an export-infused state setter function.","sidebar":"react"},"api/injectors/injectAtomValue":{"id":"api/injectors/injectAtomValue","title":"injectAtomValue","description":"An injector that accepts an atom and its params and registers a dynamic graph dependency on the resolved atom instance. Returns the current value of the injected atom instance\'s store.","sidebar":"react"},"api/injectors/injectCallback":{"id":"api/injectors/injectCallback","title":"injectCallback","description":"An injector that memoizes a function. Really just a shorthand for injectMemo() where the memoized value itself is a function. The returned function reference will only change when the passed dependencies change.","sidebar":"react"},"api/injectors/injectEffect":{"id":"api/injectors/injectEffect","title":"injectEffect","description":"An injector that attaches a side effect to an atom instance. Runs the effect on initial atom evaluation and again every time the passed dependencies change on subsequent evaluations.","sidebar":"react"},"api/injectors/injectInvalidate":{"id":"api/injectors/injectInvalidate","title":"injectInvalidate","description":"An unrestricted injector that returns an invalidate() function. This invalidate() function can be used to force a reevaluation of the current atom instance.","sidebar":"react"},"api/injectors/injectMachineStore":{"id":"api/injectors/injectMachineStore","title":"injectMachineStore","description":"An injector that creates and configures a MachineStore.","sidebar":"react"},"api/injectors/injectMemo":{"id":"api/injectors/injectMemo","title":"injectMemo","description":"An injector that memoizes a value. This is the injector equivalent of React\'s useMemo() hook. Like useMemo(), injectMemo() will return the same value on subsequent evaluations unless any items in the dependency array change.","sidebar":"react"},"api/injectors/injectPromise":{"id":"api/injectors/injectPromise","title":"injectPromise","description":"An injector that creates a memoized promise reference. Returns an AtomApi with a promise and store attached. This AtomApi\'s store tracks the promise\'s state.","sidebar":"react"},"api/injectors/injectRef":{"id":"api/injectors/injectRef","title":"injectRef","description":"An injector that returns a stable, mutable Ref object. The injector equivalent of React\'s useRef hook.","sidebar":"react"},"api/injectors/injectStore":{"id":"api/injectors/injectStore","title":"injectStore","description":"An injector that creates and returns a stable Zedux store. This reference will not change on subsequent evaluations of this atom instance.","sidebar":"react"},"api/injectors/injectWhy":{"id":"api/injectors/injectWhy","title":"injectWhy","description":"An unrestricted injector that returns a list of reasons explaining why the current atom instance is reevaluating. This injector returns an empty array on the first evaluation. On subsequent evaluations, it returns the full list of EvaluationReasons detailing why this atom reevaluated.","sidebar":"react"},"api/types/Action":{"id":"api/types/Action","title":"Action","description":"The objects ultimately dispatched to Zedux stores.","sidebar":"react"},"api/types/ActionChain":{"id":"api/types/ActionChain","title":"ActionChain","description":"The object accepted by store.dispatch(), thus also the object passed to instance.dispatch() and to DispatchInterceptors.","sidebar":"react"},"api/types/ActionFactory":{"id":"api/types/ActionFactory","title":"ActionFactory","description":"The function returned from the actionFactory() factory.","sidebar":"react"},"api/types/AtomConfig":{"id":"api/types/AtomConfig","title":"AtomConfig","description":"An AtomConfig object is the 3rd argument passed to the atom() factory.","sidebar":"react"},"api/types/AtomGetters":{"id":"api/types/AtomGetters","title":"AtomGetters","description":"An object that provides several functions for working with atoms.","sidebar":"react"},"api/types/AtomInstanceTtl":{"id":"api/types/AtomInstanceTtl","title":"AtomInstanceTtl","description":"Ttl (Time To Live) can be set at the ecosystem, atom, or atom instance levels. Setting a ttl at the atom instance level is the most flexible. You can do so using an AtomApi.","sidebar":"react"},"api/types/AtomSelector":{"id":"api/types/AtomSelector","title":"AtomSelector","description":"A function that receives an AtomGetters object as its first parameter. It can take any number of other parameters and can return anything. It can use the AtomGetters to get atom values and run other AtomSelectors.","sidebar":"react"},"api/types/AtomSelectorConfig":{"id":"api/types/AtomSelectorConfig","title":"AtomSelectorConfig","description":"Everywhere Zedux accepts an AtomSelector, it also accepts an AtomSelectorConfig object. This object has a required selector field and a few optional fields used to configure the selector.","sidebar":"react"},"api/types/AtomSetters":{"id":"api/types/AtomSetters","title":"AtomSetters","description":"The object Zedux passes as the first parameter to ion setters.","sidebar":"react"},"api/types/DispatchInterceptor":{"id":"api/types/DispatchInterceptor","title":"DispatchInterceptor","description":"A function that intercepts instance.dispatch() calls.","sidebar":"react"},"api/types/EcosystemConfig":{"id":"api/types/EcosystemConfig","title":"EcosystemConfig","description":"The config object passed to the createEcosystem() factory.","sidebar":"react"},"api/types/EvaluationReason":{"id":"api/types/EvaluationReason","title":"EvaluationReason","description":"Every update that causes an atom instance to reevaluate produces an EvaluationReason. You can get the list of reasons that caused an atom instance to reevaluate using injectWhy().","sidebar":"react"},"api/types/HierarchyDescriptor":{"id":"api/types/HierarchyDescriptor","title":"HierarchyDescriptor","description":"The type passed to createStore() and to Store#use().","sidebar":"react"},"api/types/MachineState":{"id":"api/types/MachineState","title":"MachineState","description":"\ud83d\udea7 This page is under construction"},"api/types/PromiseState":{"id":"api/types/PromiseState","title":"PromiseState","description":"The state shape that query atoms and injectPromise use. This shape is based off React Query\'s queries."},"api/types/Reducer":{"id":"api/types/Reducer","title":"Reducer","description":"In Zedux, reducers are exactly the same as in Redux and React. A reducer is just a function that receives the current state and an action and returns the new state.","sidebar":"react"},"api/types/ReducerBuilder":{"id":"api/types/ReducerBuilder","title":"ReducerBuilder","description":"The function returned from createReducer.","sidebar":"react"},"api/types/SetStateInterceptor":{"id":"api/types/SetStateInterceptor","title":"SetStateInterceptor","description":"A function that intercepts instance.setState() calls.","sidebar":"react"},"api/types/Settable":{"id":"api/types/Settable","title":"Settable","description":"The value passed to store.setState(), thus also the value passed to instance.setState() and to SetStateInterceptors and ion setters.","sidebar":"react"},"api/types/StoreEffect":{"id":"api/types/StoreEffect","title":"StoreEffect","description":"\ud83d\udea7 This page is under construction"},"api/types/Subscriber":{"id":"api/types/Subscriber","title":"Subscriber","description":"A function passed to store.subscribe(). Zedux will call the function when certain events happen.","sidebar":"react"},"api/types/Subscription":{"id":"api/types/Subscription","title":"Subscription","description":"The object returned from Store#subscribe().","sidebar":"react"},"walkthrough/advanced-patterns":{"id":"walkthrough/advanced-patterns","title":"Advanced Patterns","description":"Circular Dependencies"},"walkthrough/atom-apis":{"id":"walkthrough/atom-apis","title":"Atom APIs","description":"In the quick start, we learned that injectors are like hooks for atoms. But some operations don\'t fit well into the injector paradigm. Injectors, like hooks, should be composable and usable multiple times throughout an atom state factory and other injectors.","sidebar":"react"},"walkthrough/atom-getters":{"id":"walkthrough/atom-getters","title":"Atom Getters","description":"We\'ve learned several hooks and injectors that we can use to get atoms and their values while updating the dependency graph. These are easy enough. But it gets even easier.","sidebar":"react"},"walkthrough/atom-instances":{"id":"walkthrough/atom-instances","title":"Atom Instances","description":"In the quick start, we learned that atoms are like classes. Whenever an atom is used, Zedux creates an \\"instance\\" of that atom and caches it.","sidebar":"react"},"walkthrough/atom-state":{"id":"walkthrough/atom-state","title":"Atom State","description":"In the quick start we learned how to use the useAtomState hook to get and update an atom instance\'s state from a React component. Calling the setState function returned from useAtomState triggers an \\"external update\\". But atoms can also update themselves.","sidebar":"react"},"walkthrough/configuring-atoms":{"id":"walkthrough/configuring-atoms","title":"Configuring Atoms","description":"We\'ve learned how to use Atom APIs to configure an atom instance\'s promise and exports. But there are a few more configuration options we haven\'t covered.","sidebar":"react"},"walkthrough/creating-atoms":{"id":"walkthrough/creating-atoms","title":"Creating Atoms","description":"Atoms are extremely flexible and can be configured in many ways for many different situations."},"walkthrough/custom-injectors":{"id":"walkthrough/custom-injectors","title":"Custom Injectors","description":"If you use React, you\'ve probably written custom hooks. These are functions whose names start with use and that compose other hooks.","sidebar":"react"},"walkthrough/dependency-injection":{"id":"walkthrough/dependency-injection","title":"Dependency Injection","description":"React creates a perfect environment for Inversion of Control. Yet this amazing technique is underused. Zedux aims to help bring Dependency Injection (DI) to the forefront of React workflows."},"walkthrough/destruction":{"id":"walkthrough/destruction","title":"Destruction","description":"In the atom instances walkthrough, we learned that every atom instance has an activeState \\"lifecycle\\":","sidebar":"react"},"walkthrough/ecosystems":{"id":"walkthrough/ecosystems","title":"Ecosystems","description":"All atoms live in an atom ecosystem. An ecosystem is like an isolated group of atoms. Atoms in an ecosystem can interact with each other, but are unaware of atoms in other ecosystems.","sidebar":"react"},"walkthrough/overrides":{"id":"walkthrough/overrides","title":"Overrides","description":"Zedux\' Dependency Injection (DI) model is extremely dynamic. This walkthrough has taught several ways to inject atoms and create the DI graph so far. But Zedux has another DI superpower: Overrides.","sidebar":"react"},"walkthrough/query-atoms":{"id":"walkthrough/query-atoms","title":"Query Atoms","description":"\ud83d\udea7 This page is under construction","sidebar":"react"},"walkthrough/quick-start":{"id":"walkthrough/quick-start","title":"Quick Start","description":"Zedux is a powerful state management tool for React.","sidebar":"react"},"walkthrough/react-context":{"id":"walkthrough/react-context","title":"React Context","description":"The atomic model naturally fixes all the problems with React context. In Zedux, we can use React context with all of its benefits and none of its downsides.","sidebar":"react"},"walkthrough/resets":{"id":"walkthrough/resets","title":"Resets","description":"There are many situations where you may want to reset the state of one or more atoms. Zedux has several ways to accomplish state resets.","sidebar":"react"},"walkthrough/selectors":{"id":"walkthrough/selectors","title":"Selectors","description":"A crucial tool in state management is the ability to \\"derive\\" or transform data. In the React world, we call such state transformers \\"selectors\\". Zedux has a few different flavors of selectors.","sidebar":"react"},"walkthrough/side-effects":{"id":"walkthrough/side-effects","title":"Side Effects","description":"Zedux doesn\'t place any restrictions on how you manage asynchronous code. You can use promises, observables, sockets, generators, or any third-party library.","sidebar":"react"},"walkthrough/state-machines":{"id":"walkthrough/state-machines","title":"State Machines","description":"The state machine is one of the most important tools a statesmith can have in his belt. XState is the current king of the JavaScript state machine world. Zedux is not out to change that, in fact we may build an official XState Zedux integration soon.","sidebar":"react"},"walkthrough/stores":{"id":"walkthrough/stores","title":"Stores","description":"The store is the heart of Zedux. Zedux uses a unique and unprecedented composable store model. These stores are light-weight, powerful, and fast.","sidebar":"react"},"walkthrough/suspense":{"id":"walkthrough/suspense","title":"Suspense","description":"Atoms are extremely flexible when working with React suspense. We\'ve learned how to use Atom APIs to set an atom instance\'s promise. It\'s time we learned all about suspense.","sidebar":"react"},"walkthrough/the-graph":{"id":"walkthrough/the-graph","title":"The Graph","description":"As you use atoms inside an ecosystem, Zedux tracks all the dependencies you create and forms a graph that it uses to efficiently propagate state updates.","sidebar":"react"},"walkthrough/using-atoms":{"id":"walkthrough/using-atoms","title":"Using Atoms","description":"Atoms can be consumed and composed in many ways."}}}')}}]);