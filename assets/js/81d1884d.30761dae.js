"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[3249],{6229:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return u},toc:function(){return l},default:function(){return p}});var a=r(3117),n=r(102),o=(r(7294),r(3905)),s=["components"],i={id:"react-query-comparison",title:"React Query Comparison"},c=void 0,u={unversionedId:"about/react-query-comparison",id:"about/react-query-comparison",isDocsHomePage:!1,title:"React Query Comparison",description:"While Zedux doesn't (yet!) handle query fetching, refetching, or special query types, Zedux is currently patterned after React Query more than any other library (yes, more than Redux or Recoil). React Query's cache management is unparalleled. So Zedux' atomic model borrows a lot of ideas from it.",source:"@site/docs/about/react-query-comparison.mdx",sourceDirName:"about",slug:"/about/react-query-comparison",permalink:"/zedux/docs/about/react-query-comparison",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/about/react-query-comparison.mdx",tags:[],version:"current",frontMatter:{id:"react-query-comparison",title:"React Query Comparison"},sidebar:"react",previous:{title:"Redux Comparison",permalink:"/zedux/docs/about/redux-comparison"},next:{title:"Quick Start",permalink:"/zedux/docs/walkthrough/quick-start"}},l=[{value:"Queries",id:"queries",children:[],level:2},{value:"QueryClient",id:"queryclient",children:[],level:2},{value:"Stream Support",id:"stream-support",children:[],level:2}],m={toc:l};function p(e){var t=e.components,r=(0,n.Z)(e,s);return(0,o.kt)("wrapper",(0,a.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"While Zedux doesn't (yet!) handle query fetching, refetching, or special query types, Zedux is currently patterned after React Query more than any other library (yes, more than Redux or Recoil). React Query's cache management is unparalleled. So Zedux' atomic model borrows a lot of ideas from it."),(0,o.kt)("p",null,"However, the purpose of Zedux is very different from React Query. React Query is designed around promises - managing their state, side effects, and result caches. Zedux is designed to manage both application state (a la Redux/Recoil) and cached server data. Zedux isn't limited to promises."),(0,o.kt)("h2",{id:"queries"},"Queries"),(0,o.kt)("p",null,"Structurally, Zedux ",(0,o.kt)("a",{parentName:"p",href:"../api/classes/Atom"},"atoms")," are very similar to React Query ",(0,o.kt)("a",{parentName:"p",href:"https://react-query.tanstack.com/guides/queries"},"queries"),"."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"For destroying stale instances: Atoms have ",(0,o.kt)("a",{parentName:"li",href:"../api/classes/Atom#ttl"},(0,o.kt)("inlineCode",{parentName:"a"},"ttl")),". Queries have ",(0,o.kt)("inlineCode",{parentName:"li"},"cacheTime"),"."),(0,o.kt)("li",{parentName:"ul"},"For suspense: Atoms have ",(0,o.kt)("a",{parentName:"li",href:"../api/classes/AtomApi#setpromise"},(0,o.kt)("inlineCode",{parentName:"a"},".setPromise()")),". Queries have ",(0,o.kt)("inlineCode",{parentName:"li"},"suspense"),"."),(0,o.kt)("li",{parentName:"ul"},"Queries track promise state by default. Atoms have ",(0,o.kt)("a",{parentName:"li",href:"../api/injectors/injectAsyncEffect"},(0,o.kt)("inlineCode",{parentName:"a"},"injectAsyncEffect()"))," for tracking promise state.")),(0,o.kt)("h2",{id:"queryclient"},"QueryClient"),(0,o.kt)("p",null,"Zedux ",(0,o.kt)("a",{parentName:"p",href:"../api/classes/Ecosystem"},"ecosystems")," are patterned after React Query's ",(0,o.kt)("a",{parentName:"p",href:"https://react-query.tanstack.com/reference/QueryClient"},"QueryClient"),". They both create autonomous environments for managing queries or atoms that can be used outside React and are especially useful for testing."),(0,o.kt)("h2",{id:"stream-support"},"Stream Support"),(0,o.kt)("p",null,"Zedux atoms are designed to support any asynchronous architecture. This means that (for now) Zedux doesn't provide any promise-specific helpers like React Query's ",(0,o.kt)("inlineCode",{parentName:"p"},"onSuccess"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"refetchOnWindowFocus"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"retryDelay"),", etc. The upside is, atoms aren't restricted to using promises."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { atom, injectAtomValue, injectEffect, injectStore } from '@zedux/react'\nimport { io } from 'socket.io-client'\n\nconst socketAtom = atom('socket', () => io())\n\nconst messagesAtom = atom('messages', () => {\n  const socket = injectAtomValue(socketAtom)\n  const store = injectStore([])\n\n  injectEffect(() => {\n    const handler = message => {\n      store.setState(messages => [...messages, message])\n    }\n\n    socket.on('message', handler)\n\n    return () => socket.off('message', handler)\n  }, [socket])\n\n  return store\n})\n")),(0,o.kt)("p",null,"This is more flexible, but does require more boilerplate. Most functionality can be abstracted, of course. We'll probably provide a ",(0,o.kt)("inlineCode",{parentName:"p"},"@zedux/react/query")," package someday that provides a full suite of tools for handling promises."))}p.isMDXComponent=!0}}]);