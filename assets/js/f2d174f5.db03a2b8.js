"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[6784],{1946:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return m},metadata:function(){return d},toc:function(){return c},default:function(){return u}});var a=n(3117),o=n(102),i=(n(7294),n(3905)),s=n(3052),r=["components"],l={id:"quick-start",title:"Quick Start"},m=void 0,d={unversionedId:"walkthrough/quick-start",id:"walkthrough/quick-start",isDocsHomePage:!1,title:"Quick Start",description:"Zedux is a state management tool for React.",source:"@site/docs/walkthrough/quick-start.mdx",sourceDirName:"walkthrough",slug:"/walkthrough/quick-start",permalink:"/zedux/docs/walkthrough/quick-start",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/walkthrough/quick-start.mdx",tags:[],version:"current",frontMatter:{id:"quick-start",title:"Quick Start"},sidebar:"react",previous:{title:"React Query Comparison",permalink:"/zedux/docs/about/react-query-comparison"},next:{title:"Creating Atoms",permalink:"/zedux/docs/walkthrough/creating-atoms"}},c=[{value:"Installation",id:"installation",children:[],level:2},{value:"Meet the Atoms",id:"meet-the-atoms",children:[{value:"Setting State",id:"setting-state",children:[],level:3},{value:"Atom Evaluators",id:"atom-evaluators",children:[],level:3},{value:"Dependency Injection",id:"dependency-injection",children:[],level:3},{value:"Injectors Are Like Hooks",id:"injectors-are-like-hooks",children:[],level:3},{value:"Atom Instances",id:"atom-instances",children:[],level:3},{value:"Params",id:"params",children:[],level:3}],level:2},{value:"Recap",id:"recap",children:[],level:2},{value:"Next Steps",id:"next-steps",children:[],level:2}],p={toc:c};function u(e){var t=e.components,n=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Zedux is a state management tool for React."),(0,i.kt)("p",null,"Its React architecture is atomic - similar to ",(0,i.kt)("a",{parentName:"p",href:"https://recoiljs.org/"},"Recoil")," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/pmndrs/jotai"},"Jotai"),"."),(0,i.kt)("p",null,"State is held in stores - similar to ",(0,i.kt)("a",{parentName:"p",href:"https://redux.js.org/"},"Redux"),"."),(0,i.kt)("h2",{id:"installation"},"Installation"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"yarn add @zedux/react\n")),(0,i.kt)("h2",{id:"meet-the-atoms"},"Meet the Atoms"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { atom } from '@zedux/react'\n\nconst greetingAtom = atom('greeting', 'Hello, world!')\n")),(0,i.kt)("p",null,"This is an atom. We gave it a key, ",(0,i.kt)("inlineCode",{parentName:"p"},"greeting"),", and an initial value, ",(0,i.kt)("inlineCode",{parentName:"p"},"Hello, world!"),"."),(0,i.kt)("p",null,"When the atom is used, it creates a store to hold its state. We can use hooks to access and update the state of the store:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { useAtomState } from '@zedux/react'\n\nfunction Greet() {\n  const [greeting, setGreeting] = useAtomState(greetingAtom)\n  ...\n}\n")),(0,i.kt)("h3",{id:"setting-state"},"Setting State"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"useAtomState()")," is very similar to React's ",(0,i.kt)("inlineCode",{parentName:"p"},"useState()")," hook. But instead of passing the initial state, we defined it when we created the atom."),(0,i.kt)("p",null,"In our example, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"setGreeting")," to update the state of the atom:"),(0,i.kt)(s.u,{resultVar:"Greeting",mdxType:"LiveEditor"},"\nconst greetingAtom = atom('greeting', 'Hello, world!')\n\nfunction GreetingPreview() {\n  const [greeting] = useAtomState(greetingAtom)\n  \n  return <div>The greeting: {greeting}</div>\n}\n\nfunction EditGreeting() {\n  const [greeting, setGreeting] = useAtomState(greetingAtom)\n\n  return (\n    <input\n      onChange={({ target }) => setGreeting(target.value)}\n      value={greeting}\n    />\n  )\n}\n\nconst Greeting = () => (\n  <>\n    <GreetingPreview />\n    <EditGreeting />\n  </>\n)\n"),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"These live playgrounds have every React and Zedux export in scope."))),(0,i.kt)("p",null,"Notice that the ",(0,i.kt)("inlineCode",{parentName:"p"},"greetingAtom"),"'s state is shared between both components. This state reuse is one of the main features of atoms."),(0,i.kt)("h3",{id:"atom-evaluators"},"Atom Evaluators"),(0,i.kt)("p",null,"The second parameter to ",(0,i.kt)("inlineCode",{parentName:"p"},"atom")," can be a factory function. These factories are called \"evaluators\". The evaluator's job is to create and return the atom's value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const helloAtom = atom('hello', () => 'world')\n")),(0,i.kt)("p",null,"Evaluators have many use cases (and this simple example is not one of them). We'll look at a few right now."),(0,i.kt)("h3",{id:"dependency-injection"},"Dependency Injection"),(0,i.kt)("p",null,'Atoms can use other atoms. To use another atom, we "inject" it in the evaluator function:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { atom, injectAtomState } from '@zedux/react'\n\nconst textAtom = atom('text', 'World')\n\nconst loudGreetingAtom = atom('loudGreeting', () => {\n  const [text] = injectAtomState(textAtom)\n\n  return `HELLO, ${text.toUpperCase()}`\n})\n")),(0,i.kt)("p",null,'Here we used an "injector" - ',(0,i.kt)("inlineCode",{parentName:"p"},"injectAtomState")," - to create a dependency on ",(0,i.kt)("inlineCode",{parentName:"p"},"textAtom"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"injectAtomState()")," is just like ",(0,i.kt)("inlineCode",{parentName:"p"},"useAtomState()"),", but is used in atoms instead of components. This is a common theme with injectors:"),(0,i.kt)("h3",{id:"injectors-are-like-hooks"},"Injectors Are Like Hooks"),(0,i.kt)("p",null,"Writing an atom should feel like writing a React component. Zedux exports injectors like ",(0,i.kt)("inlineCode",{parentName:"p"},"injectEffect")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"injectMemo")," that behave like React's ",(0,i.kt)("inlineCode",{parentName:"p"},"useEffect")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"useMemo"),"."),(0,i.kt)("p",null,"There are many advantages to this approach:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Atoms are reactive by default. Just like React components, they reevaluate when their state updates.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Atoms have a small learning curve if you know hooks.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Injectors are composable, just like hooks. Abstracting common logic is easy 'cause it's just JavaScript."))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { atom, injectMemo } from '@zedux/react'\n\nconst initialPriceAtom = atom('initialPrice', () => {\n  // Let's say this atom's state changes frequently:\n  const [stockPrice] = injectAtomState(stockPriceAtom)\n  const initialPrice = injectMemo(() => stockPrice, [])\n\n  return initialPrice\n})\n")),(0,i.kt)("p",null,"In this example, ",(0,i.kt)("inlineCode",{parentName:"p"},"initialPriceAtom")," will be reevaluated every time ",(0,i.kt)("inlineCode",{parentName:"p"},"stockPriceAtom"),"'s state changes. But the ",(0,i.kt)("inlineCode",{parentName:"p"},"initialPrice")," it returns won't change, thanks to ",(0,i.kt)("inlineCode",{parentName:"p"},"injectMemo()"),". Therefore components and atoms that use ",(0,i.kt)("inlineCode",{parentName:"p"},"initialPriceAtom")," won't reevaluate."),(0,i.kt)("div",{className:"admonition admonition-important alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"important")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Injectors have the same caveats as hooks too! E.g. don't put injectors in if statements or use them outside atom evaluators."))),(0,i.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},'In general, the simple rule is: Replace the word "use" with "inject" inside atoms. Custom injectors you make should also start with "inject".'))),(0,i.kt)("h3",{id:"atom-instances"},"Atom Instances"),(0,i.kt)("p",null,"Let's take a step back."),(0,i.kt)("p",null,"When we pass an evaluator function to ",(0,i.kt)("inlineCode",{parentName:"p"},"atom()"),", that function doesn't run right away. Zedux waits until the atom is used by a component or another atom. When the atom is used for the first time, Zedux creates an \"atom instance\" and calls the evaluator to produce the instance's initial value."),(0,i.kt)("p",null,"You can think of atoms like classes, but you never instantiate the class yourself - Zedux does it for you."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"function Greeting() {\n  const [greeting] = useAtomState(greetingAtom)\n  ...\n}\n\nconst SomeGreetings = () => (\n  <>\n    <Greeting />\n    <Greeting />\n  </>\n)\n")),(0,i.kt)("p",null,"Here, the first ",(0,i.kt)("inlineCode",{parentName:"p"},"<Greeting />")," renders and Zedux creates an instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"greetingAtom"),". The next ",(0,i.kt)("inlineCode",{parentName:"p"},"<Greeting />")," then renders and reuses that same instance."),(0,i.kt)("p",null,"Usually this just works and you don't have to worry about it. But sometimes you'll need to create multiple instances of an atom. To make Zedux create more instances, we use params."),(0,i.kt)("h3",{id:"params"},"Params"),(0,i.kt)("p",null,"We can pass parameters to atom hooks/injectors:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// This atom accepts a single `id` param\nconst userDataAtom = atom('userData', (id: string) => {\n  // a hypothetical injector for simplicity (sends the request and tracks state):\n  return injectFetch(`/users/${id}`)\n})\n\nfunction UserOverview() {\n  const { data } = useAtomState(userDataAtom, ['joe'])\n  ...\n}\n")),(0,i.kt)("p",null,"Here ",(0,i.kt)("inlineCode",{parentName:"p"},"userDataAtom")," takes one parameter, ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),". When the ",(0,i.kt)("inlineCode",{parentName:"p"},"UserOverview")," component uses ",(0,i.kt)("inlineCode",{parentName:"p"},"userDataAtom"),", Zedux creates an instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"userDataAtom")," with ",(0,i.kt)("inlineCode",{parentName:"p"},"joe")," as the id."),(0,i.kt)("p",null,"If we use ",(0,i.kt)("inlineCode",{parentName:"p"},"userDataAtom")," multiple times with different ",(0,i.kt)("inlineCode",{parentName:"p"},"id"),"s, Zedux will create different atom instances:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"function UserOverview() {\n  const [joeData] = useAtomState(userDataAtom, ['joe'])\n  const [bobData] = useAtomState(userDataAtom, ['bob'])\n  ...\n}\n")),(0,i.kt)("p",null,"This example creates two instances of ",(0,i.kt)("inlineCode",{parentName:"p"},"userDataAtom")," - one that fetches the ",(0,i.kt)("inlineCode",{parentName:"p"},"joe")," user and one that fetches ",(0,i.kt)("inlineCode",{parentName:"p"},"bob"),". Each of these instances controls its own, distinct state."),(0,i.kt)("div",{className:"admonition admonition-important alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"important")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Atom parameters must be serializable. Zedux converts them to a single string that uniquely identifies each atom instance. You shouldn't need params much, but when you do need them, make them as small as possible."))),(0,i.kt)("h2",{id:"recap"},"Recap"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Atoms are behavior containers. They can be used in React with hooks.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},'Atoms can be injected into other atoms using "injectors".')),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Injectors are like hooks. Evaluators are like function components that return state instead of UI.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Atom instances are created by passing different params and reused by passing the same params."))),(0,i.kt)("p",null,"Let's finish off the quick start with a good old todos playground:"),(0,i.kt)(s.u,{resultVar:"Todos",mdxType:"LiveEditor"},"\nconst todosAtom = atom('todos', () => [\n  { text: 'Go', isDone: true },\n  { text: 'Fight', isDone: true },\n  { text: 'Win', isDone: false }\n])\n\nconst filteredTodosAtom = atom('filteredTodos', (isDone: boolean) => {\n  const [todos] = injectAtomState(todosAtom)\n\n  return todos\n    .filter(todo => todo.isDone === isDone)\n    .map(({ text }) => text)\n})\n\n// These 2 components pass different params to filteredTodosAtom\nfunction FinishedTodos() {\n  const [todos] = useAtomState(filteredTodosAtom, [true])\n\n  return <div>Finished Todos: {todos.join`, `}</div>\n}\n\nfunction UnfinishedTodos() {\n  const [todos] = useAtomState(filteredTodosAtom, [false])\n\n  return <div>Unfinished Todos: {todos}</div>\n}\n\nconst Todos = () => (\n  <>\n    <FinishedTodos />\n    <UnfinishedTodos />\n  </>\n)\n"),(0,i.kt)("h2",{id:"next-steps"},"Next Steps"),(0,i.kt)("p",null,"At this point you should know more than enough to use Zedux effectively. But there is a lot more to discover."),(0,i.kt)("p",null,"The rest of this walkthrough will cover every major feature, starting with the most generally useful ones. Feel free to jump around. You can also play with the ",(0,i.kt)("a",{parentName:"p",href:"/not-done"},"examples"),", skip ahead to the ",(0,i.kt)("a",{parentName:"p",href:"../api/classes/Atom"},"API Docs"),", or read some ",(0,i.kt)("a",{parentName:"p",href:"../about/introduction"},"boring stuff I wrote"),"."),(0,i.kt)("p",null,"Next, we'll cover more ways to ",(0,i.kt)("a",{parentName:"p",href:"creating-atoms"},"create atoms"),"."))}u.isMDXComponent=!0}}]);