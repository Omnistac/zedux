"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[1981],{9515:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return p},default:function(){return m}});var o=n(3117),a=n(102),s=(n(7294),n(3905)),r=["components"],i={id:"Ion",title:"Ion"},c=void 0,l={unversionedId:"api/classes/Ion",id:"api/classes/Ion",isDocsHomePage:!1,title:"Ion",description:"Extends Atom.",source:"@site/docs/api/classes/Ion.mdx",sourceDirName:"api/classes",slug:"/api/classes/Ion",permalink:"/zedux/docs/api/classes/Ion",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/classes/Ion.mdx",tags:[],version:"current",frontMatter:{id:"Ion",title:"Ion"},sidebar:"react",previous:{title:"Ecosystem",permalink:"/zedux/docs/api/classes/Ecosystem"},next:{title:"LocalAtom",permalink:"/zedux/docs/api/classes/LocalAtom"}},p=[{value:"Creation",id:"creation",children:[],level:2}],u={toc:p};function m(e){var t=e.components,n=(0,a.Z)(e,r);return(0,s.kt)("wrapper",(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Extends ",(0,s.kt)("a",{parentName:"p",href:"Atom"},"Atom"),"."),(0,s.kt)("p",null,"Ions are a specialized atom type. They excel at selector-type operations."),(0,s.kt)("p",null,"Ions extend the Atom class and provide just a little extra functionality and utility to your ",(0,s.kt)("a",{parentName:"p",href:"../glossary#evaluator"},"evaluator function"),"."),(0,s.kt)("p",null,'Unlike atoms, ions must be given an evaluator function. That\'s the whole point! We call ion evaluators "getters". Ions can also be given a "setter".'),(0,s.kt)("p",null,"An ion getter is really just an evaluator that receives a special ",(0,s.kt)("a",{parentName:"p",href:"../types/AtomGetters"},"AtomGetters object")," as its first parameter."),(0,s.kt)("p",null,"An ion setter is similar to a ",(0,s.kt)("a",{parentName:"p",href:"../types/SetStateInterceptor"},"SetStateInterceptor"),". But it receives a special ",(0,s.kt)("a",{parentName:"p",href:"../types/AtomSetters"},"AtomSetters object")," as its first parameter and the value passed to ",(0,s.kt)("a",{parentName:"p",href:"AtomInstance#setstate"},(0,s.kt)("inlineCode",{parentName:"a"},"instance.setState()"))," as its second parameter. Unlike SetStateInterceptors, ion setters do not need to return the new state."),(0,s.kt)("h2",{id:"creation"},"Creation"),(0,s.kt)("p",null,"Create ions using ",(0,s.kt)("a",{parentName:"p",href:"../factories/ion"},"the ",(0,s.kt)("inlineCode",{parentName:"a"},"ion()")," factory"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { ion } from '@zedux/react'\n\nconst selectorAtom = ion('selector', ({ get }) => get(otherAtom).someField)\nconst derivedAtom = ion('derived', ({ get }) => deriveStuff(get(otherAtom)))\n\nconst withParams = ion('withParams', ({ get }, one: string, two: number) => {\n  return `${one} ${two}`\n})\n\nconst withInjectors = ion('withInjectors', ({ get }) => {\n  // any injector can be used in the \"getter\" function.\n  const val = injectMemo(() => getExpensiveVal(), [])\n\n  return val\n})\n\nconst withSetter = ion('withSetter', getter, ({ get, set }, newValue) => {\n  set(otherAtom, newValue) // forward state setting on to another atom\n})\n")),(0,s.kt)("p",null,"Ions expose no unique properties or methods besides those exposed by ",(0,s.kt)("a",{parentName:"p",href:"Atom"},"Atom"),"."))}m.isMDXComponent=!0}}]);