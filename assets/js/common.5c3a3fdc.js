(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[8592],{3905:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Zo": function() { return /* binding */ MDXProvider; },\n/* harmony export */   "kt": function() { return /* binding */ createElement; }\n/* harmony export */ });\n/* unused harmony exports MDXContext, useMDXComponents, withMDXComponents */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7294);\n\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar isFunction = function isFunction(obj) {\n  return typeof obj === \'function\';\n};\n\nvar MDXContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext({});\nvar withMDXComponents = function withMDXComponents(Component) {\n  return function (props) {\n    var allComponents = useMDXComponents(props.components);\n    return /*#__PURE__*/React.createElement(Component, _extends({}, props, {\n      components: allComponents\n    }));\n  };\n};\nvar useMDXComponents = function useMDXComponents(components) {\n  var contextComponents = react__WEBPACK_IMPORTED_MODULE_0__.useContext(MDXContext);\n  var allComponents = contextComponents;\n\n  if (components) {\n    allComponents = isFunction(components) ? components(contextComponents) : _objectSpread2(_objectSpread2({}, contextComponents), components);\n  }\n\n  return allComponents;\n};\nvar MDXProvider = function MDXProvider(props) {\n  var allComponents = useMDXComponents(props.components);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(MDXContext.Provider, {\n    value: allComponents\n  }, props.children);\n};\n\nvar TYPE_PROP_NAME = \'mdxType\';\nvar DEFAULTS = {\n  inlineCode: \'code\',\n  wrapper: function wrapper(_ref) {\n    var children = _ref.children;\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}, children);\n  }\n};\nvar MDXCreateElement = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, ref) {\n  var propComponents = props.components,\n      mdxType = props.mdxType,\n      originalType = props.originalType,\n      parentName = props.parentName,\n      etc = _objectWithoutProperties(props, ["components", "mdxType", "originalType", "parentName"]);\n\n  var components = useMDXComponents(propComponents);\n  var type = mdxType;\n  var Component = components["".concat(parentName, ".").concat(type)] || components[type] || DEFAULTS[type] || originalType;\n\n  if (propComponents) {\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, _objectSpread2(_objectSpread2({\n      ref: ref\n    }, etc), {}, {\n      components: propComponents\n    }));\n  }\n\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, _objectSpread2({\n    ref: ref\n  }, etc));\n});\nMDXCreateElement.displayName = \'MDXCreateElement\';\nfunction createElement (type, props) {\n  var args = arguments;\n  var mdxType = props && props.mdxType;\n\n  if (typeof type === \'string\' || mdxType) {\n    var argsLength = args.length;\n    var createElementArgArray = new Array(argsLength);\n    createElementArgArray[0] = MDXCreateElement;\n    var newProps = {};\n\n    for (var key in props) {\n      if (hasOwnProperty.call(props, key)) {\n        newProps[key] = props[key];\n      }\n    }\n\n    newProps.originalType = type;\n    newProps[TYPE_PROP_NAME] = typeof type === \'string\' ? type : mdxType;\n    createElementArgArray[1] = newProps;\n\n    for (var i = 2; i < argsLength; i++) {\n      createElementArgArray[i] = args[i];\n    }\n\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(null, createElementArgArray);\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement.apply(null, args);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkwNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixnREFBbUIsR0FBRztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZDQUFnQjtBQUMxQzs7QUFFQTtBQUNBLDZHQUE2RztBQUM3Rzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnREFBbUI7QUFDekM7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnREFBbUIsQ0FBQywyQ0FBYyxJQUFJO0FBQzlEO0FBQ0E7QUFDQSxvQ0FBb0MsNkNBQWdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLGdEQUFtQjtBQUMzQztBQUNBLEtBQUssVUFBVTtBQUNmO0FBQ0EsS0FBSztBQUNMOztBQUVBLHNCQUFzQixnREFBbUI7QUFDekM7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBLFdBQVcsc0RBQXlCO0FBQ3BDOztBQUVBLFNBQVMsc0RBQXlCO0FBQ2xDOztBQUU4RiIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvQG1keC1qcy9yZWFjdC9kaXN0L2VzbS5qcz8wY2M1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgfSk7XG4gICAga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuXG4gICAgaWYgKGkgJSAyKSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG5cbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuXG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gaXNGdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG59O1xuXG52YXIgTURYQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHt9KTtcbnZhciB3aXRoTURYQ29tcG9uZW50cyA9IGZ1bmN0aW9uIHdpdGhNRFhDb21wb25lbnRzKENvbXBvbmVudCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgdmFyIGFsbENvbXBvbmVudHMgPSB1c2VNRFhDb21wb25lbnRzKHByb3BzLmNvbXBvbmVudHMpO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgY29tcG9uZW50czogYWxsQ29tcG9uZW50c1xuICAgIH0pKTtcbiAgfTtcbn07XG52YXIgdXNlTURYQ29tcG9uZW50cyA9IGZ1bmN0aW9uIHVzZU1EWENvbXBvbmVudHMoY29tcG9uZW50cykge1xuICB2YXIgY29udGV4dENvbXBvbmVudHMgPSBSZWFjdC51c2VDb250ZXh0KE1EWENvbnRleHQpO1xuICB2YXIgYWxsQ29tcG9uZW50cyA9IGNvbnRleHRDb21wb25lbnRzO1xuXG4gIGlmIChjb21wb25lbnRzKSB7XG4gICAgYWxsQ29tcG9uZW50cyA9IGlzRnVuY3Rpb24oY29tcG9uZW50cykgPyBjb21wb25lbnRzKGNvbnRleHRDb21wb25lbnRzKSA6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb250ZXh0Q29tcG9uZW50cyksIGNvbXBvbmVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGFsbENvbXBvbmVudHM7XG59O1xudmFyIE1EWFByb3ZpZGVyID0gZnVuY3Rpb24gTURYUHJvdmlkZXIocHJvcHMpIHtcbiAgdmFyIGFsbENvbXBvbmVudHMgPSB1c2VNRFhDb21wb25lbnRzKHByb3BzLmNvbXBvbmVudHMpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTURYQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBhbGxDb21wb25lbnRzXG4gIH0sIHByb3BzLmNoaWxkcmVuKTtcbn07XG5cbnZhciBUWVBFX1BST1BfTkFNRSA9ICdtZHhUeXBlJztcbnZhciBERUZBVUxUUyA9IHtcbiAgaW5saW5lQ29kZTogJ2NvZGUnLFxuICB3cmFwcGVyOiBmdW5jdGlvbiB3cmFwcGVyKF9yZWYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfcmVmLmNoaWxkcmVuO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwge30sIGNoaWxkcmVuKTtcbiAgfVxufTtcbnZhciBNRFhDcmVhdGVFbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgdmFyIHByb3BDb21wb25lbnRzID0gcHJvcHMuY29tcG9uZW50cyxcbiAgICAgIG1keFR5cGUgPSBwcm9wcy5tZHhUeXBlLFxuICAgICAgb3JpZ2luYWxUeXBlID0gcHJvcHMub3JpZ2luYWxUeXBlLFxuICAgICAgcGFyZW50TmFtZSA9IHByb3BzLnBhcmVudE5hbWUsXG4gICAgICBldGMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocHJvcHMsIFtcImNvbXBvbmVudHNcIiwgXCJtZHhUeXBlXCIsIFwib3JpZ2luYWxUeXBlXCIsIFwicGFyZW50TmFtZVwiXSk7XG5cbiAgdmFyIGNvbXBvbmVudHMgPSB1c2VNRFhDb21wb25lbnRzKHByb3BDb21wb25lbnRzKTtcbiAgdmFyIHR5cGUgPSBtZHhUeXBlO1xuICB2YXIgQ29tcG9uZW50ID0gY29tcG9uZW50c1tcIlwiLmNvbmNhdChwYXJlbnROYW1lLCBcIi5cIikuY29uY2F0KHR5cGUpXSB8fCBjb21wb25lbnRzW3R5cGVdIHx8IERFRkFVTFRTW3R5cGVdIHx8IG9yaWdpbmFsVHlwZTtcblxuICBpZiAocHJvcENvbXBvbmVudHMpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7XG4gICAgICByZWY6IHJlZlxuICAgIH0sIGV0YyksIHt9LCB7XG4gICAgICBjb21wb25lbnRzOiBwcm9wQ29tcG9uZW50c1xuICAgIH0pKTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9vYmplY3RTcHJlYWQyKHtcbiAgICByZWY6IHJlZlxuICB9LCBldGMpKTtcbn0pO1xuTURYQ3JlYXRlRWxlbWVudC5kaXNwbGF5TmFtZSA9ICdNRFhDcmVhdGVFbGVtZW50JztcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKHR5cGUsIHByb3BzKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbWR4VHlwZSA9IHByb3BzICYmIHByb3BzLm1keFR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCBtZHhUeXBlKSB7XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aDtcbiAgICB2YXIgY3JlYXRlRWxlbWVudEFyZ0FycmF5ID0gbmV3IEFycmF5KGFyZ3NMZW5ndGgpO1xuICAgIGNyZWF0ZUVsZW1lbnRBcmdBcnJheVswXSA9IE1EWENyZWF0ZUVsZW1lbnQ7XG4gICAgdmFyIG5ld1Byb3BzID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCBrZXkpKSB7XG4gICAgICAgIG5ld1Byb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5ld1Byb3BzLm9yaWdpbmFsVHlwZSA9IHR5cGU7XG4gICAgbmV3UHJvcHNbVFlQRV9QUk9QX05BTUVdID0gdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnID8gdHlwZSA6IG1keFR5cGU7XG4gICAgY3JlYXRlRWxlbWVudEFyZ0FycmF5WzFdID0gbmV3UHJvcHM7XG5cbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3NMZW5ndGg7IGkrKykge1xuICAgICAgY3JlYXRlRWxlbWVudEFyZ0FycmF5W2ldID0gYXJnc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudC5hcHBseShudWxsLCBjcmVhdGVFbGVtZW50QXJnQXJyYXkpO1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQuYXBwbHkobnVsbCwgYXJncyk7XG59XG5cbmV4cG9ydCB7IE1EWENvbnRleHQsIE1EWFByb3ZpZGVyLCBjcmVhdGVFbGVtZW50IGFzIG1keCwgdXNlTURYQ29tcG9uZW50cywgd2l0aE1EWENvbXBvbmVudHMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3905\n')},6412:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"p\": function() { return /* binding */ usePrismTheme; }\n/* harmony export */ });\n/* harmony import */ var _contexts_colorMode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2949);\n/* harmony import */ var _utils_useThemeConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6668);\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *//**\n * Returns a color-mode-dependent Prism theme: whatever the user specified in\n * the config. Falls back to `palenight`.\n */function usePrismTheme(){var _useThemeConfig=(0,_utils_useThemeConfig__WEBPACK_IMPORTED_MODULE_0__/* .useThemeConfig */ .L)(),prism=_useThemeConfig.prism;var _useColorMode=(0,_contexts_colorMode__WEBPACK_IMPORTED_MODULE_1__/* .useColorMode */ .I)(),colorMode=_useColorMode.colorMode;var lightModeTheme=prism.theme;var darkModeTheme=prism.darkTheme||lightModeTheme;var prismTheme=colorMode==='dark'?darkModeTheme:lightModeTheme;return prismTheme;}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQxMi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7OztHQVdBOzs7R0FJTSxRQUFVRSxjQUFhLEdBQzNCLG9CQUFnQkQsOEVBQWMsRUFBRSxDQUF6QkUsS0FBSyxpQkFBTEEsS0FBSyxDQUNaLGtCQUFvQkgsMEVBQVksRUFBRSxDQUEzQkksU0FBUyxlQUFUQSxTQUFTLENBQ2hCLEdBQU1DLGVBQWMsQ0FBR0YsS0FBSyxDQUFDRyxLQUFLLENBQ2xDLEdBQU1DLGNBQWEsQ0FBR0osS0FBSyxDQUFDSyxTQUFTLEVBQUlILGNBQWMsQ0FDdkQsR0FBTUksV0FBVSxDQUFHTCxTQUFTLEdBQUssTUFBTSxDQUFHRyxhQUFhLENBQUdGLGNBQWMsQ0FFeEUsTUFBT0ksV0FBVSxDQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi4vLi4vc3JjL2hvb2tzL3VzZVByaXNtVGhlbWUudHM/ZDNhNSJdLCJuYW1lcyI6WyJ1c2VDb2xvck1vZGUiLCJ1c2VUaGVtZUNvbmZpZyIsInVzZVByaXNtVGhlbWUiLCJwcmlzbSIsImNvbG9yTW9kZSIsImxpZ2h0TW9kZVRoZW1lIiwidGhlbWUiLCJkYXJrTW9kZVRoZW1lIiwiZGFya1RoZW1lIiwicHJpc21UaGVtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6412\n")},9441:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "ck": function() { return /* reexport */ Item; },\n  "De": function() { return /* reexport */ Legend; },\n  "rU": function() { return /* reexport */ Link/* default */.Z; },\n  "pv": function() { return /* reexport */ Sandbox/* Sandbox */.p; },\n  "mQ": function() { return /* binding */ Tabs; },\n  "Ts": function() { return /* binding */ Ts; },\n  "x_": function() { return /* binding */ tab1; },\n  "s2": function() { return /* binding */ tab2; }\n});\n\n// UNUSED EXPORTS: TabItem, Tsx\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nvar esm_extends = __webpack_require__(7462);\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(7294);\n// EXTERNAL MODULE: ./src/theme/CodeBlock/index.tsx + 18 modules\nvar theme_CodeBlock = __webpack_require__(9094);\n// EXTERNAL MODULE: ./node_modules/clsx/dist/clsx.m.js\nvar clsx_m = __webpack_require__(6010);\n// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/scrollUtils.js\nvar scrollUtils = __webpack_require__(2466);\n// EXTERNAL MODULE: ./node_modules/react-router/esm/react-router.js\nvar react_router = __webpack_require__(6550);\n// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/historyUtils.js\nvar historyUtils = __webpack_require__(1980);\n// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/jsUtils.js\nvar jsUtils = __webpack_require__(7392);\n// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/storageUtils.js\nvar storageUtils = __webpack_require__(12);\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/tabsUtils.js\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */// A very rough duck type, but good enough to guard against mistakes while\n// allowing customization\nfunction isTabItem(comp){return\'value\'in comp.props;}function ensureValidChildren(children){return react.Children.map(children,function(child){if(/*#__PURE__*/(0,react.isValidElement)(child)&&isTabItem(child)){return child;}// child.type.name will give non-sensical values in prod because of\n// minification, but we assume it won\'t throw in prod.\nthrow new Error("Docusaurus error: Bad <Tabs> child <"+(// @ts-expect-error: guarding against unexpected cases\ntypeof child.type===\'string\'?child.type:child.type.name)+">: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique \\"value\\" prop.");});}function extractChildrenTabValues(children){return ensureValidChildren(children).map(function(_ref){var _ref$props=_ref.props,value=_ref$props.value,label=_ref$props.label,attributes=_ref$props.attributes,isDefault=_ref$props.default;return{value:value,label:label,attributes:attributes,default:isDefault};});}function ensureNoDuplicateValue(values){var dup=(0,jsUtils/* duplicates */.l)(values,function(a,b){return a.value===b.value;});if(dup.length>0){throw new Error("Docusaurus error: Duplicate values \\""+dup.map(function(a){return a.value;}).join(\', \')+"\\" found in <Tabs>. Every value needs to be unique.");}}function useTabValues(props){var valuesProp=props.values,children=props.children;return (0,react.useMemo)(function(){var values=valuesProp!=null?valuesProp:extractChildrenTabValues(children);ensureNoDuplicateValue(values);return values;},[valuesProp,children]);}function isValidValue(_ref2){var value=_ref2.value,tabValues=_ref2.tabValues;return tabValues.some(function(a){return a.value===value;});}function getInitialStateValue(_ref3){var _tabValues$find;var defaultValue=_ref3.defaultValue,tabValues=_ref3.tabValues;if(tabValues.length===0){throw new Error(\'Docusaurus error: the <Tabs> component requires at least one <TabItem> children component\');}if(defaultValue){// Warn user about passing incorrect defaultValue as prop.\nif(!isValidValue({value:defaultValue,tabValues:tabValues})){throw new Error("Docusaurus error: The <Tabs> has a defaultValue \\""+defaultValue+"\\" but none of its children has the corresponding value. Available values are: "+tabValues.map(function(a){return a.value;}).join(\', \')+". If you intend to show no default tab, use defaultValue={null} instead.");}return defaultValue;}var defaultTabValue=(_tabValues$find=tabValues.find(function(tabValue){return tabValue.default;}))!=null?_tabValues$find:tabValues[0];if(!defaultTabValue){throw new Error(\'Unexpected error: 0 tabValues\');}return defaultTabValue.value;}function getStorageKey(groupId){if(!groupId){return null;}return"docusaurus.tab."+groupId;}function getQueryStringKey(_ref4){var _ref4$queryString=_ref4.queryString,queryString=_ref4$queryString===void 0?false:_ref4$queryString,groupId=_ref4.groupId;if(typeof queryString===\'string\'){return queryString;}if(queryString===false){return null;}if(queryString===true&&!groupId){throw new Error("Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString=\\"my-search-param\\".");}return groupId!=null?groupId:null;}function useTabQueryString(_ref5){var _ref5$queryString=_ref5.queryString,queryString=_ref5$queryString===void 0?false:_ref5$queryString,groupId=_ref5.groupId;var history=(0,react_router/* useHistory */.k6)();var key=getQueryStringKey({queryString:queryString,groupId:groupId});var value=(0,historyUtils/* useQueryStringValue */._X)(key);var setValue=(0,react.useCallback)(function(newValue){if(!key){return;// no-op\n}var searchParams=new URLSearchParams(history.location.search);searchParams.set(key,newValue);history.replace(Object.assign({},history.location,{search:searchParams.toString()}));},[key,history]);return[value,setValue];}function useTabStorage(_ref6){var groupId=_ref6.groupId;var key=getStorageKey(groupId);var _useStorageSlot=(0,storageUtils/* useStorageSlot */.Nk)(key),value=_useStorageSlot[0],storageSlot=_useStorageSlot[1];var setValue=(0,react.useCallback)(function(newValue){if(!key){return;// no-op\n}storageSlot.set(newValue);},[key,storageSlot]);return[value,setValue];}function useTabs(props){var defaultValue=props.defaultValue,_props$queryString=props.queryString,queryString=_props$queryString===void 0?false:_props$queryString,groupId=props.groupId;var tabValues=useTabValues(props);var _useState=(0,react.useState)(function(){return getInitialStateValue({defaultValue:defaultValue,tabValues:tabValues});}),selectedValue=_useState[0],setSelectedValue=_useState[1];var _useTabQueryString=useTabQueryString({queryString:queryString,groupId:groupId}),queryStringValue=_useTabQueryString[0],setQueryString=_useTabQueryString[1];var _useTabStorage=useTabStorage({groupId:groupId}),storageValue=_useTabStorage[0],setStorageValue=_useTabStorage[1];// We sync valid querystring/storage value to state on change + hydration\nvar valueToSync=function(){var value=queryStringValue!=null?queryStringValue:storageValue;if(!isValidValue({value:value,tabValues:tabValues})){return null;}return value;}();// Sync in a layout/sync effect is important, for useScrollPositionBlocker\n// See https://github.com/facebook/docusaurus/issues/8625\n(0,react.useLayoutEffect)(function(){if(valueToSync){setSelectedValue(valueToSync);}},[valueToSync]);var selectValue=(0,react.useCallback)(function(newValue){if(!isValidValue({value:newValue,tabValues:tabValues})){throw new Error("Can\'t select invalid tab value="+newValue);}setSelectedValue(newValue);setQueryString(newValue);setStorageValue(newValue);},[setQueryString,setStorageValue,tabValues]);return{selectedValue:selectedValue,selectValue:selectValue,tabValues:tabValues};}\n// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useIsBrowser.js\nvar useIsBrowser = __webpack_require__(2389);\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Tabs/styles.module.css\n// extracted by mini-css-extract-plugin\n/* harmony default export */ var styles_module = ({"tabList":"tabList__CuJ","tabItem":"tabItem_LNqP"});\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/Tabs/index.js\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */function TabList(_ref){var className=_ref.className,block=_ref.block,selectedValue=_ref.selectedValue,selectValue=_ref.selectValue,tabValues=_ref.tabValues;var tabRefs=[];var _useScrollPositionBlo=(0,scrollUtils/* useScrollPositionBlocker */.o5)(),blockElementScrollPositionUntilNextRender=_useScrollPositionBlo.blockElementScrollPositionUntilNextRender;var handleTabChange=function handleTabChange(event){var newTab=event.currentTarget;var newTabIndex=tabRefs.indexOf(newTab);var newTabValue=tabValues[newTabIndex].value;if(newTabValue!==selectedValue){blockElementScrollPositionUntilNextRender(newTab);selectValue(newTabValue);}};var handleKeydown=function handleKeydown(event){var _focusElement;var focusElement=null;switch(event.key){case\'Enter\':{handleTabChange(event);break;}case\'ArrowRight\':{var _tabRefs$nextTab;var nextTab=tabRefs.indexOf(event.currentTarget)+1;focusElement=(_tabRefs$nextTab=tabRefs[nextTab])!=null?_tabRefs$nextTab:tabRefs[0];break;}case\'ArrowLeft\':{var _tabRefs$prevTab;var prevTab=tabRefs.indexOf(event.currentTarget)-1;focusElement=(_tabRefs$prevTab=tabRefs[prevTab])!=null?_tabRefs$prevTab:tabRefs[tabRefs.length-1];break;}default:break;}(_focusElement=focusElement)==null?void 0:_focusElement.focus();};return/*#__PURE__*/react.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,clsx_m/* default */.Z)(\'tabs\',{\'tabs--block\':block},className)},tabValues.map(function(_ref2){var value=_ref2.value,label=_ref2.label,attributes=_ref2.attributes;return/*#__PURE__*/react.createElement("li",(0,esm_extends/* default */.Z)({// TODO extract TabListItem\nrole:"tab",tabIndex:selectedValue===value?0:-1,"aria-selected":selectedValue===value,key:value,ref:function ref(tabControl){return tabRefs.push(tabControl);},onKeyDown:handleKeydown,onClick:handleTabChange},attributes,{className:(0,clsx_m/* default */.Z)(\'tabs__item\',styles_module.tabItem,attributes==null?void 0:attributes.className,{\'tabs__item--active\':selectedValue===value})}),label!=null?label:value);}));}function TabContent(_ref3){var lazy=_ref3.lazy,children=_ref3.children,selectedValue=_ref3.selectedValue;// eslint-disable-next-line no-param-reassign\nchildren=Array.isArray(children)?children:[children];if(lazy){var selectedTabItem=children.find(function(tabItem){return tabItem.props.value===selectedValue;});if(!selectedTabItem){// fail-safe or fail-fast? not sure what\'s best here\nreturn null;}return/*#__PURE__*/(0,react.cloneElement)(selectedTabItem,{className:\'margin-top--md\'});}return/*#__PURE__*/react.createElement("div",{className:"margin-top--md"},children.map(function(tabItem,i){return/*#__PURE__*/(0,react.cloneElement)(tabItem,{key:i,hidden:tabItem.props.value!==selectedValue});}));}function TabsComponent(props){var tabs=useTabs(props);return/*#__PURE__*/react.createElement("div",{className:(0,clsx_m/* default */.Z)(\'tabs-container\',styles_module.tabList)},/*#__PURE__*/react.createElement(TabList,(0,esm_extends/* default */.Z)({},props,tabs)),/*#__PURE__*/react.createElement(TabContent,(0,esm_extends/* default */.Z)({},props,tabs)));}function Tabs_Tabs(props){var isBrowser=(0,useIsBrowser/* default */.Z)();return/*#__PURE__*/react.createElement(TabsComponent// Remount tabs after hydration\n// Temporary fix for https://github.com/facebook/docusaurus/issues/5653\n,(0,esm_extends/* default */.Z)({key:String(isBrowser)},props));}\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/TabItem/styles.module.css\n// extracted by mini-css-extract-plugin\n/* harmony default export */ var TabItem_styles_module = ({"tabItem":"tabItem_Ymn6"});\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/TabItem/index.js\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */function TabItem(_ref){var children=_ref.children,hidden=_ref.hidden,className=_ref.className;return/*#__PURE__*/react.createElement("div",{role:"tabpanel",className:(0,clsx_m/* default */.Z)(TabItem_styles_module.tabItem,className),hidden:hidden},children);}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteralLoose.js\nvar taggedTemplateLiteralLoose = __webpack_require__(1880);\n// EXTERNAL MODULE: ./src/ssc/index.tsx\nvar ssc = __webpack_require__(8880);\n;// CONCATENATED MODULE: ./src/components/Legend/Legend.tsx\nvar _templateObject,_templateObject2,_templateObject3;var ItemDesc=ssc/* default.div */.ZP.div(_templateObject||(_templateObject=(0,taggedTemplateLiteralLoose/* default */.Z)(["\\n  padding: 1rem;\\n"])));var ItemName=ssc/* default.div */.ZP.div(_templateObject2||(_templateObject2=(0,taggedTemplateLiteralLoose/* default */.Z)(["\\n  padding: 1rem;\\n"])));var Wrapper=ssc/* default.div */.ZP.div(_templateObject3||(_templateObject3=(0,taggedTemplateLiteralLoose/* default */.Z)(["\\n  border-radius: 5px;\\n  box-shadow: 4px 4px 8px 1px #0004;\\n  display: grid;\\n  grid-template-columns: auto minmax(0, 4fr);\\n  margin: 0 -0.8rem var(--ifm-paragraph-margin-bottom);\\n"])));var Legend=function Legend(_ref){var children=_ref.children;return/*#__PURE__*/react.createElement(Wrapper,null,children);};var prefixContext=/*#__PURE__*/(0,react.createContext)(\'\');var Item=function Item(_ref2){var children=_ref2.children,name=_ref2.name;var prefix=(0,react.useContext)(prefixContext);var id=prefix+name.toLowerCase().replace(/[^a-z]/g,\'\');return/*#__PURE__*/react.createElement(react.Fragment,null,/*#__PURE__*/react.createElement(ItemName,{className:"anchor anchorWithStickyNavbar_node_modules-@docusaurus-theme-classic-lib-theme-Heading-styles-module",id:id},name===\'Returns\'?name:/*#__PURE__*/react.createElement("code",null,name),/*#__PURE__*/react.createElement("a",{className:"hash-link",href:"#"+id})),/*#__PURE__*/react.createElement(ItemDesc,null,/*#__PURE__*/react.createElement(prefixContext.Provider,{value:id+"__"},children)));};\n// EXTERNAL MODULE: ./src/theme/CodeBlock/Sandbox.tsx + 45 modules\nvar Sandbox = __webpack_require__(6630);\n// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/Link.js + 1 modules\nvar Link = __webpack_require__(9960);\n;// CONCATENATED MODULE: ./src/all.tsx\nvar Tsx=function Tsx(props){return/*#__PURE__*/React.createElement(CodeBlock,_extends({language:"tsx"},props));};var Ts=function Ts(props){return/*#__PURE__*/react.createElement(theme_CodeBlock/* default */.Z,(0,esm_extends/* default */.Z)({language:"ts"},props));};var Tabs=function Tabs(_ref){var children=_ref.children;return/*#__PURE__*/react.createElement(Tabs_Tabs,{groupId:"definition-view"},children);};var tab1=function tab1(children){return/*#__PURE__*/react.createElement(TabItem,{label:"Simplified",value:"simplified"},/*#__PURE__*/react.createElement(Ts,null,children));};var tab2=function tab2(children){return/*#__PURE__*/react.createElement(TabItem,{label:"TypeScript",value:"typescript"},/*#__PURE__*/react.createElement(Ts,null,children));};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHLENBQUcsUUFBTkEsSUFBRyxDQUFJbEgsS0FBVSxxQkFBSyxvQkFBQyxTQUFTLFdBQUMsUUFBUSxDQUFDLEtBQUssRUFBS0EsS0FBSyxFQUFJLEdBQ25FLEdBQU1tSCxHQUFFLENBQUcsUUFBTEEsR0FBRSxDQUFJbkgsS0FBVSxxQkFBSyxvQkFBQyw4QkFBUyxpQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFLQSxLQUFLLEVBQUksR0FDakUsR0FBTThGLEtBQUksQ0FBRyxRQUFQQSxLQUFJLFVBQU01RixTQUFRLE1BQVJBLFFBQVEsb0JBQzdCLG9CQUFDLFNBQU8sRUFBQyxPQUFPLENBQUMsaUJBQWlCLEVBQUVBLFFBQVEsQ0FBVyxFQUN4RCxDQUVNLEdBQU1rSCxLQUFJLENBQUcsUUFBUEEsS0FBSSxDQUFJbEgsUUFBbUIscUJBQ3RDLG9CQUFDLE9BQU8sRUFBQyxLQUFLLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxZQUFZLGVBQzVDLG9CQUFDLEVBQUUsTUFBRUEsUUFBUSxDQUFNLENBQ1gsRUFDWCxDQUVNLEdBQU1tSCxLQUFJLENBQUcsUUFBUEEsS0FBSSxDQUFJbkgsUUFBbUIscUJBQ3RDLG9CQUFDLE9BQU8sRUFBQyxLQUFLLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxZQUFZLGVBQzVDLG9CQUFDLEVBQUUsTUFBRUEsUUFBUSxDQUFNLENBQ1gsRUFDWCIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi4vLi4vc3JjL3V0aWxzL3RhYnNVdGlscy50c3g/MjE5ZCIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL0Bkb2N1c2F1cnVzL3RoZW1lLWNsYXNzaWMvbGliL3RoZW1lL1RhYnMvc3R5bGVzLm1vZHVsZS5jc3M/ODM1YiIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL0Bkb2N1c2F1cnVzL3RoZW1lLWNsYXNzaWMvbGliL3RoZW1lL1RhYnMvaW5kZXguanM/ZmNjMiIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL0Bkb2N1c2F1cnVzL3RoZW1lLWNsYXNzaWMvbGliL3RoZW1lL1RhYkl0ZW0vc3R5bGVzLm1vZHVsZS5jc3M/MjAxZCIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL0Bkb2N1c2F1cnVzL3RoZW1lLWNsYXNzaWMvbGliL3RoZW1lL1RhYkl0ZW0vaW5kZXguanM/MjVhNCIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vc3JjL2NvbXBvbmVudHMvTGVnZW5kL0xlZ2VuZC50c3g/ZmZlYyIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vc3JjL2FsbC50c3g/MGM0NiJdLCJzb3VyY2VzQ29udGVudCI6W251bGwsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IGRlZmF1bHQge1widGFiTGlzdFwiOlwidGFiTGlzdF9fQ3VKXCIsXCJ0YWJJdGVtXCI6XCJ0YWJJdGVtX0xOcVBcIn07IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuaW1wb3J0IFJlYWN0LCB7Y2xvbmVFbGVtZW50fSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7XG4gIHVzZVNjcm9sbFBvc2l0aW9uQmxvY2tlcixcbiAgdXNlVGFicyxcbn0gZnJvbSAnQGRvY3VzYXVydXMvdGhlbWUtY29tbW9uL2ludGVybmFsJztcbmltcG9ydCB1c2VJc0Jyb3dzZXIgZnJvbSAnQGRvY3VzYXVydXMvdXNlSXNCcm93c2VyJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9zdHlsZXMubW9kdWxlLmNzcyc7XG5mdW5jdGlvbiBUYWJMaXN0KHtjbGFzc05hbWUsIGJsb2NrLCBzZWxlY3RlZFZhbHVlLCBzZWxlY3RWYWx1ZSwgdGFiVmFsdWVzfSkge1xuICBjb25zdCB0YWJSZWZzID0gW107XG4gIGNvbnN0IHtibG9ja0VsZW1lbnRTY3JvbGxQb3NpdGlvblVudGlsTmV4dFJlbmRlcn0gPVxuICAgIHVzZVNjcm9sbFBvc2l0aW9uQmxvY2tlcigpO1xuICBjb25zdCBoYW5kbGVUYWJDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBuZXdUYWIgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIGNvbnN0IG5ld1RhYkluZGV4ID0gdGFiUmVmcy5pbmRleE9mKG5ld1RhYik7XG4gICAgY29uc3QgbmV3VGFiVmFsdWUgPSB0YWJWYWx1ZXNbbmV3VGFiSW5kZXhdLnZhbHVlO1xuICAgIGlmIChuZXdUYWJWYWx1ZSAhPT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgYmxvY2tFbGVtZW50U2Nyb2xsUG9zaXRpb25VbnRpbE5leHRSZW5kZXIobmV3VGFiKTtcbiAgICAgIHNlbGVjdFZhbHVlKG5ld1RhYlZhbHVlKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGhhbmRsZUtleWRvd24gPSAoZXZlbnQpID0+IHtcbiAgICBsZXQgZm9jdXNFbGVtZW50ID0gbnVsbDtcbiAgICBzd2l0Y2ggKGV2ZW50LmtleSkge1xuICAgICAgY2FzZSAnRW50ZXInOiB7XG4gICAgICAgIGhhbmRsZVRhYkNoYW5nZShldmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSAnQXJyb3dSaWdodCc6IHtcbiAgICAgICAgY29uc3QgbmV4dFRhYiA9IHRhYlJlZnMuaW5kZXhPZihldmVudC5jdXJyZW50VGFyZ2V0KSArIDE7XG4gICAgICAgIGZvY3VzRWxlbWVudCA9IHRhYlJlZnNbbmV4dFRhYl0gPz8gdGFiUmVmc1swXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlICdBcnJvd0xlZnQnOiB7XG4gICAgICAgIGNvbnN0IHByZXZUYWIgPSB0YWJSZWZzLmluZGV4T2YoZXZlbnQuY3VycmVudFRhcmdldCkgLSAxO1xuICAgICAgICBmb2N1c0VsZW1lbnQgPSB0YWJSZWZzW3ByZXZUYWJdID8/IHRhYlJlZnNbdGFiUmVmcy5sZW5ndGggLSAxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9jdXNFbGVtZW50Py5mb2N1cygpO1xuICB9O1xuICByZXR1cm4gKFxuICAgIDx1bFxuICAgICAgcm9sZT1cInRhYmxpc3RcIlxuICAgICAgYXJpYS1vcmllbnRhdGlvbj1cImhvcml6b250YWxcIlxuICAgICAgY2xhc3NOYW1lPXtjbHN4KFxuICAgICAgICAndGFicycsXG4gICAgICAgIHtcbiAgICAgICAgICAndGFicy0tYmxvY2snOiBibG9jayxcbiAgICAgICAgfSxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgKX0+XG4gICAgICB7dGFiVmFsdWVzLm1hcCgoe3ZhbHVlLCBsYWJlbCwgYXR0cmlidXRlc30pID0+IChcbiAgICAgICAgPGxpXG4gICAgICAgICAgLy8gVE9ETyBleHRyYWN0IFRhYkxpc3RJdGVtXG4gICAgICAgICAgcm9sZT1cInRhYlwiXG4gICAgICAgICAgdGFiSW5kZXg9e3NlbGVjdGVkVmFsdWUgPT09IHZhbHVlID8gMCA6IC0xfVxuICAgICAgICAgIGFyaWEtc2VsZWN0ZWQ9e3NlbGVjdGVkVmFsdWUgPT09IHZhbHVlfVxuICAgICAgICAgIGtleT17dmFsdWV9XG4gICAgICAgICAgcmVmPXsodGFiQ29udHJvbCkgPT4gdGFiUmVmcy5wdXNoKHRhYkNvbnRyb2wpfVxuICAgICAgICAgIG9uS2V5RG93bj17aGFuZGxlS2V5ZG93bn1cbiAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVUYWJDaGFuZ2V9XG4gICAgICAgICAgey4uLmF0dHJpYnV0ZXN9XG4gICAgICAgICAgY2xhc3NOYW1lPXtjbHN4KCd0YWJzX19pdGVtJywgc3R5bGVzLnRhYkl0ZW0sIGF0dHJpYnV0ZXM/LmNsYXNzTmFtZSwge1xuICAgICAgICAgICAgJ3RhYnNfX2l0ZW0tLWFjdGl2ZSc6IHNlbGVjdGVkVmFsdWUgPT09IHZhbHVlLFxuICAgICAgICAgIH0pfT5cbiAgICAgICAgICB7bGFiZWwgPz8gdmFsdWV9XG4gICAgICAgIDwvbGk+XG4gICAgICApKX1cbiAgICA8L3VsPlxuICApO1xufVxuZnVuY3Rpb24gVGFiQ29udGVudCh7bGF6eSwgY2hpbGRyZW4sIHNlbGVjdGVkVmFsdWV9KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjaGlsZHJlbiA9IEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4gOiBbY2hpbGRyZW5dO1xuICBpZiAobGF6eSkge1xuICAgIGNvbnN0IHNlbGVjdGVkVGFiSXRlbSA9IGNoaWxkcmVuLmZpbmQoXG4gICAgICAodGFiSXRlbSkgPT4gdGFiSXRlbS5wcm9wcy52YWx1ZSA9PT0gc2VsZWN0ZWRWYWx1ZSxcbiAgICApO1xuICAgIGlmICghc2VsZWN0ZWRUYWJJdGVtKSB7XG4gICAgICAvLyBmYWlsLXNhZmUgb3IgZmFpbC1mYXN0PyBub3Qgc3VyZSB3aGF0J3MgYmVzdCBoZXJlXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lRWxlbWVudChzZWxlY3RlZFRhYkl0ZW0sIHtjbGFzc05hbWU6ICdtYXJnaW4tdG9wLS1tZCd9KTtcbiAgfVxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwibWFyZ2luLXRvcC0tbWRcIj5cbiAgICAgIHtjaGlsZHJlbi5tYXAoKHRhYkl0ZW0sIGkpID0+XG4gICAgICAgIGNsb25lRWxlbWVudCh0YWJJdGVtLCB7XG4gICAgICAgICAga2V5OiBpLFxuICAgICAgICAgIGhpZGRlbjogdGFiSXRlbS5wcm9wcy52YWx1ZSAhPT0gc2VsZWN0ZWRWYWx1ZSxcbiAgICAgICAgfSksXG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufVxuZnVuY3Rpb24gVGFic0NvbXBvbmVudChwcm9wcykge1xuICBjb25zdCB0YWJzID0gdXNlVGFicyhwcm9wcyk7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9e2Nsc3goJ3RhYnMtY29udGFpbmVyJywgc3R5bGVzLnRhYkxpc3QpfT5cbiAgICAgIDxUYWJMaXN0IHsuLi5wcm9wc30gey4uLnRhYnN9IC8+XG4gICAgICA8VGFiQ29udGVudCB7Li4ucHJvcHN9IHsuLi50YWJzfSAvPlxuICAgIDwvZGl2PlxuICApO1xufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVGFicyhwcm9wcykge1xuICBjb25zdCBpc0Jyb3dzZXIgPSB1c2VJc0Jyb3dzZXIoKTtcbiAgcmV0dXJuIChcbiAgICA8VGFic0NvbXBvbmVudFxuICAgICAgLy8gUmVtb3VudCB0YWJzIGFmdGVyIGh5ZHJhdGlvblxuICAgICAgLy8gVGVtcG9yYXJ5IGZpeCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2RvY3VzYXVydXMvaXNzdWVzLzU2NTNcbiAgICAgIGtleT17U3RyaW5nKGlzQnJvd3Nlcil9XG4gICAgICB7Li4ucHJvcHN9XG4gICAgLz5cbiAgKTtcbn1cbiIsIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IGRlZmF1bHQge1widGFiSXRlbVwiOlwidGFiSXRlbV9ZbW42XCJ9OyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9zdHlsZXMubW9kdWxlLmNzcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUYWJJdGVtKHtjaGlsZHJlbiwgaGlkZGVuLCBjbGFzc05hbWV9KSB7XG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgcm9sZT1cInRhYnBhbmVsXCJcbiAgICAgIGNsYXNzTmFtZT17Y2xzeChzdHlsZXMudGFiSXRlbSwgY2xhc3NOYW1lKX1cbiAgICAgIHsuLi57aGlkZGVufX0+XG4gICAgICB7Y2hpbGRyZW59XG4gICAgPC9kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgUHJvcHNXaXRoQ2hpbGRyZW4sIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBzdHlsZWQgZnJvbSAnQHNpdGUvc3JjL3NzYydcblxuY29uc3QgSXRlbURlc2MgPSBzdHlsZWQuZGl2YFxuICBwYWRkaW5nOiAxcmVtO1xuYFxuXG5jb25zdCBJdGVtTmFtZSA9IHN0eWxlZC5kaXZgXG4gIHBhZGRpbmc6IDFyZW07XG5gXG5cbmNvbnN0IFdyYXBwZXIgPSBzdHlsZWQuZGl2YFxuICBib3JkZXItcmFkaXVzOiA1cHg7XG4gIGJveC1zaGFkb3c6IDRweCA0cHggOHB4IDFweCAjMDAwNDtcbiAgZGlzcGxheTogZ3JpZDtcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBhdXRvIG1pbm1heCgwLCA0ZnIpO1xuICBtYXJnaW46IDAgLTAuOHJlbSB2YXIoLS1pZm0tcGFyYWdyYXBoLW1hcmdpbi1ib3R0b20pO1xuYFxuXG5leHBvcnQgY29uc3QgTGVnZW5kID0gKHsgY2hpbGRyZW4gfTogUHJvcHNXaXRoQ2hpbGRyZW4pID0+IHtcbiAgcmV0dXJuIDxXcmFwcGVyPntjaGlsZHJlbn08L1dyYXBwZXI+XG59XG5cbmNvbnN0IHByZWZpeENvbnRleHQgPSBjcmVhdGVDb250ZXh0KCcnKVxuXG5leHBvcnQgY29uc3QgSXRlbSA9ICh7XG4gIGNoaWxkcmVuLFxuICBuYW1lLFxufTogUHJvcHNXaXRoQ2hpbGRyZW48eyBuYW1lOiBzdHJpbmcgfT4pID0+IHtcbiAgY29uc3QgcHJlZml4ID0gdXNlQ29udGV4dChwcmVmaXhDb250ZXh0KVxuICBjb25zdCBpZCA9IHByZWZpeCArIG5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXmEtel0vZywgJycpXG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPEl0ZW1OYW1lXG4gICAgICAgIGNsYXNzTmFtZT1cImFuY2hvciBhbmNob3JXaXRoU3RpY2t5TmF2YmFyX25vZGVfbW9kdWxlcy1AZG9jdXNhdXJ1cy10aGVtZS1jbGFzc2ljLWxpYi10aGVtZS1IZWFkaW5nLXN0eWxlcy1tb2R1bGVcIlxuICAgICAgICBpZD17aWR9XG4gICAgICA+XG4gICAgICAgIHtuYW1lID09PSAnUmV0dXJucycgPyBuYW1lIDogPGNvZGU+e25hbWV9PC9jb2RlPn1cbiAgICAgICAgPGEgY2xhc3NOYW1lPVwiaGFzaC1saW5rXCIgaHJlZj17YCMke2lkfWB9IC8+XG4gICAgICA8L0l0ZW1OYW1lPlxuICAgICAgPEl0ZW1EZXNjPlxuICAgICAgICA8cHJlZml4Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17YCR7aWR9X19gfT5cbiAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvcHJlZml4Q29udGV4dC5Qcm92aWRlcj5cbiAgICAgIDwvSXRlbURlc2M+XG4gICAgPC8+XG4gIClcbn1cbiIsImltcG9ydCBSZWFjdCwgeyBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBDb2RlQmxvY2sgZnJvbSAnQHRoZW1lL0NvZGVCbG9jaydcbmltcG9ydCBSYXdUYWJzIGZyb20gJ0B0aGVtZS9UYWJzJ1xuaW1wb3J0IFRhYkl0ZW0gZnJvbSAnQHRoZW1lL1RhYkl0ZW0nXG5cbmV4cG9ydCB7IFRhYkl0ZW0gfVxuXG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMvTGVnZW5kL0xlZ2VuZCdcbmV4cG9ydCAqIGZyb20gJy4vdGhlbWUvQ29kZUJsb2NrL1NhbmRib3gnXG5leHBvcnQgeyBkZWZhdWx0IGFzIExpbmsgfSBmcm9tICdAZG9jdXNhdXJ1cy9MaW5rJ1xuXG5leHBvcnQgY29uc3QgVHN4ID0gKHByb3BzOiBhbnkpID0+IDxDb2RlQmxvY2sgbGFuZ3VhZ2U9XCJ0c3hcIiB7Li4ucHJvcHN9IC8+XG5leHBvcnQgY29uc3QgVHMgPSAocHJvcHM6IGFueSkgPT4gPENvZGVCbG9jayBsYW5ndWFnZT1cInRzXCIgey4uLnByb3BzfSAvPlxuZXhwb3J0IGNvbnN0IFRhYnMgPSAoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdEVsZW1lbnRbXSB9KSA9PiAoXG4gIDxSYXdUYWJzIGdyb3VwSWQ9XCJkZWZpbml0aW9uLXZpZXdcIj57Y2hpbGRyZW59PC9SYXdUYWJzPlxuKVxuXG5leHBvcnQgY29uc3QgdGFiMSA9IChjaGlsZHJlbjogUmVhY3ROb2RlKSA9PiAoXG4gIDxUYWJJdGVtIGxhYmVsPVwiU2ltcGxpZmllZFwiIHZhbHVlPVwic2ltcGxpZmllZFwiPlxuICAgIDxUcz57Y2hpbGRyZW59PC9Ucz5cbiAgPC9UYWJJdGVtPlxuKVxuXG5leHBvcnQgY29uc3QgdGFiMiA9IChjaGlsZHJlbjogUmVhY3ROb2RlKSA9PiAoXG4gIDxUYWJJdGVtIGxhYmVsPVwiVHlwZVNjcmlwdFwiIHZhbHVlPVwidHlwZXNjcmlwdFwiPlxuICAgIDxUcz57Y2hpbGRyZW59PC9Ucz5cbiAgPC9UYWJJdGVtPlxuKVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiaXNWYWxpZEVsZW1lbnQiLCJ1c2VDYWxsYmFjayIsInVzZVN0YXRlIiwidXNlTWVtbyIsInVzZUxheW91dEVmZmVjdCIsInVzZUhpc3RvcnkiLCJ1c2VRdWVyeVN0cmluZ1ZhbHVlIiwiZHVwbGljYXRlcyIsInVzZVN0b3JhZ2VTbG90IiwiaXNUYWJJdGVtIiwiY29tcCIsInByb3BzIiwiZW5zdXJlVmFsaWRDaGlsZHJlbiIsImNoaWxkcmVuIiwiQ2hpbGRyZW4iLCJtYXAiLCJjaGlsZCIsIkVycm9yIiwidHlwZSIsIm5hbWUiLCJleHRyYWN0Q2hpbGRyZW5UYWJWYWx1ZXMiLCJ2YWx1ZSIsImxhYmVsIiwiYXR0cmlidXRlcyIsImlzRGVmYXVsdCIsImRlZmF1bHQiLCJlbnN1cmVOb0R1cGxpY2F0ZVZhbHVlIiwidmFsdWVzIiwiZHVwIiwiYSIsImIiLCJsZW5ndGgiLCJqb2luIiwidXNlVGFiVmFsdWVzIiwidmFsdWVzUHJvcCIsImlzVmFsaWRWYWx1ZSIsInRhYlZhbHVlcyIsInNvbWUiLCJnZXRJbml0aWFsU3RhdGVWYWx1ZSIsImRlZmF1bHRWYWx1ZSIsImRlZmF1bHRUYWJWYWx1ZSIsImZpbmQiLCJ0YWJWYWx1ZSIsImdldFN0b3JhZ2VLZXkiLCJncm91cElkIiwiZ2V0UXVlcnlTdHJpbmdLZXkiLCJxdWVyeVN0cmluZyIsInVzZVRhYlF1ZXJ5U3RyaW5nIiwiaGlzdG9yeSIsImtleSIsInNldFZhbHVlIiwibmV3VmFsdWUiLCJzZWFyY2hQYXJhbXMiLCJVUkxTZWFyY2hQYXJhbXMiLCJsb2NhdGlvbiIsInNlYXJjaCIsInNldCIsInJlcGxhY2UiLCJ0b1N0cmluZyIsInVzZVRhYlN0b3JhZ2UiLCJzdG9yYWdlU2xvdCIsInVzZVRhYnMiLCJzZWxlY3RlZFZhbHVlIiwic2V0U2VsZWN0ZWRWYWx1ZSIsInF1ZXJ5U3RyaW5nVmFsdWUiLCJzZXRRdWVyeVN0cmluZyIsInN0b3JhZ2VWYWx1ZSIsInNldFN0b3JhZ2VWYWx1ZSIsInZhbHVlVG9TeW5jIiwic2VsZWN0VmFsdWUiLCJjbG9uZUVsZW1lbnQiLCJjbHN4IiwidXNlU2Nyb2xsUG9zaXRpb25CbG9ja2VyIiwidXNlSXNCcm93c2VyIiwic3R5bGVzIiwiVGFiTGlzdCIsImNsYXNzTmFtZSIsImJsb2NrIiwidGFiUmVmcyIsImJsb2NrRWxlbWVudFNjcm9sbFBvc2l0aW9uVW50aWxOZXh0UmVuZGVyIiwiaGFuZGxlVGFiQ2hhbmdlIiwiZXZlbnQiLCJuZXdUYWIiLCJjdXJyZW50VGFyZ2V0IiwibmV3VGFiSW5kZXgiLCJpbmRleE9mIiwibmV3VGFiVmFsdWUiLCJoYW5kbGVLZXlkb3duIiwiZm9jdXNFbGVtZW50IiwibmV4dFRhYiIsInByZXZUYWIiLCJmb2N1cyIsInRhYkNvbnRyb2wiLCJwdXNoIiwidGFiSXRlbSIsIlRhYkNvbnRlbnQiLCJsYXp5IiwiQXJyYXkiLCJpc0FycmF5Iiwic2VsZWN0ZWRUYWJJdGVtIiwiaSIsImhpZGRlbiIsIlRhYnNDb21wb25lbnQiLCJ0YWJzIiwidGFiTGlzdCIsIlRhYnMiLCJpc0Jyb3dzZXIiLCJTdHJpbmciLCJUYWJJdGVtIiwiY3JlYXRlQ29udGV4dCIsInVzZUNvbnRleHQiLCJzdHlsZWQiLCJJdGVtRGVzYyIsImRpdiIsIkl0ZW1OYW1lIiwiV3JhcHBlciIsIkxlZ2VuZCIsInByZWZpeENvbnRleHQiLCJJdGVtIiwicHJlZml4IiwiaWQiLCJ0b0xvd2VyQ2FzZSIsIkNvZGVCbG9jayIsIlJhd1RhYnMiLCJMaW5rIiwiVHN4IiwiVHMiLCJ0YWIxIiwidGFiMiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9441\n')},6630:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"p\": function() { return /* binding */ Sandbox; }\n});\n\n// NAMESPACE OBJECT: ../packages/immer/src/index.ts\nvar src_namespaceObject = {};\n__webpack_require__.r(src_namespaceObject);\n__webpack_require__.d(src_namespaceObject, {\n  \"ImmerStore\": function() { return ImmerStore; },\n  \"createImmerStore\": function() { return createImmerStore; },\n  \"injectImmerStore\": function() { return injectImmerStore; }\n});\n\n// NAMESPACE OBJECT: ../packages/react/src/index.ts\nvar react_src_namespaceObject = {};\n__webpack_require__.r(react_src_namespaceObject);\n__webpack_require__.d(react_src_namespaceObject, {\n  \"Atom\": function() { return Atom/* Atom */.h; },\n  \"AtomApi\": function() { return AtomApi/* AtomApi */.u; },\n  \"AtomBase\": function() { return AtomBase/* AtomBase */.H; },\n  \"AtomInstance\": function() { return AtomInstance/* AtomInstance */.p; },\n  \"AtomInstanceBase\": function() { return AtomInstanceBase/* AtomInstanceBase */.T; },\n  \"AtomInstanceProvider\": function() { return AtomInstanceProvider; },\n  \"Ecosystem\": function() { return Ecosystem/* Ecosystem */.q; },\n  \"EcosystemProvider\": function() { return EcosystemProvider; },\n  \"Ion\": function() { return Ion; },\n  \"MachineStore\": function() { return MachineStore; },\n  \"Store\": function() { return createStore/* Store */.y; },\n  \"ZeduxPlugin\": function() { return ZeduxPlugin; },\n  \"actionFactory\": function() { return actionFactory/* actionFactory */.B; },\n  \"addMeta\": function() { return meta/* addMeta */.k; },\n  \"api\": function() { return api/* api */.h; },\n  \"atom\": function() { return atom/* atom */.c; },\n  \"createEcosystem\": function() { return createEcosystem/* createEcosystem */.q; },\n  \"createInjector\": function() { return createInjector/* createInjector */.v; },\n  \"createReducer\": function() { return createReducer; },\n  \"createStore\": function() { return createStore/* createStore */.M; },\n  \"getEcosystem\": function() { return store/* getEcosystem */.$$; },\n  \"getMetaData\": function() { return meta/* getMetaData */.g2; },\n  \"hasMeta\": function() { return meta/* hasMeta */.yF; },\n  \"injectAtomGetters\": function() { return injectAtomGetters; },\n  \"injectAtomInstance\": function() { return injectAtomInstance; },\n  \"injectAtomSelector\": function() { return injectAtomSelector; },\n  \"injectAtomState\": function() { return injectAtomState; },\n  \"injectAtomValue\": function() { return injectAtomValue; },\n  \"injectCallback\": function() { return injectCallback; },\n  \"injectEffect\": function() { return injectEffect/* injectEffect */.o; },\n  \"injectInvalidate\": function() { return injectInvalidate; },\n  \"injectMachineStore\": function() { return injectMachineStore; },\n  \"injectMemo\": function() { return injectMemo; },\n  \"injectPromise\": function() { return injectPromise; },\n  \"injectRef\": function() { return injectRef/* injectRef */.i; },\n  \"injectStore\": function() { return injectStore/* injectStore */.F; },\n  \"injectWhy\": function() { return injectWhy; },\n  \"internalStore\": function() { return store/* internalStore */.Do; },\n  \"internalTypes\": function() { return constants/* internalTypes */.P; },\n  \"ion\": function() { return ion; },\n  \"is\": function() { return is.is; },\n  \"removeAllMeta\": function() { return meta/* removeAllMeta */.vU; },\n  \"removeMeta\": function() { return meta/* removeMeta */.hM; },\n  \"setInternalStore\": function() { return store/* setInternalStore */.LW; },\n  \"useAtomConsumer\": function() { return useAtomConsumer; },\n  \"useAtomInstance\": function() { return useAtomInstance/* useAtomInstance */.Q; },\n  \"useAtomSelector\": function() { return useAtomSelector; },\n  \"useAtomState\": function() { return useAtomState; },\n  \"useAtomValue\": function() { return useAtomValue; },\n  \"useEcosystem\": function() { return useEcosystem/* useEcosystem */.l; },\n  \"wipe\": function() { return store/* wipe */.Ej; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nvar esm_extends = __webpack_require__(7462);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\nvar inheritsLoose = __webpack_require__(4578);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/construct.js + 1 modules\nvar construct = __webpack_require__(8852);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelperLoose.js + 2 modules\nvar createForOfIteratorHelperLoose = __webpack_require__(7855);\n// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/hooks/usePrismTheme.js\nvar usePrismTheme = __webpack_require__(6412);\n// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useDocusaurusContext.js\nvar useDocusaurusContext = __webpack_require__(2263);\n// EXTERNAL MODULE: ./node_modules/prismjs/prism.js\nvar prism = __webpack_require__(5660);\nvar prism_default = /*#__PURE__*/__webpack_require__.n(prism);\n// EXTERNAL MODULE: ./node_modules/prismjs/components/prism-jsx.js\nvar prism_jsx = __webpack_require__(2356);\n// EXTERNAL MODULE: ./node_modules/prismjs/components/prism-typescript.js\nvar prism_typescript = __webpack_require__(6836);\n// EXTERNAL MODULE: ./node_modules/prismjs/components/prism-tsx.js\nvar prism_tsx = __webpack_require__(1029);\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(7294);\n;// CONCATENATED MODULE: ./node_modules/is-plain-object/dist/is-plain-object.mjs\n/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nfunction isObject(o) {\n  return Object.prototype.toString.call(o) === '[object Object]';\n}\n\nfunction isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (ctor === undefined) return true;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/immer/dist/immer.esm.mjs\nfunction n(n){for(var r=arguments.length,t=Array(r>1?r-1:0),e=1;e<r;e++)t[e-1]=arguments[e];if(false){ var i, o; }throw Error(\"[Immer] minified error nr: \"+n+(t.length?\" \"+t.map((function(n){return\"'\"+n+\"'\"})).join(\",\"):\"\")+\". Find the full error at: https://bit.ly/3cXEKWf\")}function r(n){return!!n&&!!n[Q]}function t(n){var r;return!!n&&(function(n){if(!n||\"object\"!=typeof n)return!1;var r=Object.getPrototypeOf(n);if(null===r)return!0;var t=Object.hasOwnProperty.call(r,\"constructor\")&&r.constructor;return t===Object||\"function\"==typeof t&&Function.toString.call(t)===Z}(n)||Array.isArray(n)||!!n[L]||!!(null===(r=n.constructor)||void 0===r?void 0:r[L])||s(n)||v(n))}function e(t){return r(t)||n(23,t),t[Q].t}function i(n,r,t){void 0===t&&(t=!1),0===o(n)?(t?Object.keys:nn)(n).forEach((function(e){t&&\"symbol\"==typeof e||r(e,n[e],n)})):n.forEach((function(t,e){return r(e,t,n)}))}function o(n){var r=n[Q];return r?r.i>3?r.i-4:r.i:Array.isArray(n)?1:s(n)?2:v(n)?3:0}function u(n,r){return 2===o(n)?n.has(r):Object.prototype.hasOwnProperty.call(n,r)}function a(n,r){return 2===o(n)?n.get(r):n[r]}function f(n,r,t){var e=o(n);2===e?n.set(r,t):3===e?(n.delete(r),n.add(t)):n[r]=t}function c(n,r){return n===r?0!==n||1/n==1/r:n!=n&&r!=r}function s(n){return X&&n instanceof Map}function v(n){return q&&n instanceof Set}function p(n){return n.o||n.t}function l(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var r=rn(n);delete r[Q];for(var t=nn(r),e=0;e<t.length;e++){var i=t[e],o=r[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(r[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),r)}function d(n,e){return void 0===e&&(e=!1),y(n)||r(n)||!t(n)?n:(o(n)>1&&(n.set=n.add=n.clear=n.delete=h),Object.freeze(n),e&&i(n,(function(n,r){return d(r,!0)}),!0),n)}function h(){n(2)}function y(n){return null==n||\"object\"!=typeof n||Object.isFrozen(n)}function b(r){var t=tn[r];return t||n(18,r),t}function m(n,r){tn[n]||(tn[n]=r)}function _(){return true||0,U}function j(n,r){r&&(b(\"Patches\"),n.u=[],n.s=[],n.v=r)}function O(n){g(n),n.p.forEach(S),n.p=null}function g(n){n===U&&(U=n.l)}function w(n){return U={p:[],l:U,h:n,m:!0,_:0}}function S(n){var r=n[Q];0===r.i||1===r.i?r.j():r.O=!0}function P(r,e){e._=e.p.length;var i=e.p[0],o=void 0!==r&&r!==i;return e.h.g||b(\"ES5\").S(e,r,o),o?(i[Q].P&&(O(e),n(4)),t(r)&&(r=M(e,r),e.l||x(e,r)),e.u&&b(\"Patches\").M(i[Q].t,r,e.u,e.s)):r=M(e,i,[]),O(e),e.u&&e.v(e.u,e.s),r!==H?r:void 0}function M(n,r,t){if(y(r))return r;var e=r[Q];if(!e)return i(r,(function(i,o){return A(n,e,r,i,o,t)}),!0),r;if(e.A!==n)return r;if(!e.P)return x(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=l(e.k):e.o;i(3===e.i?new Set(o):o,(function(r,i){return A(n,e,o,r,i,t)})),x(n,o,!1),t&&n.u&&b(\"Patches\").R(e,t,n.u,n.s)}return e.o}function A(e,i,o,a,c,s){if( false&&0,r(c)){var v=M(e,c,s&&i&&3!==i.i&&!u(i.D,a)?s.concat(a):void 0);if(f(o,a,v),!r(v))return;e.m=!1}if(t(c)&&!y(c)){if(!e.h.F&&e._<1)return;M(e,c),i&&i.A.l||x(e,c)}}function x(n,r,t){void 0===t&&(t=!1),n.h.F&&n.m&&d(r,t)}function z(n,r){var t=n[Q];return(t?p(t):n)[r]}function I(n,r){if(r in n)for(var t=Object.getPrototypeOf(n);t;){var e=Object.getOwnPropertyDescriptor(t,r);if(e)return e;t=Object.getPrototypeOf(t)}}function k(n){n.P||(n.P=!0,n.l&&k(n.l))}function E(n){n.o||(n.o=l(n.t))}function R(n,r,t){var e=s(r)?b(\"MapSet\").N(r,t):v(r)?b(\"MapSet\").T(r,t):n.g?function(n,r){var t=Array.isArray(n),e={i:t?1:0,A:r?r.A:_(),P:!1,I:!1,D:{},l:r,t:n,k:null,o:null,j:null,C:!1},i=e,o=en;t&&(i=[e],o=on);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(r,t):b(\"ES5\").J(r,t);return(t?t.A:_()).p.push(e),e}function D(e){return r(e)||n(22,e),function n(r){if(!t(r))return r;var e,u=r[Q],c=o(r);if(u){if(!u.P&&(u.i<4||!b(\"ES5\").K(u)))return u.t;u.I=!0,e=F(r,c),u.I=!1}else e=F(r,c);return i(e,(function(r,t){u&&a(u.t,r)===t||f(e,r,n(t))})),3===c?new Set(e):e}(e)}function F(n,r){switch(r){case 2:return new Map(n);case 3:return Array.from(n)}return l(n)}function N(){function t(n,r){var t=s[n];return t?t.enumerable=r:s[n]=t={configurable:!0,enumerable:r,get:function(){var r=this[Q];return false&&0,en.get(r,n)},set:function(r){var t=this[Q]; false&&0,en.set(t,n,r)}},t}function e(n){for(var r=n.length-1;r>=0;r--){var t=n[r][Q];if(!t.P)switch(t.i){case 5:a(t)&&k(t);break;case 4:o(t)&&k(t)}}}function o(n){for(var r=n.t,t=n.k,e=nn(t),i=e.length-1;i>=0;i--){var o=e[i];if(o!==Q){var a=r[o];if(void 0===a&&!u(r,o))return!0;var f=t[o],s=f&&f[Q];if(s?s.t!==a:!c(f,a))return!0}}var v=!!r[Q];return e.length!==nn(r).length+(v?0:1)}function a(n){var r=n.k;if(r.length!==n.t.length)return!0;var t=Object.getOwnPropertyDescriptor(r,r.length-1);if(t&&!t.get)return!0;for(var e=0;e<r.length;e++)if(!r.hasOwnProperty(e))return!0;return!1}function f(r){r.O&&n(3,JSON.stringify(p(r)))}var s={};m(\"ES5\",{J:function(n,r){var e=Array.isArray(n),i=function(n,r){if(n){for(var e=Array(r.length),i=0;i<r.length;i++)Object.defineProperty(e,\"\"+i,t(i,!0));return e}var o=rn(r);delete o[Q];for(var u=nn(o),a=0;a<u.length;a++){var f=u[a];o[f]=t(f,n||!!o[f].enumerable)}return Object.create(Object.getPrototypeOf(r),o)}(e,n),o={i:e?5:4,A:r?r.A:_(),P:!1,I:!1,D:{},l:r,t:n,k:i,o:null,O:!1,C:!1};return Object.defineProperty(i,Q,{value:o,writable:!0}),i},S:function(n,t,o){o?r(t)&&t[Q].A===n&&e(n.p):(n.u&&function n(r){if(r&&\"object\"==typeof r){var t=r[Q];if(t){var e=t.t,o=t.k,f=t.D,c=t.i;if(4===c)i(o,(function(r){r!==Q&&(void 0!==e[r]||u(e,r)?f[r]||n(o[r]):(f[r]=!0,k(t)))})),i(e,(function(n){void 0!==o[n]||u(o,n)||(f[n]=!1,k(t))}));else if(5===c){if(a(t)&&(k(t),f.length=!0),o.length<e.length)for(var s=o.length;s<e.length;s++)f[s]=!1;else for(var v=e.length;v<o.length;v++)f[v]=!0;for(var p=Math.min(o.length,e.length),l=0;l<p;l++)o.hasOwnProperty(l)||(f[l]=!0),void 0===f[l]&&n(o[l])}}}}(n.p[0]),e(n.p))},K:function(n){return 4===n.i?o(n):a(n)}})}function T(){function e(n){if(!t(n))return n;if(Array.isArray(n))return n.map(e);if(s(n))return new Map(Array.from(n.entries()).map((function(n){return[n[0],e(n[1])]})));if(v(n))return new Set(Array.from(n).map(e));var r=Object.create(Object.getPrototypeOf(n));for(var i in n)r[i]=e(n[i]);return u(n,L)&&(r[L]=n[L]),r}function f(n){return r(n)?e(n):n}var c=\"add\";m(\"Patches\",{$:function(r,t){return t.forEach((function(t){for(var i=t.path,u=t.op,f=r,s=0;s<i.length-1;s++){var v=o(f),p=\"\"+i[s];0!==v&&1!==v||\"__proto__\"!==p&&\"constructor\"!==p||n(24),\"function\"==typeof f&&\"prototype\"===p&&n(24),\"object\"!=typeof(f=a(f,p))&&n(15,i.join(\"/\"))}var l=o(f),d=e(t.value),h=i[i.length-1];switch(u){case\"replace\":switch(l){case 2:return f.set(h,d);case 3:n(16);default:return f[h]=d}case c:switch(l){case 1:return\"-\"===h?f.push(d):f.splice(h,0,d);case 2:return f.set(h,d);case 3:return f.add(d);default:return f[h]=d}case\"remove\":switch(l){case 1:return f.splice(h,1);case 2:return f.delete(h);case 3:return f.delete(t.value);default:return delete f[h]}default:n(17,u)}})),r},R:function(n,r,t,e){switch(n.i){case 0:case 4:case 2:return function(n,r,t,e){var o=n.t,s=n.o;i(n.D,(function(n,i){var v=a(o,n),p=a(s,n),l=i?u(o,n)?\"replace\":c:\"remove\";if(v!==p||\"replace\"!==l){var d=r.concat(n);t.push(\"remove\"===l?{op:l,path:d}:{op:l,path:d,value:p}),e.push(l===c?{op:\"remove\",path:d}:\"remove\"===l?{op:c,path:d,value:f(v)}:{op:\"replace\",path:d,value:f(v)})}}))}(n,r,t,e);case 5:case 1:return function(n,r,t,e){var i=n.t,o=n.D,u=n.o;if(u.length<i.length){var a=[u,i];i=a[0],u=a[1];var s=[e,t];t=s[0],e=s[1]}for(var v=0;v<i.length;v++)if(o[v]&&u[v]!==i[v]){var p=r.concat([v]);t.push({op:\"replace\",path:p,value:f(u[v])}),e.push({op:\"replace\",path:p,value:f(i[v])})}for(var l=i.length;l<u.length;l++){var d=r.concat([l]);t.push({op:c,path:d,value:f(u[l])})}i.length<u.length&&e.push({op:\"replace\",path:r.concat([\"length\"]),value:i.length})}(n,r,t,e);case 3:return function(n,r,t,e){var i=n.t,o=n.o,u=0;i.forEach((function(n){if(!o.has(n)){var i=r.concat([u]);t.push({op:\"remove\",path:i,value:n}),e.unshift({op:c,path:i,value:n})}u++})),u=0,o.forEach((function(n){if(!i.has(n)){var o=r.concat([u]);t.push({op:c,path:o,value:n}),e.unshift({op:\"remove\",path:o,value:n})}u++}))}(n,r,t,e)}},M:function(n,r,t,e){t.push({op:\"replace\",path:[],value:r===H?void 0:r}),e.push({op:\"replace\",path:[],value:n})}})}function C(){function r(n,r){function t(){this.constructor=n}a(n,r),n.prototype=(t.prototype=r.prototype,new t)}function e(n){n.o||(n.D=new Map,n.o=new Map(n.t))}function o(n){n.o||(n.o=new Set,n.t.forEach((function(r){if(t(r)){var e=R(n.A.h,r,n);n.p.set(r,e),n.o.add(e)}else n.o.add(r)})))}function u(r){r.O&&n(3,JSON.stringify(p(r)))}var a=function(n,r){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var t in r)r.hasOwnProperty(t)&&(n[t]=r[t])})(n,r)},f=function(){function n(n,r){return this[Q]={i:2,l:r,A:r?r.A:_(),P:!1,I:!1,o:void 0,D:void 0,t:n,k:this,C:!1,O:!1},this}r(n,Map);var o=n.prototype;return Object.defineProperty(o,\"size\",{get:function(){return p(this[Q]).size}}),o.has=function(n){return p(this[Q]).has(n)},o.set=function(n,r){var t=this[Q];return u(t),p(t).has(n)&&p(t).get(n)===r||(e(t),k(t),t.D.set(n,!0),t.o.set(n,r),t.D.set(n,!0)),this},o.delete=function(n){if(!this.has(n))return!1;var r=this[Q];return u(r),e(r),k(r),r.t.has(n)?r.D.set(n,!1):r.D.delete(n),r.o.delete(n),!0},o.clear=function(){var n=this[Q];u(n),p(n).size&&(e(n),k(n),n.D=new Map,i(n.t,(function(r){n.D.set(r,!1)})),n.o.clear())},o.forEach=function(n,r){var t=this;p(this[Q]).forEach((function(e,i){n.call(r,t.get(i),i,t)}))},o.get=function(n){var r=this[Q];u(r);var i=p(r).get(n);if(r.I||!t(i))return i;if(i!==r.t.get(n))return i;var o=R(r.A.h,i,r);return e(r),r.o.set(n,o),o},o.keys=function(){return p(this[Q]).keys()},o.values=function(){var n,r=this,t=this.keys();return(n={})[V]=function(){return r.values()},n.next=function(){var n=t.next();return n.done?n:{done:!1,value:r.get(n.value)}},n},o.entries=function(){var n,r=this,t=this.keys();return(n={})[V]=function(){return r.entries()},n.next=function(){var n=t.next();if(n.done)return n;var e=r.get(n.value);return{done:!1,value:[n.value,e]}},n},o[V]=function(){return this.entries()},n}(),c=function(){function n(n,r){return this[Q]={i:3,l:r,A:r?r.A:_(),P:!1,I:!1,o:void 0,t:n,k:this,p:new Map,O:!1,C:!1},this}r(n,Set);var t=n.prototype;return Object.defineProperty(t,\"size\",{get:function(){return p(this[Q]).size}}),t.has=function(n){var r=this[Q];return u(r),r.o?!!r.o.has(n)||!(!r.p.has(n)||!r.o.has(r.p.get(n))):r.t.has(n)},t.add=function(n){var r=this[Q];return u(r),this.has(n)||(o(r),k(r),r.o.add(n)),this},t.delete=function(n){if(!this.has(n))return!1;var r=this[Q];return u(r),o(r),k(r),r.o.delete(n)||!!r.p.has(n)&&r.o.delete(r.p.get(n))},t.clear=function(){var n=this[Q];u(n),p(n).size&&(o(n),k(n),n.o.clear())},t.values=function(){var n=this[Q];return u(n),o(n),n.o.values()},t.entries=function(){var n=this[Q];return u(n),o(n),n.o.entries()},t.keys=function(){return this.values()},t[V]=function(){return this.values()},t.forEach=function(n,r){for(var t=this.values(),e=t.next();!e.done;)n.call(r,e.value,e.value,this),e=t.next()},n}();m(\"MapSet\",{N:function(n,r){return new f(n,r)},T:function(n,r){return new c(n,r)}})}function J(){N(),C(),T()}function K(n){return n}function $(n){return n}var G,U,W=\"undefined\"!=typeof Symbol&&\"symbol\"==typeof Symbol(\"x\"),X=\"undefined\"!=typeof Map,q=\"undefined\"!=typeof Set,B=\"undefined\"!=typeof Proxy&&void 0!==Proxy.revocable&&\"undefined\"!=typeof Reflect,H=W?Symbol.for(\"immer-nothing\"):((G={})[\"immer-nothing\"]=!0,G),L=W?Symbol.for(\"immer-draftable\"):\"__$immer_draftable\",Q=W?Symbol.for(\"immer-state\"):\"__$immer_state\",V=\"undefined\"!=typeof Symbol&&Symbol.iterator||\"@@iterator\",Y={0:\"Illegal state\",1:\"Immer drafts cannot have computed properties\",2:\"This object has been frozen and should not be mutated\",3:function(n){return\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \"+n},4:\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",5:\"Immer forbids circular references\",6:\"The first or second argument to `produce` must be a function\",7:\"The third argument to `produce` must be a function or undefined\",8:\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",9:\"First argument to `finishDraft` must be a draft returned by `createDraft`\",10:\"The given draft is already finalized\",11:\"Object.defineProperty() cannot be used on an Immer draft\",12:\"Object.setPrototypeOf() cannot be used on an Immer draft\",13:\"Immer only supports deleting array indices\",14:\"Immer only supports setting array indices and the 'length' property\",15:function(n){return\"Cannot apply patch, path doesn't resolve: \"+n},16:'Sets cannot have \"replace\" patches.',17:function(n){return\"Unsupported patch operation: \"+n},18:function(n){return\"The plugin for '\"+n+\"' has not been loaded into Immer. To enable the plugin, import and call `enable\"+n+\"()` when initializing your application.\"},20:\"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",21:function(n){return\"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\"+n+\"'\"},22:function(n){return\"'current' expects a draft, got: \"+n},23:function(n){return\"'original' expects a draft, got: \"+n},24:\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"},Z=\"\"+Object.prototype.constructor,nn=\"undefined\"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,rn=Object.getOwnPropertyDescriptors||function(n){var r={};return nn(n).forEach((function(t){r[t]=Object.getOwnPropertyDescriptor(n,t)})),r},tn={},en={get:function(n,r){if(r===Q)return n;var e=p(n);if(!u(e,r))return function(n,r,t){var e,i=I(r,t);return i?\"value\"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,r);var i=e[r];return n.I||!t(i)?i:i===z(n.t,r)?(E(n),n.o[r]=R(n.A.h,i,n)):i},has:function(n,r){return r in p(n)},ownKeys:function(n){return Reflect.ownKeys(p(n))},set:function(n,r,t){var e=I(p(n),r);if(null==e?void 0:e.set)return e.set.call(n.k,t),!0;if(!n.P){var i=z(p(n),r),o=null==i?void 0:i[Q];if(o&&o.t===t)return n.o[r]=t,n.D[r]=!1,!0;if(c(t,i)&&(void 0!==t||u(n.t,r)))return!0;E(n),k(n)}return n.o[r]===t&&\"number\"!=typeof t&&(void 0!==t||r in n.o)||(n.o[r]=t,n.D[r]=!0,!0)},deleteProperty:function(n,r){return void 0!==z(n.t,r)||r in n.t?(n.D[r]=!1,E(n),k(n)):delete n.D[r],n.o&&delete n.o[r],!0},getOwnPropertyDescriptor:function(n,r){var t=p(n),e=Reflect.getOwnPropertyDescriptor(t,r);return e?{writable:!0,configurable:1!==n.i||\"length\"!==r,enumerable:e.enumerable,value:t[r]}:e},defineProperty:function(){n(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){n(12)}},on={};i(en,(function(n,r){on[n]=function(){return arguments[0]=arguments[0][0],r.apply(this,arguments)}})),on.deleteProperty=function(r,t){return false&&0,on.set.call(this,r,t,void 0)},on.set=function(r,t,e){return false&&0,en.set.call(this,r[0],t,e,r[0])};var un=function(){function e(r){var e=this;this.g=B,this.F=!0,this.produce=function(r,i,o){if(\"function\"==typeof r&&\"function\"!=typeof i){var u=i;i=r;var a=e;return function(n){var r=this;void 0===n&&(n=u);for(var t=arguments.length,e=Array(t>1?t-1:0),o=1;o<t;o++)e[o-1]=arguments[o];return a.produce(n,(function(n){var t;return(t=i).call.apply(t,[r,n].concat(e))}))}}var f;if(\"function\"!=typeof i&&n(6),void 0!==o&&\"function\"!=typeof o&&n(7),t(r)){var c=w(e),s=R(e,r,void 0),v=!0;try{f=i(s),v=!1}finally{v?O(c):g(c)}return\"undefined\"!=typeof Promise&&f instanceof Promise?f.then((function(n){return j(c,o),P(n,c)}),(function(n){throw O(c),n})):(j(c,o),P(f,c))}if(!r||\"object\"!=typeof r){if(void 0===(f=i(r))&&(f=r),f===H&&(f=void 0),e.F&&d(f,!0),o){var p=[],l=[];b(\"Patches\").M(r,f,p,l),o(p,l)}return f}n(21,r)},this.produceWithPatches=function(n,r){if(\"function\"==typeof n)return function(r){for(var t=arguments.length,i=Array(t>1?t-1:0),o=1;o<t;o++)i[o-1]=arguments[o];return e.produceWithPatches(r,(function(r){return n.apply(void 0,[r].concat(i))}))};var t,i,o=e.produce(n,r,(function(n,r){t=n,i=r}));return\"undefined\"!=typeof Promise&&o instanceof Promise?o.then((function(n){return[n,t,i]})):[o,t,i]},\"boolean\"==typeof(null==r?void 0:r.useProxies)&&this.setUseProxies(r.useProxies),\"boolean\"==typeof(null==r?void 0:r.autoFreeze)&&this.setAutoFreeze(r.autoFreeze)}var i=e.prototype;return i.createDraft=function(e){t(e)||n(8),r(e)&&(e=D(e));var i=w(this),o=R(this,e,void 0);return o[Q].C=!0,g(i),o},i.finishDraft=function(r,t){var e=r&&r[Q]; false&&(0);var i=e.A;return j(i,t),P(void 0,i)},i.setAutoFreeze=function(n){this.F=n},i.setUseProxies=function(r){r&&!B&&n(20),this.g=r},i.applyPatches=function(n,t){var e;for(e=t.length-1;e>=0;e--){var i=t[e];if(0===i.path.length&&\"replace\"===i.op){n=i.value;break}}e>-1&&(t=t.slice(e+1));var o=b(\"Patches\").$;return r(n)?o(n,t):this.produce(n,(function(n){return o(n,t)}))},e}(),an=new un,fn=an.produce,cn=an.produceWithPatches.bind(an),sn=an.setAutoFreeze.bind(an),vn=an.setUseProxies.bind(an),pn=an.applyPatches.bind(an),ln=an.createDraft.bind(an),dn=an.finishDraft.bind(an);/* harmony default export */ var immer_esm = ((/* unused pure expression or super */ null && (fn)));\n//# sourceMappingURL=immer.esm.js.map\n\n;// CONCATENATED MODULE: ./node_modules/slate/dist/index.es.js\n\n\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n\nfunction ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar nextEditorId = 0;\n/**\r\n * Create a new Slate `Editor` object.\r\n */\n\nvar createEditor = () => {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    id: nextEditorId++,\n    isInline: () => false,\n    isVoid: () => false,\n    markableVoid: () => false,\n    onChange: () => {},\n    apply: op => {\n      for (var ref of Editor.pathRefs(editor)) {\n        PathRef.transform(ref, op);\n      }\n\n      for (var _ref of Editor.pointRefs(editor)) {\n        PointRef.transform(_ref, op);\n      }\n\n      for (var _ref2 of Editor.rangeRefs(editor)) {\n        RangeRef.transform(_ref2, op);\n      }\n\n      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n      var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n      var dirtyPaths;\n      var dirtyPathKeys;\n\n      var add = path => {\n        if (path) {\n          var key = path.join(',');\n\n          if (!dirtyPathKeys.has(key)) {\n            dirtyPathKeys.add(key);\n            dirtyPaths.push(path);\n          }\n        }\n      };\n\n      if (Path.operationCanTransformPath(op)) {\n        dirtyPaths = [];\n        dirtyPathKeys = new Set();\n\n        for (var path of oldDirtyPaths) {\n          var newPath = Path.transform(path, op);\n          add(newPath);\n        }\n      } else {\n        dirtyPaths = oldDirtyPaths;\n        dirtyPathKeys = oldDirtyPathKeys;\n      }\n\n      var newDirtyPaths = editor.getDirtyPaths(op);\n\n      for (var _path of newDirtyPaths) {\n        add(_path);\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths);\n      DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n      Transforms.transform(editor, op);\n      editor.operations.push(op);\n      Editor.normalize(editor); // Clear any formats applied to the cursor if the selection changes.\n\n      if (op.type === 'set_selection') {\n        editor.marks = null;\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true);\n        Promise.resolve().then(() => {\n          FLUSHING.set(editor, false);\n          editor.onChange();\n          editor.operations = [];\n        });\n      }\n    },\n    addMark: (key, value) => {\n      var {\n        selection,\n        markableVoid\n      } = editor;\n\n      if (selection) {\n        var match = (node, path) => {\n          if (!Text.isText(node)) {\n            return false; // marks can only be applied to text\n          }\n\n          var [parentNode, parentPath] = Editor.parent(editor, path);\n          return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n        };\n\n        var expandedSelection = index_es_Range.isExpanded(selection);\n        var markAcceptingVoidSelected = false;\n\n        if (!expandedSelection) {\n          var [selectedNode, selectedPath] = Editor.node(editor, selection);\n\n          if (selectedNode && match(selectedNode, selectedPath)) {\n            var [parentNode] = Editor.parent(editor, selectedPath);\n            markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n          }\n        }\n\n        if (expandedSelection || markAcceptingVoidSelected) {\n          Transforms.setNodes(editor, {\n            [key]: value\n          }, {\n            match,\n            split: true,\n            voids: true\n          });\n        } else {\n          var marks = _objectSpread$9(_objectSpread$9({}, Editor.marks(editor) || {}), {}, {\n            [key]: value\n          });\n\n          editor.marks = marks;\n\n          if (!FLUSHING.get(editor)) {\n            editor.onChange();\n          }\n        }\n      }\n    },\n    deleteBackward: unit => {\n      var {\n        selection\n      } = editor;\n\n      if (selection && index_es_Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n          unit,\n          reverse: true\n        });\n      }\n    },\n    deleteForward: unit => {\n      var {\n        selection\n      } = editor;\n\n      if (selection && index_es_Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n          unit\n        });\n      }\n    },\n    deleteFragment: direction => {\n      var {\n        selection\n      } = editor;\n\n      if (selection && index_es_Range.isExpanded(selection)) {\n        Transforms.delete(editor, {\n          reverse: direction === 'backward'\n        });\n      }\n    },\n    getFragment: () => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        return Node.fragment(editor, selection);\n      }\n\n      return [];\n    },\n    insertBreak: () => {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertSoftBreak: () => {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertFragment: fragment => {\n      Transforms.insertFragment(editor, fragment);\n    },\n    insertNode: node => {\n      Transforms.insertNodes(editor, node);\n    },\n    insertText: text => {\n      var {\n        selection,\n        marks\n      } = editor;\n\n      if (selection) {\n        if (marks) {\n          var node = _objectSpread$9({\n            text\n          }, marks);\n\n          Transforms.insertNodes(editor, node);\n        } else {\n          Transforms.insertText(editor, text);\n        }\n\n        editor.marks = null;\n      }\n    },\n    normalizeNode: entry => {\n      var [node, path] = entry; // There are no core normalizations for text nodes.\n\n      if (Text.isText(node)) {\n        return;\n      } // Ensure that block and inline nodes have at least one text child.\n\n\n      if (Element.isElement(node) && node.children.length === 0) {\n        var child = {\n          text: ''\n        };\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true\n        });\n        return;\n      } // Determine whether the node should have block or inline children.\n\n\n      var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n\n      var n = 0;\n\n      for (var i = 0; i < node.children.length; i++, n++) {\n        var currentNode = Node.get(editor, path);\n        if (Text.isText(currentNode)) continue;\n        var _child = node.children[i];\n        var prev = currentNode.children[n - 1];\n        var isLast = i === node.children.length - 1;\n        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        } else if (Element.isElement(_child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(_child)) {\n            if (prev == null || !Text.isText(prev)) {\n              var newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true\n              });\n              n++;\n            } else if (isLast) {\n              var _newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, _newChild, {\n                at: path.concat(n + 1),\n                voids: true\n              });\n              n++;\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(_child, prev, {\n              loose: true\n            })) {\n              Transforms.mergeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true\n              });\n              n--;\n            } else if (_child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            }\n          }\n        }\n      }\n    },\n    removeMark: key => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        var match = (node, path) => {\n          if (!Text.isText(node)) {\n            return false; // marks can only be applied to text\n          }\n\n          var [parentNode, parentPath] = Editor.parent(editor, path);\n          return !editor.isVoid(parentNode) || editor.markableVoid(parentNode);\n        };\n\n        var expandedSelection = index_es_Range.isExpanded(selection);\n        var markAcceptingVoidSelected = false;\n\n        if (!expandedSelection) {\n          var [selectedNode, selectedPath] = Editor.node(editor, selection);\n\n          if (selectedNode && match(selectedNode, selectedPath)) {\n            var [parentNode] = Editor.parent(editor, selectedPath);\n            markAcceptingVoidSelected = parentNode && editor.markableVoid(parentNode);\n          }\n        }\n\n        if (expandedSelection || markAcceptingVoidSelected) {\n          Transforms.unsetNodes(editor, key, {\n            match,\n            split: true,\n            voids: true\n          });\n        } else {\n          var marks = _objectSpread$9({}, Editor.marks(editor) || {});\n\n          delete marks[key];\n          editor.marks = marks;\n\n          if (!FLUSHING.get(editor)) {\n            editor.onChange();\n          }\n        }\n      }\n    },\n\n    /**\r\n     * Get the \"dirty\" paths generated from an operation.\r\n     */\n    getDirtyPaths: op => {\n      switch (op.type) {\n        case 'insert_text':\n        case 'remove_text':\n        case 'set_node':\n          {\n            var {\n              path\n            } = op;\n            return Path.levels(path);\n          }\n\n        case 'insert_node':\n          {\n            var {\n              node,\n              path: _path2\n            } = op;\n            var levels = Path.levels(_path2);\n            var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), _ref3 => {\n              var [, p] = _ref3;\n              return _path2.concat(p);\n            });\n            return [...levels, ...descendants];\n          }\n\n        case 'merge_node':\n          {\n            var {\n              path: _path3\n            } = op;\n            var ancestors = Path.ancestors(_path3);\n            var previousPath = Path.previous(_path3);\n            return [...ancestors, previousPath];\n          }\n\n        case 'move_node':\n          {\n            var {\n              path: _path4,\n              newPath\n            } = op;\n\n            if (Path.equals(_path4, newPath)) {\n              return [];\n            }\n\n            var oldAncestors = [];\n            var newAncestors = [];\n\n            for (var ancestor of Path.ancestors(_path4)) {\n              var p = Path.transform(ancestor, op);\n              oldAncestors.push(p);\n            }\n\n            for (var _ancestor of Path.ancestors(newPath)) {\n              var _p = Path.transform(_ancestor, op);\n\n              newAncestors.push(_p);\n            }\n\n            var newParent = newAncestors[newAncestors.length - 1];\n            var newIndex = newPath[newPath.length - 1];\n            var resultPath = newParent.concat(newIndex);\n            return [...oldAncestors, ...newAncestors, resultPath];\n          }\n\n        case 'remove_node':\n          {\n            var {\n              path: _path5\n            } = op;\n\n            var _ancestors = Path.ancestors(_path5);\n\n            return [..._ancestors];\n          }\n\n        case 'split_node':\n          {\n            var {\n              path: _path6\n            } = op;\n\n            var _levels = Path.levels(_path6);\n\n            var nextPath = Path.next(_path6);\n            return [..._levels, nextPath];\n          }\n\n        default:\n          {\n            return [];\n          }\n      }\n    }\n  };\n  return editor;\n};\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */\nvar getCharacterDistance = function getCharacterDistance(str) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var isLTR = !isRTL;\n  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n  var left = CodepointType.None;\n  var right = CodepointType.None;\n  var distance = 0; // Evaluation of these conditions are deferred.\n\n  var gb11 = null; // Is GB11 applicable?\n\n  var gb12Or13 = null; // Is GB12 or GB13 applicable?\n\n  for (var char of codepoints) {\n    var code = char.codePointAt(0);\n    if (!code) break;\n    var type = getCodepointType(char, code);\n    [left, right] = isLTR ? [right, type] : [type, left];\n\n    if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n      if (isLTR) {\n        gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n      } else {\n        gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n      }\n\n      if (!gb11) break;\n    }\n\n    if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n      if (gb12Or13 !== null) {\n        gb12Or13 = !gb12Or13;\n      } else {\n        if (isLTR) {\n          gb12Or13 = true;\n        } else {\n          gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n        }\n      }\n\n      if (!gb12Or13) break;\n    }\n\n    if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n      break;\n    }\n\n    distance += char.length;\n  }\n\n  return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */\n\nvar getWordDistance = function getWordDistance(text) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var dist = 0;\n  var started = false;\n\n  while (text.length > 0) {\n    var charDist = getCharacterDistance(text, isRTL);\n    var [char, remaining] = splitByCharacterDistance(text, charDist, isRTL);\n\n    if (isWordCharacter(char, remaining, isRTL)) {\n      started = true;\n      dist += charDist;\n    } else if (!started) {\n      dist += charDist;\n    } else {\n      break;\n    }\n\n    text = remaining;\n  }\n\n  return dist;\n};\n/**\r\n * Split a string in two parts at a given distance starting from the end when\r\n * `isRTL` is set to `true`.\r\n */\n\nvar splitByCharacterDistance = (str, dist, isRTL) => {\n  if (isRTL) {\n    var at = str.length - dist;\n    return [str.slice(at, str.length), str.slice(0, at)];\n  }\n\n  return [str.slice(0, dist), str.slice(dist)];\n};\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */\n\nvar isWordCharacter = function isWordCharacter(char, remaining) {\n  var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (SPACE.test(char)) {\n    return false;\n  } // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n\n\n  if (CHAMELEON.test(char)) {\n    var charDist = getCharacterDistance(remaining, isRTL);\n    var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);\n\n    if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n      return true;\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Iterate on codepoints from right to left.\r\n */\n\n\nvar codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n  var end = str.length - 1;\n\n  for (var i = 0; i < str.length; i++) {\n    var char1 = str.charAt(end - i);\n\n    if (isLowSurrogate(char1.charCodeAt(0))) {\n      var char2 = str.charAt(end - i - 1);\n\n      if (isHighSurrogate(char2.charCodeAt(0))) {\n        yield char2 + char1;\n        i++;\n        continue;\n      }\n    }\n\n    yield char1;\n  }\n};\n/**\r\n * Is `charCode` a high surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */\n\nvar isHighSurrogate = charCode => {\n  return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\r\n * Is `charCode` a low surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */\n\n\nvar isLowSurrogate = charCode => {\n  return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\n\nvar CodepointType;\n\n(function (CodepointType) {\n  CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n  CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n  CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n  CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n  CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n  CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n  CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n  CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n  CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n  CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n  CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n  CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n  CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\n\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\n\nvar getCodepointType = (char, code) => {\n  var type = CodepointType.Any;\n\n  if (char.search(reExtend) !== -1) {\n    type |= CodepointType.Extend;\n  }\n\n  if (code === 0x200d) {\n    type |= CodepointType.ZWJ;\n  }\n\n  if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n    type |= CodepointType.RI;\n  }\n\n  if (char.search(rePrepend) !== -1) {\n    type |= CodepointType.Prepend;\n  }\n\n  if (char.search(reSpacingMark) !== -1) {\n    type |= CodepointType.SpacingMark;\n  }\n\n  if (char.search(reL) !== -1) {\n    type |= CodepointType.L;\n  }\n\n  if (char.search(reV) !== -1) {\n    type |= CodepointType.V;\n  }\n\n  if (char.search(reT) !== -1) {\n    type |= CodepointType.T;\n  }\n\n  if (char.search(reLV) !== -1) {\n    type |= CodepointType.LV;\n  }\n\n  if (char.search(reLVT) !== -1) {\n    type |= CodepointType.LVT;\n  }\n\n  if (char.search(reExtPict) !== -1) {\n    type |= CodepointType.ExtPict;\n  }\n\n  return type;\n};\n\nfunction intersects(x, y) {\n  return (x & y) !== 0;\n}\n\nvar NonBoundaryPairs = [// GB6\n[CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT], // GB7\n[CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T], // GB8\n[CodepointType.LVT | CodepointType.T, CodepointType.T], // GB9\n[CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ], // GB9a\n[CodepointType.Any, CodepointType.SpacingMark], // GB9b\n[CodepointType.Prepend, CodepointType.Any], // GB11\n[CodepointType.ZWJ, CodepointType.ExtPict], // GB12 and GB13\n[CodepointType.RI, CodepointType.RI]];\n\nfunction isBoundaryPair(left, right) {\n  return NonBoundaryPairs.findIndex(r => intersects(left, r[0]) && intersects(right, r[1])) === -1;\n}\n\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\n\nvar endsWithEmojiZWJ = str => {\n  return str.search(endingEmojiZWJ) !== -1;\n};\n\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\n\nvar endsWithOddNumberOfRIs = str => {\n  var match = str.match(endingRIs);\n\n  if (match === null) {\n    return false;\n  } else {\n    // A RI is represented by a surrogate pair.\n    var numRIs = match[0].length / 2;\n    return numRIs % 2 === 1;\n  }\n};\n\n/**\r\n * Shared the function with isElementType utility\r\n */\n\nvar isElement = value => {\n  return isPlainObject(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n}; // eslint-disable-next-line no-redeclare\n\n\nvar Element = {\n  /**\r\n   * Check if a value implements the 'Ancestor' interface.\r\n   */\n  isAncestor(value) {\n    return isPlainObject(value) && Node.isNodeList(value.children);\n  },\n\n  /**\r\n   * Check if a value implements the `Element` interface.\r\n   */\n  isElement,\n\n  /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */\n  isElementList(value) {\n    return Array.isArray(value) && value.every(val => Element.isElement(val));\n  },\n\n  /**\r\n   * Check if a set of props is a partial of Element.\r\n   */\n  isElementProps(props) {\n    return props.children !== undefined;\n  },\n\n  /**\r\n   * Check if a value implements the `Element` interface and has elementKey with selected value.\r\n   * Default it check to `type` key value\r\n   */\n  isElementType: function isElementType(value, elementVal) {\n    var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'type';\n    return isElement(value) && value[elementKey] === elementVal;\n  },\n\n  /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: this checks custom properties, and it does not ensure that any\r\n   * children are equivalent.\r\n   */\n  matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n};\n\nvar _excluded$4 = [\"text\"],\n    _excluded2$3 = [\"text\"];\n\nfunction ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar IS_EDITOR_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\n\nvar Editor = {\n  /**\r\n   * Get the ancestor above a location in the document.\r\n   */\n  above(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      voids = false,\n      mode = 'lowest',\n      at = editor.selection,\n      match\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var path = Editor.path(editor, at);\n    var reverse = mode === 'lowest';\n\n    for (var [n, p] of Editor.levels(editor, {\n      at: path,\n      voids,\n      match,\n      reverse\n    })) {\n      if (Text.isText(n)) return;\n\n      if (index_es_Range.isRange(at)) {\n        if (Path.isAncestor(p, at.anchor.path) && Path.isAncestor(p, at.focus.path)) {\n          return [n, p];\n        }\n      } else {\n        if (!Path.equals(path, p)) {\n          return [n, p];\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Add a custom property to the leaf text nodes in the current selection.\r\n   *\r\n   * If the selection is currently collapsed, the marks will be added to the\r\n   * `editor.marks` property instead, and applied when text is inserted next.\r\n   */\n  addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n\n  /**\r\n   * Get the point after a location.\r\n   */\n  after(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.point(editor, at, {\n      edge: 'end'\n    });\n    var focus = Editor.end(editor, []);\n    var range = {\n      anchor,\n      focus\n    };\n    var {\n      distance = 1\n    } = options;\n    var d = 0;\n    var target;\n\n    for (var p of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      at: range\n    }))) {\n      if (d > distance) {\n        break;\n      }\n\n      if (d !== 0) {\n        target = p;\n      }\n\n      d++;\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Get the point before a location.\r\n   */\n  before(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.start(editor, []);\n    var focus = Editor.point(editor, at, {\n      edge: 'start'\n    });\n    var range = {\n      anchor,\n      focus\n    };\n    var {\n      distance = 1\n    } = options;\n    var d = 0;\n    var target;\n\n    for (var p of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      at: range,\n      reverse: true\n    }))) {\n      if (d > distance) {\n        break;\n      }\n\n      if (d !== 0) {\n        target = p;\n      }\n\n      d++;\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Delete content in the editor backward from the current selection.\r\n   */\n  deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteBackward(unit);\n  },\n\n  /**\r\n   * Delete content in the editor forward from the current selection.\r\n   */\n  deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteForward(unit);\n  },\n\n  /**\r\n   * Delete the content in the current selection.\r\n   */\n  deleteFragment(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      direction = 'forward'\n    } = options;\n    editor.deleteFragment(direction);\n  },\n\n  /**\r\n   * Get the start and end points of a location.\r\n   */\n  edges(editor, at) {\n    return [Editor.start(editor, at), Editor.end(editor, at)];\n  },\n\n  /**\r\n   * Get the end point of a location.\r\n   */\n  end(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'end'\n    });\n  },\n\n  /**\r\n   * Get the first node at a location.\r\n   */\n  first(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'start'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the fragment at a location.\r\n   */\n  fragment(editor, at) {\n    var range = Editor.range(editor, at);\n    var fragment = Node.fragment(editor, range);\n    return fragment;\n  },\n\n  /**\r\n   * Check if a node has block children.\r\n   */\n  hasBlocks(editor, element) {\n    return element.children.some(n => Editor.isBlock(editor, n));\n  },\n\n  /**\r\n   * Check if a node has inline and text children.\r\n   */\n  hasInlines(editor, element) {\n    return element.children.some(n => Text.isText(n) || Editor.isInline(editor, n));\n  },\n\n  /**\r\n   * Check if a node has text children.\r\n   */\n  hasTexts(editor, element) {\n    return element.children.every(n => Text.isText(n));\n  },\n\n  /**\r\n   * Insert a block break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertBreak(editor) {\n    editor.insertBreak();\n  },\n\n  /**\r\n   * Insert a soft break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertSoftBreak(editor) {\n    editor.insertSoftBreak();\n  },\n\n  /**\r\n   * Insert a fragment at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertFragment(editor, fragment) {\n    editor.insertFragment(fragment);\n  },\n\n  /**\r\n   * Insert a node at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n\n  /**\r\n   * Insert text at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertText(editor, text) {\n    editor.insertText(text);\n  },\n\n  /**\r\n   * Check if a value is a block `Element` object.\r\n   */\n  isBlock(editor, value) {\n    return Element.isElement(value) && !editor.isInline(value);\n  },\n\n  /**\r\n   * Check if a value is an `Editor` object.\r\n   */\n  isEditor(value) {\n    var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n\n    if (cachedIsEditor !== undefined) {\n      return cachedIsEditor;\n    }\n\n    if (!isPlainObject(value)) {\n      return false;\n    }\n\n    var isEditor = typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteBackward === 'function' && typeof value.deleteForward === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertSoftBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isInline === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && typeof value.getDirtyPaths === 'function' && (value.marks === null || isPlainObject(value.marks)) && (value.selection === null || index_es_Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n    IS_EDITOR_CACHE.set(value, isEditor);\n    return isEditor;\n  },\n\n  /**\r\n   * Check if a point is the end point of a location.\r\n   */\n  isEnd(editor, point, at) {\n    var end = Editor.end(editor, at);\n    return Point.equals(point, end);\n  },\n\n  /**\r\n   * Check if a point is an edge of a location.\r\n   */\n  isEdge(editor, point, at) {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n  },\n\n  /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */\n  isEmpty(editor, element) {\n    var {\n      children\n    } = element;\n    var [first] = children;\n    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n  },\n\n  /**\r\n   * Check if a value is an inline `Element` object.\r\n   */\n  isInline(editor, value) {\n    return Element.isElement(value) && editor.isInline(value);\n  },\n\n  /**\r\n   * Check if the editor is currently normalizing after each operation.\r\n   */\n  isNormalizing(editor) {\n    var isNormalizing = NORMALIZING.get(editor);\n    return isNormalizing === undefined ? true : isNormalizing;\n  },\n\n  /**\r\n   * Check if a point is the start point of a location.\r\n   */\n  isStart(editor, point, at) {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false;\n    }\n\n    var start = Editor.start(editor, at);\n    return Point.equals(point, start);\n  },\n\n  /**\r\n   * Check if a value is a void `Element` object.\r\n   */\n  isVoid(editor, value) {\n    return Element.isElement(value) && editor.isVoid(value);\n  },\n\n  /**\r\n   * Get the last node at a location.\r\n   */\n  last(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'end'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the leaf text node at a location.\r\n   */\n  leaf(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.leaf(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the levels at a location.\r\n   */\n  *levels(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      reverse = false,\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n\n    if (match == null) {\n      match = () => true;\n    }\n\n    if (!at) {\n      return;\n    }\n\n    var levels = [];\n    var path = Editor.path(editor, at);\n\n    for (var [n, p] of Node.levels(editor, path)) {\n      if (!match(n, p)) {\n        continue;\n      }\n\n      levels.push([n, p]);\n\n      if (!voids && Editor.isVoid(editor, n)) {\n        break;\n      }\n    }\n\n    if (reverse) {\n      levels.reverse();\n    }\n\n    yield* levels;\n  },\n\n  /**\r\n   * Get the marks that would be added to text at the current selection.\r\n   */\n  marks(editor) {\n    var {\n      marks,\n      selection\n    } = editor;\n\n    if (!selection) {\n      return null;\n    }\n\n    if (marks) {\n      return marks;\n    }\n\n    if (index_es_Range.isExpanded(selection)) {\n      var [match] = Editor.nodes(editor, {\n        match: Text.isText\n      });\n\n      if (match) {\n        var [_node] = match;\n\n        var _rest = _objectWithoutProperties(_node, _excluded$4);\n\n        return _rest;\n      } else {\n        return {};\n      }\n    }\n\n    var {\n      anchor\n    } = selection;\n    var {\n      path\n    } = anchor;\n    var [node] = Editor.leaf(editor, path);\n\n    if (anchor.offset === 0) {\n      var prev = Editor.previous(editor, {\n        at: path,\n        match: Text.isText\n      });\n      var markedVoid = Editor.above(editor, {\n        match: n => Editor.isVoid(editor, n) && editor.markableVoid(n)\n      });\n\n      if (!markedVoid) {\n        var block = Editor.above(editor, {\n          match: n => Editor.isBlock(editor, n)\n        });\n\n        if (prev && block) {\n          var [prevNode, prevPath] = prev;\n          var [, blockPath] = block;\n\n          if (Path.isAncestor(blockPath, prevPath)) {\n            node = prevNode;\n          }\n        }\n      }\n    }\n\n    var rest = _objectWithoutProperties(node, _excluded2$3);\n\n    return rest;\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */\n  next(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var pointAfterLocation = Editor.after(editor, at, {\n      voids\n    });\n    if (!pointAfterLocation) return;\n    var [, to] = Editor.last(editor, []);\n    var span = [pointAfterLocation.path, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the next node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var [parent] = Editor.parent(editor, at);\n\n        match = n => parent.children.includes(n);\n      } else {\n        match = () => true;\n      }\n    }\n\n    var [next] = Editor.nodes(editor, {\n      at: span,\n      match,\n      mode,\n      voids\n    });\n    return next;\n  },\n\n  /**\r\n   * Get the node at a location.\r\n   */\n  node(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.get(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the nodes in the Editor.\r\n   */\n  *nodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      mode = 'all',\n      universal = false,\n      reverse = false,\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n\n    if (!match) {\n      match = () => true;\n    }\n\n    if (!at) {\n      return;\n    }\n\n    var from;\n    var to;\n\n    if (Span.isSpan(at)) {\n      from = at[0];\n      to = at[1];\n    } else {\n      var first = Editor.path(editor, at, {\n        edge: 'start'\n      });\n      var last = Editor.path(editor, at, {\n        edge: 'end'\n      });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n\n    var nodeEntries = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: _ref => {\n        var [n] = _ref;\n        return voids ? false : Editor.isVoid(editor, n);\n      }\n    });\n    var matches = [];\n    var hit;\n\n    for (var [node, path] of nodeEntries) {\n      var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.\n\n      if (mode === 'highest' && isLower) {\n        continue;\n      }\n\n      if (!match(node, path)) {\n        // If we've arrived at a leaf text node that is not lower than the last\n        // hit, then we've found a branch that doesn't include a match, which\n        // means the match is not universal.\n        if (universal && !isLower && Text.isText(node)) {\n          return;\n        } else {\n          continue;\n        }\n      } // If there's a match and it's lower than the last, update the hit.\n\n\n      if (mode === 'lowest' && isLower) {\n        hit = [node, path];\n        continue;\n      } // In lowest mode we emit the last hit, once it's guaranteed lowest.\n\n\n      var emit = mode === 'lowest' ? hit : [node, path];\n\n      if (emit) {\n        if (universal) {\n          matches.push(emit);\n        } else {\n          yield emit;\n        }\n      }\n\n      hit = [node, path];\n    } // Since lowest is always emitting one behind, catch up at the end.\n\n\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit);\n      } else {\n        yield hit;\n      }\n    } // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n\n\n    if (universal) {\n      yield* matches;\n    }\n  },\n\n  /**\r\n   * Normalize any dirty objects in the editor.\r\n   */\n  normalize(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      force = false\n    } = options;\n\n    var getDirtyPaths = editor => {\n      return DIRTY_PATHS.get(editor) || [];\n    };\n\n    var getDirtyPathKeys = editor => {\n      return DIRTY_PATH_KEYS.get(editor) || new Set();\n    };\n\n    var popDirtyPath = editor => {\n      var path = getDirtyPaths(editor).pop();\n      var key = path.join(',');\n      getDirtyPathKeys(editor).delete(key);\n      return path;\n    };\n\n    if (!Editor.isNormalizing(editor)) {\n      return;\n    }\n\n    if (force) {\n      var allPaths = Array.from(Node.nodes(editor), _ref2 => {\n        var [, p] = _ref2;\n        return p;\n      });\n      var allPathKeys = new Set(allPaths.map(p => p.join(',')));\n      DIRTY_PATHS.set(editor, allPaths);\n      DIRTY_PATH_KEYS.set(editor, allPathKeys);\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return;\n    }\n\n    Editor.withoutNormalizing(editor, () => {\n      /*\r\n        Fix dirty elements with no children.\r\n        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\r\n        Running an initial pass avoids the catch-22 race condition.\r\n      */\n      for (var dirtyPath of getDirtyPaths(editor)) {\n        if (Node.has(editor, dirtyPath)) {\n          var entry = Editor.node(editor, dirtyPath);\n          var [node, _] = entry;\n          /*\r\n            The default normalizer inserts an empty text node in this scenario, but it can be customised.\r\n            So there is some risk here.\r\n                       As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\r\n            by definition adding children to an empty node can't cause other paths to change.\r\n          */\n\n          if (Element.isElement(node) && node.children.length === 0) {\n            editor.normalizeNode(entry);\n          }\n        }\n      }\n\n      var max = getDirtyPaths(editor).length * 42; // HACK: better way?\n\n      var m = 0;\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(\"\\n            Could not completely normalize the editor after \".concat(max, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\\n          \"));\n        }\n\n        var _dirtyPath = popDirtyPath(editor); // If the node doesn't exist in the tree, it does not need to be normalized.\n\n\n        if (Node.has(editor, _dirtyPath)) {\n          var _entry = Editor.node(editor, _dirtyPath);\n\n          editor.normalizeNode(_entry);\n        }\n\n        m++;\n      }\n    });\n  },\n\n  /**\r\n   * Get the parent node of a location.\r\n   */\n  parent(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var parentPath = Path.parent(path);\n    var entry = Editor.node(editor, parentPath);\n    return entry;\n  },\n\n  /**\r\n   * Get the path of a location.\r\n   */\n  path(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      depth,\n      edge\n    } = options;\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        var [, firstPath] = Node.first(editor, at);\n        at = firstPath;\n      } else if (edge === 'end') {\n        var [, lastPath] = Node.last(editor, at);\n        at = lastPath;\n      }\n    }\n\n    if (index_es_Range.isRange(at)) {\n      if (edge === 'start') {\n        at = index_es_Range.start(at);\n      } else if (edge === 'end') {\n        at = index_es_Range.end(at);\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path);\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path;\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth);\n    }\n\n    return at;\n  },\n\n  hasPath(editor, path) {\n    return Node.has(editor, path);\n  },\n\n  /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pathRef(editor, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      affinity = 'forward'\n    } = options;\n    var ref = {\n      current: path,\n      affinity,\n\n      unref() {\n        var {\n          current\n        } = ref;\n        var pathRefs = Editor.pathRefs(editor);\n        pathRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n\n    };\n    var refs = Editor.pathRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked path refs of the editor.\r\n   */\n  pathRefs(editor) {\n    var refs = PATH_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      PATH_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Get the start or end point of a location.\r\n   */\n  point(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      edge = 'start'\n    } = options;\n\n    if (Path.isPath(at)) {\n      var path;\n\n      if (edge === 'end') {\n        var [, lastPath] = Node.last(editor, at);\n        path = lastPath;\n      } else {\n        var [, firstPath] = Node.first(editor, at);\n        path = firstPath;\n      }\n\n      var node = Node.get(editor, path);\n\n      if (!Text.isText(node)) {\n        throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n      }\n\n      return {\n        path,\n        offset: edge === 'end' ? node.text.length : 0\n      };\n    }\n\n    if (index_es_Range.isRange(at)) {\n      var [start, end] = index_es_Range.edges(at);\n      return edge === 'start' ? start : end;\n    }\n\n    return at;\n  },\n\n  /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pointRef(editor, point) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      affinity = 'forward'\n    } = options;\n    var ref = {\n      current: point,\n      affinity,\n\n      unref() {\n        var {\n          current\n        } = ref;\n        var pointRefs = Editor.pointRefs(editor);\n        pointRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n\n    };\n    var refs = Editor.pointRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked point refs of the editor.\r\n   */\n  pointRefs(editor) {\n    var refs = POINT_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      POINT_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Return all the positions in `at` range where a `Point` can be placed.\r\n   *\r\n   * By default, moves forward by individual offsets at a time, but\r\n   * the `unit` option can be used to to move by character, word, line, or block.\r\n   *\r\n   * The `reverse` option can be used to change iteration direction.\r\n   *\r\n   * Note: By default void nodes are treated as a single point and iteration\r\n   * will not happen inside their content unless you pass in true for the\r\n   * `voids` option, then iteration will occur.\r\n   */\n  *positions(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      unit = 'offset',\n      reverse = false,\n      voids = false\n    } = options;\n\n    if (!at) {\n      return;\n    }\n    /**\r\n     * Algorithm notes:\r\n     *\r\n     * Each step `distance` is dynamic depending on the underlying text\r\n     * and the `unit` specified.  Each step, e.g., a line or word, may\r\n     * span multiple text nodes, so we iterate through the text both on\r\n     * two levels in step-sync:\r\n     *\r\n     * `leafText` stores the text on a text leaf level, and is advanced\r\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\r\n     *\r\n     * `blockText` stores the text on a block level, and is shortened\r\n     * by `distance` every time it is advanced.\r\n     *\r\n     * We only maintain a window of one blockText and one leafText because\r\n     * a block node always appears before all of its leaf nodes.\r\n     */\n\n\n    var range = Editor.range(editor, at);\n    var [start, end] = index_es_Range.edges(range);\n    var first = reverse ? end : start;\n    var isNewBlock = false;\n    var blockText = '';\n    var distance = 0; // Distance for leafText to catch up to blockText.\n\n    var leafTextRemaining = 0;\n    var leafTextOffset = 0; // Iterate through all nodes in range, grabbing entire textual content\n    // of block nodes in blockText, and text nodes in leafText.\n    // Exploits the fact that nodes are sequenced in such a way that we first\n    // encounter the block node, then all of its text nodes, so when iterating\n    // through the blockText and leafText we just need to remember a window of\n    // one block node and leaf node, respectively.\n\n    for (var [node, path] of Editor.nodes(editor, {\n      at,\n      reverse,\n      voids\n    })) {\n      /*\r\n       * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\r\n       */\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, so by default we will always\n        // yield their first point. If the `voids` option is set to true,\n        // then we will iterate over their content.\n        if (!voids && editor.isVoid(node)) {\n          yield Editor.start(editor, path);\n          continue;\n        } // Inline element nodes are ignored as they don't themselves\n        // contribute to `blockText` or `leafText` - their parent and\n        // children do.\n\n\n        if (editor.isInline(node)) continue; // Block element node - set `blockText` to its text content.\n\n        if (Editor.hasInlines(editor, node)) {\n          // We always exhaust block nodes before encountering a new one:\n          //   console.assert(blockText === '',\n          //     `blockText='${blockText}' - `+\n          //     `not exhausted before new block node`, path)\n          // Ensure range considered is capped to `range`, in the\n          // start/end edge cases where block extends beyond range.\n          // Equivalent to this, but presumably more performant:\n          //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n          //   blockRange = Range.intersection(range, blockRange) // intersect\n          //   blockText = Editor.string(editor, blockRange, { voids })\n          var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n          var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n          blockText = Editor.string(editor, {\n            anchor: s,\n            focus: e\n          }, {\n            voids\n          });\n          isNewBlock = true;\n        }\n      }\n      /*\r\n       * TEXT LEAF NODE - Iterate through text content, yielding\r\n       * positions every `distance` offset according to `unit`.\r\n       */\n\n\n      if (Text.isText(node)) {\n        var isFirst = Path.equals(path, first.path); // Proof that we always exhaust text nodes before encountering a new one:\n        //   console.assert(leafTextRemaining <= 0,\n        //     `leafTextRemaining=${leafTextRemaining} - `+\n        //     `not exhausted before new leaf text node`, path)\n        // Reset `leafText` counters for new text node.\n\n        if (isFirst) {\n          leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n          leafTextOffset = first.offset; // Works for reverse too.\n        } else {\n          leafTextRemaining = node.text.length;\n          leafTextOffset = reverse ? leafTextRemaining : 0;\n        } // Yield position at the start of node (potentially).\n\n\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield {\n            path,\n            offset: leafTextOffset\n          };\n          isNewBlock = false;\n        } // Yield positions every (dynamically calculated) `distance` offset.\n\n\n        while (true) {\n          // If `leafText` has caught up with `blockText` (distance=0),\n          // and if blockText is exhausted, break to get another block node,\n          // otherwise advance blockText forward by the new `distance`.\n          if (distance === 0) {\n            if (blockText === '') break;\n            distance = calcDistance(blockText, unit, reverse); // Split the string at the previously found distance and use the\n            // remaining string for the next iteration.\n\n            blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n          } // Advance `leafText` by the current `distance`.\n\n\n          leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n          leafTextRemaining = leafTextRemaining - distance; // If `leafText` is exhausted, break to get a new leaf node\n          // and set distance to the overflow amount, so we'll (maybe)\n          // catch up to blockText in the next leaf text node.\n\n          if (leafTextRemaining < 0) {\n            distance = -leafTextRemaining;\n            break;\n          } // Successfully walked `distance` offsets through `leafText`\n          // to catch up with `blockText`, so we can reset `distance`\n          // and yield this position in this node.\n\n\n          distance = 0;\n          yield {\n            path,\n            offset: leafTextOffset\n          };\n        }\n      }\n    } // Proof that upon completion, we've exahusted both leaf and block text:\n    //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n    //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n    // Helper:\n    // Return the distance in offsets for a step of size `unit` on given string.\n\n\n    function calcDistance(text, unit, reverse) {\n      if (unit === 'character') {\n        return getCharacterDistance(text, reverse);\n      } else if (unit === 'word') {\n        return getWordDistance(text, reverse);\n      } else if (unit === 'line' || unit === 'block') {\n        return text.length;\n      }\n\n      return 1;\n    }\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */\n  previous(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var pointBeforeLocation = Editor.before(editor, at, {\n      voids\n    });\n\n    if (!pointBeforeLocation) {\n      return;\n    }\n\n    var [, to] = Editor.first(editor, []); // The search location is from the start of the document to the path of\n    // the point before the location passed in\n\n    var span = [pointBeforeLocation.path, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the previous node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var [parent] = Editor.parent(editor, at);\n\n        match = n => parent.children.includes(n);\n      } else {\n        match = () => true;\n      }\n    }\n\n    var [previous] = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match,\n      mode,\n      voids\n    });\n    return previous;\n  },\n\n  /**\r\n   * Get a range of a location.\r\n   */\n  range(editor, at, to) {\n    if (index_es_Range.isRange(at) && !to) {\n      return at;\n    }\n\n    var start = Editor.start(editor, at);\n    var end = Editor.end(editor, to || at);\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  rangeRef(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      affinity = 'forward'\n    } = options;\n    var ref = {\n      current: range,\n      affinity,\n\n      unref() {\n        var {\n          current\n        } = ref;\n        var rangeRefs = Editor.rangeRefs(editor);\n        rangeRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n\n    };\n    var refs = Editor.rangeRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked range refs of the editor.\r\n   */\n  rangeRefs(editor) {\n    var refs = RANGE_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      RANGE_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Remove a custom property from all of the leaf text nodes in the current\r\n   * selection.\r\n   *\r\n   * If the selection is currently collapsed, the removal will be stored on\r\n   * `editor.marks` and applied to the text inserted next.\r\n   */\n  removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n\n  /**\r\n   * Manually set if the editor should currently be normalizing.\r\n   *\r\n   * Note: Using this incorrectly can leave the editor in an invalid state.\r\n   *\r\n   */\n  setNormalizing(editor, isNormalizing) {\n    NORMALIZING.set(editor, isNormalizing);\n  },\n\n  /**\r\n   * Get the start point of a location.\r\n   */\n  start(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'start'\n    });\n  },\n\n  /**\r\n   * Get the text string content of a location.\r\n   *\r\n   * Note: by default the text of void nodes is considered to be an empty\r\n   * string, regardless of content, unless you pass in true for the voids option\r\n   */\n  string(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      voids = false\n    } = options;\n    var range = Editor.range(editor, at);\n    var [start, end] = index_es_Range.edges(range);\n    var text = '';\n\n    for (var [node, path] of Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n      voids\n    })) {\n      var t = node.text;\n\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset);\n      }\n\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset);\n      }\n\n      text += t;\n    }\n\n    return text;\n  },\n\n  /**\r\n   * Convert a range into a non-hanging one.\r\n   */\n  unhangRange(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      voids = false\n    } = options;\n    var [start, end] = index_es_Range.edges(range); // PERF: exit early if we can guarantee that the range isn't hanging.\n\n    if (start.offset !== 0 || end.offset !== 0 || index_es_Range.isCollapsed(range) || Path.hasPrevious(end.path)) {\n      return range;\n    }\n\n    var endBlock = Editor.above(editor, {\n      at: end,\n      match: n => Editor.isBlock(editor, n),\n      voids\n    });\n    var blockPath = endBlock ? endBlock[1] : [];\n    var first = Editor.start(editor, start);\n    var before = {\n      anchor: first,\n      focus: end\n    };\n    var skip = true;\n\n    for (var [node, path] of Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids\n    })) {\n      if (skip) {\n        skip = false;\n        continue;\n      }\n\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = {\n          path,\n          offset: node.text.length\n        };\n        break;\n      }\n    }\n\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Match a void node in the current branch of the editor.\r\n   */\n  void(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      match: n => Editor.isVoid(editor, n)\n    }));\n  },\n\n  /**\r\n   * Call a function, deferring normalization until after it completes.\r\n   */\n  withoutNormalizing(editor, fn) {\n    var value = Editor.isNormalizing(editor);\n    Editor.setNormalizing(editor, false);\n\n    try {\n      fn();\n    } finally {\n      Editor.setNormalizing(editor, value);\n    }\n\n    Editor.normalize(editor);\n  }\n\n};\n\nvar Location = {\n  /**\r\n   * Check if a value implements the `Location` interface.\r\n   */\n  isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || index_es_Range.isRange(value);\n  }\n\n}; // eslint-disable-next-line no-redeclare\n\nvar Span = {\n  /**\r\n   * Check if a value implements the `Span` interface.\r\n   */\n  isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n\n};\n\nvar _excluded$3 = [\"children\"],\n    _excluded2$2 = [\"text\"];\nvar IS_NODE_LIST_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\n\nvar Node = {\n  /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */\n  ancestor(root, path) {\n    var node = Node.get(root, path);\n\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go bottom-up.\r\n   */\n  *ancestors(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    for (var p of Path.ancestors(path, options)) {\n      var n = Node.ancestor(root, p);\n      var entry = [n, p];\n      yield entry;\n    }\n  },\n\n  /**\r\n   * Get the child of a node at a specific index.\r\n   */\n  child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n    }\n\n    var c = root.children[index];\n\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n    }\n\n    return c;\n  },\n\n  /**\r\n   * Iterate over the children of a node at a specific path.\r\n   */\n  *children(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      reverse = false\n    } = options;\n    var ancestor = Node.ancestor(root, path);\n    var {\n      children\n    } = ancestor;\n    var index = reverse ? children.length - 1 : 0;\n\n    while (reverse ? index >= 0 : index < children.length) {\n      var child = Node.child(ancestor, index);\n      var childPath = path.concat(index);\n      yield [child, childPath];\n      index = reverse ? index - 1 : index + 1;\n    }\n  },\n\n  /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */\n  common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */\n  descendant(root, path) {\n    var node = Node.get(root, path);\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of all the descendant node entries inside a root node.\r\n   */\n  *descendants(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n        yield [node, path];\n      }\n    }\n  },\n\n  /**\r\n   * Return a generator of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */\n  *elements(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path];\n      }\n    }\n  },\n\n  /**\r\n   * Extract props from a Node.\r\n   */\n  extractProps(node) {\n    if (Element.isAncestor(node)) {\n      var properties = _objectWithoutProperties(node, _excluded$3);\n\n      return properties;\n    } else {\n      var properties = _objectWithoutProperties(node, _excluded2$2);\n\n      return properties;\n    }\n  },\n\n  /**\r\n   * Get the first node entry in a root node from a path.\r\n   */\n  first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */\n  fragment(root, range) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n    }\n\n    var newRoot = fn({\n      children: root.children\n    }, r => {\n      var [start, end] = index_es_Range.edges(range);\n      var nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: _ref => {\n          var [, path] = _ref;\n          return !index_es_Range.includes(range, path);\n        }\n      });\n\n      for (var [, path] of nodeEntries) {\n        if (!index_es_Range.includes(range, path)) {\n          var parent = Node.parent(r, path);\n          var index = path[path.length - 1];\n          parent.children.splice(index, 1);\n        }\n\n        if (Path.equals(path, end.path)) {\n          var leaf = Node.leaf(r, path);\n          leaf.text = leaf.text.slice(0, end.offset);\n        }\n\n        if (Path.equals(path, start.path)) {\n          var _leaf = Node.leaf(r, path);\n\n          _leaf.text = _leaf.text.slice(start.offset);\n        }\n      }\n\n      if (Editor.isEditor(r)) {\n        r.selection = null;\n      }\n    });\n    return newRoot.children;\n  },\n\n  /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */\n  get(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n      }\n\n      node = node.children[p];\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */\n  has(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n\n      node = node.children[p];\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Check if a value implements the `Node` interface.\r\n   */\n  isNode(value) {\n    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */\n  isNodeList(value) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n\n    var cachedResult = IS_NODE_LIST_CACHE.get(value);\n\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    }\n\n    var isNodeList = value.every(val => Node.isNode(val));\n    IS_NODE_LIST_CACHE.set(value, isNodeList);\n    return isNodeList;\n  },\n\n  /**\r\n   * Get the last node entry in a root node from a path.\r\n   */\n  last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */\n  leaf(root, path) {\n    var node = Node.get(root, path);\n\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */\n  *levels(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    for (var p of Path.levels(path, options)) {\n      var n = Node.get(root, p);\n      yield [n, p];\n    }\n  },\n\n  /**\r\n   * Check if a node matches a set of props.\r\n   */\n  matches(node, props) {\n    return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n  },\n\n  /**\r\n   * Return a generator of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */\n  *nodes(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      pass,\n      reverse = false\n    } = options;\n    var {\n      from = [],\n      to\n    } = options;\n    var visited = new Set();\n    var p = [];\n    var n = root;\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break;\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p];\n      } // If we're allowed to go downward and we haven't descended yet, do.\n\n\n      if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {\n        visited.add(n);\n        var nextIndex = reverse ? n.children.length - 1 : 0;\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length];\n        }\n\n        p = p.concat(nextIndex);\n        n = Node.get(root, p);\n        continue;\n      } // If we're at the root and we can't go down, we're done.\n\n\n      if (p.length === 0) {\n        break;\n      } // If we're going forward...\n\n\n      if (!reverse) {\n        var newPath = Path.next(p);\n\n        if (Node.has(root, newPath)) {\n          p = newPath;\n          n = Node.get(root, p);\n          continue;\n        }\n      } // If we're going backward...\n\n\n      if (reverse && p[p.length - 1] !== 0) {\n        var _newPath = Path.previous(p);\n\n        p = _newPath;\n        n = Node.get(root, p);\n        continue;\n      } // Otherwise we're going upward...\n\n\n      p = Path.parent(p);\n      n = Node.get(root, p);\n      visited.add(n);\n    }\n  },\n\n  /**\r\n   * Get the parent of a node at a specific path.\r\n   */\n  parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n\n    return p;\n  },\n\n  /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */\n  string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.string).join('');\n    }\n  },\n\n  /**\r\n   * Return a generator of all leaf text nodes in a root node.\r\n   */\n  *texts(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path];\n      }\n    }\n  }\n\n};\n\nfunction ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Operation = {\n  /**\r\n   * Check of a value is a `NodeOperation` object.\r\n   */\n  isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n\n  /**\r\n   * Check of a value is an `Operation` object.\r\n   */\n  isOperation(value) {\n    if (!isPlainObject(value)) {\n      return false;\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'insert_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'merge_node':\n        return typeof value.position === 'number' && Path.isPath(value.path) && isPlainObject(value.properties);\n\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'remove_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'set_node':\n        return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);\n\n      case 'set_selection':\n        return value.properties === null && index_es_Range.isRange(value.newProperties) || value.newProperties === null && index_es_Range.isRange(value.properties) || isPlainObject(value.properties) && isPlainObject(value.newProperties);\n\n      case 'split_node':\n        return Path.isPath(value.path) && typeof value.position === 'number' && isPlainObject(value.properties);\n\n      default:\n        return false;\n    }\n  },\n\n  /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */\n  isOperationList(value) {\n    return Array.isArray(value) && value.every(val => Operation.isOperation(val));\n  },\n\n  /**\r\n   * Check of a value is a `SelectionOperation` object.\r\n   */\n  isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n\n  /**\r\n   * Check of a value is a `TextOperation` object.\r\n   */\n  isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n\n  /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */\n  inverse(op) {\n    switch (op.type) {\n      case 'insert_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'remove_node'\n          });\n        }\n\n      case 'insert_text':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'remove_text'\n          });\n        }\n\n      case 'merge_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n\n      case 'move_node':\n        {\n          var {\n            newPath,\n            path\n          } = op; // PERF: in this case the move operation is a no-op anyways.\n\n          if (Path.equals(newPath, path)) {\n            return op;\n          } // If the move happens completely within a single parent the path and\n          // newPath are stable with respect to each other.\n\n\n          if (Path.isSibling(path, newPath)) {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              path: newPath,\n              newPath: path\n            });\n          } // If the move does not happen within a single parent it is possible\n          // for the move to impact the true path to the location where the node\n          // was removed from and where it was inserted. We have to adjust for this\n          // and find the original path. We can accomplish this (only in non-sibling)\n          // moves by looking at the impact of the move operation on the node\n          // after the original move path.\n\n\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n\n      case 'remove_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'insert_node'\n          });\n        }\n\n      case 'remove_text':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'insert_text'\n          });\n        }\n\n      case 'set_node':\n        {\n          var {\n            properties,\n            newProperties\n          } = op;\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n\n      case 'set_selection':\n        {\n          var {\n            properties: _properties,\n            newProperties: _newProperties\n          } = op;\n\n          if (_properties == null) {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n\n      case 'split_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n\n};\n\n// eslint-disable-next-line no-redeclare\nvar Path = {\n  /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from shallowest to deepest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */\n  ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var paths = Path.levels(path, options);\n\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n\n    return paths;\n  },\n\n  /**\r\n   * Get the common ancestor path of two paths.\r\n   */\n  common(path, another) {\n    var common = [];\n\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n\n      if (av !== bv) {\n        break;\n      }\n\n      common.push(av);\n    }\n\n    return common;\n  },\n\n  /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */\n  compare(path, another) {\n    var min = Math.min(path.length, another.length);\n\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n\n    return 0;\n  },\n\n  /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */\n  endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n\n  /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */\n  endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n\n  /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */\n  endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n\n  /**\r\n   * Check if a path is exactly equal to another.\r\n   */\n  equals(path, another) {\n    return path.length === another.length && path.every((n, i) => n === another[i]);\n  },\n\n  /**\r\n   * Check if the path of previous sibling node exists\r\n   */\n  hasPrevious(path) {\n    return path[path.length - 1] > 0;\n  },\n\n  /**\r\n   * Check if a path is after another.\r\n   */\n  isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n\n  /**\r\n   * Check if a path is an ancestor of another.\r\n   */\n  isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is before another.\r\n   */\n  isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n\n  /**\r\n   * Check if a path is a child of another.\r\n   */\n  isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */\n  isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is a descendant of another.\r\n   */\n  isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is the parent of another.\r\n   */\n  isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check is a value implements the `Path` interface.\r\n   */\n  isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n\n  /**\r\n   * Check if a path is a sibling of another.\r\n   */\n  isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n\n  /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */\n  levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var list = [];\n\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n\n    if (reverse) {\n      list.reverse();\n    }\n\n    return list;\n  },\n\n  /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */\n  next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n\n  /**\r\n   * Returns whether this operation can affect paths or not. Used as an\r\n   * optimization when updating dirty paths during normalization\r\n   *\r\n   * NOTE: This *must* be kept in sync with the implementation of 'transform'\r\n   * below\r\n   */\n  operationCanTransformPath(operation) {\n    switch (operation.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'split_node':\n      case 'move_node':\n        return true;\n\n      default:\n        return false;\n    }\n  },\n\n  /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */\n  parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n\n    return path.slice(0, -1);\n  },\n\n  /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */\n  previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n\n    var last = path[path.length - 1];\n\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n\n    return path.slice(0, -1).concat(last - 1);\n  },\n\n  /**\r\n   * Get a path relative to an ancestor.\r\n   */\n  relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n\n    return path.slice(ancestor.length);\n  },\n\n  /**\r\n   * Transform a path by an operation.\r\n   */\n  transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (!path) return null; // PERF: use destructing instead of immer\n\n    var p = [...path];\n    var {\n      affinity = 'forward'\n    } = options; // PERF: Exit early if the operation is guaranteed not to have an effect.\n\n    if (path.length === 0) {\n      return p;\n    }\n\n    switch (operation.type) {\n      case 'insert_node':\n        {\n          var {\n            path: op\n          } = operation;\n\n          if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n            p[op.length - 1] += 1;\n          }\n\n          break;\n        }\n\n      case 'remove_node':\n        {\n          var {\n            path: _op\n          } = operation;\n\n          if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n            return null;\n          } else if (Path.endsBefore(_op, p)) {\n            p[_op.length - 1] -= 1;\n          }\n\n          break;\n        }\n\n      case 'merge_node':\n        {\n          var {\n            path: _op2,\n            position\n          } = operation;\n\n          if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n          } else if (Path.isAncestor(_op2, p)) {\n            p[_op2.length - 1] -= 1;\n            p[_op2.length] += position;\n          }\n\n          break;\n        }\n\n      case 'split_node':\n        {\n          var {\n            path: _op3,\n            position: _position\n          } = operation;\n\n          if (Path.equals(_op3, p)) {\n            if (affinity === 'forward') {\n              p[p.length - 1] += 1;\n            } else if (affinity === 'backward') ; else {\n              return null;\n            }\n          } else if (Path.endsBefore(_op3, p)) {\n            p[_op3.length - 1] += 1;\n          } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n            p[_op3.length - 1] += 1;\n            p[_op3.length] -= _position;\n          }\n\n          break;\n        }\n\n      case 'move_node':\n        {\n          var {\n            path: _op4,\n            newPath: onp\n          } = operation; // If the old and new path are the same, it's a no-op.\n\n          if (Path.equals(_op4, onp)) {\n            return p;\n          }\n\n          if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n            var copy = onp.slice();\n\n            if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n              copy[_op4.length - 1] -= 1;\n            }\n\n            return copy.concat(p.slice(_op4.length));\n          } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            } else {\n              p[_op4.length - 1] += 1;\n            }\n          } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n            if (Path.endsBefore(_op4, p)) {\n              p[_op4.length - 1] -= 1;\n            }\n\n            p[onp.length - 1] += 1;\n          } else if (Path.endsBefore(_op4, p)) {\n            if (Path.equals(onp, p)) {\n              p[onp.length - 1] += 1;\n            }\n\n            p[_op4.length - 1] -= 1;\n          }\n\n          break;\n        }\n    }\n\n    return p;\n  }\n\n};\n\nvar PathRef = {\n  /**\r\n   * Transform the path ref's current value by an operation.\r\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Path.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nfunction ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Point = {\n  /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */\n  compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Check if a point is after another.\r\n   */\n  isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n\n  /**\r\n   * Check if a point is before another.\r\n   */\n  isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n\n  /**\r\n   * Check if a point is exactly equal to another.\r\n   */\n  equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n\n  /**\r\n   * Check if a value implements the `Point` interface.\r\n   */\n  isPoint(value) {\n    return isPlainObject(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n\n  /**\r\n   * Transform a point by an operation.\r\n   */\n  transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return fn(point, p => {\n      if (p === null) {\n        return null;\n      }\n\n      var {\n        affinity = 'forward'\n      } = options;\n      var {\n        path,\n        offset\n      } = p;\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node':\n          {\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'insert_text':\n          {\n            if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === 'forward')) {\n              p.offset += op.text.length;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            if (Path.equals(op.path, path)) {\n              p.offset += op.position;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'remove_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset -= Math.min(offset - op.offset, op.text.length);\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n              return null;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'split_node':\n          {\n            if (Path.equals(op.path, path)) {\n              if (op.position === offset && affinity == null) {\n                return null;\n              } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n                p.offset -= op.position;\n                p.path = Path.transform(path, op, _objectSpread$6(_objectSpread$6({}, options), {}, {\n                  affinity: 'forward'\n                }));\n              }\n            } else {\n              p.path = Path.transform(path, op, options);\n            }\n\n            break;\n          }\n      }\n    });\n  }\n\n};\n\nvar PointRef = {\n  /**\r\n   * Transform the point ref's current value by an operation.\r\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var point = Point.transform(current, op, {\n      affinity\n    });\n    ref.current = point;\n\n    if (point == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nvar _excluded$2 = [\"anchor\", \"focus\"];\n\nfunction ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar index_es_Range = {\n  /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */\n  edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var {\n      anchor,\n      focus\n    } = range;\n    return index_es_Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n\n  /**\r\n   * Get the end point of a range.\r\n   */\n  end(range) {\n    var [, end] = index_es_Range.edges(range);\n    return end;\n  },\n\n  /**\r\n   * Check if a range is exactly equal to another.\r\n   */\n  equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n\n  /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */\n  includes(range, target) {\n    if (index_es_Range.isRange(target)) {\n      if (index_es_Range.includes(range, target.anchor) || index_es_Range.includes(range, target.focus)) {\n        return true;\n      }\n\n      var [rs, re] = index_es_Range.edges(range);\n      var [ts, te] = index_es_Range.edges(target);\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n\n    var [start, end] = index_es_Range.edges(range);\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n\n    return isAfterStart && isBeforeEnd;\n  },\n\n  /**\r\n   * Get the intersection of a range with another.\r\n   */\n  intersection(range, another) {\n    var rest = _objectWithoutProperties(range, _excluded$2);\n\n    var [s1, e1] = index_es_Range.edges(range);\n    var [s2, e2] = index_es_Range.edges(another);\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$5({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n\n  /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */\n  isBackward(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.isAfter(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */\n  isCollapsed(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.equals(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */\n  isExpanded(range) {\n    return !index_es_Range.isCollapsed(range);\n  },\n\n  /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */\n  isForward(range) {\n    return !index_es_Range.isBackward(range);\n  },\n\n  /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */\n  isRange(value) {\n    return isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n\n  /**\r\n   * Iterate through all of the point entries in a range.\r\n   */\n  *points(range) {\n    yield [range.anchor, 'anchor'];\n    yield [range.focus, 'focus'];\n  },\n\n  /**\r\n   * Get the start point of a range.\r\n   */\n  start(range) {\n    var [start] = index_es_Range.edges(range);\n    return start;\n  },\n\n  /**\r\n   * Transform a range by an operation.\r\n   */\n  transform(range, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return fn(range, r => {\n      if (r === null) {\n        return null;\n      }\n\n      var {\n        affinity = 'inward'\n      } = options;\n      var affinityAnchor;\n      var affinityFocus;\n\n      if (affinity === 'inward') {\n        // If the range is collapsed, make sure to use the same affinity to\n        // avoid the two points passing each other and expanding in the opposite\n        // direction\n        var isCollapsed = index_es_Range.isCollapsed(r);\n\n        if (index_es_Range.isForward(r)) {\n          affinityAnchor = 'forward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'backward';\n        } else {\n          affinityAnchor = 'backward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'forward';\n        }\n      } else if (affinity === 'outward') {\n        if (index_es_Range.isForward(r)) {\n          affinityAnchor = 'backward';\n          affinityFocus = 'forward';\n        } else {\n          affinityAnchor = 'forward';\n          affinityFocus = 'backward';\n        }\n      } else {\n        affinityAnchor = affinity;\n        affinityFocus = affinity;\n      }\n\n      var anchor = Point.transform(r.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r.focus, op, {\n        affinity: affinityFocus\n      });\n\n      if (!anchor || !focus) {\n        return null;\n      }\n\n      r.anchor = anchor;\n      r.focus = focus;\n    });\n  }\n\n};\n\nvar RangeRef = {\n  /**\r\n   * Transform the range ref's current value by an operation.\r\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = index_es_Range.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nvar _scrubber = undefined;\n/**\r\n * This interface implements a stringify() function, which is used by Slate\r\n * internally when generating exceptions containing end user data. Developers\r\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\r\n * stringify() function.\r\n *\r\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\r\n *\r\n *    import { Scrubber } from 'slate';\r\n *    Scrubber.setScrubber((key, val) => {\r\n *      if (key === 'text') return '...scrubbed...'\r\n *      return val\r\n *    });\r\n *\r\n */\n// eslint-disable-next-line no-redeclare\n\nvar Scrubber = {\n  setScrubber(scrubber) {\n    _scrubber = scrubber;\n  },\n\n  stringify(value) {\n    return JSON.stringify(value, _scrubber);\n  }\n\n};\n\n/*\r\n  Custom deep equal comparison for Slate nodes.\r\n\n  We don't need general purpose deep equality;\r\n  Slate only supports plain values, Arrays, and nested objects.\r\n  Complex values nested inside Arrays are not supported.\r\n\n  Slate objects are designed to be serialised, so\r\n  missing keys are deliberately normalised to undefined.\r\n */\n\nvar isDeepEqual = (node, another) => {\n  for (var key in node) {\n    var a = node[key];\n    var b = another[key];\n\n    if (isPlainObject(a) && isPlainObject(b)) {\n      if (!isDeepEqual(a, b)) return false;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false;\n\n      for (var i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) return false;\n      }\n    } else if (a !== b) {\n      return false;\n    }\n  }\n  /*\r\n    Deep object equality is only necessary in one direction; in the reverse direction\r\n    we are only looking for keys that are missing.\r\n    As above, undefined keys are normalised to missing.\r\n  */\n\n\n  for (var _key in another) {\n    if (node[_key] === undefined && another[_key] !== undefined) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar _excluded$1 = [\"text\"],\n    _excluded2$1 = [\"anchor\", \"focus\"];\n\nfunction ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Text = {\n  /**\r\n   * Check if two text nodes are equal.\r\n   *\r\n   * When loose is set, the text is not compared. This is\r\n   * used to check whether sibling text nodes can be merged.\r\n   */\n  equals(text, another) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      loose = false\n    } = options;\n\n    function omitText(obj) {\n      var rest = _objectWithoutProperties(obj, _excluded$1);\n\n      return rest;\n    }\n\n    return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n  },\n\n  /**\r\n   * Check if a value implements the `Text` interface.\r\n   */\n  isText(value) {\n    return isPlainObject(value) && typeof value.text === 'string';\n  },\n\n  /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */\n  isTextList(value) {\n    return Array.isArray(value) && value.every(val => Text.isText(val));\n  },\n\n  /**\r\n   * Check if some props are a partial of Text.\r\n   */\n  isTextProps(props) {\n    return props.text !== undefined;\n  },\n\n  /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal.\r\n   */\n  matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Get the leaves for a text node given decorations.\r\n   */\n  decorations(node, decorations) {\n    var leaves = [_objectSpread$4({}, node)];\n\n    for (var dec of decorations) {\n      var rest = _objectWithoutProperties(dec, _excluded2$1);\n\n      var [start, end] = index_es_Range.edges(dec);\n      var next = [];\n      var leafEnd = 0;\n      var decorationStart = start.offset;\n      var decorationEnd = end.offset;\n\n      for (var leaf of leaves) {\n        var {\n          length\n        } = leaf.text;\n        var leafStart = leafEnd;\n        leafEnd += length; // If the range encompasses the entire leaf, add the range.\n\n        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n          Object.assign(leaf, rest);\n          next.push(leaf);\n          continue;\n        } // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n\n\n        if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n          next.push(leaf);\n          continue;\n        } // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n\n\n        var middle = leaf;\n        var before = void 0;\n        var after = void 0;\n\n        if (decorationEnd < leafEnd) {\n          var off = decorationEnd - leafStart;\n          after = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n            text: middle.text.slice(off)\n          });\n          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n            text: middle.text.slice(0, off)\n          });\n        }\n\n        if (decorationStart > leafStart) {\n          var _off = decorationStart - leafStart;\n\n          before = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n            text: middle.text.slice(0, _off)\n          });\n          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n            text: middle.text.slice(_off)\n          });\n        }\n\n        Object.assign(middle, rest);\n\n        if (before) {\n          next.push(before);\n        }\n\n        next.push(middle);\n\n        if (after) {\n          next.push(after);\n        }\n      }\n\n      leaves = next;\n    }\n\n    return leaves;\n  }\n\n};\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar applyToDraft = (editor, selection, op) => {\n  switch (op.type) {\n    case 'insert_node':\n      {\n        var {\n          path,\n          node\n        } = op;\n        var parent = Node.parent(editor, path);\n        var index = path[path.length - 1];\n\n        if (index > parent.children.length) {\n          throw new Error(\"Cannot apply an \\\"insert_node\\\" operation at path [\".concat(path, \"] because the destination is past the end of the node.\"));\n        }\n\n        parent.children.splice(index, 0, node);\n\n        if (selection) {\n          for (var [point, key] of index_es_Range.points(selection)) {\n            selection[key] = Point.transform(point, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'insert_text':\n      {\n        var {\n          path: _path,\n          offset,\n          text\n        } = op;\n        if (text.length === 0) break;\n\n        var _node = Node.leaf(editor, _path);\n\n        var before = _node.text.slice(0, offset);\n\n        var after = _node.text.slice(offset);\n\n        _node.text = before + text + after;\n\n        if (selection) {\n          for (var [_point, _key] of index_es_Range.points(selection)) {\n            selection[_key] = Point.transform(_point, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'merge_node':\n      {\n        var {\n          path: _path2\n        } = op;\n\n        var _node2 = Node.get(editor, _path2);\n\n        var prevPath = Path.previous(_path2);\n        var prev = Node.get(editor, prevPath);\n\n        var _parent = Node.parent(editor, _path2);\n\n        var _index = _path2[_path2.length - 1];\n\n        if (Text.isText(_node2) && Text.isText(prev)) {\n          prev.text += _node2.text;\n        } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n          prev.children.push(..._node2.children);\n        } else {\n          throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n        }\n\n        _parent.children.splice(_index, 1);\n\n        if (selection) {\n          for (var [_point2, _key2] of index_es_Range.points(selection)) {\n            selection[_key2] = Point.transform(_point2, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'move_node':\n      {\n        var {\n          path: _path3,\n          newPath\n        } = op;\n\n        if (Path.isAncestor(_path3, newPath)) {\n          throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n        }\n\n        var _node3 = Node.get(editor, _path3);\n\n        var _parent2 = Node.parent(editor, _path3);\n\n        var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n\n        _parent2.children.splice(_index2, 1);\n\n        var truePath = Path.transform(_path3, op);\n        var newParent = Node.get(editor, Path.parent(truePath));\n        var newIndex = truePath[truePath.length - 1];\n        newParent.children.splice(newIndex, 0, _node3);\n\n        if (selection) {\n          for (var [_point3, _key3] of index_es_Range.points(selection)) {\n            selection[_key3] = Point.transform(_point3, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'remove_node':\n      {\n        var {\n          path: _path4\n        } = op;\n        var _index3 = _path4[_path4.length - 1];\n\n        var _parent3 = Node.parent(editor, _path4);\n\n        _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n\n\n        if (selection) {\n          for (var [_point4, _key4] of index_es_Range.points(selection)) {\n            var result = Point.transform(_point4, op);\n\n            if (selection != null && result != null) {\n              selection[_key4] = result;\n            } else {\n              var _prev = void 0;\n\n              var next = void 0;\n\n              for (var [n, p] of Node.texts(editor)) {\n                if (Path.compare(p, _path4) === -1) {\n                  _prev = [n, p];\n                } else {\n                  next = [n, p];\n                  break;\n                }\n              }\n\n              var preferNext = false;\n\n              if (_prev && next) {\n                if (Path.equals(next[1], _path4)) {\n                  preferNext = !Path.hasPrevious(next[1]);\n                } else {\n                  preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n                }\n              }\n\n              if (_prev && !preferNext) {\n                _point4.path = _prev[1];\n                _point4.offset = _prev[0].text.length;\n              } else if (next) {\n                _point4.path = next[1];\n                _point4.offset = 0;\n              } else {\n                selection = null;\n              }\n            }\n          }\n        }\n\n        break;\n      }\n\n    case 'remove_text':\n      {\n        var {\n          path: _path5,\n          offset: _offset,\n          text: _text\n        } = op;\n        if (_text.length === 0) break;\n\n        var _node4 = Node.leaf(editor, _path5);\n\n        var _before = _node4.text.slice(0, _offset);\n\n        var _after = _node4.text.slice(_offset + _text.length);\n\n        _node4.text = _before + _after;\n\n        if (selection) {\n          for (var [_point5, _key5] of index_es_Range.points(selection)) {\n            selection[_key5] = Point.transform(_point5, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'set_node':\n      {\n        var {\n          path: _path6,\n          properties,\n          newProperties\n        } = op;\n\n        if (_path6.length === 0) {\n          throw new Error(\"Cannot set properties on the root node!\");\n        }\n\n        var _node5 = Node.get(editor, _path6);\n\n        for (var _key6 in newProperties) {\n          if (_key6 === 'children' || _key6 === 'text') {\n            throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n          }\n\n          var value = newProperties[_key6];\n\n          if (value == null) {\n            delete _node5[_key6];\n          } else {\n            _node5[_key6] = value;\n          }\n        } // properties that were previously defined, but are now missing, must be deleted\n\n\n        for (var _key7 in properties) {\n          if (!newProperties.hasOwnProperty(_key7)) {\n            delete _node5[_key7];\n          }\n        }\n\n        break;\n      }\n\n    case 'set_selection':\n      {\n        var {\n          newProperties: _newProperties\n        } = op;\n\n        if (_newProperties == null) {\n          selection = _newProperties;\n        } else {\n          if (selection == null) {\n            if (!index_es_Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n\n            selection = _objectSpread$3({}, _newProperties);\n          }\n\n          for (var _key8 in _newProperties) {\n            var _value = _newProperties[_key8];\n\n            if (_value == null) {\n              if (_key8 === 'anchor' || _key8 === 'focus') {\n                throw new Error(\"Cannot remove the \\\"\".concat(_key8, \"\\\" selection property\"));\n              }\n\n              delete selection[_key8];\n            } else {\n              selection[_key8] = _value;\n            }\n          }\n        }\n\n        break;\n      }\n\n    case 'split_node':\n      {\n        var {\n          path: _path7,\n          position,\n          properties: _properties\n        } = op;\n\n        if (_path7.length === 0) {\n          throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n        }\n\n        var _node6 = Node.get(editor, _path7);\n\n        var _parent4 = Node.parent(editor, _path7);\n\n        var _index4 = _path7[_path7.length - 1];\n        var newNode;\n\n        if (Text.isText(_node6)) {\n          var _before2 = _node6.text.slice(0, position);\n\n          var _after2 = _node6.text.slice(position);\n\n          _node6.text = _before2;\n          newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n            text: _after2\n          });\n        } else {\n          var _before3 = _node6.children.slice(0, position);\n\n          var _after3 = _node6.children.slice(position);\n\n          _node6.children = _before3;\n          newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n            children: _after3\n          });\n        }\n\n        _parent4.children.splice(_index4 + 1, 0, newNode);\n\n        if (selection) {\n          for (var [_point6, _key9] of index_es_Range.points(selection)) {\n            selection[_key9] = Point.transform(_point6, op);\n          }\n        }\n\n        break;\n      }\n  }\n\n  return selection;\n}; // eslint-disable-next-line no-redeclare\n\n\nvar GeneralTransforms = {\n  /**\r\n   * Transform the editor by an operation.\r\n   */\n  transform(editor, op) {\n    editor.children = ln(editor.children);\n    var selection = editor.selection && ln(editor.selection);\n\n    try {\n      selection = applyToDraft(editor, selection, op);\n    } finally {\n      editor.children = dn(editor.children);\n\n      if (selection) {\n        editor.selection = r(selection) ? dn(selection) : selection;\n      } else {\n        editor.selection = null;\n      }\n    }\n  }\n\n};\n\nvar _excluded = [\"text\"],\n    _excluded2 = [\"children\"];\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar NodeTransforms = {\n  /**\r\n   * Insert nodes at a specific location in the Editor.\r\n   */\n  insertNodes(editor, nodes) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false,\n        mode = 'lowest'\n      } = options;\n      var {\n        at,\n        match,\n        select\n      } = options;\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes];\n      }\n\n      if (nodes.length === 0) {\n        return;\n      }\n\n      var [node] = nodes; // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection;\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, []);\n        } else {\n          at = [0];\n        }\n\n        select = true;\n      }\n\n      if (select == null) {\n        select = false;\n      }\n\n      if (index_es_Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at, {\n            voids\n          });\n        }\n\n        if (index_es_Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end] = index_es_Range.edges(at);\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = n => Text.isText(n);\n          } else if (editor.isInline(node)) {\n            match = n => Text.isText(n) || Editor.isInline(editor, n);\n          } else {\n            match = n => Editor.isBlock(editor, n);\n          }\n        }\n\n        var [entry] = Editor.nodes(editor, {\n          at: at.path,\n          match,\n          mode,\n          voids\n        });\n\n        if (entry) {\n          var [, _matchPath] = entry;\n          var pathRef = Editor.pathRef(editor, _matchPath);\n          var isAtEnd = Editor.isEnd(editor, at, _matchPath);\n          Transforms.splitNodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n          });\n          var path = pathRef.unref();\n          at = isAtEnd ? Path.next(path) : path;\n        } else {\n          return;\n        }\n      }\n\n      var parentPath = Path.parent(at);\n      var index = at[at.length - 1];\n\n      if (!voids && Editor.void(editor, {\n        at: parentPath\n      })) {\n        return;\n      }\n\n      for (var _node of nodes) {\n        var _path = parentPath.concat(index);\n\n        index++;\n        editor.apply({\n          type: 'insert_node',\n          path: _path,\n          node: _node\n        });\n        at = Path.next(at);\n      }\n\n      at = Path.previous(at);\n\n      if (select) {\n        var point = Editor.end(editor, at);\n\n        if (point) {\n          Transforms.select(editor, point);\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */\n  liftNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false\n      } = options;\n      var {\n        match\n      } = options;\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var matches = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(matches, _ref => {\n        var [, p] = _ref;\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n\n        if (path.length < 2) {\n          throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n        }\n\n        var parentNodeEntry = Editor.node(editor, Path.parent(path));\n        var [parent, parentPath] = parentNodeEntry;\n        var index = path[path.length - 1];\n        var {\n          length\n        } = parent.children;\n\n        if (length === 1) {\n          var toPath = Path.next(parentPath);\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: toPath,\n            voids\n          });\n          Transforms.removeNodes(editor, {\n            at: parentPath,\n            voids\n          });\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: parentPath,\n            voids\n          });\n        } else if (index === length - 1) {\n          var _toPath = Path.next(parentPath);\n\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath,\n            voids\n          });\n        } else {\n          var splitPath = Path.next(path);\n\n          var _toPath2 = Path.next(parentPath);\n\n          Transforms.splitNodes(editor, {\n            at: splitPath,\n            voids\n          });\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath2,\n            voids\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */\n  mergeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        match,\n        at = editor.selection\n      } = options;\n      var {\n        hanging = false,\n        voids = false,\n        mode = 'lowest'\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var [parent] = Editor.parent(editor, at);\n\n          match = n => parent.children.includes(n);\n        } else {\n          match = n => Editor.isBlock(editor, n);\n        }\n      }\n\n      if (!hanging && index_es_Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at, {\n          voids\n        });\n      }\n\n      if (index_es_Range.isRange(at)) {\n        if (index_es_Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end] = index_es_Range.edges(at);\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n\n          if (options.at == null) {\n            Transforms.select(editor, at);\n          }\n        }\n      }\n\n      var [current] = Editor.nodes(editor, {\n        at,\n        match,\n        voids,\n        mode\n      });\n      var prev = Editor.previous(editor, {\n        at,\n        match,\n        voids,\n        mode\n      });\n\n      if (!current || !prev) {\n        return;\n      }\n\n      var [node, path] = current;\n      var [prevNode, prevPath] = prev;\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return;\n      }\n\n      var newPath = Path.next(prevPath);\n      var commonPath = Path.common(path, prevPath);\n      var isPreviousSibling = Path.isSibling(path, prevPath);\n      var levels = Array.from(Editor.levels(editor, {\n        at: path\n      }), _ref2 => {\n        var [n] = _ref2;\n        return n;\n      }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n\n      var emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: n => levels.includes(n) && hasSingleChildNest(editor, n)\n      });\n      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n      var properties;\n      var position; // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        var rest = _objectWithoutProperties(node, _excluded);\n\n        position = prevNode.text.length;\n        properties = rest;\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        var rest = _objectWithoutProperties(node, _excluded2);\n\n        position = prevNode.children.length;\n        properties = rest;\n      } else {\n        throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n      } // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n\n\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: newPath,\n          voids\n        });\n      } // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n\n\n      if (emptyRef) {\n        Transforms.removeNodes(editor, {\n          at: emptyRef.current,\n          voids\n        });\n      } // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n      // if prevNode is first child in parent,don't remove it.\n\n\n      if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '' && prevPath[prevPath.length - 1] !== 0) {\n        Transforms.removeNodes(editor, {\n          at: prevPath,\n          voids\n        });\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position,\n          properties\n        });\n      }\n\n      if (emptyRef) {\n        emptyRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Move the nodes at a location to a new location.\r\n   */\n  moveNodes(editor, options) {\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        to,\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false\n      } = options;\n      var {\n        match\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      var toRef = Editor.pathRef(editor, to);\n      var targets = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(targets, _ref3 => {\n        var [, p] = _ref3;\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n        var newPath = toRef.current;\n\n        if (path.length !== 0) {\n          editor.apply({\n            type: 'move_node',\n            path,\n            newPath\n          });\n        }\n\n        if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n          // When performing a sibling move to a later index, the path at the destination is shifted\n          // to before the insertion point instead of after. To ensure our group of nodes are inserted\n          // in the correct order we increment toRef to account for that\n          toRef.current = Path.next(toRef.current);\n        }\n      }\n\n      toRef.unref();\n    });\n  },\n\n  /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */\n  removeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false,\n        mode = 'lowest'\n      } = options;\n      var {\n        at = editor.selection,\n        match\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (!hanging && index_es_Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at, {\n          voids\n        });\n      }\n\n      var depths = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(depths, _ref4 => {\n        var [, p] = _ref4;\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n\n        if (path) {\n          var [node] = Editor.node(editor, path);\n          editor.apply({\n            type: 'remove_node',\n            path,\n            node\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Set new properties on the nodes at a location.\r\n   */\n  setNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        match,\n        at = editor.selection,\n        compare,\n        merge\n      } = options;\n      var {\n        hanging = false,\n        mode = 'lowest',\n        split = false,\n        voids = false\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (!hanging && index_es_Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at, {\n          voids\n        });\n      }\n\n      if (split && index_es_Range.isRange(at)) {\n        if (index_es_Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n          // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n          // set that won't get normalized away\n          return;\n        }\n\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n        var [start, end] = index_es_Range.edges(at);\n        var splitMode = mode === 'lowest' ? 'lowest' : 'highest';\n        var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          mode: splitMode,\n          voids,\n          always: !endAtEndOfNode\n        });\n        var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          mode: splitMode,\n          voids,\n          always: !startAtStartOfNode\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      if (!compare) {\n        compare = (prop, nodeProp) => prop !== nodeProp;\n      }\n\n      for (var [node, path] of Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      })) {\n        var properties = {};\n        var newProperties = {}; // You can't set properties on the editor node.\n\n        if (path.length === 0) {\n          continue;\n        }\n\n        var hasChanges = false;\n\n        for (var k in props) {\n          if (k === 'children' || k === 'text') {\n            continue;\n          }\n\n          if (compare(props[k], node[k])) {\n            hasChanges = true; // Omit new properties from the old properties list\n\n            if (node.hasOwnProperty(k)) properties[k] = node[k]; // Omit properties that have been removed from the new properties list\n\n            if (merge) {\n              if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n            } else {\n              if (props[k] != null) newProperties[k] = props[k];\n            }\n          }\n        }\n\n        if (hasChanges) {\n          editor.apply({\n            type: 'set_node',\n            path,\n            properties,\n            newProperties\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Split the nodes at a specific location.\r\n   */\n  splitNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = 'lowest',\n        voids = false\n      } = options;\n      var {\n        match,\n        at = editor.selection,\n        height = 0,\n        always = false\n      } = options;\n\n      if (match == null) {\n        match = n => Editor.isBlock(editor, n);\n      }\n\n      if (index_es_Range.isRange(at)) {\n        at = deleteRange(editor, at);\n      } // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n\n\n      if (Path.isPath(at)) {\n        var path = at;\n        var point = Editor.point(editor, path);\n        var [parent] = Editor.parent(editor, path);\n\n        match = n => n === parent;\n\n        height = point.path.length - path.length + 1;\n        at = point;\n        always = true;\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward'\n      });\n      var afterRef;\n\n      try {\n        var [highest] = Editor.nodes(editor, {\n          at,\n          match,\n          mode,\n          voids\n        });\n\n        if (!highest) {\n          return;\n        }\n\n        var voidMatch = Editor.void(editor, {\n          at,\n          mode: 'highest'\n        });\n        var nudge = 0;\n\n        if (!voids && voidMatch) {\n          var [voidNode, voidPath] = voidMatch;\n\n          if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n            var after = Editor.after(editor, voidPath);\n\n            if (!after) {\n              var text = {\n                text: ''\n              };\n              var afterPath = Path.next(voidPath);\n              Transforms.insertNodes(editor, text, {\n                at: afterPath,\n                voids\n              });\n              after = Editor.point(editor, afterPath);\n            }\n\n            at = after;\n            always = true;\n          }\n\n          var siblingHeight = at.path.length - voidPath.length;\n          height = siblingHeight + 1;\n          always = true;\n        }\n\n        afterRef = Editor.pointRef(editor, at);\n        var depth = at.path.length - height;\n        var [, highestPath] = highest;\n        var lowestPath = at.path.slice(0, depth);\n        var position = height === 0 ? at.offset : at.path[depth] + nudge;\n\n        for (var [node, _path2] of Editor.levels(editor, {\n          at: lowestPath,\n          reverse: true,\n          voids\n        })) {\n          var split = false;\n\n          if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Editor.isVoid(editor, node)) {\n            break;\n          }\n\n          var _point = beforeRef.current;\n          var isEnd = Editor.isEnd(editor, _point, _path2);\n\n          if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {\n            split = true;\n            var properties = Node.extractProps(node);\n            editor.apply({\n              type: 'split_node',\n              path: _path2,\n              position,\n              properties\n            });\n          }\n\n          position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);\n        }\n\n        if (options.at == null) {\n          var _point2 = afterRef.current || Editor.end(editor, []);\n\n          Transforms.select(editor, _point2);\n        }\n      } finally {\n        var _afterRef;\n\n        beforeRef.unref();\n        (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Unset properties on the nodes at a location.\r\n   */\n  unsetNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!Array.isArray(props)) {\n      props = [props];\n    }\n\n    var obj = {};\n\n    for (var key of props) {\n      obj[key] = null;\n    }\n\n    Transforms.setNodes(editor, obj, options);\n  },\n\n  /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */\n  unwrapNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = 'lowest',\n        split = false,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection,\n        match\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      var rangeRef = index_es_Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n      var matches = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(matches, _ref5 => {\n        var [, p] = _ref5;\n        return Editor.pathRef(editor, p);\n      } // unwrapNode will call liftNode which does not support splitting the node when nested.\n      // If we do not reverse the order and call it from top to the bottom, it will remove all blocks\n      // that wrap target node. So we reverse the order.\n      ).reverse();\n\n      var _loop = function _loop(pathRef) {\n        var path = pathRef.unref();\n        var [node] = Editor.node(editor, path);\n        var range = Editor.range(editor, path);\n\n        if (split && rangeRef) {\n          range = index_es_Range.intersection(rangeRef.current, range);\n        }\n\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: n => Element.isAncestor(node) && node.children.includes(n),\n          voids\n        });\n      };\n\n      for (var pathRef of pathRefs) {\n        _loop(pathRef);\n      }\n\n      if (rangeRef) {\n        rangeRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */\n  wrapNodes(editor, element) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = 'lowest',\n        split = false,\n        voids = false\n      } = options;\n      var {\n        match,\n        at = editor.selection\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at);\n        } else if (editor.isInline(element)) {\n          match = n => Editor.isInline(editor, n) || Text.isText(n);\n        } else {\n          match = n => Editor.isBlock(editor, n);\n        }\n      }\n\n      if (split && index_es_Range.isRange(at)) {\n        var [start, end] = index_es_Range.edges(at);\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          voids\n        });\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          voids\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      var roots = Array.from(Editor.nodes(editor, {\n        at,\n        match: editor.isInline(element) ? n => Editor.isBlock(editor, n) : n => Editor.isEditor(n),\n        mode: 'lowest',\n        voids\n      }));\n\n      for (var [, rootPath] of roots) {\n        var a = index_es_Range.isRange(at) ? index_es_Range.intersection(at, Editor.range(editor, rootPath)) : at;\n\n        if (!a) {\n          continue;\n        }\n\n        var matches = Array.from(Editor.nodes(editor, {\n          at: a,\n          match,\n          mode,\n          voids\n        }));\n\n        if (matches.length > 0) {\n          var _ret = function () {\n            var [first] = matches;\n            var last = matches[matches.length - 1];\n            var [, firstPath] = first;\n            var [, lastPath] = last;\n\n            if (firstPath.length === 0 && lastPath.length === 0) {\n              // if there's no matching parent - usually means the node is an editor - don't do anything\n              return \"continue\";\n            }\n\n            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n            var range = Editor.range(editor, firstPath, lastPath);\n            var commonNodeEntry = Editor.node(editor, commonPath);\n            var [commonNode] = commonNodeEntry;\n            var depth = commonPath.length + 1;\n            var wrapperPath = Path.next(lastPath.slice(0, depth));\n\n            var wrapper = _objectSpread$2(_objectSpread$2({}, element), {}, {\n              children: []\n            });\n\n            Transforms.insertNodes(editor, wrapper, {\n              at: wrapperPath,\n              voids\n            });\n            Transforms.moveNodes(editor, {\n              at: range,\n              match: n => Element.isAncestor(commonNode) && commonNode.children.includes(n),\n              to: wrapperPath.concat(0),\n              voids\n            });\n          }();\n\n          if (_ret === \"continue\") continue;\n        }\n      }\n    });\n  }\n\n};\n\nvar hasSingleChildNest = (editor, node) => {\n  if (Element.isElement(node)) {\n    var element = node;\n\n    if (Editor.isVoid(editor, node)) {\n      return true;\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0]);\n    } else {\n      return false;\n    }\n  } else if (Editor.isEditor(node)) {\n    return false;\n  } else {\n    return true;\n  }\n};\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */\n\n\nvar deleteRange = (editor, range) => {\n  if (index_es_Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var [, end] = index_es_Range.edges(range);\n    var pointRef = Editor.pointRef(editor, end);\n    Transforms.delete(editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\n\nvar matchPath = (editor, path) => {\n  var [node] = Editor.node(editor, path);\n  return n => n === node;\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar SelectionTransforms = {\n  /**\r\n   * Collapse the selection.\r\n   */\n  collapse(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      edge = 'anchor'\n    } = options;\n    var {\n      selection\n    } = editor;\n\n    if (!selection) {\n      return;\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor);\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus);\n    } else if (edge === 'start') {\n      var [start] = index_es_Range.edges(selection);\n      Transforms.select(editor, start);\n    } else if (edge === 'end') {\n      var [, end] = index_es_Range.edges(selection);\n      Transforms.select(editor, end);\n    }\n  },\n\n  /**\r\n   * Unset the selection.\r\n   */\n  deselect(editor) {\n    var {\n      selection\n    } = editor;\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null\n      });\n    }\n  },\n\n  /**\r\n   * Move the selection's point forward or backward.\r\n   */\n  move(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      selection\n    } = editor;\n    var {\n      distance = 1,\n      unit = 'character',\n      reverse = false\n    } = options;\n    var {\n      edge = null\n    } = options;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = index_es_Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = index_es_Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var {\n      anchor,\n      focus\n    } = selection;\n    var opts = {\n      distance,\n      unit\n    };\n    var props = {};\n\n    if (edge == null || edge === 'anchor') {\n      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n\n      if (point) {\n        props.anchor = point;\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n\n      if (_point) {\n        props.focus = _point;\n      }\n    }\n\n    Transforms.setSelection(editor, props);\n  },\n\n  /**\r\n   * Set the selection to a new value.\r\n   */\n  select(editor, target) {\n    var {\n      selection\n    } = editor;\n    target = Editor.range(editor, target);\n\n    if (selection) {\n      Transforms.setSelection(editor, target);\n      return;\n    }\n\n    if (!index_es_Range.isRange(target)) {\n      throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target\n    });\n  },\n\n  /**\r\n   * Set new properties on one of the selection's points.\r\n   */\n  setPoint(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      selection\n    } = editor;\n    var {\n      edge = 'both'\n    } = options;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = index_es_Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = index_es_Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var {\n      anchor,\n      focus\n    } = selection;\n    var point = edge === 'anchor' ? anchor : focus;\n    Transforms.setSelection(editor, {\n      [edge === 'anchor' ? 'anchor' : 'focus']: _objectSpread$1(_objectSpread$1({}, point), props)\n    });\n  },\n\n  /**\r\n   * Set new properties on the selection.\r\n   */\n  setSelection(editor, props) {\n    var {\n      selection\n    } = editor;\n    var oldProps = {};\n    var newProps = {};\n\n    if (!selection) {\n      return;\n    }\n\n    for (var k in props) {\n      if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n        oldProps[k] = selection[k];\n        newProps[k] = props[k];\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps\n      });\n    }\n  }\n\n};\n\nvar TextTransforms = {\n  /**\r\n   * Delete content in the editor.\r\n   */\n  delete(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        reverse = false,\n        unit = 'character',\n        distance = 1,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection,\n        hanging = false\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      var isCollapsed = false;\n\n      if (index_es_Range.isRange(at) && index_es_Range.isCollapsed(at)) {\n        isCollapsed = true;\n        at = at.anchor;\n      }\n\n      if (Point.isPoint(at)) {\n        var furthestVoid = Editor.void(editor, {\n          at,\n          mode: 'highest'\n        });\n\n        if (!voids && furthestVoid) {\n          var [, voidPath] = furthestVoid;\n          at = voidPath;\n        } else {\n          var opts = {\n            unit,\n            distance\n          };\n          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n          at = {\n            anchor: at,\n            focus: target\n          };\n          hanging = true;\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, {\n          at,\n          voids\n        });\n        return;\n      }\n\n      if (index_es_Range.isCollapsed(at)) {\n        return;\n      }\n\n      if (!hanging) {\n        var [, _end] = index_es_Range.edges(at);\n        var endOfDoc = Editor.end(editor, []);\n\n        if (!Point.equals(_end, endOfDoc)) {\n          at = Editor.unhangRange(editor, at, {\n            voids\n          });\n        }\n      }\n\n      var [start, end] = index_es_Range.edges(at);\n      var startBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: start,\n        voids\n      });\n      var endBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: end,\n        voids\n      });\n      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n      var isSingleText = Path.equals(start.path, end.path);\n      var startVoid = voids ? null : Editor.void(editor, {\n        at: start,\n        mode: 'highest'\n      });\n      var endVoid = voids ? null : Editor.void(editor, {\n        at: end,\n        mode: 'highest'\n      }); // If the start or end points are inside an inline void, nudge them out.\n\n      if (startVoid) {\n        var before = Editor.before(editor, start);\n\n        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n          start = before;\n        }\n      }\n\n      if (endVoid) {\n        var after = Editor.after(editor, end);\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after;\n        }\n      } // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n\n\n      var matches = [];\n      var lastPath;\n\n      for (var entry of Editor.nodes(editor, {\n        at,\n        voids\n      })) {\n        var [node, path] = entry;\n\n        if (lastPath && Path.compare(path, lastPath) === 0) {\n          continue;\n        }\n\n        if (!voids && Editor.isVoid(editor, node) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n          matches.push(entry);\n          lastPath = path;\n        }\n      }\n\n      var pathRefs = Array.from(matches, _ref => {\n        var [, p] = _ref;\n        return Editor.pathRef(editor, p);\n      });\n      var startRef = Editor.pointRef(editor, start);\n      var endRef = Editor.pointRef(editor, end);\n      var removedText = '';\n\n      if (!isSingleText && !startVoid) {\n        var _point = startRef.current;\n        var [_node] = Editor.leaf(editor, _point);\n        var {\n          path: _path\n        } = _point;\n        var {\n          offset\n        } = start;\n\n        var text = _node.text.slice(offset);\n\n        if (text.length > 0) {\n          editor.apply({\n            type: 'remove_text',\n            path: _path,\n            offset,\n            text\n          });\n          removedText = text;\n        }\n      }\n\n      pathRefs.reverse().map(r => r.unref()).filter(r => r !== null).forEach(p => Transforms.removeNodes(editor, {\n        at: p,\n        voids\n      }));\n\n      if (!endVoid) {\n        var _point2 = endRef.current;\n        var [_node2] = Editor.leaf(editor, _point2);\n        var {\n          path: _path2\n        } = _point2;\n\n        var _offset = isSingleText ? start.offset : 0;\n\n        var _text = _node2.text.slice(_offset, end.offset);\n\n        if (_text.length > 0) {\n          editor.apply({\n            type: 'remove_text',\n            path: _path2,\n            offset: _offset,\n            text: _text\n          });\n          removedText = _text;\n        }\n      }\n\n      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids\n        });\n      } // For Thai script, deleting N character(s) backward should delete\n      // N code point(s) instead of an entire grapheme cluster.\n      // Therefore, the remaining code points should be inserted back.\n\n\n      if (isCollapsed && reverse && unit === 'character' && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n        Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n      }\n\n      var startUnref = startRef.unref();\n      var endUnref = endRef.unref();\n      var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point);\n      }\n    });\n  },\n\n  /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */\n  insertFragment(editor, fragment) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection\n      } = options;\n\n      if (!fragment.length) {\n        return;\n      }\n\n      if (!at) {\n        return;\n      } else if (index_es_Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at, {\n            voids\n          });\n        }\n\n        if (index_es_Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end] = index_es_Range.edges(at);\n\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at);\n      }\n\n      if (!voids && Editor.void(editor, {\n        at\n      })) {\n        return;\n      } // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n\n\n      var inlineElementMatch = Editor.above(editor, {\n        at,\n        match: n => Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n\n      if (inlineElementMatch) {\n        var [, _inlinePath] = inlineElementMatch;\n\n        if (Editor.isEnd(editor, at, _inlinePath)) {\n          var after = Editor.after(editor, _inlinePath);\n          at = after;\n        } else if (Editor.isStart(editor, at, _inlinePath)) {\n          var before = Editor.before(editor, _inlinePath);\n          at = before;\n        }\n      }\n\n      var blockMatch = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at,\n        voids\n      });\n      var [, blockPath] = blockMatch;\n      var isBlockStart = Editor.isStart(editor, at, blockPath);\n      var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n      var isBlockEmpty = isBlockStart && isBlockEnd;\n      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n      var mergeEnd = !isBlockEnd;\n      var [, firstPath] = Node.first({\n        children: fragment\n      }, []);\n      var [, lastPath] = Node.last({\n        children: fragment\n      }, []);\n      var matches = [];\n\n      var matcher = _ref2 => {\n        var [n, p] = _ref2;\n        var isRoot = p.length === 0;\n\n        if (isRoot) {\n          return false;\n        }\n\n        if (isBlockEmpty) {\n          return true;\n        }\n\n        if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        return true;\n      };\n\n      for (var entry of Node.nodes({\n        children: fragment\n      }, {\n        pass: matcher\n      })) {\n        if (matcher(entry)) {\n          matches.push(entry);\n        }\n      }\n\n      var starts = [];\n      var middles = [];\n      var ends = [];\n      var starting = true;\n      var hasBlocks = false;\n\n      for (var [node] of matches) {\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false;\n          hasBlocks = true;\n          middles.push(node);\n        } else if (starting) {\n          starts.push(node);\n        } else {\n          ends.push(node);\n        }\n      }\n\n      var [inlineMatch] = Editor.nodes(editor, {\n        at,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n      var [, inlinePath] = inlineMatch;\n      var isInlineStart = Editor.isStart(editor, at, inlinePath);\n      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n      var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.splitNodes(editor, {\n        at,\n        match: n => hasBlocks ? Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),\n        mode: hasBlocks ? 'lowest' : 'highest',\n        always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n        voids\n      });\n      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n\n      if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n        Transforms.delete(editor, {\n          at: blockPath,\n          voids\n        });\n      }\n\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current,\n        match: n => Editor.isBlock(editor, n),\n        mode: 'lowest',\n        voids\n      });\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n\n      if (!options.at) {\n        var path;\n\n        if (ends.length > 0 && endRef.current) {\n          path = Path.previous(endRef.current);\n        } else if (middles.length > 0 && middleRef.current) {\n          path = Path.previous(middleRef.current);\n        } else if (startRef.current) {\n          path = Path.previous(startRef.current);\n        }\n\n        if (path) {\n          var _end2 = Editor.end(editor, path);\n\n          Transforms.select(editor, _end2);\n        }\n      }\n\n      startRef.unref();\n      middleRef.unref();\n      endRef.unref();\n    });\n  },\n\n  /**\r\n   * Insert a string of text in the Editor.\r\n   */\n  insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        voids = false\n      } = options;\n      var {\n        at = editor.selection\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      if (index_es_Range.isRange(at)) {\n        if (index_es_Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end = index_es_Range.end(at);\n\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var start = index_es_Range.start(at);\n          var startRef = Editor.pointRef(editor, start);\n          var endRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at,\n            voids\n          });\n          var startPoint = startRef.unref();\n          var endPoint = endRef.unref();\n          at = startPoint || endPoint;\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n\n      if (!voids && Editor.void(editor, {\n        at\n      })) {\n        return;\n      }\n\n      var {\n        path,\n        offset\n      } = at;\n      if (text.length > 0) editor.apply({\n        type: 'insert_text',\n        path,\n        offset,\n        text\n      });\n    });\n  }\n\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar Transforms = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n\n\n//# sourceMappingURL=index.es.js.map\n\n;// CONCATENATED MODULE: ./node_modules/slate-history/dist/index.es.js\n\n\n\nvar History = {\n  /**\r\n   * Check if a value is a `History` object.\r\n   */\n  isHistory(value) {\n    return isPlainObject(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || Operation.isOperationList(value.redos[0].operations)) && (value.undos.length === 0 || Operation.isOperationList(value.undos[0].operations));\n  }\n\n};\n\n/**\r\n * Weakmaps for attaching state to the editor.\r\n */\n\nvar HISTORY = new WeakMap();\nvar SAVING = new WeakMap();\nvar MERGING = new WeakMap(); // eslint-disable-next-line no-redeclare\n\nvar HistoryEditor = {\n  /**\r\n   * Check if a value is a `HistoryEditor` object.\r\n   */\n  isHistoryEditor(value) {\n    return History.isHistory(value.history) && Editor.isEditor(value);\n  },\n\n  /**\r\n   * Get the merge flag's current value.\r\n   */\n  isMerging(editor) {\n    return MERGING.get(editor);\n  },\n\n  /**\r\n   * Get the saving flag's current value.\r\n   */\n  isSaving(editor) {\n    return SAVING.get(editor);\n  },\n\n  /**\r\n   * Redo to the previous saved state.\r\n   */\n  redo(editor) {\n    editor.redo();\n  },\n\n  /**\r\n   * Undo to the previous saved state.\r\n   */\n  undo(editor) {\n    editor.undo();\n  },\n\n  /**\r\n   * Apply a series of changes inside a synchronous `fn`, without merging any of\r\n   * the new operations into previous save point in the history.\r\n   */\n  withoutMerging(editor, fn) {\n    var prev = HistoryEditor.isMerging(editor);\n    MERGING.set(editor, false);\n    fn();\n    MERGING.set(editor, prev);\n  },\n\n  /**\r\n   * Apply a series of changes inside a synchronous `fn`, without saving any of\r\n   * their operations into the history.\r\n   */\n  withoutSaving(editor, fn) {\n    var prev = HistoryEditor.isSaving(editor);\n    SAVING.set(editor, false);\n    fn();\n    SAVING.set(editor, prev);\n  }\n\n};\n\n/**\r\n * The `withHistory` plugin keeps track of the operation history of a Slate\r\n * editor as operations are applied to it, using undo and redo stacks.\r\n *\r\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\r\n * this plugin.\r\n *\r\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\r\n */\n\nvar withHistory = editor => {\n  var e = editor;\n  var {\n    apply\n  } = e;\n  e.history = {\n    undos: [],\n    redos: []\n  };\n\n  e.redo = () => {\n    var {\n      history\n    } = e;\n    var {\n      redos\n    } = history;\n\n    if (redos.length > 0) {\n      var batch = redos[redos.length - 1];\n\n      if (batch.selectionBefore) {\n        Transforms.setSelection(e, batch.selectionBefore);\n      }\n\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          for (var op of batch.operations) {\n            e.apply(op);\n          }\n        });\n      });\n      history.redos.pop();\n      history.undos.push(batch);\n    }\n  };\n\n  e.undo = () => {\n    var {\n      history\n    } = e;\n    var {\n      undos\n    } = history;\n\n    if (undos.length > 0) {\n      var batch = undos[undos.length - 1];\n      HistoryEditor.withoutSaving(e, () => {\n        Editor.withoutNormalizing(e, () => {\n          var inverseOps = batch.operations.map(Operation.inverse).reverse();\n\n          for (var op of inverseOps) {\n            e.apply(op);\n          }\n\n          if (batch.selectionBefore) {\n            Transforms.setSelection(e, batch.selectionBefore);\n          }\n        });\n      });\n      history.redos.push(batch);\n      history.undos.pop();\n    }\n  };\n\n  e.apply = op => {\n    var {\n      operations,\n      history\n    } = e;\n    var {\n      undos\n    } = history;\n    var lastBatch = undos[undos.length - 1];\n    var lastOp = lastBatch && lastBatch.operations[lastBatch.operations.length - 1];\n    var save = HistoryEditor.isSaving(e);\n    var merge = HistoryEditor.isMerging(e);\n\n    if (save == null) {\n      save = shouldSave(op);\n    }\n\n    if (save) {\n      if (merge == null) {\n        if (lastBatch == null) {\n          merge = false;\n        } else if (operations.length !== 0) {\n          merge = true;\n        } else {\n          merge = shouldMerge(op, lastOp);\n        }\n      }\n\n      if (lastBatch && merge) {\n        lastBatch.operations.push(op);\n      } else {\n        var batch = {\n          operations: [op],\n          selectionBefore: e.selection\n        };\n        undos.push(batch);\n      }\n\n      while (undos.length > 100) {\n        undos.shift();\n      }\n\n      history.redos = [];\n    }\n\n    apply(op);\n  };\n\n  return e;\n};\n/**\r\n * Check whether to merge an operation into the previous operation.\r\n */\n\nvar shouldMerge = (op, prev) => {\n  if (prev && op.type === 'insert_text' && prev.type === 'insert_text' && op.offset === prev.offset + prev.text.length && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n\n  if (prev && op.type === 'remove_text' && prev.type === 'remove_text' && op.offset + op.text.length === prev.offset && Path.equals(op.path, prev.path)) {\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Check whether an operation needs to be saved to the history.\r\n */\n\n\nvar shouldSave = (op, prev) => {\n  if (op.type === 'set_selection') {\n    return false;\n  }\n\n  return true;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n\n// EXTERNAL MODULE: ./node_modules/direction/index.js\nvar direction = __webpack_require__(6907);\nvar direction_default = /*#__PURE__*/__webpack_require__.n(direction);\n// EXTERNAL MODULE: ./node_modules/lodash/debounce.js\nvar debounce = __webpack_require__(3279);\nvar debounce_default = /*#__PURE__*/__webpack_require__.n(debounce);\n// EXTERNAL MODULE: ./node_modules/lodash/throttle.js\nvar throttle = __webpack_require__(3493);\nvar throttle_default = /*#__PURE__*/__webpack_require__.n(throttle);\n;// CONCATENATED MODULE: ./node_modules/compute-scroll-into-view/dist/index.mjs\nfunction dist_t(t){return\"object\"==typeof t&&null!=t&&1===t.nodeType}function dist_e(t,e){return(!e||\"hidden\"!==t)&&\"visible\"!==t&&\"clip\"!==t}function dist_n(t,n){if(t.clientHeight<t.scrollHeight||t.clientWidth<t.scrollWidth){var r=getComputedStyle(t,null);return dist_e(r.overflowY,n)||dist_e(r.overflowX,n)||function(t){var e=function(t){if(!t.ownerDocument||!t.ownerDocument.defaultView)return null;try{return t.ownerDocument.defaultView.frameElement}catch(t){return null}}(t);return!!e&&(e.clientHeight<t.scrollHeight||e.clientWidth<t.scrollWidth)}(t)}return!1}function dist_r(t,e,n,r,i,o,l,d){return o<t&&l>e||o>t&&l<e?0:o<=t&&d<=n||l>=e&&d>=n?o-t-r:l>e&&d<n||o<t&&d>n?l-e+i:0}var dist_i=function(e,i){var o=window,l=i.scrollMode,d=i.block,f=i.inline,h=i.boundary,u=i.skipOverflowHiddenElements,s=\"function\"==typeof h?h:function(t){return t!==h};if(!dist_t(e))throw new TypeError(\"Invalid target\");for(var a,c,g=document.scrollingElement||document.documentElement,p=[],m=e;dist_t(m)&&s(m);){if((m=null==(c=(a=m).parentElement)?a.getRootNode().host||null:c)===g){p.push(m);break}null!=m&&m===document.body&&dist_n(m)&&!dist_n(document.documentElement)||null!=m&&dist_n(m,u)&&p.push(m)}for(var w=o.visualViewport?o.visualViewport.width:innerWidth,v=o.visualViewport?o.visualViewport.height:innerHeight,W=window.scrollX||pageXOffset,H=window.scrollY||pageYOffset,b=e.getBoundingClientRect(),y=b.height,E=b.width,M=b.top,V=b.right,x=b.bottom,I=b.left,C=\"start\"===d||\"nearest\"===d?M:\"end\"===d?x:M+y/2,R=\"center\"===f?I+E/2:\"end\"===f?V:I,T=[],k=0;k<p.length;k++){var B=p[k],D=B.getBoundingClientRect(),O=D.height,X=D.width,Y=D.top,L=D.right,S=D.bottom,j=D.left;if(\"if-needed\"===l&&M>=0&&I>=0&&x<=v&&V<=w&&M>=Y&&x<=S&&I>=j&&V<=L)return T;var N=getComputedStyle(B),q=parseInt(N.borderLeftWidth,10),z=parseInt(N.borderTopWidth,10),A=parseInt(N.borderRightWidth,10),F=parseInt(N.borderBottomWidth,10),G=0,J=0,K=\"offsetWidth\"in B?B.offsetWidth-B.clientWidth-q-A:0,P=\"offsetHeight\"in B?B.offsetHeight-B.clientHeight-z-F:0,Q=\"offsetWidth\"in B?0===B.offsetWidth?0:X/B.offsetWidth:0,U=\"offsetHeight\"in B?0===B.offsetHeight?0:O/B.offsetHeight:0;if(g===B)G=\"start\"===d?C:\"end\"===d?C-v:\"nearest\"===d?dist_r(H,H+v,v,z,F,H+C,H+C+y,y):C-v/2,J=\"start\"===f?R:\"center\"===f?R-w/2:\"end\"===f?R-w:dist_r(W,W+w,w,q,A,W+R,W+R+E,E),G=Math.max(0,G+H),J=Math.max(0,J+W);else{G=\"start\"===d?C-Y-z:\"end\"===d?C-S+F+P:\"nearest\"===d?dist_r(Y,S,O,z,F+P,C,C+y,y):C-(Y+O/2)+P/2,J=\"start\"===f?R-j-q:\"center\"===f?R-(j+X/2)+K/2:\"end\"===f?R-L+A+K:dist_r(j,L,X,q,A+K,R,R+E,E);var Z=B.scrollLeft,$=B.scrollTop;C+=$-(G=Math.max(0,Math.min($+G/U,B.scrollHeight-O/U+P))),R+=Z-(J=Math.max(0,Math.min(Z+J/Q,B.scrollWidth-X/Q+K)))}T.push({el:B,top:G,left:J})}return T};\n//# sourceMappingURL=index.mjs.map\n\n;// CONCATENATED MODULE: ./node_modules/scroll-into-view-if-needed/es/index.js\n\nfunction isOptionsObject(options) {\n  return options === Object(options) && Object.keys(options).length !== 0;\n}\nfunction defaultBehavior(actions, behavior) {\n  if (behavior === void 0) {\n    behavior = 'auto';\n  }\n  var canSmoothScroll = ('scrollBehavior' in document.body.style);\n  actions.forEach(function (_ref) {\n    var el = _ref.el,\n      top = _ref.top,\n      left = _ref.left;\n    if (el.scroll && canSmoothScroll) {\n      el.scroll({\n        top: top,\n        left: left,\n        behavior: behavior\n      });\n    } else {\n      el.scrollTop = top;\n      el.scrollLeft = left;\n    }\n  });\n}\nfunction getOptions(options) {\n  if (options === false) {\n    return {\n      block: 'end',\n      inline: 'nearest'\n    };\n  }\n  if (isOptionsObject(options)) {\n    return options;\n  }\n  return {\n    block: 'start',\n    inline: 'nearest'\n  };\n}\nfunction scrollIntoView(target, options) {\n  var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);\n  if (isOptionsObject(options) && typeof options.behavior === 'function') {\n    return options.behavior(isTargetAttached ? dist_i(target, options) : []);\n  }\n  if (!isTargetAttached) {\n    return;\n  }\n  var computeOptions = getOptions(options);\n  return defaultBehavior(dist_i(target, computeOptions), computeOptions.behavior);\n}\n/* harmony default export */ var es = (scrollIntoView);\n// EXTERNAL MODULE: ./node_modules/is-hotkey/lib/index.js\nvar lib = __webpack_require__(8156);\n// EXTERNAL MODULE: ./node_modules/react-dom/index.js\nvar react_dom = __webpack_require__(3935);\n;// CONCATENATED MODULE: ./node_modules/slate-react/dist/index.es.js\n\n\n\n\n\n\n\n\n\nfunction index_es_defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction index_es_objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction index_es_objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = index_es_objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n/**\r\n * An auto-incrementing identifier for keys.\r\n */\nvar index_es_n = 0;\n/**\r\n * A class that keeps track of a key string. We use a full class here because we\r\n * want to be able to use them as keys in `WeakMap` objects.\r\n */\n\nclass Key {\n  constructor() {\n    this.id = \"\".concat(index_es_n++);\n  }\n\n}\n\n/**\r\n * Two weak maps that allow us rebuild a path given a node. They are populated\r\n * at render time such that after a render occurs we can always backtrack.\r\n */\nvar NODE_TO_INDEX = new WeakMap();\nvar NODE_TO_PARENT = new WeakMap();\n/**\r\n * Weak maps that allow us to go between Slate nodes and DOM nodes. These\r\n * are used to resolve DOM event-related logic into Slate actions.\r\n */\n\nvar EDITOR_TO_WINDOW = new WeakMap();\nvar EDITOR_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_PLACEHOLDER_ELEMENT = new WeakMap();\nvar ELEMENT_TO_NODE = new WeakMap();\nvar NODE_TO_ELEMENT = new WeakMap();\nvar NODE_TO_KEY = new WeakMap();\nvar EDITOR_TO_KEY_TO_ELEMENT = new WeakMap();\nvar EDITOR_TO_STYLE_ELEMENT = new WeakMap();\n/**\r\n * Weak maps for storing editor-related state.\r\n */\n\nvar IS_READ_ONLY = new WeakMap();\nvar IS_FOCUSED = new WeakMap();\nvar IS_COMPOSING = new WeakMap();\nvar EDITOR_TO_USER_SELECTION = new WeakMap();\n/**\r\n * Weak map for associating the context `onChange` context with the plugin.\r\n */\n\nvar EDITOR_TO_ON_CHANGE = new WeakMap();\n/**\r\n * Weak maps for saving pending state on composition stage.\r\n */\n\nvar EDITOR_TO_SCHEDULE_FLUSH = new WeakMap();\nvar EDITOR_TO_PENDING_INSERTION_MARKS = new WeakMap();\nvar EDITOR_TO_USER_MARKS = new WeakMap();\n/**\r\n * Android input handling specific weak-maps\r\n */\n\nvar EDITOR_TO_PENDING_DIFFS = new WeakMap();\nvar EDITOR_TO_PENDING_ACTION = new WeakMap();\nvar EDITOR_TO_PENDING_SELECTION = new WeakMap();\nvar EDITOR_TO_FORCE_RENDER = new WeakMap();\n/**\r\n * Symbols.\r\n */\n\nvar PLACEHOLDER_SYMBOL = Symbol('placeholder');\nvar MARK_PLACEHOLDER_SYMBOL = Symbol('mark-placeholder');\n\n/**\r\n * Types.\r\n */\nvar DOMText = globalThis.Text;\n/**\r\n * Returns the host window of a DOM node\r\n */\n\nvar getDefaultView = value => {\n  return value && value.ownerDocument && value.ownerDocument.defaultView || null;\n};\n/**\r\n * Check if a DOM node is a comment node.\r\n */\n\nvar isDOMComment = value => {\n  return isDOMNode(value) && value.nodeType === 8;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */\n\nvar isDOMElement = value => {\n  return isDOMNode(value) && value.nodeType === 1;\n};\n/**\r\n * Check if a value is a DOM node.\r\n */\n\nvar isDOMNode = value => {\n  var window = getDefaultView(value);\n  return !!window && value instanceof window.Node;\n};\n/**\r\n * Check if a value is a DOM selection.\r\n */\n\nvar isDOMSelection = value => {\n  var window = value && value.anchorNode && getDefaultView(value.anchorNode);\n  return !!window && value instanceof window.Selection;\n};\n/**\r\n * Check if a DOM node is an element node.\r\n */\n\nvar isDOMText = value => {\n  return isDOMNode(value) && value.nodeType === 3;\n};\n/**\r\n * Checks whether a paste event is a plaintext-only event.\r\n */\n\nvar isPlainTextOnlyPaste = event => {\n  return event.clipboardData && event.clipboardData.getData('text/plain') !== '' && event.clipboardData.types.length === 1;\n};\n/**\r\n * Normalize a DOM point so that it always refers to a text node.\r\n */\n\nvar normalizeDOMPoint = domPoint => {\n  var [node, offset] = domPoint; // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n\n  if (isDOMElement(node) && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var index = isLast ? offset - 1 : offset;\n    [node, index] = getEditableChildAndIndex(node, index, isLast ? 'backward' : 'forward'); // If the editable child found is in front of input offset, we instead seek to its end\n\n    isLast = index < offset; // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n\n    while (isDOMElement(node) && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, isLast ? 'backward' : 'forward');\n    } // Determine the new offset inside the text node.\n\n\n    offset = isLast && node.textContent != null ? node.textContent.length : 0;\n  } // Return the node and offset.\n\n\n  return [node, offset];\n};\n/**\r\n * Determines wether the active element is nested within a shadowRoot\r\n */\n\nvar hasShadowRoot = () => {\n  return !!(window.document.activeElement && window.document.activeElement.shadowRoot);\n};\n/**\r\n * Get the nearest editable child and index at `index` in a `parent`, preferring\r\n * `direction`.\r\n */\n\nvar getEditableChildAndIndex = (parent, index, direction) => {\n  var {\n    childNodes\n  } = parent;\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false; // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n\n  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) {\n      break;\n    }\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    index = i;\n    i += direction === 'forward' ? 1 : -1;\n  }\n\n  return [child, index];\n};\n/**\r\n * Get the nearest editable child at `index` in a `parent`, preferring\r\n * `direction`.\r\n */\n\nvar getEditableChild = (parent, index, direction) => {\n  var [child] = getEditableChildAndIndex(parent, index, direction);\n  return child;\n};\n/**\r\n * Get a plaintext representation of the content of a node, accounting for block\r\n * elements which get a newline appended.\r\n *\r\n * The domNode must be attached to the DOM.\r\n */\n\nvar getPlainText = domNode => {\n  var text = '';\n\n  if (isDOMText(domNode) && domNode.nodeValue) {\n    return domNode.nodeValue;\n  }\n\n  if (isDOMElement(domNode)) {\n    for (var childNode of Array.from(domNode.childNodes)) {\n      text += getPlainText(childNode);\n    }\n\n    var display = getComputedStyle(domNode).getPropertyValue('display');\n\n    if (display === 'block' || display === 'list' || domNode.tagName === 'BR') {\n      text += '\\n';\n    }\n  }\n\n  return text;\n};\n/**\r\n * Get x-slate-fragment attribute from data-slate-fragment\r\n */\n\nvar catchSlateFragment = /data-slate-fragment=\"(.+?)\"/m;\nvar getSlateFragmentAttribute = dataTransfer => {\n  var htmlData = dataTransfer.getData('text/html');\n  var [, fragment] = htmlData.match(catchSlateFragment) || [];\n  return fragment;\n};\n/**\r\n * Check whether a mutation originates from a editable element inside the editor.\r\n */\n\nvar isTrackedMutation = (editor, mutation, batch) => {\n  var {\n    target\n  } = mutation;\n\n  if (isDOMElement(target) && target.matches('[contentEditable=\"false\"]')) {\n    return false;\n  }\n\n  var {\n    document\n  } = ReactEditor.getWindow(editor);\n\n  if (document.contains(target)) {\n    return ReactEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  }\n\n  var parentMutation = batch.find(_ref => {\n    var {\n      addedNodes,\n      removedNodes\n    } = _ref;\n\n    for (var node of addedNodes) {\n      if (node === target || node.contains(target)) {\n        return true;\n      }\n    }\n\n    for (var _node of removedNodes) {\n      if (_node === target || _node.contains(target)) {\n        return true;\n      }\n    }\n  });\n\n  if (!parentMutation || parentMutation === mutation) {\n    return false;\n  } // Target add/remove is tracked. Track the mutation if we track the parent mutation.\n\n\n  return isTrackedMutation(editor, parentMutation, batch);\n};\n\nvar IS_REACT_VERSION_17_OR_ABOVE = parseInt(react.version.split('.')[0], 10) >= 17;\nvar IS_IOS = typeof navigator !== 'undefined' && typeof window !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nvar IS_APPLE = typeof navigator !== 'undefined' && /Mac OS X/.test(navigator.userAgent);\nvar IS_ANDROID = typeof navigator !== 'undefined' && /Android/.test(navigator.userAgent);\nvar IS_FIREFOX = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nvar IS_SAFARI = typeof navigator !== 'undefined' && /Version\\/[\\d\\.]+.*Safari/.test(navigator.userAgent); // \"modern\" Edge was released at 79.x\n\nvar IS_EDGE_LEGACY = typeof navigator !== 'undefined' && /Edge?\\/(?:[0-6][0-9]|[0-7][0-8])(?:\\.)/i.test(navigator.userAgent);\nvar IS_CHROME = typeof navigator !== 'undefined' && /Chrome/i.test(navigator.userAgent); // Native `beforeInput` events don't work well with react on Chrome 75\n// and older, Chrome 76+ can use `beforeInput` though.\n\nvar IS_CHROME_LEGACY = typeof navigator !== 'undefined' && /Chrome?\\/(?:[0-7][0-5]|[0-6][0-9])(?:\\.)/i.test(navigator.userAgent); // Firefox did not support `beforeInput` until `v87`.\n\nvar IS_FIREFOX_LEGACY = typeof navigator !== 'undefined' && /^(?!.*Seamonkey)(?=.*Firefox\\/(?:[0-7][0-9]|[0-8][0-6])(?:\\.)).*/i.test(navigator.userAgent); // qq browser\n\nvar IS_QQBROWSER = typeof navigator !== 'undefined' && /.*QQBrowser/.test(navigator.userAgent); // UC mobile browser\n\nvar IS_UC_MOBILE = typeof navigator !== 'undefined' && /.*UCBrowser/.test(navigator.userAgent); // Wechat browser\n\nvar IS_WECHATBROWSER = typeof navigator !== 'undefined' && /.*Wechat/.test(navigator.userAgent); // Check if DOM is available as React does internally.\n// https://github.com/facebook/react/blob/master/packages/shared/ExecutionEnvironment.js\n\nvar CAN_USE_DOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined'); // COMPAT: Firefox/Edge Legacy don't support the `beforeinput` event\n// Chrome Legacy doesn't support `beforeinput` correctly\n\nvar HAS_BEFORE_INPUT_SUPPORT = !IS_CHROME_LEGACY && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers\ntypeof globalThis !== 'undefined' && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.\ntypeof globalThis.InputEvent.prototype.getTargetRanges === 'function';\n\nvar ReactEditor = {\n  /**\r\n   * Check if the user is currently composing inside the editor.\r\n   */\n  isComposing(editor) {\n    return !!IS_COMPOSING.get(editor);\n  },\n\n  /**\r\n   * Return the host window of the current editor.\r\n   */\n  getWindow(editor) {\n    var window = EDITOR_TO_WINDOW.get(editor);\n\n    if (!window) {\n      throw new Error('Unable to find a host window element for this editor');\n    }\n\n    return window;\n  },\n\n  /**\r\n   * Find a key for a Slate node.\r\n   */\n  findKey(editor, node) {\n    var key = NODE_TO_KEY.get(node);\n\n    if (!key) {\n      key = new Key();\n      NODE_TO_KEY.set(node, key);\n    }\n\n    return key;\n  },\n\n  /**\r\n   * Find the path of Slate node.\r\n   */\n  findPath(editor, node) {\n    var path = [];\n    var child = node;\n\n    while (true) {\n      var parent = NODE_TO_PARENT.get(child);\n\n      if (parent == null) {\n        if (Editor.isEditor(child)) {\n          return path;\n        } else {\n          break;\n        }\n      }\n\n      var i = NODE_TO_INDEX.get(child);\n\n      if (i == null) {\n        break;\n      }\n\n      path.unshift(i);\n      child = parent;\n    }\n\n    throw new Error(\"Unable to find the path for Slate node: \".concat(Scrubber.stringify(node)));\n  },\n\n  /**\r\n   * Find the DOM node that implements DocumentOrShadowRoot for the editor.\r\n   */\n  findDocumentOrShadowRoot(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = el.getRootNode();\n\n    if ((root instanceof Document || root instanceof ShadowRoot) && root.getSelection != null) {\n      return root;\n    }\n\n    return el.ownerDocument;\n  },\n\n  /**\r\n   * Check if the editor is focused.\r\n   */\n  isFocused(editor) {\n    return !!IS_FOCUSED.get(editor);\n  },\n\n  /**\r\n   * Check if the editor is in read-only mode.\r\n   */\n  isReadOnly(editor) {\n    return !!IS_READ_ONLY.get(editor);\n  },\n\n  /**\r\n   * Blur the editor.\r\n   */\n  blur(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, false);\n\n    if (root.activeElement === el) {\n      el.blur();\n    }\n  },\n\n  /**\r\n   * Focus the editor.\r\n   */\n  focus(editor) {\n    var el = ReactEditor.toDOMNode(editor, editor);\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    IS_FOCUSED.set(editor, true);\n\n    if (root.activeElement !== el) {\n      el.focus({\n        preventScroll: true\n      });\n    }\n  },\n\n  /**\r\n   * Deselect the editor.\r\n   */\n  deselect(editor) {\n    var {\n      selection\n    } = editor;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = root.getSelection();\n\n    if (domSelection && domSelection.rangeCount > 0) {\n      domSelection.removeAllRanges();\n    }\n\n    if (selection) {\n      Transforms.deselect(editor);\n    }\n  },\n\n  /**\r\n   * Check if a DOM node is within the editor.\r\n   */\n  hasDOMNode(editor, target) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      editable = false\n    } = options;\n    var editorEl = ReactEditor.toDOMNode(editor, editor);\n    var targetEl; // COMPAT: In Firefox, reading `target.nodeType` will throw an error if\n    // target is originating from an internal \"restricted\" element (e.g. a\n    // stepper arrow on a number input). (2018/05/04)\n    // https://github.com/ianstormtaylor/slate/issues/1819\n\n    try {\n      targetEl = isDOMElement(target) ? target : target.parentElement;\n    } catch (err) {\n      if (!err.message.includes('Permission denied to access property \"nodeType\"')) {\n        throw err;\n      }\n    }\n\n    if (!targetEl) {\n      return false;\n    }\n\n    return targetEl.closest(\"[data-slate-editor]\") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === 'boolean' && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined\n    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable=\"false\"(readOnly)\n    targetEl.closest('[contenteditable=\"false\"]') === editorEl || !!targetEl.getAttribute('data-slate-zero-width'));\n  },\n\n  /**\r\n   * Insert data from a `DataTransfer` into the editor.\r\n   */\n  insertData(editor, data) {\n    editor.insertData(data);\n  },\n\n  /**\r\n   * Insert fragment data from a `DataTransfer` into the editor.\r\n   */\n  insertFragmentData(editor, data) {\n    return editor.insertFragmentData(data);\n  },\n\n  /**\r\n   * Insert text data from a `DataTransfer` into the editor.\r\n   */\n  insertTextData(editor, data) {\n    return editor.insertTextData(data);\n  },\n\n  /**\r\n   * Sets data from the currently selected fragment on a `DataTransfer`.\r\n   */\n  setFragmentData(editor, data, originEvent) {\n    editor.setFragmentData(data, originEvent);\n  },\n\n  /**\r\n   * Find the native DOM element from a Slate node.\r\n   */\n  toDOMNode(editor, node) {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n    var domNode = Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node));\n\n    if (!domNode) {\n      throw new Error(\"Cannot resolve a DOM node from Slate node: \".concat(Scrubber.stringify(node)));\n    }\n\n    return domNode;\n  },\n\n  /**\r\n   * Find a native DOM selection point from a Slate point.\r\n   */\n  toDOMPoint(editor, point) {\n    var [node] = Editor.node(editor, point.path);\n    var el = ReactEditor.toDOMNode(editor, node);\n    var domPoint; // If we're inside a void node, force the offset to 0, otherwise the zero\n    // width spacing character will result in an incorrect offset of 1\n\n    if (Editor[\"void\"](editor, {\n      at: point\n    })) {\n      point = {\n        path: point.path,\n        offset: 0\n      };\n    } // For each leaf, we need to isolate its content, which means filtering\n    // to its direct text and zero-width spans. (We have to filter out any\n    // other siblings that may have been rendered alongside them.)\n\n\n    var selector = \"[data-slate-string], [data-slate-zero-width]\";\n    var texts = Array.from(el.querySelectorAll(selector));\n    var start = 0;\n\n    for (var i = 0; i < texts.length; i++) {\n      var text = texts[i];\n      var domNode = text.childNodes[0];\n\n      if (domNode == null || domNode.textContent == null) {\n        continue;\n      }\n\n      var {\n        length\n      } = domNode.textContent;\n      var attr = text.getAttribute('data-slate-length');\n      var trueLength = attr == null ? length : parseInt(attr, 10);\n      var end = start + trueLength; // Prefer putting the selection inside the mark placeholder to ensure\n      // composed text is displayed with the correct marks.\n\n      var nextText = texts[i + 1];\n\n      if (point.offset === end && nextText !== null && nextText !== void 0 && nextText.hasAttribute('data-slate-mark-placeholder')) {\n        var _nextText$textContent;\n\n        var domText = nextText.childNodes[0];\n        domPoint = [// COMPAT: If we don't explicity set the dom point to be on the actual\n        // dom text element, chrome will put the selection behind the actual dom\n        // text element, causing domRange.getBoundingClientRect() calls on a collapsed\n        // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)\n        // which will cause issues when scrolling to it.\n        domText instanceof DOMText ? domText : nextText, (_nextText$textContent = nextText.textContent) !== null && _nextText$textContent !== void 0 && _nextText$textContent.startsWith('\\uFEFF') ? 1 : 0];\n        break;\n      }\n\n      if (point.offset <= end) {\n        var offset = Math.min(length, Math.max(0, point.offset - start));\n        domPoint = [domNode, offset];\n        break;\n      }\n\n      start = end;\n    }\n\n    if (!domPoint) {\n      throw new Error(\"Cannot resolve a DOM point from Slate point: \".concat(Scrubber.stringify(point)));\n    }\n\n    return domPoint;\n  },\n\n  /**\r\n   * Find a native DOM range from a Slate `range`.\r\n   *\r\n   * Notice: the returned range will always be ordinal regardless of the direction of Slate `range` due to DOM API limit.\r\n   *\r\n   * there is no way to create a reverse DOM Range using Range.setStart/setEnd\r\n   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.\r\n   */\n  toDOMRange(editor, range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    var isBackward = index_es_Range.isBackward(range);\n    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);\n    var domFocus = index_es_Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus);\n    var window = ReactEditor.getWindow(editor);\n    var domRange = window.document.createRange();\n    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;\n    var [endNode, endOffset] = isBackward ? domAnchor : domFocus; // A slate Point at zero-width Leaf always has an offset of 0 but a native DOM selection at\n    // zero-width node has an offset of 1 so we have to check if we are in a zero-width node and\n    // adjust the offset accordingly.\n\n    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;\n    var isStartAtZeroWidth = !!startEl.getAttribute('data-slate-zero-width');\n    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;\n    var isEndAtZeroWidth = !!endEl.getAttribute('data-slate-zero-width');\n    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);\n    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);\n    return domRange;\n  },\n\n  /**\r\n   * Find a Slate node from a native DOM `element`.\r\n   */\n  toSlateNode(editor, domNode) {\n    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;\n\n    if (domEl && !domEl.hasAttribute('data-slate-node')) {\n      domEl = domEl.closest(\"[data-slate-node]\");\n    }\n\n    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;\n\n    if (!node) {\n      throw new Error(\"Cannot resolve a Slate node from DOM node: \".concat(domEl));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Get the target range from a DOM `event`.\r\n   */\n  findEventRange(editor, event) {\n    if ('nativeEvent' in event) {\n      event = event.nativeEvent;\n    }\n\n    var {\n      clientX: x,\n      clientY: y,\n      target\n    } = event;\n\n    if (x == null || y == null) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    }\n\n    var node = ReactEditor.toSlateNode(editor, event.target);\n    var path = ReactEditor.findPath(editor, node); // If the drop target is inside a void node, move it into either the\n    // next or previous node, depending on which side the `x` and `y`\n    // coordinates are closest to.\n\n    if (Editor.isVoid(editor, node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrev = editor.isInline(node) ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n      var edge = Editor.point(editor, path, {\n        edge: isPrev ? 'start' : 'end'\n      });\n      var point = isPrev ? Editor.before(editor, edge) : Editor.after(editor, edge);\n\n      if (point) {\n        var _range = Editor.range(editor, point);\n\n        return _range;\n      }\n    } // Else resolve a range from the caret position where the drop occured.\n\n\n    var domRange;\n    var {\n      document\n    } = ReactEditor.getWindow(editor); // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n\n    if (document.caretRangeFromPoint) {\n      domRange = document.caretRangeFromPoint(x, y);\n    } else {\n      var position = document.caretPositionFromPoint(x, y);\n\n      if (position) {\n        domRange = document.createRange();\n        domRange.setStart(position.offsetNode, position.offset);\n        domRange.setEnd(position.offsetNode, position.offset);\n      }\n    }\n\n    if (!domRange) {\n      throw new Error(\"Cannot resolve a Slate range from a DOM event: \".concat(event));\n    } // Resolve a Slate range from the DOM range.\n\n\n    var range = ReactEditor.toSlateRange(editor, domRange, {\n      exactMatch: false,\n      suppressThrow: false\n    });\n    return range;\n  },\n\n  /**\r\n   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.\r\n   */\n  toSlatePoint(editor, domPoint, options) {\n    var {\n      exactMatch,\n      suppressThrow\n    } = options;\n    var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);\n    var parentNode = nearestNode.parentNode;\n    var textNode = null;\n    var offset = 0;\n\n    if (parentNode) {\n      var _domNode$textContent, _domNode$textContent2;\n\n      var editorEl = ReactEditor.toDOMNode(editor, editor);\n      var potentialVoidNode = parentNode.closest('[data-slate-void=\"true\"]'); // Need to ensure that the closest void node is actually a void node\n      // within this editor, and not a void node within some parent editor. This can happen\n      // if this editor is within a void node of another editor (\"nested editors\", like in\n      // the \"Editable Voids\" example on the docs site).\n\n      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;\n      var leafNode = parentNode.closest('[data-slate-leaf]');\n      var domNode = null; // Calculate how far into the text node the `nearestNode` is, so that we\n      // can determine what the offset relative to the text node is.\n\n      if (leafNode) {\n        textNode = leafNode.closest('[data-slate-node=\"text\"]');\n\n        if (textNode) {\n          var window = ReactEditor.getWindow(editor);\n          var range = window.document.createRange();\n          range.setStart(textNode, 0);\n          range.setEnd(nearestNode, nearestOffset);\n          var contents = range.cloneContents();\n          var removals = [...Array.prototype.slice.call(contents.querySelectorAll('[data-slate-zero-width]')), ...Array.prototype.slice.call(contents.querySelectorAll('[contenteditable=false]'))];\n          removals.forEach(el => {\n            // COMPAT: While composing at the start of a text node, some keyboards put\n            // the text content inside the zero width space.\n            if (IS_ANDROID && !exactMatch && el.hasAttribute('data-slate-zero-width') && el.textContent.length > 0 && el.textContext !== '\\uFEFF') {\n              if (el.textContent.startsWith('\\uFEFF')) {\n                el.textContent = el.textContent.slice(1);\n              }\n\n              return;\n            }\n\n            el.parentNode.removeChild(el);\n          }); // COMPAT: Edge has a bug where Range.prototype.toString() will\n          // convert \\n into \\r\\n. The bug causes a loop when slate-react\n          // attempts to reposition its cursor to match the native position. Use\n          // textContent.length instead.\n          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n\n          offset = contents.textContent.length;\n          domNode = textNode;\n        }\n      } else if (voidNode) {\n        // For void nodes, the element with the offset key will be a cousin, not an\n        // ancestor, so find it by going down from the nearest void parent and taking the\n        // first one that isn't inside a nested editor.\n        var leafNodes = voidNode.querySelectorAll('[data-slate-leaf]');\n\n        for (var index = 0; index < leafNodes.length; index++) {\n          var current = leafNodes[index];\n\n          if (ReactEditor.hasDOMNode(editor, current)) {\n            leafNode = current;\n            break;\n          }\n        } // COMPAT: In read-only editors the leaf is not rendered.\n\n\n        if (!leafNode) {\n          offset = 1;\n        } else {\n          textNode = leafNode.closest('[data-slate-node=\"text\"]');\n          domNode = leafNode;\n          offset = domNode.textContent.length;\n          domNode.querySelectorAll('[data-slate-zero-width]').forEach(el => {\n            offset -= el.textContent.length;\n          });\n        }\n      }\n\n      if (domNode && offset === domNode.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,\n      // and we don't add it for line-breaks.\n      IS_ANDROID && domNode.getAttribute('data-slate-zero-width') === 'z' && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.startsWith('\\uFEFF') && (parentNode.hasAttribute('data-slate-zero-width') || IS_FIREFOX && (_domNode$textContent2 = domNode.textContent) !== null && _domNode$textContent2 !== void 0 && _domNode$textContent2.endsWith('\\n\\n'))) {\n        offset--;\n      }\n    }\n\n    if (IS_ANDROID && !textNode && !exactMatch) {\n      var node = parentNode.hasAttribute('data-slate-node') ? parentNode : parentNode.closest('[data-slate-node]');\n\n      if (node && ReactEditor.hasDOMNode(editor, node, {\n        editable: true\n      })) {\n        var _slateNode = ReactEditor.toSlateNode(editor, node);\n\n        var {\n          path: _path,\n          offset: _offset\n        } = Editor.start(editor, ReactEditor.findPath(editor, _slateNode));\n\n        if (!node.querySelector('[data-slate-leaf]')) {\n          _offset = nearestOffset;\n        }\n\n        return {\n          path: _path,\n          offset: _offset\n        };\n      }\n    }\n\n    if (!textNode) {\n      if (suppressThrow) {\n        return null;\n      }\n\n      throw new Error(\"Cannot resolve a Slate point from DOM point: \".concat(domPoint));\n    } // COMPAT: If someone is clicking from one Slate editor into another,\n    // the select event fires twice, once for the old editor's `element`\n    // first, and then afterwards for the correct `element`. (2017/03/03)\n\n\n    var slateNode = ReactEditor.toSlateNode(editor, textNode);\n    var path = ReactEditor.findPath(editor, slateNode);\n    return {\n      path,\n      offset\n    };\n  },\n\n  /**\r\n   * Find a Slate range from a DOM range or selection.\r\n   */\n  toSlateRange(editor, domRange, options) {\n    var {\n      exactMatch,\n      suppressThrow\n    } = options;\n    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;\n    var anchorNode;\n    var anchorOffset;\n    var focusNode;\n    var focusOffset;\n    var isCollapsed;\n\n    if (el) {\n      if (isDOMSelection(domRange)) {\n        anchorNode = domRange.anchorNode;\n        anchorOffset = domRange.anchorOffset;\n        focusNode = domRange.focusNode;\n        focusOffset = domRange.focusOffset; // COMPAT: There's a bug in chrome that always returns `true` for\n        // `isCollapsed` for a Selection that comes from a ShadowRoot.\n        // (2020/08/08)\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n\n        if (IS_CHROME && hasShadowRoot()) {\n          isCollapsed = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;\n        } else {\n          isCollapsed = domRange.isCollapsed;\n        }\n      } else {\n        anchorNode = domRange.startContainer;\n        anchorOffset = domRange.startOffset;\n        focusNode = domRange.endContainer;\n        focusOffset = domRange.endOffset;\n        isCollapsed = domRange.collapsed;\n      }\n    }\n\n    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {\n      throw new Error(\"Cannot resolve a Slate range from DOM range: \".concat(domRange));\n    }\n\n    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {\n      exactMatch,\n      suppressThrow\n    });\n\n    if (!anchor) {\n      return null;\n    }\n\n    var focus = isCollapsed ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset], {\n      exactMatch,\n      suppressThrow\n    });\n\n    if (!focus) {\n      return null;\n    }\n\n    var range = {\n      anchor: anchor,\n      focus: focus\n    }; // if the selection is a hanging range that ends in a void\n    // and the DOM focus is an Element\n    // (meaning that the selection ends before the element)\n    // unhang the range to avoid mistakenly including the void\n\n    if (index_es_Range.isExpanded(range) && index_es_Range.isForward(range) && isDOMElement(focusNode) && Editor[\"void\"](editor, {\n      at: range.focus,\n      mode: 'highest'\n    })) {\n      range = Editor.unhangRange(editor, range, {\n        voids: true\n      });\n    }\n\n    return range;\n  },\n\n  hasRange(editor, range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus.path);\n  },\n\n  /**\r\n   * Check if the target is in the editor.\r\n   */\n  hasTarget(editor, target) {\n    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);\n  },\n\n  /**\r\n   * Check if the target is editable and in the editor.\r\n   */\n  hasEditableTarget(editor, target) {\n    return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {\n      editable: true\n    });\n  },\n\n  /**\r\n   * Check if the target can be selectable\r\n   */\n  hasSelectableTarget(editor, target) {\n    return ReactEditor.hasEditableTarget(editor, target) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, target);\n  },\n\n  /**\r\n   * Check if the target is inside void and in an non-readonly editor.\r\n   */\n  isTargetInsideNonReadonlyVoid(editor, target) {\n    if (IS_READ_ONLY.get(editor)) return false;\n    var slateNode = ReactEditor.hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);\n    return Editor.isVoid(editor, slateNode);\n  },\n\n  /**\r\n   * Experimental and android specific: Flush all pending diffs and cancel composition at the next possible time.\r\n   */\n  androidScheduleFlush(editor) {\n    var _EDITOR_TO_SCHEDULE_F;\n\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(editor)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n  },\n\n  /**\r\n   * Experimental and android specific: Get pending diffs\r\n   */\n  androidPendingDiffs(editor) {\n    return EDITOR_TO_PENDING_DIFFS.get(editor);\n  }\n\n};\n\n/**\r\n * Prevent warning on SSR by falling back to useEffect when DOM isn't available\r\n */\n\nvar useIsomorphicLayoutEffect = CAN_USE_DOM ? react.useLayoutEffect : react.useEffect;\n\nvar index_es_excluded$3 = [\"anchor\", \"focus\"],\n    index_es_excluded2$1 = [\"anchor\", \"focus\"];\nvar shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every(key => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);\n/**\r\n * Check if a list of decorator ranges are equal to another.\r\n *\r\n * PERF: this requires the two lists to also have the ranges inside them in the\r\n * same order, but this is an okay constraint for us since decorations are\r\n * kept in order, and the odd case where they aren't is okay to re-render for.\r\n */\n\nvar isDecoratorRangeListEqual = (list, another) => {\n  if (list.length !== another.length) {\n    return false;\n  }\n\n  for (var i = 0; i < list.length; i++) {\n    var range = list[i];\n    var other = another[i];\n\n    var rangeOwnProps = index_es_objectWithoutProperties(range, index_es_excluded$3);\n\n    var otherOwnProps = index_es_objectWithoutProperties(other, index_es_excluded2$1);\n\n    if (!index_es_Range.equals(range, other) || range[PLACEHOLDER_SYMBOL] !== other[PLACEHOLDER_SYMBOL] || !shallowCompare(rangeOwnProps, otherOwnProps)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\r\n * Leaf content strings.\r\n */\n\nvar index_es_String = props => {\n  var {\n    isLast,\n    leaf,\n    parent,\n    text\n  } = props;\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, text);\n  var parentPath = Path.parent(path);\n  var isMarkPlaceholder = leaf[MARK_PLACEHOLDER_SYMBOL] === true; // COMPAT: Render text inside void nodes with a zero-width space.\n  // So the node can contain selection but the text is not visible.\n\n  if (editor.isVoid(parent)) {\n    return /*#__PURE__*/react.createElement(ZeroWidthString, {\n      length: Node.string(parent).length\n    });\n  } // COMPAT: If this is the last text node in an empty block, render a zero-\n  // width space that will convert into a line break when copying and pasting\n  // to support expected plain text.\n\n\n  if (leaf.text === '' && parent.children[parent.children.length - 1] === text && !editor.isInline(parent) && Editor.string(editor, parentPath) === '') {\n    return /*#__PURE__*/react.createElement(ZeroWidthString, {\n      isLineBreak: true,\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  } // COMPAT: If the text is empty, it's because it's on the edge of an inline\n  // node, so we render a zero-width space so that the selection can be\n  // inserted next to it still.\n\n\n  if (leaf.text === '') {\n    return /*#__PURE__*/react.createElement(ZeroWidthString, {\n      isMarkPlaceholder: isMarkPlaceholder\n    });\n  } // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n  // so we need to add an extra trailing new lines to prevent that.\n\n\n  if (isLast && leaf.text.slice(-1) === '\\n') {\n    return /*#__PURE__*/react.createElement(TextString, {\n      isTrailing: true,\n      text: leaf.text\n    });\n  }\n\n  return /*#__PURE__*/react.createElement(TextString, {\n    text: leaf.text\n  });\n};\n/**\r\n * Leaf strings with text in them.\r\n */\n\n\nvar TextString = props => {\n  var {\n    text,\n    isTrailing = false\n  } = props;\n  var ref = (0,react.useRef)(null);\n\n  var getTextContent = () => {\n    return \"\".concat(text !== null && text !== void 0 ? text : '').concat(isTrailing ? '\\n' : '');\n  }; // This is the actual text rendering boundary where we interface with the DOM\n  // The text is not rendered as part of the virtual DOM, as since we handle basic character insertions natively,\n  // updating the DOM is not a one way dataflow anymore. What we need here is not reconciliation and diffing\n  // with previous version of the virtual DOM, but rather diffing with the actual DOM element, and replace the DOM <span> content\n  // exactly if and only if its current content does not match our current virtual DOM.\n  // Otherwise the DOM TextNode would always be replaced by React as the user types, which interferes with native text features,\n  // eg makes native spellcheck opt out from checking the text node.\n  // useLayoutEffect: updating our span before browser paint\n\n\n  useIsomorphicLayoutEffect(() => {\n    // null coalescing text to make sure we're not outputing \"null\" as a string in the extreme case it is nullish at runtime\n    var textWithTrailing = getTextContent();\n\n    if (ref.current && ref.current.textContent !== textWithTrailing) {\n      ref.current.textContent = textWithTrailing;\n    } // intentionally not specifying dependencies, so that this effect runs on every render\n    // as this effectively replaces \"specifying the text in the virtual DOM under the <span> below\" on each render\n\n  }); // Render text content immediately if it's the first-time render\n  // Ensure that text content is rendered on server-side rendering\n\n  if (!ref.current) {\n    return /*#__PURE__*/react.createElement(\"span\", {\n      \"data-slate-string\": true,\n      ref: ref\n    }, getTextContent());\n  } // the span is intentionally same on every render in virtual DOM, actual rendering happens in the layout effect above\n\n\n  return /*#__PURE__*/react.createElement(\"span\", {\n    \"data-slate-string\": true,\n    ref: ref\n  });\n};\n/**\r\n * Leaf strings without text, render as zero-width strings.\r\n */\n\n\nvar ZeroWidthString = props => {\n  var {\n    length = 0,\n    isLineBreak = false,\n    isMarkPlaceholder = false\n  } = props;\n  var attributes = {\n    'data-slate-zero-width': isLineBreak ? 'n' : 'z',\n    'data-slate-length': length\n  };\n\n  if (isMarkPlaceholder) {\n    attributes['data-slate-mark-placeholder'] = true;\n  }\n\n  return /*#__PURE__*/react.createElement(\"span\", Object.assign({}, attributes), !IS_ANDROID || !isLineBreak ? '\\uFEFF' : null, isLineBreak ? /*#__PURE__*/react.createElement(\"br\", null) : null);\n};\n\n/**\r\n * A React context for sharing the editor object.\r\n */\n\nvar EditorContext = /*#__PURE__*/(0,react.createContext)(null);\n/**\r\n * Get the current editor object from the React context.\r\n */\n\nvar useSlateStatic = () => {\n  var editor = (0,react.useContext)(EditorContext);\n\n  if (!editor) {\n    throw new Error(\"The `useSlateStatic` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return editor;\n};\n\n/**\r\n * Individual leaves in a text node with unique formatting.\r\n */\n\nvar Leaf = props => {\n  var {\n    leaf,\n    isLast,\n    text,\n    parent,\n    renderPlaceholder,\n    renderLeaf = props => /*#__PURE__*/react.createElement(DefaultLeaf, Object.assign({}, props))\n  } = props;\n  var placeholderRef = (0,react.useRef)(null);\n  var editor = useSlateStatic();\n  var placeholderResizeObserver = (0,react.useRef)(null);\n  (0,react.useEffect)(() => {\n    return () => {\n      if (placeholderResizeObserver.current) {\n        placeholderResizeObserver.current.disconnect();\n      }\n    };\n  }, []);\n  (0,react.useEffect)(() => {\n    var placeholderEl = placeholderRef === null || placeholderRef === void 0 ? void 0 : placeholderRef.current;\n\n    if (placeholderEl) {\n      EDITOR_TO_PLACEHOLDER_ELEMENT.set(editor, placeholderEl);\n    } else {\n      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n    }\n\n    if (placeholderResizeObserver.current) {\n      // Update existing observer.\n      placeholderResizeObserver.current.disconnect();\n      if (placeholderEl) placeholderResizeObserver.current.observe(placeholderEl);\n    } else if (placeholderEl) {\n      // Create a new observer and observe the placeholder element.\n      placeholderResizeObserver.current = new ResizeObserver(_ref => {\n        var [{\n          target\n        }] = _ref;\n        var styleElement = EDITOR_TO_STYLE_ELEMENT.get(editor);\n\n        if (styleElement) {\n          // Make the min-height the height of the placeholder.\n          var minHeight = \"\".concat(target.clientHeight, \"px\");\n          styleElement.innerHTML = \":where([data-slate-editor-id=\\\"\".concat(editor.id, \"\\\"]) { min-height: \").concat(minHeight, \"; }\");\n        }\n      });\n      placeholderResizeObserver.current.observe(placeholderEl);\n    }\n\n    if (!placeholderEl) {\n      // No placeholder element, so no need for a resize observer.\n      var styleElement = EDITOR_TO_STYLE_ELEMENT.get(editor);\n\n      if (styleElement) {\n        // No min-height if there is no placeholder.\n        styleElement.innerHTML = '';\n      }\n    }\n\n    return () => {\n      EDITOR_TO_PLACEHOLDER_ELEMENT.delete(editor);\n    };\n  }, [placeholderRef, leaf]);\n  var children = /*#__PURE__*/react.createElement(index_es_String, {\n    isLast: isLast,\n    leaf: leaf,\n    parent: parent,\n    text: text\n  });\n\n  if (leaf[PLACEHOLDER_SYMBOL]) {\n    var placeholderProps = {\n      children: leaf.placeholder,\n      attributes: {\n        'data-slate-placeholder': true,\n        style: {\n          position: 'absolute',\n          pointerEvents: 'none',\n          width: '100%',\n          maxWidth: '100%',\n          display: 'block',\n          opacity: '0.333',\n          userSelect: 'none',\n          textDecoration: 'none'\n        },\n        contentEditable: false,\n        ref: placeholderRef\n      }\n    };\n    children = /*#__PURE__*/react.createElement(react.Fragment, null, renderPlaceholder(placeholderProps), children);\n  } // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n  // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n  // contenteditable behaviors. (2019/05/08)\n\n\n  var attributes = {\n    'data-slate-leaf': true\n  };\n  return renderLeaf({\n    attributes,\n    children,\n    leaf,\n    text\n  });\n};\n\nvar MemoizedLeaf = /*#__PURE__*/react.memo(Leaf, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && Text.equals(next.leaf, prev.leaf) && next.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL];\n});\nvar DefaultLeaf = props => {\n  var {\n    attributes,\n    children\n  } = props;\n  return /*#__PURE__*/react.createElement(\"span\", Object.assign({}, attributes), children);\n};\n\n/**\r\n * Text.\r\n */\n\nvar index_es_Text = props => {\n  var {\n    decorations,\n    isLast,\n    parent,\n    renderPlaceholder,\n    renderLeaf,\n    text\n  } = props;\n  var editor = useSlateStatic();\n  var ref = (0,react.useRef)(null);\n  var leaves = Text.decorations(text, decorations);\n  var key = ReactEditor.findKey(editor, text);\n  var children = [];\n\n  for (var i = 0; i < leaves.length; i++) {\n    var leaf = leaves[i];\n    children.push( /*#__PURE__*/react.createElement(MemoizedLeaf, {\n      isLast: isLast && i === leaves.length - 1,\n      key: \"\".concat(key.id, \"-\").concat(i),\n      renderPlaceholder: renderPlaceholder,\n      leaf: leaf,\n      text: text,\n      parent: parent,\n      renderLeaf: renderLeaf\n    }));\n  } // Update element-related weak maps with the DOM element ref.\n\n\n  useIsomorphicLayoutEffect(() => {\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n\n    if (ref.current) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref.current);\n      NODE_TO_ELEMENT.set(text, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, text);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(text);\n    }\n  });\n  return /*#__PURE__*/react.createElement(\"span\", {\n    \"data-slate-node\": \"text\",\n    ref: ref\n  }, children);\n};\n\nvar MemoizedText = /*#__PURE__*/react.memo(index_es_Text, (prev, next) => {\n  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.text === prev.text && isDecoratorRangeListEqual(next.decorations, prev.decorations);\n});\n\n/**\r\n * Element.\r\n */\n\nvar index_es_Element = props => {\n  var {\n    decorations,\n    element,\n    renderElement = p => /*#__PURE__*/react.createElement(DefaultElement, Object.assign({}, p)),\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  } = props;\n  var editor = useSlateStatic();\n  var readOnly = useReadOnly();\n  var isInline = editor.isInline(element);\n  var key = ReactEditor.findKey(editor, element);\n  var ref = (0,react.useCallback)(ref => {\n    // Update element-related weak maps with the DOM element ref.\n    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);\n\n    if (ref) {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref);\n      NODE_TO_ELEMENT.set(element, ref);\n      ELEMENT_TO_NODE.set(ref, element);\n    } else {\n      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);\n      NODE_TO_ELEMENT.delete(element);\n    }\n  }, [editor, key, element]);\n  var children = useChildren({\n    decorations,\n    node: element,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  }); // Attributes that the developer must mix into the element in their\n  // custom node renderer component.\n\n  var attributes = {\n    'data-slate-node': 'element',\n    ref\n  };\n\n  if (isInline) {\n    attributes['data-slate-inline'] = true;\n  } // If it's a block node with inline children, add the proper `dir` attribute\n  // for text direction.\n\n\n  if (!isInline && Editor.hasInlines(editor, element)) {\n    var text = Node.string(element);\n    var dir = direction_default()(text);\n\n    if (dir === 'rtl') {\n      attributes.dir = dir;\n    }\n  } // If it's a void node, wrap the children in extra void-specific elements.\n\n\n  if (Editor.isVoid(editor, element)) {\n    attributes['data-slate-void'] = true;\n\n    if (!readOnly && isInline) {\n      attributes.contentEditable = false;\n    }\n\n    var Tag = isInline ? 'span' : 'div';\n    var [[_text]] = Node.texts(element);\n    children = /*#__PURE__*/react.createElement(Tag, {\n      \"data-slate-spacer\": true,\n      style: {\n        height: '0',\n        color: 'transparent',\n        outline: 'none',\n        position: 'absolute'\n      }\n    }, /*#__PURE__*/react.createElement(MemoizedText, {\n      renderPlaceholder: renderPlaceholder,\n      decorations: [],\n      isLast: false,\n      parent: element,\n      text: _text\n    }));\n    NODE_TO_INDEX.set(_text, 0);\n    NODE_TO_PARENT.set(_text, element);\n  }\n\n  return renderElement({\n    attributes,\n    children,\n    element\n  });\n};\n\nvar MemoizedElement = /*#__PURE__*/react.memo(index_es_Element, (prev, next) => {\n  return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && isDecoratorRangeListEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && index_es_Range.equals(prev.selection, next.selection));\n});\n/**\r\n * The default element renderer.\r\n */\n\nvar DefaultElement = props => {\n  var {\n    attributes,\n    children,\n    element\n  } = props;\n  var editor = useSlateStatic();\n  var Tag = editor.isInline(element) ? 'span' : 'div';\n  return /*#__PURE__*/react.createElement(Tag, Object.assign({}, attributes, {\n    style: {\n      position: 'relative'\n    }\n  }), children);\n};\n\n/**\r\n * A React context for sharing the `decorate` prop of the editable.\r\n */\n\nvar DecorateContext = /*#__PURE__*/(0,react.createContext)(() => []);\n/**\r\n * Get the current `decorate` prop of the editable.\r\n */\n\nvar useDecorate = () => {\n  return (0,react.useContext)(DecorateContext);\n};\n\n/**\r\n * A React context for sharing the `selected` state of an element.\r\n */\n\nvar SelectedContext = /*#__PURE__*/(0,react.createContext)(false);\n/**\r\n * Get the current `selected` state of an element.\r\n */\n\nvar useSelected = () => {\n  return useContext(SelectedContext);\n};\n\n/**\r\n * Children.\r\n */\n\nvar useChildren = props => {\n  var {\n    decorations,\n    node,\n    renderElement,\n    renderPlaceholder,\n    renderLeaf,\n    selection\n  } = props;\n  var decorate = useDecorate();\n  var editor = useSlateStatic();\n  var path = ReactEditor.findPath(editor, node);\n  var children = [];\n  var isLeafBlock = Element.isElement(node) && !editor.isInline(node) && Editor.hasInlines(editor, node);\n\n  for (var i = 0; i < node.children.length; i++) {\n    var p = path.concat(i);\n    var n = node.children[i];\n    var key = ReactEditor.findKey(editor, n);\n    var range = Editor.range(editor, p);\n    var sel = selection && index_es_Range.intersection(range, selection);\n    var ds = decorate([n, p]);\n\n    for (var dec of decorations) {\n      var d = index_es_Range.intersection(dec, range);\n\n      if (d) {\n        ds.push(d);\n      }\n    }\n\n    if (Element.isElement(n)) {\n      children.push( /*#__PURE__*/react.createElement(SelectedContext.Provider, {\n        key: \"provider-\".concat(key.id),\n        value: !!sel\n      }, /*#__PURE__*/react.createElement(MemoizedElement, {\n        decorations: ds,\n        element: n,\n        key: key.id,\n        renderElement: renderElement,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        selection: sel\n      })));\n    } else {\n      children.push( /*#__PURE__*/react.createElement(MemoizedText, {\n        decorations: ds,\n        key: key.id,\n        isLast: isLeafBlock && i === node.children.length - 1,\n        parent: node,\n        renderPlaceholder: renderPlaceholder,\n        renderLeaf: renderLeaf,\n        text: n\n      }));\n    }\n\n    NODE_TO_INDEX.set(n, i);\n    NODE_TO_PARENT.set(n, node);\n  }\n\n  return children;\n};\n\n/**\r\n * A React context for sharing the `readOnly` state of the editor.\r\n */\n\nvar ReadOnlyContext = /*#__PURE__*/(0,react.createContext)(false);\n/**\r\n * Get the current `readOnly` state of the editor.\r\n */\n\nvar useReadOnly = () => {\n  return (0,react.useContext)(ReadOnlyContext);\n};\n\nvar SlateContext = /*#__PURE__*/(0,react.createContext)(null);\n/**\r\n * Get the current editor object from the React context.\r\n */\n\nvar useSlate = () => {\n  var context = (0,react.useContext)(SlateContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n\n  var {\n    editor\n  } = context;\n  return editor;\n};\nvar useSlateWithV = () => {\n  var context = useContext(SlateContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlate` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return context;\n};\n\nvar TRIPLE_CLICK = 3;\n\n/**\r\n * Hotkey mappings for each platform.\r\n */\n\nvar HOTKEYS = {\n  bold: 'mod+b',\n  compose: ['down', 'left', 'right', 'up', 'backspace', 'enter'],\n  moveBackward: 'left',\n  moveForward: 'right',\n  moveWordBackward: 'ctrl+left',\n  moveWordForward: 'ctrl+right',\n  deleteBackward: 'shift?+backspace',\n  deleteForward: 'shift?+delete',\n  extendBackward: 'shift+left',\n  extendForward: 'shift+right',\n  italic: 'mod+i',\n  insertSoftBreak: 'shift+enter',\n  splitBlock: 'enter',\n  undo: 'mod+z'\n};\nvar APPLE_HOTKEYS = {\n  moveLineBackward: 'opt+up',\n  moveLineForward: 'opt+down',\n  moveWordBackward: 'opt+left',\n  moveWordForward: 'opt+right',\n  deleteBackward: ['ctrl+backspace', 'ctrl+h'],\n  deleteForward: ['ctrl+delete', 'ctrl+d'],\n  deleteLineBackward: 'cmd+shift?+backspace',\n  deleteLineForward: ['cmd+shift?+delete', 'ctrl+k'],\n  deleteWordBackward: 'opt+shift?+backspace',\n  deleteWordForward: 'opt+shift?+delete',\n  extendLineBackward: 'opt+shift+up',\n  extendLineForward: 'opt+shift+down',\n  redo: 'cmd+shift+z',\n  transposeCharacter: 'ctrl+t'\n};\nvar WINDOWS_HOTKEYS = {\n  deleteWordBackward: 'ctrl+shift?+backspace',\n  deleteWordForward: 'ctrl+shift?+delete',\n  redo: ['ctrl+y', 'ctrl+shift+z']\n};\n/**\r\n * Create a platform-aware hotkey checker.\r\n */\n\nvar create = key => {\n  var generic = HOTKEYS[key];\n  var apple = APPLE_HOTKEYS[key];\n  var windows = WINDOWS_HOTKEYS[key];\n  var isGeneric = generic && (0,lib/* isKeyHotkey */.TB)(generic);\n  var isApple = apple && (0,lib/* isKeyHotkey */.TB)(apple);\n  var isWindows = windows && (0,lib/* isKeyHotkey */.TB)(windows);\n  return event => {\n    if (isGeneric && isGeneric(event)) return true;\n    if (IS_APPLE && isApple && isApple(event)) return true;\n    if (!IS_APPLE && isWindows && isWindows(event)) return true;\n    return false;\n  };\n};\n/**\r\n * Hotkeys.\r\n */\n\n\nvar Hotkeys = {\n  isBold: create('bold'),\n  isCompose: create('compose'),\n  isMoveBackward: create('moveBackward'),\n  isMoveForward: create('moveForward'),\n  isDeleteBackward: create('deleteBackward'),\n  isDeleteForward: create('deleteForward'),\n  isDeleteLineBackward: create('deleteLineBackward'),\n  isDeleteLineForward: create('deleteLineForward'),\n  isDeleteWordBackward: create('deleteWordBackward'),\n  isDeleteWordForward: create('deleteWordForward'),\n  isExtendBackward: create('extendBackward'),\n  isExtendForward: create('extendForward'),\n  isExtendLineBackward: create('extendLineBackward'),\n  isExtendLineForward: create('extendLineForward'),\n  isItalic: create('italic'),\n  isMoveLineBackward: create('moveLineBackward'),\n  isMoveLineForward: create('moveLineForward'),\n  isMoveWordBackward: create('moveWordBackward'),\n  isMoveWordForward: create('moveWordForward'),\n  isRedo: create('redo'),\n  isSoftBreak: create('insertSoftBreak'),\n  isSplitBlock: create('splitBlock'),\n  isTransposeCharacter: create('transposeCharacter'),\n  isUndo: create('undo')\n};\n\nvar createRestoreDomManager = (editor, receivedUserInput) => {\n  var bufferedMutations = [];\n\n  var clear = () => {\n    bufferedMutations = [];\n  };\n\n  var registerMutations = mutations => {\n    if (!receivedUserInput.current) {\n      return;\n    }\n\n    var trackedMutations = mutations.filter(mutation => isTrackedMutation(editor, mutation, mutations));\n    bufferedMutations.push(...trackedMutations);\n  };\n\n  function restoreDOM() {\n    bufferedMutations.reverse().forEach(mutation => {\n      if (mutation.type === 'characterData') {\n        mutation.target.textContent = mutation.oldValue;\n        return;\n      }\n\n      mutation.removedNodes.forEach(node => {\n        mutation.target.insertBefore(node, mutation.nextSibling);\n      });\n      mutation.addedNodes.forEach(node => {\n        mutation.target.removeChild(node);\n      });\n    }); // Clear buffered mutations to ensure we don't undo them twice\n\n    clear();\n  }\n\n  return {\n    registerMutations,\n    restoreDOM,\n    clear\n  };\n};\n\nvar MUTATION_OBSERVER_CONFIG$1 = {\n  subtree: true,\n  childList: true,\n  characterData: true,\n  characterDataOldValue: true\n}; // We have to use a class component here since we rely on `getSnapshotBeforeUpdate` which has no FC equivalent\n// to run code synchronously immediately before react commits the component update to the DOM.\n\nclass RestoreDOMComponent extends react.Component {\n  constructor() {\n    super(...arguments);\n    this.context = null;\n    this.manager = null;\n    this.mutationObserver = null;\n  }\n\n  observe() {\n    var _this$mutationObserve;\n\n    var {\n      node\n    } = this.props;\n\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined');\n    }\n\n    (_this$mutationObserve = this.mutationObserver) === null || _this$mutationObserve === void 0 ? void 0 : _this$mutationObserve.observe(node.current, MUTATION_OBSERVER_CONFIG$1);\n  }\n\n  componentDidMount() {\n    var {\n      receivedUserInput\n    } = this.props;\n    var editor = this.context;\n    this.manager = createRestoreDomManager(editor, receivedUserInput);\n    this.mutationObserver = new MutationObserver(this.manager.registerMutations);\n    this.observe();\n  }\n\n  getSnapshotBeforeUpdate() {\n    var _this$mutationObserve2, _this$mutationObserve3, _this$manager2;\n\n    var pendingMutations = (_this$mutationObserve2 = this.mutationObserver) === null || _this$mutationObserve2 === void 0 ? void 0 : _this$mutationObserve2.takeRecords();\n\n    if (pendingMutations !== null && pendingMutations !== void 0 && pendingMutations.length) {\n      var _this$manager;\n\n      (_this$manager = this.manager) === null || _this$manager === void 0 ? void 0 : _this$manager.registerMutations(pendingMutations);\n    }\n\n    (_this$mutationObserve3 = this.mutationObserver) === null || _this$mutationObserve3 === void 0 ? void 0 : _this$mutationObserve3.disconnect();\n    (_this$manager2 = this.manager) === null || _this$manager2 === void 0 ? void 0 : _this$manager2.restoreDOM();\n    return null;\n  }\n\n  componentDidUpdate() {\n    var _this$manager3;\n\n    (_this$manager3 = this.manager) === null || _this$manager3 === void 0 ? void 0 : _this$manager3.clear();\n    this.observe();\n  }\n\n  componentWillUnmount() {\n    var _this$mutationObserve4;\n\n    (_this$mutationObserve4 = this.mutationObserver) === null || _this$mutationObserve4 === void 0 ? void 0 : _this$mutationObserve4.disconnect();\n  }\n\n  render() {\n    return this.props.children;\n  }\n\n}\n\nRestoreDOMComponent.contextType = EditorContext;\nvar RestoreDOM = IS_ANDROID ? RestoreDOMComponent : _ref => {\n  var {\n    children\n  } = _ref;\n  return /*#__PURE__*/react.createElement(react.Fragment, null, children);\n};\n\n/**\r\n * Check whether a text diff was applied in a way we can perform the pending action on /\r\n * recover the pending selection.\r\n */\n\nfunction verifyDiffState(editor, textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n\n  if (!Editor.hasPath(editor, path)) {\n    return false;\n  }\n\n  var node = Node.get(editor, path);\n\n  if (!Text.isText(node)) {\n    return false;\n  }\n\n  if (diff.start !== node.text.length || diff.text.length === 0) {\n    return node.text.slice(diff.start, diff.start + diff.text.length) === diff.text;\n  }\n\n  var nextPath = Path.next(path);\n\n  if (!Editor.hasPath(editor, nextPath)) {\n    return false;\n  }\n\n  var nextNode = Node.get(editor, nextPath);\n  return Text.isText(nextNode) && nextNode.text.startsWith(diff.text);\n}\n\nfunction applyStringDiff(text) {\n  for (var _len = arguments.length, diffs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    diffs[_key - 1] = arguments[_key];\n  }\n\n  return diffs.reduce((text, diff) => text.slice(0, diff.start) + diff.text + text.slice(diff.end), text);\n}\n\nfunction longestCommonPrefixLength(str, another) {\n  var length = Math.min(str.length, another.length);\n\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(i) !== another.charAt(i)) {\n      return i;\n    }\n  }\n\n  return length;\n}\n\nfunction longestCommonSuffixLength(str, another, max) {\n  var length = Math.min(str.length, another.length, max);\n\n  for (var i = 0; i < length; i++) {\n    if (str.charAt(str.length - i - 1) !== another.charAt(another.length - i - 1)) {\n      return i;\n    }\n  }\n\n  return length;\n}\n/**\r\n * Remove redundant changes from the diff so that it spans the minimal possible range\r\n */\n\n\nfunction normalizeStringDiff(targetText, diff) {\n  var {\n    start,\n    end,\n    text\n  } = diff;\n  var removedText = targetText.slice(start, end);\n  var prefixLength = longestCommonPrefixLength(removedText, text);\n  var max = Math.min(removedText.length - prefixLength, text.length - prefixLength);\n  var suffixLength = longestCommonSuffixLength(removedText, text, max);\n  var normalized = {\n    start: start + prefixLength,\n    end: end - suffixLength,\n    text: text.slice(prefixLength, text.length - suffixLength)\n  };\n\n  if (normalized.start === normalized.end && normalized.text.length === 0) {\n    return null;\n  }\n\n  return normalized;\n}\n/**\r\n * Return a string diff that is equivalent to applying b after a spanning the range of\r\n * both changes\r\n */\n\nfunction mergeStringDiffs(targetText, a, b) {\n  var start = Math.min(a.start, b.start);\n  var overlap = Math.max(0, Math.min(a.start + a.text.length, b.end) - b.start);\n  var applied = applyStringDiff(targetText, a, b);\n  var sliceEnd = Math.max(b.start + b.text.length, a.start + a.text.length + (a.start + a.text.length > b.start ? b.text.length : 0) - overlap);\n  var text = applied.slice(start, sliceEnd);\n  var end = Math.max(a.end, b.end - a.text.length + (a.end - a.start));\n  return normalizeStringDiff(targetText, {\n    start,\n    end,\n    text\n  });\n}\n/**\r\n * Get the slate range the text diff spans.\r\n */\n\nfunction targetRange(textDiff) {\n  var {\n    path,\n    diff\n  } = textDiff;\n  return {\n    anchor: {\n      path,\n      offset: diff.start\n    },\n    focus: {\n      path,\n      offset: diff.end\n    }\n  };\n}\n/**\r\n * Normalize a 'pending point' a.k.a a point based on the dom state before applying\r\n * the pending diffs. Since the pending diffs might have been inserted with different\r\n * marks we have to 'walk' the offset from the starting position to ensure we still\r\n * have a valid point inside the document\r\n */\n\nfunction normalizePoint(editor, point) {\n  var {\n    path,\n    offset\n  } = point;\n\n  if (!Editor.hasPath(editor, path)) {\n    return null;\n  }\n\n  var leaf = Node.get(editor, path);\n\n  if (!Text.isText(leaf)) {\n    return null;\n  }\n\n  var parentBlock = Editor.above(editor, {\n    match: n => Editor.isBlock(editor, n),\n    at: path\n  });\n\n  if (!parentBlock) {\n    return null;\n  }\n\n  while (offset > leaf.text.length) {\n    var entry = Editor.next(editor, {\n      at: path,\n      match: Text.isText\n    });\n\n    if (!entry || !Path.isDescendant(entry[1], parentBlock[1])) {\n      return null;\n    }\n\n    offset -= leaf.text.length;\n    leaf = entry[0];\n    path = entry[1];\n  }\n\n  return {\n    path,\n    offset\n  };\n}\n/**\r\n * Normalize a 'pending selection' to ensure it's valid in the current document state.\r\n */\n\nfunction normalizeRange(editor, range) {\n  var anchor = normalizePoint(editor, range.anchor);\n\n  if (!anchor) {\n    return null;\n  }\n\n  if (index_es_Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n\n  var focus = normalizePoint(editor, range.focus);\n\n  if (!focus) {\n    return null;\n  }\n\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformPendingPoint(editor, point, op) {\n  var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(editor);\n  var textDiff = pendingDiffs === null || pendingDiffs === void 0 ? void 0 : pendingDiffs.find(_ref => {\n    var {\n      path\n    } = _ref;\n    return Path.equals(path, point.path);\n  });\n\n  if (!textDiff || point.offset <= textDiff.diff.start) {\n    return Point.transform(point, op, {\n      affinity: 'backward'\n    });\n  }\n\n  var {\n    diff\n  } = textDiff; // Point references location inside the diff => transform the point based on the location\n  // the diff will be applied to and add the offset inside the diff.\n\n  if (point.offset <= diff.start + diff.text.length) {\n    var _anchor = {\n      path: point.path,\n      offset: diff.start\n    };\n\n    var _transformed = Point.transform(_anchor, op, {\n      affinity: 'backward'\n    });\n\n    if (!_transformed) {\n      return null;\n    }\n\n    return {\n      path: _transformed.path,\n      offset: _transformed.offset + point.offset - diff.start\n    };\n  } // Point references location after the diff\n\n\n  var anchor = {\n    path: point.path,\n    offset: point.offset - diff.text.length + diff.end - diff.start\n  };\n  var transformed = Point.transform(anchor, op, {\n    affinity: 'backward'\n  });\n\n  if (!transformed) {\n    return null;\n  }\n\n  if (op.type === 'split_node' && Path.equals(op.path, point.path) && anchor.offset < op.position && diff.start < op.position) {\n    return transformed;\n  }\n\n  return {\n    path: transformed.path,\n    offset: transformed.offset + diff.text.length - diff.end + diff.start\n  };\n}\nfunction transformPendingRange(editor, range, op) {\n  var anchor = transformPendingPoint(editor, range.anchor, op);\n\n  if (!anchor) {\n    return null;\n  }\n\n  if (index_es_Range.isCollapsed(range)) {\n    return {\n      anchor,\n      focus: anchor\n    };\n  }\n\n  var focus = transformPendingPoint(editor, range.focus, op);\n\n  if (!focus) {\n    return null;\n  }\n\n  return {\n    anchor,\n    focus\n  };\n}\nfunction transformTextDiff(textDiff, op) {\n  var {\n    path,\n    diff,\n    id\n  } = textDiff;\n\n  switch (op.type) {\n    case 'insert_text':\n      {\n        if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n\n        if (op.offset <= diff.start) {\n          return {\n            diff: {\n              start: op.text.length + diff.start,\n              end: op.text.length + diff.end,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end + op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n\n    case 'remove_text':\n      {\n        if (!Path.equals(op.path, path) || op.offset >= diff.end) {\n          return textDiff;\n        }\n\n        if (op.offset + op.text.length <= diff.start) {\n          return {\n            diff: {\n              start: diff.start - op.text.length,\n              end: diff.end - op.text.length,\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start,\n            end: diff.end - op.text.length,\n            text: diff.text\n          },\n          id,\n          path\n        };\n      }\n\n    case 'split_node':\n      {\n        if (!Path.equals(op.path, path) || op.position >= diff.end) {\n          return {\n            diff,\n            id,\n            path: Path.transform(path, op, {\n              affinity: 'backward'\n            })\n          };\n        }\n\n        if (op.position > diff.start) {\n          return {\n            diff: {\n              start: diff.start,\n              end: Math.min(op.position, diff.end),\n              text: diff.text\n            },\n            id,\n            path\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start - op.position,\n            end: diff.end - op.position,\n            text: diff.text\n          },\n          id,\n          path: Path.transform(path, op, {\n            affinity: 'forward'\n          })\n        };\n      }\n\n    case 'merge_node':\n      {\n        if (!Path.equals(op.path, path)) {\n          return {\n            diff,\n            id,\n            path: Path.transform(path, op)\n          };\n        }\n\n        return {\n          diff: {\n            start: diff.start + op.position,\n            end: diff.end + op.position,\n            text: diff.text\n          },\n          id,\n          path: Path.transform(path, op)\n        };\n      }\n  }\n\n  var newPath = Path.transform(path, op);\n\n  if (!newPath) {\n    return null;\n  }\n\n  return {\n    diff,\n    path: newPath,\n    id\n  };\n}\n\nfunction index_es_ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction index_es_objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { index_es_ownKeys$3(Object(source), true).forEach(function (key) { index_es_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { index_es_ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n// When using keyboard English association function, conpositionEnd triggered too fast, resulting in after `insertText` still maintain association state.\n\nvar RESOLVE_DELAY = 25; // Time with no user interaction before the current user action is considered as done.\n\nvar FLUSH_DELAY = 200; // Replace with `const debug = console.log` to debug\n\nvar debug = function debug() {};\n\nfunction createAndroidInputManager(_ref) {\n  var {\n    editor,\n    scheduleOnDOMSelectionChange,\n    onDOMSelectionChange\n  } = _ref;\n  var flushing = false;\n  var compositionEndTimeoutId = null;\n  var flushTimeoutId = null;\n  var actionTimeoutId = null;\n  var idCounter = 0;\n  var insertPositionHint = false;\n\n  var applyPendingSelection = () => {\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(editor);\n    EDITOR_TO_PENDING_SELECTION.delete(editor);\n\n    if (pendingSelection) {\n      var {\n        selection\n      } = editor;\n      var normalized = normalizeRange(editor, pendingSelection);\n\n      if (normalized && (!selection || !index_es_Range.equals(normalized, selection))) {\n        Transforms.select(editor, normalized);\n      }\n    }\n  };\n\n  var performAction = () => {\n    var action = EDITOR_TO_PENDING_ACTION.get(editor);\n    EDITOR_TO_PENDING_ACTION.delete(editor);\n\n    if (!action) {\n      return;\n    }\n\n    if (action.at) {\n      var target = Point.isPoint(action.at) ? normalizePoint(editor, action.at) : normalizeRange(editor, action.at);\n\n      if (!target) {\n        return;\n      }\n\n      var _targetRange = Editor.range(editor, target);\n\n      if (!editor.selection || !index_es_Range.equals(editor.selection, _targetRange)) {\n        Transforms.select(editor, target);\n      }\n    }\n\n    action.run();\n  };\n\n  var flush = () => {\n    var _EDITOR_TO_PENDING_DI;\n\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n\n    if (actionTimeoutId) {\n      clearTimeout(actionTimeoutId);\n      actionTimeoutId = null;\n    }\n\n    if (!hasPendingDiffs() && !hasPendingAction()) {\n      applyPendingSelection();\n      return;\n    }\n\n    if (!flushing) {\n      flushing = true;\n      setTimeout(() => flushing = false);\n    }\n\n    if (hasPendingAction()) {\n      flushing = 'action';\n    }\n\n    var selectionRef = editor.selection && Editor.rangeRef(editor, editor.selection, {\n      affinity: 'forward'\n    });\n    EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n    debug('flush', EDITOR_TO_PENDING_ACTION.get(editor), EDITOR_TO_PENDING_DIFFS.get(editor));\n    var scheduleSelectionChange = !!((_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length);\n    var diff;\n\n    while (diff = (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI2 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI2[0]) {\n      var _EDITOR_TO_PENDING_DI2, _EDITOR_TO_PENDING_DI3;\n\n      var pendingMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n\n      if (pendingMarks !== undefined) {\n        EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n        editor.marks = pendingMarks;\n      }\n\n      if (pendingMarks && insertPositionHint === false) {\n        insertPositionHint = null;\n      }\n\n      var range = targetRange(diff);\n\n      if (!editor.selection || !index_es_Range.equals(editor.selection, range)) {\n        Transforms.select(editor, range);\n      }\n\n      if (diff.diff.text) {\n        Editor.insertText(editor, diff.diff.text);\n      } else {\n        Editor.deleteFragment(editor);\n      } // Remove diff only after we have applied it to account for it when transforming\n      // pending ranges.\n\n\n      EDITOR_TO_PENDING_DIFFS.set(editor, (_EDITOR_TO_PENDING_DI3 = EDITOR_TO_PENDING_DIFFS.get(editor)) === null || _EDITOR_TO_PENDING_DI3 === void 0 ? void 0 : _EDITOR_TO_PENDING_DI3.filter(_ref2 => {\n        var {\n          id\n        } = _ref2;\n        return id !== diff.id;\n      }));\n\n      if (!verifyDiffState(editor, diff)) {\n        scheduleSelectionChange = false;\n        EDITOR_TO_PENDING_ACTION.delete(editor);\n        EDITOR_TO_USER_MARKS.delete(editor);\n        flushing = 'action'; // Ensure we don't restore the pending user (dom) selection\n        // since the document and dom state do not match.\n\n        EDITOR_TO_PENDING_SELECTION.delete(editor);\n        scheduleOnDOMSelectionChange.cancel();\n        onDOMSelectionChange.cancel();\n        selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n      }\n    }\n\n    var selection = selectionRef === null || selectionRef === void 0 ? void 0 : selectionRef.unref();\n\n    if (selection && !EDITOR_TO_PENDING_SELECTION.get(editor) && (!editor.selection || !index_es_Range.equals(selection, editor.selection))) {\n      Transforms.select(editor, selection);\n    }\n\n    if (hasPendingAction()) {\n      performAction();\n      return;\n    } // COMPAT: The selectionChange event is fired after the action is performed,\n    // so we have to manually schedule it to ensure we don't 'throw away' the selection\n    // while rendering if we have pending changes.\n\n\n    if (scheduleSelectionChange) {\n      scheduleOnDOMSelectionChange();\n    }\n\n    scheduleOnDOMSelectionChange.flush();\n    onDOMSelectionChange.flush();\n    applyPendingSelection();\n    var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n    EDITOR_TO_USER_MARKS.delete(editor);\n\n    if (userMarks !== undefined) {\n      editor.marks = userMarks;\n      editor.onChange();\n    }\n  };\n\n  var handleCompositionEnd = _event => {\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n    }\n\n    compositionEndTimeoutId = setTimeout(() => {\n      IS_COMPOSING.set(editor, false);\n      flush();\n    }, RESOLVE_DELAY);\n  };\n\n  var handleCompositionStart = _event => {\n    IS_COMPOSING.set(editor, true);\n\n    if (compositionEndTimeoutId) {\n      clearTimeout(compositionEndTimeoutId);\n      compositionEndTimeoutId = null;\n    }\n  };\n\n  var updatePlaceholderVisibility = function updatePlaceholderVisibility() {\n    var forceHide = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var placeholderElement = EDITOR_TO_PLACEHOLDER_ELEMENT.get(editor);\n\n    if (!placeholderElement) {\n      return;\n    }\n\n    if (hasPendingDiffs() || forceHide) {\n      placeholderElement.style.display = 'none';\n      return;\n    }\n\n    placeholderElement.style.removeProperty('display');\n  };\n\n  var storeDiff = (path, diff) => {\n    var _EDITOR_TO_PENDING_DI4;\n    var pendingDiffs = (_EDITOR_TO_PENDING_DI4 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI4 !== void 0 ? _EDITOR_TO_PENDING_DI4 : [];\n    EDITOR_TO_PENDING_DIFFS.set(editor, pendingDiffs);\n    var target = Node.leaf(editor, path);\n    var idx = pendingDiffs.findIndex(change => Path.equals(change.path, path));\n\n    if (idx < 0) {\n      var normalized = normalizeStringDiff(target.text, diff);\n\n      if (normalized) {\n        pendingDiffs.push({\n          path,\n          diff,\n          id: idCounter++\n        });\n      }\n\n      updatePlaceholderVisibility();\n      return;\n    }\n\n    var merged = mergeStringDiffs(target.text, pendingDiffs[idx].diff, diff);\n\n    if (!merged) {\n      pendingDiffs.splice(idx, 1);\n      updatePlaceholderVisibility();\n      return;\n    }\n\n    pendingDiffs[idx] = index_es_objectSpread$3(index_es_objectSpread$3({}, pendingDiffs[idx]), {}, {\n      diff: merged\n    });\n  };\n\n  var scheduleAction = function scheduleAction(run) {\n    var {\n      at\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    insertPositionHint = false;\n    EDITOR_TO_PENDING_SELECTION.delete(editor);\n    scheduleOnDOMSelectionChange.cancel();\n    onDOMSelectionChange.cancel();\n\n    if (hasPendingAction()) {\n      flush();\n    }\n\n    EDITOR_TO_PENDING_ACTION.set(editor, {\n      at,\n      run\n    }); // COMPAT: When deleting before a non-contenteditable element chrome only fires a beforeinput,\n    // (no input) and doesn't perform any dom mutations. Without a flush timeout we would never flush\n    // in this case and thus never actually perform the action.\n\n    actionTimeoutId = setTimeout(flush);\n  };\n\n  var handleDOMBeforeInput = event => {\n    var _targetRange2;\n\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n\n    var {\n      inputType: type\n    } = event;\n    var targetRange = null;\n    var data = event.dataTransfer || event.data || undefined;\n\n    if (insertPositionHint !== false && type !== 'insertText' && type !== 'insertCompositionText') {\n      insertPositionHint = false;\n    }\n\n    var [nativeTargetRange] = event.getTargetRanges();\n\n    if (nativeTargetRange) {\n      targetRange = ReactEditor.toSlateRange(editor, nativeTargetRange, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    } // COMPAT: SelectionChange event is fired after the action is performed, so we\n    // have to manually get the selection here to ensure it's up-to-date.\n\n\n    var window = ReactEditor.getWindow(editor);\n    var domSelection = window.getSelection();\n\n    if (!targetRange && domSelection) {\n      nativeTargetRange = domSelection;\n      targetRange = ReactEditor.toSlateRange(editor, domSelection, {\n        exactMatch: false,\n        suppressThrow: true\n      });\n    }\n\n    targetRange = (_targetRange2 = targetRange) !== null && _targetRange2 !== void 0 ? _targetRange2 : editor.selection;\n\n    if (!targetRange) {\n      return;\n    }\n\n    if (index_es_Range.isExpanded(targetRange) && type.startsWith('delete')) {\n      var [start, end] = index_es_Range.edges(targetRange);\n      var leaf = Node.leaf(editor, start.path);\n\n      if (leaf.text.length === start.offset && end.offset === 0) {\n        var next = Editor.next(editor, {\n          at: start.path,\n          match: Text.isText\n        });\n\n        if (next && Path.equals(next[1], end.path)) {\n          targetRange = {\n            anchor: end,\n            focus: end\n          };\n        }\n      }\n    }\n\n    if (index_es_Range.isExpanded(targetRange) && type.startsWith('delete')) {\n      if (Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n        var [_start, _end] = index_es_Range.edges(targetRange);\n        return storeDiff(targetRange.anchor.path, {\n          text: '',\n          end: _end.offset,\n          start: _start.offset\n        });\n      }\n\n      var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n      return scheduleAction(() => Editor.deleteFragment(editor, {\n        direction\n      }), {\n        at: targetRange\n      });\n    }\n\n    switch (type) {\n      case 'deleteByComposition':\n      case 'deleteByCut':\n      case 'deleteByDrag':\n        {\n          return scheduleAction(() => Editor.deleteFragment(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteContent':\n      case 'deleteContentForward':\n        {\n          var {\n            anchor\n          } = targetRange;\n\n          if (index_es_Range.isCollapsed(targetRange)) {\n            var targetNode = Node.leaf(editor, anchor.path);\n\n            if (anchor.offset < targetNode.text.length) {\n              return storeDiff(anchor.path, {\n                text: '',\n                start: anchor.offset,\n                end: anchor.offset + 1\n              });\n            }\n          }\n\n          return scheduleAction(() => Editor.deleteForward(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteContentBackward':\n        {\n          var _nativeTargetRange;\n\n          var {\n            anchor: _anchor\n          } = targetRange; // If we have a mismatch between the native and slate selection being collapsed\n          // we are most likely deleting a zero-width placeholder and thus should perform it\n          // as an action to ensure correct behavior (mostly happens with mark placeholders)\n\n          var nativeCollapsed = isDOMSelection(nativeTargetRange) ? nativeTargetRange.isCollapsed : !!((_nativeTargetRange = nativeTargetRange) !== null && _nativeTargetRange !== void 0 && _nativeTargetRange.collapsed);\n\n          if (nativeCollapsed && index_es_Range.isCollapsed(targetRange) && _anchor.offset > 0) {\n            return storeDiff(_anchor.path, {\n              text: '',\n              start: _anchor.offset - 1,\n              end: _anchor.offset\n            });\n          }\n\n          return scheduleAction(() => Editor.deleteBackward(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteEntireSoftLine':\n        {\n          return scheduleAction(() => {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n          }, {\n            at: targetRange\n          });\n        }\n\n      case 'deleteHardLineBackward':\n        {\n          return scheduleAction(() => Editor.deleteBackward(editor, {\n            unit: 'block'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteSoftLineBackward':\n        {\n          return scheduleAction(() => Editor.deleteBackward(editor, {\n            unit: 'line'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteHardLineForward':\n        {\n          return scheduleAction(() => Editor.deleteForward(editor, {\n            unit: 'block'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteSoftLineForward':\n        {\n          return scheduleAction(() => Editor.deleteForward(editor, {\n            unit: 'line'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteWordBackward':\n        {\n          return scheduleAction(() => Editor.deleteBackward(editor, {\n            unit: 'word'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'deleteWordForward':\n        {\n          return scheduleAction(() => Editor.deleteForward(editor, {\n            unit: 'word'\n          }), {\n            at: targetRange\n          });\n        }\n\n      case 'insertLineBreak':\n        {\n          return scheduleAction(() => Editor.insertSoftBreak(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'insertParagraph':\n        {\n          return scheduleAction(() => Editor.insertBreak(editor), {\n            at: targetRange\n          });\n        }\n\n      case 'insertCompositionText':\n      case 'deleteCompositionText':\n      case 'insertFromComposition':\n      case 'insertFromDrop':\n      case 'insertFromPaste':\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText':\n        {\n          if ((data === null || data === void 0 ? void 0 : data.constructor.name) === 'DataTransfer') {\n            return scheduleAction(() => ReactEditor.insertData(editor, data), {\n              at: targetRange\n            });\n          }\n\n          if (typeof data === 'string' && data.includes('\\n')) {\n            return scheduleAction(() => Editor.insertSoftBreak(editor), {\n              at: index_es_Range.end(targetRange)\n            });\n          }\n\n          var text = data !== null && data !== void 0 ? data : ''; // COMPAT: If we are writing inside a placeholder, the ime inserts the text inside\n          // the placeholder itself and thus includes the zero-width space inside edit events.\n\n          if (EDITOR_TO_PENDING_INSERTION_MARKS.get(editor)) {\n            text = text.replace('\\uFEFF', '');\n          }\n\n          if (Path.equals(targetRange.anchor.path, targetRange.focus.path)) {\n            var [_start2, _end2] = index_es_Range.edges(targetRange);\n            var diff = {\n              start: _start2.offset,\n              end: _end2.offset,\n              text\n            }; // COMPAT: Swiftkey has a weird bug where the target range of the 2nd word\n            // inserted after a mark placeholder is inserted with an anchor offset off by 1.\n            // So writing 'some text' will result in 'some ttext'. Luckily all 'normal' insert\n            // text events are fired with the correct target ranges, only the final 'insertComposition'\n            // isn't, so we can adjust the target range start offset if we are confident this is the\n            // swiftkey insert causing the issue.\n\n            if (text && insertPositionHint && type === 'insertCompositionText') {\n              var hintPosition = insertPositionHint.start + insertPositionHint.text.search(/\\S|$/);\n              var diffPosition = diff.start + diff.text.search(/\\S|$/);\n\n              if (diffPosition === hintPosition + 1 && diff.end === insertPositionHint.start + insertPositionHint.text.length) {\n                diff.start -= 1;\n                insertPositionHint = null;\n                scheduleFlush();\n              } else {\n                insertPositionHint = false;\n              }\n            } else if (type === 'insertText') {\n              if (insertPositionHint === null) {\n                insertPositionHint = diff;\n              } else if (insertPositionHint && index_es_Range.isCollapsed(targetRange) && insertPositionHint.end + insertPositionHint.text.length === _start2.offset) {\n                insertPositionHint = index_es_objectSpread$3(index_es_objectSpread$3({}, insertPositionHint), {}, {\n                  text: insertPositionHint.text + text\n                });\n              } else {\n                insertPositionHint = false;\n              }\n            } else {\n              insertPositionHint = false;\n            }\n\n            storeDiff(_start2.path, diff);\n            return;\n          }\n\n          return scheduleAction(() => Editor.insertText(editor, text), {\n            at: targetRange\n          });\n        }\n    }\n  };\n\n  var hasPendingAction = () => {\n    return !!EDITOR_TO_PENDING_ACTION.get(editor);\n  };\n\n  var hasPendingDiffs = () => {\n    var _EDITOR_TO_PENDING_DI5;\n\n    return !!((_EDITOR_TO_PENDING_DI5 = EDITOR_TO_PENDING_DIFFS.get(editor)) !== null && _EDITOR_TO_PENDING_DI5 !== void 0 && _EDITOR_TO_PENDING_DI5.length);\n  };\n\n  var hasPendingChanges = () => {\n    return hasPendingAction() || hasPendingDiffs();\n  };\n\n  var isFlushing = () => {\n    return flushing;\n  };\n\n  var handleUserSelect = range => {\n    EDITOR_TO_PENDING_SELECTION.set(editor, range);\n\n    if (flushTimeoutId) {\n      clearTimeout(flushTimeoutId);\n      flushTimeoutId = null;\n    }\n\n    var {\n      selection\n    } = editor;\n\n    if (!range) {\n      return;\n    }\n\n    var pathChanged = !selection || !Path.equals(selection.anchor.path, range.anchor.path);\n    var parentPathChanged = !selection || !Path.equals(selection.anchor.path.slice(0, -1), range.anchor.path.slice(0, -1));\n\n    if (pathChanged && insertPositionHint || parentPathChanged) {\n      insertPositionHint = false;\n    }\n\n    if (pathChanged || !hasPendingDiffs()) {\n      flushTimeoutId = setTimeout(flush, FLUSH_DELAY);\n    }\n  };\n\n  var handleInput = () => {\n    if (hasPendingAction() || !hasPendingDiffs()) {\n      flush();\n    }\n  };\n\n  var handleKeyDown = _ => {\n    // COMPAT: Swiftkey closes the keyboard when typing inside a empty node\n    // directly next to a non-contenteditable element (= the placeholder).\n    // The only event fired soon enough for us to allow hiding the placeholder\n    // without swiftkey picking it up is the keydown event, so we have to hide it\n    // here. See https://github.com/ianstormtaylor/slate/pull/4988#issuecomment-1201050535\n    if (!hasPendingDiffs()) {\n      updatePlaceholderVisibility(true);\n      setTimeout(updatePlaceholderVisibility);\n    }\n  };\n\n  var scheduleFlush = () => {\n    if (!hasPendingAction()) {\n      actionTimeoutId = setTimeout(flush);\n    }\n  };\n\n  var handleDomMutations = mutations => {\n    if (hasPendingDiffs() || hasPendingAction()) {\n      return;\n    }\n\n    if (mutations.some(mutation => isTrackedMutation(editor, mutation, mutations))) {\n      var _EDITOR_TO_FORCE_REND;\n\n      // Cause a re-render to restore the dom state if we encounter tracked mutations without\n      // a corresponding pending action.\n      (_EDITOR_TO_FORCE_REND = EDITOR_TO_FORCE_RENDER.get(editor)) === null || _EDITOR_TO_FORCE_REND === void 0 ? void 0 : _EDITOR_TO_FORCE_REND();\n    }\n  };\n\n  return {\n    flush,\n    scheduleFlush,\n    hasPendingDiffs,\n    hasPendingAction,\n    hasPendingChanges,\n    isFlushing,\n    handleUserSelect,\n    handleCompositionEnd,\n    handleCompositionStart,\n    handleDOMBeforeInput,\n    handleKeyDown,\n    handleDomMutations,\n    handleInput\n  };\n}\n\nfunction useIsMounted() {\n  var isMountedRef = (0,react.useRef)(false);\n  (0,react.useEffect)(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  return isMountedRef.current;\n}\n\nfunction useMutationObserver(node, callback, options) {\n  var [mutationObserver] = (0,react.useState)(() => new MutationObserver(callback));\n  useIsomorphicLayoutEffect(() => {\n    // Discard mutations caused during render phase. This works due to react calling\n    // useLayoutEffect synchronously after the render phase before the next tick.\n    mutationObserver.takeRecords();\n  });\n  (0,react.useEffect)(() => {\n    if (!node.current) {\n      throw new Error('Failed to attach MutationObserver, `node` is undefined');\n    }\n\n    mutationObserver.observe(node.current, options);\n    return () => mutationObserver.disconnect();\n  }, []);\n}\n\nvar index_es_excluded$2 = [\"node\"];\n\nfunction index_es_ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction index_es_objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { index_es_ownKeys$2(Object(source), true).forEach(function (key) { index_es_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { index_es_ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar MUTATION_OBSERVER_CONFIG = {\n  subtree: true,\n  childList: true,\n  characterData: true\n};\nfunction useAndroidInputManager(_ref) {\n  var {\n    node\n  } = _ref,\n      options = index_es_objectWithoutProperties(_ref, index_es_excluded$2);\n\n  if (!IS_ANDROID) {\n    return null;\n  }\n\n  var editor = useSlateStatic();\n  var isMounted = useIsMounted();\n  var [inputManager] = (0,react.useState)(() => createAndroidInputManager(index_es_objectSpread$2({\n    editor\n  }, options)));\n  useMutationObserver(node, inputManager.handleDomMutations, MUTATION_OBSERVER_CONFIG);\n  EDITOR_TO_SCHEDULE_FLUSH.set(editor, inputManager.scheduleFlush);\n\n  if (isMounted) {\n    inputManager.flush();\n  }\n\n  return inputManager;\n}\n\nfunction useTrackUserInput() {\n  var editor = useSlateStatic();\n  var receivedUserInput = (0,react.useRef)(false);\n  var animationFrameIdRef = (0,react.useRef)(0);\n  var onUserInput = (0,react.useCallback)(() => {\n    if (receivedUserInput.current) {\n      return;\n    }\n\n    receivedUserInput.current = true;\n    var window = ReactEditor.getWindow(editor);\n    window.cancelAnimationFrame(animationFrameIdRef.current);\n    animationFrameIdRef.current = window.requestAnimationFrame(() => {\n      receivedUserInput.current = false;\n    });\n  }, []);\n  (0,react.useEffect)(() => () => cancelAnimationFrame(animationFrameIdRef.current), []);\n  return {\n    receivedUserInput,\n    onUserInput\n  };\n}\n\nvar index_es_excluded$1 = [\"autoFocus\", \"decorate\", \"onDOMBeforeInput\", \"placeholder\", \"readOnly\", \"renderElement\", \"renderLeaf\", \"renderPlaceholder\", \"scrollSelectionIntoView\", \"style\", \"as\"],\n    index_es_excluded2 = [\"text\"];\n\nfunction index_es_ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction index_es_objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { index_es_ownKeys$1(Object(source), true).forEach(function (key) { index_es_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { index_es_ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Children = props => /*#__PURE__*/react.createElement(react.Fragment, null, useChildren(props)); // The number of Editable components currently mounted.\n\n\nvar mountedCount = 0;\n/**\r\n * Editable.\r\n */\n\nvar Editable = props => {\n  var {\n    autoFocus,\n    decorate = defaultDecorate,\n    onDOMBeforeInput: propsOnDOMBeforeInput,\n    placeholder,\n    readOnly = false,\n    renderElement,\n    renderLeaf,\n    renderPlaceholder = props => /*#__PURE__*/react.createElement(DefaultPlaceholder, Object.assign({}, props)),\n    scrollSelectionIntoView = defaultScrollSelectionIntoView,\n    style = {},\n    as: Component = 'div'\n  } = props,\n      attributes = index_es_objectWithoutProperties(props, index_es_excluded$1);\n\n  var editor = useSlate(); // Rerender editor when composition status changed\n\n  var [isComposing, setIsComposing] = (0,react.useState)(false);\n  var ref = (0,react.useRef)(null);\n  var deferredOperations = (0,react.useRef)([]);\n  var {\n    onUserInput,\n    receivedUserInput\n  } = useTrackUserInput();\n  var [, forceRender] = (0,react.useReducer)(s => s + 1, 0);\n  EDITOR_TO_FORCE_RENDER.set(editor, forceRender); // Update internal state on each render.\n\n  IS_READ_ONLY.set(editor, readOnly); // Keep track of some state for the event handler logic.\n\n  var state = (0,react.useMemo)(() => ({\n    isDraggingInternally: false,\n    isUpdatingSelection: false,\n    latestElement: null,\n    hasMarkPlaceholder: false\n  }), []); // The autoFocus TextareaHTMLAttribute doesn't do anything on a div, so it\n  // needs to be manually focused.\n\n  (0,react.useEffect)(() => {\n    if (ref.current && autoFocus) {\n      ref.current.focus();\n    }\n  }, [autoFocus]); // Listen on the native `selectionchange` event to be able to update any time\n  // the selection changes. This is required because React's `onSelect` is leaky\n  // and non-standard so it doesn't fire until after a selection has been\n  // released. This causes issues in situations where another change happens\n  // while a selection is being dragged.\n\n  var onDOMSelectionChange = (0,react.useCallback)(throttle_default()(() => {\n    if ((IS_ANDROID || !ReactEditor.isComposing(editor)) && (!state.isUpdatingSelection || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing()) && !state.isDraggingInternally) {\n      var root = ReactEditor.findDocumentOrShadowRoot(editor);\n      var {\n        activeElement\n      } = root;\n      var el = ReactEditor.toDOMNode(editor, editor);\n      var domSelection = root.getSelection();\n\n      if (activeElement === el) {\n        state.latestElement = activeElement;\n        IS_FOCUSED.set(editor, true);\n      } else {\n        IS_FOCUSED.delete(editor);\n      }\n\n      if (!domSelection) {\n        return Transforms.deselect(editor);\n      }\n\n      var {\n        anchorNode,\n        focusNode\n      } = domSelection;\n      var anchorNodeSelectable = ReactEditor.hasEditableTarget(editor, anchorNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, anchorNode);\n      var focusNodeSelectable = ReactEditor.hasEditableTarget(editor, focusNode) || ReactEditor.isTargetInsideNonReadonlyVoid(editor, focusNode);\n\n      if (anchorNodeSelectable && focusNodeSelectable) {\n        var range = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n\n        if (range) {\n          if (!ReactEditor.isComposing(editor) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingChanges()) && !(androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.isFlushing())) {\n            Transforms.select(editor, range);\n          } else {\n            androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleUserSelect(range);\n          }\n        }\n      } // Deselect the editor if the dom selection is not selectable in readonly mode\n\n\n      if (readOnly && (!anchorNodeSelectable || !focusNodeSelectable)) {\n        Transforms.deselect(editor);\n      }\n    }\n  }, 100), [readOnly]);\n  var scheduleOnDOMSelectionChange = (0,react.useMemo)(() => debounce_default()(onDOMSelectionChange, 0), [onDOMSelectionChange]);\n  var androidInputManager = useAndroidInputManager({\n    node: ref,\n    onDOMSelectionChange,\n    scheduleOnDOMSelectionChange\n  });\n  useIsomorphicLayoutEffect(() => {\n    // Update element-related weak maps with the DOM element ref.\n    var window;\n\n    if (ref.current && (window = getDefaultView(ref.current))) {\n      EDITOR_TO_WINDOW.set(editor, window);\n      EDITOR_TO_ELEMENT.set(editor, ref.current);\n      NODE_TO_ELEMENT.set(editor, ref.current);\n      ELEMENT_TO_NODE.set(ref.current, editor);\n    } else {\n      NODE_TO_ELEMENT.delete(editor);\n    } // Make sure the DOM selection state is in sync.\n\n\n    var {\n      selection\n    } = editor;\n    var root = ReactEditor.findDocumentOrShadowRoot(editor);\n    var domSelection = root.getSelection();\n\n    if (!domSelection || !ReactEditor.isFocused(editor) || androidInputManager !== null && androidInputManager !== void 0 && androidInputManager.hasPendingAction()) {\n      return;\n    }\n\n    var setDomSelection = forceChange => {\n      var hasDomSelection = domSelection.type !== 'None'; // If the DOM selection is properly unset, we're done.\n\n      if (!selection && !hasDomSelection) {\n        return;\n      } // verify that the dom selection is in the editor\n\n\n      var editorElement = EDITOR_TO_ELEMENT.get(editor);\n      var hasDomSelectionInEditor = false;\n\n      if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {\n        hasDomSelectionInEditor = true;\n      } // If the DOM selection is in the editor and the editor selection is already correct, we're done.\n\n\n      if (hasDomSelection && hasDomSelectionInEditor && selection && !forceChange) {\n        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: true,\n          // domSelection is not necessarily a valid Slate range\n          // (e.g. when clicking on contentEditable:false element)\n          suppressThrow: true\n        });\n\n        if (slateRange && index_es_Range.equals(slateRange, selection)) {\n          var _anchorNode$parentEle;\n\n          if (!state.hasMarkPlaceholder) {\n            return;\n          } // Ensure selection is inside the mark placeholder\n\n\n          var {\n            anchorNode\n          } = domSelection;\n\n          if (anchorNode !== null && anchorNode !== void 0 && (_anchorNode$parentEle = anchorNode.parentElement) !== null && _anchorNode$parentEle !== void 0 && _anchorNode$parentEle.hasAttribute('data-slate-mark-placeholder')) {\n            return;\n          }\n        }\n      } // when <Editable/> is being controlled through external value\n      // then its children might just change - DOM responds to it on its own\n      // but Slate's value is not being updated through any operation\n      // and thus it doesn't transform selection on its own\n\n\n      if (selection && !ReactEditor.hasRange(editor, selection)) {\n        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {\n          exactMatch: false,\n          suppressThrow: true\n        });\n        return;\n      } // Otherwise the DOM selection is out of sync, so update it.\n\n\n      state.isUpdatingSelection = true;\n      var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);\n\n      if (newDomRange) {\n        if (index_es_Range.isBackward(selection)) {\n          domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);\n        } else {\n          domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);\n        }\n\n        scrollSelectionIntoView(editor, newDomRange);\n      } else {\n        domSelection.removeAllRanges();\n      }\n\n      return newDomRange;\n    };\n\n    var newDomRange = setDomSelection();\n    var ensureSelection = (androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.isFlushing()) === 'action';\n\n    if (!IS_ANDROID || !ensureSelection) {\n      setTimeout(() => {\n        // COMPAT: In Firefox, it's not enough to create a range, you also need\n        // to focus the contenteditable element too. (2016/11/16)\n        if (newDomRange && IS_FIREFOX) {\n          var el = ReactEditor.toDOMNode(editor, editor);\n          el.focus();\n        }\n\n        state.isUpdatingSelection = false;\n      });\n      return;\n    }\n\n    var timeoutId = null;\n    var animationFrameId = requestAnimationFrame(() => {\n      if (ensureSelection) {\n        var ensureDomSelection = forceChange => {\n          try {\n            var el = ReactEditor.toDOMNode(editor, editor);\n            el.focus();\n            setDomSelection(forceChange);\n          } catch (e) {// Ignore, dom and state might be out of sync\n          }\n        }; // Compat: Android IMEs try to force their selection by manually re-applying it even after we set it.\n        // This essentially would make setting the slate selection during an update meaningless, so we force it\n        // again here. We can't only do it in the setTimeout after the animation frame since that would cause a\n        // visible flicker.\n\n\n        ensureDomSelection();\n        timeoutId = setTimeout(() => {\n          // COMPAT: While setting the selection in an animation frame visually correctly sets the selection,\n          // it doesn't update GBoards spellchecker state. We have to manually trigger a selection change after\n          // the animation frame to ensure it displays the correct state.\n          ensureDomSelection(true);\n          state.isUpdatingSelection = false;\n        });\n      }\n    });\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  }); // Listen on the native `beforeinput` event to get real \"Level 2\" events. This\n  // is required because React's `beforeinput` is fake and never really attaches\n  // to the real event sadly. (2019/11/01)\n  // https://github.com/facebook/react/issues/11211\n\n  var onDOMBeforeInput = (0,react.useCallback)(event => {\n    onUserInput();\n\n    if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {\n      var _EDITOR_TO_USER_SELEC;\n\n      // COMPAT: BeforeInput events aren't cancelable on android, so we have to handle them differently using the android input manager.\n      if (androidInputManager) {\n        return androidInputManager.handleDOMBeforeInput(event);\n      } // Some IMEs/Chrome extensions like e.g. Grammarly set the selection immediately before\n      // triggering a `beforeinput` expecting the change to be applied to the immediately before\n      // set selection.\n\n\n      scheduleOnDOMSelectionChange.flush();\n      onDOMSelectionChange.flush();\n      var {\n        selection\n      } = editor;\n      var {\n        inputType: type\n      } = event;\n      var data = event.dataTransfer || event.data || undefined;\n      var isCompositionChange = type === 'insertCompositionText' || type === 'deleteCompositionText'; // COMPAT: use composition change events as a hint to where we should insert\n      // composition text if we aren't composing to work around https://github.com/ianstormtaylor/slate/issues/5038\n\n      if (isCompositionChange && ReactEditor.isComposing(editor)) {\n        return;\n      }\n\n      var native = false;\n\n      if (type === 'insertText' && selection && index_es_Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.\n      // Long-press events (hold a + press 4 = \xe4) to choose a special character otherwise\n      // causes duplicate inserts.\n      event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405\n      // When there is an inline element, e.g. a link, and you select\n      // right after it (the start of the next node).\n      selection.anchor.offset !== 0) {\n        var _node$parentElement, _window$getComputedSt;\n\n        native = true; // Skip native if there are marks, as\n        // `insertText` will insert a node, not just text.\n\n        if (editor.marks) {\n          native = false;\n        } // Chrome also has issues correctly editing the end of anchor elements: https://bugs.chromium.org/p/chromium/issues/detail?id=1259100\n        // Therefore we don't allow native events to insert text at the end of anchor nodes.\n\n\n        var {\n          anchor\n        } = selection;\n        var [node, offset] = ReactEditor.toDOMPoint(editor, anchor);\n        var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest('a');\n        var window = ReactEditor.getWindow(editor);\n\n        if (native && anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {\n          var _lastText$textContent;\n\n          // Find the last text node inside the anchor.\n          var lastText = window === null || window === void 0 ? void 0 : window.document.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();\n\n          if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset) {\n            native = false;\n          }\n        } // Chrome has issues with the presence of tab characters inside elements with whiteSpace = 'pre'\n        // causing abnormal insert behavior: https://bugs.chromium.org/p/chromium/issues/detail?id=1219139\n\n\n        if (native && node.parentElement && (window === null || window === void 0 ? void 0 : (_window$getComputedSt = window.getComputedStyle(node.parentElement)) === null || _window$getComputedSt === void 0 ? void 0 : _window$getComputedSt.whiteSpace) === 'pre') {\n          var block = Editor.above(editor, {\n            at: anchor.path,\n            match: n => Editor.isBlock(editor, n)\n          });\n\n          if (block && Node.string(block[0]).includes('\\t')) {\n            native = false;\n          }\n        }\n      } // COMPAT: For the deleting forward/backward input types we don't want\n      // to change the selection because it is the range that will be deleted,\n      // and those commands determine that for themselves.\n\n\n      if (!type.startsWith('delete') || type.startsWith('deleteBy')) {\n        var [targetRange] = event.getTargetRanges();\n\n        if (targetRange) {\n          var range = ReactEditor.toSlateRange(editor, targetRange, {\n            exactMatch: false,\n            suppressThrow: false\n          });\n\n          if (!selection || !index_es_Range.equals(selection, range)) {\n            native = false;\n            var selectionRef = !isCompositionChange && editor.selection && Editor.rangeRef(editor, editor.selection);\n            Transforms.select(editor, range);\n\n            if (selectionRef) {\n              EDITOR_TO_USER_SELECTION.set(editor, selectionRef);\n            }\n          }\n        }\n      } // Composition change types occur while a user is composing text and can't be\n      // cancelled. Let them through and wait for the composition to end.\n\n\n      if (isCompositionChange) {\n        return;\n      }\n\n      if (!native) {\n        event.preventDefault();\n      } // COMPAT: If the selection is expanded, even if the command seems like\n      // a delete forward/backward command it should delete the selection.\n\n\n      if (selection && index_es_Range.isExpanded(selection) && type.startsWith('delete')) {\n        var direction = type.endsWith('Backward') ? 'backward' : 'forward';\n        Editor.deleteFragment(editor, {\n          direction\n        });\n        return;\n      }\n\n      switch (type) {\n        case 'deleteByComposition':\n        case 'deleteByCut':\n        case 'deleteByDrag':\n          {\n            Editor.deleteFragment(editor);\n            break;\n          }\n\n        case 'deleteContent':\n        case 'deleteContentForward':\n          {\n            Editor.deleteForward(editor);\n            break;\n          }\n\n        case 'deleteContentBackward':\n          {\n            Editor.deleteBackward(editor);\n            break;\n          }\n\n        case 'deleteEntireSoftLine':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteHardLineBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n\n        case 'deleteSoftLineBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteHardLineForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'block'\n            });\n            break;\n          }\n\n        case 'deleteSoftLineForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'line'\n            });\n            break;\n          }\n\n        case 'deleteWordBackward':\n          {\n            Editor.deleteBackward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n\n        case 'deleteWordForward':\n          {\n            Editor.deleteForward(editor, {\n              unit: 'word'\n            });\n            break;\n          }\n\n        case 'insertLineBreak':\n          Editor.insertSoftBreak(editor);\n          break;\n\n        case 'insertParagraph':\n          {\n            Editor.insertBreak(editor);\n            break;\n          }\n\n        case 'insertFromComposition':\n        case 'insertFromDrop':\n        case 'insertFromPaste':\n        case 'insertFromYank':\n        case 'insertReplacementText':\n        case 'insertText':\n          {\n            if (type === 'insertFromComposition') {\n              // COMPAT: in Safari, `compositionend` is dispatched after the\n              // `beforeinput` for \"insertFromComposition\". But if we wait for it\n              // then we will abort because we're still composing and the selection\n              // won't be updated properly.\n              // https://www.w3.org/TR/input-events-2/\n              if (ReactEditor.isComposing(editor)) {\n                setIsComposing(false);\n                IS_COMPOSING.set(editor, false);\n              }\n            } // use a weak comparison instead of 'instanceof' to allow\n            // programmatic access of paste events coming from external windows\n            // like cypress where cy.window does not work realibly\n\n\n            if ((data === null || data === void 0 ? void 0 : data.constructor.name) === 'DataTransfer') {\n              ReactEditor.insertData(editor, data);\n            } else if (typeof data === 'string') {\n              // Only insertText operations use the native functionality, for now.\n              // Potentially expand to single character deletes, as well.\n              if (native) {\n                deferredOperations.current.push(() => Editor.insertText(editor, data));\n              } else {\n                Editor.insertText(editor, data);\n              }\n            }\n\n            break;\n          }\n      } // Restore the actual user section if nothing manually set it.\n\n\n      var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n      EDITOR_TO_USER_SELECTION.delete(editor);\n\n      if (toRestore && (!editor.selection || !index_es_Range.equals(editor.selection, toRestore))) {\n        Transforms.select(editor, toRestore);\n      }\n    }\n  }, [readOnly, propsOnDOMBeforeInput]); // Attach a native DOM event handler for `beforeinput` events, because React's\n  // built-in `onBeforeInput` is actually a leaky polyfill that doesn't expose\n  // real `beforeinput` events sadly... (2019/11/04)\n  // https://github.com/facebook/react/issues/11211\n\n  useIsomorphicLayoutEffect(() => {\n    if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n      // @ts-ignore The `beforeinput` event isn't recognized.\n      ref.current.addEventListener('beforeinput', onDOMBeforeInput);\n    }\n\n    return () => {\n      if (ref.current && HAS_BEFORE_INPUT_SUPPORT) {\n        // @ts-ignore The `beforeinput` event isn't recognized.\n        ref.current.removeEventListener('beforeinput', onDOMBeforeInput);\n      }\n    };\n  }, [onDOMBeforeInput]); // Attach a native DOM event handler for `selectionchange`, because React's\n  // built-in `onSelect` handler doesn't fire for all selection changes. It's a\n  // leaky polyfill that only fires on keypresses or clicks. Instead, we want to\n  // fire for any change to the selection inside the editor. (2019/11/04)\n  // https://github.com/facebook/react/issues/5785\n\n  useIsomorphicLayoutEffect(() => {\n    var window = ReactEditor.getWindow(editor);\n    window.document.addEventListener('selectionchange', scheduleOnDOMSelectionChange);\n    return () => {\n      window.document.removeEventListener('selectionchange', scheduleOnDOMSelectionChange);\n    };\n  }, [scheduleOnDOMSelectionChange]);\n  var decorations = decorate([editor, []]);\n\n  if (placeholder && editor.children.length === 1 && Array.from(Node.texts(editor)).length === 1 && Node.string(editor) === '' && !isComposing) {\n    var start = Editor.start(editor, []);\n    decorations.push({\n      [PLACEHOLDER_SYMBOL]: true,\n      placeholder,\n      anchor: start,\n      focus: start\n    });\n  }\n\n  var {\n    marks\n  } = editor;\n  state.hasMarkPlaceholder = false;\n\n  if (editor.selection && index_es_Range.isCollapsed(editor.selection) && marks) {\n    var {\n      anchor\n    } = editor.selection;\n    var leaf = Node.leaf(editor, anchor.path);\n\n    var rest = index_es_objectWithoutProperties(leaf, index_es_excluded2); // While marks isn't a 'complete' text, we can still use loose Text.equals\n    // here which only compares marks anyway.\n\n\n    if (!Text.equals(leaf, marks, {\n      loose: true\n    })) {\n      state.hasMarkPlaceholder = true;\n      var unset = Object.fromEntries(Object.keys(rest).map(mark => [mark, null]));\n      decorations.push(index_es_objectSpread$1(index_es_objectSpread$1(index_es_objectSpread$1({\n        [MARK_PLACEHOLDER_SYMBOL]: true\n      }, unset), marks), {}, {\n        anchor,\n        focus: anchor\n      }));\n    }\n  } // Update EDITOR_TO_MARK_PLACEHOLDER_MARKS in setTimeout useEffect to ensure we don't set it\n  // before we receive the composition end event.\n\n\n  (0,react.useEffect)(() => {\n    setTimeout(() => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        var {\n          anchor: _anchor\n        } = selection;\n\n        var _text = Node.leaf(editor, _anchor.path); // While marks isn't a 'complete' text, we can still use loose Text.equals\n        // here which only compares marks anyway.\n\n\n        if (marks && !Text.equals(_text, marks, {\n          loose: true\n        })) {\n          EDITOR_TO_PENDING_INSERTION_MARKS.set(editor, marks);\n          return;\n        }\n      }\n\n      EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor);\n    });\n  });\n  (0,react.useEffect)(() => {\n    mountedCount++;\n\n    if (mountedCount === 1) {\n      // Set global default styles for editors.\n      var defaultStylesElement = document.createElement('style');\n      defaultStylesElement.setAttribute('data-slate-default-styles', 'true');\n      defaultStylesElement.innerHTML = // :where is used to give these rules lower specificity so user stylesheets can override them.\n      \":where([data-slate-editor]) {\" + // Allow positioning relative to the editable element.\n      \"position: relative;\" + // Prevent the default outline styles.\n      \"outline: none;\" + // Preserve adjacent whitespace and new lines.\n      \"white-space: pre-wrap;\" + // Allow words to break if they are too long.\n      \"word-wrap: break-word;\" + \"}\";\n      document.head.appendChild(defaultStylesElement);\n    }\n\n    return () => {\n      var _document$querySelect;\n\n      mountedCount--;\n      if (mountedCount <= 0) (_document$querySelect = document.querySelector('style[data-slate-default-styles]')) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.remove();\n    };\n  }, []);\n  (0,react.useEffect)(() => {\n    var styleElement = document.createElement('style');\n    document.head.appendChild(styleElement);\n    EDITOR_TO_STYLE_ELEMENT.set(editor, styleElement);\n    return () => {\n      styleElement.remove();\n      EDITOR_TO_STYLE_ELEMENT.delete(editor);\n    };\n  }, []);\n  return /*#__PURE__*/react.createElement(ReadOnlyContext.Provider, {\n    value: readOnly\n  }, /*#__PURE__*/react.createElement(DecorateContext.Provider, {\n    value: decorate\n  }, /*#__PURE__*/react.createElement(RestoreDOM, {\n    node: ref,\n    receivedUserInput: receivedUserInput\n  }, /*#__PURE__*/react.createElement(Component, Object.assign({\n    role: readOnly ? undefined : 'textbox',\n    \"aria-multiline\": readOnly ? undefined : true\n  }, attributes, {\n    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd\n    // have to use hacks to make these replacement-based features work.\n    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop\n    // mismatch warning app moves to browser. Pass-through consumer props when\n    // not CAN_USE_DOM (SSR) and default to falsy value\n    spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,\n    autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : 'false',\n    autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : 'false',\n    \"data-slate-editor\": true,\n    \"data-slate-editor-id\": editor.id,\n    \"data-slate-node\": \"value\",\n    // explicitly set this\n    contentEditable: !readOnly,\n    // in some cases, a decoration needs access to the range / selection to decorate a text node,\n    // then you will select the whole text node when you select part the of text\n    // this magic zIndex=\"-1\" will fix it\n    zindex: -1,\n    suppressContentEditableWarning: true,\n    ref: ref,\n    style: style,\n    onBeforeInput: (0,react.useCallback)(event => {\n      // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n      // fall back to React's leaky polyfill instead just for it. It\n      // only works for the `insertText` input type.\n      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && ReactEditor.hasSelectableTarget(editor, event.target)) {\n        event.preventDefault();\n\n        if (!ReactEditor.isComposing(editor)) {\n          var _text2 = event.data;\n          Editor.insertText(editor, _text2);\n        }\n      }\n    }, [readOnly]),\n    onInput: (0,react.useCallback)(event => {\n      if (androidInputManager) {\n        androidInputManager.handleInput();\n        return;\n      } // Flush native operations, as native events will have propogated\n      // and we can correctly compare DOM text values in components\n      // to stop rendering, so that browser functions like autocorrect\n      // and spellcheck work as expected.\n\n\n      for (var op of deferredOperations.current) {\n        op();\n      }\n\n      deferredOperations.current = [];\n    }, []),\n    onBlur: (0,react.useCallback)(event => {\n      if (readOnly || state.isUpdatingSelection || !ReactEditor.hasSelectableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {\n        return;\n      } // COMPAT: If the current `activeElement` is still the previous\n      // one, this is due to the window being blurred when the tab\n      // itself becomes unfocused, so we want to abort early to allow to\n      // editor to stay focused when the tab becomes focused again.\n\n\n      var root = ReactEditor.findDocumentOrShadowRoot(editor);\n\n      if (state.latestElement === root.activeElement) {\n        return;\n      }\n\n      var {\n        relatedTarget\n      } = event;\n      var el = ReactEditor.toDOMNode(editor, editor); // COMPAT: The event should be ignored if the focus is returning\n      // to the editor from an embedded editable element (eg. an <input>\n      // element inside a void node).\n\n      if (relatedTarget === el) {\n        return;\n      } // COMPAT: The event should be ignored if the focus is moving from\n      // the editor to inside a void node's spacer element.\n\n\n      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute('data-slate-spacer')) {\n        return;\n      } // COMPAT: The event should be ignored if the focus is moving to a\n      // non- editable section of an element that isn't a void node (eg.\n      // a list item of the check list example).\n\n\n      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {\n        var node = ReactEditor.toSlateNode(editor, relatedTarget);\n\n        if (Element.isElement(node) && !editor.isVoid(node)) {\n          return;\n        }\n      } // COMPAT: Safari doesn't always remove the selection even if the content-\n      // editable element no longer has focus. Refer to:\n      // https://stackoverflow.com/questions/12353247/force-contenteditable-div-to-stop-accepting-input-after-it-loses-focus-under-web\n\n\n      if (IS_SAFARI) {\n        var domSelection = root.getSelection();\n        domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges();\n      }\n\n      IS_FOCUSED.delete(editor);\n    }, [readOnly, attributes.onBlur]),\n    onClick: (0,react.useCallback)(event => {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node); // At this time, the Slate document may be arbitrarily different,\n        // because onClick handlers can change the document before we get here.\n        // Therefore we must check that this path actually exists,\n        // and that it still refers to the same node.\n\n        if (!Editor.hasPath(editor, path) || Node.get(editor, path) !== node) {\n          return;\n        }\n\n        if (event.detail === TRIPLE_CLICK && path.length >= 1) {\n          var blockPath = path;\n\n          if (!Editor.isBlock(editor, node)) {\n            var _block$;\n\n            var block = Editor.above(editor, {\n              match: n => Editor.isBlock(editor, n),\n              at: path\n            });\n            blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);\n          }\n\n          var range = Editor.range(editor, blockPath);\n          Transforms.select(editor, range);\n          return;\n        }\n\n        if (readOnly) {\n          return;\n        }\n\n        var _start = Editor.start(editor, path);\n\n        var end = Editor.end(editor, path);\n        var startVoid = Editor[\"void\"](editor, {\n          at: _start\n        });\n        var endVoid = Editor[\"void\"](editor, {\n          at: end\n        });\n\n        if (startVoid && endVoid && Path.equals(startVoid[1], endVoid[1])) {\n          var _range = Editor.range(editor, _start);\n\n          Transforms.select(editor, _range);\n        }\n      }\n    }, [readOnly, attributes.onClick]),\n    onCompositionEnd: (0,react.useCallback)(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        if (ReactEditor.isComposing(editor)) {\n          setIsComposing(false);\n          IS_COMPOSING.set(editor, false);\n        }\n\n        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionEnd(event);\n\n        if (isEventHandled(event, attributes.onCompositionEnd) || IS_ANDROID) {\n          return;\n        } // COMPAT: In Chrome, `beforeinput` events for compositions\n        // aren't correct and never fire the \"insertFromComposition\"\n        // type that we need. So instead, insert whenever a composition\n        // ends since it will already have been committed to the DOM.\n\n\n        if (!IS_SAFARI && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_QQBROWSER && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {\n          var placeholderMarks = EDITOR_TO_PENDING_INSERTION_MARKS.get(editor);\n          EDITOR_TO_PENDING_INSERTION_MARKS.delete(editor); // Ensure we insert text with the marks the user was actually seeing\n\n          if (placeholderMarks !== undefined) {\n            EDITOR_TO_USER_MARKS.set(editor, editor.marks);\n            editor.marks = placeholderMarks;\n          }\n\n          Editor.insertText(editor, event.data);\n          var userMarks = EDITOR_TO_USER_MARKS.get(editor);\n          EDITOR_TO_USER_MARKS.delete(editor);\n\n          if (userMarks !== undefined) {\n            editor.marks = userMarks;\n          }\n        }\n      }\n    }, [attributes.onCompositionEnd]),\n    onCompositionUpdate: (0,react.useCallback)(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {\n        if (!ReactEditor.isComposing(editor)) {\n          setIsComposing(true);\n          IS_COMPOSING.set(editor, true);\n        }\n      }\n    }, [attributes.onCompositionUpdate]),\n    onCompositionStart: (0,react.useCallback)(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target)) {\n        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleCompositionStart(event);\n\n        if (isEventHandled(event, attributes.onCompositionStart) || IS_ANDROID) {\n          return;\n        }\n\n        setIsComposing(true);\n        var {\n          selection\n        } = editor;\n\n        if (selection) {\n          if (index_es_Range.isExpanded(selection)) {\n            Editor.deleteFragment(editor);\n            return;\n          }\n\n          var inline = Editor.above(editor, {\n            match: n => Editor.isInline(editor, n),\n            mode: 'highest'\n          });\n\n          if (inline) {\n            var [, inlinePath] = inline;\n\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              var point = Editor.after(editor, inlinePath);\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point\n              });\n            }\n          }\n        }\n      }\n    }, [attributes.onCompositionStart]),\n    onCopy: (0,react.useCallback)(event => {\n      if (ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'copy');\n      }\n    }, [attributes.onCopy]),\n    onCut: (0,react.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {\n        event.preventDefault();\n        ReactEditor.setFragmentData(editor, event.clipboardData, 'cut');\n        var {\n          selection\n        } = editor;\n\n        if (selection) {\n          if (index_es_Range.isExpanded(selection)) {\n            Editor.deleteFragment(editor);\n          } else {\n            var node = Node.parent(editor, selection.anchor.path);\n\n            if (Editor.isVoid(editor, node)) {\n              Transforms[\"delete\"](editor);\n            }\n          }\n        }\n      }\n    }, [readOnly, attributes.onCut]),\n    onDragOver: (0,react.useCallback)(event => {\n      if (ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {\n        // Only when the target is void, call `preventDefault` to signal\n        // that drops are allowed. Editable content is droppable by\n        // default, and calling `preventDefault` hides the cursor.\n        var node = ReactEditor.toSlateNode(editor, event.target);\n\n        if (Editor.isVoid(editor, node)) {\n          event.preventDefault();\n        }\n      }\n    }, [attributes.onDragOver]),\n    onDragStart: (0,react.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {\n        var node = ReactEditor.toSlateNode(editor, event.target);\n        var path = ReactEditor.findPath(editor, node);\n        var voidMatch = Editor.isVoid(editor, node) || Editor[\"void\"](editor, {\n          at: path,\n          voids: true\n        }); // If starting a drag on a void node, make sure it is selected\n        // so that it shows up in the selection's fragment.\n\n        if (voidMatch) {\n          var range = Editor.range(editor, path);\n          Transforms.select(editor, range);\n        }\n\n        state.isDraggingInternally = true;\n        ReactEditor.setFragmentData(editor, event.dataTransfer, 'drag');\n      }\n    }, [readOnly, attributes.onDragStart]),\n    onDrop: (0,react.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {\n        event.preventDefault(); // Keep a reference to the dragged range before updating selection\n\n        var draggedRange = editor.selection; // Find the range where the drop happened\n\n        var range = ReactEditor.findEventRange(editor, event);\n        var data = event.dataTransfer;\n        Transforms.select(editor, range);\n\n        if (state.isDraggingInternally) {\n          if (draggedRange && !index_es_Range.equals(draggedRange, range) && !Editor[\"void\"](editor, {\n            at: range,\n            voids: true\n          })) {\n            Transforms[\"delete\"](editor, {\n              at: draggedRange\n            });\n          }\n        }\n\n        ReactEditor.insertData(editor, data); // When dragging from another source into the editor, it's possible\n        // that the current editor does not have focus.\n\n        if (!ReactEditor.isFocused(editor)) {\n          ReactEditor.focus(editor);\n        }\n      }\n\n      state.isDraggingInternally = false;\n    }, [readOnly, attributes.onDrop]),\n    onDragEnd: (0,react.useCallback)(event => {\n      if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && ReactEditor.hasTarget(editor, event.target)) {\n        attributes.onDragEnd(event);\n      } // When dropping on a different droppable element than the current editor,\n      // `onDrop` is not called. So we need to clean up in `onDragEnd` instead.\n      // Note: `onDragEnd` is only called when `onDrop` is not called\n\n\n      state.isDraggingInternally = false;\n    }, [readOnly, attributes.onDragEnd]),\n    onFocus: (0,react.useCallback)(event => {\n      if (!readOnly && !state.isUpdatingSelection && ReactEditor.hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {\n        var el = ReactEditor.toDOMNode(editor, editor);\n        var root = ReactEditor.findDocumentOrShadowRoot(editor);\n        state.latestElement = root.activeElement; // COMPAT: If the editor has nested editable elements, the focus\n        // can go to them. In Firefox, this must be prevented because it\n        // results in issues with keyboard navigation. (2017/03/30)\n\n        if (IS_FIREFOX && event.target !== el) {\n          el.focus();\n          return;\n        }\n\n        IS_FOCUSED.set(editor, true);\n      }\n    }, [readOnly, attributes.onFocus]),\n    onKeyDown: (0,react.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasEditableTarget(editor, event.target)) {\n        androidInputManager === null || androidInputManager === void 0 ? void 0 : androidInputManager.handleKeyDown(event);\n        var {\n          nativeEvent\n        } = event; // COMPAT: The composition end event isn't fired reliably in all browsers,\n        // so we sometimes might end up stuck in a composition state even though we\n        // aren't composing any more.\n\n        if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {\n          IS_COMPOSING.set(editor, false);\n          setIsComposing(false);\n        }\n\n        if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {\n          return;\n        }\n\n        var {\n          selection\n        } = editor;\n        var element = editor.children[selection !== null ? selection.focus.path[0] : 0];\n        var isRTL = direction_default()(Node.string(element)) === 'rtl'; // COMPAT: Since we prevent the default behavior on\n        // `beforeinput` events, the browser doesn't think there's ever\n        // any history stack to undo or redo, so we have to manage these\n        // hotkeys ourselves. (2019/11/06)\n\n        if (Hotkeys.isRedo(nativeEvent)) {\n          event.preventDefault();\n          var maybeHistoryEditor = editor;\n\n          if (typeof maybeHistoryEditor.redo === 'function') {\n            maybeHistoryEditor.redo();\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isUndo(nativeEvent)) {\n          event.preventDefault();\n          var _maybeHistoryEditor = editor;\n\n          if (typeof _maybeHistoryEditor.undo === 'function') {\n            _maybeHistoryEditor.undo();\n          }\n\n          return;\n        } // COMPAT: Certain browsers don't handle the selection updates\n        // properly. In Chrome, the selection isn't properly extended.\n        // And in Firefox, the selection isn't properly collapsed.\n        // (2017/10/17)\n\n\n        if (Hotkeys.isMoveLineBackward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            reverse: true\n          });\n          return;\n        }\n\n        if (Hotkeys.isMoveLineForward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line'\n          });\n          return;\n        }\n\n        if (Hotkeys.isExtendLineBackward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus',\n            reverse: true\n          });\n          return;\n        }\n\n        if (Hotkeys.isExtendLineForward(nativeEvent)) {\n          event.preventDefault();\n          Transforms.move(editor, {\n            unit: 'line',\n            edge: 'focus'\n          });\n          return;\n        } // COMPAT: If a void node is selected, or a zero-width text node\n        // adjacent to an inline is selected, we need to handle these\n        // hotkeys manually because browsers won't be able to skip over\n        // the void node with the zero-width space not being an empty\n        // string.\n\n\n        if (Hotkeys.isMoveBackward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && index_es_Range.isCollapsed(selection)) {\n            Transforms.move(editor, {\n              reverse: !isRTL\n            });\n          } else {\n            Transforms.collapse(editor, {\n              edge: 'start'\n            });\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isMoveForward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && index_es_Range.isCollapsed(selection)) {\n            Transforms.move(editor, {\n              reverse: isRTL\n            });\n          } else {\n            Transforms.collapse(editor, {\n              edge: 'end'\n            });\n          }\n\n          return;\n        }\n\n        if (Hotkeys.isMoveWordBackward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && index_es_Range.isExpanded(selection)) {\n            Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n\n          Transforms.move(editor, {\n            unit: 'word',\n            reverse: !isRTL\n          });\n          return;\n        }\n\n        if (Hotkeys.isMoveWordForward(nativeEvent)) {\n          event.preventDefault();\n\n          if (selection && index_es_Range.isExpanded(selection)) {\n            Transforms.collapse(editor, {\n              edge: 'focus'\n            });\n          }\n\n          Transforms.move(editor, {\n            unit: 'word',\n            reverse: isRTL\n          });\n          return;\n        } // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to guessing at the input intention for hotkeys.\n        // COMPAT: In iOS, some of these hotkeys are handled in the\n\n\n        if (!HAS_BEFORE_INPUT_SUPPORT) {\n          // We don't have a core behavior for these, but they change the\n          // DOM if we don't prevent them, so we have to.\n          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {\n            event.preventDefault();\n            return;\n          }\n\n          if (Hotkeys.isSoftBreak(nativeEvent)) {\n            event.preventDefault();\n            Editor.insertSoftBreak(editor);\n            return;\n          }\n\n          if (Hotkeys.isSplitBlock(nativeEvent)) {\n            event.preventDefault();\n            Editor.insertBreak(editor);\n            return;\n          }\n\n          if (Hotkeys.isDeleteBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && index_es_Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor);\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && index_es_Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor);\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && index_es_Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor, {\n                unit: 'line'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteLineForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && index_es_Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor, {\n                unit: 'line'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && index_es_Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'backward'\n              });\n            } else {\n              Editor.deleteBackward(editor, {\n                unit: 'word'\n              });\n            }\n\n            return;\n          }\n\n          if (Hotkeys.isDeleteWordForward(nativeEvent)) {\n            event.preventDefault();\n\n            if (selection && index_es_Range.isExpanded(selection)) {\n              Editor.deleteFragment(editor, {\n                direction: 'forward'\n              });\n            } else {\n              Editor.deleteForward(editor, {\n                unit: 'word'\n              });\n            }\n\n            return;\n          }\n        } else {\n          if (IS_CHROME || IS_SAFARI) {\n            // COMPAT: Chrome and Safari support `beforeinput` event but do not fire\n            // an event when deleting backwards in a selected void inline node\n            if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && index_es_Range.isCollapsed(selection)) {\n              var currentNode = Node.parent(editor, selection.anchor.path);\n\n              if (Element.isElement(currentNode) && Editor.isVoid(editor, currentNode) && (Editor.isInline(editor, currentNode) || Editor.isBlock(editor, currentNode))) {\n                event.preventDefault();\n                Editor.deleteBackward(editor, {\n                  unit: 'block'\n                });\n                return;\n              }\n            }\n          }\n        }\n      }\n    }, [readOnly, attributes.onKeyDown]),\n    onPaste: (0,react.useCallback)(event => {\n      if (!readOnly && ReactEditor.hasSelectableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {\n        // COMPAT: Certain browsers don't support the `beforeinput` event, so we\n        // fall back to React's `onPaste` here instead.\n        // COMPAT: Firefox, Chrome and Safari don't emit `beforeinput` events\n        // when \"paste without formatting\" is used, so fallback. (2020/02/20)\n        if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent)) {\n          event.preventDefault();\n          ReactEditor.insertData(editor, event.clipboardData);\n        }\n      }\n    }, [readOnly, attributes.onPaste])\n  }), /*#__PURE__*/react.createElement(Children, {\n    decorations: decorations,\n    node: editor,\n    renderElement: renderElement,\n    renderPlaceholder: renderPlaceholder,\n    renderLeaf: renderLeaf,\n    selection: editor.selection\n  })))));\n};\n/**\r\n * The default placeholder element\r\n */\n\nvar DefaultPlaceholder = _ref => {\n  var {\n    attributes,\n    children\n  } = _ref;\n  return (\n    /*#__PURE__*/\n    // COMPAT: Artificially add a line-break to the end on the placeholder element\n    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter\n    react.createElement(\"span\", Object.assign({}, attributes), children, IS_ANDROID && /*#__PURE__*/react.createElement(\"br\", null))\n  );\n};\n/**\r\n * A default memoized decorate function.\r\n */\n\nvar defaultDecorate = () => [];\n/**\r\n * A default implement to scroll dom range into view.\r\n */\n\nvar defaultScrollSelectionIntoView = (editor, domRange) => {\n  // This was affecting the selection of multiple blocks and dragging behavior,\n  // so enabled only if the selection has been collapsed.\n  if (!editor.selection || editor.selection && index_es_Range.isCollapsed(editor.selection)) {\n    var leafEl = domRange.startContainer.parentElement;\n    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);\n    es(leafEl, {\n      scrollMode: 'if-needed'\n    }); // @ts-expect-error an unorthodox delete D:\n\n    delete leafEl.getBoundingClientRect;\n  }\n};\n/**\r\n * Check if an event is overrided by a handler.\r\n */\n\n\nvar isEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  } // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n\n\n  var shouldTreatEventAsHandled = handler(event);\n\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n\n  return event.isDefaultPrevented() || event.isPropagationStopped();\n};\n/**\r\n * Check if a DOM event is overrided by a handler.\r\n */\n\nvar isDOMEventHandled = (event, handler) => {\n  if (!handler) {\n    return false;\n  } // The custom event handler may return a boolean to specify whether the event\n  // shall be treated as being handled or not.\n\n\n  var shouldTreatEventAsHandled = handler(event);\n\n  if (shouldTreatEventAsHandled != null) {\n    return shouldTreatEventAsHandled;\n  }\n\n  return event.defaultPrevented;\n};\n\n/**\r\n * A React context for sharing the `focused` state of the editor.\r\n */\n\nvar FocusedContext = /*#__PURE__*/(0,react.createContext)(false);\n/**\r\n * Get the current `focused` state of the editor.\r\n */\n\nvar useFocused = () => {\n  return useContext(FocusedContext);\n};\n\nfunction isError(error) {\n  return error instanceof Error;\n}\n/**\r\n * A React context for sharing the editor selector context in a way to control rerenders\r\n */\n\n\nvar SlateSelectorContext = /*#__PURE__*/(0,react.createContext)({});\n\nvar refEquality = (a, b) => a === b;\n/**\r\n * use redux style selectors to prevent rerendering on every keystroke.\r\n * Bear in mind rerendering can only prevented if the returned value is a value type or for reference types (e.g. objects and arrays) add a custom equality function.\r\n *\r\n * Example:\r\n * ```\r\n *  const isSelectionActive = useSlateSelector(editor => Boolean(editor.selection));\r\n * ```\r\n */\n\n\nfunction useSlateSelector(selector) {\n  var equalityFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : refEquality;\n  var [, forceRender] = useReducer(s => s + 1, 0);\n  var context = useContext(SlateSelectorContext);\n\n  if (!context) {\n    throw new Error(\"The `useSlateSelector` hook must be used inside the <Slate> component's context.\");\n  }\n\n  var {\n    getSlate,\n    addEventListener\n  } = context;\n  var latestSubscriptionCallbackError = useRef();\n  var latestSelector = useRef(() => null);\n  var latestSelectedState = useRef(null);\n  var selectedState;\n\n  try {\n    if (selector !== latestSelector.current || latestSubscriptionCallbackError.current) {\n      selectedState = selector(getSlate());\n    } else {\n      selectedState = latestSelectedState.current;\n    }\n  } catch (err) {\n    if (latestSubscriptionCallbackError.current && isError(err)) {\n      err.message += \"\\nThe error may be correlated with this previous error:\\n\".concat(latestSubscriptionCallbackError.current.stack, \"\\n\\n\");\n    }\n\n    throw err;\n  }\n\n  useIsomorphicLayoutEffect(() => {\n    latestSelector.current = selector;\n    latestSelectedState.current = selectedState;\n    latestSubscriptionCallbackError.current = undefined;\n  });\n  useIsomorphicLayoutEffect(() => {\n    function checkForUpdates() {\n      try {\n        var newSelectedState = latestSelector.current(getSlate());\n\n        if (equalityFn(newSelectedState, latestSelectedState.current)) {\n          return;\n        }\n\n        latestSelectedState.current = newSelectedState;\n      } catch (err) {\n        // we ignore all errors here, since when the component\n        // is re-rendered, the selectors are called again, and\n        // will throw again, if neither props nor store state\n        // changed\n        latestSubscriptionCallbackError.current = err;\n      }\n\n      forceRender();\n    }\n\n    var unsubscribe = addEventListener(checkForUpdates);\n    checkForUpdates();\n    return () => unsubscribe();\n  }, // don't rerender on equalityFn change since we want to be able to define it inline\n  [addEventListener, getSlate]);\n  return selectedState;\n}\n/**\r\n * Create selector context with editor updating on every editor change\r\n */\n\nfunction getSelectorContext(editor) {\n  var eventListeners = (0,react.useRef)([]).current;\n  var slateRef = (0,react.useRef)({\n    editor\n  }).current;\n  var onChange = (0,react.useCallback)(editor => {\n    slateRef.editor = editor;\n    eventListeners.forEach(listener => listener(editor));\n  }, []);\n  var selectorContext = (0,react.useMemo)(() => {\n    return {\n      getSlate: () => slateRef.editor,\n      addEventListener: callback => {\n        eventListeners.push(callback);\n        return () => {\n          eventListeners.splice(eventListeners.indexOf(callback), 1);\n        };\n      }\n    };\n  }, [eventListeners, slateRef]);\n  return {\n    selectorContext,\n    onChange\n  };\n}\n\nvar index_es_excluded = [\"editor\", \"children\", \"onChange\", \"value\"];\n/**\r\n * A wrapper around the provider to handle `onChange` events, because the editor\r\n * is a mutable singleton so it won't ever register as \"changed\" otherwise.\r\n */\n\nvar Slate = props => {\n  var {\n    editor,\n    children,\n    onChange,\n    value\n  } = props,\n      rest = index_es_objectWithoutProperties(props, index_es_excluded);\n\n  var unmountRef = (0,react.useRef)(false);\n  var [context, setContext] = react.useState(() => {\n    if (!Node.isNodeList(value)) {\n      throw new Error(\"[Slate] value is invalid! Expected a list of elements but got: \".concat(Scrubber.stringify(value)));\n    }\n\n    if (!Editor.isEditor(editor)) {\n      throw new Error(\"[Slate] editor is invalid! You passed: \".concat(Scrubber.stringify(editor)));\n    }\n\n    editor.children = value;\n    Object.assign(editor, rest);\n    return {\n      v: 0,\n      editor\n    };\n  });\n  var {\n    selectorContext,\n    onChange: handleSelectorChange\n  } = getSelectorContext(editor);\n  var onContextChange = (0,react.useCallback)(() => {\n    if (onChange) {\n      onChange(editor.children);\n    }\n\n    setContext(prevContext => ({\n      v: prevContext.v + 1,\n      editor\n    }));\n    handleSelectorChange(editor);\n  }, [onChange]);\n  EDITOR_TO_ON_CHANGE.set(editor, onContextChange);\n  (0,react.useEffect)(() => {\n    return () => {\n      EDITOR_TO_ON_CHANGE.set(editor, () => {});\n      unmountRef.current = true;\n    };\n  }, []);\n  var [isFocused, setIsFocused] = (0,react.useState)(ReactEditor.isFocused(editor));\n  (0,react.useEffect)(() => {\n    setIsFocused(ReactEditor.isFocused(editor));\n  });\n  useIsomorphicLayoutEffect(() => {\n    var fn = () => setIsFocused(ReactEditor.isFocused(editor));\n\n    if (IS_REACT_VERSION_17_OR_ABOVE) {\n      // In React >= 17 onFocus and onBlur listen to the focusin and focusout events during the bubbling phase.\n      // Therefore in order for <Editable />'s handlers to run first, which is necessary for ReactEditor.isFocused(editor)\n      // to return the correct value, we have to listen to the focusin and focusout events without useCapture here.\n      document.addEventListener('focusin', fn);\n      document.addEventListener('focusout', fn);\n      return () => {\n        document.removeEventListener('focusin', fn);\n        document.removeEventListener('focusout', fn);\n      };\n    } else {\n      document.addEventListener('focus', fn, true);\n      document.addEventListener('blur', fn, true);\n      return () => {\n        document.removeEventListener('focus', fn, true);\n        document.removeEventListener('blur', fn, true);\n      };\n    }\n  }, []);\n  return /*#__PURE__*/react.createElement(SlateSelectorContext.Provider, {\n    value: selectorContext\n  }, /*#__PURE__*/react.createElement(SlateContext.Provider, {\n    value: context\n  }, /*#__PURE__*/react.createElement(EditorContext.Provider, {\n    value: context.editor\n  }, /*#__PURE__*/react.createElement(FocusedContext.Provider, {\n    value: isFocused\n  }, children))));\n};\n\n/**\r\n * Get the current editor object from the React context.\r\n * @deprecated Use useSlateStatic instead.\r\n */\n\nvar useEditor = () => {\n  var editor = useContext(EditorContext);\n\n  if (!editor) {\n    throw new Error(\"The `useEditor` hook must be used inside the <Slate> component's context.\");\n  }\n\n  return editor;\n};\n\n/**\r\n * Get the current slate selection.\r\n * Only triggers a rerender when the selection actually changes\r\n */\n\nvar useSlateSelection = () => {\n  return useSlateSelector(editor => editor.selection, isSelectionEqual);\n};\n\nvar isSelectionEqual = (a, b) => {\n  if (!a && !b) return true;\n  if (!a || !b) return false;\n  return Range.equals(a, b);\n};\n\n/**\r\n * Utilities for single-line deletion\r\n */\n\nvar doRectsIntersect = (rect, compareRect) => {\n  var middle = (compareRect.top + compareRect.bottom) / 2;\n  return rect.top <= middle && rect.bottom >= middle;\n};\n\nvar areRangesSameLine = (editor, range1, range2) => {\n  var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();\n  var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();\n  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);\n};\n/**\r\n * A helper utility that returns the end portion of a `Range`\r\n * which is located on a single line.\r\n *\r\n * @param {Editor} editor The editor object to compare against\r\n * @param {Range} parentRange The parent range to compare against\r\n * @returns {Range} A valid portion of the parentRange which is one a single line\r\n */\n\n\nvar findCurrentLineRange = (editor, parentRange) => {\n  var parentRangeBoundary = Editor.range(editor, index_es_Range.end(parentRange));\n  var positions = Array.from(Editor.positions(editor, {\n    at: parentRange\n  }));\n  var left = 0;\n  var right = positions.length;\n  var middle = Math.floor(right / 2);\n\n  if (areRangesSameLine(editor, Editor.range(editor, positions[left]), parentRangeBoundary)) {\n    return Editor.range(editor, positions[left], parentRangeBoundary);\n  }\n\n  if (positions.length < 2) {\n    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);\n  }\n\n  while (middle !== positions.length && middle !== left) {\n    if (areRangesSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary)) {\n      right = middle;\n    } else {\n      left = middle;\n    }\n\n    middle = Math.floor((left + right) / 2);\n  }\n\n  return Editor.range(editor, positions[right], parentRangeBoundary);\n};\n\nfunction index_es_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction index_es_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { index_es_ownKeys(Object(source), true).forEach(function (key) { index_es_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { index_es_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n/**\r\n * `withReact` adds React and DOM specific behaviors to the editor.\r\n *\r\n * If you are using TypeScript, you must extend Slate's CustomTypes to use\r\n * this plugin.\r\n *\r\n * See https://docs.slatejs.org/concepts/11-typescript to learn how.\r\n */\n\nvar withReact = editor => {\n  var e = editor;\n  var {\n    apply,\n    onChange,\n    deleteBackward,\n    addMark,\n    removeMark\n  } = e; // The WeakMap which maps a key to a specific HTMLElement must be scoped to the editor instance to\n  // avoid collisions between editors in the DOM that share the same value.\n\n  EDITOR_TO_KEY_TO_ELEMENT.set(e, new WeakMap());\n\n  e.addMark = (key, value) => {\n    var _EDITOR_TO_SCHEDULE_F, _EDITOR_TO_PENDING_DI;\n\n    (_EDITOR_TO_SCHEDULE_F = EDITOR_TO_SCHEDULE_FLUSH.get(e)) === null || _EDITOR_TO_SCHEDULE_F === void 0 ? void 0 : _EDITOR_TO_SCHEDULE_F();\n\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI !== void 0 && _EDITOR_TO_PENDING_DI.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n\n    EDITOR_TO_USER_MARKS.delete(e);\n    addMark(key, value);\n  };\n\n  e.removeMark = key => {\n    var _EDITOR_TO_PENDING_DI2;\n\n    if (!EDITOR_TO_PENDING_INSERTION_MARKS.get(e) && (_EDITOR_TO_PENDING_DI2 = EDITOR_TO_PENDING_DIFFS.get(e)) !== null && _EDITOR_TO_PENDING_DI2 !== void 0 && _EDITOR_TO_PENDING_DI2.length) {\n      // Ensure the current pending diffs originating from changes before the addMark\n      // are applied with the current formatting\n      EDITOR_TO_PENDING_INSERTION_MARKS.set(e, null);\n    }\n\n    EDITOR_TO_USER_MARKS.delete(e);\n    removeMark(key);\n  };\n\n  e.deleteBackward = unit => {\n    if (unit !== 'line') {\n      return deleteBackward(unit);\n    }\n\n    if (e.selection && index_es_Range.isCollapsed(e.selection)) {\n      var parentBlockEntry = Editor.above(e, {\n        match: n => Editor.isBlock(e, n),\n        at: e.selection\n      });\n\n      if (parentBlockEntry) {\n        var [, parentBlockPath] = parentBlockEntry;\n        var parentElementRange = Editor.range(e, parentBlockPath, e.selection.anchor);\n        var currentLineRange = findCurrentLineRange(e, parentElementRange);\n\n        if (!index_es_Range.isCollapsed(currentLineRange)) {\n          Transforms[\"delete\"](e, {\n            at: currentLineRange\n          });\n        }\n      }\n    }\n  }; // This attempts to reset the NODE_TO_KEY entry to the correct value\n  // as apply() changes the object reference and hence invalidates the NODE_TO_KEY entry\n\n\n  e.apply = op => {\n    var matches = [];\n    var pendingDiffs = EDITOR_TO_PENDING_DIFFS.get(e);\n\n    if (pendingDiffs !== null && pendingDiffs !== void 0 && pendingDiffs.length) {\n      var transformed = pendingDiffs.map(textDiff => transformTextDiff(textDiff, op)).filter(Boolean);\n      EDITOR_TO_PENDING_DIFFS.set(e, transformed);\n    }\n\n    var pendingSelection = EDITOR_TO_PENDING_SELECTION.get(e);\n\n    if (pendingSelection) {\n      EDITOR_TO_PENDING_SELECTION.set(e, transformPendingRange(e, pendingSelection, op));\n    }\n\n    var pendingAction = EDITOR_TO_PENDING_ACTION.get(e);\n\n    if (pendingAction !== null && pendingAction !== void 0 && pendingAction.at) {\n      var at = Point.isPoint(pendingAction === null || pendingAction === void 0 ? void 0 : pendingAction.at) ? transformPendingPoint(e, pendingAction.at, op) : transformPendingRange(e, pendingAction.at, op);\n      EDITOR_TO_PENDING_ACTION.set(e, at ? index_es_objectSpread(index_es_objectSpread({}, pendingAction), {}, {\n        at\n      }) : null);\n    }\n\n    switch (op.type) {\n      case 'insert_text':\n      case 'remove_text':\n      case 'set_node':\n      case 'split_node':\n        {\n          matches.push(...getMatches(e, op.path));\n          break;\n        }\n\n      case 'set_selection':\n        {\n          var _EDITOR_TO_USER_SELEC;\n\n          // Selection was manually set, don't restore the user selection after the change.\n          (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(e)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();\n          EDITOR_TO_USER_SELECTION.delete(e);\n          break;\n        }\n\n      case 'insert_node':\n      case 'remove_node':\n        {\n          matches.push(...getMatches(e, Path.parent(op.path)));\n          break;\n        }\n\n      case 'merge_node':\n        {\n          var prevPath = Path.previous(op.path);\n          matches.push(...getMatches(e, prevPath));\n          break;\n        }\n\n      case 'move_node':\n        {\n          var commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath));\n          matches.push(...getMatches(e, commonPath));\n          break;\n        }\n    }\n\n    apply(op);\n\n    for (var [path, key] of matches) {\n      var [node] = Editor.node(e, path);\n      NODE_TO_KEY.set(node, key);\n    }\n  };\n\n  e.setFragmentData = data => {\n    var {\n      selection\n    } = e;\n\n    if (!selection) {\n      return;\n    }\n\n    var [start, end] = index_es_Range.edges(selection);\n    var startVoid = Editor[\"void\"](e, {\n      at: start.path\n    });\n    var endVoid = Editor[\"void\"](e, {\n      at: end.path\n    });\n\n    if (index_es_Range.isCollapsed(selection) && !startVoid) {\n      return;\n    } // Create a fake selection so that we can add a Base64-encoded copy of the\n    // fragment to the HTML, to decode on future pastes.\n\n\n    var domRange = ReactEditor.toDOMRange(e, selection);\n    var contents = domRange.cloneContents();\n    var attach = contents.childNodes[0]; // Make sure attach is non-empty, since empty nodes will not get copied.\n\n    contents.childNodes.forEach(node => {\n      if (node.textContent && node.textContent.trim() !== '') {\n        attach = node;\n      }\n    }); // COMPAT: If the end node is a void node, we need to move the end of the\n    // range from the void node's spacer span, to the end of the void node's\n    // content, since the spacer is before void's content in the DOM.\n\n    if (endVoid) {\n      var [voidNode] = endVoid;\n      var r = domRange.cloneRange();\n      var domNode = ReactEditor.toDOMNode(e, voidNode);\n      r.setEndAfter(domNode);\n      contents = r.cloneContents();\n    } // COMPAT: If the start node is a void node, we need to attach the encoded\n    // fragment to the void node's content node instead of the spacer, because\n    // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n    // most browsers. (2018/04/27)\n\n\n    if (startVoid) {\n      attach = contents.querySelector('[data-slate-spacer]');\n    } // Remove any zero-width space spans from the cloned DOM so that they don't\n    // show up elsewhere when pasted.\n\n\n    Array.from(contents.querySelectorAll('[data-slate-zero-width]')).forEach(zw => {\n      var isNewline = zw.getAttribute('data-slate-zero-width') === 'n';\n      zw.textContent = isNewline ? '\\n' : '';\n    }); // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n    // in the HTML, and can be used for intra-Slate pasting. If it's a text\n    // node, wrap it in a `<span>` so we have something to set an attribute on.\n\n    if (isDOMText(attach)) {\n      var span = attach.ownerDocument.createElement('span'); // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n      // then leading and trailing spaces will be ignored. (2017/09/21)\n\n      span.style.whiteSpace = 'pre';\n      span.appendChild(attach);\n      contents.appendChild(span);\n      attach = span;\n    }\n\n    var fragment = e.getFragment();\n    var string = JSON.stringify(fragment);\n    var encoded = window.btoa(encodeURIComponent(string));\n    attach.setAttribute('data-slate-fragment', encoded);\n    data.setData('application/x-slate-fragment', encoded); // Add the content to a <div> so that we can get its inner HTML.\n\n    var div = contents.ownerDocument.createElement('div');\n    div.appendChild(contents);\n    div.setAttribute('hidden', 'true');\n    contents.ownerDocument.body.appendChild(div);\n    data.setData('text/html', div.innerHTML);\n    data.setData('text/plain', getPlainText(div));\n    contents.ownerDocument.body.removeChild(div);\n    return data;\n  };\n\n  e.insertData = data => {\n    if (!e.insertFragmentData(data)) {\n      e.insertTextData(data);\n    }\n  };\n\n  e.insertFragmentData = data => {\n    /**\r\n     * Checking copied fragment from application/x-slate-fragment or data-slate-fragment\r\n     */\n    var fragment = data.getData('application/x-slate-fragment') || getSlateFragmentAttribute(data);\n\n    if (fragment) {\n      var decoded = decodeURIComponent(window.atob(fragment));\n      var parsed = JSON.parse(decoded);\n      e.insertFragment(parsed);\n      return true;\n    }\n\n    return false;\n  };\n\n  e.insertTextData = data => {\n    var text = data.getData('text/plain');\n\n    if (text) {\n      var lines = text.split(/\\r\\n|\\r|\\n/);\n      var split = false;\n\n      for (var line of lines) {\n        if (split) {\n          Transforms.splitNodes(e, {\n            always: true\n          });\n        }\n\n        e.insertText(line);\n        split = true;\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n\n  e.onChange = () => {\n    // COMPAT: React doesn't batch `setState` hook calls, which means that the\n    // children and selection can get out of sync for one render pass. So we\n    // have to use this unstable API to ensure it batches them. (2019/12/03)\n    // https://github.com/facebook/react/issues/14259#issuecomment-439702367\n    react_dom.unstable_batchedUpdates(() => {\n      var onContextChange = EDITOR_TO_ON_CHANGE.get(e);\n\n      if (onContextChange) {\n        onContextChange();\n      }\n\n      onChange();\n    });\n  };\n\n  return e;\n};\n\nvar getMatches = (e, path) => {\n  var matches = [];\n\n  for (var [n, p] of Editor.levels(e, {\n    at: path\n  })) {\n    var key = ReactEditor.findKey(e, n);\n    matches.push([p, key]);\n  }\n\n  return matches;\n};\n\n\n//# sourceMappingURL=index.es.js.map\n\n// EXTERNAL MODULE: ../packages/core/src/api/createStore.ts + 4 modules\nvar createStore = __webpack_require__(1694);\n;// CONCATENATED MODULE: ../node_modules/immer/dist/immer.esm.mjs\nfunction immer_esm_n(n){for(var r=arguments.length,t=Array(r>1?r-1:0),e=1;e<r;e++)t[e-1]=arguments[e];if(false){ var i, o; }throw Error(\"[Immer] minified error nr: \"+n+(t.length?\" \"+t.map((function(n){return\"'\"+n+\"'\"})).join(\",\"):\"\")+\". Find the full error at: https://bit.ly/3cXEKWf\")}function immer_esm_r(n){return!!n&&!!n[immer_esm_Q]}function immer_esm_t(n){var r;return!!n&&(function(n){if(!n||\"object\"!=typeof n)return!1;var r=Object.getPrototypeOf(n);if(null===r)return!0;var t=Object.hasOwnProperty.call(r,\"constructor\")&&r.constructor;return t===Object||\"function\"==typeof t&&Function.toString.call(t)===immer_esm_Z}(n)||Array.isArray(n)||!!n[immer_esm_L]||!!(null===(r=n.constructor)||void 0===r?void 0:r[immer_esm_L])||immer_esm_s(n)||immer_esm_v(n))}function immer_esm_e(t){return immer_esm_r(t)||immer_esm_n(23,t),t[immer_esm_Q].t}function immer_esm_i(n,r,t){void 0===t&&(t=!1),0===immer_esm_o(n)?(t?Object.keys:immer_esm_nn)(n).forEach((function(e){t&&\"symbol\"==typeof e||r(e,n[e],n)})):n.forEach((function(t,e){return r(e,t,n)}))}function immer_esm_o(n){var r=n[immer_esm_Q];return r?r.i>3?r.i-4:r.i:Array.isArray(n)?1:immer_esm_s(n)?2:immer_esm_v(n)?3:0}function immer_esm_u(n,r){return 2===immer_esm_o(n)?n.has(r):Object.prototype.hasOwnProperty.call(n,r)}function immer_esm_a(n,r){return 2===immer_esm_o(n)?n.get(r):n[r]}function immer_esm_f(n,r,t){var e=immer_esm_o(n);2===e?n.set(r,t):3===e?n.add(t):n[r]=t}function immer_esm_c(n,r){return n===r?0!==n||1/n==1/r:n!=n&&r!=r}function immer_esm_s(n){return immer_esm_X&&n instanceof Map}function immer_esm_v(n){return immer_esm_q&&n instanceof Set}function immer_esm_p(n){return n.o||n.t}function immer_esm_l(n){if(Array.isArray(n))return Array.prototype.slice.call(n);var r=immer_esm_rn(n);delete r[immer_esm_Q];for(var t=immer_esm_nn(r),e=0;e<t.length;e++){var i=t[e],o=r[i];!1===o.writable&&(o.writable=!0,o.configurable=!0),(o.get||o.set)&&(r[i]={configurable:!0,writable:!0,enumerable:o.enumerable,value:n[i]})}return Object.create(Object.getPrototypeOf(n),r)}function immer_esm_d(n,e){return void 0===e&&(e=!1),immer_esm_y(n)||immer_esm_r(n)||!immer_esm_t(n)||(immer_esm_o(n)>1&&(n.set=n.add=n.clear=n.delete=immer_esm_h),Object.freeze(n),e&&immer_esm_i(n,(function(n,r){return immer_esm_d(r,!0)}),!0)),n}function immer_esm_h(){immer_esm_n(2)}function immer_esm_y(n){return null==n||\"object\"!=typeof n||Object.isFrozen(n)}function immer_esm_b(r){var t=immer_esm_tn[r];return t||immer_esm_n(18,r),t}function immer_esm_m(n,r){immer_esm_tn[n]||(immer_esm_tn[n]=r)}function immer_esm_(){return true||0,immer_esm_U}function immer_esm_j(n,r){r&&(immer_esm_b(\"Patches\"),n.u=[],n.s=[],n.v=r)}function immer_esm_O(n){immer_esm_g(n),n.p.forEach(immer_esm_S),n.p=null}function immer_esm_g(n){n===immer_esm_U&&(immer_esm_U=n.l)}function immer_esm_w(n){return immer_esm_U={p:[],l:immer_esm_U,h:n,m:!0,_:0}}function immer_esm_S(n){var r=n[immer_esm_Q];0===r.i||1===r.i?r.j():r.O=!0}function immer_esm_P(r,e){e._=e.p.length;var i=e.p[0],o=void 0!==r&&r!==i;return e.h.g||immer_esm_b(\"ES5\").S(e,r,o),o?(i[immer_esm_Q].P&&(immer_esm_O(e),immer_esm_n(4)),immer_esm_t(r)&&(r=immer_esm_M(e,r),e.l||immer_esm_x(e,r)),e.u&&immer_esm_b(\"Patches\").M(i[immer_esm_Q].t,r,e.u,e.s)):r=immer_esm_M(e,i,[]),immer_esm_O(e),e.u&&e.v(e.u,e.s),r!==immer_esm_H?r:void 0}function immer_esm_M(n,r,t){if(immer_esm_y(r))return r;var e=r[immer_esm_Q];if(!e)return immer_esm_i(r,(function(i,o){return immer_esm_A(n,e,r,i,o,t)}),!0),r;if(e.A!==n)return r;if(!e.P)return immer_esm_x(n,e.t,!0),e.t;if(!e.I){e.I=!0,e.A._--;var o=4===e.i||5===e.i?e.o=immer_esm_l(e.k):e.o,u=o,a=!1;3===e.i&&(u=new Set(o),o.clear(),a=!0),immer_esm_i(u,(function(r,i){return immer_esm_A(n,e,o,r,i,t,a)})),immer_esm_x(n,o,!1),t&&n.u&&immer_esm_b(\"Patches\").N(e,t,n.u,n.s)}return e.o}function immer_esm_A(e,i,o,a,c,s,v){if( false&&0,immer_esm_r(c)){var p=immer_esm_M(e,c,s&&i&&3!==i.i&&!immer_esm_u(i.R,a)?s.concat(a):void 0);if(immer_esm_f(o,a,p),!immer_esm_r(p))return;e.m=!1}else v&&o.add(c);if(immer_esm_t(c)&&!immer_esm_y(c)){if(!e.h.D&&e._<1)return;immer_esm_M(e,c),i&&i.A.l||immer_esm_x(e,c)}}function immer_esm_x(n,r,t){void 0===t&&(t=!1),!n.l&&n.h.D&&n.m&&immer_esm_d(r,t)}function immer_esm_z(n,r){var t=n[immer_esm_Q];return(t?immer_esm_p(t):n)[r]}function immer_esm_I(n,r){if(r in n)for(var t=Object.getPrototypeOf(n);t;){var e=Object.getOwnPropertyDescriptor(t,r);if(e)return e;t=Object.getPrototypeOf(t)}}function immer_esm_k(n){n.P||(n.P=!0,n.l&&immer_esm_k(n.l))}function immer_esm_E(n){n.o||(n.o=immer_esm_l(n.t))}function immer_esm_N(n,r,t){var e=immer_esm_s(r)?immer_esm_b(\"MapSet\").F(r,t):immer_esm_v(r)?immer_esm_b(\"MapSet\").T(r,t):n.g?function(n,r){var t=Array.isArray(n),e={i:t?1:0,A:r?r.A:immer_esm_(),P:!1,I:!1,R:{},l:r,t:n,k:null,o:null,j:null,C:!1},i=e,o=immer_esm_en;t&&(i=[e],o=immer_esm_on);var u=Proxy.revocable(i,o),a=u.revoke,f=u.proxy;return e.k=f,e.j=a,f}(r,t):immer_esm_b(\"ES5\").J(r,t);return(t?t.A:immer_esm_()).p.push(e),e}function immer_esm_R(e){return immer_esm_r(e)||immer_esm_n(22,e),function n(r){if(!immer_esm_t(r))return r;var e,u=r[immer_esm_Q],c=immer_esm_o(r);if(u){if(!u.P&&(u.i<4||!immer_esm_b(\"ES5\").K(u)))return u.t;u.I=!0,e=immer_esm_D(r,c),u.I=!1}else e=immer_esm_D(r,c);return immer_esm_i(e,(function(r,t){u&&immer_esm_a(u.t,r)===t||immer_esm_f(e,r,n(t))})),3===c?new Set(e):e}(e)}function immer_esm_D(n,r){switch(r){case 2:return new Map(n);case 3:return Array.from(n)}return immer_esm_l(n)}function immer_esm_F(){function t(n,r){var t=s[n];return t?t.enumerable=r:s[n]=t={configurable:!0,enumerable:r,get:function(){var r=this[immer_esm_Q];return false&&0,immer_esm_en.get(r,n)},set:function(r){var t=this[immer_esm_Q]; false&&0,immer_esm_en.set(t,n,r)}},t}function e(n){for(var r=n.length-1;r>=0;r--){var t=n[r][immer_esm_Q];if(!t.P)switch(t.i){case 5:a(t)&&immer_esm_k(t);break;case 4:o(t)&&immer_esm_k(t)}}}function o(n){for(var r=n.t,t=n.k,e=immer_esm_nn(t),i=e.length-1;i>=0;i--){var o=e[i];if(o!==immer_esm_Q){var a=r[o];if(void 0===a&&!immer_esm_u(r,o))return!0;var f=t[o],s=f&&f[immer_esm_Q];if(s?s.t!==a:!immer_esm_c(f,a))return!0}}var v=!!r[immer_esm_Q];return e.length!==immer_esm_nn(r).length+(v?0:1)}function a(n){var r=n.k;if(r.length!==n.t.length)return!0;var t=Object.getOwnPropertyDescriptor(r,r.length-1);if(t&&!t.get)return!0;for(var e=0;e<r.length;e++)if(!r.hasOwnProperty(e))return!0;return!1}function f(r){r.O&&immer_esm_n(3,JSON.stringify(immer_esm_p(r)))}var s={};immer_esm_m(\"ES5\",{J:function(n,r){var e=Array.isArray(n),i=function(n,r){if(n){for(var e=Array(r.length),i=0;i<r.length;i++)Object.defineProperty(e,\"\"+i,t(i,!0));return e}var o=immer_esm_rn(r);delete o[immer_esm_Q];for(var u=immer_esm_nn(o),a=0;a<u.length;a++){var f=u[a];o[f]=t(f,n||!!o[f].enumerable)}return Object.create(Object.getPrototypeOf(r),o)}(e,n),o={i:e?5:4,A:r?r.A:immer_esm_(),P:!1,I:!1,R:{},l:r,t:n,k:i,o:null,O:!1,C:!1};return Object.defineProperty(i,immer_esm_Q,{value:o,writable:!0}),i},S:function(n,t,o){o?immer_esm_r(t)&&t[immer_esm_Q].A===n&&e(n.p):(n.u&&function n(r){if(r&&\"object\"==typeof r){var t=r[immer_esm_Q];if(t){var e=t.t,o=t.k,f=t.R,c=t.i;if(4===c)immer_esm_i(o,(function(r){r!==immer_esm_Q&&(void 0!==e[r]||immer_esm_u(e,r)?f[r]||n(o[r]):(f[r]=!0,immer_esm_k(t)))})),immer_esm_i(e,(function(n){void 0!==o[n]||immer_esm_u(o,n)||(f[n]=!1,immer_esm_k(t))}));else if(5===c){if(a(t)&&(immer_esm_k(t),f.length=!0),o.length<e.length)for(var s=o.length;s<e.length;s++)f[s]=!1;else for(var v=e.length;v<o.length;v++)f[v]=!0;for(var p=Math.min(o.length,e.length),l=0;l<p;l++)o.hasOwnProperty(l)||(f[l]=!0),void 0===f[l]&&n(o[l])}}}}(n.p[0]),e(n.p))},K:function(n){return 4===n.i?o(n):a(n)}})}function immer_esm_T(){function e(n){if(!immer_esm_t(n))return n;if(Array.isArray(n))return n.map(e);if(immer_esm_s(n))return new Map(Array.from(n.entries()).map((function(n){return[n[0],e(n[1])]})));if(immer_esm_v(n))return new Set(Array.from(n).map(e));var r=Object.create(Object.getPrototypeOf(n));for(var i in n)r[i]=e(n[i]);return immer_esm_u(n,immer_esm_L)&&(r[immer_esm_L]=n[immer_esm_L]),r}function f(n){return immer_esm_r(n)?e(n):n}var c=\"add\";immer_esm_m(\"Patches\",{$:function(r,t){return t.forEach((function(t){for(var i=t.path,u=t.op,f=r,s=0;s<i.length-1;s++){var v=immer_esm_o(f),p=\"\"+i[s];0!==v&&1!==v||\"__proto__\"!==p&&\"constructor\"!==p||immer_esm_n(24),\"function\"==typeof f&&\"prototype\"===p&&immer_esm_n(24),\"object\"!=typeof(f=immer_esm_a(f,p))&&immer_esm_n(15,i.join(\"/\"))}var l=immer_esm_o(f),d=e(t.value),h=i[i.length-1];switch(u){case\"replace\":switch(l){case 2:return f.set(h,d);case 3:immer_esm_n(16);default:return f[h]=d}case c:switch(l){case 1:return\"-\"===h?f.push(d):f.splice(h,0,d);case 2:return f.set(h,d);case 3:return f.add(d);default:return f[h]=d}case\"remove\":switch(l){case 1:return f.splice(h,1);case 2:return f.delete(h);case 3:return f.delete(t.value);default:return delete f[h]}default:immer_esm_n(17,u)}})),r},N:function(n,r,t,e){switch(n.i){case 0:case 4:case 2:return function(n,r,t,e){var o=n.t,s=n.o;immer_esm_i(n.R,(function(n,i){var v=immer_esm_a(o,n),p=immer_esm_a(s,n),l=i?immer_esm_u(o,n)?\"replace\":c:\"remove\";if(v!==p||\"replace\"!==l){var d=r.concat(n);t.push(\"remove\"===l?{op:l,path:d}:{op:l,path:d,value:p}),e.push(l===c?{op:\"remove\",path:d}:\"remove\"===l?{op:c,path:d,value:f(v)}:{op:\"replace\",path:d,value:f(v)})}}))}(n,r,t,e);case 5:case 1:return function(n,r,t,e){var i=n.t,o=n.R,u=n.o;if(u.length<i.length){var a=[u,i];i=a[0],u=a[1];var s=[e,t];t=s[0],e=s[1]}for(var v=0;v<i.length;v++)if(o[v]&&u[v]!==i[v]){var p=r.concat([v]);t.push({op:\"replace\",path:p,value:f(u[v])}),e.push({op:\"replace\",path:p,value:f(i[v])})}for(var l=i.length;l<u.length;l++){var d=r.concat([l]);t.push({op:c,path:d,value:f(u[l])})}i.length<u.length&&e.push({op:\"replace\",path:r.concat([\"length\"]),value:i.length})}(n,r,t,e);case 3:return function(n,r,t,e){var i=n.t,o=n.o,u=0;i.forEach((function(n){if(!o.has(n)){var i=r.concat([u]);t.push({op:\"remove\",path:i,value:n}),e.unshift({op:c,path:i,value:n})}u++})),u=0,o.forEach((function(n){if(!i.has(n)){var o=r.concat([u]);t.push({op:c,path:o,value:n}),e.unshift({op:\"remove\",path:o,value:n})}u++}))}(n,r,t,e)}},M:function(n,r,t,e){t.push({op:\"replace\",path:[],value:r===immer_esm_H?void 0:r}),e.push({op:\"replace\",path:[],value:n})}})}function immer_esm_C(){function r(n,r){function t(){this.constructor=n}a(n,r),n.prototype=(t.prototype=r.prototype,new t)}function e(n){n.o||(n.R=new Map,n.o=new Map(n.t))}function o(n){n.o||(n.o=new Set,n.t.forEach((function(r){if(immer_esm_t(r)){var e=immer_esm_N(n.A.h,r,n);n.p.set(r,e),n.o.add(e)}else n.o.add(r)})))}function u(r){r.O&&immer_esm_n(3,JSON.stringify(immer_esm_p(r)))}var a=function(n,r){return(a=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,r){n.__proto__=r}||function(n,r){for(var t in r)r.hasOwnProperty(t)&&(n[t]=r[t])})(n,r)},f=function(){function n(n,r){return this[immer_esm_Q]={i:2,l:r,A:r?r.A:immer_esm_(),P:!1,I:!1,o:void 0,R:void 0,t:n,k:this,C:!1,O:!1},this}r(n,Map);var o=n.prototype;return Object.defineProperty(o,\"size\",{get:function(){return immer_esm_p(this[immer_esm_Q]).size}}),o.has=function(n){return immer_esm_p(this[immer_esm_Q]).has(n)},o.set=function(n,r){var t=this[immer_esm_Q];return u(t),immer_esm_p(t).has(n)&&immer_esm_p(t).get(n)===r||(e(t),immer_esm_k(t),t.R.set(n,!0),t.o.set(n,r),t.R.set(n,!0)),this},o.delete=function(n){if(!this.has(n))return!1;var r=this[immer_esm_Q];return u(r),e(r),immer_esm_k(r),r.t.has(n)?r.R.set(n,!1):r.R.delete(n),r.o.delete(n),!0},o.clear=function(){var n=this[immer_esm_Q];u(n),immer_esm_p(n).size&&(e(n),immer_esm_k(n),n.R=new Map,immer_esm_i(n.t,(function(r){n.R.set(r,!1)})),n.o.clear())},o.forEach=function(n,r){var t=this;immer_esm_p(this[immer_esm_Q]).forEach((function(e,i){n.call(r,t.get(i),i,t)}))},o.get=function(n){var r=this[immer_esm_Q];u(r);var i=immer_esm_p(r).get(n);if(r.I||!immer_esm_t(i))return i;if(i!==r.t.get(n))return i;var o=immer_esm_N(r.A.h,i,r);return e(r),r.o.set(n,o),o},o.keys=function(){return immer_esm_p(this[immer_esm_Q]).keys()},o.values=function(){var n,r=this,t=this.keys();return(n={})[immer_esm_V]=function(){return r.values()},n.next=function(){var n=t.next();return n.done?n:{done:!1,value:r.get(n.value)}},n},o.entries=function(){var n,r=this,t=this.keys();return(n={})[immer_esm_V]=function(){return r.entries()},n.next=function(){var n=t.next();if(n.done)return n;var e=r.get(n.value);return{done:!1,value:[n.value,e]}},n},o[immer_esm_V]=function(){return this.entries()},n}(),c=function(){function n(n,r){return this[immer_esm_Q]={i:3,l:r,A:r?r.A:immer_esm_(),P:!1,I:!1,o:void 0,t:n,k:this,p:new Map,O:!1,C:!1},this}r(n,Set);var t=n.prototype;return Object.defineProperty(t,\"size\",{get:function(){return immer_esm_p(this[immer_esm_Q]).size}}),t.has=function(n){var r=this[immer_esm_Q];return u(r),r.o?!!r.o.has(n)||!(!r.p.has(n)||!r.o.has(r.p.get(n))):r.t.has(n)},t.add=function(n){var r=this[immer_esm_Q];return u(r),this.has(n)||(o(r),immer_esm_k(r),r.o.add(n)),this},t.delete=function(n){if(!this.has(n))return!1;var r=this[immer_esm_Q];return u(r),o(r),immer_esm_k(r),r.o.delete(n)||!!r.p.has(n)&&r.o.delete(r.p.get(n))},t.clear=function(){var n=this[immer_esm_Q];u(n),immer_esm_p(n).size&&(o(n),immer_esm_k(n),n.o.clear())},t.values=function(){var n=this[immer_esm_Q];return u(n),o(n),n.o.values()},t.entries=function(){var n=this[immer_esm_Q];return u(n),o(n),n.o.entries()},t.keys=function(){return this.values()},t[immer_esm_V]=function(){return this.values()},t.forEach=function(n,r){for(var t=this.values(),e=t.next();!e.done;)n.call(r,e.value,e.value,this),e=t.next()},n}();immer_esm_m(\"MapSet\",{F:function(n,r){return new f(n,r)},T:function(n,r){return new c(n,r)}})}function immer_esm_J(){immer_esm_F(),immer_esm_C(),immer_esm_T()}function immer_esm_K(n){return n}function immer_esm_$(n){return n}var immer_esm_G,immer_esm_U,immer_esm_W=\"undefined\"!=typeof Symbol&&\"symbol\"==typeof Symbol(\"x\"),immer_esm_X=\"undefined\"!=typeof Map,immer_esm_q=\"undefined\"!=typeof Set,immer_esm_B=\"undefined\"!=typeof Proxy&&void 0!==Proxy.revocable&&\"undefined\"!=typeof Reflect,immer_esm_H=immer_esm_W?Symbol.for(\"immer-nothing\"):((immer_esm_G={})[\"immer-nothing\"]=!0,immer_esm_G),immer_esm_L=immer_esm_W?Symbol.for(\"immer-draftable\"):\"__$immer_draftable\",immer_esm_Q=immer_esm_W?Symbol.for(\"immer-state\"):\"__$immer_state\",immer_esm_V=\"undefined\"!=typeof Symbol&&Symbol.iterator||\"@@iterator\",immer_esm_Y={0:\"Illegal state\",1:\"Immer drafts cannot have computed properties\",2:\"This object has been frozen and should not be mutated\",3:function(n){return\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \"+n},4:\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",5:\"Immer forbids circular references\",6:\"The first or second argument to `produce` must be a function\",7:\"The third argument to `produce` must be a function or undefined\",8:\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",9:\"First argument to `finishDraft` must be a draft returned by `createDraft`\",10:\"The given draft is already finalized\",11:\"Object.defineProperty() cannot be used on an Immer draft\",12:\"Object.setPrototypeOf() cannot be used on an Immer draft\",13:\"Immer only supports deleting array indices\",14:\"Immer only supports setting array indices and the 'length' property\",15:function(n){return\"Cannot apply patch, path doesn't resolve: \"+n},16:'Sets cannot have \"replace\" patches.',17:function(n){return\"Unsupported patch operation: \"+n},18:function(n){return\"The plugin for '\"+n+\"' has not been loaded into Immer. To enable the plugin, import and call `enable\"+n+\"()` when initializing your application.\"},20:\"Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available\",21:function(n){return\"produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '\"+n+\"'\"},22:function(n){return\"'current' expects a draft, got: \"+n},23:function(n){return\"'original' expects a draft, got: \"+n},24:\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"},immer_esm_Z=\"\"+Object.prototype.constructor,immer_esm_nn=\"undefined\"!=typeof Reflect&&Reflect.ownKeys?Reflect.ownKeys:void 0!==Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:Object.getOwnPropertyNames,immer_esm_rn=Object.getOwnPropertyDescriptors||function(n){var r={};return immer_esm_nn(n).forEach((function(t){r[t]=Object.getOwnPropertyDescriptor(n,t)})),r},immer_esm_tn={},immer_esm_en={get:function(n,r){if(r===immer_esm_Q)return n;var e=immer_esm_p(n);if(!immer_esm_u(e,r))return function(n,r,t){var e,i=immer_esm_I(r,t);return i?\"value\"in i?i.value:null===(e=i.get)||void 0===e?void 0:e.call(n.k):void 0}(n,e,r);var i=e[r];return n.I||!immer_esm_t(i)?i:i===immer_esm_z(n.t,r)?(immer_esm_E(n),n.o[r]=immer_esm_N(n.A.h,i,n)):i},has:function(n,r){return r in immer_esm_p(n)},ownKeys:function(n){return Reflect.ownKeys(immer_esm_p(n))},set:function(n,r,t){var e=immer_esm_I(immer_esm_p(n),r);if(null==e?void 0:e.set)return e.set.call(n.k,t),!0;if(!n.P){var i=immer_esm_z(immer_esm_p(n),r),o=null==i?void 0:i[immer_esm_Q];if(o&&o.t===t)return n.o[r]=t,n.R[r]=!1,!0;if(immer_esm_c(t,i)&&(void 0!==t||immer_esm_u(n.t,r)))return!0;immer_esm_E(n),immer_esm_k(n)}return n.o[r]===t&&(void 0!==t||r in n.o)||Number.isNaN(t)&&Number.isNaN(n.o[r])||(n.o[r]=t,n.R[r]=!0),!0},deleteProperty:function(n,r){return void 0!==immer_esm_z(n.t,r)||r in n.t?(n.R[r]=!1,immer_esm_E(n),immer_esm_k(n)):delete n.R[r],n.o&&delete n.o[r],!0},getOwnPropertyDescriptor:function(n,r){var t=immer_esm_p(n),e=Reflect.getOwnPropertyDescriptor(t,r);return e?{writable:!0,configurable:1!==n.i||\"length\"!==r,enumerable:e.enumerable,value:t[r]}:e},defineProperty:function(){immer_esm_n(11)},getPrototypeOf:function(n){return Object.getPrototypeOf(n.t)},setPrototypeOf:function(){immer_esm_n(12)}},immer_esm_on={};immer_esm_i(immer_esm_en,(function(n,r){immer_esm_on[n]=function(){return arguments[0]=arguments[0][0],r.apply(this,arguments)}})),immer_esm_on.deleteProperty=function(r,t){return false&&0,immer_esm_on.set.call(this,r,t,void 0)},immer_esm_on.set=function(r,t,e){return false&&0,immer_esm_en.set.call(this,r[0],t,e,r[0])};var immer_esm_un=function(){function e(r){var e=this;this.g=immer_esm_B,this.D=!0,this.produce=function(r,i,o){if(\"function\"==typeof r&&\"function\"!=typeof i){var u=i;i=r;var a=e;return function(n){var r=this;void 0===n&&(n=u);for(var t=arguments.length,e=Array(t>1?t-1:0),o=1;o<t;o++)e[o-1]=arguments[o];return a.produce(n,(function(n){var t;return(t=i).call.apply(t,[r,n].concat(e))}))}}var f;if(\"function\"!=typeof i&&immer_esm_n(6),void 0!==o&&\"function\"!=typeof o&&immer_esm_n(7),immer_esm_t(r)){var c=immer_esm_w(e),s=immer_esm_N(e,r,void 0),v=!0;try{f=i(s),v=!1}finally{v?immer_esm_O(c):immer_esm_g(c)}return\"undefined\"!=typeof Promise&&f instanceof Promise?f.then((function(n){return immer_esm_j(c,o),immer_esm_P(n,c)}),(function(n){throw immer_esm_O(c),n})):(immer_esm_j(c,o),immer_esm_P(f,c))}if(!r||\"object\"!=typeof r){if(void 0===(f=i(r))&&(f=r),f===immer_esm_H&&(f=void 0),e.D&&immer_esm_d(f,!0),o){var p=[],l=[];immer_esm_b(\"Patches\").M(r,f,p,l),o(p,l)}return f}immer_esm_n(21,r)},this.produceWithPatches=function(n,r){if(\"function\"==typeof n)return function(r){for(var t=arguments.length,i=Array(t>1?t-1:0),o=1;o<t;o++)i[o-1]=arguments[o];return e.produceWithPatches(r,(function(r){return n.apply(void 0,[r].concat(i))}))};var t,i,o=e.produce(n,r,(function(n,r){t=n,i=r}));return\"undefined\"!=typeof Promise&&o instanceof Promise?o.then((function(n){return[n,t,i]})):[o,t,i]},\"boolean\"==typeof(null==r?void 0:r.useProxies)&&this.setUseProxies(r.useProxies),\"boolean\"==typeof(null==r?void 0:r.autoFreeze)&&this.setAutoFreeze(r.autoFreeze)}var i=e.prototype;return i.createDraft=function(e){immer_esm_t(e)||immer_esm_n(8),immer_esm_r(e)&&(e=immer_esm_R(e));var i=immer_esm_w(this),o=immer_esm_N(this,e,void 0);return o[immer_esm_Q].C=!0,immer_esm_g(i),o},i.finishDraft=function(r,t){var e=r&&r[immer_esm_Q]; false&&(0);var i=e.A;return immer_esm_j(i,t),immer_esm_P(void 0,i)},i.setAutoFreeze=function(n){this.D=n},i.setUseProxies=function(r){r&&!immer_esm_B&&immer_esm_n(20),this.g=r},i.applyPatches=function(n,t){var e;for(e=t.length-1;e>=0;e--){var i=t[e];if(0===i.path.length&&\"replace\"===i.op){n=i.value;break}}e>-1&&(t=t.slice(e+1));var o=immer_esm_b(\"Patches\").$;return immer_esm_r(n)?o(n,t):this.produce(n,(function(n){return o(n,t)}))},e}(),immer_esm_an=new immer_esm_un,immer_esm_fn=immer_esm_an.produce,immer_esm_cn=immer_esm_an.produceWithPatches.bind(immer_esm_an),immer_esm_sn=immer_esm_an.setAutoFreeze.bind(immer_esm_an),immer_esm_vn=immer_esm_an.setUseProxies.bind(immer_esm_an),immer_esm_pn=immer_esm_an.applyPatches.bind(immer_esm_an),immer_esm_ln=immer_esm_an.createDraft.bind(immer_esm_an),immer_esm_dn=immer_esm_an.finishDraft.bind(immer_esm_an);/* harmony default export */ var dist_immer_esm = (immer_esm_fn);\n//# sourceMappingURL=immer.esm.js.map\n\n;// CONCATENATED MODULE: ../packages/immer/src/ImmerStore.ts\nvar ImmerStore=/*#__PURE__*/function(_Store){(0,inheritsLoose/* default */.Z)(ImmerStore,_Store);function ImmerStore(initialState){return _Store.call(this,null,initialState)||this;}var _proto=ImmerStore.prototype;_proto.produce=function produce(recipe){this.setState(dist_immer_esm(this.getState(),function(draft){recipe(draft);// don't return the result - user should use store.setState() to override state\n}));};return ImmerStore;}(createStore/* Store */.y);\n;// CONCATENATED MODULE: ../packages/immer/src/createImmerStore.ts\nvar createImmerStore=function createImmerStore(initialState){return new ImmerStore(initialState);};\n// EXTERNAL MODULE: ../packages/core/src/api/constants.ts\nvar constants = __webpack_require__(3064);\n// EXTERNAL MODULE: ../packages/react/src/factories/createInjector.ts\nvar createInjector = __webpack_require__(3870);\n;// CONCATENATED MODULE: ../packages/immer/src/injectImmerStore.ts\nvar operation='injectImmerStore';var doSubscribe=function doSubscribe(instance,store){return store.subscribe({effects:function effects(_ref){var action=_ref.action,newState=_ref.newState,oldState=_ref.oldState;// Nothing to do if the state hasn't changed. Also, ignore state updates\n// during evaluation. TODO: Create an ecosystem-level flag to turn on\n// warning logging for state-updates-during-evaluation, since this may be\n// considered an anti-pattern.\nif(newState===oldState||instance.ecosystem._evaluationStack.isEvaluating(instance.keyHash)||(action==null?void 0:action.meta)===constants/* internalTypes.ignore */.P.ignore){return;}instance._scheduleEvaluation({newState:newState,oldState:oldState,operation:operation,reasons:[{action:action,newState:newState,oldState:oldState,operation:'dispatch',sourceType:'Store',type:'state changed'}],sourceType:'Injector',type:'state changed'},false);// run the scheduler synchronously after any store update\ninstance.ecosystem._scheduler.flush();}});};var injectImmerStore=(0,createInjector/* createInjector */.v)(operation,function(instance,state,config){var _config$subscribe;var subscribe=(_config$subscribe=config==null?void 0:config.subscribe)!=null?_config$subscribe:true;var hydration=instance.ecosystem._consumeHydration(instance);var store=createImmerStore(hydration!=null?hydration:state);var subscription=subscribe&&doSubscribe(instance,store);return{cleanup:subscription?function(){return subscription.unsubscribe();}:undefined,result:store,type:'@@zedux/immerStore'};},function(prevDescriptor,instance,state,config){var _config$subscribe2;var subscribe=(_config$subscribe2=config==null?void 0:config.subscribe)!=null?_config$subscribe2:true;var prevsubscribe=!!prevDescriptor.cleanup;if(prevsubscribe===subscribe)return prevDescriptor;// we were subscribed, now we're not\nif(!subscribe){prevDescriptor.cleanup==null?void 0:prevDescriptor.cleanup();prevDescriptor.cleanup=undefined;return prevDescriptor;}// we weren't subscribed, now we are\nvar subscription=doSubscribe(instance,prevDescriptor.result);prevDescriptor.cleanup=function(){return subscription.unsubscribe();};return prevDescriptor;});\n;// CONCATENATED MODULE: ../packages/immer/src/index.ts\n\n// EXTERNAL MODULE: ../packages/core/src/api/actionFactory.ts\nvar actionFactory = __webpack_require__(2808);\n;// CONCATENATED MODULE: ../packages/core/src/utils/actions.ts\n/**\n  Pulls the string action type out of an ActionFactory or returns\n  a given string action type as-is.\n*/var extractActionType=function extractActionType(reactable,method){// The reactable may be a literal action type string\nif(typeof reactable==='string')return reactable;if( true&&(typeof reactable!=='function'||typeof reactable.type!=='string')){var type=typeof reactable==='function'?\"function with invalid \\\"type\\\" property - \"+typeof reactable.type:typeof reactable;throw new TypeError(\"Zedux: \"+method+\" - reactable must be either a string or a function with a \\\"type\\\" property. Received \"+type);}return reactable.type;};/**\n  Pulls the string action types out of a list of (possibly) mixed\n  reactables and string action types.\n*/var extractActionTypes=function extractActionTypes(reactables,method){return reactables.map(function(reactable){return extractActionType(reactable,method);});};\n;// CONCATENATED MODULE: ../packages/core/src/api/createReducer.ts\n/**\n  Creates a new ReducerBuilder.\n\n  A ReducerBuilder is just a reducer with a special `.reducer()` method for\n  easily mapping action types to sub-reducers that handle them.\n*/var createReducer=function createReducer(initialState){var actionToReducersMap={};var reducer=function reducer(state,action){if(state===void 0){state=initialState;}var reducers=actionToReducersMap[action.type]||[];return runReducers(reducers,state,action);};reducer.reduce=function(reactable,subReducer){var method='ReducerBuilder.reduce()';var actionTypes=Array.isArray(reactable)?extractActionTypes(reactable,method):[extractActionType(reactable,method)];mapActionTypesToReducer(actionToReducersMap,actionTypes,subReducer);return reducer;};return reducer;};function mapActionTypesToReducer(map,actionTypes,consumer){actionTypes.forEach(function(actionType){if(!map[actionType]){map[actionType]=[];}map[actionType].push(consumer);});}function runReducers(reducers,state,action){return reducers.reduce(function(accumulatedState,reducer){return reducer(accumulatedState,action.payload,action);},state);}\n;// CONCATENATED MODULE: ../packages/core/src/api/MachineStore.ts\n/**\n * An extremely low-level Store class that represents a state machine. Don't\n * create this class yourself, use a helper such as @zedux/react's\n * `injectMachineStore()`\n */var MachineStore=/*#__PURE__*/function(_Store){(0,inheritsLoose/* default */.Z)(MachineStore,_Store);function MachineStore(initialState,states,initialContext,guard){var _this;_this=_Store.call(this,null,{context:initialContext,value:initialState})||this;_this.getContext=function(){return _this.getState().context;};_this.getValue=function(){return _this.getState().value;};_this.is=function(stateName){return _this.getState().value===stateName;};_this.send=function(eventName,meta){return _this.setState(function(currentState){var nextValue=_this.states[currentState.value][eventName];if(!nextValue||nextValue!=null&&nextValue.guard&&!nextValue.guard(currentState.context)||_this.guard&&!_this.guard(currentState,nextValue.name)){return currentState;}return{context:currentState.context,value:nextValue.name};},meta);};_this.setContext=function(context,meta){return _this.setState(function(state){return{context:typeof context==='function'?context(state.context):context,value:state.value};},meta);};_this.setContextDeep=function(partialContext,meta){return _this.setStateDeep(function(state){return{context:typeof partialContext==='function'?partialContext(state.context):partialContext};},meta);};_this.states=states;_this.guard=guard;return _this;}return MachineStore;}(createStore/* Store */.y);\n// EXTERNAL MODULE: ../packages/core/src/api/meta.ts\nvar meta = __webpack_require__(7159);\n// EXTERNAL MODULE: ../packages/core/src/api/is.ts\nvar is = __webpack_require__(9283);\n;// CONCATENATED MODULE: ../packages/core/src/index.ts\n\n;// CONCATENATED MODULE: ../packages/react/src/factories/ion.ts\nvar ion=function ion(key,get,config){return new Ion(key,get,config);};\n// EXTERNAL MODULE: ../packages/react/src/classes/EvaluationStack.ts\nvar EvaluationStack = __webpack_require__(2633);\n;// CONCATENATED MODULE: ../packages/react/src/injectors/injectAtomGetters.ts\n/**\n * injectAtomGetters\n *\n * An injector that returns an AtomGetters object. The returned AtomGetters\n * dynamically register dependencies for the current atom instance when called\n * synchronously during atom evaluation.\n *\n * ```ts\n * const exampleAtom = atom('example', () => {\n *   const {\xa0ecosystem, get, getInstance } = injectAtomGetters()\n *   const dynamicVal = get(myAtom) // registers a dynamic graph edge\n *   const instance = getInstance(myAtom) // registers a static graph edge\n *   const fromEcosystem = ecosystem.get(myAtom) // doesn't register anything\n *\n *   injectEffect(() => {\n *     const dynamicVal2 = get(myAtom) // doesn't register anything\n *     const instance2 = getInstance(myAtom) // doesn't register anything\n *     const fromEcosystem2 = ecosystem.get(myAtom) // doesn't register anything\n *   }, []) // no need to pass AtomGetters as deps; they're stable references\n * })\n * ```\n *\n * @see AtomGetters\n */var injectAtomGetters=function injectAtomGetters(){var instance=(0,EvaluationStack/* readInstance */.i)();return instance.ecosystem._evaluationStack.atomGetters;};\n// EXTERNAL MODULE: ../packages/react/src/classes/instances/AtomInstance.ts + 4 modules\nvar AtomInstance = __webpack_require__(4985);\n// EXTERNAL MODULE: ../packages/react/src/classes/atoms/AtomBase.ts\nvar AtomBase = __webpack_require__(3789);\n;// CONCATENATED MODULE: ../packages/react/src/classes/atoms/Ion.ts\nvar Ion=/*#__PURE__*/function(_AtomBase){(0,inheritsLoose/* default */.Z)(Ion,_AtomBase);function Ion(key,stateFactory,_config){var _this;_this=_AtomBase.call(this,key,function(){for(var _len=arguments.length,params=new Array(_len),_key=0;_key<_len;_key++){params[_key]=arguments[_key];}return stateFactory.apply(void 0,[injectAtomGetters()].concat(params));},_config)||this;_this._get=stateFactory;return _this;}var _proto=Ion.prototype;_proto._createInstance=function _createInstance(ecosystem,keyHash,params){return new AtomInstance/* AtomInstance */.p(ecosystem,this,keyHash,params);};_proto.getKeyHash=function getKeyHash(ecosystem,params){var base=this.key;if(!(params!=null&&params.length))return base;return base+\"-\"+ecosystem._idGenerator.hashParams(params,ecosystem.complexParams);};_proto.override=function override(newGet){return ion(this.key,newGet||this._get,this._config);};return Ion;}(AtomBase/* AtomBase */.H);\n// EXTERNAL MODULE: ../packages/react/src/classes/atoms/Atom.ts\nvar Atom = __webpack_require__(1968);\n// EXTERNAL MODULE: ../packages/react/src/classes/instances/AtomInstanceBase.ts\nvar AtomInstanceBase = __webpack_require__(4987);\n// EXTERNAL MODULE: ../packages/react/src/classes/AtomApi.ts\nvar AtomApi = __webpack_require__(2448);\n// EXTERNAL MODULE: ../packages/react/src/classes/Ecosystem.ts + 4 modules\nvar Ecosystem = __webpack_require__(5092);\n// EXTERNAL MODULE: ../packages/react/src/utils/plugin-actions.ts\nvar plugin_actions = __webpack_require__(3299);\n;// CONCATENATED MODULE: ../packages/react/src/classes/ZeduxPlugin.ts\nvar ZeduxPlugin=/**\n   * These actions should only be dispatched to an ecosystem's modBus\n   * store, so they don't need prefixes\n   */function ZeduxPlugin(_temp){var _ref=_temp===void 0?{}:_temp,_ref$initialMods=_ref.initialMods,initialMods=_ref$initialMods===void 0?[]:_ref$initialMods,registerEcosystem=_ref.registerEcosystem;this.modStore=(0,createStore/* createStore */.M)(null,initialMods);this.registerEcosystem=registerEcosystem||function(){};};ZeduxPlugin.actions=plugin_actions/* pluginActions */.V;\n;// CONCATENATED MODULE: ../packages/react/src/classes/index.ts\n// this .. has to be imported before Atom or the build breaks :exploding_head:\n\n// EXTERNAL MODULE: ../packages/react/src/hooks/useEcosystem.ts\nvar useEcosystem = __webpack_require__(6215);\n;// CONCATENATED MODULE: ../packages/react/src/components/AtomInstanceProvider.tsx\nvar AtomInstanceProvider=function AtomInstanceProvider(_ref){var children=_ref.children,instance=_ref.instance,instances=_ref.instances;var ecosystem=(0,useEcosystem/* useEcosystem */.l)();if( true&&!instance&&!instances){throw new Error('Zedux: AtomInstanceProvider requires either an `instance` or `instances` prop');}var allInstances=instances||[instance];if(allInstances.length===1){var _context=ecosystem._getReactContext(allInstances[0].atom);return/*#__PURE__*/react.createElement(_context.Provider,{value:allInstances[0]},children);}var parentInstance=allInstances[0],childInstances=allInstances.slice(1);var context=ecosystem._getReactContext(parentInstance.atom);return/*#__PURE__*/react.createElement(context.Provider,{value:parentInstance},/*#__PURE__*/react.createElement(AtomInstanceProvider,{instances:childInstances},children));};\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nvar objectWithoutPropertiesLoose = __webpack_require__(3366);\n// EXTERNAL MODULE: ../packages/react/src/factories/createEcosystem.ts\nvar createEcosystem = __webpack_require__(2662);\n// EXTERNAL MODULE: ../packages/react/src/utils/general.ts\nvar general = __webpack_require__(395);\n;// CONCATENATED MODULE: ../packages/react/src/components/EcosystemProvider.tsx\nvar EcosystemProvider_excluded=[\"children\",\"ecosystem\"];/**\n * EcosystemProvider\n *\n * Creates an atom ecosystem. The behavior of atoms inside this EcosystemProvider can\n * be configured with props passed here.\n */var EcosystemProvider=function EcosystemProvider(_ref){var children=_ref.children,passedEcosystem=_ref.ecosystem,ecosystemConfig=(0,objectWithoutPropertiesLoose/* default */.Z)(_ref,EcosystemProvider_excluded);var _useMemo=(0,react.useMemo)(function(){var resolvedEcosystem=passedEcosystem||(0,createEcosystem/* createEcosystem */.q)(Object.assign({destroyOnUnmount:true},ecosystemConfig));return[function(){resolvedEcosystem._incrementRefCount();return function(){return resolvedEcosystem._decrementRefCount();};},function(){return resolvedEcosystem;}];},[ecosystemConfig.id,passedEcosystem]),subscribe=_useMemo[0],getSnapshot=_useMemo[1];// don't pass other vals; just get snapshot when these change\nvar ecosystem=(0,react.useSyncExternalStore)(subscribe,getSnapshot,getSnapshot);return/*#__PURE__*/react.createElement(general/* ecosystemContext.Provider */.zs.Provider,{value:ecosystem.id},children);};\n;// CONCATENATED MODULE: ../packages/react/src/components/index.ts\n\n// EXTERNAL MODULE: ../packages/react/src/factories/api.ts\nvar api = __webpack_require__(552);\n// EXTERNAL MODULE: ../packages/react/src/factories/atom.ts\nvar atom = __webpack_require__(5965);\n;// CONCATENATED MODULE: ../packages/react/src/factories/index.ts\n\n;// CONCATENATED MODULE: ../packages/react/src/hooks/useAtomConsumer.ts\nvar useAtomConsumer=function useAtomConsumer(atom,defaultParams){var ecosystem=(0,useEcosystem/* useEcosystem */.l)();var instance=(0,react.useContext)(ecosystem._getReactContext(atom));if(!defaultParams||(0,is.is)(instance,AtomInstanceBase/* AtomInstanceBase */.T)){if( true&&instance.activeState==='Destroyed'){throw new Error(\"Zedux: useAtomConsumer - A destroyed atom instance was provided with key \\\"\"+instance.keyHash+\"\\\". This is not supported. Provide an active atom instance instead.\");}return instance;}if(typeof defaultParams==='boolean'){if(true){throw new ReferenceError(\"Zedux: useAtomConsumer - No atom instance was provided for atom \\\"\"+atom.key+\"\\\".\");}else{}}return ecosystem.getInstance(atom,defaultParams);};\n// EXTERNAL MODULE: ../packages/react/src/hooks/useAtomInstance.ts\nvar useAtomInstance = __webpack_require__(4538);\n// EXTERNAL MODULE: ../packages/react/src/hooks/useReactComponentId.ts\nvar useReactComponentId = __webpack_require__(6559);\n;// CONCATENATED MODULE: ../packages/react/src/hooks/useAtomSelector.ts\nvar glob=typeof globalThis!=='undefined'&&globalThis||{};var INVALIDATE_REACT=\"INVALIDATE_REACT_\"+Math.random();var OPERATION='useAtomSelector';/**\n * If we detect an inline selector using these not-exactly-cheap checks, we can\n * prevent the graph from changing by swapping out its reference and\n * invalidating the cache. It's unfortunately probably not a good trade-off\n * performance-wise, but it's necessary to prevent React's render-loop-of-death\n * in `useSyncExternalStore` when both the subscribe reference and the selector\n * result change every render. Simple reproduction:\n *\n * ```tsx\n * // subscribe ref and getSnapshot result ref change every render = death\n * useSyncExternalStore(() => () => {}, () => ({}))\n * ```\n *\n * It's also better dev-X when the graph doesn't change unnecessarily.\n *\n * Inline selectors that haven't _actually_ changed must be exactly the same,\n * stringified. The stringified `resultsComparator` must also be exactly the\n * same. `argsComparator` doesn't matter since it only runs at the hook level.\n *\n * Importantly, an inline selector's graph node must have exactly one dependent\n * too - the React component that called `useAtomSelector(inlineSelector)`.\n */var isRefDifferent=function isRefDifferent(ecosystem,newSelector,cacheRef){var _ecosystem$_graph$nod;if(!cacheRef.current)return true;var oldSelector=cacheRef.current.selectorRef;if(newSelector===oldSelector)return false;var dependents=(_ecosystem$_graph$nod=ecosystem._graph.nodes[cacheRef.current.cacheKey])==null?void 0:_ecosystem$_graph$nod.dependents;if(dependents&&Object.keys(dependents).length!==1)return true;var newIsFunction=typeof newSelector==='function';var oldIsFunction=typeof oldSelector==='function';if(newIsFunction!==oldIsFunction)return true;var newKey=ecosystem.selectorCache._getIdealCacheKey(newSelector);var oldKey=ecosystem.selectorCache._getIdealCacheKey(oldSelector);if(newKey!==oldKey)return true;if(!newIsFunction&&!oldIsFunction&&newSelector.resultsComparator!==oldSelector.resultsComparator){var _newSelector$resultsC,_oldSelector$resultsC;var newResultsComparatorStr=((_newSelector$resultsC=newSelector.resultsComparator)==null?void 0:_newSelector$resultsC.toString())||'';var oldResultsComparatorStr=((_oldSelector$resultsC=oldSelector.resultsComparator)==null?void 0:_oldSelector$resultsC.toString())||'';if(newResultsComparatorStr!==oldResultsComparatorStr)return true;}// last thing to compare is the selectors themselves\nif(newIsFunction&&oldIsFunction){return newSelector.toString()!==oldSelector.toString();}// we know they're both objects at this point\nif(newSelector.selector===oldSelector.selector){return false;}var newRefStr=newSelector.selector.toString();var oldRefStr=oldSelector.selector.toString();return newRefStr!==oldRefStr;};/**\n * Get the result of running an AtomSelector in the current ecosystem.\n *\n * If the exact selector function (or object if it's an AtomSelectorConfig\n * object) reference + params combo has been used in this ecosystem before,\n * return the cached result.\n *\n * Register a dynamic graph dependency between this React component (as a new\n * external node) and the AtomSelector.\n */var useAtomSelector=function useAtomSelector(selectorOrConfig){var _cacheRef$current,_cacheRef$current2,_cacheRef$current3,_cacheRef$current4;var ecosystem=(0,useEcosystem/* useEcosystem */.l)();var dependentKey=(0,useReactComponentId/* useReactComponentId */.$)();var cacheRef=(0,react.useRef)();var skipState=(0,react.useRef)();var isConfig=typeof selectorOrConfig!=='function';for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}var argsChanged=isConfig&&selectorOrConfig.argsComparator&&(_cacheRef$current=cacheRef.current)!=null&&_cacheRef$current.args?selectorOrConfig.argsComparator(args,cacheRef.current.args):(0,general/* haveDepsChanged */.EM)((_cacheRef$current2=cacheRef.current)==null?void 0:_cacheRef$current2.args,args);var resolvedArgs=argsChanged?args:((_cacheRef$current3=cacheRef.current)==null?void 0:_cacheRef$current3.args)||[];var hasRefChanged=selectorOrConfig!==((_cacheRef$current4=cacheRef.current)==null?void 0:_cacheRef$current4.selectorRef);var isDifferent=argsChanged||isRefDifferent(ecosystem,selectorOrConfig,cacheRef);if(isDifferent||!cacheRef.current){// yes, this mutation is fine\ncacheRef.current=ecosystem.selectorCache.getCache(selectorOrConfig,resolvedArgs);}var cache=cacheRef.current;var _useMemo=(0,react.useMemo)(function(){var isInvalidated=false;return[function(onStoreChange){var _ecosystem$_graph$nod2;// we have to fire an extra update on subscribe in test envs because\n// there's a bug in React (but only in test environments) where\n// useEffects in child components run before useSyncExternalStore\n// subscribe is called in the parent component.\nif(glob.IS_REACT_ACT_ENVIRONMENT)onStoreChange();// this function must be idempotent\nif(!((_ecosystem$_graph$nod2=ecosystem._graph.nodes[cache.cacheKey])!=null&&_ecosystem$_graph$nod2.dependents[dependentKey])){// React can unmount other components before calling this subscribe\n// function but after we got the cache above. Re-get the cache\n// if such unmountings destroyed it in the meantime:\nif(cache.isDestroyed){;cacheRef.current=general/* destroyed */.lv;isInvalidated=true;onStoreChange();return function(){};// let the next render register the graph edge\n}ecosystem._graph.addEdge(dependentKey,cache.cacheKey,OPERATION,general/* External */.RQ,function(signal,newState){if(newState===skipState.current)return;if(signal==='Destroyed'){// see comment in useAtomInstance about why returning\n// a nonsense value from `getSnapshot` works\n;cacheRef.current=general/* destroyed */.lv;isInvalidated=true;}onStoreChange();});}return function(){// I don't think we need to unset any of the cache refs here\necosystem._graph.removeEdge(dependentKey,cache.cacheKey);};},function(){return isInvalidated?INVALIDATE_REACT:cache.result;}];},[ecosystem,cache]),subscribe=_useMemo[0],getSnapshot=_useMemo[1];// if ref changed but is clearly the \"same\" selector, swap out the ref and\n// invalidate the cache\nif(hasRefChanged&&!isDifferent){ecosystem.selectorCache._swapRefs(cache.selectorRef,selectorOrConfig,resolvedArgs);// prevent state update loop if new selector ref just returned a new result:\nskipState.current=cache.result;}return (0,react.useSyncExternalStore)(subscribe,getSnapshot,getSnapshot);};\n;// CONCATENATED MODULE: ../packages/react/src/hooks/useAtomState.ts\nvar useAtomState=function useAtomState(atom,params,config){if(config===void 0){config={operation:'useAtomState'};}var instance=(0,useAtomInstance/* useAtomInstance */.Q)(atom,params,Object.assign({},config,{subscribe:true}));return[instance.getState(),instance._infusedSetter];};\n;// CONCATENATED MODULE: ../packages/react/src/hooks/useAtomValue.ts\nvar useAtomValue=function useAtomValue(atom,params,config){if(config===void 0){config={operation:'useAtomValue'};}var instance=(0,useAtomInstance/* useAtomInstance */.Q)(atom,params,Object.assign({},config,{subscribe:true}));return instance.getState();};\n;// CONCATENATED MODULE: ../packages/react/src/hooks/index.ts\n\n;// CONCATENATED MODULE: ../packages/react/src/injectors/injectAtomInstance.ts\nvar defaultOperation='injectAtomInstance';/**\n * injectAtomInstance\n *\n * Creates an atom instance for the passed atom based on the passed params. If\n * an instance has already been created for the passed params, reuses the\n * existing instance.\n *\n * Registers a static graph dependency on the atom instance. This means atoms\n * that use this injector will *not* reevaluate when this atom instance's state\n * changes.\n *\n * Pass false as the 4th param to prevent this graph dependency from being\n * registered. Useful when you need to control the graph dependency manually.\n * `injectAtomSelector` does this internally.\n *\n * @param atom The atom to instantiate or reuse an instantiation of.\n * @param params The params for generating the instance's key.\n * @param operation The operation name (e.g. name of the injector function)\n * that's triggering this graph dependency. If you're using this injector\n * directly in an atom, it's fine to omit this parameter.\n * @returns An atom instance, keyed based on the passed params.\n */var injectAtomInstance=(0,createInjector/* createInjector */.v)(defaultOperation,function(instance,atom,params,config){var injectedInstance=instance.ecosystem._evaluationStack.atomGetters.getInstance(atom,params,[config!=null&&config.subscribe?0:general/* Static */.qG,(config==null?void 0:config.operation)||defaultOperation]);return{result:injectedInstance,type:general/* prefix */.O4+\"/atom\"};},function(prevDescriptor,instance,atom,params,config){// make sure the dependency gets registered for this evaluation\nvar injectedInstance=instance.ecosystem._evaluationStack.atomGetters.getInstance(atom,params,[config!=null&&config.subscribe?0:general/* Static */.qG,(config==null?void 0:config.operation)||defaultOperation]);prevDescriptor.result=injectedInstance;return prevDescriptor;});\n;// CONCATENATED MODULE: ../packages/react/src/injectors/injectAtomSelector.ts\nvar injectAtomSelector=function injectAtomSelector(selectable){var _instance$ecosystem$_;var instance=(0,EvaluationStack/* readInstance */.i)();for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}return(_instance$ecosystem$_=instance.ecosystem._evaluationStack.atomGetters).select.apply(_instance$ecosystem$_,[selectable].concat(args));};\n;// CONCATENATED MODULE: ../packages/react/src/injectors/injectAtomState.ts\nvar injectAtomState=function injectAtomState(atom,params){var instance=injectAtomInstance(atom,params,{operation:'injectAtomState',subscribe:true});var setState=function setState(settable,meta){return instance.setState(settable,meta);};Object.assign(setState,instance.exports);return[instance.store.getState(),setState];};\n;// CONCATENATED MODULE: ../packages/react/src/injectors/injectAtomValue.ts\nvar injectAtomValue=function injectAtomValue(atom,params){var instance=injectAtomInstance(atom,params,{operation:'injectAtomValue',subscribe:true});return instance.store.getState();};\n;// CONCATENATED MODULE: ../packages/react/src/injectors/injectMemo.ts\nvar injectMemo=(0,createInjector/* createInjector */.v)('injectMemo',function(instance,valueFactory,deps){return{type:general/* prefix */.O4+\"/memo\",deps:deps,result:valueFactory()};},function(prevDescriptor,instance,valueFactory,deps){var depsHaveChanged=(0,general/* haveDepsChanged */.EM)(prevDescriptor.deps,deps);var result=depsHaveChanged?valueFactory():prevDescriptor.result;prevDescriptor.deps=deps;prevDescriptor.result=result;return prevDescriptor;});\n;// CONCATENATED MODULE: ../packages/react/src/injectors/injectCallback.ts\nvar injectCallback=function injectCallback(callback,deps){return injectMemo(function(){return callback;},deps);};\n// EXTERNAL MODULE: ../packages/react/src/injectors/injectEffect.ts\nvar injectEffect = __webpack_require__(8723);\n;// CONCATENATED MODULE: ../packages/react/src/injectors/injectInvalidate.ts\nvar injectInvalidate=function injectInvalidate(){var instance=(0,EvaluationStack/* readInstance */.i)();return function(){return instance.invalidate('injectInvalidate','Injector');};};\n// EXTERNAL MODULE: ../packages/react/src/injectors/injectStore.ts\nvar injectStore = __webpack_require__(5684);\n;// CONCATENATED MODULE: ../packages/react/src/injectors/injectMachineStore.ts\n/**\n * Create a MachineStore. Pass a statesFactory\n *\n * The first state in the state list returned from your statesFactory will\n * become the initial state (`.value`) of the store.\n *\n * Registers an effect that listens to all store changes and calls the\n * configured listeners appropriately.\n *\n * ```ts\n * const store = injectMachineStore(state => [\n *   state('a')\n *     .on('next', 'b', localGuard)\n *     .onEnter(enterListener)\n *     .onLeave(leaveListener),\n *   state('b').on('next', 'a')\n * ], initialContext, { guard, onTransition })\n * ```\n *\n * Set a universal transition guard via the 3rd `config` object param. This\n * guard will be called every time a valid transition is about to occur. It will\n * be called with the current `.context` value and should return a boolean.\n * Return true to allow the transition, or any falsy value to deny it.\n *\n * Set a universal `onTransition` listener via the 3rd `config` object param.\n * This listener will be called every time the machine transitions to a new\n * state (after the state is updated). It will be called with 2 params: The\n * current MachineStore and the storeEffect of the action that transitioned the\n * store. For example, use `storeEffect.oldState.value` to see what state the\n * machine just transitioned from.\n *\n * @param statesFactory Required. A function. Use the received state factory to\n * create a list of states for the machine and specify their transitions,\n * guards, and listeners.\n * @param initialContext Optional. An object or undefined. Will be set as the\n * initial `.context` value of the machine store's state.\n * @param config Optional. An object with 2 additional properties: `guard` and\n * `onTransition`.\n */var injectMachineStore=(0,createInjector/* createInjector */.v)('injectMachineStore',function(instance){var _hydration$value,_hydration$context;for(var _len=arguments.length,_ref=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){_ref[_key-1]=arguments[_key];}var statesFactory=_ref[0],initialContext=_ref[1],config=_ref[2];var enterHooks={};var leaveHooks={};var states={};var createState=function createState(stateName){var state={on:function on(eventName,nextState,guard){if(!states[stateName]){states[stateName]={};}if(!states[nextState]){states[nextState]={};}states[stateName][eventName]={name:nextState,guard:guard};return state;},onEnter:function onEnter(callback){if(!enterHooks[stateName]){enterHooks[stateName]=[];}enterHooks[stateName].push(callback);return state;},onLeave:function onLeave(callback){if(!leaveHooks[stateName]){leaveHooks[stateName]=[];}leaveHooks[stateName].push(callback);return state;},stateName:stateName};return state;};var _statesFactory=statesFactory(createState),initialState=_statesFactory[0];var hydration=(config==null?void 0:config.hydrate)&&instance.ecosystem._consumeHydration(instance);var store=new MachineStore((_hydration$value=hydration==null?void 0:hydration.value)!=null?_hydration$value:initialState.stateName,states,(_hydration$context=hydration==null?void 0:hydration.context)!=null?_hydration$context:initialContext,config==null?void 0:config.guard);var subscription=store.subscribe({effects:function effects(storeEffect){var newState=storeEffect.newState,oldState=storeEffect.oldState;if(newState.value===(oldState==null?void 0:oldState.value))return;if(oldState&&leaveHooks[oldState.value]){leaveHooks[oldState.value].forEach(function(callback){return callback(store,storeEffect);});}if(enterHooks[newState.value]){enterHooks[newState.value].forEach(function(callback){return callback(store,storeEffect);});}if(config!=null&&config.onTransition){config.onTransition(store,storeEffect);}}});var updaterSub=(config==null?void 0:config.subscribe)&&(0,injectStore/* doSubscribe */.n)(instance,store);var currentState=store.getState();if(enterHooks[currentState.value]){enterHooks[currentState.value].forEach(function(callback){return callback(store,{newState:currentState,store:store});});}var descriptor={cleanup:function cleanup(){subscription.unsubscribe();descriptor.cleanupUpdater==null?void 0:descriptor.cleanupUpdater();},result:store,type:general/* prefix */.O4+\"/machineStore\"};if(updaterSub){descriptor.cleanupUpdater=function(){return updaterSub.unsubscribe();};}return descriptor;},function(prevDescriptor,instance){var _config$subscribe;for(var _len2=arguments.length,_ref2=new Array(_len2>2?_len2-2:0),_key2=2;_key2<_len2;_key2++){_ref2[_key2-2]=arguments[_key2];}var config=_ref2[2];var subscribe=(_config$subscribe=config==null?void 0:config.subscribe)!=null?_config$subscribe:true;var prevsubscribe=!!prevDescriptor.cleanupUpdater;if(prevsubscribe===subscribe)return prevDescriptor;// we were subscribed, now we're not\nif(!subscribe){prevDescriptor.cleanupUpdater==null?void 0:prevDescriptor.cleanupUpdater();prevDescriptor.cleanupUpdater=undefined;return prevDescriptor;}// we weren't subscribed, now we are\nvar subscription=(0,injectStore/* doSubscribe */.n)(instance,prevDescriptor.result);prevDescriptor.cleanupUpdater=function(){return subscription.unsubscribe();};return prevDescriptor;});\n// EXTERNAL MODULE: ../packages/core/src/utils/general.ts\nvar utils_general = __webpack_require__(8487);\n// EXTERNAL MODULE: ../packages/react/src/utils/promiseUtils.ts\nvar promiseUtils = __webpack_require__(1881);\n// EXTERNAL MODULE: ../packages/react/src/injectors/injectRef.ts\nvar injectRef = __webpack_require__(7361);\n;// CONCATENATED MODULE: ../packages/react/src/injectors/injectPromise.ts\nvar injectPromise_excluded=[\"dataOnly\",\"initialState\"];/**\n * Create a memoized promise reference. Kicks off the promise immediately\n * (unlike injectEffect which waits a tick). Creates a store to track promise\n * state. This store's state shape is based off React Query:\n *\n * ```ts\n * {\n *   data?: <promise result type>\n *   error?: Error\n *   isError: boolean\n *   isLoading: boolean\n *   isSuccess: boolean\n *   status: 'error' | 'loading' | 'success'\n * }\n * ```\n *\n * Returns an Atom API with `.store` and `.promise` set.\n *\n * The 2nd `deps` param is just like `injectMemo` - these deps determine when\n * the promise's reference should change.\n *\n * The 3rd `config` param can take the following options:\n *\n * - `dataOnly`: Set this to true to prevent the store from tracking promise\n *   status and make your promise's `data` the entire state.\n *\n * - `initialState`: Set the initial state of the store (e.g. a placeholder\n *   value before the promise resolves)\n *\n * - store config: Any other config options will be passed directly to\n *   `injectStore`'s config. For example, pass `subscribe: false` to\n *   prevent the store from reevaluating the current atom on update.\n *\n * ```ts\n * const promiseApi = injectPromise(async () => {\n *   const response = await fetch(url)\n *   return await response.json()\n * }, [url], {\n *   dataOnly: true,\n *   initialState: '',\n *   subscribe: false\n * })\n * ```\n */var injectPromise=function injectPromise(promiseFactory,deps,_temp){var _ref=_temp===void 0?{}:_temp,dataOnly=_ref.dataOnly,initialState=_ref.initialState,storeConfig=(0,objectWithoutPropertiesLoose/* default */.Z)(_ref,injectPromise_excluded);var refs=(0,injectRef/* injectRef */.i)({});var store=(0,injectStore/* injectStore */.F)(dataOnly?initialState:(0,promiseUtils/* getInitialPromiseState */.KF)(initialState),storeConfig);// setting a ref during evaluation is perfectly fine in Zedux\nrefs.current.promise=injectMemo(function(){var prevController=refs.current.controller;var nextController=typeof AbortController!=='undefined'?new AbortController():undefined;refs.current.controller=nextController;var promise=promiseFactory(refs.current.controller);if( true&&typeof(promise==null?void 0:promise.then)!=='function'){throw new TypeError(\"Zedux: injectPromise expected callback to return a promise. Received \"+(0,utils_general/* detailedTypeof */.px)(promise));}if(promise===refs.current.promise)return refs.current.promise;prevController==null?void 0:prevController.abort==null?void 0:prevController.abort('updated');if(!dataOnly){// preserve previous data and error using setStateDeep:\nstore.setStateDeep((0,promiseUtils/* getInitialPromiseState */.KF)());}promise.then(function(data){if(nextController!=null&&nextController.signal.aborted)return;store.setState(dataOnly?data:(0,promiseUtils/* getSuccessPromiseState */.W2)(data));}).catch(function(error){if(dataOnly||nextController!=null&&nextController.signal.aborted)return;// preserve previous data using setStateDeep:\nstore.setStateDeep((0,promiseUtils/* getErrorPromiseState */.bG)(error));});return promise;},deps);(0,injectEffect/* injectEffect */.o)(function(){return function(){var _refs$current$control;return(_refs$current$control=refs.current.controller)==null?void 0:_refs$current$control.abort==null?void 0:_refs$current$control.abort('destroyed');};},[]);return (0,api/* api */.h)(store).setPromise(refs.current.promise);};\n;// CONCATENATED MODULE: ../packages/react/src/injectors/injectWhy.ts\n/**\n * A fake injector (can actually be used in loops and if statements). An alias\n * for:\n *\n * ```ts\n * const { ecosystem } = injectAtomGetters()\n * const reasons = ecosystem.why()\n * ```\n */var injectWhy=function injectWhy(){return (0,EvaluationStack/* readInstance */.i)()._nextEvaluationReasons;};\n;// CONCATENATED MODULE: ../packages/react/src/injectors/index.ts\n\n// EXTERNAL MODULE: ../packages/react/src/store/index.ts\nvar store = __webpack_require__(825);\n;// CONCATENATED MODULE: ../packages/react/src/index.ts\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteralLoose.js\nvar taggedTemplateLiteralLoose = __webpack_require__(1880);\n// EXTERNAL MODULE: ./src/ssc/index.tsx\nvar ssc = __webpack_require__(8880);\n;// CONCATENATED MODULE: ./src/theme/CodeBlock/LogActions.tsx\nvar _templateObject,_templateObject2,_templateObject3,_templateObject4,_templateObject5,_templateObject6;var options={AtomState:'Atom State',SelectorCache:'Selector Cache',Ecosystem:'Ecosystem',Graph:'Graph',Scope:'Sandbox Scope'};var Backdrop=ssc/* default.div */.ZP.div(_templateObject||(_templateObject=(0,taggedTemplateLiteralLoose/* default */.Z)([\"\\n  height: 100%;\\n  left: 0;\\n  position: fixed;\\n  top: 0;\\n  width: 100%;\\n  z-index: 1000000;\\n\"])));var Button=ssc/* default.button */.ZP.button(_templateObject2||(_templateObject2=(0,taggedTemplateLiteralLoose/* default */.Z)([\"\\n  background: none;\\n  border: none;\\n  color: #fff;\\n  cursor: pointer;\\n\"])));var Dropdown=ssc/* default.button */.ZP.button(_templateObject3||(_templateObject3=(0,taggedTemplateLiteralLoose/* default */.Z)([\"\\n  align-items: center;\\n  background: transparent;\\n  border: none;\\n  color: #fff;\\n  cursor: pointer;\\n  display: flex;\\n  flex-flow: row nowrap;\\n  font-size: inherit;\\n  gap: 0.5rem;\\n\"])));var Option=ssc/* default.span */.ZP.span(_templateObject4||(_templateObject4=(0,taggedTemplateLiteralLoose/* default */.Z)([\"\\n  background: #ffa359;\\n  border-radius: 5px;\\n  box-shadow: 5px 5px 8px #0004;\\n  cursor: pointer;\\n  padding: 0.2rem 1rem;\\n  white-space: nowrap;\\n  transform: scale(1);\\n  transition: transform 0.1s;\\n\\n  &:hover {\\n    transform: scale(1.05);\\n  }\\n\"])));var Options=ssc/* default.span */.ZP.span(_templateObject5||(_templateObject5=(0,taggedTemplateLiteralLoose/* default */.Z)([\"\\n  display: flex;\\n  flex-flow: column nowrap;\\n  gap: 1rem;\\n  left: 50%;\\n  position: absolute;\\n  transform: translateX(-50%);\\n  top: calc(100% + 1rem);\\n  z-index: 1000001;\\n\"])));var Wrapper=ssc/* default.span */.ZP.span(_templateObject6||(_templateObject6=(0,taggedTemplateLiteralLoose/* default */.Z)([\"\\n  border: 1px solid #fff;\\n  border-radius: 3px;\\n  display: flex;\\n  flex-flow: row nowrap;\\n  font-size: 0.8em;\\n  position: relative;\\n\\n  > button {\\n    padding: 2px 0.8rem;\\n\\n    &:hover {\\n      background: #fff4;\\n    }\\n  }\\n\"])));var CaretDownIcon=function CaretDownIcon(){return/*#__PURE__*/react.createElement(\"svg\",{xmlns:\"http://www.w3.org/2000/svg\",width:\"12\",height:\"8\",viewBox:\"0 0 12 8\"},/*#__PURE__*/react.createElement(\"path\",{fill:\"transparent\",stroke:\"#fff\",d:\"M0 0 L 6 8 L 12 0\"}));};var LogActions=function LogActions(_ref){var ecosystemIdRef=_ref.ecosystemIdRef,Zedux=_ref.Zedux;var _useState=(0,react.useState)(false),isOpen=_useState[0],setIsOpen=_useState[1];var _useState2=(0,react.useState)(),lastSelection=_useState2[0],setLastSelection=_useState2[1];var actions=(0,react.useMemo)(function(){return{AtomState:function AtomState(){console.group('Current state of all atom instances:');console.log(Zedux.getEcosystem(ecosystemIdRef.current).dehydrate({transform:false}));console.groupEnd();},Ecosystem:function Ecosystem(){console.group('Ecosystem:');console.log(Zedux.getEcosystem(ecosystemIdRef.current));console.groupEnd();},Graph:function Graph(){var ecosystem=Zedux.getEcosystem(ecosystemIdRef.current);console.group('Current graph:');console.log('Flat:',ecosystem.viewGraph('flat'));console.log('Top-Down:',ecosystem.viewGraph('top-down'));console.log('Bottom-Up:',ecosystem.viewGraph('bottom-up'));console.groupEnd();},SelectorCache:function SelectorCache(){console.group('Cached selectors:');console.log(Zedux.getEcosystem(ecosystemIdRef.current).selectorCache.inspectItemValues());console.groupEnd();},Scope:function Scope(){console.group('Exports available in the sandbox:');console.log('Zedux:',Zedux);console.log('React:',react);console.groupEnd();}};},[Zedux]);return/*#__PURE__*/react.createElement(react.Fragment,null,isOpen&&/*#__PURE__*/react.createElement(Backdrop,{onClick:function onClick(){return setIsOpen(false);}}),/*#__PURE__*/react.createElement(Wrapper,null,lastSelection&&/*#__PURE__*/react.createElement(Button,{onClick:function onClick(){return actions[lastSelection]();}},\"Log \",options[lastSelection]),/*#__PURE__*/react.createElement(Dropdown,{onClick:function onClick(){return setIsOpen(true);}},!lastSelection&&/*#__PURE__*/react.createElement(\"span\",null,\"Log\"),/*#__PURE__*/react.createElement(CaretDownIcon,null)),isOpen&&/*#__PURE__*/react.createElement(Options,{onClick:function onClick(){setIsOpen(false);}},Object.keys(options).map(function(option){return/*#__PURE__*/react.createElement(Option,{key:option,onClick:function onClick(){setLastSelection(option);actions[option]();}},options[option]);}))));};\n;// CONCATENATED MODULE: ./src/theme/CodeBlock/editorUtils.ts\nvar openingChars=['{','[','(','<'];var closingChars=['}',']',')','>'];var editorUtils_onKeyDown=function onKeyDown(editor,event){var _lineText$match;if(event.key==='Tab'){event.preventDefault();editor.insertText('  ');return;}if(event.key==='{'){event.preventDefault();editor.insertText('{}');Transforms.move(editor,{distance:1,reverse:true,unit:'character'});return;}if(event.key==='['){event.preventDefault();editor.insertText('[]');Transforms.move(editor,{distance:1,reverse:true,unit:'character'});return;}if(event.key==='('){event.preventDefault();editor.insertText('()');Transforms.move(editor,{distance:1,reverse:true,unit:'character'});return;}var domRange=editor.selection&&ReactEditor.toDOMRange(editor,editor.selection);if(!domRange)return;var line=domRange.startContainer.parentElement;while(line.dataset.slateNode!=='text'){line=line.parentElement;}var lineText=line.innerText;var spaces=((_lineText$match=lineText.match(/^ +/))==null?void 0:_lineText$match[0])||'';var hasSelection=domRange.startOffset!==domRange.endOffset;var endOffset=hasSelection?domRange.endOffset:editor.selection.focus.offset;var startOffset=hasSelection?domRange.startOffset:endOffset;var prevChar=lineText[startOffset-1]||'';var nextChar=lineText[endOffset]||'';if(event.key==='}'&&nextChar==='}'||event.key===']'&&nextChar===']'||event.key===')'&&nextChar===')'||event.key==='\"'&&nextChar==='\"'||event.key===\"'\"&&nextChar===\"'\"||event.key==='`'&&nextChar==='`'){event.preventDefault();Transforms.move(editor,{distance:1,unit:'character'});return;}if(event.key==='Enter'){event.preventDefault();editor.insertBreak();if(openingChars.includes(prevChar)){editor.insertText(spaces+\"  \");if(closingChars.includes(nextChar)){editor.insertBreak();editor.insertText(spaces);Transforms.move(editor,{distance:spaces.length+1,reverse:true,unit:'character'});}return;}editor.insertText(spaces);return;}};var scrollSelectionIntoView=function scrollSelectionIntoView(editor,domRange){var el=domRange.startContainer.parentElement;var editorEl=domRange.startContainer.parentElement;while(!editorEl.dataset.slateEditor){editorEl=editorEl.parentElement;}var charWidth=el.getBoundingClientRect().width/el.innerText.length;var prevPos=editorEl.scrollLeft;domRange.startContainer.parentElement.scrollIntoView({block:'nearest'});if(!charWidth){// this means the current line is empty - set scrollPos to the far left\neditorEl.scrollLeft=0;return;}var width=editorEl.clientWidth;var charNum=editor.selection.focus.offset;var offset=charNum*charWidth;var BUFFER=24;if(offset+(BUFFER+8)-width>prevPos){// move right\neditorEl.scrollLeft=offset+(BUFFER+8)-width;}else if(offset-(BUFFER-8)<prevPos){// move left\neditorEl.scrollLeft=offset-(BUFFER-8);}else{editorEl.scrollLeft=prevPos;}};\n;// CONCATENATED MODULE: ./src/theme/CodeBlock/styles.ts\nvar styles_templateObject,styles_templateObject2,styles_templateObject3,styles_templateObject4,styles_templateObject5,styles_templateObject6,_templateObject7,_templateObject8,_templateObject9;var EditorWrapper=ssc/* default.div */.ZP.div(styles_templateObject||(styles_templateObject=(0,taggedTemplateLiteralLoose/* default */.Z)([\"\\n  display: flex;\\n  flex-flow: row nowrap;\\n  font-family: 'Source Code Pro', monospace;\\n  font-size: var(--ifm-code-font-size);\\n  letter-spacing: -0.2px;\\n  max-height: 500px;\\n  overflow-y: auto;\\n\"])));var Gutter=ssc/* default.div */.ZP.div(styles_templateObject2||(styles_templateObject2=(0,taggedTemplateLiteralLoose/* default */.Z)([\"\\n  border-bottom-left-radius: 12px;\\n  display: flex;\\n  flex-flow: column nowrap;\\n  height: fit-content;\\n  min-height: 100%;\\n  min-width: 1.7rem;\\n  padding: 0.5rem 5px 1rem;\\n  text-align: right;\\n\\n  > span {\\n    color: #fffb;\\n    transform: scale(0.8);\\n    white-space: nowrap;\\n  }\\n\"])));var Header=ssc/* default.div */.ZP.div(styles_templateObject3||(styles_templateObject3=(0,taggedTemplateLiteralLoose/* default */.Z)([\"\\n  align-items: center;\\n  background: #ffa359;\\n  border-radius: 12px 12px 0 0;\\n  color: #fff;\\n  display: flex;\\n  flex-flow: row nowrap;\\n  gap: 1rem;\\n  grid-column: span 2;\\n  padding: 0.5rem;\\n\\n  > img {\\n    filter: brightness(0) invert(1);\\n    font-size: 0;\\n    height: 1rem;\\n  }\\n\"])));var HeaderActions=ssc/* default.span */.ZP.span(styles_templateObject4||(styles_templateObject4=(0,taggedTemplateLiteralLoose/* default */.Z)([\"\\n  display: flex;\\n  flex-flow: row nowrap;\\n  gap: 1rem;\\n\"])));var HeaderText=ssc/* default.span */.ZP.span(styles_templateObject5||(styles_templateObject5=(0,taggedTemplateLiteralLoose/* default */.Z)([\"\\n  flex: 1;\\n\"])));var ResetButton=ssc/* default.button */.ZP.button(styles_templateObject6||(styles_templateObject6=(0,taggedTemplateLiteralLoose/* default */.Z)([\"\\n  background: #fff;\\n  border: none;\\n  border-radius: 3px;\\n  color: #ff4545;\\n  cursor: pointer;\\n  font-size: 0.8em;\\n  padding: 2px 1rem;\\n\\n  &:hover {\\n    background: #fffb;\\n  }\\n\"])));var Result=ssc/* default.div */.ZP.div(_templateObject7||(_templateObject7=(0,taggedTemplateLiteralLoose/* default */.Z)([\"\\n  background: #fff;\\n  border-bottom-right-radius: 12px;\\n  box-shadow: inset 4px 4px 6px #888;\\n  color: #1c1e21;\\n  color-scheme: light;\\n  max-height: 500px;\\n  overflow: auto;\\n  padding: 0.5rem;\\n  position: relative;\\n\"])));var StyledEditable=(0,ssc/* default */.ZP)(Editable)(_templateObject8||(_templateObject8=(0,taggedTemplateLiteralLoose/* default */.Z)([\"\\n  background: #2b313a;\\n  flex: 1;\\n  height: fit-content;\\n  min-height: 100%;\\n  overflow-x: auto;\\n  padding: 0.5rem 0.5rem 1rem;\\n  white-space: pre !important;\\n\\n  > div {\\n    min-width: fit-content;\\n    padding-right: 0.5rem;\\n  }\\n\\n  .token {\\n    color: #d7dfec;\\n\\n    \",\"\\n\\n    &.comment {\\n      font-style: italic;\\n    }\\n\\n    &.keyword {\\n      color: #e08a57;\\n    }\\n  }\\n\"])),function(_ref){var $sscProps=_ref.$sscProps;return $sscProps.styles.map(function(_ref2){var style=_ref2.style,types=_ref2.types;return types.map(function(type){return\"&.\"+type+\" { \"+(0,ssc/* css */.iv)(style/* Prism font-weight type is wrong */)+\" }\";}).join('\\n');}).join('\\n');});var styles_Wrapper=ssc/* default.section */.ZP.section(_templateObject9||(_templateObject9=(0,taggedTemplateLiteralLoose/* default */.Z)([\"\\n  background: #474c54;\\n  border-radius: 12px;\\n  box-shadow: 10px 10px 7px rgba(0, 0, 0, 0.4);\\n  display: grid;\\n  grid-template-columns: minmax(180px, 9fr) minmax(140px, 5fr);\\n  grid-template-rows: auto auto;\\n  line-height: 1.45;\\n  margin: 0 -0.6rem 2em;\\n\\n  @media (min-width: 1600px) {\\n    margin-left: -1.8rem;\\n    margin-right: -1.8rem;\\n  }\\n\"])));\n;// CONCATENATED MODULE: ./src/theme/CodeBlock/Sandbox.tsx\nvar Zedux=Object.assign({},react_src_namespaceObject,src_namespaceObject);// resolves all the getters\nvar scope=Object.assign({},Zedux,react);var scopeKeys=Object.keys(scope);var scopeValues=scopeKeys.map(function(key){return scope[key];});var decorateTokens=function decorateTokens(path,tokens,params,parentType){for(var _iterator=(0,createForOfIteratorHelperLoose/* default */.Z)(tokens),_step;!(_step=_iterator()).done;){var token=_step.value;var end=params.start+token.length;if(typeof token==='string'){if(parentType){params.ranges.push({anchor:{path:path,offset:params.start},focus:{path:path,offset:end},tokenType:parentType});}params.start=end;continue;}if(typeof token.content==='string'||!Array.isArray(token.content)){params.ranges.push({anchor:{path:path,offset:params.start},focus:{path:path,offset:end},tokenType:token.type});params.start=end;continue;}decorateTokens(path,token.content,params,token.type);}return params.ranges;};var decorate=function decorate(_ref){var node=_ref[0],path=_ref[1];if(!Text.isText(node)){return[];}var tokens=prism_default().tokenize(node.text,(prism_default()).languages.tsx);return decorateTokens(path,tokens,{ranges:[],start:0});};var evalCode=function evalCode(code,resultVarName,ecosystemIdRef,extraScope){var resultStr=\"var \"+resultVarName+\"; \"+code+\"; var _$_$res = typeof \"+resultVarName+\" === 'function' ? React.createElement(\"+resultVarName+\") : typeof \"+resultVarName+\" === 'string' ? \"+resultVarName+\" : React.createElement('pre', null, JSON.stringify(\"+resultVarName+\", null, 2));\";var wrapped=resultStr+\" return _$_$res\";var extraScopeKeys=extraScope?[].concat(Object.keys(extraScope)):[];var keys=extraScope?[].concat(scopeKeys,extraScopeKeys):scopeKeys;var vals=extraScope?[].concat(scopeValues,extraScopeKeys.map(function(key){return extraScope[key];})):scopeValues;// eslint-disable-next-line no-new-func\nvar fn=(0,construct/* default */.Z)(Function,['React'].concat(keys,[wrapped]));var ecosystemsBefore=store/* internalStore.getState */.Do.getState();var result=fn.call.apply(fn,[null,react].concat(vals));var ecosystemsAfter=store/* internalStore.getState */.Do.getState();if(!ecosystemIdRef.current){Object.keys(ecosystemsAfter).forEach(function(key){if(!ecosystemsBefore[key])ecosystemIdRef.current=key;});}return result;};var parse=function parse(text){return text.split('\\n').slice(0,-1).map(function(line){return{type:'paragraph',children:[{text:line}]};});};var serialize=function serialize(nodes){return nodes.map(function(node){return node.children.map(function(child){return child.text;}).join('');}).join('\\n');};var ErrorBoundary=/*#__PURE__*/function(_React$Component){(0,inheritsLoose/* default */.Z)(ErrorBoundary,_React$Component);function ErrorBoundary(props){var _this;_this=_React$Component.call(this,props)||this;_this.state={hasError:false};return _this;}var _proto=ErrorBoundary.prototype;_proto.UNSAFE_componentWillReceiveProps=function UNSAFE_componentWillReceiveProps(){this.setState({hasError:false});};ErrorBoundary.getDerivedStateFromError=function getDerivedStateFromError(){return{hasError:true};};_proto.render=function render(){// idk y\nif(this.state.hasError){return/*#__PURE__*/react.createElement(\"span\",null,\"...\");}return this.props.children||/*#__PURE__*/react.createElement(\"span\",null);};return ErrorBoundary;}(react.Component);var Sandbox_Leaf=function Leaf(_ref2){var attributes=_ref2.attributes,children=_ref2.children,leaf=_ref2.leaf;return/*#__PURE__*/react.createElement(\"span\",(0,esm_extends/* default */.Z)({className:\"token \"+(leaf.tokenType||'')},attributes),children);};var Sandbox=function Sandbox(_ref3){var children=_ref3.children,ecosystemId=_ref3.ecosystemId,extraScope=_ref3.extraScope,_ref3$resultVar=_ref3.resultVar,resultVar=_ref3$resultVar===void 0?'Result':_ref3$resultVar;var baseUrl=(0,useDocusaurusContext/* default */.Z)().siteConfig.baseUrl;var editor=(0,react.useMemo)(function(){return withHistory(withReact(createEditor()));},[]);var initialValue=(0,react.useMemo)(function(){return parse(children);},[]);var _useState=(0,react.useState)(initialValue),value=_useState[0],setValue=_useState[1];var _useState2=(0,react.useState)(''),result=_useState2[0],setResult=_useState2[1];var theme=(0,usePrismTheme/* usePrismTheme */.p)();var ecosystemIdRef=(0,react.useRef)(ecosystemId);var lastLoggedErrorTimeRef=(0,react.useRef)();var isMountedRef=(0,react.useRef)(true);var runCode=(0,react.useCallback)(function(rawVal){var val=serialize(rawVal);try{var _window;var extraScopeStr=typeof extraScope==='string'?extraScope:'';var jsCode=(_window=window)==null?void 0:_window.ts.transpile(extraScopeStr+\"; \"+val,{jsx:'react'});if(!jsCode)return;var ecosystem=Zedux.getEcosystem(ecosystemIdRef.current);if(Object.keys((ecosystem==null?void 0:ecosystem._instances)||{}).length){ecosystem==null?void 0:ecosystem.wipe();ecosystem==null?void 0:ecosystem.setOverrides([]);}var evalResult=evalCode(jsCode,resultVar,ecosystemIdRef,typeof extraScope==='string'?undefined:extraScope);lastLoggedErrorTimeRef.current=undefined;if(isMountedRef.current)setResult(evalResult);}catch(err){if(isMountedRef.current)setResult(err.message);if(lastLoggedErrorTimeRef.current&&Date.now()-lastLoggedErrorTimeRef.current<5000// only log errors once every 5 seconds\n){return;}console.error('Live Sandbox error:',err);lastLoggedErrorTimeRef.current=Date.now();}},[ecosystemId,extraScope,resultVar]);// run initial code on mount (or if runCode changes - shouldn't happen)\n(0,react.useEffect)(function(){runCode(value);},[runCode]);var slate=/*#__PURE__*/react.createElement(Slate,{editor:editor,onChange:function onChange(newValue){if(newValue===value)return;setValue(newValue);runCode(newValue);},value:value},/*#__PURE__*/react.createElement(styles_Wrapper,null,/*#__PURE__*/react.createElement(Header,null,/*#__PURE__*/react.createElement(\"img\",{src:baseUrl+\"img/zedux-icon-75x75.png\"}),/*#__PURE__*/react.createElement(HeaderText,null,\"Live Sandbox\"),/*#__PURE__*/react.createElement(HeaderActions,null,/*#__PURE__*/react.createElement(LogActions,{ecosystemIdRef:ecosystemIdRef,Zedux:Zedux}),/*#__PURE__*/react.createElement(ResetButton,{onClick:function onClick(){setValue(initialValue);runCode(initialValue);editor.children=initialValue;}},\"Reset\"))),/*#__PURE__*/react.createElement(EditorWrapper,null,/*#__PURE__*/react.createElement(Gutter,null,value.map(function(_,i){return/*#__PURE__*/react.createElement(\"span\",{key:i},i+1);})),/*#__PURE__*/react.createElement(StyledEditable,{decorate:decorate,onKeyDown:function onKeyDown(event){return editorUtils_onKeyDown(editor,event);},placeholder:\"Write some code...\",renderLeaf:Sandbox_Leaf,scrollSelectionIntoView:scrollSelectionIntoView,$sscProps:theme})),/*#__PURE__*/react.createElement(Result,null,/*#__PURE__*/react.createElement(ErrorBoundary,null,result))));return ecosystemIdRef.current?/*#__PURE__*/react.createElement(Zedux.EcosystemProvider,{id:ecosystemId},slate):slate;};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxjQUFLO0FBQ3JDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVix3Q0FBd0MsNEJBQTRCOztBQUVwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQixtQkFBbUI7O0FBRW5CLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QUMzRjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLGFBQWE7QUFDdEI7QUFDQTs7QUFFQSx1dEJBQXV0QixhQUFhLCtDQUErQyxjQUFLO0FBQ3h4QjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxjQUFLO0FBQ2I7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDOzs7QUFHL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsY0FBSztBQUNiO0FBQ0EsYUFBYSxjQUFLO0FBQ2xCLFFBQVE7QUFDUixhQUFhLGNBQUs7QUFDbEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGNBQUs7QUFDYix5QkFBeUIsY0FBSztBQUM5QjtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsdUJBQXVCLGNBQUs7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7OztBQUdBLDZDQUE2Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELE9BQU87QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQSxvQ0FBb0MsbUJBQW1CO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QztBQUN6QyxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDs7QUFFQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsY0FBSztBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHVCQUF1QixjQUFLO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sdUJBQXVCLGNBQUssZUFBZTs7QUFFM0Msa0RBQWtELGNBQUs7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsY0FBYztBQUNoRjtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGNBQUs7QUFDOUQ7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxXQUFXOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNC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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCOztBQUUvQixpRUFBaUU7O0FBRWpFO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBLFVBQVUsY0FBSztBQUNmO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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OztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxVQUFVLGNBQUs7QUFDZjtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGNBQUs7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUEseUJBQXlCLGNBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOztBQUVWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxTQUFTLGNBQUs7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLFlBQVksY0FBSztBQUNqQjtBQUNBLFVBQVU7QUFDVix3QkFBd0IsY0FBSzs7QUFFN0I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7O0FBRTVGLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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MEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsRUFBRSxZQUFZOztBQUV4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHlCQUFnQixXQUFXLHdCQUFlLHNDQUFzQyxjQUFXO0FBQ25HO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLFdBQVcsY0FBYyx5QkFBeUIsY0FBYztBQUNoRSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLHFCQUFlLEdBQUcsZUFBUzs7QUFFekUsSUFBSSxtQkFBVztBQUNmLElBQUksb0JBQVk7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7O0FBRUEsd0JBQXdCLGdDQUF3QixRQUFRLG1CQUFXOztBQUVuRSx3QkFBd0IsZ0NBQXdCLFFBQVEsb0JBQVk7O0FBRXBFLFNBQVMscUJBQVk7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQUksZUFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCLGtFQUFrRTtBQUNsRTs7QUFFQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0MsY0FBYyxXQUFXO0FBQ3pCLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7O0FBR0EsOEdBQThHLGFBQWE7QUFDM0gsd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKOzs7QUFHQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixZQUFZLGdCQUFNOztBQUVsQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQSxHQUFHLEdBQUc7QUFDTjs7QUFFQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOzs7QUFHSixzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixtQkFBbUIseUJBQXlCLHlGQUF5RixtQkFBbUI7QUFDOUs7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyx1QkFBYTtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG9CQUFVOztBQUV6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsbUJBQW1CLDhCQUE4QjtBQUN4RixJQUFJO0FBQ0osdUJBQXVCLGdCQUFNO0FBQzdCO0FBQ0Esa0NBQWtDLGdCQUFNO0FBQ3hDLEVBQUUsbUJBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsbUJBQVM7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLHFDQUFxQztBQUNwSTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCw4QkFBOEIsbUJBQW1CLENBQUMsZUFBTTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUIsQ0FBQyxjQUFjO0FBQzlELElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGdDQUFnQyxVQUFVO0FBQzFDLDhMQUE4TCxXQUFhO0FBQzNNLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixzQkFBc0IsbUJBQW1CLHlCQUF5QjtBQUNsRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxhQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxZQUFZLGdCQUFNO0FBQ2xCLGVBQWUsZ0JBQWtCO0FBQ2pDO0FBQ0E7O0FBRUEsa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBLGdDQUFnQyxtQkFBbUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGdDQUFnQyxVQUFVLENBQUMsYUFBSTtBQUMvQztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLElBQUksZ0JBQU87QUFDWDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUJBQW1CLGlDQUFpQztBQUMxRjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFXO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0EsbUJBQW1CLGlCQUFpQjtBQUNwQyxlQUFlLFdBQVc7QUFDMUIsY0FBYyxtQkFBWTs7QUFFMUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0osTUFBTSxhQUFhO0FBQ25COztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGVBQWUsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLG1DQUFtQyxVQUFVLENBQUMsZ0JBQU87QUFDckQsNlFBQTZRLHFCQUFZO0FBQ3pSLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQixzQkFBc0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsdUJBQWE7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxvQkFBVTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLHVCQUFhO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQW1CLG9DQUFvQyxpQkFBaUI7O0FBRTVGLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUIsMkJBQTJCLDJCQUFrQjtBQUM3Qzs7QUFFQTtBQUNBLGNBQWMsMkJBQWtCOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGlCQUFtQjtBQUMzQixrQ0FBa0MsbUJBQW1CO0FBQ3JEO0FBQ0E7QUFDQSxPQUFPLGVBQWUsbUJBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTixrQ0FBa0MsbUJBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsdUJBQWE7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUyxvQkFBVTtBQUNuQjs7QUFFQSxnQ0FBZ0MsdUJBQWE7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLG9CQUFVOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQVc7QUFDeEMseUJBQXlCLDJCQUFXO0FBQ3BDLDZCQUE2QiwyQkFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLLEdBQUc7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxrQ0FBa0MsZUFBUztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHNCQUFzQixtQkFBbUIsQ0FBQyxjQUFjO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSixPQUFPLGNBQWM7QUFDckI7QUFDQTs7QUFFQSxhQUFhLFFBQVE7O0FBRXJCLE9BQU8sV0FBYTtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsU0FBUzs7QUFFMUIsT0FBTyxjQUFjO0FBQ3JCO0FBQ0E7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekIsU0FBUyxXQUFhO0FBQ3RCOztBQUVBO0FBQ0EsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKLE9BQU8sY0FBYztBQUNyQjtBQUNBOztBQUVBLGFBQWEsUUFBUTs7QUFFckIsT0FBTyxXQUFhO0FBQ3BCO0FBQ0E7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEMsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0EsYUFBYSxXQUFhO0FBQzFCLEtBQUs7O0FBRUwsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSwwQkFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sV0FBVyxXQUFXO0FBQ3RCLEdBQUc7O0FBRUg7QUFDQSxXQUFXLGVBQWU7QUFDMUI7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLElBQUksWUFBWTtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLFdBQVc7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTSwwQkFBaUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixjQUFjOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsa0JBQVMsMkJBQTJCLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELHNCQUFzQiwwQ0FBMEMsaUVBQWlFLEtBQUssa0NBQWtDOztBQUU3VSxTQUFTLHVCQUFlLFdBQVcsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLGtCQUFTLGdEQUFnRCx1QkFBZSw2QkFBNkIsS0FBSyw2Q0FBNkMsNkVBQTZFLE9BQU8sa0JBQVMsMENBQTBDLG1GQUFtRixPQUFPO0FBQzVnQjs7QUFFQSx3QkFBd0I7O0FBRXhCLHVCQUF1Qjs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSx3Q0FBd0MscUJBQVk7QUFDcEQsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsYUFBYTs7QUFFaEM7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixZQUFZOztBQUVyQyxnQ0FBZ0MscUJBQVk7QUFDNUMsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdDQUFnQyxxQkFBWTtBQUM1QyxRQUFRLGlCQUFpQjtBQUN6Qjs7QUFFQTtBQUNBLFFBQVEsaUJBQWlCO0FBQ3pCLFFBQVE7QUFDUixRQUFRLHFCQUFxQjtBQUM3QixRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHdGQUF3RixxQkFBWTtBQUNwRyxNQUFNLGlCQUFpQjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCLCtDQUErQyxXQUFXOztBQUUxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLHVCQUFlLENBQUMsdUJBQWUsR0FBRyx3QkFBd0I7QUFDbEY7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHlCQUFnQjtBQUN4Qix5QkFBeUIsb0JBQVc7QUFDcEMsaUJBQWlCLFNBQVM7O0FBRTFCO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQSxpQkFBaUIsV0FBYTtBQUM5QixTQUFTOztBQUVULG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEseUJBQWdCO0FBQ3hCLFVBQVUsV0FBVztBQUNyQiw2QkFBNkIsb0JBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxrQ0FBa0MscUJBQXFCO0FBQ3ZEO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNEO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaLGNBQWMsMEJBQWlCO0FBQy9CLDZCQUE2QixTQUFTOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7O0FBRUEsc0NBQXNDLG9CQUFvQjtBQUMxRDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBOztBQUVBOztBQUVBLGlDQUFpQywwQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsc0NBQXNDLHFCQUFxQjtBQUMzRDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBLGFBQWE7QUFDYixZQUFZLG9CQUFvQjtBQUNoQztBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0Q7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxzQkFBc0I7QUFDNUQ7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RCxrQkFBa0Isa0JBQVM7QUFDM0IsYUFBYTtBQUNiOztBQUVBLG1FQUFtRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxXQUFXO0FBQ3pCLG1DQUFtQyxvQkFBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCLDBCQUFpQjtBQUNoRSxxQ0FBcUMsdUJBQWUsQ0FBQyx1QkFBZSxHQUFHLHlCQUF5QjtBQUNoRztBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFdBQVc7QUFDaEQsMkNBQTJDLFdBQVc7O0FBRXREO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsZ0JBQU07QUFDM0IsRUFBRSxtQkFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsa0JBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSxtQkFBUztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLElBQUksbUJBQVc7O0FBRWYsU0FBUyxrQkFBUywyQkFBMkIsZ0NBQWdDLG9DQUFvQyxvREFBb0Qsc0JBQXNCLDBDQUEwQyxpRUFBaUUsS0FBSyxrQ0FBa0M7O0FBRTdVLFNBQVMsdUJBQWUsV0FBVyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEsa0JBQVMsZ0RBQWdELHVCQUFlLDZCQUE2QixLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxrQkFBUywwQ0FBMEMsbUZBQW1GLE9BQU87QUFDNWdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0JBQWdCLGdDQUF3QixPQUFPLG1CQUFXOztBQUUxRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixrQkFBUSxpQ0FBaUMsdUJBQWU7QUFDL0U7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFNO0FBQ2hDLDRCQUE0QixnQkFBTTtBQUNsQyxvQkFBb0IscUJBQVc7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUUsbUJBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksbUJBQVc7QUFDZixJQUFJLGtCQUFVOztBQUVkLFNBQVMsa0JBQVMsMkJBQTJCLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELHNCQUFzQiwwQ0FBMEMsaUVBQWlFLEtBQUssa0NBQWtDOztBQUU3VSxTQUFTLHVCQUFlLFdBQVcsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLGtCQUFTLGdEQUFnRCx1QkFBZSw2QkFBNkIsS0FBSyw2Q0FBNkMsNkVBQTZFLE9BQU8sa0JBQVMsMENBQTBDLG1GQUFtRixPQUFPOztBQUU1Z0IscUNBQXFDLG1CQUFtQixDQUFDLGNBQWMsNkJBQTZCOzs7QUFHcEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1CQUFtQixxQ0FBcUM7QUFDdEc7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxJQUFJO0FBQ0osbUJBQW1CLGdDQUF3QixRQUFRLG1CQUFXOztBQUU5RCwyQkFBMkI7O0FBRTNCLHNDQUFzQyxrQkFBUTtBQUM5QyxZQUFZLGdCQUFNO0FBQ2xCLDJCQUEyQixnQkFBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osd0JBQXdCLG9CQUFVO0FBQ2xDLG1EQUFtRDs7QUFFbkQsc0NBQXNDOztBQUV0QyxjQUFjLGlCQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxRQUFRO0FBQ1g7O0FBRUEsRUFBRSxtQkFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0JBQWdCO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixxQkFBVyxDQUFDLGtCQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBLFFBQVEsbUJBQW1CO0FBQzNCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUNBQXFDLGlCQUFPLE9BQU8sa0JBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMERBQTBEOztBQUUxRDtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVCwwQkFBMEIscUJBQVk7QUFDdEM7O0FBRUE7QUFDQTtBQUNBLFlBQVk7OztBQUdaO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0EsWUFBWSx5QkFBZ0I7QUFDNUI7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7QUFDTjtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLHFCQUFXO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxzR0FBc0c7QUFDdEc7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdEQUFnRCwwQkFBaUI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7OztBQUdBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQSx3QkFBd0IsY0FBYztBQUN0QyxXQUFXOztBQUVYLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWCw2QkFBNkIscUJBQVk7QUFDekM7QUFDQSwyRUFBMkUsZUFBZTtBQUMxRixZQUFZLGlCQUFpQjs7QUFFN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBLHVCQUF1Qix5QkFBZ0I7QUFDdkM7QUFDQSxRQUFRLHFCQUFxQjtBQUM3QjtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0EsYUFBYTtBQUNiLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLHNCQUFzQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGlCQUFpQjtBQUN2RSxnQkFBZ0I7QUFDaEIsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBLDhDQUE4QyxxQkFBWTtBQUMxRCxRQUFRLGlCQUFpQjtBQUN6QjtBQUNBO0FBQ0EsR0FBRyxzQ0FBc0M7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx1QkFBdUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLGdFQUFnRSxVQUFVLDBCQUEwQixXQUFXO0FBQy9HLGdCQUFnQixZQUFZO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSwwQkFBMEIsMEJBQWlCO0FBQzNDO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZUFBZSxTQUFTOztBQUV4QixlQUFlLGdDQUF3QixPQUFPLGtCQUFVLEdBQUc7QUFDM0Q7OztBQUdBLFNBQVMsV0FBYTtBQUN0QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCLHVCQUFlLENBQUMsdUJBQWUsQ0FBQyx1QkFBZTtBQUN0RTtBQUNBLE9BQU8sb0JBQW9CO0FBQzNCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7OztBQUdBLEVBQUUsbUJBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVYsb0JBQW9CLFNBQVMsd0JBQXdCO0FBQ3JEOzs7QUFHQSxzQkFBc0IsV0FBYTtBQUNuQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsRUFBRSxtQkFBUztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsMEJBQTBCO0FBQzFCLHFCQUFxQjtBQUNyQiw2QkFBNkI7QUFDN0IsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFLG1CQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBLEdBQUcsZUFBZSxtQkFBbUI7QUFDckM7QUFDQSxHQUFHLGVBQWUsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHLGVBQWUsbUJBQW1CO0FBQ3JDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBVztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWEscUJBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLFlBQVkscUJBQVc7QUFDdkI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNEQUFzRDtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxZQUFZLGlCQUFtQjtBQUMvQjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLGFBQWEscUJBQVc7QUFDeEI7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxjQUFjLGtCQUFrQixRQUFRO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLGNBQWM7QUFDN0I7O0FBRUEsd0JBQXdCLFlBQVk7QUFDcEMsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxzQkFBc0IsWUFBWTtBQUNsQyxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsWUFBWTs7QUFFakMsa0JBQWtCLFVBQVU7QUFDNUIsd0JBQXdCLGNBQVc7QUFDbkM7QUFDQSxTQUFTO0FBQ1Qsc0JBQXNCLGNBQVc7QUFDakM7QUFDQSxTQUFTOztBQUVULG9DQUFvQyxXQUFXO0FBQy9DLHVCQUF1QixZQUFZOztBQUVuQyxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0EsS0FBSztBQUNMLHNCQUFzQixxQkFBVztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wseUJBQXlCLHFCQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx3QkFBd0IscUJBQVc7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBLGNBQWMseUJBQWdCO0FBQzlCLFlBQVkscUJBQXFCO0FBQ2pDO0FBQ0E7O0FBRUEsdUJBQXVCLFlBQVk7QUFDbkMsd0JBQXdCLGVBQWU7QUFDdkM7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUEsZ0JBQWdCLFlBQVk7QUFDNUIsMEJBQTBCLFlBQVk7QUFDdEMsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLHFCQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcscUJBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQSxjQUFjLHlCQUFnQjtBQUM5QixZQUFZLHFCQUFxQjtBQUNqQyxZQUFZO0FBQ1osdUJBQXVCLFdBQVc7O0FBRWxDLGdCQUFnQixhQUFhO0FBQzdCLGNBQWMsb0JBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGdCQUFnQixxQkFBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLHFCQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhLGtCQUFrQixjQUFXO0FBQ2xFO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWjs7QUFFQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDLFVBQVUsaUJBQWlCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLHFCQUFXO0FBQ3ZCO0FBQ0EsZ0NBQWdDOztBQUVoQyw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQSxRQUFRLGlCQUFpQjs7QUFFekI7QUFDQSwrQkFBK0IscUJBQVksMEJBQTBCLGNBQVc7QUFDaEY7QUFDQTtBQUNBLFdBQVc7QUFDWCxZQUFZLG9CQUFpQjtBQUM3QjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxlQUFlLHFCQUFXO0FBQzFCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7O0FBR0E7QUFDQSxLQUFLO0FBQ0wsYUFBYSxxQkFBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUscUJBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFNBQVM7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLG9CQUFvQixtQkFBWSxDQUFDLFdBQVcsc0JBQXNCO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekI7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSwyQkFBMkIsMEJBQWlCO0FBQzVDLFlBQVksZUFBZTtBQUMzQjtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1osWUFBWSxtQkFBbUI7QUFDL0I7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQiwwQkFBaUI7QUFDNUMsWUFBWSxlQUFlO0FBQzNCO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWixZQUFZLG1CQUFtQjtBQUMvQjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLHlCQUFnQjtBQUMzQyxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBLGFBQWE7QUFDYjs7QUFFQSxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLHlCQUFnQjtBQUMzQyxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBLGFBQWE7QUFDYjs7QUFFQSxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE2Qix5QkFBZ0I7QUFDN0MsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkLGNBQWMscUJBQXFCO0FBQ25DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkIseUJBQWdCO0FBQzdDLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZCxjQUFjLG9CQUFvQjtBQUNsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCLHlCQUFnQjtBQUM3QyxjQUFjLHFCQUFxQjtBQUNuQztBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2QsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE2Qix5QkFBZ0I7QUFDN0MsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQSxlQUFlO0FBQ2YsY0FBYztBQUNkLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2QkFBNkIseUJBQWdCO0FBQzdDLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZCxjQUFjLHFCQUFxQjtBQUNuQztBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCLHlCQUFnQjtBQUM3QyxjQUFjLHFCQUFxQjtBQUNuQztBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2QsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0gsMEJBQWlCO0FBQ2pJLGdDQUFnQyxXQUFXOztBQUUzQyxrQkFBa0IsaUJBQW1CLGlCQUFpQixhQUFhLDBCQUEwQixlQUFlLHlCQUF5QixjQUFjO0FBQ25KO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYSxxQkFBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHLGdCQUFnQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQkFBbUIseUJBQXlCLG9EQUFvRCxtQkFBbUI7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMEJBQWlCO0FBQ2hFO0FBQ0E7QUFDQSxJQUFJLEVBQWM7QUFDbEI7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyx1QkFBYTtBQUMvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esd0NBQXdDLHVCQUFhLEdBQUc7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGdCQUFNO0FBQzdCLGlCQUFpQixnQkFBTTtBQUN2QjtBQUNBLEdBQUc7QUFDSCxpQkFBaUIscUJBQVc7QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSCx3QkFBd0IsaUJBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxpQkFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixhQUFhLGdDQUF3QixRQUFRLGlCQUFTOztBQUV0RCxtQkFBbUIsZ0JBQU07QUFDekIsOEJBQThCLGNBQWM7QUFDNUMsU0FBUyxlQUFlO0FBQ3hCLCtGQUErRixrQkFBa0I7QUFDakg7O0FBRUEsU0FBUyxlQUFlO0FBQ3hCLHVFQUF1RSxrQkFBa0I7QUFDekY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix3QkFBd0IscUJBQVc7QUFDbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUUsbUJBQVM7QUFDWDtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0EsR0FBRztBQUNILGtDQUFrQyxrQkFBUTtBQUMxQyxFQUFFLG1CQUFTO0FBQ1g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsbUJBQW1CO0FBQ3pDO0FBQ0EsR0FBRyxlQUFlLG1CQUFtQjtBQUNyQztBQUNBLEdBQUcsZUFBZSxtQkFBbUI7QUFDckM7QUFDQSxHQUFHLGVBQWUsbUJBQW1CO0FBQ3JDO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCOzs7QUFHQTtBQUNBLDRCQUE0QixZQUFZLFNBQVMsa0JBQVM7QUFDMUQsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLFlBQVk7QUFDNUMsV0FBVyxZQUFZO0FBQ3ZCOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCOztBQUVBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVMsWUFBWTtBQUNyQjs7QUFFQSxTQUFTLGdCQUFPLDJCQUEyQixnQ0FBZ0Msb0NBQW9DLG9EQUFvRCxzQkFBc0IsMENBQTBDLGlFQUFpRSxLQUFLLGtDQUFrQzs7QUFFM1UsU0FBUyxxQkFBYSxXQUFXLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSxnQkFBTyxnREFBZ0QsdUJBQWUsNkJBQTZCLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLGdCQUFPLDBDQUEwQyxtRkFBbUYsT0FBTztBQUN0Z0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxLQUFLO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QiwwQkFBaUI7QUFDeEMsNkJBQTZCLFlBQVk7QUFDekMsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTtBQUM3Qzs7QUFFQSxhQUFhLDBCQUFpQjtBQUM5QixVQUFVLG9CQUFpQjtBQUMzQjtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxlQUFlLGFBQWE7QUFDNUIsMkNBQTJDLHFCQUFhLENBQUMscUJBQWEsR0FBRyxvQkFBb0I7QUFDN0Y7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVcsQ0FBQyxXQUFXLFdBQVcsV0FBVztBQUN4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsb0JBQVc7QUFDbEMsb0JBQW9CLGNBQVc7QUFDL0I7QUFDQSxLQUFLO0FBQ0wsa0JBQWtCLGNBQVc7QUFDN0I7QUFDQSxLQUFLOztBQUVMLFFBQVEsMEJBQWlCO0FBQ3pCO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRztBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLDZEQUE2RDtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQjtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlDQUFnQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVtTztBQUNuTzs7Ozs7QUN6Z0tBLFNBQVMsV0FBQyxJQUFJLGtEQUFrRCxJQUFJLHdCQUF3QixHQUFHLEtBQW1DLENBQUMsYUFBd0csNkVBQTZFLGdCQUFnQixxRUFBcUUsU0FBUyxXQUFDLElBQUksZUFBZSxXQUFDLEVBQUUsU0FBUyxXQUFDLElBQUksTUFBTSx3QkFBd0IsbUNBQW1DLCtCQUErQixxQkFBcUIsaUVBQWlFLHFFQUFxRSxXQUFDLENBQUMsMkJBQTJCLFdBQUMsb0RBQW9ELFdBQUMsSUFBSSxXQUFDLEtBQUssV0FBQyxLQUFLLFNBQVMsV0FBQyxJQUFJLE9BQU8sV0FBQyxLQUFLLFdBQUMsU0FBUyxXQUFDLElBQUksU0FBUyxXQUFDLFFBQVEsdUJBQXVCLFdBQUMsbUJBQW1CLFlBQUUsMEJBQTBCLG1DQUFtQyw0QkFBNEIsZ0JBQWdCLEdBQUcsU0FBUyxXQUFDLElBQUksUUFBUSxXQUFDLEVBQUUsNENBQTRDLFdBQUMsTUFBTSxXQUFDLFFBQVEsU0FBUyxXQUFDLE1BQU0sV0FBVyxXQUFDLHVEQUF1RCxTQUFTLFdBQUMsTUFBTSxXQUFXLFdBQUMsa0JBQWtCLFNBQVMsV0FBQyxRQUFRLE1BQU0sV0FBQyxJQUFJLHVDQUF1QyxTQUFTLFdBQUMsTUFBTSx3Q0FBd0MsU0FBUyxXQUFDLElBQUksT0FBTyxXQUFDLG1CQUFtQixTQUFTLFdBQUMsSUFBSSxPQUFPLFdBQUMsbUJBQW1CLFNBQVMsV0FBQyxJQUFJLGdCQUFnQixTQUFTLFdBQUMsSUFBSSx5REFBeUQsTUFBTSxZQUFFLElBQUksU0FBUyxXQUFDLEVBQUUsVUFBVSxZQUFFLFFBQVEsV0FBVyxLQUFLLGtCQUFrQiwwRUFBMEUsK0RBQStELEVBQUUsaURBQWlELFNBQVMsV0FBQyxNQUFNLDBCQUEwQixXQUFDLEtBQUssV0FBQyxNQUFNLFdBQUMsTUFBTSxXQUFDLHFDQUFxQyxXQUFDLHNCQUFzQixXQUFDLGtCQUFrQixPQUFPLFdBQUMsT0FBTyxTQUFTLFNBQVMsV0FBQyxHQUFHLFdBQUMsSUFBSSxTQUFTLFdBQUMsSUFBSSx1REFBdUQsU0FBUyxXQUFDLElBQUksTUFBTSxZQUFFLElBQUksVUFBVSxXQUFDLFNBQVMsU0FBUyxXQUFDLE1BQU0sWUFBRSxNQUFNLFlBQUUsT0FBTyxTQUFTLFVBQUMsR0FBRyxNQUFNLEtBQXNDLEVBQUUsQ0FBSSxDQUFDLFdBQUMsQ0FBQyxTQUFTLFdBQUMsTUFBTSxJQUFJLFdBQUMsaUNBQWlDLFNBQVMsV0FBQyxJQUFJLFdBQUMsZ0JBQWdCLFdBQUMsV0FBVyxTQUFTLFdBQUMsSUFBSSxJQUFJLFdBQUMsR0FBRyxXQUFDLE1BQU0sU0FBUyxXQUFDLElBQUksT0FBTyxXQUFDLEVBQUUsT0FBTyxXQUFDLGVBQWUsU0FBUyxXQUFDLElBQUksUUFBUSxXQUFDLEVBQUUsOEJBQThCLFNBQVMsV0FBQyxNQUFNLGVBQWUsaUNBQWlDLGNBQWMsV0FBQyxzQkFBc0IsV0FBQyxNQUFNLFdBQUMsSUFBSSxXQUFDLEtBQUssV0FBQyxRQUFRLFdBQUMsV0FBVyxXQUFDLFlBQVksV0FBQyxnQkFBZ0IsV0FBQyxrQkFBa0IsV0FBQyxTQUFTLFdBQUMsMEJBQTBCLFdBQUMsVUFBVSxTQUFTLFdBQUMsUUFBUSxHQUFHLFdBQUMsYUFBYSxRQUFRLFdBQUMsRUFBRSxhQUFhLFdBQUMsa0JBQWtCLE9BQU8sV0FBQyxjQUFjLFFBQVEsb0JBQW9CLGVBQWUsV0FBQyxlQUFlLFNBQVMsZUFBZSwyQkFBMkIsV0FBQyxtQkFBbUIsdUNBQXVDLFdBQUMsa0JBQWtCLE9BQU8sV0FBQyxnQkFBZ0IsR0FBRyxXQUFDLGlCQUFpQixXQUFDLDJCQUEyQixXQUFXLFNBQVMsV0FBQyxnQkFBZ0IsR0FBRyxNQUEwQyxFQUFFLENBQUksQ0FBQyxXQUFDLEtBQUssTUFBTSxXQUFDLHFCQUFxQixXQUFDLDRCQUE0QixHQUFHLFdBQUMsU0FBUyxXQUFDLFdBQVcsT0FBTyxpQkFBaUIsR0FBRyxXQUFDLE1BQU0sV0FBQyxLQUFLLHdCQUF3QixXQUFDLGdCQUFnQixXQUFDLE9BQU8sU0FBUyxXQUFDLFFBQVEscUNBQXFDLFdBQUMsTUFBTSxTQUFTLFdBQUMsTUFBTSxRQUFRLFdBQUMsRUFBRSxTQUFTLFdBQUMsVUFBVSxTQUFTLFdBQUMsTUFBTSw2Q0FBNkMsRUFBRSxFQUFFLDJDQUEyQyxjQUFjLDRCQUE0QixTQUFTLFdBQUMsSUFBSSxrQkFBa0IsV0FBQyxPQUFPLFNBQVMsV0FBQyxJQUFJLFVBQVUsV0FBQyxPQUFPLFNBQVMsV0FBQyxRQUFRLE1BQU0sV0FBQyxJQUFJLFdBQUMsa0JBQWtCLFdBQUMsSUFBSSxXQUFDLG9DQUFvQywwQkFBMEIsZ0JBQWdCLFVBQUMsaUJBQWlCLG1DQUFtQyxPQUFPLFlBQUUsQ0FBQyxZQUFZLFlBQUUsRUFBRSxnREFBZ0QscUJBQXFCLE1BQU0sV0FBQyxlQUFlLGFBQWEsVUFBQyxnQkFBZ0IsU0FBUyxXQUFDLElBQUksT0FBTyxXQUFDLEtBQUssV0FBQyxxQkFBcUIsSUFBSSxXQUFDLGFBQWEsVUFBVSxXQUFDLElBQUksV0FBQyxJQUFJLE1BQU0sa0JBQWtCLFdBQUMseUJBQXlCLFNBQVMsV0FBQyxhQUFhLE9BQU8sV0FBQyxNQUFNLE9BQU8sV0FBQyxrQkFBa0IsR0FBRyxXQUFDLGFBQWEsV0FBQyxXQUFXLHNCQUFzQixJQUFJLFNBQVMsV0FBQyxNQUFNLFVBQVUseUJBQXlCLDRCQUE0QixPQUFPLFdBQUMsSUFBSSxTQUFTLFdBQUMsR0FBRyxnQkFBZ0IsV0FBVyxnQ0FBZ0MsNENBQTRDLFdBQVcsV0FBQyxFQUFFLE1BQU0sTUFBbUMsRUFBRSxDQUFJLENBQUMsWUFBRSxVQUFVLGlCQUFpQixXQUFXLFdBQUMsRUFBRSxNQUFtQyxFQUFFLENBQUksQ0FBQyxZQUFFLGFBQWEsR0FBRyxjQUFjLHFCQUFxQixLQUFLLEtBQUssV0FBVyxXQUFDLEVBQUUsb0JBQW9CLGFBQWEsV0FBQyxJQUFJLE1BQU0sYUFBYSxXQUFDLE1BQU0sY0FBYyxzQkFBc0IsWUFBRSxpQkFBaUIsS0FBSyxLQUFLLFdBQVcsT0FBTyxXQUFDLEVBQUUsV0FBVyxnQkFBZ0IsV0FBQyxlQUFlLGtCQUFrQixXQUFDLEVBQUUsY0FBYyxXQUFDLGdCQUFnQixVQUFVLFdBQUMsRUFBRSxrQkFBa0IsWUFBRSxtQkFBbUIsY0FBYyxVQUFVLGtDQUFrQyxvREFBb0Qsc0JBQXNCLFlBQVksV0FBVyxxQ0FBcUMsU0FBUyxjQUFjLEtBQUssV0FBQyxrQkFBa0IsV0FBQyxNQUFNLFNBQVMsV0FBQyxRQUFRLGdCQUFnQix1Q0FBdUMsTUFBTSw4QkFBOEIsV0FBVywwQ0FBMEMsU0FBUyxNQUFNLFlBQUUsSUFBSSxTQUFTLFdBQUMsRUFBRSxVQUFVLFlBQUUsUUFBUSxXQUFXLEtBQUssV0FBVywrQkFBK0IsaURBQWlELFNBQVMsZ0JBQWdCLFVBQUMsaUJBQWlCLCtCQUErQiwrQkFBK0IsV0FBQyxFQUFFLG9CQUFvQixJQUFJLG1CQUFtQixFQUFFLFdBQUMsT0FBTyxXQUFDLG9DQUFvQywwQkFBMEIsUUFBUSxXQUFDLEVBQUUsTUFBTSw0QkFBNEIsU0FBUyxXQUFDLGdCQUFnQixJQUFJLFdBQUMsa0JBQWtCLFdBQUMsNkJBQTZCLFdBQUMsTUFBTSxHQUFHLFdBQUMsZ0JBQWdCLGVBQWUsV0FBQyxnQkFBZ0IsV0FBQyxLQUFLLEdBQUcsZUFBZSxVQUFVLFdBQUMsc0RBQXNELFdBQVcsWUFBWSx3QkFBd0IsV0FBVyxZQUFZLDBDQUEwQyxJQUFJLDZEQUE2RCxpQkFBaUIsZUFBZSwwQkFBMEIsRUFBRSxTQUFTLFdBQUMsR0FBRyxjQUFjLElBQUksV0FBQyxhQUFhLG9DQUFvQyxHQUFHLFdBQUMsNERBQTRELHFCQUFxQixJQUFJLEdBQUcsV0FBQyx5Q0FBeUMsOENBQThDLDRCQUE0QixPQUFPLFdBQUMsR0FBRyxXQUFDLE1BQU0sV0FBQyxJQUFJLFdBQUMsS0FBSyxjQUFjLE9BQU8sV0FBQyxXQUFXLFlBQVksV0FBQyxZQUFZLGdCQUFnQiw4QkFBOEIsZ0NBQWdDLGFBQWEsS0FBSyxNQUFNLFdBQUMsY0FBYyxrREFBa0QsV0FBQyw0Q0FBNEMsV0FBQyx3QkFBd0IsV0FBQyxRQUFRLFdBQUMsaUJBQWlCLE1BQU0sV0FBQyxpQ0FBaUMsVUFBVSx3QkFBd0IseUJBQXlCLE9BQU8sV0FBQyxLQUFLLHNCQUFzQixpQkFBaUIsK0NBQStDLHlCQUF5Qix1QkFBdUIsc0JBQXNCLHVCQUF1Qiw0QkFBNEIsMEJBQTBCLGdDQUFnQywyQkFBMkIsUUFBUSxXQUFDLFFBQVEsS0FBSyxxQkFBcUIsWUFBWSw4Q0FBOEMsZ0JBQWdCLFdBQUMsb0JBQW9CLE1BQU0sV0FBQyxRQUFRLFdBQUMsVUFBVSxXQUFDLDJCQUEyQix5QkFBeUIsa0JBQWtCLHFCQUFxQixZQUFZLEVBQUUsb0JBQW9CLGdCQUFnQixtQkFBbUIsZUFBZSx1QkFBdUIsRUFBRSwrQkFBK0IsR0FBRyxHQUFHLFVBQVUsdUNBQXVDLHNCQUFzQixzQkFBc0IsWUFBWSxjQUFjLFlBQVksY0FBYyxZQUFZLFdBQVcsMEJBQTBCLG9CQUFvQixRQUFRLGtDQUFrQyxVQUFVLGtDQUFrQyxFQUFFLG1CQUFtQixXQUFXLEtBQUssb0JBQW9CLFFBQVEsMEJBQTBCLEVBQUUsMkJBQTJCLHNEQUFzRCxFQUFFLFVBQVUsZ0NBQWdDLG9CQUFvQix1QkFBdUIsY0FBYyxvQkFBb0IsUUFBUSwyQkFBMkIsYUFBYSxvQkFBb0IsRUFBRSxJQUFJLDhCQUE4QixjQUFjLG9CQUFvQixRQUFRLG9CQUFvQixhQUFhLDJCQUEyQixFQUFFLElBQUksR0FBRyxXQUFXLHFCQUFxQixRQUFRLCtCQUErQixXQUFDLFVBQVUsVUFBVSw2QkFBNkIsR0FBRyxFQUFFLFNBQVMsV0FBQyxHQUFHLGdCQUFnQixhQUFhLG1CQUFtQixtREFBbUQsY0FBYyxvQ0FBb0MsY0FBYywyQ0FBMkMsR0FBRyxXQUFDLEtBQUssTUFBTSxXQUFDLFlBQVksd0JBQXdCLGdCQUFnQixJQUFJLGNBQWMsS0FBSyxXQUFDLGtCQUFrQixXQUFDLE1BQU0sb0JBQW9CLGlDQUFpQyxhQUFhLGdDQUFnQyxjQUFjLGdCQUFnQixnREFBZ0QsT0FBTyxjQUFjLGdCQUFnQixZQUFZLFdBQUMsR0FBRyxnQkFBZ0IsVUFBQyxvREFBb0QsTUFBTSxTQUFTLGtCQUFrQix1Q0FBdUMsZUFBZSxPQUFPLFdBQUMsTUFBTSxXQUFDLFNBQVMsb0JBQW9CLE9BQU8sV0FBQyxNQUFNLFdBQUMsVUFBVSxxQkFBcUIsV0FBVyxXQUFDLEVBQUUsWUFBWSxXQUFDLFlBQVksV0FBQyxzQkFBc0IsV0FBQyxtREFBbUQsc0JBQXNCLHlCQUF5QixXQUFXLFdBQUMsRUFBRSxpQkFBaUIsV0FBQyw0REFBNEQsb0JBQW9CLFdBQVcsV0FBQyxFQUFFLEtBQUssV0FBQyxnQkFBZ0IsV0FBQyxnQkFBZ0IsV0FBQyxrQkFBa0IsY0FBYyxnQkFBZ0IseUJBQXlCLFdBQVcsV0FBQyxNQUFNLFdBQUMsMEJBQTBCLHVCQUF1QixHQUFHLG1CQUFtQixXQUFXLFdBQUMsRUFBRSxLQUFLLE1BQU0sV0FBQyxXQUFXLFNBQVMsV0FBQyxhQUFhLDJCQUEyQixNQUFNLFdBQUMsWUFBWSwyQkFBMkIsbUJBQW1CLE9BQU8sV0FBQyxNQUFNLFdBQUMsVUFBVSxxQkFBcUIsMkJBQTJCLFdBQVcsRUFBRSxXQUFDLGFBQWEsa0JBQWtCLG1CQUFtQixlQUFlLGlCQUFpQiw4QkFBOEIsR0FBRyxzQkFBc0IsMkJBQTJCLFdBQVcsRUFBRSxXQUFDLGFBQWEsbUJBQW1CLG1CQUFtQixlQUFlLG1CQUFtQixxQkFBcUIsT0FBTywyQkFBMkIsR0FBRyxHQUFHLFdBQUMsYUFBYSxzQkFBc0IsR0FBRyxnQkFBZ0IsZ0JBQWdCLFlBQVksV0FBQyxHQUFHLGdCQUFnQixVQUFDLHFEQUFxRCxNQUFNLFNBQVMsa0JBQWtCLHVDQUF1QyxlQUFlLE9BQU8sV0FBQyxNQUFNLFdBQUMsU0FBUyxvQkFBb0IsV0FBVyxXQUFDLEVBQUUsOEVBQThFLG1CQUFtQixXQUFXLFdBQUMsRUFBRSwrQkFBK0IsV0FBQyxxQkFBcUIsc0JBQXNCLHlCQUF5QixXQUFXLFdBQUMsRUFBRSxpQkFBaUIsV0FBQyx3REFBd0Qsb0JBQW9CLFdBQVcsV0FBQyxFQUFFLEtBQUssV0FBQyxnQkFBZ0IsV0FBQyxpQkFBaUIscUJBQXFCLFdBQVcsV0FBQyxFQUFFLDhCQUE4QixzQkFBc0IsV0FBVyxXQUFDLEVBQUUsK0JBQStCLG1CQUFtQixxQkFBcUIsR0FBRyxXQUFDLGFBQWEscUJBQXFCLHlCQUF5QixtQ0FBbUMsUUFBUSwyQ0FBMkMsR0FBRyxHQUFHLFdBQUMsV0FBVyxnQkFBZ0Isa0JBQWtCLGlCQUFpQixtQkFBbUIsRUFBRSxTQUFTLFdBQUMsR0FBRyxXQUFDLEdBQUcsV0FBQyxHQUFHLFdBQUMsR0FBRyxTQUFTLFdBQUMsSUFBSSxTQUFTLFNBQVMsV0FBQyxJQUFJLFNBQVMsSUFBSSxXQUFDLENBQUMsV0FBQyxDQUFDLFdBQUMsMERBQTBELFdBQUMseUJBQXlCLFdBQUMseUJBQXlCLFdBQUMsa0ZBQWtGLFdBQUMsQ0FBQyxXQUFDLCtCQUErQixXQUFDLEdBQUcsc0JBQXNCLFdBQUMsRUFBRSxXQUFDLENBQUMsV0FBQyxvREFBb0QsV0FBQyxDQUFDLFdBQUMsNENBQTRDLFdBQUMsMkRBQTJELFdBQUMsRUFBRSwySUFBMkksK0hBQStILDJ2QkFBMnZCLHFEQUFxRCx5REFBeUQsd0NBQXdDLGdCQUFnQix5SkFBeUosK0ZBQStGLGtLQUFrSyxnQkFBZ0IsMkNBQTJDLGdCQUFnQiw0Q0FBNEMsNEZBQTRGLENBQUMsV0FBQyxpQ0FBaUMsWUFBRSxnSEFBZ0gsNkVBQTZFLDRCQUE0QixZQUFFLCtDQUErQyxTQUFTLE9BQU8sWUFBRSx5QkFBeUIsMENBQTBDLEtBQUssQ0FBQyxZQUFFLEdBQUcsQ0FBQyxZQUFFLEVBQUUsa0JBQWtCLE9BQU8sV0FBQyxVQUFVLE1BQU0sV0FBQyxJQUFJLElBQUksV0FBQyw2QkFBNkIsUUFBUSxXQUFDLE1BQU0sb0ZBQW9GLFFBQVEsV0FBVyxhQUFhLFdBQUMsVUFBVSxXQUFDLFNBQVMsV0FBQyxXQUFXLFdBQUMsZUFBZSxtQkFBbUIsWUFBWSxXQUFDLElBQUkscUJBQXFCLHVCQUF1QixXQUFDLEtBQUsscUJBQXFCLE1BQU0sV0FBQyxDQUFDLFdBQUMsT0FBTyxvREFBb0QsU0FBUyxNQUFNLFdBQUMsQ0FBQyxXQUFDLDBCQUEwQixXQUFDLEVBQUUsMkNBQTJDLEdBQUcsV0FBQyxvQkFBb0IsV0FBQyxrQkFBa0IsV0FBQyxJQUFJLFdBQUMsSUFBSSwwR0FBMEcsOEJBQThCLGdCQUFnQixXQUFDLDZCQUE2QixXQUFDLElBQUksV0FBQyx5Q0FBeUMsd0NBQXdDLE1BQU0sV0FBQyw0Q0FBNEMsVUFBVSxrRkFBa0YsR0FBRywyQkFBMkIsV0FBQyxLQUFLLDRCQUE0QixrQ0FBa0MsMkJBQTJCLFdBQUMsTUFBTSxDQUFDLFlBQUUsSUFBSSxXQUFDLENBQUMsWUFBRSxnQkFBZ0IsWUFBRSxlQUFlLDZEQUE2RCxHQUFHLFlBQUUsOEJBQThCLE1BQU0sTUFBdUQsRUFBRSxDQUFLLENBQUMsWUFBRSwyQkFBMkIsQ0FBQyxZQUFFLHFCQUFxQixNQUFNLE1BQXFFLEVBQUUsQ0FBSyxDQUFDLFlBQUUsK0JBQStCLElBQUksWUFBRSxZQUFZLGNBQWMsV0FBVyxPQUFPLFdBQUMsd0NBQXdDLCtDQUErQyxRQUFRLElBQUksUUFBUSxtQkFBbUIsV0FBVyxrQkFBa0Isa0RBQWtELElBQUksd0JBQXdCLGdDQUFnQyxNQUFNLDBDQUEwQyxJQUFJLE1BQU0seUJBQXlCLFdBQUMsc0NBQXNDLFdBQUMsSUFBSSxXQUFDLEtBQUssTUFBTSxXQUFDLE1BQU0sV0FBQyxrQkFBa0IsSUFBSSxZQUFZLFFBQVEsRUFBRSxXQUFDLElBQUksV0FBQyxJQUFJLDRFQUE0RSxPQUFPLFdBQUMsTUFBTSxXQUFDLE1BQU0sZUFBZSxNQUFNLFdBQUMsTUFBTSxJQUFJLFdBQUMsTUFBTSxXQUFDLE9BQU8sMkJBQTJCLGdDQUFnQyxXQUFDLGtCQUFrQixXQUFDLFVBQVUsY0FBYyxXQUFDLDhCQUE4QixTQUFTLFdBQUMsT0FBTyx1Q0FBdUMsMkNBQTJDLGtEQUFrRCxJQUFJLHdCQUF3QiwyQ0FBMkMscUNBQXFDLElBQUksdUNBQXVDLFFBQVEsR0FBRyw0RUFBNEUsY0FBYyxXQUFXLG1LQUFtSyxrQkFBa0IsaUNBQWlDLFdBQUMsS0FBSyxXQUFDLElBQUksV0FBQyxRQUFRLFdBQUMsS0FBSyxNQUFNLFdBQUMsU0FBUyxXQUFDLGdCQUFnQixTQUFTLFdBQUMsT0FBTyxXQUFDLE1BQU0sNkJBQTZCLFdBQVcsV0FBQyxFQUFFLE1BQW1DLEdBQUcsQ0FBdUIsRUFBRSxVQUFVLE9BQU8sV0FBQyxNQUFNLFdBQUMsV0FBVyw2QkFBNkIsU0FBUyw2QkFBNkIsSUFBSSxXQUFDLEVBQUUsV0FBQyxjQUFjLDhCQUE4QixNQUFNLGlCQUFpQixLQUFLLEtBQUssV0FBVyx3Q0FBd0MsVUFBVSxPQUFPLHVCQUF1QixNQUFNLFdBQUMsY0FBYyxPQUFPLFdBQUMsdUNBQXVDLGNBQWMsR0FBRyxHQUFHLEdBQUcsWUFBRSxLQUFLLFlBQUUsQ0FBQyxZQUFFLENBQUMsWUFBRSxTQUFTLFlBQUUsQ0FBQyxZQUFFLHlCQUF5QixZQUFFLEVBQUUsWUFBRSxDQUFDLFlBQUUsb0JBQW9CLFlBQUUsRUFBRSxZQUFFLENBQUMsWUFBRSxvQkFBb0IsWUFBRSxFQUFFLFlBQUUsQ0FBQyxZQUFFLG1CQUFtQixZQUFFLEVBQUUsWUFBRSxDQUFDLFlBQUUsa0JBQWtCLFlBQUUsRUFBRSxZQUFFLENBQUMsWUFBRSxrQkFBa0IsWUFBRSxFQUFFLG1EQUFlLFlBQUUsRUFBd1c7QUFDbjZqQjs7O0FDRU8sR0FBTUUsV0FBVSxtRkFDckIsb0JBQW1CQyxZQUFvQixDQUFFLE9BQ3ZDLGtCQUFNLElBQUksQ0FBRUEsWUFBWSxDQUFDLE9BQzNCLENBQUMsdUNBRU1GLE9BQU8sQ0FBZCxpQkFBZUcsTUFBb0MsQ0FBRSxDQUNuRCxJQUFJLENBQUNDLFFBQVEsQ0FDWEosY0FBTyxDQUFDLElBQUksQ0FBQ0ssUUFBUSxFQUFFLENBQUUsU0FBQUMsS0FBSyxDQUFJLENBQ2hDSCxNQUFNLENBQUNHLEtBQUssQ0FBQyxDQUFDO0FBQ2hCLENBQUMsQ0FBQyxDQUNILENBQ0gsQ0FBQyxxQkFYb0NQLHdCQUFLLEU7O0FDRHJDLEdBQU1RLGlCQUFnQixDQUFHLFFBQW5CQSxpQkFBZ0IsQ0FBV0wsWUFBb0IsUUFDMUQsSUFBSUQsQ0FBQUEsVUFBVSxDQUFRQyxZQUFZLENBQUMsRzs7Ozs7O0FDT3JDLEdBQU1RLFVBQVMsQ0FBRyxrQkFBa0IsQ0FFcEMsR0FBTUMsWUFBVyxDQUFHLFFBQWRBLFlBQVcsQ0FDZkMsUUFBNkIsQ0FDN0JDLEtBQW1CLFFBRW5CQSxNQUFLLENBQUNDLFNBQVMsQ0FBQyxDQUNkQyxPQUFPLENBQUUsc0JBQW9DLElBQWpDQyxPQUFNLE1BQU5BLE1BQU0sQ0FBRUMsUUFBUSxNQUFSQSxRQUFRLENBQUVDLFFBQVEsTUFBUkEsUUFBUSxDQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQ0VELFFBQVEsR0FBS0MsUUFBUSxFQUNyQk4sUUFBUSxDQUFDTyxTQUFTLENBQUNDLGdCQUFnQixDQUFDQyxZQUFZLENBQUNULFFBQVEsQ0FBQ1UsT0FBTyxDQUFDLEVBQ2xFLENBQUFOLE1BQU0sY0FBTkEsTUFBTSxDQUFFTyxJQUFJLElBQUtkLDRDQUFvQixDQUNyQyxDQUNBLE9BQ0YsQ0FFQUcsUUFBUSxDQUFDYSxtQkFBbUIsQ0FDMUIsQ0FDRVIsUUFBUSxDQUFSQSxRQUFRLENBQ1JDLFFBQVEsQ0FBUkEsUUFBUSxDQUNSUixTQUFTLENBQVRBLFNBQVMsQ0FDVGdCLE9BQU8sQ0FBRSxDQUNQLENBQ0VWLE1BQU0sQ0FBTkEsTUFBTSxDQUNOQyxRQUFRLENBQVJBLFFBQVEsQ0FDUkMsUUFBUSxDQUFSQSxRQUFRLENBQ1JSLFNBQVMsQ0FBRSxVQUFVLENBQ3JCaUIsVUFBVSxDQUFFLE9BQU8sQ0FDbkJDLElBQUksQ0FBRSxlQUNSLENBQUMsQ0FDRixDQUNERCxVQUFVLENBQUUsVUFBVSxDQUN0QkMsSUFBSSxDQUFFLGVBQ1IsQ0FBQyxDQUNELEtBQUssQ0FDTixDQUVEO0FBQ0FoQixRQUFRLENBQUNPLFNBQVMsQ0FBQ1UsVUFBVSxDQUFDQyxLQUFLLEVBQUUsQ0FDdkMsQ0FDRixDQUFDLENBQUMsR0FFRyxHQUFNQyxpQkFHWixDQUFHdkIsd0NBQWMsQ0FDaEJFLFNBQVMsQ0FDVCxTQUNFRSxRQUE2QixDQUM3Qm9CLEtBQWEsQ0FDYkMsTUFBMEIsQ0FDdkIsdUJBQ0gsR0FBTW5CLFVBQVMsb0JBQUdtQixNQUFNLGNBQU5BLE1BQU0sQ0FBRW5CLFNBQVMsMEJBQUksSUFBSSxDQUMzQyxHQUFNb0IsVUFBUyxDQUFHdEIsUUFBUSxDQUFDTyxTQUFTLENBQUNnQixpQkFBaUIsQ0FBQ3ZCLFFBQVEsQ0FBQyxDQUNoRSxHQUFNQyxNQUFLLENBQUdOLGdCQUFnQixDQUFRMkIsU0FBUyxPQUFUQSxTQUFTLENBQUlGLEtBQUssQ0FBQyxDQUV6RCxHQUFNSSxhQUFZLENBQUd0QixTQUFTLEVBQUlILFdBQVcsQ0FBQ0MsUUFBUSxDQUFFQyxLQUFLLENBQUMsQ0FFOUQsTUFBTyxDQUNMd0IsT0FBTyxDQUFFRCxZQUFZLENBQUcsaUJBQU1BLGFBQVksQ0FBQ0UsV0FBVyxFQUFFLEdBQUdDLFNBQVMsQ0FDcEVDLE1BQU0sQ0FBRTNCLEtBQUssQ0FDYmUsSUFBSSxDQUFFLG9CQUNSLENBQUMsQ0FDSCxDQUFDLENBQ0QsU0FDRWEsY0FJQyxDQUNEN0IsUUFBNkIsQ0FDN0JvQixLQUFhLENBQ2JDLE1BQTBCLENBQ3ZCLHdCQUNILEdBQU1uQixVQUFTLHFCQUFHbUIsTUFBTSxjQUFOQSxNQUFNLENBQUVuQixTQUFTLDJCQUFJLElBQUksQ0FDM0MsR0FBTTRCLGNBQWEsQ0FBRyxDQUFDLENBQUNELGNBQWMsQ0FBQ0osT0FBTyxDQUU5QyxHQUFJSyxhQUFhLEdBQUs1QixTQUFTLENBQUUsTUFBTzJCLGVBQWMsQ0FFdEQ7QUFDQSxHQUFJLENBQUMzQixTQUFTLENBQUUsQ0FDZDJCLGNBQWMsQ0FBQ0osT0FBTyxjQUF0QkksY0FBYyxDQUFDSixPQUFPLEVBQUksQ0FDMUJJLGNBQWMsQ0FBQ0osT0FBTyxDQUFHRSxTQUFTLENBQ2xDLE1BQU9FLGVBQWMsQ0FDdkIsQ0FFQTtBQUNBLEdBQU1MLGFBQVksQ0FBR3pCLFdBQVcsQ0FBQ0MsUUFBUSxDQUFFNkIsY0FBYyxDQUFDRCxNQUFNLENBQUMsQ0FDakVDLGNBQWMsQ0FBQ0osT0FBTyxDQUFHLGlCQUFNRCxhQUFZLENBQUNFLFdBQVcsRUFBRSxHQUV6RCxNQUFPRyxlQUFjLENBQ3ZCLENBQUMsQ0FDRixDOzs7Ozs7QUV4R0Q7QUFDQTtBQUNBO0FBQ0EsRUFDTyxHQUFNRSxrQkFBaUIsQ0FBRyxRQUFwQkEsa0JBQWlCLENBQUlDLFNBQW9CLENBQUVDLE1BQWMsQ0FBSyxDQUN6RTtBQUNBLEdBQUksTUFBT0QsVUFBUyxHQUFLLFFBQVEsQ0FBRSxNQUFPQSxVQUFTLENBRW5ELEdBQ0VFLEtBQUcsR0FDRixNQUFPRixVQUFTLEdBQUssVUFBVSxFQUFJLE1BQU9BLFVBQVMsQ0FBQ2hCLElBQUksR0FBSyxRQUFRLENBQUMsQ0FDdkUsQ0FDQSxHQUFNQSxLQUFJLENBQ1IsTUFBT2dCLFVBQVMsR0FBSyxVQUFVLDhDQUNnQixNQUFPQSxVQUFTLENBQUNoQixJQUFJLENBQ2hFLE1BQU9nQixVQUFTLENBRXRCLEtBQU0sSUFBSUcsVUFBUyxXQUNQRixNQUFNLDBGQUF1RmpCLElBQUksQ0FDNUcsQ0FDSCxDQUVBLE1BQU9nQixVQUFTLENBQUNoQixJQUFJLENBQ3ZCLENBQUMsQ0FFRDtBQUNBO0FBQ0E7QUFDQSxFQUNPLEdBQU1vQixtQkFBa0IsQ0FBRyxRQUFyQkEsbUJBQWtCLENBQUlDLFVBQXVCLENBQUVKLE1BQWMsUUFDeEVJLFdBQVUsQ0FBQ0MsR0FBRyxDQUFDLFNBQUFOLFNBQVMsUUFBSUQsa0JBQWlCLENBQUNDLFNBQVMsQ0FBRUMsTUFBTSxDQUFDLEdBQUMsRzs7QUN6Qm5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUNPLEdBQU1NLGNBQWEsQ0FBRyxRQUFoQkEsY0FBYSxDQUFpQmpELFlBQW9CLENBQUssQ0FDbEUsR0FBTWtELG9CQUF1QyxDQUFHLENBQUMsQ0FBQyxDQUVsRCxHQUFNQyxRQUFPLENBQUksUUFBWEEsUUFBTyxDQUFLckIsS0FBWSxDQUEwQmhCLE1BQWMsQ0FBSyxJQUF6RGdCLEtBQVksV0FBWkEsS0FBWSxDQUFHOUIsWUFBWSxFQUMzQyxHQUFNb0QsU0FBUSxDQUFHRixtQkFBbUIsQ0FBQ3BDLE1BQU0sQ0FBQ1ksSUFBSSxDQUFDLEVBQUksRUFBRSxDQUV2RCxNQUFPMkIsWUFBVyxDQUFDRCxRQUFRLENBQUV0QixLQUFLLENBQUVoQixNQUFNLENBQUMsQ0FDN0MsQ0FBMkIsQ0FFM0JxQyxPQUFPLENBQUNHLE1BQU0sQ0FBRyxTQUNmWixTQUFnRSxDQUNoRWEsVUFBa0QsQ0FDL0MsQ0FDSCxHQUFNWixPQUFNLENBQUcseUJBQXlCLENBQ3hDLEdBQU1hLFlBQVcsQ0FBR0MsS0FBSyxDQUFDQyxPQUFPLENBQUNoQixTQUFTLENBQUMsQ0FDeENJLGtCQUFrQixDQUFDSixTQUFTLENBQUVDLE1BQU0sQ0FBQyxDQUNyQyxDQUFDRixpQkFBaUIsQ0FBQ0MsU0FBUyxDQUFFQyxNQUFNLENBQUMsQ0FBQyxDQUUxQ2dCLHVCQUF1QixDQUFDVCxtQkFBbUIsQ0FBRU0sV0FBVyxDQUFFRCxVQUFVLENBQUMsQ0FFckUsTUFBT0osUUFBTyxDQUNoQixDQUFDLENBRUQsTUFBT0EsUUFBTyxDQUNoQixDQUFDLENBRUQsUUFBU1Esd0JBQXVCLENBQzlCWCxHQUF1QixDQUN2QlEsV0FBcUIsQ0FDckJJLFFBQW9CLENBQ3BCLENBQ0FKLFdBQVcsQ0FBQ0ssT0FBTyxDQUFDLFNBQUFDLFVBQVUsQ0FBSSxDQUNoQyxHQUFJLENBQUNkLEdBQUcsQ0FBQ2MsVUFBVSxDQUFDLENBQUUsQ0FDcEJkLEdBQUcsQ0FBQ2MsVUFBVSxDQUFDLENBQUcsRUFBRSxDQUN0QixDQUVBZCxHQUFHLENBQUNjLFVBQVUsQ0FBQyxDQUFDQyxJQUFJLENBQUNILFFBQVEsQ0FBQyxDQUNoQyxDQUFDLENBQUMsQ0FDSixDQUVBLFFBQVNQLFlBQVcsQ0FDbEJELFFBQXNCLENBQ3RCdEIsS0FBWSxDQUNaaEIsTUFBYyxDQUNkLENBQ0EsTUFBT3NDLFNBQVEsQ0FBQ0UsTUFBTSxDQUNwQixTQUFDVSxnQkFBZ0IsQ0FBRWIsT0FBTyxRQUN4QkEsUUFBTyxDQUFDYSxnQkFBZ0IsQ0FBRWxELE1BQU0sQ0FBQ21ELE9BQU8sQ0FBRW5ELE1BQU0sQ0FBQyxHQUNuRGdCLEtBQUssQ0FDTixDQUNILEM7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FDTyxHQUFNb0MsYUFBWSxxRkFLdkIsc0JBQ0VsRSxZQUF3QixDQUNSbUUsTUFNZixDQUNEQyxjQUF3QixDQUNQQyxLQUdMLENBQ1osV0FDQSx1QkFBTSxJQUFJLENBQUUsQ0FDVkMsT0FBTyxDQUFFRixjQUF5QixDQUNsQ0csS0FBSyxDQUFFdkUsWUFDVCxDQUFDLENBQUMsYUFHR3dFLFVBQVUsQ0FBRyxpQkFBTSxPQUFLckUsUUFBUSxFQUFFLENBQUNtRSxPQUFPLFNBRTFDRyxRQUFRLENBQUcsaUJBQU0sT0FBS3RFLFFBQVEsRUFBRSxDQUFDb0UsS0FBSyxTQUV0Q0csRUFBRSxDQUFHLFNBQUNDLFNBQXFCLFFBQUssT0FBS3hFLFFBQVEsRUFBRSxDQUFDb0UsS0FBSyxHQUFLSSxTQUFTLFNBRW5FQyxJQUFJLENBQUcsU0FBQ0MsU0FBcUIsQ0FBRXhELElBQVUsUUFDOUMsT0FBS25CLFFBQVEsQ0FBQyxTQUFBNEUsWUFBWSxDQUFJLENBQzVCLEdBQU1DLFVBQVMsQ0FBRyxNQUFLWixNQUFNLENBQUNXLFlBQVksQ0FBQ1AsS0FBSyxDQUFDLENBQUNNLFNBQVMsQ0FBQyxDQUU1RCxHQUNFLENBQUNFLFNBQVMsRUFDVEEsU0FBUyxRQUFUQSxTQUFTLENBQUVWLEtBQUssRUFBSSxDQUFDVSxTQUFTLENBQUNWLEtBQUssQ0FBQ1MsWUFBWSxDQUFDUixPQUFPLENBQUUsRUFDM0QsTUFBS0QsS0FBSyxFQUFJLENBQUMsTUFBS0EsS0FBSyxDQUFDUyxZQUFZLENBQUVDLFNBQVMsQ0FBQ0MsSUFBSSxDQUFFLENBQ3pELENBQ0EsTUFBT0YsYUFBWSxDQUNyQixDQUVBLE1BQU8sQ0FBRVIsT0FBTyxDQUFFUSxZQUFZLENBQUNSLE9BQU8sQ0FBRUMsS0FBSyxDQUFFUSxTQUFTLENBQUNDLElBQUssQ0FBQyxDQUNqRSxDQUFDLENBQUUzRCxJQUFJLENBQUMsU0FFSDRELFVBQVUsQ0FBRyxTQUFDWCxPQUEwQixDQUFFakQsSUFBVSxRQUN6RCxPQUFLbkIsUUFBUSxDQUNYLFNBQUE0QixLQUFLLFFBQUssQ0FDUndDLE9BQU8sQ0FDTCxNQUFPQSxRQUFPLEdBQUssVUFBVSxDQUFHQSxPQUFPLENBQUN4QyxLQUFLLENBQUN3QyxPQUFPLENBQUMsQ0FBR0EsT0FBTyxDQUNsRUMsS0FBSyxDQUFFekMsS0FBSyxDQUFDeUMsS0FDZixDQUFDLEVBQUMsQ0FDRmxELElBQUksQ0FDTCxTQUVJNkQsY0FBYyxDQUFHLFNBQ3RCQyxjQUE0RCxDQUM1RDlELElBQVUsUUFFVixPQUFLK0QsWUFBWSxDQUNmLFNBQUF0RCxLQUFLLFFBQUssQ0FDUndDLE9BQU8sQ0FDTCxNQUFPYSxlQUFjLEdBQUssVUFBVSxDQUNoQ0EsY0FBYyxDQUFDckQsS0FBSyxDQUFDd0MsT0FBTyxDQUFDLENBQzdCYSxjQUNSLENBQUMsRUFBQyxDQUNGOUQsSUFBSSxDQUNMLFNBOURlOEMsTUFNZixDQU5lQSxNQU1mLE9BRWdCRSxLQUdMLENBSEtBLEtBR0wsY0FNZCxDQUFDLHNCQXBCT3hFLHdCQUFLLEU7Ozs7Ozs7O0FFRlIsR0FBTXlGLElBaUVaLENBQUcsUUFqRVNBLElBaUVaLENBT0NDLEdBQVcsQ0FDWEMsR0FBb0UsQ0FDcEV6RCxNQUEwQixRQUN2QixJQUFJc0QsQ0FBQUEsR0FBRyxDQUFDRSxHQUFHLENBQUVDLEdBQUcsQ0FBRXpELE1BQU0sQ0FBQyxHOzs7O0FDcEY5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FDTyxHQUFNMkQsa0JBQWlCLENBQUcsUUFBcEJBLGtCQUFpQixFQUFTLENBQ3JDLEdBQU1oRixTQUFRLENBQUcrRSx1Q0FBWSxFQUFFLENBRS9CLE1BQU8vRSxTQUFRLENBQUNPLFNBQVMsQ0FBQ0MsZ0JBQWdCLENBQUN5RSxXQUFXLENBQ3hELENBQUMsQzs7Ozs7O0FDdEJNLEdBQU1OLElBQUcsa0ZBZ0JkLGFBQ0VFLEdBQVcsQ0FDWE8sWUFNQyxDQUNEQyxPQUEyQixDQUMzQixXQUNBLDBCQUNFUixHQUFHLENBQ0gseUNBQUlTLE1BQU0sMENBQU5BLE1BQU0sOEJBQWFGLGFBQVksZUFBQ0osaUJBQWlCLEVBQUUsU0FBS00sTUFBTSxFQUFDLEdBQ25FRCxPQUFPLENBQ1IsT0FFRCxNQUFLRSxJQUFJLENBQUdILFlBQVksY0FDMUIsQ0FBQyxnQ0FFTUksZUFBZSxDQUF0Qix5QkFDRWpGLFNBQW9CLENBQ3BCRyxPQUFlLENBQ2Y0RSxNQUFjLENBQ2dELENBQzlELE1BQU8sSUFBSUosQ0FBQUEsZ0NBQVksQ0FDckIzRSxTQUFTLENBQ1QsSUFBSSxDQUNKRyxPQUFPLENBQ1A0RSxNQUFNLENBQ1AsQ0FDSCxDQUFDLFFBRU1HLFVBQVUsQ0FBakIsb0JBQWtCbEYsU0FBb0IsQ0FBRStFLE1BQWUsQ0FBRSxDQUN2RCxHQUFNSSxLQUFJLENBQUcsSUFBSSxDQUFDYixHQUFHLENBRXJCLEdBQUksRUFBQ1MsTUFBTSxRQUFOQSxNQUFNLENBQUVLLE1BQU0sRUFBRSxNQUFPRCxLQUFJLENBRWhDLE1BQVVBLEtBQUksS0FBSW5GLFNBQVMsQ0FBQ3FGLFlBQVksQ0FBQ0MsVUFBVSxDQUNqRFAsTUFBTSxDQUNOL0UsU0FBUyxDQUFDdUYsYUFBYSxDQUN4QixDQUNILENBQUMsUUFFTUMsUUFBUSxDQUFmLGtCQUNFQyxNQUF3RSxDQUN4RSxDQUNBLE1BQU9wQixDQUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDQyxHQUFHLENBQUVtQixNQUFNLEVBQUksSUFBSSxDQUFDVCxJQUFJLENBQUUsSUFBSSxDQUFDRixPQUFPLENBQUMsQ0FDekQsQ0FBQyxjQTFET0Ysd0JBQVEsRTs7Ozs7Ozs7Ozs7O0FDTVgsR0FBTWdCLFlBQVcsQ0FDdEI7QUFDRjtBQUNBO0FBQ0EsS0FNRSwyQkFNUSx5QkFBSixDQUFDLENBQUMsNkJBTEpDLFdBQVcsQ0FBWEEsV0FBVywyQkFBRyxFQUFFLGtCQUNoQkMsaUJBQWlCLE1BQWpCQSxpQkFBaUIsQ0FLakIsSUFBSSxDQUFDQyxRQUFRLENBQUdMLGtDQUFXLENBQUMsSUFBSSxDQUFFRyxXQUFXLENBQUMsQ0FFOUMsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBR0EsaUJBQWlCLEVBQUssVUFBTSxDQUFDLENBQUUsQ0FDMUQsQ0FBQyxDQXBCVUYsV0FBVyxDQUtSSSxPQUFPLENBQUdMLG1DQUFhLEM7O0FDekJYOzs7OztBQ0tyQixHQUFNUSxxQkFXWixDQUFHLFFBWFNBLHFCQVdaLE1BQTBDLElBQXBDQyxTQUFRLE1BQVJBLFFBQVEsQ0FBRTNHLFFBQVEsTUFBUkEsUUFBUSxDQUFFNEcsU0FBUyxNQUFUQSxTQUFTLENBQ2xDLEdBQU1yRyxVQUFTLENBQUdrRyxvQ0FBWSxFQUFFLENBRWhDLEdBQUl2RSxLQUFHLEVBQUksQ0FBQ2xDLFFBQVEsRUFBSSxDQUFDNEcsU0FBUyxDQUFFLENBQ2xDLEtBQU0sSUFBSUMsTUFBSyxDQUNiLCtFQUErRSxDQUNoRixDQUNILENBRUEsR0FBTUMsYUFBWSxDQUNoQkYsU0FBUyxFQUFLLENBQUM1RyxRQUFRLENBQTJDLENBRXBFLEdBQUk4RyxZQUFZLENBQUNuQixNQUFNLEdBQUssQ0FBQyxDQUFFLENBQzdCLEdBQU0vQixTQUFPLENBQUdyRCxTQUFTLENBQUN3RyxnQkFBZ0IsQ0FBQ0QsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDRSxJQUFJLENBQUMsQ0FFaEUsbUJBQ0Usb0JBQUMsUUFBTyxDQUFDLFFBQVEsRUFBQyxLQUFLLENBQUVGLFlBQVksQ0FBQyxDQUFDLENBQUUsRUFBRUgsUUFBUSxDQUFvQixDQUUzRSxDQUVBLEdBQU9NLGVBQWMsQ0FBdUJILFlBQVksSUFBOUJJLGNBQWMsQ0FBSUosWUFBWSxVQUN4RCxHQUFNbEQsUUFBTyxDQUFHckQsU0FBUyxDQUFDd0csZ0JBQWdCLENBQUNFLGNBQWMsQ0FBQ0QsSUFBSSxDQUFDLENBRS9ELG1CQUNFLG9CQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUMsS0FBSyxDQUFFQyxjQUFlLGVBQ3RDLG9CQUFDLG9CQUFvQixFQUFDLFNBQVMsQ0FBRUMsY0FBZSxFQUM3Q1AsUUFBUSxDQUNZLENBQ04sQ0FFdkIsQ0FBQyxDOzs7Ozs7Ozt3REN2Q0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQ08sR0FBTVksa0JBQWlCLENBQUcsUUFBcEJBLGtCQUFpQixNQVluQixJQVhUWixTQUFRLE1BQVJBLFFBQVEsQ0FDR2EsZUFBZSxNQUExQmpILFNBQVMsQ0FDTmtILGVBQWUsa0ZBVWxCLGFBQWlDTixpQkFBTyxDQUFDLFVBQU0sQ0FDN0MsR0FBTU8sa0JBQWlCLENBQ3JCRixlQUFlLEVBQ2ZILDBDQUFlLGdCQUNiTSxnQkFBZ0IsQ0FBRSxJQUFJLEVBQ25CRixlQUFlLEVBQ2xCLENBRUosTUFBTyxDQUNMLFVBQU0sQ0FDSkMsaUJBQWlCLENBQUNFLGtCQUFrQixFQUFFLENBRXRDLE1BQU8sa0JBQU1GLGtCQUFpQixDQUFDRyxrQkFBa0IsRUFBRSxHQUNyRCxDQUFDLENBQ0QsaUJBQU1ILGtCQUFpQixHQUN4QixDQUNILENBQUMsQ0FBRSxDQUFDRCxlQUFlLENBQUNLLEVBQUUsQ0FBRU4sZUFBZSxDQUFDLENBQUMsQ0FoQmxDdEgsU0FBUyxhQUFFNkgsV0FBVyxhQWdCYTtBQUUxQyxHQUFNeEgsVUFBUyxDQUFHNkcsOEJBQW9CLENBQUNsSCxTQUFTLENBQUU2SCxXQUFXLENBQUVBLFdBQVcsQ0FBQyxDQUUzRSxtQkFDRSxvQkFBQyxrREFBeUIsRUFBQyxLQUFLLENBQUV4SCxTQUFTLENBQUN1SCxFQUFHLEVBQzVDbkIsUUFBUSxDQUNpQixDQUVoQyxDQUFDLEM7Ozs7Ozs7Ozs7QUc3Q00sR0FBTXVCLGdCQVNaLENBQUcsUUFUU0EsZ0JBU1osQ0FDQ2xCLElBQU8sQ0FDUG1CLGFBQTJDLENBQ3hDLENBQ0gsR0FBTTVILFVBQVMsQ0FBR2tHLG9DQUFZLEVBQUUsQ0FDaEMsR0FBTXpHLFNBQVEsQ0FBR2dJLG9CQUFVLENBQUN6SCxTQUFTLENBQUN3RyxnQkFBZ0IsQ0FBQ0MsSUFBSSxDQUFDLENBQUMsQ0FFN0QsR0FBSSxDQUFDbUIsYUFBYSxFQUFJbkUsU0FBRSxDQUFDaEUsUUFBUSxDQUFFaUksd0NBQWdCLENBQUMsQ0FBRSxDQUNwRCxHQUFJL0YsS0FBRyxFQUFLbEMsUUFBUSxDQUF5Qm9JLFdBQVcsR0FBSyxXQUFXLENBQUUsQ0FDeEUsS0FBTSxJQUFJdkIsTUFBSywrRUFFVjdHLFFBQVEsQ0FBeUJVLE9BQU8sdUVBRTVDLENBQ0gsQ0FFQSxNQUFPVixTQUFRLENBQ2pCLENBRUEsR0FBSSxNQUFPbUksY0FBYSxHQUFLLFNBQVMsQ0FBRSxDQUN0QyxHQUFJakcsSUFBRyxDQUFFLENBQ1AsS0FBTSxJQUFJbUcsZUFBYyxzRUFDOENyQixJQUFJLENBQUNuQyxHQUFHLE9BQzdFLENBQ0gsQ0FBQyxJQUFNLEVBR1QsQ0FFQSxNQUFPdEUsVUFBUyxDQUFDK0gsV0FBVyxDQUFDdEIsSUFBSSxDQUFFbUIsYUFBYSxDQUFDLENBQ25ELENBQUMsQzs7Ozs7O0FDckNELEdBQU1TLEtBQUksQ0FBSyxNQUFPQyxXQUFVLEdBQUssV0FBVyxFQUFJQSxVQUFVLEVBQUssQ0FBQyxDQUFTLENBQzdFLEdBQU1DLGlCQUFnQixxQkFBdUJDLElBQUksQ0FBQ0MsTUFBTSxFQUFJLENBQzVELEdBQU1DLFVBQVMsQ0FBRyxpQkFBaUIsQ0FFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FDQSxHQUFNQyxlQUFjLENBQUcsUUFBakJBLGVBQWMsQ0FDbEIzSSxTQUFvQixDQUNwQjRJLFdBQTJDLENBQzNDQyxRQUFtRSxDQUNoRSwyQkFDSCxHQUFJLENBQUNBLFFBQVEsQ0FBQ0MsT0FBTyxDQUFFLE1BQU8sS0FBSSxDQUVsQyxHQUFNQyxZQUFXLENBQUdGLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDRSxXQUFXLENBRWhELEdBQUlKLFdBQVcsR0FBS0csV0FBVyxDQUFFLE1BQU8sTUFBSyxDQUU3QyxHQUFNRSxXQUFVLHdCQUNkakosU0FBUyxDQUFDa0osTUFBTSxDQUFDQyxLQUFLLENBQUNOLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDTSxRQUFRLENBQUMsZUFBakQsc0JBQW1ESCxVQUFVLENBRS9ELEdBQUlBLFVBQVUsRUFBSUksTUFBTSxDQUFDQyxJQUFJLENBQUNMLFVBQVUsQ0FBQyxDQUFDN0QsTUFBTSxHQUFLLENBQUMsQ0FBRSxNQUFPLEtBQUksQ0FFbkUsR0FBTW1FLGNBQWEsQ0FBRyxNQUFPWCxZQUFXLEdBQUssVUFBVSxDQUN2RCxHQUFNWSxjQUFhLENBQUcsTUFBT1QsWUFBVyxHQUFLLFVBQVUsQ0FFdkQsR0FBSVEsYUFBYSxHQUFLQyxhQUFhLENBQUUsTUFBTyxLQUFJLENBRWhELEdBQU1DLE9BQU0sQ0FBR3pKLFNBQVMsQ0FBQzBKLGFBQWEsQ0FBQ0MsaUJBQWlCLENBQUNmLFdBQVcsQ0FBQyxDQUNyRSxHQUFNZ0IsT0FBTSxDQUFHNUosU0FBUyxDQUFDMEosYUFBYSxDQUFDQyxpQkFBaUIsQ0FBQ1osV0FBVyxDQUFDLENBRXJFLEdBQUlVLE1BQU0sR0FBS0csTUFBTSxDQUFFLE1BQU8sS0FBSSxDQUVsQyxHQUNFLENBQUNMLGFBQWEsRUFDZCxDQUFDQyxhQUFhLEVBQ2RaLFdBQVcsQ0FBQ2lCLGlCQUFpQixHQUFLZCxXQUFXLENBQUNjLGlCQUFpQixDQUMvRCxpREFDQSxHQUFNQyx3QkFBdUIsQ0FDM0Isd0JBQUFsQixXQUFXLENBQUNpQixpQkFBaUIsZUFBN0Isc0JBQStCRSxRQUFRLEVBQUUsR0FBSSxFQUFFLENBRWpELEdBQU1DLHdCQUF1QixDQUMzQix3QkFBQWpCLFdBQVcsQ0FBQ2MsaUJBQWlCLGVBQTdCLHNCQUErQkUsUUFBUSxFQUFFLEdBQUksRUFBRSxDQUVqRCxHQUFJRCx1QkFBdUIsR0FBS0UsdUJBQXVCLENBQUUsTUFBTyxLQUFJLENBQ3RFLENBRUE7QUFDQSxHQUFJVCxhQUFhLEVBQUlDLGFBQWEsQ0FBRSxDQUNsQyxNQUFPWixZQUFXLENBQUNtQixRQUFRLEVBQUUsR0FBS2hCLFdBQVcsQ0FBQ2dCLFFBQVEsRUFBRSxDQUMxRCxDQUVBO0FBQ0EsR0FDR25CLFdBQVcsQ0FBd0JxQixRQUFRLEdBQzNDbEIsV0FBVyxDQUF3QmtCLFFBQVEsQ0FDNUMsQ0FDQSxNQUFPLE1BQUssQ0FDZCxDQUVBLEdBQU1DLFVBQVMsQ0FBSXRCLFdBQVcsQ0FBd0JxQixRQUFRLENBQUNGLFFBQVEsRUFBRSxDQUN6RSxHQUFNSSxVQUFTLENBQUlwQixXQUFXLENBQXdCa0IsUUFBUSxDQUFDRixRQUFRLEVBQUUsQ0FFekUsTUFBT0csVUFBUyxHQUFLQyxTQUFTLENBQ2hDLENBQUMsQ0FFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUNPLEdBQU1DLGdCQUFlLENBQUcsUUFBbEJBLGdCQUFlLENBQzFCQyxnQkFBK0MsQ0FFekMsZ0ZBQ04sR0FBTXJLLFVBQVMsQ0FBR2tHLG9DQUFZLEVBQUUsQ0FDaEMsR0FBTW9FLGFBQVksQ0FBR2xDLGtEQUFtQixFQUFFLENBQzFDLEdBQU1TLFNBQVEsQ0FBR2IsZ0JBQU0sRUFBOEIsQ0FDckQsR0FBTXVDLFVBQVMsQ0FBR3ZDLGdCQUFNLEVBQUssQ0FDN0IsR0FBTXdDLFNBQVEsQ0FBRyxNQUFPSCxpQkFBZ0IsR0FBSyxVQUFVLCtCQU5wREksSUFBSSxxREFBSkEsSUFBSSwwQkFRUCxHQUFNQyxZQUFXLENBQ2ZGLFFBQVEsRUFBSUgsZ0JBQWdCLENBQUNNLGNBQWMscUJBQUk5QixRQUFRLENBQUNDLE9BQU8sU0FBaEIsa0JBQWtCMkIsSUFBSSxDQUNqRUosZ0JBQWdCLENBQUNNLGNBQWMsQ0FBQ0YsSUFBSSxDQUFFNUIsUUFBUSxDQUFDQyxPQUFPLENBQUMyQixJQUFJLENBQUMsQ0FDNUR0QyxtQ0FBZSxxQkFBQ1UsUUFBUSxDQUFDQyxPQUFPLGVBQWhCLG1CQUFrQjJCLElBQUksQ0FBRUEsSUFBSSxDQUFDLENBRW5ELEdBQU1HLGFBQVksQ0FBR0YsV0FBVyxDQUM1QkQsSUFBSSxDQUNKLHFCQUFBNUIsUUFBUSxDQUFDQyxPQUFPLGVBQWhCLG1CQUFrQjJCLElBQUksR0FBTSxFQUF1QixDQUV2RCxHQUFNSSxjQUFhLENBQUdSLGdCQUFnQix3QkFBS3hCLFFBQVEsQ0FBQ0MsT0FBTyxlQUFoQixtQkFBa0JFLFdBQVcsRUFDeEUsR0FBTThCLFlBQVcsQ0FDZkosV0FBVyxFQUFJL0IsY0FBYyxDQUFDM0ksU0FBUyxDQUFFcUssZ0JBQWdCLENBQUV4QixRQUFRLENBQUMsQ0FFdEUsR0FBSWlDLFdBQVcsRUFBSSxDQUFDakMsUUFBUSxDQUFDQyxPQUFPLENBQUUsQ0FDcEM7QUFDQUQsUUFBUSxDQUFDQyxPQUFPLENBQUc5SSxTQUFTLENBQUMwSixhQUFhLENBQUNxQixRQUFRLENBQ2pEVixnQkFBZ0IsQ0FDaEJPLFlBQVksQ0FDYixDQUNILENBRUEsR0FBTUksTUFBSyxDQUFHbkMsUUFBUSxDQUFDQyxPQUFxQyxDQUU1RCxhQUFpQ2xDLGlCQUFPLENBQUMsVUFBTSxDQUM3QyxHQUFJcUUsY0FBYSxDQUFHLEtBQUssQ0FFekIsTUFBTyxDQUNMLFNBQUNDLGFBQXlCLENBQUssNEJBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBSTdDLElBQUksQ0FBQzhDLHdCQUF3QixDQUFFRCxhQUFhLEVBQUUsQ0FFbEQ7QUFDQSxHQUFJLDBCQUFDbEwsU0FBUyxDQUFDa0osTUFBTSxDQUFDQyxLQUFLLENBQUM2QixLQUFLLENBQUM1QixRQUFRLENBQUMsU0FBdEMsdUJBQXdDSCxVQUFVLENBQUNxQixZQUFZLENBQUMsRUFBRSxDQUNyRTtBQUNBO0FBQ0E7QUFDQSxHQUFJVSxLQUFLLENBQUNJLFdBQVcsQ0FBRSxDQUNyQixDQUFFdkMsUUFBUSxDQUFDQyxPQUFPLENBQVdiLHlCQUFTLENBQ3RDZ0QsYUFBYSxDQUFHLElBQUksQ0FFcEJDLGFBQWEsRUFBRSxDQUVmLE1BQU8sV0FBTSxDQUFDLENBQUMsQ0FBQztBQUNsQixDQUVBbEwsU0FBUyxDQUFDa0osTUFBTSxDQUFDbUMsT0FBTyxDQUN0QmYsWUFBWSxDQUNaVSxLQUFLLENBQUM1QixRQUFRLENBQ2RWLFNBQVMsQ0FDVFIsd0JBQVEsQ0FDUixTQUFDb0QsTUFBTSxDQUFFeEwsUUFBUSxDQUFLLENBQ3BCLEdBQUlBLFFBQVEsR0FBS3lLLFNBQVMsQ0FBQ3pCLE9BQU8sQ0FBRSxPQUNwQyxHQUFJd0MsTUFBTSxHQUFLLFdBQVcsQ0FBRSxDQUMxQjtBQUNBO0FBQ0EsQ0FBRXpDLFFBQVEsQ0FBQ0MsT0FBTyxDQUFXYix5QkFBUyxDQUN0Q2dELGFBQWEsQ0FBRyxJQUFJLENBQ3RCLENBRUFDLGFBQWEsRUFBRSxDQUNqQixDQUFDLENBQ0YsQ0FDSCxDQUVBLE1BQU8sV0FBTSxDQUNYO0FBQ0FsTCxTQUFTLENBQUNrSixNQUFNLENBQUNxQyxVQUFVLENBQUNqQixZQUFZLENBQUVVLEtBQUssQ0FBQzVCLFFBQVEsQ0FBQyxDQUMzRCxDQUFDLENBQ0gsQ0FBQyxDQUNELGlCQUFPNkIsY0FBYSxDQUFHMUMsZ0JBQWdCLENBQUd5QyxLQUFLLENBQUMzSixNQUFNLEVBQUMsQ0FDeEQsQ0FDSCxDQUFDLENBQUUsQ0FBQ3JCLFNBQVMsQ0FBRWdMLEtBQUssQ0FBQyxDQUFDLENBbkRmckwsU0FBUyxhQUFFNkgsV0FBVyxhQXFEN0I7QUFDQTtBQUNBLEdBQUlxRCxhQUFhLEVBQUksQ0FBQ0MsV0FBVyxDQUFFLENBQ2pDOUssU0FBUyxDQUFDMEosYUFBYSxDQUFDOEIsU0FBUyxDQUMvQlIsS0FBSyxDQUFDaEMsV0FBVyxDQUNqQnFCLGdCQUFnQixDQUNoQk8sWUFBWSxDQUNiLENBQ0Q7QUFDQUwsU0FBUyxDQUFDekIsT0FBTyxDQUFHa0MsS0FBSyxDQUFDM0osTUFBTSxDQUNsQyxDQUVBLE1BQU93RixDQUFBQSw4QkFBb0IsQ0FBQ2xILFNBQVMsQ0FBRTZILFdBQVcsQ0FBRUEsV0FBVyxDQUFDLENBQ2xFLENBQUMsQzs7QUM3TE0sR0FBTWtFLGFBaUJaLENBQUcsUUFqQlNBLGFBaUJaLENBQ0NqRixJQUFPLENBQ1AxQixNQUEwQixDQUMxQmpFLE1BQTBDLENBQ2UsSUFEekRBLE1BQTBDLFdBQTFDQSxNQUEwQyxDQUFHLENBQUV2QixTQUFTLENBQUUsY0FBZSxDQUFDLEVBRTFFLEdBQU1FLFNBQVEsQ0FBR2dNLDBDQUFlLENBQUNoRixJQUFJLENBQUUxQixNQUFNLGtCQUN4Q2pFLE1BQU0sRUFDVG5CLFNBQVMsQ0FBRSxJQUFJLEdBQ2YsQ0FFRixNQUFPLENBQUNGLFFBQVEsQ0FBQ1AsUUFBUSxFQUFFLENBQUVPLFFBQVEsQ0FBQ2tNLGNBQWMsQ0FBQyxDQUN2RCxDQUFDLEM7O0FDaENNLEdBQU1DLGFBY1osQ0FBRyxRQWRTQSxhQWNaLENBQ0NuRixJQUFPLENBQ1AxQixNQUEwQixDQUMxQmpFLE1BQTBDLENBQ3ZDLElBREhBLE1BQTBDLFdBQTFDQSxNQUEwQyxDQUFHLENBQUV2QixTQUFTLENBQUUsY0FBZSxDQUFDLEVBRTFFLEdBQU1FLFNBQVEsQ0FBR2dNLDBDQUFlLENBQUNoRixJQUFJLENBQUUxQixNQUFNLGtCQUN4Q2pFLE1BQU0sRUFDVG5CLFNBQVMsQ0FBRSxJQUFJLEdBQ2YsQ0FFRixNQUFPRixTQUFRLENBQUNQLFFBQVEsRUFBRSxDQUM1QixDQUFDLEM7Ozs7QUV2QkQsR0FBTTZNLGlCQUFnQixDQUFHLG9CQUFvQixDQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUNPLEdBQU1DLG1CQWdCWixDQUFHM00sd0NBQWMsQ0FDaEIwTSxnQkFBZ0IsQ0FDaEIsU0FDRXRNLFFBQTZCLENBQzdCZ0gsSUFBNkIsQ0FDN0IxQixNQUEwQixDQUMxQmpFLE1BQWlDLENBQzlCLENBQ0gsR0FBTW1MLGlCQUFnQixDQUFHeE0sUUFBUSxDQUFDTyxTQUFTLENBQUNDLGdCQUFnQixDQUFDeUUsV0FBVyxDQUFDcUQsV0FBVyxDQUNsRnRCLElBQUksQ0FDSjFCLE1BQU0sQ0FDTixDQUFDakUsTUFBTSxRQUFOQSxNQUFNLENBQUVuQixTQUFTLENBQUcsQ0FBQyxDQUFHbU0sc0JBQU0sQ0FBRSxDQUFBaEwsTUFBTSxjQUFOQSxNQUFNLENBQUV2QixTQUFTLEdBQUl3TSxnQkFBZ0IsQ0FBQyxDQUN4RSxDQUVELE1BQU8sQ0FDTDFLLE1BQU0sQ0FBRTRLLGdCQUF1QyxDQUMvQ3hMLElBQUksQ0FBS29MLHNCQUFNLFFBQ2pCLENBQUMsQ0FDSCxDQUFDLENBQ0QsU0FDRXZLLGNBQXVELENBQ3ZEN0IsUUFBNkIsQ0FDN0JnSCxJQUE2QixDQUM3QjFCLE1BQTBCLENBQzFCakUsTUFBaUMsQ0FDOUIsQ0FDSDtBQUNBLEdBQU1tTCxpQkFBZ0IsQ0FBR3hNLFFBQVEsQ0FBQ08sU0FBUyxDQUFDQyxnQkFBZ0IsQ0FBQ3lFLFdBQVcsQ0FBQ3FELFdBQVcsQ0FDbEZ0QixJQUFJLENBQ0oxQixNQUFNLENBQ04sQ0FBQ2pFLE1BQU0sUUFBTkEsTUFBTSxDQUFFbkIsU0FBUyxDQUFHLENBQUMsQ0FBR21NLHNCQUFNLENBQUUsQ0FBQWhMLE1BQU0sY0FBTkEsTUFBTSxDQUFFdkIsU0FBUyxHQUFJd00sZ0JBQWdCLENBQUMsQ0FDeEUsQ0FFRHpLLGNBQWMsQ0FBQ0QsTUFBTSxDQUFHNEssZ0JBQXVDLENBRS9ELE1BQU8zSyxlQUFjLENBQ3ZCLENBQUMsQ0FDRixDOztBQ3JGTSxHQUFNNEssbUJBQWtCLENBQUcsUUFBckJBLG1CQUFrQixDQUM3QkMsVUFBK0IsQ0FFekIsMkJBQ04sR0FBTTFNLFNBQVEsQ0FBRytFLHVDQUFZLEVBQUUsK0JBRjVCaUcsSUFBSSxxREFBSkEsSUFBSSwwQkFJUCxNQUFPLHVCQUFBaEwsUUFBUSxDQUFDTyxTQUFTLENBQUNDLGdCQUFnQixDQUFDeUUsV0FBVyxFQUFDMEgsTUFBTSw4QkFDM0RELFVBQVUsU0FDUDFCLElBQUksRUFDUixDQUNILENBQUMsQzs7QUNETSxHQUFNNEIsZ0JBY1osQ0FBRyxRQWRTQSxnQkFjWixDQUNDNUYsSUFBTyxDQUNQMUIsTUFBMEIsQ0FDK0IsQ0FDekQsR0FBTXRGLFNBQVEsQ0FBR3VNLGtCQUFrQixDQUFDdkYsSUFBSSxDQUFFMUIsTUFBTSxDQUF1QixDQUNyRXhGLFNBQVMsQ0FBRSxpQkFBaUIsQ0FDNUJJLFNBQVMsQ0FBRSxJQUNiLENBQUMsQ0FBNEQsQ0FFN0QsR0FBTVYsU0FBYSxDQUFHLFFBQWhCQSxTQUFhLENBQUlxTixRQUFhLENBQUVsTSxJQUFVLFFBQzlDWCxTQUFRLENBQUNSLFFBQVEsQ0FBQ3FOLFFBQVEsQ0FBRWxNLElBQUksQ0FBQyxHQUVuQ2lKLE1BQU0sQ0FBQ2tELE1BQU0sQ0FBQ3ROLFFBQVEsQ0FBRVEsUUFBUSxDQUFDK00sT0FBTyxDQUFDLENBRXpDLE1BQU8sQ0FBQy9NLFFBQVEsQ0FBQ0MsS0FBSyxDQUFDUixRQUFRLEVBQUUsQ0FBRUQsUUFBUSxDQUFDLENBQzlDLENBQUMsQzs7QUNyQ00sR0FBTXdOLGdCQVdaLENBQUcsUUFYU0EsZ0JBV1osQ0FDQ2hHLElBQU8sQ0FDUDFCLE1BQTBCLENBQ3ZCLENBQ0gsR0FBTXRGLFNBQVEsQ0FBR3VNLGtCQUFrQixDQUFDdkYsSUFBSSxDQUFFMUIsTUFBTSxDQUF1QixDQUNyRXhGLFNBQVMsQ0FBRSxpQkFBaUIsQ0FDNUJJLFNBQVMsQ0FBRSxJQUNiLENBQUMsQ0FBc0QsQ0FFdkQsTUFBT0YsU0FBUSxDQUFDQyxLQUFLLENBQUNSLFFBQVEsRUFBRSxDQUNsQyxDQUFDLEM7O0FDZk0sR0FBTXdOLFdBQVUsQ0FBR3JOLHdDQUFjLENBQ3RDLFlBQVksQ0FDWixTQUNFSSxRQUE2QixDQUM3QmtOLFlBQXlCLENBQ3pCQyxJQUFtQixRQUVsQixDQUNDbk0sSUFBSSxDQUFLb0wsc0JBQU0sUUFBTyxDQUN0QmUsSUFBSSxDQUFKQSxJQUFJLENBQ0p2TCxNQUFNLENBQUVzTCxZQUFZLEVBQ3RCLENBQUMsRUFBa0MsQ0FDckMsU0FDRXJMLGNBQTZDLENBQzdDN0IsUUFBNkIsQ0FDN0JrTixZQUF5QixDQUN6QkMsSUFBbUIsQ0FDaEIsQ0FDSCxHQUFNQyxnQkFBZSxDQUFHMUUsbUNBQWUsQ0FBQzdHLGNBQWMsQ0FBQ3NMLElBQUksQ0FBRUEsSUFBSSxDQUFDLENBRWxFLEdBQU12TCxPQUFNLENBQUd3TCxlQUFlLENBQUdGLFlBQVksRUFBRSxDQUFHckwsY0FBYyxDQUFDRCxNQUFNLENBRXZFQyxjQUFjLENBQUNzTCxJQUFJLENBQUdBLElBQUksQ0FDMUJ0TCxjQUFjLENBQUNELE1BQU0sQ0FBR0EsTUFBTSxDQUU5QixNQUFPQyxlQUFjLENBQ3ZCLENBQUMsQ0FDRixDOztBQ2xDTSxHQUFNd0wsZUFBYyxDQUFHLFFBQWpCQSxlQUFjLENBQ3pCQyxRQUFnQyxDQUNoQ0gsSUFBbUIsUUFDaEJGLENBQUFBLFVBQVUsQ0FBQyxpQkFBTUssU0FBUSxHQUFFSCxJQUFJLENBQUMsRzs7OztBQ0o5QixHQUFNSSxpQkFBZ0IsQ0FBRyxRQUFuQkEsaUJBQWdCLEVBQVMsQ0FDcEMsR0FBTXZOLFNBQVEsQ0FBRytFLHVDQUFZLEVBQUUsQ0FFL0IsTUFBTyxrQkFBTS9FLFNBQVEsQ0FBQ3dOLFVBQVUsQ0FBQyxrQkFBa0IsQ0FBRSxVQUFVLENBQUMsR0FDbEUsQ0FBQyxDOzs7O0FDaUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUNPLEdBQU1DLG1CQVlaLENBQUc3Tix3Q0FBYyxDQUNoQixvQkFBb0IsQ0FDcEIsU0FJRUksUUFBNkIsQ0FLMUIsaUtBSkMwTixjQUFhLFNBQUVoSyxjQUFjLFNBQUVyQyxNQUFNLFNBUXpDLEdBQU1zTSxXQUdMLENBQUcsQ0FBQyxDQUFDLENBRU4sR0FBTUMsV0FHTCxDQUFHLENBQUMsQ0FBQyxDQUVOLEdBQU1uSyxPQUFNLENBQUcsQ0FBQyxDQU1mLENBRUQsR0FBTW9LLFlBQVcsQ0FBRyxRQUFkQSxZQUFXLENBQXlCNUosU0FBZSxDQUFLLENBQzVELEdBQU03QyxNQUFLLENBQUcsQ0FDWjBNLEVBQUUsQ0FBRSxZQUNGM0osU0FBaUIsQ0FDakI0SixTQUFpQixDQUNqQnBLLEtBQXFDLENBQ2xDLENBQ0gsR0FBSSxDQUFDRixNQUFNLENBQUNRLFNBQVMsQ0FBZSxDQUFFLENBQ3BDUixNQUFNLENBQUNRLFNBQVMsQ0FBZSxDQUFHLENBQUMsQ0FBQyxDQUN0QyxDQUVBLEdBQUksQ0FBQ1IsTUFBTSxDQUFDc0ssU0FBUyxDQUFlLENBQUUsQ0FDcEN0SyxNQUFNLENBQUNzSyxTQUFTLENBQWUsQ0FBRyxDQUFDLENBQUMsQ0FDdEMsQ0FFQXRLLE1BQU0sQ0FBQ1EsU0FBUyxDQUFlLENBQUNFLFNBQVMsQ0FBZSxDQUFHLENBQ3pERyxJQUFJLENBQUV5SixTQUF1QixDQUM3QnBLLEtBQUssQ0FBTEEsS0FDRixDQUFDLENBRUQsTUFBT3ZDLE1BQUssQ0FDZCxDQUFDLENBQ0Q0TSxPQUFPLENBQUUsaUJBQUNWLFFBQWEsQ0FBSyxDQUMxQixHQUFJLENBQUNLLFVBQVUsQ0FBQzFKLFNBQVMsQ0FBQyxDQUFFLENBQzFCMEosVUFBVSxDQUFDMUosU0FBUyxDQUFDLENBQUcsRUFBRSxDQUM1QixDQUVBMEosVUFBVSxDQUFDMUosU0FBUyxDQUFDLENBQUNaLElBQUksQ0FBQ2lLLFFBQVEsQ0FBQyxDQUVwQyxNQUFPbE0sTUFBSyxDQUNkLENBQUMsQ0FDRDZNLE9BQU8sQ0FBRSxpQkFBQ1gsUUFBYSxDQUFLLENBQzFCLEdBQUksQ0FBQ00sVUFBVSxDQUFDM0osU0FBUyxDQUFDLENBQUUsQ0FDMUIySixVQUFVLENBQUMzSixTQUFTLENBQUMsQ0FBRyxFQUFFLENBQzVCLENBRUEySixVQUFVLENBQUMzSixTQUFTLENBQUMsQ0FBQ1osSUFBSSxDQUFDaUssUUFBUSxDQUFDLENBRXBDLE1BQU9sTSxNQUFLLENBQ2QsQ0FBQyxDQUNENkMsU0FBUyxDQUFUQSxTQUNGLENBQUMsQ0FFRCxNQUFPN0MsTUFBSyxDQUNkLENBQUMsQ0FFRCxtQkFBdUJzTSxhQUFhLENBQUNHLFdBQVcsQ0FBQyxDQUExQ3ZPLFlBQVksbUJBQ25CLEdBQU1nQyxVQUFTLENBQ2IsQ0FBQUQsTUFBTSxjQUFOQSxNQUFNLENBQUU2TSxPQUFPLEdBQUlsTyxRQUFRLENBQUNPLFNBQVMsQ0FBQ2dCLGlCQUFpQixDQUFDdkIsUUFBUSxDQUFDLENBRW5FLEdBQU1DLE1BQUssQ0FBRyxHQUFJdUQsQ0FBQUEsWUFBWSxtQkFDNUJsQyxTQUFTLGNBQVRBLFNBQVMsQ0FBRXVDLEtBQUsseUJBQUt2RSxZQUFZLENBQUMyRSxTQUFTLENBQzNDUixNQUFNLHFCQUNObkMsU0FBUyxjQUFUQSxTQUFTLENBQUVzQyxPQUFPLDJCQUFJRixjQUFjLENBQ3BDckMsTUFBTSxjQUFOQSxNQUFNLENBQUVzQyxLQUFLLENBQ2QsQ0FFRCxHQUFNbkMsYUFBWSxDQUFHdkIsS0FBSyxDQUFDQyxTQUFTLENBQUMsQ0FDbkNDLE9BQU8sQ0FBRSxpQkFBQWdPLFdBQVcsQ0FBSSxDQUN0QixHQUFROU4sU0FBUSxDQUFlOE4sV0FBVyxDQUFsQzlOLFFBQVEsQ0FBRUMsUUFBUSxDQUFLNk4sV0FBVyxDQUF4QjdOLFFBQVEsQ0FFMUIsR0FBSUQsUUFBUSxDQUFDd0QsS0FBSyxJQUFLdkQsUUFBUSxjQUFSQSxRQUFRLENBQUV1RCxLQUFLLEVBQUUsT0FFeEMsR0FBSXZELFFBQVEsRUFBSXNOLFVBQVUsQ0FBQ3ROLFFBQVEsQ0FBQ3VELEtBQUssQ0FBQyxDQUFFLENBQzFDK0osVUFBVSxDQUFDdE4sUUFBUSxDQUFDdUQsS0FBSyxDQUFDLENBQUNWLE9BQU8sQ0FBQyxTQUFBbUssUUFBUSxRQUN6Q0EsU0FBUSxDQUFDck4sS0FBSyxDQUFFa08sV0FBVyxDQUFDLEdBQzdCLENBQ0gsQ0FDQSxHQUFJUixVQUFVLENBQUN0TixRQUFRLENBQUN3RCxLQUFLLENBQUMsQ0FBRSxDQUM5QjhKLFVBQVUsQ0FBQ3ROLFFBQVEsQ0FBQ3dELEtBQUssQ0FBQyxDQUFDVixPQUFPLENBQUMsU0FBQW1LLFFBQVEsUUFDekNBLFNBQVEsQ0FBQ3JOLEtBQUssQ0FBRWtPLFdBQVcsQ0FBQyxHQUM3QixDQUNILENBQ0EsR0FBSTlNLE1BQU0sUUFBTkEsTUFBTSxDQUFFK00sWUFBWSxDQUFFLENBQ3hCL00sTUFBTSxDQUFDK00sWUFBWSxDQUFDbk8sS0FBSyxDQUFFa08sV0FBVyxDQUFDLENBQ3pDLENBQ0YsQ0FDRixDQUFDLENBQUMsQ0FDRixHQUFNRSxXQUFVLENBQUcsQ0FBQWhOLE1BQU0sY0FBTkEsTUFBTSxDQUFFbkIsU0FBUyxHQUFJSCxrQ0FBVyxDQUFDQyxRQUFRLENBQUVDLEtBQUssQ0FBQyxDQUVwRSxHQUFNbUUsYUFBWSxDQUFHbkUsS0FBSyxDQUFDUixRQUFRLEVBQUUsQ0FFckMsR0FBSWtPLFVBQVUsQ0FBQ3ZKLFlBQVksQ0FBQ1AsS0FBSyxDQUFDLENBQUUsQ0FDbEM4SixVQUFVLENBQUN2SixZQUFZLENBQUNQLEtBQUssQ0FBQyxDQUFDVixPQUFPLENBQUMsU0FBQW1LLFFBQVEsUUFDN0NBLFNBQVEsQ0FBQ3JOLEtBQUssQ0FBRSxDQUNkSSxRQUFRLENBQUUrRCxZQUFZLENBQ3RCbkUsS0FBSyxDQUFMQSxLQUNGLENBQUMsQ0FBQyxHQUNILENBQ0gsQ0FFQSxHQUFNcU8sV0FFNkIsQ0FBRyxDQUNwQzdNLE9BQU8sQ0FBRSxrQkFBTSxDQUNiRCxZQUFZLENBQUNFLFdBQVcsRUFBRSxDQUMxQjRNLFVBQVUsQ0FBQ0MsY0FBYyxjQUF6QkQsVUFBVSxDQUFDQyxjQUFjLEVBQUksQ0FDL0IsQ0FBQyxDQUNEM00sTUFBTSxDQUFFM0IsS0FBSyxDQUNiZSxJQUFJLENBQUtvTCxzQkFBTSxnQkFDakIsQ0FBQyxDQUVELEdBQUlpQyxVQUFVLENBQUUsQ0FDZEMsVUFBVSxDQUFDQyxjQUFjLENBQUcsaUJBQU1GLFdBQVUsQ0FBQzNNLFdBQVcsRUFBRSxHQUM1RCxDQUVBLE1BQU80TSxXQUFVLENBQ25CLENBQUMsQ0FDRCxTQUlFek0sY0FNbUMsQ0FDbkM3QixRQUE2QixDQUUxQiwwSkFES3FCLE9BQU0sVUFFZCxHQUFNbkIsVUFBUyxvQkFBR21CLE1BQU0sY0FBTkEsTUFBTSxDQUFFbkIsU0FBUywwQkFBSSxJQUFJLENBQzNDLEdBQU00QixjQUFhLENBQUcsQ0FBQyxDQUFDRCxjQUFjLENBQUMwTSxjQUFjLENBRXJELEdBQUl6TSxhQUFhLEdBQUs1QixTQUFTLENBQUUsTUFBTzJCLGVBQWMsQ0FFdEQ7QUFDQSxHQUFJLENBQUMzQixTQUFTLENBQUUsQ0FDZDJCLGNBQWMsQ0FBQzBNLGNBQWMsY0FBN0IxTSxjQUFjLENBQUMwTSxjQUFjLEVBQUksQ0FDakMxTSxjQUFjLENBQUMwTSxjQUFjLENBQUc1TSxTQUFTLENBQ3pDLE1BQU9FLGVBQWMsQ0FDdkIsQ0FFQTtBQUNBLEdBQU1MLGFBQVksQ0FBR3pCLGtDQUFXLENBQUNDLFFBQVEsQ0FBRTZCLGNBQWMsQ0FBQ0QsTUFBTSxDQUFDLENBQ2pFQyxjQUFjLENBQUMwTSxjQUFjLENBQUcsaUJBQU0vTSxhQUFZLENBQUNFLFdBQVcsRUFBRSxHQUVoRSxNQUFPRyxlQUFjLENBQ3ZCLENBQUMsQ0FDRixDOzs7Ozs7Ozt1REN4VEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUNPLEdBQU1tTixjQWlCWixDQUFHLFFBakJTQSxjQWlCWixDQUNDQyxjQUE0RCxDQUM1RDlCLElBQW1CLE9BTWhCLHlCQUQrRCxDQUFDLENBQUMsT0FIbEUrQixRQUFRLE1BQVJBLFFBQVEsQ0FDUjVQLFlBQVksTUFBWkEsWUFBWSxDQUNUNlAsV0FBVyw4RUFHaEIsR0FBTUMsS0FBSSxDQUFHTCw4QkFBUyxDQUNwQixDQUFDLENBQUMsQ0FDSCxDQUVELEdBQU05TyxNQUFLLENBQUc2TyxrQ0FBVyxDQUN2QkksUUFBUSxDQUFHNVAsWUFBWSxDQUFHcVAsK0NBQXNCLENBQUlyUCxZQUFZLENBQUMsQ0FDakU2UCxXQUFXLENBQ1osQ0FFRDtBQUNBQyxJQUFJLENBQUMvRixPQUFPLENBQUNnRyxPQUFPLENBQUdwQyxVQUFVLENBQUMsVUFBTSxDQUN0QyxHQUFNcUMsZUFBYyxDQUFHRixJQUFJLENBQUMvRixPQUFPLENBQUNrRyxVQUFVLENBQzlDLEdBQU1DLGVBQWMsQ0FDbEIsTUFBT0MsZ0JBQWUsR0FBSyxXQUFXLENBQUcsR0FBSUEsZ0JBQWUsRUFBRSxDQUFHOU4sU0FBUyxDQUU1RXlOLElBQUksQ0FBQy9GLE9BQU8sQ0FBQ2tHLFVBQVUsQ0FBR0MsY0FBYyxDQUN4QyxHQUFNSCxRQUFPLENBQUdKLGNBQWMsQ0FBQ0csSUFBSSxDQUFDL0YsT0FBTyxDQUFDa0csVUFBVSxDQUFDLENBRXZELEdBQUlyTixLQUFHLEVBQUksT0FBT21OLE9BQU8sY0FBUEEsT0FBTyxDQUFFSyxJQUFJLElBQUssVUFBVSxDQUFFLENBQzlDLEtBQU0sSUFBSXZOLFVBQVMseUVBQ3VEcU0sd0NBQWMsQ0FDcEZhLE9BQU8sQ0FDUixDQUNGLENBQ0gsQ0FFQSxHQUFJQSxPQUFPLEdBQUtELElBQUksQ0FBQy9GLE9BQU8sQ0FBQ2dHLE9BQU8sQ0FBRSxNQUFPRCxLQUFJLENBQUMvRixPQUFPLENBQUNnRyxPQUFPLENBQy9EQyxjQUFjLGNBQWRBLGNBQWMsQ0FBRUssS0FBSyxjQUFyQkwsY0FBYyxDQUFFSyxLQUFLLENBQ3JCLFNBQVMsQ0FDVixDQUVELEdBQUksQ0FBQ1QsUUFBUSxDQUFFLENBQ2I7QUFDQWpQLEtBQUssQ0FBQ3lFLFlBQVksQ0FBQ2lLLCtDQUFzQixFQUFFLENBQUMsQ0FDOUMsQ0FFQVUsT0FBTyxDQUNKSyxJQUFJLENBQUMsU0FBQUUsSUFBSSxDQUFJLENBQ1osR0FBSUosY0FBYyxRQUFkQSxjQUFjLENBQUUzRCxNQUFNLENBQUNnRSxPQUFPLENBQUUsT0FFcEM1UCxLQUFLLENBQUNULFFBQVEsQ0FBQzBQLFFBQVEsQ0FBR1UsSUFBSSxDQUFHaEIsK0NBQXNCLENBQUNnQixJQUFJLENBQUMsQ0FBQyxDQUNoRSxDQUFDLENBQUMsQ0FDREUsS0FBSyxDQUFDLFNBQUFDLEtBQUssQ0FBSSxDQUNkLEdBQUliLFFBQVEsRUFBSU0sY0FBYyxRQUFkQSxjQUFjLENBQUUzRCxNQUFNLENBQUNnRSxPQUFPLENBQUUsT0FFaEQ7QUFDQTVQLEtBQUssQ0FBQ3lFLFlBQVksQ0FBQ2dLLDZDQUFvQixDQUFDcUIsS0FBSyxDQUFDLENBQUMsQ0FDakQsQ0FBQyxDQUFDLENBRUosTUFBT1YsUUFBTyxDQUNoQixDQUFDLENBQUVsQyxJQUFJLENBQUMsQ0FFUjBCLG9DQUFZLENBQ1YsaUJBQU0sbUVBQU9PLElBQUksQ0FBQy9GLE9BQU8sQ0FBQ2tHLFVBQVUsZUFBdkIsc0JBQXlCSSxLQUFLLGNBQTlCLHNCQUF5QkEsS0FBSyxDQUFXLFdBQVcsQ0FBQyxLQUNsRSxFQUFFLENBQ0gsQ0FFRCxNQUFPbEIsQ0FBQUEsa0JBQUcsQ0FBQ3hPLEtBQUssQ0FBQyxDQUFDK1AsVUFBVSxDQUFDWixJQUFJLENBQUMvRixPQUFPLENBQUNnRyxPQUFPLENBQUMsQ0FDcEQsQ0FBQyxDOztBQzdJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FDTyxHQUFNWSxVQUFTLENBQUcsUUFBWkEsVUFBUyxTQUFTbEwsQ0FBQUEsdUNBQVksRUFBRSxDQUFDbUwsc0JBQXNCLEc7Ozs7Ozs7Ozs7Ozt5R0dOcEUsR0FBTUcsUUFBTyxDQUFHLENBQ2RDLFNBQVMsQ0FBRSxZQUFZLENBQ3ZCQyxhQUFhLENBQUUsZ0JBQWdCLENBQy9CQyxTQUFTLENBQUUsV0FBVyxDQUN0QkMsS0FBSyxDQUFFLE9BQU8sQ0FDZEMsS0FBSyxDQUFFLGVBQ1QsQ0FBQyxDQUVELEdBQU1DLFNBQVEsQ0FBR1AsMkJBQVUsMkxBTzFCLENBRUQsR0FBTVMsT0FBTSxDQUFHVCxpQ0FBYSxzS0FLM0IsQ0FFRCxHQUFNVyxTQUFRLENBQUdYLGlDQUFhLHdSQVU3QixDQUVELEdBQU1ZLE9BQU0sQ0FBR1osNkJBQVcsMFZBYXpCLENBRUQsR0FBTWMsUUFBTyxDQUFHZCw2QkFBVyw4UUFTMUIsQ0FFRCxHQUFNZSxRQUFPLENBQUdmLDZCQUFXLHVVQWUxQixDQUVELEdBQU1nQixjQUFhLENBQUcsUUFBaEJBLGNBQWEsc0JBQ2pCLDJCQUNFLEtBQUssQ0FBQyw0QkFBNEIsQ0FDbEMsS0FBSyxDQUFDLElBQUksQ0FDVixNQUFNLENBQUMsR0FBRyxDQUNWLE9BQU8sQ0FBQyxVQUFVLGVBRWxCLDRCQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsbUJBQW1CLEVBQUcsQ0FDM0QsRUFDUCxDQUVNLEdBQU1DLFdBQVUsQ0FBRyxRQUFiQSxXQUFVLE1BTWpCLElBTEpDLGVBQWMsTUFBZEEsY0FBYyxDQUNkQyxLQUFLLE1BQUxBLEtBQUssQ0FLTCxjQUE0QnBCLGtCQUFRLENBQUMsS0FBSyxDQUFDLENBQXBDcUIsTUFBTSxjQUFFQyxTQUFTLGNBQ3hCLGVBQTBDdEIsa0JBQVEsRUFBd0IsQ0FBbkV1QixhQUFhLGVBQUVDLGdCQUFnQixlQUV0QyxHQUFNcEwsUUFBTyxDQUFHWSxpQkFBTyxDQUNyQixpQkFBTyxDQUNMbUosU0FBUyxDQUFFLG9CQUFNLENBQ2ZzQixPQUFPLENBQUNDLEtBQUssQ0FBQyxzQ0FBc0MsQ0FBQyxDQUNyREQsT0FBTyxDQUFDRSxHQUFHLENBQ1RQLEtBQUssQ0FBQ1EsWUFBWSxDQUFDVCxjQUFjLENBQUNqSSxPQUFPLENBQUMsQ0FBQzJJLFNBQVMsQ0FBQyxDQUNuREMsU0FBUyxDQUFFLEtBQ2IsQ0FBQyxDQUFDLENBQ0gsQ0FDREwsT0FBTyxDQUFDTSxRQUFRLEVBQUUsQ0FDcEIsQ0FBQyxDQUNEMUIsU0FBUyxDQUFFLG9CQUFNLENBQ2ZvQixPQUFPLENBQUNDLEtBQUssQ0FBQyxZQUFZLENBQUMsQ0FDM0JELE9BQU8sQ0FBQ0UsR0FBRyxDQUFDUCxLQUFLLENBQUNRLFlBQVksQ0FBQ1QsY0FBYyxDQUFDakksT0FBTyxDQUFDLENBQUMsQ0FDdkR1SSxPQUFPLENBQUNNLFFBQVEsRUFBRSxDQUNwQixDQUFDLENBQ0R6QixLQUFLLENBQUUsZ0JBQU0sQ0FDWCxHQUFNbFEsVUFBUyxDQUFHZ1IsS0FBSyxDQUFDUSxZQUFZLENBQUNULGNBQWMsQ0FBQ2pJLE9BQU8sQ0FBQyxDQUM1RHVJLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLGdCQUFnQixDQUFDLENBQy9CRCxPQUFPLENBQUNFLEdBQUcsQ0FBQyxPQUFPLENBQUV2UixTQUFTLENBQUM0UixTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FDakRQLE9BQU8sQ0FBQ0UsR0FBRyxDQUFDLFdBQVcsQ0FBRXZSLFNBQVMsQ0FBQzRSLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUN6RFAsT0FBTyxDQUFDRSxHQUFHLENBQUMsWUFBWSxDQUFFdlIsU0FBUyxDQUFDNFIsU0FBUyxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQzNEUCxPQUFPLENBQUNNLFFBQVEsRUFBRSxDQUNwQixDQUFDLENBQ0QzQixhQUFhLENBQUUsd0JBQU0sQ0FDbkJxQixPQUFPLENBQUNDLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUNsQ0QsT0FBTyxDQUFDRSxHQUFHLENBQ1RQLEtBQUssQ0FBQ1EsWUFBWSxDQUNoQlQsY0FBYyxDQUFDakksT0FBTyxDQUN2QixDQUFDWSxhQUFhLENBQUNtSSxpQkFBaUIsRUFBRSxDQUNwQyxDQUNEUixPQUFPLENBQUNNLFFBQVEsRUFBRSxDQUNwQixDQUFDLENBQ0R4QixLQUFLLENBQUUsZ0JBQU0sQ0FDWGtCLE9BQU8sQ0FBQ0MsS0FBSyxDQUFDLG1DQUFtQyxDQUFDLENBQ2xERCxPQUFPLENBQUNFLEdBQUcsQ0FBQyxRQUFRLENBQUVQLEtBQUssQ0FBQyxDQUM1QkssT0FBTyxDQUFDRSxHQUFHLENBQUMsUUFBUSxDQUFFdEwsS0FBSyxDQUFDLENBQzVCb0wsT0FBTyxDQUFDTSxRQUFRLEVBQUUsQ0FDcEIsQ0FDRixDQUFDLEVBQUMsQ0FDRixDQUFDWCxLQUFLLENBQUMsQ0FDUixDQUVELG1CQUNFLHdDQUNHQyxNQUFNLGVBQUksb0JBQUMsUUFBUSxFQUFDLE9BQU8sQ0FBRSx5QkFBTUMsVUFBUyxDQUFDLEtBQUssQ0FBQyxFQUFDLEVBQUcsY0FDeEQsb0JBQUMsT0FBTyxNQUNMQyxhQUFhLGVBQ1osb0JBQUMsTUFBTSxFQUFDLE9BQU8sQ0FBRSx5QkFBTW5MLFFBQU8sQ0FBQ21MLGFBQWEsQ0FBQyxFQUFFLEVBQUMsU0FDekNyQixPQUFPLENBQUNxQixhQUFhLENBQUMsQ0FFOUIsY0FDRCxvQkFBQyxRQUFRLEVBQUMsT0FBTyxDQUFFLHlCQUFNRCxVQUFTLENBQUMsSUFBSSxDQUFDLEVBQUMsRUFDdEMsQ0FBQ0MsYUFBYSxlQUFJLHNDQUFnQixjQUNuQyxvQkFBQyxhQUFhLE1BQUcsQ0FDUixDQUNWRixNQUFNLGVBQ0wsb0JBQUMsT0FBTyxFQUNOLE9BQU8sQ0FBRSxrQkFBTSxDQUNiQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQ2xCLENBQUUsRUFFRDdILE1BQU0sQ0FBQ0MsSUFBSSxDQUFDd0csT0FBTyxDQUFDLENBQUMvTixHQUFHLENBQUMsU0FBQytQLE1BQTRCLHFCQUNyRCxvQkFBQyxNQUFNLEVBQ0wsR0FBRyxDQUFFQSxNQUFPLENBQ1osT0FBTyxDQUFFLGtCQUFNLENBQ2JWLGdCQUFnQixDQUFDVSxNQUFNLENBQUMsQ0FDeEI5TCxPQUFPLENBQUM4TCxNQUFNLENBQUMsRUFBRSxDQUNuQixDQUFFLEVBRURoQyxPQUFPLENBQUNnQyxNQUFNLENBQUMsQ0FDVCxFQUNWLENBQUMsQ0FFTCxDQUNPLENBQ1QsQ0FFUCxDQUFDLEM7O0FDbkxELEdBQU1HLGFBQVksQ0FBRyxDQUFDLEdBQUcsQ0FBRSxHQUFHLENBQUUsR0FBRyxDQUFFLEdBQUcsQ0FBQyxDQUN6QyxHQUFNQyxhQUFZLENBQUcsQ0FBQyxHQUFHLENBQUUsR0FBRyxDQUFFLEdBQUcsQ0FBRSxHQUFHLENBQUMsQ0FFbEMsR0FBTUMsQ0FBQUEscUJBQVMsQ0FBRyxRQUFaQSxVQUFTLENBQ3BCQyxNQUFtQixDQUNuQkMsS0FBb0MsQ0FDakMscUJBQ0gsR0FBSUEsS0FBSyxDQUFDL04sR0FBRyxHQUFLLEtBQUssQ0FBRSxDQUN2QitOLEtBQUssQ0FBQ0MsY0FBYyxFQUFFLENBRXRCRixNQUFNLENBQUNHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FFdkIsT0FDRixDQUVBLEdBQUlGLEtBQUssQ0FBQy9OLEdBQUcsR0FBSyxHQUFHLENBQUUsQ0FDckIrTixLQUFLLENBQUNDLGNBQWMsRUFBRSxDQUN0QkYsTUFBTSxDQUFDRyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQ3ZCUCxlQUFlLENBQUNJLE1BQU0sQ0FBRSxDQUN0QkssUUFBUSxDQUFFLENBQUMsQ0FDWEMsT0FBTyxDQUFFLElBQUksQ0FDYkMsSUFBSSxDQUFFLFdBQ1IsQ0FBQyxDQUFDLENBQ0YsT0FDRixDQUVBLEdBQUlOLEtBQUssQ0FBQy9OLEdBQUcsR0FBSyxHQUFHLENBQUUsQ0FDckIrTixLQUFLLENBQUNDLGNBQWMsRUFBRSxDQUN0QkYsTUFBTSxDQUFDRyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQ3ZCUCxlQUFlLENBQUNJLE1BQU0sQ0FBRSxDQUN0QkssUUFBUSxDQUFFLENBQUMsQ0FDWEMsT0FBTyxDQUFFLElBQUksQ0FDYkMsSUFBSSxDQUFFLFdBQ1IsQ0FBQyxDQUFDLENBQ0YsT0FDRixDQUVBLEdBQUlOLEtBQUssQ0FBQy9OLEdBQUcsR0FBSyxHQUFHLENBQUUsQ0FDckIrTixLQUFLLENBQUNDLGNBQWMsRUFBRSxDQUN0QkYsTUFBTSxDQUFDRyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQ3ZCUCxlQUFlLENBQUNJLE1BQU0sQ0FBRSxDQUN0QkssUUFBUSxDQUFFLENBQUMsQ0FDWEMsT0FBTyxDQUFFLElBQUksQ0FDYkMsSUFBSSxDQUFFLFdBQ1IsQ0FBQyxDQUFDLENBQ0YsT0FDRixDQUVBLEdBQU1DLFNBQVEsQ0FDWlIsTUFBTSxDQUFDUyxTQUFTLEVBQUlkLHNCQUFzQixDQUFDSyxNQUFNLENBQUVBLE1BQU0sQ0FBQ1MsU0FBUyxDQUFDLENBRXRFLEdBQUksQ0FBQ0QsUUFBUSxDQUFFLE9BRWYsR0FBSUcsS0FBSSxDQUFHSCxRQUFRLENBQUNJLGNBQWMsQ0FBQ0MsYUFBYSxDQUNoRCxNQUFPRixJQUFJLENBQUNHLE9BQU8sQ0FBQ0MsU0FBUyxHQUFLLE1BQU0sQ0FBRSxDQUN4Q0osSUFBSSxDQUFHQSxJQUFJLENBQUNFLGFBQWEsQ0FDM0IsQ0FFQSxHQUFNRyxTQUFRLENBQUdMLElBQUksQ0FBQ00sU0FBUyxDQUMvQixHQUFNQyxPQUFNLENBQUcsa0JBQUFGLFFBQVEsQ0FBQ0csS0FBSyxDQUFDLEtBQUssQ0FBQyxlQUFyQixnQkFBd0IsQ0FBQyxDQUFDLEdBQUksRUFBRSxDQUMvQyxHQUFNQyxhQUFZLENBQUdaLFFBQVEsQ0FBQ2EsV0FBVyxHQUFLYixRQUFRLENBQUNjLFNBQVMsQ0FDaEUsR0FBTUEsVUFBUyxDQUFHRixZQUFZLENBQzFCWixRQUFRLENBQUNjLFNBQVMsQ0FDbEJ0QixNQUFNLENBQUNTLFNBQVMsQ0FBQ2MsS0FBSyxDQUFDQyxNQUFNLENBQ2pDLEdBQU1ILFlBQVcsQ0FBR0QsWUFBWSxDQUFHWixRQUFRLENBQUNhLFdBQVcsQ0FBR0MsU0FBUyxDQUNuRSxHQUFNRyxTQUFRLENBQUdULFFBQVEsQ0FBQ0ssV0FBVyxDQUFHLENBQUMsQ0FBQyxFQUFJLEVBQUUsQ0FDaEQsR0FBTUssU0FBUSxDQUFHVixRQUFRLENBQUNNLFNBQVMsQ0FBQyxFQUFJLEVBQUUsQ0FFMUMsR0FDR3JCLEtBQUssQ0FBQy9OLEdBQUcsR0FBSyxHQUFHLEVBQUl3UCxRQUFRLEdBQUssR0FBRyxFQUNyQ3pCLEtBQUssQ0FBQy9OLEdBQUcsR0FBSyxHQUFHLEVBQUl3UCxRQUFRLEdBQUssR0FBSSxFQUN0Q3pCLEtBQUssQ0FBQy9OLEdBQUcsR0FBSyxHQUFHLEVBQUl3UCxRQUFRLEdBQUssR0FBSSxFQUN0Q3pCLEtBQUssQ0FBQy9OLEdBQUcsR0FBSyxHQUFHLEVBQUl3UCxRQUFRLEdBQUssR0FBSSxFQUN0Q3pCLEtBQUssQ0FBQy9OLEdBQUcsR0FBSyxHQUFHLEVBQUl3UCxRQUFRLEdBQUssR0FBSSxFQUN0Q3pCLEtBQUssQ0FBQy9OLEdBQUcsR0FBSyxHQUFHLEVBQUl3UCxRQUFRLEdBQUssR0FBSSxDQUN2QyxDQUNBekIsS0FBSyxDQUFDQyxjQUFjLEVBQUUsQ0FDdEJOLGVBQWUsQ0FBQ0ksTUFBTSxDQUFFLENBQ3RCSyxRQUFRLENBQUUsQ0FBQyxDQUNYRSxJQUFJLENBQUUsV0FDUixDQUFDLENBQUMsQ0FDRixPQUNGLENBRUEsR0FBSU4sS0FBSyxDQUFDL04sR0FBRyxHQUFLLE9BQU8sQ0FBRSxDQUN6QitOLEtBQUssQ0FBQ0MsY0FBYyxFQUFFLENBQ3RCRixNQUFNLENBQUMyQixXQUFXLEVBQUUsQ0FFcEIsR0FBSTlCLFlBQVksQ0FBQytCLFFBQVEsQ0FBQ0gsUUFBUSxDQUFDLENBQUUsQ0FDbkN6QixNQUFNLENBQUNHLFVBQVUsQ0FBSWUsTUFBTSxNQUFLLENBRWhDLEdBQUlwQixZQUFZLENBQUM4QixRQUFRLENBQUNGLFFBQVEsQ0FBQyxDQUFFLENBQ25DMUIsTUFBTSxDQUFDMkIsV0FBVyxFQUFFLENBQ3BCM0IsTUFBTSxDQUFDRyxVQUFVLENBQUNlLE1BQU0sQ0FBQyxDQUN6QnRCLGVBQWUsQ0FBQ0ksTUFBTSxDQUFFLENBQ3RCSyxRQUFRLENBQUVhLE1BQU0sQ0FBQ2xPLE1BQU0sQ0FBRyxDQUFDLENBQzNCc04sT0FBTyxDQUFFLElBQUksQ0FDYkMsSUFBSSxDQUFFLFdBQ1IsQ0FBQyxDQUFDLENBQ0osQ0FFQSxPQUNGLENBRUFQLE1BQU0sQ0FBQ0csVUFBVSxDQUFDZSxNQUFNLENBQUMsQ0FFekIsT0FDRixDQUNGLENBQUMsQ0FFTSxHQUFNVyx3QkFBdUIsQ0FBRyxRQUExQkEsd0JBQXVCLENBQ2xDN0IsTUFBbUIsQ0FDbkJRLFFBQWUsQ0FDWixDQUNILEdBQU1zQixHQUFFLENBQUd0QixRQUFRLENBQUNJLGNBQWMsQ0FBQ0MsYUFBYSxDQUNoRCxHQUFJa0IsU0FBUSxDQUFHdkIsUUFBUSxDQUFDSSxjQUFjLENBQUNDLGFBQWEsQ0FFcEQsTUFBTyxDQUFDa0IsUUFBUSxDQUFDakIsT0FBTyxDQUFDa0IsV0FBVyxDQUFFLENBQ3BDRCxRQUFRLENBQUdBLFFBQVEsQ0FBQ2xCLGFBQWEsQ0FDbkMsQ0FFQSxHQUFNb0IsVUFBUyxDQUFHSCxFQUFFLENBQUNJLHFCQUFxQixFQUFFLENBQUNDLEtBQUssQ0FBR0wsRUFBRSxDQUFDYixTQUFTLENBQUNqTyxNQUFNLENBRXhFLEdBQU1vUCxRQUFPLENBQUdMLFFBQVEsQ0FBQ00sVUFBVSxDQUNuQzdCLFFBQVEsQ0FBQ0ksY0FBYyxDQUFDQyxhQUFhLENBQUN5QixjQUFjLENBQUMsQ0FDbkRDLEtBQUssQ0FBRSxTQUNULENBQUMsQ0FBQyxDQUVGLEdBQUksQ0FBQ04sU0FBUyxDQUFFLENBQ2Q7QUFDQUYsUUFBUSxDQUFDTSxVQUFVLENBQUcsQ0FBQyxDQUN2QixPQUNGLENBRUEsR0FBTUYsTUFBSyxDQUFHSixRQUFRLENBQUNTLFdBQVcsQ0FDbEMsR0FBTUMsUUFBTyxDQUFHekMsTUFBTSxDQUFDUyxTQUFTLENBQUNjLEtBQUssQ0FBQ0MsTUFBTSxDQUM3QyxHQUFNQSxPQUFNLENBQUdpQixPQUFPLENBQUdSLFNBQVMsQ0FDbEMsR0FBTVMsT0FBTSxDQUFHLEVBQUUsQ0FFakIsR0FBSWxCLE1BQU0sRUFBSWtCLE1BQU0sQ0FBRyxDQUFDLENBQUMsQ0FBR1AsS0FBSyxDQUFHQyxPQUFPLENBQUUsQ0FDM0M7QUFDQUwsUUFBUSxDQUFDTSxVQUFVLENBQUdiLE1BQU0sRUFBSWtCLE1BQU0sQ0FBRyxDQUFDLENBQUMsQ0FBR1AsS0FBSyxDQUNyRCxDQUFDLElBQU0sSUFBSVgsTUFBTSxFQUFJa0IsTUFBTSxDQUFHLENBQUMsQ0FBQyxDQUFHTixPQUFPLENBQUUsQ0FDMUM7QUFDQUwsUUFBUSxDQUFDTSxVQUFVLENBQUdiLE1BQU0sRUFBSWtCLE1BQU0sQ0FBRyxDQUFDLENBQUMsQ0FDN0MsQ0FBQyxJQUFNLENBQ0xYLFFBQVEsQ0FBQ00sVUFBVSxDQUFHRCxPQUFPLENBQy9CLENBQ0YsQ0FBQyxDOztnTUNwSk0sR0FBTVMsY0FBYSxDQUFHcEYsMkJBQVUsK1NBUXRDLENBRU0sR0FBTXFGLE9BQU0sQ0FBR3JGLDJCQUFVLDZZQWUvQixDQUVNLEdBQU1zRixPQUFNLENBQUd0RiwyQkFBVSw2WUFnQi9CLENBRU0sR0FBTXVGLGNBQWEsQ0FBR3ZGLDZCQUFXLGtLQUl2QyxDQUVNLEdBQU13RixXQUFVLENBQUd4Riw2QkFBVyxvSEFFcEMsQ0FFTSxHQUFNeUYsWUFBVyxDQUFHekYsaUNBQWEsbVNBWXZDLENBRU0sR0FBTTBGLE9BQU0sQ0FBRzFGLDJCQUFVLDRUQVUvQixDQUVNLEdBQU0yRixlQUFjLENBQUczRix1QkFBTSxDQUFDa0YsUUFBUSxDQUFDLHNlQW1CeEMsa0JBQUdVLFVBQVMsTUFBVEEsU0FBUyxPQUNaQSxVQUFTLENBQUNDLE1BQU0sQ0FDYjNULEdBQUcsQ0FBQyxtQkFBRzRULE1BQUssT0FBTEEsS0FBSyxDQUFFQyxLQUFLLE9BQUxBLEtBQUssT0FDbEJBLE1BQUssQ0FDRjdULEdBQUcsQ0FDRixTQUFBdEIsSUFBSSxhQUNHQSxJQUFJLE9BQU11VSxtQkFBRyxDQUNoQlcsS0FBYSxzQ0FDZCxPQUFJLENBQ1IsQ0FDQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUNkLENBQ0FBLElBQUksQ0FBQyxJQUFJLENBQUMsR0FVbEIsQ0FFTSxHQUFNakYsQ0FBQUEsY0FBTyxDQUFHZixtQ0FBYyxnY0FjcEMsQzs7QUN6RkQsR0FBTW1CLE1BQUssa0JBQVEwRix5QkFBVSxDQUFLRCxtQkFBVSxDQUFFLENBQUM7QUFFL0MsR0FBTUUsTUFBSyxrQkFDTjNGLEtBQUssQ0FDTC9LLEtBQUssQ0FDVCxDQUNELEdBQU0yUSxVQUFTLENBQUd2TixNQUFNLENBQUNDLElBQUksQ0FBQ3FOLEtBQUssQ0FBQyxDQUNwQyxHQUFNRSxZQUFXLENBQUdELFNBQVMsQ0FBQzdVLEdBQUcsQ0FBQyxTQUFBdUMsR0FBRyxRQUFJcVMsTUFBSyxDQUFDclMsR0FBRyxDQUFDLEdBQUMsQ0FFcEQsR0FBTXdTLGVBQWMsQ0FBRyxRQUFqQkEsZUFBYyxDQUNsQkMsSUFBVSxDQUNWQyxNQUF5QyxDQUN6Q2pTLE1BQTBDLENBQzFDa1MsVUFBbUIsQ0FDaEIsQ0FDSCxvRUFBb0JELE1BQU0sbUNBQUUsSUFBakJFLE1BQUssYUFDZCxHQUFNQyxJQUFHLENBQUdwUyxNQUFNLENBQUNxUyxLQUFLLENBQUdGLEtBQUssQ0FBQzlSLE1BQU0sQ0FFdkMsR0FBSSxNQUFPOFIsTUFBSyxHQUFLLFFBQVEsQ0FBRSxDQUM3QixHQUFJRCxVQUFVLENBQUUsQ0FDZGxTLE1BQU0sQ0FBQ3NTLE1BQU0sQ0FBQ3ZVLElBQUksQ0FBQyxDQUNqQndVLE1BQU0sQ0FBRSxDQUFFUCxJQUFJLENBQUpBLElBQUksQ0FBRW5ELE1BQU0sQ0FBRTdPLE1BQU0sQ0FBQ3FTLEtBQU0sQ0FBQyxDQUN0Q3pELEtBQUssQ0FBRSxDQUFFb0QsSUFBSSxDQUFKQSxJQUFJLENBQUVuRCxNQUFNLENBQUV1RCxHQUFJLENBQUMsQ0FDNUJJLFNBQVMsQ0FBRU4sVUFDYixDQUFDLENBQUMsQ0FDSixDQUVBbFMsTUFBTSxDQUFDcVMsS0FBSyxDQUFHRCxHQUFHLENBRWxCLFNBQ0YsQ0FFQSxHQUFJLE1BQU9ELE1BQUssQ0FBQ00sT0FBTyxHQUFLLFFBQVEsRUFBSSxDQUFDaFYsS0FBSyxDQUFDQyxPQUFPLENBQUN5VSxLQUFLLENBQUNNLE9BQU8sQ0FBQyxDQUFFLENBQ3RFelMsTUFBTSxDQUFDc1MsTUFBTSxDQUFDdlUsSUFBSSxDQUFDLENBQ2pCd1UsTUFBTSxDQUFFLENBQUVQLElBQUksQ0FBSkEsSUFBSSxDQUFFbkQsTUFBTSxDQUFFN08sTUFBTSxDQUFDcVMsS0FBTSxDQUFDLENBQ3RDekQsS0FBSyxDQUFFLENBQUVvRCxJQUFJLENBQUpBLElBQUksQ0FBRW5ELE1BQU0sQ0FBRXVELEdBQUksQ0FBQyxDQUM1QkksU0FBUyxDQUFFTCxLQUFLLENBQUN6VyxJQUNuQixDQUFDLENBQUMsQ0FFRnNFLE1BQU0sQ0FBQ3FTLEtBQUssQ0FBR0QsR0FBRyxDQUVsQixTQUNGLENBRUFMLGNBQWMsQ0FBQ0MsSUFBSSxDQUFFRyxLQUFLLENBQUNNLE9BQU8sQ0FBRXpTLE1BQU0sQ0FBRW1TLEtBQUssQ0FBQ3pXLElBQUksQ0FBQyxDQUN6RCxDQUVBLE1BQU9zRSxPQUFNLENBQUNzUyxNQUFNLENBQ3RCLENBQUMsQ0FFRCxHQUFNSSxTQUFRLENBQUcsUUFBWEEsU0FBUSxNQUFnQyxJQUEzQkMsS0FBSSxTQUFFWCxJQUFJLFNBQzNCLEdBQUksQ0FBQ1gsV0FBVyxDQUFDc0IsSUFBSSxDQUFDLENBQUUsQ0FDdEIsTUFBTyxFQUFFLENBQ1gsQ0FFQSxHQUFNVixPQUFNLENBQUdmLHdCQUFjLENBQUN5QixJQUFJLENBQUNHLElBQUksQ0FBRTVCLCtCQUFtQixDQUFDLENBRTdELE1BQU9hLGVBQWMsQ0FBQ0MsSUFBSSxDQUFFQyxNQUFNLENBQUUsQ0FBRUssTUFBTSxDQUFFLEVBQUUsQ0FBRUQsS0FBSyxDQUFFLENBQUUsQ0FBQyxDQUFDLENBQy9ELENBQUMsQ0FFRCxHQUFNWSxTQUFRLENBQUcsUUFBWEEsU0FBUSxDQUNaQyxJQUFZLENBQ1pDLGFBQXFCLENBQ3JCbkgsY0FBeUMsQ0FDekNvSCxVQUFnQyxDQUM3QixDQUNILEdBQU1DLFVBQVMsUUFBVUYsYUFBYSxNQUFLRCxJQUFJLDJCQUEwQkMsYUFBYSwwQ0FBeUNBLGFBQWEsZUFBY0EsYUFBYSxvQkFBbUJBLGFBQWEsdURBQXNEQSxhQUFhLGVBQWMsQ0FDeFIsR0FBTUcsUUFBTyxDQUFNRCxTQUFTLGtCQUFpQixDQUU3QyxHQUFNRSxlQUFjLENBQUdILFVBQVUsV0FBTzlPLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDNk8sVUFBVSxDQUFDLEVBQUksRUFBRSxDQUNyRSxHQUFNN08sS0FBSSxDQUFHNk8sVUFBVSxXQUFPdkIsU0FBUyxDQUFLMEIsY0FBYyxFQUFJMUIsU0FBUyxDQUN2RSxHQUFNMkIsS0FBSSxDQUFHSixVQUFVLFdBQ2Z0QixXQUFXLENBQUt5QixjQUFjLENBQUN2VyxHQUFHLENBQUMsU0FBQXVDLEdBQUcsUUFBSTZULFdBQVUsQ0FBQzdULEdBQUcsQ0FBQyxHQUFDLEVBQzlEdVMsV0FBVyxDQUVmO0FBQ0EsR0FBTTJCLEdBQUUsOEJBQU9DLFFBQVEsRUFBQyxPQUFPLFNBQUtuUCxJQUFJLEVBQUUrTyxPQUFPLEdBQUMsQ0FFbEQsR0FBTUssaUJBQWdCLENBQUdoQyw2Q0FBaUMsRUFBRSxDQUM1RCxHQUFNclYsT0FBTSxDQUFHbVgsRUFBRSxDQUFDSSxJQUFJLE9BQVBKLEVBQUUsRUFBTSxJQUFJLENBQUV2UyxLQUFLLFNBQUtzUyxJQUFJLEVBQUMsQ0FDNUMsR0FBTU0sZ0JBQWUsQ0FBR25DLDZDQUFpQyxFQUFFLENBRTNELEdBQUksQ0FBQzNGLGNBQWMsQ0FBQ2pJLE9BQU8sQ0FBRSxDQUMzQk8sTUFBTSxDQUFDQyxJQUFJLENBQUN1UCxlQUFlLENBQUMsQ0FBQ2pXLE9BQU8sQ0FBQyxTQUFBMEIsR0FBRyxDQUFJLENBQzFDLEdBQUksQ0FBQ29VLGdCQUFnQixDQUFDcFUsR0FBRyxDQUFDLENBQUV5TSxjQUFjLENBQUNqSSxPQUFPLENBQUd4RSxHQUFHLENBQzFELENBQUMsQ0FBQyxDQUNKLENBRUEsTUFBT2pELE9BQU0sQ0FDZixDQUFDLENBRUQsR0FBTXlYLE1BQUssQ0FBRyxRQUFSQSxNQUFLLENBQUlqQixJQUFZLFFBQ3pCQSxLQUFJLENBQ0RrQixLQUFLLENBQUMsSUFBSSxDQUFDLENBQ1hDLEtBQUssQ0FBQyxDQUFDLENBQUUsQ0FBQyxDQUFDLENBQUMsQ0FDWmpYLEdBQUcsQ0FBQyxTQUFBZ1IsSUFBSSxRQUFLLENBQ1p0UyxJQUFJLENBQUUsV0FBVyxDQUNqQjJGLFFBQVEsQ0FBRSxDQUFDLENBQUV5UixJQUFJLENBQUU5RSxJQUFLLENBQUMsQ0FDM0IsQ0FBQyxFQUFDLENBQUMsR0FFUCxHQUFNa0csVUFBUyxDQUFHLFFBQVpBLFVBQVMsQ0FBSTlQLEtBQW1CLFFBQ3BDQSxNQUFLLENBQ0ZwSCxHQUFHLENBQUMsU0FBQTJWLElBQUksUUFDTkEsS0FBSSxDQUFhdFIsUUFBUSxDQUFDckUsR0FBRyxDQUFDLFNBQUFtWCxLQUFLLFFBQUtBLE1BQUssQ0FBVXJCLElBQUksR0FBQyxDQUFDaEMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUN2RSxDQUNBQSxJQUFJLENBQUMsSUFBSSxDQUFDLE1BRVRzRCxjQUFhLDBHQUNqQix1QkFBWUMsS0FBSyxDQUFFLFdBQ2pCLGlDQUFNQSxLQUFLLENBQUMsT0FDWixNQUFLdlksS0FBSyxDQUFHLENBQUV3WSxRQUFRLENBQUUsS0FBTSxDQUFDLGNBQ2xDLENBQUMsMENBRURDLGdDQUFnQyxDQUFoQywyQ0FBbUMsQ0FDakMsSUFBSSxDQUFDcmEsUUFBUSxDQUFDLENBQUVvYSxRQUFRLENBQUUsS0FBTSxDQUFDLENBQUMsQ0FDcEMsQ0FBQyxlQUVNRSx3QkFBd0IsQ0FBL0IsbUNBQWtDLENBQ2hDLE1BQU8sQ0FBRUYsUUFBUSxDQUFFLElBQUssQ0FBQyxDQUMzQixDQUFDLFFBRURHLE1BQU0sQ0FBTixpQkFBYyxDQUNaO0FBQ0EsR0FBSSxJQUFJLENBQUMzWSxLQUFLLENBQUN3WSxRQUFRLENBQUUsQ0FDdkIsbUJBQU8sc0NBQWdCLENBQ3pCLENBRUEsTUFBTyxLQUFJLENBQUNELEtBQUssQ0FBQ2hULFFBQVEsZUFBSSxnQ0FBUSxDQUN4QyxDQUFDLHdCQXJCeUJILGVBQWUsRUF3QjNDLEdBQU15VCxDQUFBQSxZQUFJLENBQUcsUUFBUEEsS0FBSSxPQUF3RCxJQUFsREMsV0FBVSxPQUFWQSxVQUFVLENBQUV2VCxRQUFRLE9BQVJBLFFBQVEsQ0FBRXdULElBQUksT0FBSkEsSUFBSSxDQUN4QyxtQkFDRSwyREFBTSxTQUFTLFdBQVdBLElBQUksQ0FBQ3JDLFNBQVMsRUFBSSxFQUFFLENBQUcsRUFBS29DLFVBQVUsRUFDN0R2VCxRQUFRLENBQ0osQ0FFWCxDQUFDLENBRU0sR0FBTXlULFFBQU8sQ0FBRyxRQUFWQSxRQUFPLE9BVWQsSUFUSnpULFNBQVEsT0FBUkEsUUFBUSxDQUNSMFQsV0FBVyxPQUFYQSxXQUFXLENBQ1gzQixVQUFVLE9BQVZBLFVBQVUsdUJBQ1Y0QixTQUFTLENBQVRBLFNBQVMsMEJBQUcsUUFBUSxpQkFPcEIsR0FBUUMsUUFBTyxDQUFLaEUsdUNBQW9CLEVBQUUsQ0FBQ2lFLFVBQVUsQ0FBN0NELE9BQU8sQ0FDZixHQUFNNUgsT0FBTSxDQUFHeEwsaUJBQU8sQ0FBQyxpQkFBTTBQLENBQUFBLFdBQVcsQ0FBQ0UsU0FBUyxDQUFDSCxZQUFZLEVBQUUsQ0FBQyxDQUFDLEdBQUUsRUFBRSxDQUFDLENBQ3hFLEdBQU02RCxhQUFZLENBQUd0VCxpQkFBTyxDQUFDLGlCQUFNa1MsTUFBSyxDQUFDMVMsUUFBUSxDQUFDLEdBQUUsRUFBRSxDQUFDLENBQ3ZELGNBQTBCd0osa0JBQVEsQ0FBQ3NLLFlBQVksQ0FBQyxDQUF6QzVXLEtBQUssY0FBRTZXLFFBQVEsY0FDdEIsZUFBNEJ2SyxrQkFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFqQ3ZPLE1BQU0sZUFBRStZLFNBQVMsZUFDeEIsR0FBTUMsTUFBSyxDQUFHdEUsc0NBQWEsRUFBRSxDQUM3QixHQUFNaEYsZUFBYyxDQUFHL0ksZ0JBQU0sQ0FBQzhSLFdBQVcsQ0FBQyxDQUMxQyxHQUFNUSx1QkFBc0IsQ0FBR3RTLGdCQUFNLEVBQXNCLENBQzNELEdBQU11UyxhQUFZLENBQUd2UyxnQkFBTSxDQUFDLElBQUksQ0FBQyxDQUVqQyxHQUFNd1MsUUFBTyxDQUFHdEUscUJBQVcsQ0FDekIsU0FBQ3VFLE1BQW9CLENBQUssQ0FDeEIsR0FBTUMsSUFBRyxDQUFHekIsU0FBUyxDQUFDd0IsTUFBTSxDQUFDLENBRTdCLEdBQUksYUFDRixHQUFNRSxjQUFhLENBQUcsTUFBT3hDLFdBQVUsR0FBSyxRQUFRLENBQUdBLFVBQVUsQ0FBRyxFQUFFLENBQ3RFLEdBQU15QyxPQUFNLFVBQUlDLE1BQU0sZUFBUCxRQUFpQkMsRUFBRSxDQUFDQyxTQUFTLENBQ3ZDSixhQUFhLE1BQUtELEdBQUcsQ0FDeEIsQ0FDRU0sR0FBRyxDQUFFLE9BQ1AsQ0FBQyxDQUNGLENBRUQsR0FBSSxDQUFDSixNQUFNLENBQUUsT0FFYixHQUFNNWEsVUFBUyxDQUFHZ1IsS0FBSyxDQUFDUSxZQUFZLENBQUNULGNBQWMsQ0FBQ2pJLE9BQU8sQ0FBQyxDQUM1RCxHQUFJTyxNQUFNLENBQUNDLElBQUksQ0FBQyxDQUFBdEosU0FBUyxjQUFUQSxTQUFTLENBQUVpYixVQUFVLEdBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQzdWLE1BQU0sQ0FBRSxDQUNuRHBGLFNBQVMsY0FBVEEsU0FBUyxDQUFFa2IsSUFBSSxFQUFFLENBQ2pCbGIsU0FBUyxjQUFUQSxTQUFTLENBQUVtYixZQUFZLENBQUMsRUFBRSxDQUFDLENBQzdCLENBRUEsR0FBTUMsV0FBVSxDQUFHcEQsUUFBUSxDQUN6QjRDLE1BQU0sQ0FDTmIsU0FBUyxDQUNUaEosY0FBYyxDQUNkLE1BQU9vSCxXQUFVLEdBQUssUUFBUSxDQUFHL1csU0FBUyxDQUFHK1csVUFBVSxDQUN4RCxDQUVEbUMsc0JBQXNCLENBQUN4UixPQUFPLENBQUcxSCxTQUFTLENBRTFDLEdBQUltWixZQUFZLENBQUN6UixPQUFPLENBQUVzUixTQUFTLENBQUNnQixVQUFVLENBQUMsQ0FDakQsQ0FBRSxNQUFPQyxHQUFHLENBQUUsQ0FDWixHQUFJZCxZQUFZLENBQUN6UixPQUFPLENBQUVzUixTQUFTLENBQUNpQixHQUFHLENBQUNDLE9BQU8sQ0FBQyxDQUVoRCxHQUNFaEIsc0JBQXNCLENBQUN4UixPQUFPLEVBQzlCeVMsSUFBSSxDQUFDQyxHQUFHLEVBQUUsQ0FBR2xCLHNCQUFzQixDQUFDeFIsT0FBTyxDQUFHLElBQUs7QUFBQSxDQUNuRCxDQUNBLE9BQ0YsQ0FFQXVJLE9BQU8sQ0FBQzdCLEtBQUssQ0FBQyxxQkFBcUIsQ0FBRTZMLEdBQUcsQ0FBQyxDQUN6Q2Ysc0JBQXNCLENBQUN4UixPQUFPLENBQUd5UyxJQUFJLENBQUNDLEdBQUcsRUFBRSxDQUM3QyxDQUNGLENBQUMsQ0FDRCxDQUFDMUIsV0FBVyxDQUFFM0IsVUFBVSxDQUFFNEIsU0FBUyxDQUFDLENBQ3JDLENBRUQ7QUFDQTVELG1CQUFTLENBQUMsVUFBTSxDQUNkcUUsT0FBTyxDQUFDbFgsS0FBSyxDQUFDLENBQ2hCLENBQUMsQ0FBRSxDQUFDa1gsT0FBTyxDQUFDLENBQUMsQ0FFYixHQUFNaUIsTUFBSyxjQUNULG9CQUFDLEtBQUssRUFDSixNQUFNLENBQUVySixNQUFPLENBQ2YsUUFBUSxDQUFFLGtCQUFBc0osUUFBUSxDQUFJLENBQ3BCLEdBQUlBLFFBQVEsR0FBS3BZLEtBQUssQ0FBRSxPQUV4QjZXLFFBQVEsQ0FBQ3VCLFFBQVEsQ0FBQyxDQUNsQmxCLE9BQU8sQ0FBQ2tCLFFBQVEsQ0FBQyxDQUNuQixDQUFFLENBQ0YsS0FBSyxDQUFFcFksS0FBTSxlQUViLG9CQUFDLGNBQU8sbUJBQ04sb0JBQUMsTUFBTSxtQkFDTCwyQkFBSyxHQUFHLENBQUswVyxPQUFPLDJCQUEyQixFQUFHLGNBQ2xELG9CQUFDLFVBQVUscUJBQTBCLGNBQ3JDLG9CQUFDLGFBQWEsbUJBQ1osb0JBQUMsVUFBVSxFQUFDLGNBQWMsQ0FBRWpKLGNBQWUsQ0FBQyxLQUFLLENBQUVDLEtBQU0sRUFBRyxjQUM1RCxvQkFBQyxXQUFXLEVBQ1YsT0FBTyxDQUFFLGtCQUFNLENBQ2JtSixRQUFRLENBQUNELFlBQVksQ0FBQyxDQUN0Qk0sT0FBTyxDQUFDTixZQUFZLENBQUMsQ0FDckI5SCxNQUFNLENBQUNoTSxRQUFRLENBQUc4VCxZQUFZLENBQ2hDLENBQUUsVUFHVSxDQUNBLENBQ1QsY0FDVCxvQkFBQyxhQUFhLG1CQUNaLG9CQUFDLE1BQU0sTUFDSjVXLEtBQUssQ0FBQ3ZCLEdBQUcsQ0FBQyxTQUFDNFosQ0FBQyxDQUFFQyxDQUFDLHFCQUNkLDRCQUFNLEdBQUcsQ0FBRUEsQ0FBRSxFQUFFQSxDQUFDLENBQUcsQ0FBQyxDQUFRLEVBQzdCLENBQUMsQ0FDSyxjQUNULG9CQUFDLGNBQWMsRUFDYixRQUFRLENBQUVuRSxRQUFTLENBQ25CLFNBQVMsQ0FBRSxtQkFBQXBGLEtBQUssUUFBSUYsQ0FBQUEscUJBQVMsQ0FBQ0MsTUFBTSxDQUFFQyxLQUFLLENBQUMsRUFBQyxDQUM3QyxXQUFXLENBQUMsb0JBQW9CLENBQ2hDLFVBQVUsQ0FBRXFILFlBQUssQ0FDakIsdUJBQXVCLENBQUV6Rix1QkFBd0IsQ0FDakQsU0FBUyxDQUFFb0csS0FBTSxFQUNqQixDQUNZLGNBQ2hCLG9CQUFDLE1BQU0sbUJBQ0wsb0JBQUMsYUFBYSxNQUFFaFosTUFBTSxDQUFpQixDQUNoQyxDQUNELENBRWIsQ0FFRCxNQUFPMFAsZUFBYyxDQUFDakksT0FBTyxjQUMzQixvQkFBQyxLQUFLLENBQUMsaUJBQWlCLEVBQUMsRUFBRSxDQUFFZ1IsV0FBWSxFQUFFMkIsS0FBSyxDQUEyQixDQUUzRUEsS0FDRCxDQUNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL2lzLXBsYWluLW9iamVjdC9kaXN0L2lzLXBsYWluLW9iamVjdC5tanM/NjBhOCIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL2ltbWVyL2Rpc3QvaW1tZXIuZXNtLm1qcz8zODMwIiwid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvc2xhdGUvZGlzdC9pbmRleC5lcy5qcz83ZjRiIiwid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvc2xhdGUtaGlzdG9yeS9kaXN0L2luZGV4LmVzLmpzPzA0ZjQiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uL25vZGVfbW9kdWxlcy9jb21wdXRlLXNjcm9sbC1pbnRvLXZpZXcvZGlzdC9pbmRleC5tanM/ODk0NiIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL3Njcm9sbC1pbnRvLXZpZXctaWYtbmVlZGVkL2VzL2luZGV4LmpzP2E2OWQiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uL25vZGVfbW9kdWxlcy9zbGF0ZS1yZWFjdC9kaXN0L2luZGV4LmVzLmpzPzRlMjMiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9ub2RlX21vZHVsZXMvaW1tZXIvZGlzdC9pbW1lci5lc20ubWpzPzMzN2YiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9pbW1lci9zcmMvSW1tZXJTdG9yZS50cz8wMDMzIiwid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvaW1tZXIvc3JjL2NyZWF0ZUltbWVyU3RvcmUudHM/MTcwYyIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL2ltbWVyL3NyYy9pbmplY3RJbW1lclN0b3JlLnRzPzgwZTUiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9pbW1lci9zcmMvaW5kZXgudHM/ODJjNyIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL2NvcmUvc3JjL3V0aWxzL2FjdGlvbnMudHM/MGYwNSIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL2NvcmUvc3JjL2FwaS9jcmVhdGVSZWR1Y2VyLnRzP2NlZmUiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9jb3JlL3NyYy9hcGkvTWFjaGluZVN0b3JlLnRzPzkyZjciLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9jb3JlL3NyYy9pbmRleC50cz9mMjYyIiwid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL2ZhY3Rvcmllcy9pb24udHM/MmUwYyIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9pbmplY3RvcnMvaW5qZWN0QXRvbUdldHRlcnMudHM/NmZhMyIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9jbGFzc2VzL2F0b21zL0lvbi50cz9mYzA0Iiwid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL2NsYXNzZXMvWmVkdXhQbHVnaW4udHM/ZTEwZSIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9jbGFzc2VzL2luZGV4LnRzPzUzMzYiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9yZWFjdC9zcmMvY29tcG9uZW50cy9BdG9tSW5zdGFuY2VQcm92aWRlci50c3g/N2Q5ZCIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9jb21wb25lbnRzL0Vjb3N5c3RlbVByb3ZpZGVyLnRzeD9hMDIwIiwid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL2NvbXBvbmVudHMvaW5kZXgudHM/MjFiOSIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9mYWN0b3JpZXMvaW5kZXgudHM/MTg5OCIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9ob29rcy91c2VBdG9tQ29uc3VtZXIudHM/MzhlMCIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9ob29rcy91c2VBdG9tU2VsZWN0b3IudHM/OGUyYSIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9ob29rcy91c2VBdG9tU3RhdGUudHM/M2MzYiIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9ob29rcy91c2VBdG9tVmFsdWUudHM/MDJiOSIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9ob29rcy9pbmRleC50cz82ZTBiIiwid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL2luamVjdG9ycy9pbmplY3RBdG9tSW5zdGFuY2UudHM/NjE5ZSIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9pbmplY3RvcnMvaW5qZWN0QXRvbVNlbGVjdG9yLnRzP2M5NjEiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9yZWFjdC9zcmMvaW5qZWN0b3JzL2luamVjdEF0b21TdGF0ZS50cz9kN2U4Iiwid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL2luamVjdG9ycy9pbmplY3RBdG9tVmFsdWUudHM/YzMzMSIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9pbmplY3RvcnMvaW5qZWN0TWVtby50cz9mYjZkIiwid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL2luamVjdG9ycy9pbmplY3RDYWxsYmFjay50cz9hMDkyIiwid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL2luamVjdG9ycy9pbmplY3RJbnZhbGlkYXRlLnRzP2YwYmIiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9yZWFjdC9zcmMvaW5qZWN0b3JzL2luamVjdE1hY2hpbmVTdG9yZS50cz9jNjViIiwid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL2luamVjdG9ycy9pbmplY3RQcm9taXNlLnRzPzMzZGIiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9yZWFjdC9zcmMvaW5qZWN0b3JzL2luamVjdFdoeS50cz8wYmEzIiwid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL2luamVjdG9ycy9pbmRleC50cz82YWIxIiwid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL2luZGV4LnRzP2Y0ODAiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uL3NyYy90aGVtZS9Db2RlQmxvY2svTG9nQWN0aW9ucy50c3g/ZWRiZCIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vc3JjL3RoZW1lL0NvZGVCbG9jay9lZGl0b3JVdGlscy50cz9mM2UwIiwid2VicGFjazovL3plZHV4LWRvY3MvLi9zcmMvdGhlbWUvQ29kZUJsb2NrL3N0eWxlcy50cz8xNmQ2Iiwid2VicGFjazovL3plZHV4LWRvY3MvLi9zcmMvdGhlbWUvQ29kZUJsb2NrL1NhbmRib3gudHN4P2UyOWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBpcy1wbGFpbi1vYmplY3QgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLXBsYWluLW9iamVjdD5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNywgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuZnVuY3Rpb24gaXNPYmplY3Qobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gIHZhciBjdG9yLHByb3Q7XG5cbiAgaWYgKGlzT2JqZWN0KG8pID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIGhhcyBtb2RpZmllZCBjb25zdHJ1Y3RvclxuICBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgaWYgKGN0b3IgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG5cbiAgLy8gSWYgaGFzIG1vZGlmaWVkIHByb3RvdHlwZVxuICBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gIGlmIChpc09iamVjdChwcm90KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiBjb25zdHJ1Y3RvciBkb2VzIG5vdCBoYXZlIGFuIE9iamVjdC1zcGVjaWZpYyBtZXRob2RcbiAgaWYgKHByb3QuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBNb3N0IGxpa2VseSBhIHBsYWluIE9iamVjdFxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgaXNQbGFpbk9iamVjdCB9O1xuIiwiZnVuY3Rpb24gbihuKXtmb3IodmFyIHI9YXJndW1lbnRzLmxlbmd0aCx0PUFycmF5KHI+MT9yLTE6MCksZT0xO2U8cjtlKyspdFtlLTFdPWFyZ3VtZW50c1tlXTtpZihcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WKXt2YXIgaT1ZW25dLG89aT9cImZ1bmN0aW9uXCI9PXR5cGVvZiBpP2kuYXBwbHkobnVsbCx0KTppOlwidW5rbm93biBlcnJvciBucjogXCIrbjt0aHJvdyBFcnJvcihcIltJbW1lcl0gXCIrbyl9dGhyb3cgRXJyb3IoXCJbSW1tZXJdIG1pbmlmaWVkIGVycm9yIG5yOiBcIituKyh0Lmxlbmd0aD9cIiBcIit0Lm1hcCgoZnVuY3Rpb24obil7cmV0dXJuXCInXCIrbitcIidcIn0pKS5qb2luKFwiLFwiKTpcIlwiKStcIi4gRmluZCB0aGUgZnVsbCBlcnJvciBhdDogaHR0cHM6Ly9iaXQubHkvM2NYRUtXZlwiKX1mdW5jdGlvbiByKG4pe3JldHVybiEhbiYmISFuW1FdfWZ1bmN0aW9uIHQobil7dmFyIHI7cmV0dXJuISFuJiYoZnVuY3Rpb24obil7aWYoIW58fFwib2JqZWN0XCIhPXR5cGVvZiBuKXJldHVybiExO3ZhciByPU9iamVjdC5nZXRQcm90b3R5cGVPZihuKTtpZihudWxsPT09cilyZXR1cm4hMDt2YXIgdD1PYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChyLFwiY29uc3RydWN0b3JcIikmJnIuY29uc3RydWN0b3I7cmV0dXJuIHQ9PT1PYmplY3R8fFwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJkZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwodCk9PT1afShuKXx8QXJyYXkuaXNBcnJheShuKXx8ISFuW0xdfHwhIShudWxsPT09KHI9bi5jb25zdHJ1Y3Rvcil8fHZvaWQgMD09PXI/dm9pZCAwOnJbTF0pfHxzKG4pfHx2KG4pKX1mdW5jdGlvbiBlKHQpe3JldHVybiByKHQpfHxuKDIzLHQpLHRbUV0udH1mdW5jdGlvbiBpKG4scix0KXt2b2lkIDA9PT10JiYodD0hMSksMD09PW8obik/KHQ/T2JqZWN0LmtleXM6bm4pKG4pLmZvckVhY2goKGZ1bmN0aW9uKGUpe3QmJlwic3ltYm9sXCI9PXR5cGVvZiBlfHxyKGUsbltlXSxuKX0pKTpuLmZvckVhY2goKGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIoZSx0LG4pfSkpfWZ1bmN0aW9uIG8obil7dmFyIHI9bltRXTtyZXR1cm4gcj9yLmk+Mz9yLmktNDpyLmk6QXJyYXkuaXNBcnJheShuKT8xOnMobik/Mjp2KG4pPzM6MH1mdW5jdGlvbiB1KG4scil7cmV0dXJuIDI9PT1vKG4pP24uaGFzKHIpOk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLHIpfWZ1bmN0aW9uIGEobixyKXtyZXR1cm4gMj09PW8obik/bi5nZXQocik6bltyXX1mdW5jdGlvbiBmKG4scix0KXt2YXIgZT1vKG4pOzI9PT1lP24uc2V0KHIsdCk6Mz09PWU/KG4uZGVsZXRlKHIpLG4uYWRkKHQpKTpuW3JdPXR9ZnVuY3Rpb24gYyhuLHIpe3JldHVybiBuPT09cj8wIT09bnx8MS9uPT0xL3I6biE9biYmciE9cn1mdW5jdGlvbiBzKG4pe3JldHVybiBYJiZuIGluc3RhbmNlb2YgTWFwfWZ1bmN0aW9uIHYobil7cmV0dXJuIHEmJm4gaW5zdGFuY2VvZiBTZXR9ZnVuY3Rpb24gcChuKXtyZXR1cm4gbi5vfHxuLnR9ZnVuY3Rpb24gbChuKXtpZihBcnJheS5pc0FycmF5KG4pKXJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChuKTt2YXIgcj1ybihuKTtkZWxldGUgcltRXTtmb3IodmFyIHQ9bm4ociksZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgaT10W2VdLG89cltpXTshMT09PW8ud3JpdGFibGUmJihvLndyaXRhYmxlPSEwLG8uY29uZmlndXJhYmxlPSEwKSwoby5nZXR8fG8uc2V0KSYmKHJbaV09e2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCxlbnVtZXJhYmxlOm8uZW51bWVyYWJsZSx2YWx1ZTpuW2ldfSl9cmV0dXJuIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pLHIpfWZ1bmN0aW9uIGQobixlKXtyZXR1cm4gdm9pZCAwPT09ZSYmKGU9ITEpLHkobil8fHIobil8fCF0KG4pP246KG8obik+MSYmKG4uc2V0PW4uYWRkPW4uY2xlYXI9bi5kZWxldGU9aCksT2JqZWN0LmZyZWV6ZShuKSxlJiZpKG4sKGZ1bmN0aW9uKG4scil7cmV0dXJuIGQociwhMCl9KSwhMCksbil9ZnVuY3Rpb24gaCgpe24oMil9ZnVuY3Rpb24geShuKXtyZXR1cm4gbnVsbD09bnx8XCJvYmplY3RcIiE9dHlwZW9mIG58fE9iamVjdC5pc0Zyb3plbihuKX1mdW5jdGlvbiBiKHIpe3ZhciB0PXRuW3JdO3JldHVybiB0fHxuKDE4LHIpLHR9ZnVuY3Rpb24gbShuLHIpe3RuW25dfHwodG5bbl09cil9ZnVuY3Rpb24gXygpe3JldHVyblwicHJvZHVjdGlvblwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlZ8fFV8fG4oMCksVX1mdW5jdGlvbiBqKG4scil7ciYmKGIoXCJQYXRjaGVzXCIpLG4udT1bXSxuLnM9W10sbi52PXIpfWZ1bmN0aW9uIE8obil7ZyhuKSxuLnAuZm9yRWFjaChTKSxuLnA9bnVsbH1mdW5jdGlvbiBnKG4pe249PT1VJiYoVT1uLmwpfWZ1bmN0aW9uIHcobil7cmV0dXJuIFU9e3A6W10sbDpVLGg6bixtOiEwLF86MH19ZnVuY3Rpb24gUyhuKXt2YXIgcj1uW1FdOzA9PT1yLml8fDE9PT1yLmk/ci5qKCk6ci5PPSEwfWZ1bmN0aW9uIFAocixlKXtlLl89ZS5wLmxlbmd0aDt2YXIgaT1lLnBbMF0sbz12b2lkIDAhPT1yJiZyIT09aTtyZXR1cm4gZS5oLmd8fGIoXCJFUzVcIikuUyhlLHIsbyksbz8oaVtRXS5QJiYoTyhlKSxuKDQpKSx0KHIpJiYocj1NKGUsciksZS5sfHx4KGUscikpLGUudSYmYihcIlBhdGNoZXNcIikuTShpW1FdLnQscixlLnUsZS5zKSk6cj1NKGUsaSxbXSksTyhlKSxlLnUmJmUudihlLnUsZS5zKSxyIT09SD9yOnZvaWQgMH1mdW5jdGlvbiBNKG4scix0KXtpZih5KHIpKXJldHVybiByO3ZhciBlPXJbUV07aWYoIWUpcmV0dXJuIGkociwoZnVuY3Rpb24oaSxvKXtyZXR1cm4gQShuLGUscixpLG8sdCl9KSwhMCkscjtpZihlLkEhPT1uKXJldHVybiByO2lmKCFlLlApcmV0dXJuIHgobixlLnQsITApLGUudDtpZighZS5JKXtlLkk9ITAsZS5BLl8tLTt2YXIgbz00PT09ZS5pfHw1PT09ZS5pP2Uubz1sKGUuayk6ZS5vO2koMz09PWUuaT9uZXcgU2V0KG8pOm8sKGZ1bmN0aW9uKHIsaSl7cmV0dXJuIEEobixlLG8scixpLHQpfSkpLHgobixvLCExKSx0JiZuLnUmJmIoXCJQYXRjaGVzXCIpLlIoZSx0LG4udSxuLnMpfXJldHVybiBlLm99ZnVuY3Rpb24gQShlLGksbyxhLGMscyl7aWYoXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmYz09PW8mJm4oNSkscihjKSl7dmFyIHY9TShlLGMscyYmaSYmMyE9PWkuaSYmIXUoaS5ELGEpP3MuY29uY2F0KGEpOnZvaWQgMCk7aWYoZihvLGEsdiksIXIodikpcmV0dXJuO2UubT0hMX1pZih0KGMpJiYheShjKSl7aWYoIWUuaC5GJiZlLl88MSlyZXR1cm47TShlLGMpLGkmJmkuQS5sfHx4KGUsYyl9fWZ1bmN0aW9uIHgobixyLHQpe3ZvaWQgMD09PXQmJih0PSExKSxuLmguRiYmbi5tJiZkKHIsdCl9ZnVuY3Rpb24geihuLHIpe3ZhciB0PW5bUV07cmV0dXJuKHQ/cCh0KTpuKVtyXX1mdW5jdGlvbiBJKG4scil7aWYociBpbiBuKWZvcih2YXIgdD1PYmplY3QuZ2V0UHJvdG90eXBlT2Yobik7dDspe3ZhciBlPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxyKTtpZihlKXJldHVybiBlO3Q9T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpfX1mdW5jdGlvbiBrKG4pe24uUHx8KG4uUD0hMCxuLmwmJmsobi5sKSl9ZnVuY3Rpb24gRShuKXtuLm98fChuLm89bChuLnQpKX1mdW5jdGlvbiBSKG4scix0KXt2YXIgZT1zKHIpP2IoXCJNYXBTZXRcIikuTihyLHQpOnYocik/YihcIk1hcFNldFwiKS5UKHIsdCk6bi5nP2Z1bmN0aW9uKG4scil7dmFyIHQ9QXJyYXkuaXNBcnJheShuKSxlPXtpOnQ/MTowLEE6cj9yLkE6XygpLFA6ITEsSTohMSxEOnt9LGw6cix0Om4sazpudWxsLG86bnVsbCxqOm51bGwsQzohMX0saT1lLG89ZW47dCYmKGk9W2VdLG89b24pO3ZhciB1PVByb3h5LnJldm9jYWJsZShpLG8pLGE9dS5yZXZva2UsZj11LnByb3h5O3JldHVybiBlLms9ZixlLmo9YSxmfShyLHQpOmIoXCJFUzVcIikuSihyLHQpO3JldHVybih0P3QuQTpfKCkpLnAucHVzaChlKSxlfWZ1bmN0aW9uIEQoZSl7cmV0dXJuIHIoZSl8fG4oMjIsZSksZnVuY3Rpb24gbihyKXtpZighdChyKSlyZXR1cm4gcjt2YXIgZSx1PXJbUV0sYz1vKHIpO2lmKHUpe2lmKCF1LlAmJih1Lmk8NHx8IWIoXCJFUzVcIikuSyh1KSkpcmV0dXJuIHUudDt1Lkk9ITAsZT1GKHIsYyksdS5JPSExfWVsc2UgZT1GKHIsYyk7cmV0dXJuIGkoZSwoZnVuY3Rpb24ocix0KXt1JiZhKHUudCxyKT09PXR8fGYoZSxyLG4odCkpfSkpLDM9PT1jP25ldyBTZXQoZSk6ZX0oZSl9ZnVuY3Rpb24gRihuLHIpe3N3aXRjaChyKXtjYXNlIDI6cmV0dXJuIG5ldyBNYXAobik7Y2FzZSAzOnJldHVybiBBcnJheS5mcm9tKG4pfXJldHVybiBsKG4pfWZ1bmN0aW9uIE4oKXtmdW5jdGlvbiB0KG4scil7dmFyIHQ9c1tuXTtyZXR1cm4gdD90LmVudW1lcmFibGU9cjpzW25dPXQ9e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOnIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHI9dGhpc1tRXTtyZXR1cm5cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZmKHIpLGVuLmdldChyLG4pfSxzZXQ6ZnVuY3Rpb24ocil7dmFyIHQ9dGhpc1tRXTtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZmKHQpLGVuLnNldCh0LG4scil9fSx0fWZ1bmN0aW9uIGUobil7Zm9yKHZhciByPW4ubGVuZ3RoLTE7cj49MDtyLS0pe3ZhciB0PW5bcl1bUV07aWYoIXQuUClzd2l0Y2godC5pKXtjYXNlIDU6YSh0KSYmayh0KTticmVhaztjYXNlIDQ6byh0KSYmayh0KX19fWZ1bmN0aW9uIG8obil7Zm9yKHZhciByPW4udCx0PW4uayxlPW5uKHQpLGk9ZS5sZW5ndGgtMTtpPj0wO2ktLSl7dmFyIG89ZVtpXTtpZihvIT09USl7dmFyIGE9cltvXTtpZih2b2lkIDA9PT1hJiYhdShyLG8pKXJldHVybiEwO3ZhciBmPXRbb10scz1mJiZmW1FdO2lmKHM/cy50IT09YTohYyhmLGEpKXJldHVybiEwfX12YXIgdj0hIXJbUV07cmV0dXJuIGUubGVuZ3RoIT09bm4ocikubGVuZ3RoKyh2PzA6MSl9ZnVuY3Rpb24gYShuKXt2YXIgcj1uLms7aWYoci5sZW5ndGghPT1uLnQubGVuZ3RoKXJldHVybiEwO3ZhciB0PU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocixyLmxlbmd0aC0xKTtpZih0JiYhdC5nZXQpcmV0dXJuITA7Zm9yKHZhciBlPTA7ZTxyLmxlbmd0aDtlKyspaWYoIXIuaGFzT3duUHJvcGVydHkoZSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gZihyKXtyLk8mJm4oMyxKU09OLnN0cmluZ2lmeShwKHIpKSl9dmFyIHM9e307bShcIkVTNVwiLHtKOmZ1bmN0aW9uKG4scil7dmFyIGU9QXJyYXkuaXNBcnJheShuKSxpPWZ1bmN0aW9uKG4scil7aWYobil7Zm9yKHZhciBlPUFycmF5KHIubGVuZ3RoKSxpPTA7aTxyLmxlbmd0aDtpKyspT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJcIitpLHQoaSwhMCkpO3JldHVybiBlfXZhciBvPXJuKHIpO2RlbGV0ZSBvW1FdO2Zvcih2YXIgdT1ubihvKSxhPTA7YTx1Lmxlbmd0aDthKyspe3ZhciBmPXVbYV07b1tmXT10KGYsbnx8ISFvW2ZdLmVudW1lcmFibGUpfXJldHVybiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihyKSxvKX0oZSxuKSxvPXtpOmU/NTo0LEE6cj9yLkE6XygpLFA6ITEsSTohMSxEOnt9LGw6cix0Om4sazppLG86bnVsbCxPOiExLEM6ITF9O3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSxRLHt2YWx1ZTpvLHdyaXRhYmxlOiEwfSksaX0sUzpmdW5jdGlvbihuLHQsbyl7bz9yKHQpJiZ0W1FdLkE9PT1uJiZlKG4ucCk6KG4udSYmZnVuY3Rpb24gbihyKXtpZihyJiZcIm9iamVjdFwiPT10eXBlb2Ygcil7dmFyIHQ9cltRXTtpZih0KXt2YXIgZT10LnQsbz10LmssZj10LkQsYz10Lmk7aWYoND09PWMpaShvLChmdW5jdGlvbihyKXtyIT09USYmKHZvaWQgMCE9PWVbcl18fHUoZSxyKT9mW3JdfHxuKG9bcl0pOihmW3JdPSEwLGsodCkpKX0pKSxpKGUsKGZ1bmN0aW9uKG4pe3ZvaWQgMCE9PW9bbl18fHUobyxuKXx8KGZbbl09ITEsayh0KSl9KSk7ZWxzZSBpZig1PT09Yyl7aWYoYSh0KSYmKGsodCksZi5sZW5ndGg9ITApLG8ubGVuZ3RoPGUubGVuZ3RoKWZvcih2YXIgcz1vLmxlbmd0aDtzPGUubGVuZ3RoO3MrKylmW3NdPSExO2Vsc2UgZm9yKHZhciB2PWUubGVuZ3RoO3Y8by5sZW5ndGg7disrKWZbdl09ITA7Zm9yKHZhciBwPU1hdGgubWluKG8ubGVuZ3RoLGUubGVuZ3RoKSxsPTA7bDxwO2wrKylvLmhhc093blByb3BlcnR5KGwpfHwoZltsXT0hMCksdm9pZCAwPT09ZltsXSYmbihvW2xdKX19fX0obi5wWzBdKSxlKG4ucCkpfSxLOmZ1bmN0aW9uKG4pe3JldHVybiA0PT09bi5pP28obik6YShuKX19KX1mdW5jdGlvbiBUKCl7ZnVuY3Rpb24gZShuKXtpZighdChuKSlyZXR1cm4gbjtpZihBcnJheS5pc0FycmF5KG4pKXJldHVybiBuLm1hcChlKTtpZihzKG4pKXJldHVybiBuZXcgTWFwKEFycmF5LmZyb20obi5lbnRyaWVzKCkpLm1hcCgoZnVuY3Rpb24obil7cmV0dXJuW25bMF0sZShuWzFdKV19KSkpO2lmKHYobikpcmV0dXJuIG5ldyBTZXQoQXJyYXkuZnJvbShuKS5tYXAoZSkpO3ZhciByPU9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pKTtmb3IodmFyIGkgaW4gbilyW2ldPWUobltpXSk7cmV0dXJuIHUobixMKSYmKHJbTF09bltMXSkscn1mdW5jdGlvbiBmKG4pe3JldHVybiByKG4pP2Uobik6bn12YXIgYz1cImFkZFwiO20oXCJQYXRjaGVzXCIseyQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXtmb3IodmFyIGk9dC5wYXRoLHU9dC5vcCxmPXIscz0wO3M8aS5sZW5ndGgtMTtzKyspe3ZhciB2PW8oZikscD1cIlwiK2lbc107MCE9PXYmJjEhPT12fHxcIl9fcHJvdG9fX1wiIT09cCYmXCJjb25zdHJ1Y3RvclwiIT09cHx8bigyNCksXCJmdW5jdGlvblwiPT10eXBlb2YgZiYmXCJwcm90b3R5cGVcIj09PXAmJm4oMjQpLFwib2JqZWN0XCIhPXR5cGVvZihmPWEoZixwKSkmJm4oMTUsaS5qb2luKFwiL1wiKSl9dmFyIGw9byhmKSxkPWUodC52YWx1ZSksaD1pW2kubGVuZ3RoLTFdO3N3aXRjaCh1KXtjYXNlXCJyZXBsYWNlXCI6c3dpdGNoKGwpe2Nhc2UgMjpyZXR1cm4gZi5zZXQoaCxkKTtjYXNlIDM6bigxNik7ZGVmYXVsdDpyZXR1cm4gZltoXT1kfWNhc2UgYzpzd2l0Y2gobCl7Y2FzZSAxOnJldHVyblwiLVwiPT09aD9mLnB1c2goZCk6Zi5zcGxpY2UoaCwwLGQpO2Nhc2UgMjpyZXR1cm4gZi5zZXQoaCxkKTtjYXNlIDM6cmV0dXJuIGYuYWRkKGQpO2RlZmF1bHQ6cmV0dXJuIGZbaF09ZH1jYXNlXCJyZW1vdmVcIjpzd2l0Y2gobCl7Y2FzZSAxOnJldHVybiBmLnNwbGljZShoLDEpO2Nhc2UgMjpyZXR1cm4gZi5kZWxldGUoaCk7Y2FzZSAzOnJldHVybiBmLmRlbGV0ZSh0LnZhbHVlKTtkZWZhdWx0OnJldHVybiBkZWxldGUgZltoXX1kZWZhdWx0Om4oMTcsdSl9fSkpLHJ9LFI6ZnVuY3Rpb24obixyLHQsZSl7c3dpdGNoKG4uaSl7Y2FzZSAwOmNhc2UgNDpjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKG4scix0LGUpe3ZhciBvPW4udCxzPW4ubztpKG4uRCwoZnVuY3Rpb24obixpKXt2YXIgdj1hKG8sbikscD1hKHMsbiksbD1pP3UobyxuKT9cInJlcGxhY2VcIjpjOlwicmVtb3ZlXCI7aWYodiE9PXB8fFwicmVwbGFjZVwiIT09bCl7dmFyIGQ9ci5jb25jYXQobik7dC5wdXNoKFwicmVtb3ZlXCI9PT1sP3tvcDpsLHBhdGg6ZH06e29wOmwscGF0aDpkLHZhbHVlOnB9KSxlLnB1c2gobD09PWM/e29wOlwicmVtb3ZlXCIscGF0aDpkfTpcInJlbW92ZVwiPT09bD97b3A6YyxwYXRoOmQsdmFsdWU6Zih2KX06e29wOlwicmVwbGFjZVwiLHBhdGg6ZCx2YWx1ZTpmKHYpfSl9fSkpfShuLHIsdCxlKTtjYXNlIDU6Y2FzZSAxOnJldHVybiBmdW5jdGlvbihuLHIsdCxlKXt2YXIgaT1uLnQsbz1uLkQsdT1uLm87aWYodS5sZW5ndGg8aS5sZW5ndGgpe3ZhciBhPVt1LGldO2k9YVswXSx1PWFbMV07dmFyIHM9W2UsdF07dD1zWzBdLGU9c1sxXX1mb3IodmFyIHY9MDt2PGkubGVuZ3RoO3YrKylpZihvW3ZdJiZ1W3ZdIT09aVt2XSl7dmFyIHA9ci5jb25jYXQoW3ZdKTt0LnB1c2goe29wOlwicmVwbGFjZVwiLHBhdGg6cCx2YWx1ZTpmKHVbdl0pfSksZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOnAsdmFsdWU6ZihpW3ZdKX0pfWZvcih2YXIgbD1pLmxlbmd0aDtsPHUubGVuZ3RoO2wrKyl7dmFyIGQ9ci5jb25jYXQoW2xdKTt0LnB1c2goe29wOmMscGF0aDpkLHZhbHVlOmYodVtsXSl9KX1pLmxlbmd0aDx1Lmxlbmd0aCYmZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOnIuY29uY2F0KFtcImxlbmd0aFwiXSksdmFsdWU6aS5sZW5ndGh9KX0obixyLHQsZSk7Y2FzZSAzOnJldHVybiBmdW5jdGlvbihuLHIsdCxlKXt2YXIgaT1uLnQsbz1uLm8sdT0wO2kuZm9yRWFjaCgoZnVuY3Rpb24obil7aWYoIW8uaGFzKG4pKXt2YXIgaT1yLmNvbmNhdChbdV0pO3QucHVzaCh7b3A6XCJyZW1vdmVcIixwYXRoOmksdmFsdWU6bn0pLGUudW5zaGlmdCh7b3A6YyxwYXRoOmksdmFsdWU6bn0pfXUrK30pKSx1PTAsby5mb3JFYWNoKChmdW5jdGlvbihuKXtpZighaS5oYXMobikpe3ZhciBvPXIuY29uY2F0KFt1XSk7dC5wdXNoKHtvcDpjLHBhdGg6byx2YWx1ZTpufSksZS51bnNoaWZ0KHtvcDpcInJlbW92ZVwiLHBhdGg6byx2YWx1ZTpufSl9dSsrfSkpfShuLHIsdCxlKX19LE06ZnVuY3Rpb24obixyLHQsZSl7dC5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOltdLHZhbHVlOnI9PT1IP3ZvaWQgMDpyfSksZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOltdLHZhbHVlOm59KX19KX1mdW5jdGlvbiBDKCl7ZnVuY3Rpb24gcihuLHIpe2Z1bmN0aW9uIHQoKXt0aGlzLmNvbnN0cnVjdG9yPW59YShuLHIpLG4ucHJvdG90eXBlPSh0LnByb3RvdHlwZT1yLnByb3RvdHlwZSxuZXcgdCl9ZnVuY3Rpb24gZShuKXtuLm98fChuLkQ9bmV3IE1hcCxuLm89bmV3IE1hcChuLnQpKX1mdW5jdGlvbiBvKG4pe24ub3x8KG4ubz1uZXcgU2V0LG4udC5mb3JFYWNoKChmdW5jdGlvbihyKXtpZih0KHIpKXt2YXIgZT1SKG4uQS5oLHIsbik7bi5wLnNldChyLGUpLG4uby5hZGQoZSl9ZWxzZSBuLm8uYWRkKHIpfSkpKX1mdW5jdGlvbiB1KHIpe3IuTyYmbigzLEpTT04uc3RyaW5naWZ5KHAocikpKX12YXIgYT1mdW5jdGlvbihuLHIpe3JldHVybihhPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihuLHIpe24uX19wcm90b19fPXJ9fHxmdW5jdGlvbihuLHIpe2Zvcih2YXIgdCBpbiByKXIuaGFzT3duUHJvcGVydHkodCkmJihuW3RdPXJbdF0pfSkobixyKX0sZj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4obixyKXtyZXR1cm4gdGhpc1tRXT17aToyLGw6cixBOnI/ci5BOl8oKSxQOiExLEk6ITEsbzp2b2lkIDAsRDp2b2lkIDAsdDpuLGs6dGhpcyxDOiExLE86ITF9LHRoaXN9cihuLE1hcCk7dmFyIG89bi5wcm90b3R5cGU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLFwic2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5zaXplfX0pLG8uaGFzPWZ1bmN0aW9uKG4pe3JldHVybiBwKHRoaXNbUV0pLmhhcyhuKX0sby5zZXQ9ZnVuY3Rpb24obixyKXt2YXIgdD10aGlzW1FdO3JldHVybiB1KHQpLHAodCkuaGFzKG4pJiZwKHQpLmdldChuKT09PXJ8fChlKHQpLGsodCksdC5ELnNldChuLCEwKSx0Lm8uc2V0KG4sciksdC5ELnNldChuLCEwKSksdGhpc30sby5kZWxldGU9ZnVuY3Rpb24obil7aWYoIXRoaXMuaGFzKG4pKXJldHVybiExO3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksZShyKSxrKHIpLHIudC5oYXMobik/ci5ELnNldChuLCExKTpyLkQuZGVsZXRlKG4pLHIuby5kZWxldGUobiksITB9LG8uY2xlYXI9ZnVuY3Rpb24oKXt2YXIgbj10aGlzW1FdO3UobikscChuKS5zaXplJiYoZShuKSxrKG4pLG4uRD1uZXcgTWFwLGkobi50LChmdW5jdGlvbihyKXtuLkQuc2V0KHIsITEpfSkpLG4uby5jbGVhcigpKX0sby5mb3JFYWNoPWZ1bmN0aW9uKG4scil7dmFyIHQ9dGhpcztwKHRoaXNbUV0pLmZvckVhY2goKGZ1bmN0aW9uKGUsaSl7bi5jYWxsKHIsdC5nZXQoaSksaSx0KX0pKX0sby5nZXQ9ZnVuY3Rpb24obil7dmFyIHI9dGhpc1tRXTt1KHIpO3ZhciBpPXAocikuZ2V0KG4pO2lmKHIuSXx8IXQoaSkpcmV0dXJuIGk7aWYoaSE9PXIudC5nZXQobikpcmV0dXJuIGk7dmFyIG89UihyLkEuaCxpLHIpO3JldHVybiBlKHIpLHIuby5zZXQobixvKSxvfSxvLmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5rZXlzKCl9LG8udmFsdWVzPWZ1bmN0aW9uKCl7dmFyIG4scj10aGlzLHQ9dGhpcy5rZXlzKCk7cmV0dXJuKG49e30pW1ZdPWZ1bmN0aW9uKCl7cmV0dXJuIHIudmFsdWVzKCl9LG4ubmV4dD1mdW5jdGlvbigpe3ZhciBuPXQubmV4dCgpO3JldHVybiBuLmRvbmU/bjp7ZG9uZTohMSx2YWx1ZTpyLmdldChuLnZhbHVlKX19LG59LG8uZW50cmllcz1mdW5jdGlvbigpe3ZhciBuLHI9dGhpcyx0PXRoaXMua2V5cygpO3JldHVybihuPXt9KVtWXT1mdW5jdGlvbigpe3JldHVybiByLmVudHJpZXMoKX0sbi5uZXh0PWZ1bmN0aW9uKCl7dmFyIG49dC5uZXh0KCk7aWYobi5kb25lKXJldHVybiBuO3ZhciBlPXIuZ2V0KG4udmFsdWUpO3JldHVybntkb25lOiExLHZhbHVlOltuLnZhbHVlLGVdfX0sbn0sb1tWXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVudHJpZXMoKX0sbn0oKSxjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuLHIpe3JldHVybiB0aGlzW1FdPXtpOjMsbDpyLEE6cj9yLkE6XygpLFA6ITEsSTohMSxvOnZvaWQgMCx0Om4sazp0aGlzLHA6bmV3IE1hcCxPOiExLEM6ITF9LHRoaXN9cihuLFNldCk7dmFyIHQ9bi5wcm90b3R5cGU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwic2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5zaXplfX0pLHQuaGFzPWZ1bmN0aW9uKG4pe3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksci5vPyEhci5vLmhhcyhuKXx8ISghci5wLmhhcyhuKXx8IXIuby5oYXMoci5wLmdldChuKSkpOnIudC5oYXMobil9LHQuYWRkPWZ1bmN0aW9uKG4pe3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksdGhpcy5oYXMobil8fChvKHIpLGsociksci5vLmFkZChuKSksdGhpc30sdC5kZWxldGU9ZnVuY3Rpb24obil7aWYoIXRoaXMuaGFzKG4pKXJldHVybiExO3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksbyhyKSxrKHIpLHIuby5kZWxldGUobil8fCEhci5wLmhhcyhuKSYmci5vLmRlbGV0ZShyLnAuZ2V0KG4pKX0sdC5jbGVhcj1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07dShuKSxwKG4pLnNpemUmJihvKG4pLGsobiksbi5vLmNsZWFyKCkpfSx0LnZhbHVlcz1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07cmV0dXJuIHUobiksbyhuKSxuLm8udmFsdWVzKCl9LHQuZW50cmllcz1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07cmV0dXJuIHUobiksbyhuKSxuLm8uZW50cmllcygpfSx0LmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZXMoKX0sdFtWXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlcygpfSx0LmZvckVhY2g9ZnVuY3Rpb24obixyKXtmb3IodmFyIHQ9dGhpcy52YWx1ZXMoKSxlPXQubmV4dCgpOyFlLmRvbmU7KW4uY2FsbChyLGUudmFsdWUsZS52YWx1ZSx0aGlzKSxlPXQubmV4dCgpfSxufSgpO20oXCJNYXBTZXRcIix7TjpmdW5jdGlvbihuLHIpe3JldHVybiBuZXcgZihuLHIpfSxUOmZ1bmN0aW9uKG4scil7cmV0dXJuIG5ldyBjKG4scil9fSl9ZnVuY3Rpb24gSigpe04oKSxDKCksVCgpfWZ1bmN0aW9uIEsobil7cmV0dXJuIG59ZnVuY3Rpb24gJChuKXtyZXR1cm4gbn12YXIgRyxVLFc9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbChcInhcIiksWD1cInVuZGVmaW5lZFwiIT10eXBlb2YgTWFwLHE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNldCxCPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm94eSYmdm9pZCAwIT09UHJveHkucmV2b2NhYmxlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCxIPVc/U3ltYm9sLmZvcihcImltbWVyLW5vdGhpbmdcIik6KChHPXt9KVtcImltbWVyLW5vdGhpbmdcIl09ITAsRyksTD1XP1N5bWJvbC5mb3IoXCJpbW1lci1kcmFmdGFibGVcIik6XCJfXyRpbW1lcl9kcmFmdGFibGVcIixRPVc/U3ltYm9sLmZvcihcImltbWVyLXN0YXRlXCIpOlwiX18kaW1tZXJfc3RhdGVcIixWPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcnx8XCJAQGl0ZXJhdG9yXCIsWT17MDpcIklsbGVnYWwgc3RhdGVcIiwxOlwiSW1tZXIgZHJhZnRzIGNhbm5vdCBoYXZlIGNvbXB1dGVkIHByb3BlcnRpZXNcIiwyOlwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIiwzOmZ1bmN0aW9uKG4pe3JldHVyblwiQ2Fubm90IHVzZSBhIHByb3h5IHRoYXQgaGFzIGJlZW4gcmV2b2tlZC4gRGlkIHlvdSBwYXNzIGFuIG9iamVjdCBmcm9tIGluc2lkZSBhbiBpbW1lciBmdW5jdGlvbiB0byBhbiBhc3luYyBwcm9jZXNzPyBcIitufSw0OlwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIiw1OlwiSW1tZXIgZm9yYmlkcyBjaXJjdWxhciByZWZlcmVuY2VzXCIsNjpcIlRoZSBmaXJzdCBvciBzZWNvbmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvblwiLDc6XCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIiw4OlwiRmlyc3QgYXJndW1lbnQgdG8gYGNyZWF0ZURyYWZ0YCBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LCBhbiBhcnJheSwgb3IgYW4gaW1tZXJhYmxlIG9iamVjdFwiLDk6XCJGaXJzdCBhcmd1bWVudCB0byBgZmluaXNoRHJhZnRgIG11c3QgYmUgYSBkcmFmdCByZXR1cm5lZCBieSBgY3JlYXRlRHJhZnRgXCIsMTA6XCJUaGUgZ2l2ZW4gZHJhZnQgaXMgYWxyZWFkeSBmaW5hbGl6ZWRcIiwxMTpcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsMTI6XCJPYmplY3Quc2V0UHJvdG90eXBlT2YoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLDEzOlwiSW1tZXIgb25seSBzdXBwb3J0cyBkZWxldGluZyBhcnJheSBpbmRpY2VzXCIsMTQ6XCJJbW1lciBvbmx5IHN1cHBvcnRzIHNldHRpbmcgYXJyYXkgaW5kaWNlcyBhbmQgdGhlICdsZW5ndGgnIHByb3BlcnR5XCIsMTU6ZnVuY3Rpb24obil7cmV0dXJuXCJDYW5ub3QgYXBwbHkgcGF0Y2gsIHBhdGggZG9lc24ndCByZXNvbHZlOiBcIitufSwxNjonU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicsMTc6ZnVuY3Rpb24obil7cmV0dXJuXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiK259LDE4OmZ1bmN0aW9uKG4pe3JldHVyblwiVGhlIHBsdWdpbiBmb3IgJ1wiK24rXCInIGhhcyBub3QgYmVlbiBsb2FkZWQgaW50byBJbW1lci4gVG8gZW5hYmxlIHRoZSBwbHVnaW4sIGltcG9ydCBhbmQgY2FsbCBgZW5hYmxlXCIrbitcIigpYCB3aGVuIGluaXRpYWxpemluZyB5b3VyIGFwcGxpY2F0aW9uLlwifSwyMDpcIkNhbm5vdCB1c2UgcHJveGllcyBpZiBQcm94eSwgUHJveHkucmV2b2NhYmxlIG9yIFJlZmxlY3QgYXJlIG5vdCBhdmFpbGFibGVcIiwyMTpmdW5jdGlvbihuKXtyZXR1cm5cInByb2R1Y2UgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoaW5ncyB0aGF0IGFyZSBkcmFmdGFibGU6IHBsYWluIG9iamVjdHMsIGFycmF5cywgTWFwLCBTZXQgb3IgY2xhc3NlcyB0aGF0IGFyZSBtYXJrZWQgd2l0aCAnW2ltbWVyYWJsZV06IHRydWUnLiBHb3QgJ1wiK24rXCInXCJ9LDIyOmZ1bmN0aW9uKG4pe3JldHVyblwiJ2N1cnJlbnQnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiBcIitufSwyMzpmdW5jdGlvbihuKXtyZXR1cm5cIidvcmlnaW5hbCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6IFwiK259LDI0OlwiUGF0Y2hpbmcgcmVzZXJ2ZWQgYXR0cmlidXRlcyBsaWtlIF9fcHJvdG9fXywgcHJvdG90eXBlIGFuZCBjb25zdHJ1Y3RvciBpcyBub3QgYWxsb3dlZFwifSxaPVwiXCIrT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcixubj1cInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5vd25LZXlzP1JlZmxlY3Qub3duS2V5czp2b2lkIDAhPT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzP2Z1bmN0aW9uKG4pe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhuKSl9Ok9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLHJuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzfHxmdW5jdGlvbihuKXt2YXIgcj17fTtyZXR1cm4gbm4obikuZm9yRWFjaCgoZnVuY3Rpb24odCl7clt0XT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCl9KSkscn0sdG49e30sZW49e2dldDpmdW5jdGlvbihuLHIpe2lmKHI9PT1RKXJldHVybiBuO3ZhciBlPXAobik7aWYoIXUoZSxyKSlyZXR1cm4gZnVuY3Rpb24obixyLHQpe3ZhciBlLGk9SShyLHQpO3JldHVybiBpP1widmFsdWVcImluIGk/aS52YWx1ZTpudWxsPT09KGU9aS5nZXQpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmNhbGwobi5rKTp2b2lkIDB9KG4sZSxyKTt2YXIgaT1lW3JdO3JldHVybiBuLkl8fCF0KGkpP2k6aT09PXoobi50LHIpPyhFKG4pLG4ub1tyXT1SKG4uQS5oLGksbikpOml9LGhhczpmdW5jdGlvbihuLHIpe3JldHVybiByIGluIHAobil9LG93bktleXM6ZnVuY3Rpb24obil7cmV0dXJuIFJlZmxlY3Qub3duS2V5cyhwKG4pKX0sc2V0OmZ1bmN0aW9uKG4scix0KXt2YXIgZT1JKHAobikscik7aWYobnVsbD09ZT92b2lkIDA6ZS5zZXQpcmV0dXJuIGUuc2V0LmNhbGwobi5rLHQpLCEwO2lmKCFuLlApe3ZhciBpPXoocChuKSxyKSxvPW51bGw9PWk/dm9pZCAwOmlbUV07aWYobyYmby50PT09dClyZXR1cm4gbi5vW3JdPXQsbi5EW3JdPSExLCEwO2lmKGModCxpKSYmKHZvaWQgMCE9PXR8fHUobi50LHIpKSlyZXR1cm4hMDtFKG4pLGsobil9cmV0dXJuIG4ub1tyXT09PXQmJlwibnVtYmVyXCIhPXR5cGVvZiB0JiYodm9pZCAwIT09dHx8ciBpbiBuLm8pfHwobi5vW3JdPXQsbi5EW3JdPSEwLCEwKX0sZGVsZXRlUHJvcGVydHk6ZnVuY3Rpb24obixyKXtyZXR1cm4gdm9pZCAwIT09eihuLnQscil8fHIgaW4gbi50PyhuLkRbcl09ITEsRShuKSxrKG4pKTpkZWxldGUgbi5EW3JdLG4ubyYmZGVsZXRlIG4ub1tyXSwhMH0sZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOmZ1bmN0aW9uKG4scil7dmFyIHQ9cChuKSxlPVJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQscik7cmV0dXJuIGU/e3dyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZToxIT09bi5pfHxcImxlbmd0aFwiIT09cixlbnVtZXJhYmxlOmUuZW51bWVyYWJsZSx2YWx1ZTp0W3JdfTplfSxkZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbigpe24oMTEpfSxnZXRQcm90b3R5cGVPZjpmdW5jdGlvbihuKXtyZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG4udCl9LHNldFByb3RvdHlwZU9mOmZ1bmN0aW9uKCl7bigxMil9fSxvbj17fTtpKGVuLChmdW5jdGlvbihuLHIpe29uW25dPWZ1bmN0aW9uKCl7cmV0dXJuIGFyZ3VtZW50c1swXT1hcmd1bWVudHNbMF1bMF0sci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSkpLG9uLmRlbGV0ZVByb3BlcnR5PWZ1bmN0aW9uKHIsdCl7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmaXNOYU4ocGFyc2VJbnQodCkpJiZuKDEzKSxvbi5zZXQuY2FsbCh0aGlzLHIsdCx2b2lkIDApfSxvbi5zZXQ9ZnVuY3Rpb24ocix0LGUpe3JldHVyblwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJlwibGVuZ3RoXCIhPT10JiZpc05hTihwYXJzZUludCh0KSkmJm4oMTQpLGVuLnNldC5jYWxsKHRoaXMsclswXSx0LGUsclswXSl9O3ZhciB1bj1mdW5jdGlvbigpe2Z1bmN0aW9uIGUocil7dmFyIGU9dGhpczt0aGlzLmc9Qix0aGlzLkY9ITAsdGhpcy5wcm9kdWNlPWZ1bmN0aW9uKHIsaSxvKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiByJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBpKXt2YXIgdT1pO2k9cjt2YXIgYT1lO3JldHVybiBmdW5jdGlvbihuKXt2YXIgcj10aGlzO3ZvaWQgMD09PW4mJihuPXUpO2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLGU9QXJyYXkodD4xP3QtMTowKSxvPTE7bzx0O28rKyllW28tMV09YXJndW1lbnRzW29dO3JldHVybiBhLnByb2R1Y2UobiwoZnVuY3Rpb24obil7dmFyIHQ7cmV0dXJuKHQ9aSkuY2FsbC5hcHBseSh0LFtyLG5dLmNvbmNhdChlKSl9KSl9fXZhciBmO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGkmJm4oNiksdm9pZCAwIT09byYmXCJmdW5jdGlvblwiIT10eXBlb2YgbyYmbig3KSx0KHIpKXt2YXIgYz13KGUpLHM9UihlLHIsdm9pZCAwKSx2PSEwO3RyeXtmPWkocyksdj0hMX1maW5hbGx5e3Y/TyhjKTpnKGMpfXJldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm9taXNlJiZmIGluc3RhbmNlb2YgUHJvbWlzZT9mLnRoZW4oKGZ1bmN0aW9uKG4pe3JldHVybiBqKGMsbyksUChuLGMpfSksKGZ1bmN0aW9uKG4pe3Rocm93IE8oYyksbn0pKTooaihjLG8pLFAoZixjKSl9aWYoIXJ8fFwib2JqZWN0XCIhPXR5cGVvZiByKXtpZih2b2lkIDA9PT0oZj1pKHIpKSYmKGY9ciksZj09PUgmJihmPXZvaWQgMCksZS5GJiZkKGYsITApLG8pe3ZhciBwPVtdLGw9W107YihcIlBhdGNoZXNcIikuTShyLGYscCxsKSxvKHAsbCl9cmV0dXJuIGZ9bigyMSxyKX0sdGhpcy5wcm9kdWNlV2l0aFBhdGNoZXM9ZnVuY3Rpb24obixyKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBuKXJldHVybiBmdW5jdGlvbihyKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxpPUFycmF5KHQ+MT90LTE6MCksbz0xO288dDtvKyspaVtvLTFdPWFyZ3VtZW50c1tvXTtyZXR1cm4gZS5wcm9kdWNlV2l0aFBhdGNoZXMociwoZnVuY3Rpb24ocil7cmV0dXJuIG4uYXBwbHkodm9pZCAwLFtyXS5jb25jYXQoaSkpfSkpfTt2YXIgdCxpLG89ZS5wcm9kdWNlKG4sciwoZnVuY3Rpb24obixyKXt0PW4saT1yfSkpO3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm9taXNlJiZvIGluc3RhbmNlb2YgUHJvbWlzZT9vLnRoZW4oKGZ1bmN0aW9uKG4pe3JldHVybltuLHQsaV19KSk6W28sdCxpXX0sXCJib29sZWFuXCI9PXR5cGVvZihudWxsPT1yP3ZvaWQgMDpyLnVzZVByb3hpZXMpJiZ0aGlzLnNldFVzZVByb3hpZXMoci51c2VQcm94aWVzKSxcImJvb2xlYW5cIj09dHlwZW9mKG51bGw9PXI/dm9pZCAwOnIuYXV0b0ZyZWV6ZSkmJnRoaXMuc2V0QXV0b0ZyZWV6ZShyLmF1dG9GcmVlemUpfXZhciBpPWUucHJvdG90eXBlO3JldHVybiBpLmNyZWF0ZURyYWZ0PWZ1bmN0aW9uKGUpe3QoZSl8fG4oOCkscihlKSYmKGU9RChlKSk7dmFyIGk9dyh0aGlzKSxvPVIodGhpcyxlLHZvaWQgMCk7cmV0dXJuIG9bUV0uQz0hMCxnKGkpLG99LGkuZmluaXNoRHJhZnQ9ZnVuY3Rpb24ocix0KXt2YXIgZT1yJiZyW1FdO1wicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJihlJiZlLkN8fG4oOSksZS5JJiZuKDEwKSk7dmFyIGk9ZS5BO3JldHVybiBqKGksdCksUCh2b2lkIDAsaSl9LGkuc2V0QXV0b0ZyZWV6ZT1mdW5jdGlvbihuKXt0aGlzLkY9bn0saS5zZXRVc2VQcm94aWVzPWZ1bmN0aW9uKHIpe3ImJiFCJiZuKDIwKSx0aGlzLmc9cn0saS5hcHBseVBhdGNoZXM9ZnVuY3Rpb24obix0KXt2YXIgZTtmb3IoZT10Lmxlbmd0aC0xO2U+PTA7ZS0tKXt2YXIgaT10W2VdO2lmKDA9PT1pLnBhdGgubGVuZ3RoJiZcInJlcGxhY2VcIj09PWkub3Ape249aS52YWx1ZTticmVha319ZT4tMSYmKHQ9dC5zbGljZShlKzEpKTt2YXIgbz1iKFwiUGF0Y2hlc1wiKS4kO3JldHVybiByKG4pP28obix0KTp0aGlzLnByb2R1Y2UobiwoZnVuY3Rpb24obil7cmV0dXJuIG8obix0KX0pKX0sZX0oKSxhbj1uZXcgdW4sZm49YW4ucHJvZHVjZSxjbj1hbi5wcm9kdWNlV2l0aFBhdGNoZXMuYmluZChhbiksc249YW4uc2V0QXV0b0ZyZWV6ZS5iaW5kKGFuKSx2bj1hbi5zZXRVc2VQcm94aWVzLmJpbmQoYW4pLHBuPWFuLmFwcGx5UGF0Y2hlcy5iaW5kKGFuKSxsbj1hbi5jcmVhdGVEcmFmdC5iaW5kKGFuKSxkbj1hbi5maW5pc2hEcmFmdC5iaW5kKGFuKTtleHBvcnQgZGVmYXVsdCBmbjtleHBvcnR7dW4gYXMgSW1tZXIscG4gYXMgYXBwbHlQYXRjaGVzLEsgYXMgY2FzdERyYWZ0LCQgYXMgY2FzdEltbXV0YWJsZSxsbiBhcyBjcmVhdGVEcmFmdCxEIGFzIGN1cnJlbnQsSiBhcyBlbmFibGVBbGxQbHVnaW5zLE4gYXMgZW5hYmxlRVM1LEMgYXMgZW5hYmxlTWFwU2V0LFQgYXMgZW5hYmxlUGF0Y2hlcyxkbiBhcyBmaW5pc2hEcmFmdCxkIGFzIGZyZWV6ZSxMIGFzIGltbWVyYWJsZSxyIGFzIGlzRHJhZnQsdCBhcyBpc0RyYWZ0YWJsZSxIIGFzIG5vdGhpbmcsZSBhcyBvcmlnaW5hbCxmbiBhcyBwcm9kdWNlLGNuIGFzIHByb2R1Y2VXaXRoUGF0Y2hlcyxzbiBhcyBzZXRBdXRvRnJlZXplLHZuIGFzIHNldFVzZVByb3hpZXN9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1tZXIuZXNtLmpzLm1hcFxuIiwiaW1wb3J0IHsgaXNQbGFpbk9iamVjdCB9IGZyb20gJ2lzLXBsYWluLW9iamVjdCc7XG5pbXBvcnQgeyBwcm9kdWNlLCBjcmVhdGVEcmFmdCwgZmluaXNoRHJhZnQsIGlzRHJhZnQgfSBmcm9tICdpbW1lcic7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG52YXIgRElSVFlfUEFUSFMgPSBuZXcgV2Vha01hcCgpO1xudmFyIERJUlRZX1BBVEhfS0VZUyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRkxVU0hJTkcgPSBuZXcgV2Vha01hcCgpO1xudmFyIE5PUk1BTElaSU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBQQVRIX1JFRlMgPSBuZXcgV2Vha01hcCgpO1xudmFyIFBPSU5UX1JFRlMgPSBuZXcgV2Vha01hcCgpO1xudmFyIFJBTkdFX1JFRlMgPSBuZXcgV2Vha01hcCgpO1xuXG5mdW5jdGlvbiBvd25LZXlzJDkob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDkodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ5KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkOShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBuZXh0RWRpdG9ySWQgPSAwO1xuLyoqXHJcbiAqIENyZWF0ZSBhIG5ldyBTbGF0ZSBgRWRpdG9yYCBvYmplY3QuXHJcbiAqL1xuXG52YXIgY3JlYXRlRWRpdG9yID0gKCkgPT4ge1xuICB2YXIgZWRpdG9yID0ge1xuICAgIGNoaWxkcmVuOiBbXSxcbiAgICBvcGVyYXRpb25zOiBbXSxcbiAgICBzZWxlY3Rpb246IG51bGwsXG4gICAgbWFya3M6IG51bGwsXG4gICAgaWQ6IG5leHRFZGl0b3JJZCsrLFxuICAgIGlzSW5saW5lOiAoKSA9PiBmYWxzZSxcbiAgICBpc1ZvaWQ6ICgpID0+IGZhbHNlLFxuICAgIG1hcmthYmxlVm9pZDogKCkgPT4gZmFsc2UsXG4gICAgb25DaGFuZ2U6ICgpID0+IHt9LFxuICAgIGFwcGx5OiBvcCA9PiB7XG4gICAgICBmb3IgKHZhciByZWYgb2YgRWRpdG9yLnBhdGhSZWZzKGVkaXRvcikpIHtcbiAgICAgICAgUGF0aFJlZi50cmFuc2Zvcm0ocmVmLCBvcCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9yZWYgb2YgRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpKSB7XG4gICAgICAgIFBvaW50UmVmLnRyYW5zZm9ybShfcmVmLCBvcCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9yZWYyIG9mIEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKSkge1xuICAgICAgICBSYW5nZVJlZi50cmFuc2Zvcm0oX3JlZjIsIG9wKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9sZERpcnR5UGF0aHMgPSBESVJUWV9QQVRIUy5nZXQoZWRpdG9yKSB8fCBbXTtcbiAgICAgIHZhciBvbGREaXJ0eVBhdGhLZXlzID0gRElSVFlfUEFUSF9LRVlTLmdldChlZGl0b3IpIHx8IG5ldyBTZXQoKTtcbiAgICAgIHZhciBkaXJ0eVBhdGhzO1xuICAgICAgdmFyIGRpcnR5UGF0aEtleXM7XG5cbiAgICAgIHZhciBhZGQgPSBwYXRoID0+IHtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICB2YXIga2V5ID0gcGF0aC5qb2luKCcsJyk7XG5cbiAgICAgICAgICBpZiAoIWRpcnR5UGF0aEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGRpcnR5UGF0aEtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBkaXJ0eVBhdGhzLnB1c2gocGF0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoUGF0aC5vcGVyYXRpb25DYW5UcmFuc2Zvcm1QYXRoKG9wKSkge1xuICAgICAgICBkaXJ0eVBhdGhzID0gW107XG4gICAgICAgIGRpcnR5UGF0aEtleXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgZm9yICh2YXIgcGF0aCBvZiBvbGREaXJ0eVBhdGhzKSB7XG4gICAgICAgICAgdmFyIG5ld1BhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gICAgICAgICAgYWRkKG5ld1BhdGgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXJ0eVBhdGhzID0gb2xkRGlydHlQYXRocztcbiAgICAgICAgZGlydHlQYXRoS2V5cyA9IG9sZERpcnR5UGF0aEtleXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdEaXJ0eVBhdGhzID0gZWRpdG9yLmdldERpcnR5UGF0aHMob3ApO1xuXG4gICAgICBmb3IgKHZhciBfcGF0aCBvZiBuZXdEaXJ0eVBhdGhzKSB7XG4gICAgICAgIGFkZChfcGF0aCk7XG4gICAgICB9XG5cbiAgICAgIERJUlRZX1BBVEhTLnNldChlZGl0b3IsIGRpcnR5UGF0aHMpO1xuICAgICAgRElSVFlfUEFUSF9LRVlTLnNldChlZGl0b3IsIGRpcnR5UGF0aEtleXMpO1xuICAgICAgVHJhbnNmb3Jtcy50cmFuc2Zvcm0oZWRpdG9yLCBvcCk7XG4gICAgICBlZGl0b3Iub3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgIEVkaXRvci5ub3JtYWxpemUoZWRpdG9yKTsgLy8gQ2xlYXIgYW55IGZvcm1hdHMgYXBwbGllZCB0byB0aGUgY3Vyc29yIGlmIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy5cblxuICAgICAgaWYgKG9wLnR5cGUgPT09ICdzZXRfc2VsZWN0aW9uJykge1xuICAgICAgICBlZGl0b3IubWFya3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUZMVVNISU5HLmdldChlZGl0b3IpKSB7XG4gICAgICAgIEZMVVNISU5HLnNldChlZGl0b3IsIHRydWUpO1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBGTFVTSElORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICAgICAgZWRpdG9yLm9uQ2hhbmdlKCk7XG4gICAgICAgICAgZWRpdG9yLm9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBhZGRNYXJrOiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICBtYXJrYWJsZVZvaWRcbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgdmFyIG1hdGNoID0gKG5vZGUsIHBhdGgpID0+IHtcbiAgICAgICAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIG1hcmtzIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gdGV4dFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBbcGFyZW50Tm9kZSwgcGFyZW50UGF0aF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgcmV0dXJuICFlZGl0b3IuaXNWb2lkKHBhcmVudE5vZGUpIHx8IGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGV4cGFuZGVkU2VsZWN0aW9uID0gUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pO1xuICAgICAgICB2YXIgbWFya0FjY2VwdGluZ1ZvaWRTZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmICghZXhwYW5kZWRTZWxlY3Rpb24pIHtcbiAgICAgICAgICB2YXIgW3NlbGVjdGVkTm9kZSwgc2VsZWN0ZWRQYXRoXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgc2VsZWN0aW9uKTtcblxuICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgbWF0Y2goc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGgpKSB7XG4gICAgICAgICAgICB2YXIgW3BhcmVudE5vZGVdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIHNlbGVjdGVkUGF0aCk7XG4gICAgICAgICAgICBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gcGFyZW50Tm9kZSAmJiBlZGl0b3IubWFya2FibGVWb2lkKHBhcmVudE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHBhbmRlZFNlbGVjdGlvbiB8fCBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIFtrZXldOiB2YWx1ZVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtYXJrcyA9IF9vYmplY3RTcHJlYWQkOShfb2JqZWN0U3ByZWFkJDkoe30sIEVkaXRvci5tYXJrcyhlZGl0b3IpIHx8IHt9KSwge30sIHtcbiAgICAgICAgICAgIFtrZXldOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZWRpdG9yLm1hcmtzID0gbWFya3M7XG5cbiAgICAgICAgICBpZiAoIUZMVVNISU5HLmdldChlZGl0b3IpKSB7XG4gICAgICAgICAgICBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRlbGV0ZUJhY2t3YXJkOiB1bml0ID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlbGV0ZUZvcndhcmQ6IHVuaXQgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgdW5pdFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlbGV0ZUZyYWdtZW50OiBkaXJlY3Rpb24gPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICByZXZlcnNlOiBkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRGcmFnbWVudDogKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBOb2RlLmZyYWdtZW50KGVkaXRvciwgc2VsZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgaW5zZXJ0QnJlYWs6ICgpID0+IHtcbiAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYWx3YXlzOiB0cnVlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGluc2VydFNvZnRCcmVhazogKCkgPT4ge1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhbHdheXM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaW5zZXJ0RnJhZ21lbnQ6IGZyYWdtZW50ID0+IHtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCk7XG4gICAgfSxcbiAgICBpbnNlcnROb2RlOiBub2RlID0+IHtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2RlKTtcbiAgICB9LFxuICAgIGluc2VydFRleHQ6IHRleHQgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uLFxuICAgICAgICBtYXJrc1xuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAobWFya3MpIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IF9vYmplY3RTcHJlYWQkOSh7XG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfSwgbWFya3MpO1xuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWRpdG9yLm1hcmtzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5vcm1hbGl6ZU5vZGU6IGVudHJ5ID0+IHtcbiAgICAgIHZhciBbbm9kZSwgcGF0aF0gPSBlbnRyeTsgLy8gVGhlcmUgYXJlIG5vIGNvcmUgbm9ybWFsaXphdGlvbnMgZm9yIHRleHQgbm9kZXMuXG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEVuc3VyZSB0aGF0IGJsb2NrIGFuZCBpbmxpbmUgbm9kZXMgaGF2ZSBhdCBsZWFzdCBvbmUgdGV4dCBjaGlsZC5cblxuXG4gICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGNoaWxkID0ge1xuICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgIH07XG4gICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBjaGlsZCwge1xuICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdCgwKSxcbiAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgbm9kZSBzaG91bGQgaGF2ZSBibG9jayBvciBpbmxpbmUgY2hpbGRyZW4uXG5cblxuICAgICAgdmFyIHNob3VsZEhhdmVJbmxpbmVzID0gRWRpdG9yLmlzRWRpdG9yKG5vZGUpID8gZmFsc2UgOiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpIHx8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IFRleHQuaXNUZXh0KG5vZGUuY2hpbGRyZW5bMF0pIHx8IGVkaXRvci5pc0lubGluZShub2RlLmNoaWxkcmVuWzBdKSk7IC8vIFNpbmNlIHdlJ2xsIGJlIGFwcGx5aW5nIG9wZXJhdGlvbnMgd2hpbGUgaXRlcmF0aW5nLCBrZWVwIHRyYWNrIG9mIGFuXG4gICAgICAvLyBpbmRleCB0aGF0IGFjY291bnRzIGZvciBhbnkgYWRkZWQvcmVtb3ZlZCBub2Rlcy5cblxuICAgICAgdmFyIG4gPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyssIG4rKykge1xuICAgICAgICB2YXIgY3VycmVudE5vZGUgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuICAgICAgICBpZiAoVGV4dC5pc1RleHQoY3VycmVudE5vZGUpKSBjb250aW51ZTtcbiAgICAgICAgdmFyIF9jaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIHZhciBwcmV2ID0gY3VycmVudE5vZGUuY2hpbGRyZW5bbiAtIDFdO1xuICAgICAgICB2YXIgaXNMYXN0ID0gaSA9PT0gbm9kZS5jaGlsZHJlbi5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgaXNJbmxpbmVPclRleHQgPSBUZXh0LmlzVGV4dChfY2hpbGQpIHx8IEVsZW1lbnQuaXNFbGVtZW50KF9jaGlsZCkgJiYgZWRpdG9yLmlzSW5saW5lKF9jaGlsZCk7IC8vIE9ubHkgYWxsb3cgYmxvY2sgbm9kZXMgaW4gdGhlIHRvcC1sZXZlbCBjaGlsZHJlbiBhbmQgcGFyZW50IGJsb2Nrc1xuICAgICAgICAvLyB0aGF0IG9ubHkgY29udGFpbiBibG9jayBub2Rlcy4gU2ltaWxhcmx5LCBvbmx5IGFsbG93IGlubGluZSBub2RlcyBpblxuICAgICAgICAvLyBvdGhlciBpbmxpbmUgbm9kZXMsIG9yIHBhcmVudCBibG9ja3MgdGhhdCBvbmx5IGNvbnRhaW4gaW5saW5lcyBhbmRcbiAgICAgICAgLy8gdGV4dC5cblxuICAgICAgICBpZiAoaXNJbmxpbmVPclRleHQgIT09IHNob3VsZEhhdmVJbmxpbmVzKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbi0tO1xuICAgICAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KF9jaGlsZCkpIHtcbiAgICAgICAgICAvLyBFbnN1cmUgdGhhdCBpbmxpbmUgbm9kZXMgYXJlIHN1cnJvdW5kZWQgYnkgdGV4dCBub2Rlcy5cbiAgICAgICAgICBpZiAoZWRpdG9yLmlzSW5saW5lKF9jaGlsZCkpIHtcbiAgICAgICAgICAgIGlmIChwcmV2ID09IG51bGwgfHwgIVRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgICAgIHZhciBuZXdDaGlsZCA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbmV3Q2hpbGQsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICAgIHZhciBfbmV3Q2hpbGQgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIF9uZXdDaGlsZCwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuICsgMSksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTWVyZ2UgYWRqYWNlbnQgdGV4dCBub2RlcyB0aGF0IGFyZSBlbXB0eSBvciBtYXRjaC5cbiAgICAgICAgICBpZiAocHJldiAhPSBudWxsICYmIFRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgICBpZiAoVGV4dC5lcXVhbHMoX2NoaWxkLCBwcmV2LCB7XG4gICAgICAgICAgICAgIGxvb3NlOiB0cnVlXG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLm1lcmdlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByZXYudGV4dCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiAtIDEpLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9jaGlsZC50ZXh0ID09PSAnJykge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlTWFyazoga2V5ID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICB2YXIgbWF0Y2ggPSAobm9kZSwgcGF0aCkgPT4ge1xuICAgICAgICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gbWFya3MgY2FuIG9ubHkgYmUgYXBwbGllZCB0byB0ZXh0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIFtwYXJlbnROb2RlLCBwYXJlbnRQYXRoXSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICByZXR1cm4gIWVkaXRvci5pc1ZvaWQocGFyZW50Tm9kZSkgfHwgZWRpdG9yLm1hcmthYmxlVm9pZChwYXJlbnROb2RlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZXhwYW5kZWRTZWxlY3Rpb24gPSBSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbik7XG4gICAgICAgIHZhciBtYXJrQWNjZXB0aW5nVm9pZFNlbGVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFleHBhbmRlZFNlbGVjdGlvbikge1xuICAgICAgICAgIHZhciBbc2VsZWN0ZWROb2RlLCBzZWxlY3RlZFBhdGhdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBzZWxlY3Rpb24pO1xuXG4gICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZSAmJiBtYXRjaChzZWxlY3RlZE5vZGUsIHNlbGVjdGVkUGF0aCkpIHtcbiAgICAgICAgICAgIHZhciBbcGFyZW50Tm9kZV0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgc2VsZWN0ZWRQYXRoKTtcbiAgICAgICAgICAgIG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQgPSBwYXJlbnROb2RlICYmIGVkaXRvci5tYXJrYWJsZVZvaWQocGFyZW50Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4cGFuZGVkU2VsZWN0aW9uIHx8IG1hcmtBY2NlcHRpbmdWb2lkU2VsZWN0ZWQpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoZWRpdG9yLCBrZXksIHtcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtYXJrcyA9IF9vYmplY3RTcHJlYWQkOSh7fSwgRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30pO1xuXG4gICAgICAgICAgZGVsZXRlIG1hcmtzW2tleV07XG4gICAgICAgICAgZWRpdG9yLm1hcmtzID0gbWFya3M7XG5cbiAgICAgICAgICBpZiAoIUZMVVNISU5HLmdldChlZGl0b3IpKSB7XG4gICAgICAgICAgICBlZGl0b3Iub25DaGFuZ2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIFwiZGlydHlcIiBwYXRocyBnZW5lcmF0ZWQgZnJvbSBhbiBvcGVyYXRpb24uXHJcbiAgICAgKi9cbiAgICBnZXREaXJ0eVBhdGhzOiBvcCA9PiB7XG4gICAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgICBwYXRoXG4gICAgICAgICAgICB9ID0gb3A7XG4gICAgICAgICAgICByZXR1cm4gUGF0aC5sZXZlbHMocGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICBwYXRoOiBfcGF0aDJcbiAgICAgICAgICAgIH0gPSBvcDtcbiAgICAgICAgICAgIHZhciBsZXZlbHMgPSBQYXRoLmxldmVscyhfcGF0aDIpO1xuICAgICAgICAgICAgdmFyIGRlc2NlbmRhbnRzID0gVGV4dC5pc1RleHQobm9kZSkgPyBbXSA6IEFycmF5LmZyb20oTm9kZS5ub2Rlcyhub2RlKSwgX3JlZjMgPT4ge1xuICAgICAgICAgICAgICB2YXIgWywgcF0gPSBfcmVmMztcbiAgICAgICAgICAgICAgcmV0dXJuIF9wYXRoMi5jb25jYXQocCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBbLi4ubGV2ZWxzLCAuLi5kZXNjZW5kYW50c107XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IF9wYXRoM1xuICAgICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgICAgdmFyIGFuY2VzdG9ycyA9IFBhdGguYW5jZXN0b3JzKF9wYXRoMyk7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNQYXRoID0gUGF0aC5wcmV2aW91cyhfcGF0aDMpO1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5hbmNlc3RvcnMsIHByZXZpb3VzUGF0aF07XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgICAgcGF0aDogX3BhdGg0LFxuICAgICAgICAgICAgICBuZXdQYXRoXG4gICAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfcGF0aDQsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9sZEFuY2VzdG9ycyA9IFtdO1xuICAgICAgICAgICAgdmFyIG5ld0FuY2VzdG9ycyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBhbmNlc3RvciBvZiBQYXRoLmFuY2VzdG9ycyhfcGF0aDQpKSB7XG4gICAgICAgICAgICAgIHZhciBwID0gUGF0aC50cmFuc2Zvcm0oYW5jZXN0b3IsIG9wKTtcbiAgICAgICAgICAgICAgb2xkQW5jZXN0b3JzLnB1c2gocCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIF9hbmNlc3RvciBvZiBQYXRoLmFuY2VzdG9ycyhuZXdQYXRoKSkge1xuICAgICAgICAgICAgICB2YXIgX3AgPSBQYXRoLnRyYW5zZm9ybShfYW5jZXN0b3IsIG9wKTtcblxuICAgICAgICAgICAgICBuZXdBbmNlc3RvcnMucHVzaChfcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXdQYXJlbnQgPSBuZXdBbmNlc3RvcnNbbmV3QW5jZXN0b3JzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIG5ld0luZGV4ID0gbmV3UGF0aFtuZXdQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIHJlc3VsdFBhdGggPSBuZXdQYXJlbnQuY29uY2F0KG5ld0luZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBbLi4ub2xkQW5jZXN0b3JzLCAuLi5uZXdBbmNlc3RvcnMsIHJlc3VsdFBhdGhdO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgICAgcGF0aDogX3BhdGg1XG4gICAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICAgIHZhciBfYW5jZXN0b3JzID0gUGF0aC5hbmNlc3RvcnMoX3BhdGg1KTtcblxuICAgICAgICAgICAgcmV0dXJuIFsuLi5fYW5jZXN0b3JzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgICAgcGF0aDogX3BhdGg2XG4gICAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICAgIHZhciBfbGV2ZWxzID0gUGF0aC5sZXZlbHMoX3BhdGg2KTtcblxuICAgICAgICAgICAgdmFyIG5leHRQYXRoID0gUGF0aC5uZXh0KF9wYXRoNik7XG4gICAgICAgICAgICByZXR1cm4gWy4uLl9sZXZlbHMsIG5leHRQYXRoXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVkaXRvcjtcbn07XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpO1xuICB2YXIga2V5LCBpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlU3ltYm9sS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAga2V5ID0gc291cmNlU3ltYm9sS2V5c1tpXTtcbiAgICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzb3VyY2UsIGtleSkpIGNvbnRpbnVlO1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyBDaGFyYWN0ZXIgKGdyYXBoZW1lIGNsdXN0ZXIpIGJvdW5kYXJpZXMgYXJlIGRldGVybWluZWQgYWNjb3JkaW5nIHRvXG4vLyB0aGUgZGVmYXVsdCBncmFwaGVtZSBjbHVzdGVyIGJvdW5kYXJ5IHNwZWNpZmljYXRpb24sIGV4dGVuZGVkIGdyYXBoZW1lIGNsdXN0ZXJzIHZhcmlhbnRbMV0uXG4vL1xuLy8gUmVmZXJlbmNlczpcbi8vXG4vLyBbMV0gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjI5LyNEZWZhdWx0X0dyYXBoZW1lX0NsdXN0ZXJfVGFibGVcbi8vIFsyXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtQcm9wZXJ0eS50eHRcbi8vIFszXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtUZXN0Lmh0bWxcbi8vIFs0XSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvYXV4aWxpYXJ5L0dyYXBoZW1lQnJlYWtUZXN0LnR4dFxuXG4vKipcclxuICogR2V0IHRoZSBkaXN0YW5jZSB0byB0aGUgZW5kIG9mIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gYSBzdHJpbmcgb2YgdGV4dC5cclxuICovXG52YXIgZ2V0Q2hhcmFjdGVyRGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRDaGFyYWN0ZXJEaXN0YW5jZShzdHIpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgdmFyIGlzTFRSID0gIWlzUlRMO1xuICB2YXIgY29kZXBvaW50cyA9IGlzUlRMID8gY29kZXBvaW50c0l0ZXJhdG9yUlRMKHN0cikgOiBzdHI7XG4gIHZhciBsZWZ0ID0gQ29kZXBvaW50VHlwZS5Ob25lO1xuICB2YXIgcmlnaHQgPSBDb2RlcG9pbnRUeXBlLk5vbmU7XG4gIHZhciBkaXN0YW5jZSA9IDA7IC8vIEV2YWx1YXRpb24gb2YgdGhlc2UgY29uZGl0aW9ucyBhcmUgZGVmZXJyZWQuXG5cbiAgdmFyIGdiMTEgPSBudWxsOyAvLyBJcyBHQjExIGFwcGxpY2FibGU/XG5cbiAgdmFyIGdiMTJPcjEzID0gbnVsbDsgLy8gSXMgR0IxMiBvciBHQjEzIGFwcGxpY2FibGU/XG5cbiAgZm9yICh2YXIgY2hhciBvZiBjb2RlcG9pbnRzKSB7XG4gICAgdmFyIGNvZGUgPSBjaGFyLmNvZGVQb2ludEF0KDApO1xuICAgIGlmICghY29kZSkgYnJlYWs7XG4gICAgdmFyIHR5cGUgPSBnZXRDb2RlcG9pbnRUeXBlKGNoYXIsIGNvZGUpO1xuICAgIFtsZWZ0LCByaWdodF0gPSBpc0xUUiA/IFtyaWdodCwgdHlwZV0gOiBbdHlwZSwgbGVmdF07XG5cbiAgICBpZiAoaW50ZXJzZWN0cyhsZWZ0LCBDb2RlcG9pbnRUeXBlLlpXSikgJiYgaW50ZXJzZWN0cyhyaWdodCwgQ29kZXBvaW50VHlwZS5FeHRQaWN0KSkge1xuICAgICAgaWYgKGlzTFRSKSB7XG4gICAgICAgIGdiMTEgPSBlbmRzV2l0aEVtb2ppWldKKHN0ci5zdWJzdHJpbmcoMCwgZGlzdGFuY2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdiMTEgPSBlbmRzV2l0aEVtb2ppWldKKHN0ci5zdWJzdHJpbmcoMCwgc3RyLmxlbmd0aCAtIGRpc3RhbmNlKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZ2IxMSkgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKGludGVyc2VjdHMobGVmdCwgQ29kZXBvaW50VHlwZS5SSSkgJiYgaW50ZXJzZWN0cyhyaWdodCwgQ29kZXBvaW50VHlwZS5SSSkpIHtcbiAgICAgIGlmIChnYjEyT3IxMyAhPT0gbnVsbCkge1xuICAgICAgICBnYjEyT3IxMyA9ICFnYjEyT3IxMztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0xUUikge1xuICAgICAgICAgIGdiMTJPcjEzID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnYjEyT3IxMyA9IGVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMoc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gZGlzdGFuY2UpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWdiMTJPcjEzKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAobGVmdCAhPT0gQ29kZXBvaW50VHlwZS5Ob25lICYmIHJpZ2h0ICE9PSBDb2RlcG9pbnRUeXBlLk5vbmUgJiYgaXNCb3VuZGFyeVBhaXIobGVmdCwgcmlnaHQpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBkaXN0YW5jZSArPSBjaGFyLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBkaXN0YW5jZSB8fCAxO1xufTtcbnZhciBTUEFDRSA9IC9cXHMvO1xudmFyIFBVTkNUVUFUSU9OID0gL1tcXHUwMDIxLVxcdTAwMjNcXHUwMDI1LVxcdTAwMkFcXHUwMDJDLVxcdTAwMkZcXHUwMDNBXFx1MDAzQlxcdTAwM0ZcXHUwMDQwXFx1MDA1Qi1cXHUwMDVEXFx1MDA1RlxcdTAwN0JcXHUwMDdEXFx1MDBBMVxcdTAwQTdcXHUwMEFCXFx1MDBCNlxcdTAwQjdcXHUwMEJCXFx1MDBCRlxcdTAzN0VcXHUwMzg3XFx1MDU1QS1cXHUwNTVGXFx1MDU4OVxcdTA1OEFcXHUwNUJFXFx1MDVDMFxcdTA1QzNcXHUwNUM2XFx1MDVGM1xcdTA1RjRcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxQlxcdTA2MUVcXHUwNjFGXFx1MDY2QS1cXHUwNjZEXFx1MDZENFxcdTA3MDAtXFx1MDcwRFxcdTA3RjctXFx1MDdGOVxcdTA4MzAtXFx1MDgzRVxcdTA4NUVcXHUwOTY0XFx1MDk2NVxcdTA5NzBcXHUwQUYwXFx1MERGNFxcdTBFNEZcXHUwRTVBXFx1MEU1QlxcdTBGMDQtXFx1MEYxMlxcdTBGMTRcXHUwRjNBLVxcdTBGM0RcXHUwRjg1XFx1MEZEMC1cXHUwRkQ0XFx1MEZEOVxcdTBGREFcXHUxMDRBLVxcdTEwNEZcXHUxMEZCXFx1MTM2MC1cXHUxMzY4XFx1MTQwMFxcdTE2NkRcXHUxNjZFXFx1MTY5QlxcdTE2OUNcXHUxNkVCLVxcdTE2RURcXHUxNzM1XFx1MTczNlxcdTE3RDQtXFx1MTdENlxcdTE3RDgtXFx1MTdEQVxcdTE4MDAtXFx1MTgwQVxcdTE5NDRcXHUxOTQ1XFx1MUExRVxcdTFBMUZcXHUxQUEwLVxcdTFBQTZcXHUxQUE4LVxcdTFBQURcXHUxQjVBLVxcdTFCNjBcXHUxQkZDLVxcdTFCRkZcXHUxQzNCLVxcdTFDM0ZcXHUxQzdFXFx1MUM3RlxcdTFDQzAtXFx1MUNDN1xcdTFDRDNcXHUyMDEwLVxcdTIwMjdcXHUyMDMwLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNUVcXHUyMDdEXFx1MjA3RVxcdTIwOERcXHUyMDhFXFx1MjMyOVxcdTIzMkFcXHUyNzY4LVxcdTI3NzVcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkNGOS1cXHUyQ0ZDXFx1MkNGRVxcdTJDRkZcXHUyRDcwXFx1MkUwMC1cXHUyRTJFXFx1MkUzMC1cXHUyRTNCXFx1MzAwMS1cXHUzMDAzXFx1MzAwOC1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAzMFxcdTMwM0RcXHUzMEEwXFx1MzBGQlxcdUE0RkVcXHVBNEZGXFx1QTYwRC1cXHVBNjBGXFx1QTY3M1xcdUE2N0VcXHVBNkYyLVxcdUE2RjdcXHVBODc0LVxcdUE4NzdcXHVBOENFXFx1QThDRlxcdUE4RjgtXFx1QThGQVxcdUE5MkVcXHVBOTJGXFx1QTk1RlxcdUE5QzEtXFx1QTlDRFxcdUE5REVcXHVBOURGXFx1QUE1Qy1cXHVBQTVGXFx1QUFERVxcdUFBREZcXHVBQUYwXFx1QUFGMVxcdUFCRUJcXHVGRDNFXFx1RkQzRlxcdUZFMTAtXFx1RkUxOVxcdUZFMzAtXFx1RkU1MlxcdUZFNTQtXFx1RkU2MVxcdUZFNjNcXHVGRTY4XFx1RkU2QVxcdUZFNkJcXHVGRjAxLVxcdUZGMDNcXHVGRjA1LVxcdUZGMEFcXHVGRjBDLVxcdUZGMEZcXHVGRjFBXFx1RkYxQlxcdUZGMUZcXHVGRjIwXFx1RkYzQi1cXHVGRjNEXFx1RkYzRlxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRjY1XS87XG52YXIgQ0hBTUVMRU9OID0gL1snXFx1MjAxOFxcdTIwMTldLztcbi8qKlxyXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0IHdvcmQgaW4gYSBzdHJpbmcgb2YgdGV4dC5cclxuICovXG5cbnZhciBnZXRXb3JkRGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRXb3JkRGlzdGFuY2UodGV4dCkge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgZGlzdCA9IDA7XG4gIHZhciBzdGFydGVkID0gZmFsc2U7XG5cbiAgd2hpbGUgKHRleHQubGVuZ3RoID4gMCkge1xuICAgIHZhciBjaGFyRGlzdCA9IGdldENoYXJhY3RlckRpc3RhbmNlKHRleHQsIGlzUlRMKTtcbiAgICB2YXIgW2NoYXIsIHJlbWFpbmluZ10gPSBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgY2hhckRpc3QsIGlzUlRMKTtcblxuICAgIGlmIChpc1dvcmRDaGFyYWN0ZXIoY2hhciwgcmVtYWluaW5nLCBpc1JUTCkpIHtcbiAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgZGlzdCArPSBjaGFyRGlzdDtcbiAgICB9IGVsc2UgaWYgKCFzdGFydGVkKSB7XG4gICAgICBkaXN0ICs9IGNoYXJEaXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0ZXh0ID0gcmVtYWluaW5nO1xuICB9XG5cbiAgcmV0dXJuIGRpc3Q7XG59O1xuLyoqXHJcbiAqIFNwbGl0IGEgc3RyaW5nIGluIHR3byBwYXJ0cyBhdCBhIGdpdmVuIGRpc3RhbmNlIHN0YXJ0aW5nIGZyb20gdGhlIGVuZCB3aGVuXHJcbiAqIGBpc1JUTGAgaXMgc2V0IHRvIGB0cnVlYC5cclxuICovXG5cbnZhciBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UgPSAoc3RyLCBkaXN0LCBpc1JUTCkgPT4ge1xuICBpZiAoaXNSVEwpIHtcbiAgICB2YXIgYXQgPSBzdHIubGVuZ3RoIC0gZGlzdDtcbiAgICByZXR1cm4gW3N0ci5zbGljZShhdCwgc3RyLmxlbmd0aCksIHN0ci5zbGljZSgwLCBhdCldO1xuICB9XG5cbiAgcmV0dXJuIFtzdHIuc2xpY2UoMCwgZGlzdCksIHN0ci5zbGljZShkaXN0KV07XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgY2hhcmFjdGVyIGlzIGEgd29yZCBjaGFyYWN0ZXIuIFRoZSBgcmVtYWluaW5nYCBhcmd1bWVudCBpcyB1c2VkXHJcbiAqIGJlY2F1c2Ugc29tZXRpbWVzIHlvdSBtdXN0IHJlYWQgc3Vic2VxdWVudCBjaGFyYWN0ZXJzIHRvIHRydWx5IGRldGVybWluZSBpdC5cclxuICovXG5cbnZhciBpc1dvcmRDaGFyYWN0ZXIgPSBmdW5jdGlvbiBpc1dvcmRDaGFyYWN0ZXIoY2hhciwgcmVtYWluaW5nKSB7XG4gIHZhciBpc1JUTCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgaWYgKFNQQUNFLnRlc3QoY2hhcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gQ2hhbWVsZW9ucyBjb3VudCBhcyB3b3JkIGNoYXJhY3RlcnMgYXMgbG9uZyBhcyB0aGV5J3JlIGluIGEgd29yZCwgc29cbiAgLy8gcmVjdXJzZSB0byBzZWUgaWYgdGhlIG5leHQgb25lIGlzIGEgd29yZCBjaGFyYWN0ZXIgb3Igbm90LlxuXG5cbiAgaWYgKENIQU1FTEVPTi50ZXN0KGNoYXIpKSB7XG4gICAgdmFyIGNoYXJEaXN0ID0gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UocmVtYWluaW5nLCBpc1JUTCk7XG4gICAgdmFyIFtuZXh0Q2hhciwgbmV4dFJlbWFpbmluZ10gPSBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UocmVtYWluaW5nLCBjaGFyRGlzdCwgaXNSVEwpO1xuXG4gICAgaWYgKGlzV29yZENoYXJhY3RlcihuZXh0Q2hhciwgbmV4dFJlbWFpbmluZywgaXNSVEwpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoUFVOQ1RVQVRJT04udGVzdChjaGFyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcbi8qKlxyXG4gKiBJdGVyYXRlIG9uIGNvZGVwb2ludHMgZnJvbSByaWdodCB0byBsZWZ0LlxyXG4gKi9cblxuXG52YXIgY29kZXBvaW50c0l0ZXJhdG9yUlRMID0gZnVuY3Rpb24qIGNvZGVwb2ludHNJdGVyYXRvclJUTChzdHIpIHtcbiAgdmFyIGVuZCA9IHN0ci5sZW5ndGggLSAxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoYXIxID0gc3RyLmNoYXJBdChlbmQgLSBpKTtcblxuICAgIGlmIChpc0xvd1N1cnJvZ2F0ZShjaGFyMS5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgdmFyIGNoYXIyID0gc3RyLmNoYXJBdChlbmQgLSBpIC0gMSk7XG5cbiAgICAgIGlmIChpc0hpZ2hTdXJyb2dhdGUoY2hhcjIuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgeWllbGQgY2hhcjIgKyBjaGFyMTtcbiAgICAgICAgaSsrO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB5aWVsZCBjaGFyMTtcbiAgfVxufTtcbi8qKlxyXG4gKiBJcyBgY2hhckNvZGVgIGEgaGlnaCBzdXJyb2dhdGUuXHJcbiAqXHJcbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXZlcnNhbF9DaGFyYWN0ZXJfU2V0X2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xyXG4gKi9cblxudmFyIGlzSGlnaFN1cnJvZ2F0ZSA9IGNoYXJDb2RlID0+IHtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDB4ZDgwMCAmJiBjaGFyQ29kZSA8PSAweGRiZmY7XG59O1xuLyoqXHJcbiAqIElzIGBjaGFyQ29kZWAgYSBsb3cgc3Vycm9nYXRlLlxyXG4gKlxyXG4gKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Vbml2ZXJzYWxfQ2hhcmFjdGVyX1NldF9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcclxuICovXG5cblxudmFyIGlzTG93U3Vycm9nYXRlID0gY2hhckNvZGUgPT4ge1xuICByZXR1cm4gY2hhckNvZGUgPj0gMHhkYzAwICYmIGNoYXJDb2RlIDw9IDB4ZGZmZjtcbn07XG5cbnZhciBDb2RlcG9pbnRUeXBlO1xuXG4oZnVuY3Rpb24gKENvZGVwb2ludFR5cGUpIHtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkV4dGVuZFwiXSA9IDFdID0gXCJFeHRlbmRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiWldKXCJdID0gMl0gPSBcIlpXSlwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJSSVwiXSA9IDRdID0gXCJSSVwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJQcmVwZW5kXCJdID0gOF0gPSBcIlByZXBlbmRcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiU3BhY2luZ01hcmtcIl0gPSAxNl0gPSBcIlNwYWNpbmdNYXJrXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxcIl0gPSAzMl0gPSBcIkxcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiVlwiXSA9IDY0XSA9IFwiVlwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJUXCJdID0gMTI4XSA9IFwiVFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJMVlwiXSA9IDI1Nl0gPSBcIkxWXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxWVFwiXSA9IDUxMl0gPSBcIkxWVFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJFeHRQaWN0XCJdID0gMTAyNF0gPSBcIkV4dFBpY3RcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiQW55XCJdID0gMjA0OF0gPSBcIkFueVwiO1xufSkoQ29kZXBvaW50VHlwZSB8fCAoQ29kZXBvaW50VHlwZSA9IHt9KSk7XG5cbnZhciByZUV4dGVuZCA9IC9eKD86W1xcdTAzMDAtXFx1MDM2RlxcdTA0ODMtXFx1MDQ4OVxcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA2MTAtXFx1MDYxQVxcdTA2NEItXFx1MDY1RlxcdTA2NzBcXHUwNkQ2LVxcdTA2RENcXHUwNkRGLVxcdTA2RTRcXHUwNkU3XFx1MDZFOFxcdTA2RUEtXFx1MDZFRFxcdTA3MTFcXHUwNzMwLVxcdTA3NEFcXHUwN0E2LVxcdTA3QjBcXHUwN0VCLVxcdTA3RjNcXHUwN0ZEXFx1MDgxNi1cXHUwODE5XFx1MDgxQi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJEXFx1MDg1OS1cXHUwODVCXFx1MDhEMy1cXHUwOEUxXFx1MDhFMy1cXHUwOTAyXFx1MDkzQVxcdTA5M0NcXHUwOTQxLVxcdTA5NDhcXHUwOTREXFx1MDk1MS1cXHUwOTU3XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDlCQ1xcdTA5QkVcXHUwOUMxLVxcdTA5QzRcXHUwOUNEXFx1MDlEN1xcdTA5RTJcXHUwOUUzXFx1MDlGRVxcdTBBMDFcXHUwQTAyXFx1MEEzQ1xcdTBBNDFcXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE3MFxcdTBBNzFcXHUwQTc1XFx1MEE4MVxcdTBBODJcXHUwQUJDXFx1MEFDMS1cXHUwQUM1XFx1MEFDN1xcdTBBQzhcXHUwQUNEXFx1MEFFMlxcdTBBRTNcXHUwQUZBLVxcdTBBRkZcXHUwQjAxXFx1MEIzQ1xcdTBCM0VcXHUwQjNGXFx1MEI0MS1cXHUwQjQ0XFx1MEI0RFxcdTBCNTUtXFx1MEI1N1xcdTBCNjJcXHUwQjYzXFx1MEI4MlxcdTBCQkVcXHUwQkMwXFx1MEJDRFxcdTBCRDdcXHUwQzAwXFx1MEMwNFxcdTBDM0UtXFx1MEM0MFxcdTBDNDYtXFx1MEM0OFxcdTBDNEEtXFx1MEM0RFxcdTBDNTVcXHUwQzU2XFx1MEM2MlxcdTBDNjNcXHUwQzgxXFx1MENCQ1xcdTBDQkZcXHUwQ0MyXFx1MENDNlxcdTBDQ0NcXHUwQ0NEXFx1MENENVxcdTBDRDZcXHUwQ0UyXFx1MENFM1xcdTBEMDBcXHUwRDAxXFx1MEQzQlxcdTBEM0NcXHUwRDNFXFx1MEQ0MS1cXHUwRDQ0XFx1MEQ0RFxcdTBENTdcXHUwRDYyXFx1MEQ2M1xcdTBEODFcXHUwRENBXFx1MERDRlxcdTBERDItXFx1MERENFxcdTBERDZcXHUwRERGXFx1MEUzMVxcdTBFMzQtXFx1MEUzQVxcdTBFNDctXFx1MEU0RVxcdTBFQjFcXHUwRUI0LVxcdTBFQkNcXHUwRUM4LVxcdTBFQ0RcXHUwRjE4XFx1MEYxOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGNzEtXFx1MEY3RVxcdTBGODAtXFx1MEY4NFxcdTBGODZcXHUwRjg3XFx1MEY4RC1cXHUwRjk3XFx1MEY5OS1cXHUwRkJDXFx1MEZDNlxcdTEwMkQtXFx1MTAzMFxcdTEwMzItXFx1MTAzN1xcdTEwMzlcXHUxMDNBXFx1MTAzRFxcdTEwM0VcXHUxMDU4XFx1MTA1OVxcdTEwNUUtXFx1MTA2MFxcdTEwNzEtXFx1MTA3NFxcdTEwODJcXHUxMDg1XFx1MTA4NlxcdTEwOERcXHUxMDlEXFx1MTM1RC1cXHUxMzVGXFx1MTcxMi1cXHUxNzE0XFx1MTczMi1cXHUxNzM0XFx1MTc1MlxcdTE3NTNcXHUxNzcyXFx1MTc3M1xcdTE3QjRcXHUxN0I1XFx1MTdCNy1cXHUxN0JEXFx1MTdDNlxcdTE3QzktXFx1MTdEM1xcdTE3RERcXHUxODBCLVxcdTE4MERcXHUxODg1XFx1MTg4NlxcdTE4QTlcXHUxOTIwLVxcdTE5MjJcXHUxOTI3XFx1MTkyOFxcdTE5MzJcXHUxOTM5LVxcdTE5M0JcXHUxQTE3XFx1MUExOFxcdTFBMUJcXHUxQTU2XFx1MUE1OC1cXHUxQTVFXFx1MUE2MFxcdTFBNjJcXHUxQTY1LVxcdTFBNkNcXHUxQTczLVxcdTFBN0NcXHUxQTdGXFx1MUFCMC1cXHUxQUMwXFx1MUIwMC1cXHUxQjAzXFx1MUIzNC1cXHUxQjNBXFx1MUIzQ1xcdTFCNDJcXHUxQjZCLVxcdTFCNzNcXHUxQjgwXFx1MUI4MVxcdTFCQTItXFx1MUJBNVxcdTFCQThcXHUxQkE5XFx1MUJBQi1cXHUxQkFEXFx1MUJFNlxcdTFCRThcXHUxQkU5XFx1MUJFRFxcdTFCRUYtXFx1MUJGMVxcdTFDMkMtXFx1MUMzM1xcdTFDMzZcXHUxQzM3XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0UwXFx1MUNFMi1cXHUxQ0U4XFx1MUNFRFxcdTFDRjRcXHUxQ0Y4XFx1MUNGOVxcdTFEQzAtXFx1MURGOVxcdTFERkItXFx1MURGRlxcdTIwMENcXHUyMEQwLVxcdTIwRjBcXHUyQ0VGLVxcdTJDRjFcXHUyRDdGXFx1MkRFMC1cXHUyREZGXFx1MzAyQS1cXHUzMDJGXFx1MzA5OVxcdTMwOUFcXHVBNjZGLVxcdUE2NzJcXHVBNjc0LVxcdUE2N0RcXHVBNjlFXFx1QTY5RlxcdUE2RjBcXHVBNkYxXFx1QTgwMlxcdUE4MDZcXHVBODBCXFx1QTgyNVxcdUE4MjZcXHVBODJDXFx1QThDNFxcdUE4QzVcXHVBOEUwLVxcdUE4RjFcXHVBOEZGXFx1QTkyNi1cXHVBOTJEXFx1QTk0Ny1cXHVBOTUxXFx1QTk4MC1cXHVBOTgyXFx1QTlCM1xcdUE5QjYtXFx1QTlCOVxcdUE5QkNcXHVBOUJEXFx1QTlFNVxcdUFBMjktXFx1QUEyRVxcdUFBMzFcXHVBQTMyXFx1QUEzNVxcdUFBMzZcXHVBQTQzXFx1QUE0Q1xcdUFBN0NcXHVBQUIwXFx1QUFCMi1cXHVBQUI0XFx1QUFCN1xcdUFBQjhcXHVBQUJFXFx1QUFCRlxcdUFBQzFcXHVBQUVDXFx1QUFFRFxcdUFBRjZcXHVBQkU1XFx1QUJFOFxcdUFCRURcXHVGQjFFXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkY5RVxcdUZGOUZdfFxcdUQ4MDBbXFx1RERGRFxcdURFRTBcXHVERjc2LVxcdURGN0FdfFxcdUQ4MDJbXFx1REUwMS1cXHVERTAzXFx1REUwNVxcdURFMDZcXHVERTBDLVxcdURFMEZcXHVERTM4LVxcdURFM0FcXHVERTNGXFx1REVFNVxcdURFRTZdfFxcdUQ4MDNbXFx1REQyNC1cXHVERDI3XFx1REVBQlxcdURFQUNcXHVERjQ2LVxcdURGNTBdfFxcdUQ4MDRbXFx1REMwMVxcdURDMzgtXFx1REM0NlxcdURDN0YtXFx1REM4MVxcdURDQjMtXFx1RENCNlxcdURDQjlcXHVEQ0JBXFx1REQwMC1cXHVERDAyXFx1REQyNy1cXHVERDJCXFx1REQyRC1cXHVERDM0XFx1REQ3M1xcdUREODBcXHVERDgxXFx1RERCNi1cXHVEREJFXFx1RERDOS1cXHVERENDXFx1RERDRlxcdURFMkYtXFx1REUzMVxcdURFMzRcXHVERTM2XFx1REUzN1xcdURFM0VcXHVERURGXFx1REVFMy1cXHVERUVBXFx1REYwMFxcdURGMDFcXHVERjNCXFx1REYzQ1xcdURGM0VcXHVERjQwXFx1REY1N1xcdURGNjYtXFx1REY2Q1xcdURGNzAtXFx1REY3NF18XFx1RDgwNVtcXHVEQzM4LVxcdURDM0ZcXHVEQzQyLVxcdURDNDRcXHVEQzQ2XFx1REM1RVxcdURDQjBcXHVEQ0IzLVxcdURDQjhcXHVEQ0JBXFx1RENCRFxcdURDQkZcXHVEQ0MwXFx1RENDMlxcdURDQzNcXHVEREFGXFx1RERCMi1cXHVEREI1XFx1RERCQ1xcdUREQkRcXHVEREJGXFx1RERDMFxcdURERENcXHVEREREXFx1REUzMy1cXHVERTNBXFx1REUzRFxcdURFM0ZcXHVERTQwXFx1REVBQlxcdURFQURcXHVERUIwLVxcdURFQjVcXHVERUI3XFx1REYxRC1cXHVERjFGXFx1REYyMi1cXHVERjI1XFx1REYyNy1cXHVERjJCXXxcXHVEODA2W1xcdURDMkYtXFx1REMzN1xcdURDMzlcXHVEQzNBXFx1REQzMFxcdUREM0JcXHVERDNDXFx1REQzRVxcdURENDNcXHVEREQ0LVxcdURERDdcXHVERERBXFx1REREQlxcdURERTBcXHVERTAxLVxcdURFMEFcXHVERTMzLVxcdURFMzhcXHVERTNCLVxcdURFM0VcXHVERTQ3XFx1REU1MS1cXHVERTU2XFx1REU1OS1cXHVERTVCXFx1REU4QS1cXHVERTk2XFx1REU5OFxcdURFOTldfFxcdUQ4MDdbXFx1REMzMC1cXHVEQzM2XFx1REMzOC1cXHVEQzNEXFx1REMzRlxcdURDOTItXFx1RENBN1xcdURDQUEtXFx1RENCMFxcdURDQjJcXHVEQ0IzXFx1RENCNVxcdURDQjZcXHVERDMxLVxcdUREMzZcXHVERDNBXFx1REQzQ1xcdUREM0RcXHVERDNGLVxcdURENDVcXHVERDQ3XFx1REQ5MFxcdUREOTFcXHVERDk1XFx1REQ5N1xcdURFRjNcXHVERUY0XXxcXHVEODFBW1xcdURFRjAtXFx1REVGNFxcdURGMzAtXFx1REYzNl18XFx1RDgxQltcXHVERjRGXFx1REY4Ri1cXHVERjkyXFx1REZFNF18XFx1RDgyRltcXHVEQzlEXFx1REM5RV18XFx1RDgzNFtcXHVERDY1XFx1REQ2Ny1cXHVERDY5XFx1REQ2RS1cXHVERDcyXFx1REQ3Qi1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1REU0Mi1cXHVERTQ0XXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODM4W1xcdURDMDAtXFx1REMwNlxcdURDMDgtXFx1REMxOFxcdURDMUItXFx1REMyMVxcdURDMjNcXHVEQzI0XFx1REMyNi1cXHVEQzJBXFx1REQzMC1cXHVERDM2XFx1REVFQy1cXHVERUVGXXxcXHVEODNBW1xcdURDRDAtXFx1RENENlxcdURENDQtXFx1REQ0QV18XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdfFxcdURCNDBbXFx1REMyMC1cXHVEQzdGXFx1REQwMC1cXHVEREVGXSkkLztcbnZhciByZVByZXBlbmQgPSAvXig/OltcXHUwNjAwLVxcdTA2MDVcXHUwNkREXFx1MDcwRlxcdTA4OTBcXHUwODkxXFx1MDhFMlxcdTBENEVdfFxcdUQ4MDRbXFx1RENCRFxcdURDQ0RcXHVEREMyXFx1RERDM118XFx1RDgwNltcXHVERDNGXFx1REQ0MVxcdURFM0FcXHVERTg0LVxcdURFODldfFxcdUQ4MDdcXHVERDQ2KSQvO1xudmFyIHJlU3BhY2luZ01hcmsgPSAvXig/OltcXHUwOTAzXFx1MDkzQlxcdTA5M0UtXFx1MDk0MFxcdTA5NDktXFx1MDk0Q1xcdTA5NEVcXHUwOTRGXFx1MDk4MlxcdTA5ODNcXHUwOUJGXFx1MDlDMFxcdTA5QzdcXHUwOUM4XFx1MDlDQlxcdTA5Q0NcXHUwQTAzXFx1MEEzRS1cXHUwQTQwXFx1MEE4M1xcdTBBQkUtXFx1MEFDMFxcdTBBQzlcXHUwQUNCXFx1MEFDQ1xcdTBCMDJcXHUwQjAzXFx1MEI0MFxcdTBCNDdcXHUwQjQ4XFx1MEI0QlxcdTBCNENcXHUwQkJGXFx1MEJDMVxcdTBCQzJcXHUwQkM2LVxcdTBCQzhcXHUwQkNBLVxcdTBCQ0NcXHUwQzAxLVxcdTBDMDNcXHUwQzQxLVxcdTBDNDRcXHUwQzgyXFx1MEM4M1xcdTBDQkVcXHUwQ0MwXFx1MENDMVxcdTBDQzNcXHUwQ0M0XFx1MENDN1xcdTBDQzhcXHUwQ0NBXFx1MENDQlxcdTBEMDJcXHUwRDAzXFx1MEQzRlxcdTBENDBcXHUwRDQ2LVxcdTBENDhcXHUwRDRBLVxcdTBENENcXHUwRDgyXFx1MEQ4M1xcdTBERDBcXHUwREQxXFx1MEREOC1cXHUwRERFXFx1MERGMlxcdTBERjNcXHUwRTMzXFx1MEVCM1xcdTBGM0VcXHUwRjNGXFx1MEY3RlxcdTEwMzFcXHUxMDNCXFx1MTAzQ1xcdTEwNTZcXHUxMDU3XFx1MTA4NFxcdTE3MTVcXHUxNzM0XFx1MTdCNlxcdTE3QkUtXFx1MTdDNVxcdTE3QzdcXHUxN0M4XFx1MTkyMy1cXHUxOTI2XFx1MTkyOS1cXHUxOTJCXFx1MTkzMFxcdTE5MzFcXHUxOTMzLVxcdTE5MzhcXHUxQTE5XFx1MUExQVxcdTFBNTVcXHUxQTU3XFx1MUE2RC1cXHUxQTcyXFx1MUIwNFxcdTFCM0JcXHUxQjNELVxcdTFCNDFcXHUxQjQzXFx1MUI0NFxcdTFCODJcXHUxQkExXFx1MUJBNlxcdTFCQTdcXHUxQkFBXFx1MUJFN1xcdTFCRUEtXFx1MUJFQ1xcdTFCRUVcXHUxQkYyXFx1MUJGM1xcdTFDMjQtXFx1MUMyQlxcdTFDMzRcXHUxQzM1XFx1MUNFMVxcdTFDRjdcXHVBODIzXFx1QTgyNFxcdUE4MjdcXHVBODgwXFx1QTg4MVxcdUE4QjQtXFx1QThDM1xcdUE5NTJcXHVBOTUzXFx1QTk4M1xcdUE5QjRcXHVBOUI1XFx1QTlCQVxcdUE5QkJcXHVBOUJFLVxcdUE5QzBcXHVBQTJGXFx1QUEzMFxcdUFBMzNcXHVBQTM0XFx1QUE0RFxcdUFBRUJcXHVBQUVFXFx1QUFFRlxcdUFBRjVcXHVBQkUzXFx1QUJFNFxcdUFCRTZcXHVBQkU3XFx1QUJFOVxcdUFCRUFcXHVBQkVDXXxcXHVEODA0W1xcdURDMDBcXHVEQzAyXFx1REM4MlxcdURDQjAtXFx1RENCMlxcdURDQjdcXHVEQ0I4XFx1REQyQ1xcdURENDVcXHVERDQ2XFx1REQ4MlxcdUREQjMtXFx1RERCNVxcdUREQkZcXHVEREMwXFx1RERDRVxcdURFMkMtXFx1REUyRVxcdURFMzJcXHVERTMzXFx1REUzNVxcdURFRTAtXFx1REVFMlxcdURGMDJcXHVERjAzXFx1REYzRlxcdURGNDEtXFx1REY0NFxcdURGNDdcXHVERjQ4XFx1REY0Qi1cXHVERjREXFx1REY2MlxcdURGNjNdfFxcdUQ4MDVbXFx1REMzNS1cXHVEQzM3XFx1REM0MFxcdURDNDFcXHVEQzQ1XFx1RENCMVxcdURDQjJcXHVEQ0I5XFx1RENCQlxcdURDQkNcXHVEQ0JFXFx1RENDMVxcdUREQjBcXHVEREIxXFx1RERCOC1cXHVEREJCXFx1RERCRVxcdURFMzAtXFx1REUzMlxcdURFM0JcXHVERTNDXFx1REUzRVxcdURFQUNcXHVERUFFXFx1REVBRlxcdURFQjZcXHVERjI2XXxcXHVEODA2W1xcdURDMkMtXFx1REMyRVxcdURDMzhcXHVERDMxLVxcdUREMzVcXHVERDM3XFx1REQzOFxcdUREM0RcXHVERDQwXFx1REQ0MlxcdURERDEtXFx1REREM1xcdUREREMtXFx1RERERlxcdURERTRcXHVERTM5XFx1REU1N1xcdURFNThcXHVERTk3XXxcXHVEODA3W1xcdURDMkZcXHVEQzNFXFx1RENBOVxcdURDQjFcXHVEQ0I0XFx1REQ4QS1cXHVERDhFXFx1REQ5M1xcdUREOTRcXHVERDk2XFx1REVGNVxcdURFRjZdfFxcdUQ4MUJbXFx1REY1MS1cXHVERjg3XFx1REZGMFxcdURGRjFdfFxcdUQ4MzRbXFx1REQ2NlxcdURENkRdKSQvO1xudmFyIHJlTCA9IC9eW1xcdTExMDAtXFx1MTE1RlxcdUE5NjAtXFx1QTk3Q10kLztcbnZhciByZVYgPSAvXltcXHUxMTYwLVxcdTExQTdcXHVEN0IwLVxcdUQ3QzZdJC87XG52YXIgcmVUID0gL15bXFx1MTFBOC1cXHUxMUZGXFx1RDdDQi1cXHVEN0ZCXSQvO1xudmFyIHJlTFYgPSAvXltcXHVBQzAwXFx1QUMxQ1xcdUFDMzhcXHVBQzU0XFx1QUM3MFxcdUFDOENcXHVBQ0E4XFx1QUNDNFxcdUFDRTBcXHVBQ0ZDXFx1QUQxOFxcdUFEMzRcXHVBRDUwXFx1QUQ2Q1xcdUFEODhcXHVBREE0XFx1QURDMFxcdUFERENcXHVBREY4XFx1QUUxNFxcdUFFMzBcXHVBRTRDXFx1QUU2OFxcdUFFODRcXHVBRUEwXFx1QUVCQ1xcdUFFRDhcXHVBRUY0XFx1QUYxMFxcdUFGMkNcXHVBRjQ4XFx1QUY2NFxcdUFGODBcXHVBRjlDXFx1QUZCOFxcdUFGRDRcXHVBRkYwXFx1QjAwQ1xcdUIwMjhcXHVCMDQ0XFx1QjA2MFxcdUIwN0NcXHVCMDk4XFx1QjBCNFxcdUIwRDBcXHVCMEVDXFx1QjEwOFxcdUIxMjRcXHVCMTQwXFx1QjE1Q1xcdUIxNzhcXHVCMTk0XFx1QjFCMFxcdUIxQ0NcXHVCMUU4XFx1QjIwNFxcdUIyMjBcXHVCMjNDXFx1QjI1OFxcdUIyNzRcXHVCMjkwXFx1QjJBQ1xcdUIyQzhcXHVCMkU0XFx1QjMwMFxcdUIzMUNcXHVCMzM4XFx1QjM1NFxcdUIzNzBcXHVCMzhDXFx1QjNBOFxcdUIzQzRcXHVCM0UwXFx1QjNGQ1xcdUI0MThcXHVCNDM0XFx1QjQ1MFxcdUI0NkNcXHVCNDg4XFx1QjRBNFxcdUI0QzBcXHVCNERDXFx1QjRGOFxcdUI1MTRcXHVCNTMwXFx1QjU0Q1xcdUI1NjhcXHVCNTg0XFx1QjVBMFxcdUI1QkNcXHVCNUQ4XFx1QjVGNFxcdUI2MTBcXHVCNjJDXFx1QjY0OFxcdUI2NjRcXHVCNjgwXFx1QjY5Q1xcdUI2QjhcXHVCNkQ0XFx1QjZGMFxcdUI3MENcXHVCNzI4XFx1Qjc0NFxcdUI3NjBcXHVCNzdDXFx1Qjc5OFxcdUI3QjRcXHVCN0QwXFx1QjdFQ1xcdUI4MDhcXHVCODI0XFx1Qjg0MFxcdUI4NUNcXHVCODc4XFx1Qjg5NFxcdUI4QjBcXHVCOENDXFx1QjhFOFxcdUI5MDRcXHVCOTIwXFx1QjkzQ1xcdUI5NThcXHVCOTc0XFx1Qjk5MFxcdUI5QUNcXHVCOUM4XFx1QjlFNFxcdUJBMDBcXHVCQTFDXFx1QkEzOFxcdUJBNTRcXHVCQTcwXFx1QkE4Q1xcdUJBQThcXHVCQUM0XFx1QkFFMFxcdUJBRkNcXHVCQjE4XFx1QkIzNFxcdUJCNTBcXHVCQjZDXFx1QkI4OFxcdUJCQTRcXHVCQkMwXFx1QkJEQ1xcdUJCRjhcXHVCQzE0XFx1QkMzMFxcdUJDNENcXHVCQzY4XFx1QkM4NFxcdUJDQTBcXHVCQ0JDXFx1QkNEOFxcdUJDRjRcXHVCRDEwXFx1QkQyQ1xcdUJENDhcXHVCRDY0XFx1QkQ4MFxcdUJEOUNcXHVCREI4XFx1QkRENFxcdUJERjBcXHVCRTBDXFx1QkUyOFxcdUJFNDRcXHVCRTYwXFx1QkU3Q1xcdUJFOThcXHVCRUI0XFx1QkVEMFxcdUJFRUNcXHVCRjA4XFx1QkYyNFxcdUJGNDBcXHVCRjVDXFx1QkY3OFxcdUJGOTRcXHVCRkIwXFx1QkZDQ1xcdUJGRThcXHVDMDA0XFx1QzAyMFxcdUMwM0NcXHVDMDU4XFx1QzA3NFxcdUMwOTBcXHVDMEFDXFx1QzBDOFxcdUMwRTRcXHVDMTAwXFx1QzExQ1xcdUMxMzhcXHVDMTU0XFx1QzE3MFxcdUMxOENcXHVDMUE4XFx1QzFDNFxcdUMxRTBcXHVDMUZDXFx1QzIxOFxcdUMyMzRcXHVDMjUwXFx1QzI2Q1xcdUMyODhcXHVDMkE0XFx1QzJDMFxcdUMyRENcXHVDMkY4XFx1QzMxNFxcdUMzMzBcXHVDMzRDXFx1QzM2OFxcdUMzODRcXHVDM0EwXFx1QzNCQ1xcdUMzRDhcXHVDM0Y0XFx1QzQxMFxcdUM0MkNcXHVDNDQ4XFx1QzQ2NFxcdUM0ODBcXHVDNDlDXFx1QzRCOFxcdUM0RDRcXHVDNEYwXFx1QzUwQ1xcdUM1MjhcXHVDNTQ0XFx1QzU2MFxcdUM1N0NcXHVDNTk4XFx1QzVCNFxcdUM1RDBcXHVDNUVDXFx1QzYwOFxcdUM2MjRcXHVDNjQwXFx1QzY1Q1xcdUM2NzhcXHVDNjk0XFx1QzZCMFxcdUM2Q0NcXHVDNkU4XFx1QzcwNFxcdUM3MjBcXHVDNzNDXFx1Qzc1OFxcdUM3NzRcXHVDNzkwXFx1QzdBQ1xcdUM3QzhcXHVDN0U0XFx1QzgwMFxcdUM4MUNcXHVDODM4XFx1Qzg1NFxcdUM4NzBcXHVDODhDXFx1QzhBOFxcdUM4QzRcXHVDOEUwXFx1QzhGQ1xcdUM5MThcXHVDOTM0XFx1Qzk1MFxcdUM5NkNcXHVDOTg4XFx1QzlBNFxcdUM5QzBcXHVDOURDXFx1QzlGOFxcdUNBMTRcXHVDQTMwXFx1Q0E0Q1xcdUNBNjhcXHVDQTg0XFx1Q0FBMFxcdUNBQkNcXHVDQUQ4XFx1Q0FGNFxcdUNCMTBcXHVDQjJDXFx1Q0I0OFxcdUNCNjRcXHVDQjgwXFx1Q0I5Q1xcdUNCQjhcXHVDQkQ0XFx1Q0JGMFxcdUNDMENcXHVDQzI4XFx1Q0M0NFxcdUNDNjBcXHVDQzdDXFx1Q0M5OFxcdUNDQjRcXHVDQ0QwXFx1Q0NFQ1xcdUNEMDhcXHVDRDI0XFx1Q0Q0MFxcdUNENUNcXHVDRDc4XFx1Q0Q5NFxcdUNEQjBcXHVDRENDXFx1Q0RFOFxcdUNFMDRcXHVDRTIwXFx1Q0UzQ1xcdUNFNThcXHVDRTc0XFx1Q0U5MFxcdUNFQUNcXHVDRUM4XFx1Q0VFNFxcdUNGMDBcXHVDRjFDXFx1Q0YzOFxcdUNGNTRcXHVDRjcwXFx1Q0Y4Q1xcdUNGQThcXHVDRkM0XFx1Q0ZFMFxcdUNGRkNcXHVEMDE4XFx1RDAzNFxcdUQwNTBcXHVEMDZDXFx1RDA4OFxcdUQwQTRcXHVEMEMwXFx1RDBEQ1xcdUQwRjhcXHVEMTE0XFx1RDEzMFxcdUQxNENcXHVEMTY4XFx1RDE4NFxcdUQxQTBcXHVEMUJDXFx1RDFEOFxcdUQxRjRcXHVEMjEwXFx1RDIyQ1xcdUQyNDhcXHVEMjY0XFx1RDI4MFxcdUQyOUNcXHVEMkI4XFx1RDJENFxcdUQyRjBcXHVEMzBDXFx1RDMyOFxcdUQzNDRcXHVEMzYwXFx1RDM3Q1xcdUQzOThcXHVEM0I0XFx1RDNEMFxcdUQzRUNcXHVENDA4XFx1RDQyNFxcdUQ0NDBcXHVENDVDXFx1RDQ3OFxcdUQ0OTRcXHVENEIwXFx1RDRDQ1xcdUQ0RThcXHVENTA0XFx1RDUyMFxcdUQ1M0NcXHVENTU4XFx1RDU3NFxcdUQ1OTBcXHVENUFDXFx1RDVDOFxcdUQ1RTRcXHVENjAwXFx1RDYxQ1xcdUQ2MzhcXHVENjU0XFx1RDY3MFxcdUQ2OENcXHVENkE4XFx1RDZDNFxcdUQ2RTBcXHVENkZDXFx1RDcxOFxcdUQ3MzRcXHVENzUwXFx1RDc2Q1xcdUQ3ODhdJC87XG52YXIgcmVMVlQgPSAvXltcXHVBQzAxLVxcdUFDMUJcXHVBQzFELVxcdUFDMzdcXHVBQzM5LVxcdUFDNTNcXHVBQzU1LVxcdUFDNkZcXHVBQzcxLVxcdUFDOEJcXHVBQzhELVxcdUFDQTdcXHVBQ0E5LVxcdUFDQzNcXHVBQ0M1LVxcdUFDREZcXHVBQ0UxLVxcdUFDRkJcXHVBQ0ZELVxcdUFEMTdcXHVBRDE5LVxcdUFEMzNcXHVBRDM1LVxcdUFENEZcXHVBRDUxLVxcdUFENkJcXHVBRDZELVxcdUFEODdcXHVBRDg5LVxcdUFEQTNcXHVBREE1LVxcdUFEQkZcXHVBREMxLVxcdUFEREJcXHVBRERELVxcdUFERjdcXHVBREY5LVxcdUFFMTNcXHVBRTE1LVxcdUFFMkZcXHVBRTMxLVxcdUFFNEJcXHVBRTRELVxcdUFFNjdcXHVBRTY5LVxcdUFFODNcXHVBRTg1LVxcdUFFOUZcXHVBRUExLVxcdUFFQkJcXHVBRUJELVxcdUFFRDdcXHVBRUQ5LVxcdUFFRjNcXHVBRUY1LVxcdUFGMEZcXHVBRjExLVxcdUFGMkJcXHVBRjJELVxcdUFGNDdcXHVBRjQ5LVxcdUFGNjNcXHVBRjY1LVxcdUFGN0ZcXHVBRjgxLVxcdUFGOUJcXHVBRjlELVxcdUFGQjdcXHVBRkI5LVxcdUFGRDNcXHVBRkQ1LVxcdUFGRUZcXHVBRkYxLVxcdUIwMEJcXHVCMDBELVxcdUIwMjdcXHVCMDI5LVxcdUIwNDNcXHVCMDQ1LVxcdUIwNUZcXHVCMDYxLVxcdUIwN0JcXHVCMDdELVxcdUIwOTdcXHVCMDk5LVxcdUIwQjNcXHVCMEI1LVxcdUIwQ0ZcXHVCMEQxLVxcdUIwRUJcXHVCMEVELVxcdUIxMDdcXHVCMTA5LVxcdUIxMjNcXHVCMTI1LVxcdUIxM0ZcXHVCMTQxLVxcdUIxNUJcXHVCMTVELVxcdUIxNzdcXHVCMTc5LVxcdUIxOTNcXHVCMTk1LVxcdUIxQUZcXHVCMUIxLVxcdUIxQ0JcXHVCMUNELVxcdUIxRTdcXHVCMUU5LVxcdUIyMDNcXHVCMjA1LVxcdUIyMUZcXHVCMjIxLVxcdUIyM0JcXHVCMjNELVxcdUIyNTdcXHVCMjU5LVxcdUIyNzNcXHVCMjc1LVxcdUIyOEZcXHVCMjkxLVxcdUIyQUJcXHVCMkFELVxcdUIyQzdcXHVCMkM5LVxcdUIyRTNcXHVCMkU1LVxcdUIyRkZcXHVCMzAxLVxcdUIzMUJcXHVCMzFELVxcdUIzMzdcXHVCMzM5LVxcdUIzNTNcXHVCMzU1LVxcdUIzNkZcXHVCMzcxLVxcdUIzOEJcXHVCMzhELVxcdUIzQTdcXHVCM0E5LVxcdUIzQzNcXHVCM0M1LVxcdUIzREZcXHVCM0UxLVxcdUIzRkJcXHVCM0ZELVxcdUI0MTdcXHVCNDE5LVxcdUI0MzNcXHVCNDM1LVxcdUI0NEZcXHVCNDUxLVxcdUI0NkJcXHVCNDZELVxcdUI0ODdcXHVCNDg5LVxcdUI0QTNcXHVCNEE1LVxcdUI0QkZcXHVCNEMxLVxcdUI0REJcXHVCNERELVxcdUI0RjdcXHVCNEY5LVxcdUI1MTNcXHVCNTE1LVxcdUI1MkZcXHVCNTMxLVxcdUI1NEJcXHVCNTRELVxcdUI1NjdcXHVCNTY5LVxcdUI1ODNcXHVCNTg1LVxcdUI1OUZcXHVCNUExLVxcdUI1QkJcXHVCNUJELVxcdUI1RDdcXHVCNUQ5LVxcdUI1RjNcXHVCNUY1LVxcdUI2MEZcXHVCNjExLVxcdUI2MkJcXHVCNjJELVxcdUI2NDdcXHVCNjQ5LVxcdUI2NjNcXHVCNjY1LVxcdUI2N0ZcXHVCNjgxLVxcdUI2OUJcXHVCNjlELVxcdUI2QjdcXHVCNkI5LVxcdUI2RDNcXHVCNkQ1LVxcdUI2RUZcXHVCNkYxLVxcdUI3MEJcXHVCNzBELVxcdUI3MjdcXHVCNzI5LVxcdUI3NDNcXHVCNzQ1LVxcdUI3NUZcXHVCNzYxLVxcdUI3N0JcXHVCNzdELVxcdUI3OTdcXHVCNzk5LVxcdUI3QjNcXHVCN0I1LVxcdUI3Q0ZcXHVCN0QxLVxcdUI3RUJcXHVCN0VELVxcdUI4MDdcXHVCODA5LVxcdUI4MjNcXHVCODI1LVxcdUI4M0ZcXHVCODQxLVxcdUI4NUJcXHVCODVELVxcdUI4NzdcXHVCODc5LVxcdUI4OTNcXHVCODk1LVxcdUI4QUZcXHVCOEIxLVxcdUI4Q0JcXHVCOENELVxcdUI4RTdcXHVCOEU5LVxcdUI5MDNcXHVCOTA1LVxcdUI5MUZcXHVCOTIxLVxcdUI5M0JcXHVCOTNELVxcdUI5NTdcXHVCOTU5LVxcdUI5NzNcXHVCOTc1LVxcdUI5OEZcXHVCOTkxLVxcdUI5QUJcXHVCOUFELVxcdUI5QzdcXHVCOUM5LVxcdUI5RTNcXHVCOUU1LVxcdUI5RkZcXHVCQTAxLVxcdUJBMUJcXHVCQTFELVxcdUJBMzdcXHVCQTM5LVxcdUJBNTNcXHVCQTU1LVxcdUJBNkZcXHVCQTcxLVxcdUJBOEJcXHVCQThELVxcdUJBQTdcXHVCQUE5LVxcdUJBQzNcXHVCQUM1LVxcdUJBREZcXHVCQUUxLVxcdUJBRkJcXHVCQUZELVxcdUJCMTdcXHVCQjE5LVxcdUJCMzNcXHVCQjM1LVxcdUJCNEZcXHVCQjUxLVxcdUJCNkJcXHVCQjZELVxcdUJCODdcXHVCQjg5LVxcdUJCQTNcXHVCQkE1LVxcdUJCQkZcXHVCQkMxLVxcdUJCREJcXHVCQkRELVxcdUJCRjdcXHVCQkY5LVxcdUJDMTNcXHVCQzE1LVxcdUJDMkZcXHVCQzMxLVxcdUJDNEJcXHVCQzRELVxcdUJDNjdcXHVCQzY5LVxcdUJDODNcXHVCQzg1LVxcdUJDOUZcXHVCQ0ExLVxcdUJDQkJcXHVCQ0JELVxcdUJDRDdcXHVCQ0Q5LVxcdUJDRjNcXHVCQ0Y1LVxcdUJEMEZcXHVCRDExLVxcdUJEMkJcXHVCRDJELVxcdUJENDdcXHVCRDQ5LVxcdUJENjNcXHVCRDY1LVxcdUJEN0ZcXHVCRDgxLVxcdUJEOUJcXHVCRDlELVxcdUJEQjdcXHVCREI5LVxcdUJERDNcXHVCREQ1LVxcdUJERUZcXHVCREYxLVxcdUJFMEJcXHVCRTBELVxcdUJFMjdcXHVCRTI5LVxcdUJFNDNcXHVCRTQ1LVxcdUJFNUZcXHVCRTYxLVxcdUJFN0JcXHVCRTdELVxcdUJFOTdcXHVCRTk5LVxcdUJFQjNcXHVCRUI1LVxcdUJFQ0ZcXHVCRUQxLVxcdUJFRUJcXHVCRUVELVxcdUJGMDdcXHVCRjA5LVxcdUJGMjNcXHVCRjI1LVxcdUJGM0ZcXHVCRjQxLVxcdUJGNUJcXHVCRjVELVxcdUJGNzdcXHVCRjc5LVxcdUJGOTNcXHVCRjk1LVxcdUJGQUZcXHVCRkIxLVxcdUJGQ0JcXHVCRkNELVxcdUJGRTdcXHVCRkU5LVxcdUMwMDNcXHVDMDA1LVxcdUMwMUZcXHVDMDIxLVxcdUMwM0JcXHVDMDNELVxcdUMwNTdcXHVDMDU5LVxcdUMwNzNcXHVDMDc1LVxcdUMwOEZcXHVDMDkxLVxcdUMwQUJcXHVDMEFELVxcdUMwQzdcXHVDMEM5LVxcdUMwRTNcXHVDMEU1LVxcdUMwRkZcXHVDMTAxLVxcdUMxMUJcXHVDMTFELVxcdUMxMzdcXHVDMTM5LVxcdUMxNTNcXHVDMTU1LVxcdUMxNkZcXHVDMTcxLVxcdUMxOEJcXHVDMThELVxcdUMxQTdcXHVDMUE5LVxcdUMxQzNcXHVDMUM1LVxcdUMxREZcXHVDMUUxLVxcdUMxRkJcXHVDMUZELVxcdUMyMTdcXHVDMjE5LVxcdUMyMzNcXHVDMjM1LVxcdUMyNEZcXHVDMjUxLVxcdUMyNkJcXHVDMjZELVxcdUMyODdcXHVDMjg5LVxcdUMyQTNcXHVDMkE1LVxcdUMyQkZcXHVDMkMxLVxcdUMyREJcXHVDMkRELVxcdUMyRjdcXHVDMkY5LVxcdUMzMTNcXHVDMzE1LVxcdUMzMkZcXHVDMzMxLVxcdUMzNEJcXHVDMzRELVxcdUMzNjdcXHVDMzY5LVxcdUMzODNcXHVDMzg1LVxcdUMzOUZcXHVDM0ExLVxcdUMzQkJcXHVDM0JELVxcdUMzRDdcXHVDM0Q5LVxcdUMzRjNcXHVDM0Y1LVxcdUM0MEZcXHVDNDExLVxcdUM0MkJcXHVDNDJELVxcdUM0NDdcXHVDNDQ5LVxcdUM0NjNcXHVDNDY1LVxcdUM0N0ZcXHVDNDgxLVxcdUM0OUJcXHVDNDlELVxcdUM0QjdcXHVDNEI5LVxcdUM0RDNcXHVDNEQ1LVxcdUM0RUZcXHVDNEYxLVxcdUM1MEJcXHVDNTBELVxcdUM1MjdcXHVDNTI5LVxcdUM1NDNcXHVDNTQ1LVxcdUM1NUZcXHVDNTYxLVxcdUM1N0JcXHVDNTdELVxcdUM1OTdcXHVDNTk5LVxcdUM1QjNcXHVDNUI1LVxcdUM1Q0ZcXHVDNUQxLVxcdUM1RUJcXHVDNUVELVxcdUM2MDdcXHVDNjA5LVxcdUM2MjNcXHVDNjI1LVxcdUM2M0ZcXHVDNjQxLVxcdUM2NUJcXHVDNjVELVxcdUM2NzdcXHVDNjc5LVxcdUM2OTNcXHVDNjk1LVxcdUM2QUZcXHVDNkIxLVxcdUM2Q0JcXHVDNkNELVxcdUM2RTdcXHVDNkU5LVxcdUM3MDNcXHVDNzA1LVxcdUM3MUZcXHVDNzIxLVxcdUM3M0JcXHVDNzNELVxcdUM3NTdcXHVDNzU5LVxcdUM3NzNcXHVDNzc1LVxcdUM3OEZcXHVDNzkxLVxcdUM3QUJcXHVDN0FELVxcdUM3QzdcXHVDN0M5LVxcdUM3RTNcXHVDN0U1LVxcdUM3RkZcXHVDODAxLVxcdUM4MUJcXHVDODFELVxcdUM4MzdcXHVDODM5LVxcdUM4NTNcXHVDODU1LVxcdUM4NkZcXHVDODcxLVxcdUM4OEJcXHVDODhELVxcdUM4QTdcXHVDOEE5LVxcdUM4QzNcXHVDOEM1LVxcdUM4REZcXHVDOEUxLVxcdUM4RkJcXHVDOEZELVxcdUM5MTdcXHVDOTE5LVxcdUM5MzNcXHVDOTM1LVxcdUM5NEZcXHVDOTUxLVxcdUM5NkJcXHVDOTZELVxcdUM5ODdcXHVDOTg5LVxcdUM5QTNcXHVDOUE1LVxcdUM5QkZcXHVDOUMxLVxcdUM5REJcXHVDOURELVxcdUM5RjdcXHVDOUY5LVxcdUNBMTNcXHVDQTE1LVxcdUNBMkZcXHVDQTMxLVxcdUNBNEJcXHVDQTRELVxcdUNBNjdcXHVDQTY5LVxcdUNBODNcXHVDQTg1LVxcdUNBOUZcXHVDQUExLVxcdUNBQkJcXHVDQUJELVxcdUNBRDdcXHVDQUQ5LVxcdUNBRjNcXHVDQUY1LVxcdUNCMEZcXHVDQjExLVxcdUNCMkJcXHVDQjJELVxcdUNCNDdcXHVDQjQ5LVxcdUNCNjNcXHVDQjY1LVxcdUNCN0ZcXHVDQjgxLVxcdUNCOUJcXHVDQjlELVxcdUNCQjdcXHVDQkI5LVxcdUNCRDNcXHVDQkQ1LVxcdUNCRUZcXHVDQkYxLVxcdUNDMEJcXHVDQzBELVxcdUNDMjdcXHVDQzI5LVxcdUNDNDNcXHVDQzQ1LVxcdUNDNUZcXHVDQzYxLVxcdUNDN0JcXHVDQzdELVxcdUNDOTdcXHVDQzk5LVxcdUNDQjNcXHVDQ0I1LVxcdUNDQ0ZcXHVDQ0QxLVxcdUNDRUJcXHVDQ0VELVxcdUNEMDdcXHVDRDA5LVxcdUNEMjNcXHVDRDI1LVxcdUNEM0ZcXHVDRDQxLVxcdUNENUJcXHVDRDVELVxcdUNENzdcXHVDRDc5LVxcdUNEOTNcXHVDRDk1LVxcdUNEQUZcXHVDREIxLVxcdUNEQ0JcXHVDRENELVxcdUNERTdcXHVDREU5LVxcdUNFMDNcXHVDRTA1LVxcdUNFMUZcXHVDRTIxLVxcdUNFM0JcXHVDRTNELVxcdUNFNTdcXHVDRTU5LVxcdUNFNzNcXHVDRTc1LVxcdUNFOEZcXHVDRTkxLVxcdUNFQUJcXHVDRUFELVxcdUNFQzdcXHVDRUM5LVxcdUNFRTNcXHVDRUU1LVxcdUNFRkZcXHVDRjAxLVxcdUNGMUJcXHVDRjFELVxcdUNGMzdcXHVDRjM5LVxcdUNGNTNcXHVDRjU1LVxcdUNGNkZcXHVDRjcxLVxcdUNGOEJcXHVDRjhELVxcdUNGQTdcXHVDRkE5LVxcdUNGQzNcXHVDRkM1LVxcdUNGREZcXHVDRkUxLVxcdUNGRkJcXHVDRkZELVxcdUQwMTdcXHVEMDE5LVxcdUQwMzNcXHVEMDM1LVxcdUQwNEZcXHVEMDUxLVxcdUQwNkJcXHVEMDZELVxcdUQwODdcXHVEMDg5LVxcdUQwQTNcXHVEMEE1LVxcdUQwQkZcXHVEMEMxLVxcdUQwREJcXHVEMERELVxcdUQwRjdcXHVEMEY5LVxcdUQxMTNcXHVEMTE1LVxcdUQxMkZcXHVEMTMxLVxcdUQxNEJcXHVEMTRELVxcdUQxNjdcXHVEMTY5LVxcdUQxODNcXHVEMTg1LVxcdUQxOUZcXHVEMUExLVxcdUQxQkJcXHVEMUJELVxcdUQxRDdcXHVEMUQ5LVxcdUQxRjNcXHVEMUY1LVxcdUQyMEZcXHVEMjExLVxcdUQyMkJcXHVEMjJELVxcdUQyNDdcXHVEMjQ5LVxcdUQyNjNcXHVEMjY1LVxcdUQyN0ZcXHVEMjgxLVxcdUQyOUJcXHVEMjlELVxcdUQyQjdcXHVEMkI5LVxcdUQyRDNcXHVEMkQ1LVxcdUQyRUZcXHVEMkYxLVxcdUQzMEJcXHVEMzBELVxcdUQzMjdcXHVEMzI5LVxcdUQzNDNcXHVEMzQ1LVxcdUQzNUZcXHVEMzYxLVxcdUQzN0JcXHVEMzdELVxcdUQzOTdcXHVEMzk5LVxcdUQzQjNcXHVEM0I1LVxcdUQzQ0ZcXHVEM0QxLVxcdUQzRUJcXHVEM0VELVxcdUQ0MDdcXHVENDA5LVxcdUQ0MjNcXHVENDI1LVxcdUQ0M0ZcXHVENDQxLVxcdUQ0NUJcXHVENDVELVxcdUQ0NzdcXHVENDc5LVxcdUQ0OTNcXHVENDk1LVxcdUQ0QUZcXHVENEIxLVxcdUQ0Q0JcXHVENENELVxcdUQ0RTdcXHVENEU5LVxcdUQ1MDNcXHVENTA1LVxcdUQ1MUZcXHVENTIxLVxcdUQ1M0JcXHVENTNELVxcdUQ1NTdcXHVENTU5LVxcdUQ1NzNcXHVENTc1LVxcdUQ1OEZcXHVENTkxLVxcdUQ1QUJcXHVENUFELVxcdUQ1QzdcXHVENUM5LVxcdUQ1RTNcXHVENUU1LVxcdUQ1RkZcXHVENjAxLVxcdUQ2MUJcXHVENjFELVxcdUQ2MzdcXHVENjM5LVxcdUQ2NTNcXHVENjU1LVxcdUQ2NkZcXHVENjcxLVxcdUQ2OEJcXHVENjhELVxcdUQ2QTdcXHVENkE5LVxcdUQ2QzNcXHVENkM1LVxcdUQ2REZcXHVENkUxLVxcdUQ2RkJcXHVENkZELVxcdUQ3MTdcXHVENzE5LVxcdUQ3MzNcXHVENzM1LVxcdUQ3NEZcXHVENzUxLVxcdUQ3NkJcXHVENzZELVxcdUQ3ODdcXHVENzg5LVxcdUQ3QTNdJC87XG52YXIgcmVFeHRQaWN0ID0gL14oPzpbXFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMUFcXHUyMzFCXFx1MjMyOFxcdTIzODhcXHUyM0NGXFx1MjNFOS1cXHUyM0YzXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCLVxcdTI1RkVcXHUyNjAwLVxcdTI2MDVcXHUyNjA3LVxcdTI2MTJcXHUyNjE0LVxcdTI2ODVcXHUyNjkwLVxcdTI3MDVcXHUyNzA4LVxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjcyOFxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzYzLVxcdTI3NjdcXHUyNzk1LVxcdTI3OTdcXHUyN0ExXFx1MjdCMFxcdTI3QkZcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURDMDAtXFx1RENGRlxcdUREMEQtXFx1REQwRlxcdUREMkZcXHVERDZDLVxcdURENzFcXHVERDdFXFx1REQ3RlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREFELVxcdURERTVcXHVERTAxLVxcdURFMEZcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzQVxcdURFM0MtXFx1REUzRlxcdURFNDktXFx1REZGQV18XFx1RDgzRFtcXHVEQzAwLVxcdUREM0RcXHVERDQ2LVxcdURFNEZcXHVERTgwLVxcdURFRkZcXHVERjc0LVxcdURGN0ZcXHVERkQ1LVxcdURGRkZdfFxcdUQ4M0VbXFx1REMwQy1cXHVEQzBGXFx1REM0OC1cXHVEQzRGXFx1REM1QS1cXHVEQzVGXFx1REM4OC1cXHVEQzhGXFx1RENBRS1cXHVEQ0ZGXFx1REQwQy1cXHVERDNBXFx1REQzQy1cXHVERDQ1XFx1REQ0Ny1cXHVERUZGXXxcXHVEODNGW1xcdURDMDAtXFx1REZGRF0pJC87XG5cbnZhciBnZXRDb2RlcG9pbnRUeXBlID0gKGNoYXIsIGNvZGUpID0+IHtcbiAgdmFyIHR5cGUgPSBDb2RlcG9pbnRUeXBlLkFueTtcblxuICBpZiAoY2hhci5zZWFyY2gocmVFeHRlbmQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5FeHRlbmQ7XG4gIH1cblxuICBpZiAoY29kZSA9PT0gMHgyMDBkKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlpXSjtcbiAgfVxuXG4gIGlmIChjb2RlID49IDB4MWYxZTYgJiYgY29kZSA8PSAweDFmMWZmKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlJJO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlUHJlcGVuZCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlByZXBlbmQ7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVTcGFjaW5nTWFyaykgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlNwYWNpbmdNYXJrO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlTCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkw7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVWKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuVjtcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZVQpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5UO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlTFYpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5MVjtcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZUxWVCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkxWVDtcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZUV4dFBpY3QpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5FeHRQaWN0O1xuICB9XG5cbiAgcmV0dXJuIHR5cGU7XG59O1xuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKHgsIHkpIHtcbiAgcmV0dXJuICh4ICYgeSkgIT09IDA7XG59XG5cbnZhciBOb25Cb3VuZGFyeVBhaXJzID0gWy8vIEdCNlxuW0NvZGVwb2ludFR5cGUuTCwgQ29kZXBvaW50VHlwZS5MIHwgQ29kZXBvaW50VHlwZS5WIHwgQ29kZXBvaW50VHlwZS5MViB8IENvZGVwb2ludFR5cGUuTFZUXSwgLy8gR0I3XG5bQ29kZXBvaW50VHlwZS5MViB8IENvZGVwb2ludFR5cGUuViwgQ29kZXBvaW50VHlwZS5WIHwgQ29kZXBvaW50VHlwZS5UXSwgLy8gR0I4XG5bQ29kZXBvaW50VHlwZS5MVlQgfCBDb2RlcG9pbnRUeXBlLlQsIENvZGVwb2ludFR5cGUuVF0sIC8vIEdCOVxuW0NvZGVwb2ludFR5cGUuQW55LCBDb2RlcG9pbnRUeXBlLkV4dGVuZCB8IENvZGVwb2ludFR5cGUuWldKXSwgLy8gR0I5YVxuW0NvZGVwb2ludFR5cGUuQW55LCBDb2RlcG9pbnRUeXBlLlNwYWNpbmdNYXJrXSwgLy8gR0I5YlxuW0NvZGVwb2ludFR5cGUuUHJlcGVuZCwgQ29kZXBvaW50VHlwZS5BbnldLCAvLyBHQjExXG5bQ29kZXBvaW50VHlwZS5aV0osIENvZGVwb2ludFR5cGUuRXh0UGljdF0sIC8vIEdCMTIgYW5kIEdCMTNcbltDb2RlcG9pbnRUeXBlLlJJLCBDb2RlcG9pbnRUeXBlLlJJXV07XG5cbmZ1bmN0aW9uIGlzQm91bmRhcnlQYWlyKGxlZnQsIHJpZ2h0KSB7XG4gIHJldHVybiBOb25Cb3VuZGFyeVBhaXJzLmZpbmRJbmRleChyID0+IGludGVyc2VjdHMobGVmdCwgclswXSkgJiYgaW50ZXJzZWN0cyhyaWdodCwgclsxXSkpID09PSAtMTtcbn1cblxudmFyIGVuZGluZ0Vtb2ppWldKID0gLyg/OltcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjM4OFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNVxcdTI2MDctXFx1MjYxMlxcdTI2MTQtXFx1MjY4NVxcdTI2OTAtXFx1MjcwNVxcdTI3MDgtXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjMtXFx1Mjc2N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwMC1cXHVEQ0ZGXFx1REQwRC1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdUREQUQtXFx1RERFNVxcdURFMDEtXFx1REUwRlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REUzQy1cXHVERTNGXFx1REU0OS1cXHVERkZBXXxcXHVEODNEW1xcdURDMDAtXFx1REQzRFxcdURENDYtXFx1REU0RlxcdURFODAtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdURDRkZcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURFRkZdfFxcdUQ4M0ZbXFx1REMwMC1cXHVERkZEXSkoPzpbXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA3RkRcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwOEQzLVxcdTA4RTFcXHUwOEUzLVxcdTA5MDJcXHUwOTNBXFx1MDkzQ1xcdTA5NDEtXFx1MDk0OFxcdTA5NERcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOUJDXFx1MDlCRVxcdTA5QzEtXFx1MDlDNFxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwOUZFXFx1MEEwMVxcdTBBMDJcXHUwQTNDXFx1MEE0MVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxXFx1MEE4MlxcdTBBQkNcXHUwQUMxLVxcdTBBQzVcXHUwQUM3XFx1MEFDOFxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBBRkEtXFx1MEFGRlxcdTBCMDFcXHUwQjNDXFx1MEIzRVxcdTBCM0ZcXHUwQjQxLVxcdTBCNDRcXHUwQjREXFx1MEI1NS1cXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJCRVxcdTBCQzBcXHUwQkNEXFx1MEJEN1xcdTBDMDBcXHUwQzA0XFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzJcXHUwQ0M2XFx1MENDQ1xcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDRTJcXHUwQ0UzXFx1MEQwMFxcdTBEMDFcXHUwRDNCXFx1MEQzQ1xcdTBEM0VcXHUwRDQxLVxcdTBENDRcXHUwRDREXFx1MEQ1N1xcdTBENjJcXHUwRDYzXFx1MEQ4MVxcdTBEQ0FcXHUwRENGXFx1MEREMi1cXHUwREQ0XFx1MERENlxcdTBEREZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRFxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNFxcdTE3QjVcXHUxN0I3LVxcdTE3QkRcXHUxN0M2XFx1MTdDOS1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQzBcXHUxQjAwLVxcdTFCMDNcXHUxQjM0LVxcdTFCM0FcXHUxQjNDXFx1MUI0MlxcdTFCNkItXFx1MUI3M1xcdTFCODBcXHUxQjgxXFx1MUJBMi1cXHUxQkE1XFx1MUJBOFxcdTFCQTlcXHUxQkFCLVxcdTFCQURcXHUxQkU2XFx1MUJFOFxcdTFCRTlcXHUxQkVEXFx1MUJFRi1cXHUxQkYxXFx1MUMyQy1cXHUxQzMzXFx1MUMzNlxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRTBcXHUxQ0UyLVxcdTFDRThcXHUxQ0VEXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREY5XFx1MURGQi1cXHUxREZGXFx1MjAwQ1xcdTIwRDAtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2NkYtXFx1QTY3MlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODI1XFx1QTgyNlxcdUE4MkNcXHVBOEM0XFx1QThDNVxcdUE4RTAtXFx1QThGMVxcdUE4RkZcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5QkRcXHVBOUU1XFx1QUEyOS1cXHVBQTJFXFx1QUEzMVxcdUFBMzJcXHVBQTM1XFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE3Q1xcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUNcXHVBQUVEXFx1QUFGNlxcdUFCRTVcXHVBQkU4XFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRjlFXFx1RkY5Rl18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgwM1tcXHVERDI0LVxcdUREMjdcXHVERUFCXFx1REVBQ1xcdURGNDYtXFx1REY1MF18XFx1RDgwNFtcXHVEQzAxXFx1REMzOC1cXHVEQzQ2XFx1REM3Ri1cXHVEQzgxXFx1RENCMy1cXHVEQ0I2XFx1RENCOVxcdURDQkFcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVEREM5LVxcdUREQ0NcXHVERENGXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REUzRVxcdURFREZcXHVERUUzLVxcdURFRUFcXHVERjAwXFx1REYwMVxcdURGM0JcXHVERjNDXFx1REYzRVxcdURGNDBcXHVERjU3XFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMzgtXFx1REMzRlxcdURDNDItXFx1REM0NFxcdURDNDZcXHVEQzVFXFx1RENCMFxcdURDQjMtXFx1RENCOFxcdURDQkFcXHVEQ0JEXFx1RENCRlxcdURDQzBcXHVEQ0MyXFx1RENDM1xcdUREQUZcXHVEREIyLVxcdUREQjVcXHVEREJDXFx1RERCRFxcdUREQkZcXHVEREMwXFx1REREQ1xcdURERERcXHVERTMzLVxcdURFM0FcXHVERTNEXFx1REUzRlxcdURFNDBcXHVERUFCXFx1REVBRFxcdURFQjAtXFx1REVCNVxcdURFQjdcXHVERjFELVxcdURGMUZcXHVERjIyLVxcdURGMjVcXHVERjI3LVxcdURGMkJdfFxcdUQ4MDZbXFx1REMyRi1cXHVEQzM3XFx1REMzOVxcdURDM0FcXHVERDMwXFx1REQzQlxcdUREM0NcXHVERDNFXFx1REQ0M1xcdURERDQtXFx1REREN1xcdUREREFcXHVERERCXFx1RERFMFxcdURFMDEtXFx1REUwQVxcdURFMzMtXFx1REUzOFxcdURFM0ItXFx1REUzRVxcdURFNDdcXHVERTUxLVxcdURFNTZcXHVERTU5LVxcdURFNUJcXHVERThBLVxcdURFOTZcXHVERTk4XFx1REU5OV18XFx1RDgwN1tcXHVEQzMwLVxcdURDMzZcXHVEQzM4LVxcdURDM0RcXHVEQzNGXFx1REM5Mi1cXHVEQ0E3XFx1RENBQS1cXHVEQ0IwXFx1RENCMlxcdURDQjNcXHVEQ0I1XFx1RENCNlxcdUREMzEtXFx1REQzNlxcdUREM0FcXHVERDNDXFx1REQzRFxcdUREM0YtXFx1REQ0NVxcdURENDdcXHVERDkwXFx1REQ5MVxcdUREOTVcXHVERDk3XFx1REVGM1xcdURFRjRdfFxcdUQ4MUFbXFx1REVGMC1cXHVERUY0XFx1REYzMC1cXHVERjM2XXxcXHVEODFCW1xcdURGNEZcXHVERjhGLVxcdURGOTJcXHVERkU0XXxcXHVEODJGW1xcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjVcXHVERDY3LVxcdURENjlcXHVERDZFLVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFcXHVERDMwLVxcdUREMzZcXHVERUVDLVxcdURFRUZdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XFx1REQ0NC1cXHVERDRBXXxcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1REI0MFtcXHVEQzIwLVxcdURDN0ZcXHVERDAwLVxcdURERUZdKSpcXHUyMDBEJC87XG5cbnZhciBlbmRzV2l0aEVtb2ppWldKID0gc3RyID0+IHtcbiAgcmV0dXJuIHN0ci5zZWFyY2goZW5kaW5nRW1vamlaV0opICE9PSAtMTtcbn07XG5cbnZhciBlbmRpbmdSSXMgPSAvKD86XFx1RDgzQ1tcXHVEREU2LVxcdURERkZdKSskL2c7XG5cbnZhciBlbmRzV2l0aE9kZE51bWJlck9mUklzID0gc3RyID0+IHtcbiAgdmFyIG1hdGNoID0gc3RyLm1hdGNoKGVuZGluZ1JJcyk7XG5cbiAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIC8vIEEgUkkgaXMgcmVwcmVzZW50ZWQgYnkgYSBzdXJyb2dhdGUgcGFpci5cbiAgICB2YXIgbnVtUklzID0gbWF0Y2hbMF0ubGVuZ3RoIC8gMjtcbiAgICByZXR1cm4gbnVtUklzICUgMiA9PT0gMTtcbiAgfVxufTtcblxuLyoqXHJcbiAqIFNoYXJlZCB0aGUgZnVuY3Rpb24gd2l0aCBpc0VsZW1lbnRUeXBlIHV0aWxpdHlcclxuICovXG5cbnZhciBpc0VsZW1lbnQgPSB2YWx1ZSA9PiB7XG4gIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBOb2RlLmlzTm9kZUxpc3QodmFsdWUuY2hpbGRyZW4pICYmICFFZGl0b3IuaXNFZGl0b3IodmFsdWUpO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5cbnZhciBFbGVtZW50ID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlICdBbmNlc3RvcicgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc0FuY2VzdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbik7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgRWxlbWVudGAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc0VsZW1lbnQsXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBhcnJheSBvZiBgRWxlbWVudGAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNFbGVtZW50TGlzdCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeSh2YWwgPT4gRWxlbWVudC5pc0VsZW1lbnQodmFsKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBzZXQgb2YgcHJvcHMgaXMgYSBwYXJ0aWFsIG9mIEVsZW1lbnQuXHJcbiAgICovXG4gIGlzRWxlbWVudFByb3BzKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuICE9PSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgRWxlbWVudGAgaW50ZXJmYWNlIGFuZCBoYXMgZWxlbWVudEtleSB3aXRoIHNlbGVjdGVkIHZhbHVlLlxyXG4gICAqIERlZmF1bHQgaXQgY2hlY2sgdG8gYHR5cGVgIGtleSB2YWx1ZVxyXG4gICAqL1xuICBpc0VsZW1lbnRUeXBlOiBmdW5jdGlvbiBpc0VsZW1lbnRUeXBlKHZhbHVlLCBlbGVtZW50VmFsKSB7XG4gICAgdmFyIGVsZW1lbnRLZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICd0eXBlJztcbiAgICByZXR1cm4gaXNFbGVtZW50KHZhbHVlKSAmJiB2YWx1ZVtlbGVtZW50S2V5XSA9PT0gZWxlbWVudFZhbDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhbiBlbGVtZW50IG1hdGNoZXMgc2V0IG9mIHByb3BlcnRpZXMuXHJcbiAgICpcclxuICAgKiBOb3RlOiB0aGlzIGNoZWNrcyBjdXN0b20gcHJvcGVydGllcywgYW5kIGl0IGRvZXMgbm90IGVuc3VyZSB0aGF0IGFueVxyXG4gICAqIGNoaWxkcmVuIGFyZSBlcXVpdmFsZW50LlxyXG4gICAqL1xuICBtYXRjaGVzKGVsZW1lbnQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoa2V5ID09PSAnY2hpbGRyZW4nKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudFtrZXldICE9PSBwcm9wc1trZXldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG59O1xuXG52YXIgX2V4Y2x1ZGVkJDQgPSBbXCJ0ZXh0XCJdLFxuICAgIF9leGNsdWRlZDIkMyA9IFtcInRleHRcIl07XG5cbmZ1bmN0aW9uIG93bktleXMkOChvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkOCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDgoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ4KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIElTX0VESVRPUl9DQUNIRSA9IG5ldyBXZWFrTWFwKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxudmFyIEVkaXRvciA9IHtcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBhbmNlc3RvciBhYm92ZSBhIGxvY2F0aW9uIGluIHRoZSBkb2N1bWVudC5cclxuICAgKi9cbiAgYWJvdmUoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgbWF0Y2hcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQpO1xuICAgIHZhciByZXZlcnNlID0gbW9kZSA9PT0gJ2xvd2VzdCc7XG5cbiAgICBmb3IgKHZhciBbbiwgcF0gb2YgRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgdm9pZHMsXG4gICAgICBtYXRjaCxcbiAgICAgIHJldmVyc2VcbiAgICB9KSkge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG4pKSByZXR1cm47XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKHAsIGF0LmFuY2hvci5wYXRoKSAmJiBQYXRoLmlzQW5jZXN0b3IocCwgYXQuZm9jdXMucGF0aCkpIHtcbiAgICAgICAgICByZXR1cm4gW24sIHBdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIVBhdGguZXF1YWxzKHBhdGgsIHApKSB7XG4gICAgICAgICAgcmV0dXJuIFtuLCBwXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBBZGQgYSBjdXN0b20gcHJvcGVydHkgdG8gdGhlIGxlYWYgdGV4dCBub2RlcyBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBjb2xsYXBzZWQsIHRoZSBtYXJrcyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxyXG4gICAqIGBlZGl0b3IubWFya3NgIHByb3BlcnR5IGluc3RlYWQsIGFuZCBhcHBsaWVkIHdoZW4gdGV4dCBpcyBpbnNlcnRlZCBuZXh0LlxyXG4gICAqL1xuICBhZGRNYXJrKGVkaXRvciwga2V5LCB2YWx1ZSkge1xuICAgIGVkaXRvci5hZGRNYXJrKGtleSwgdmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcG9pbnQgYWZ0ZXIgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgYWZ0ZXIoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgYW5jaG9yID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gICAgdmFyIGZvY3VzID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH07XG4gICAgdmFyIHtcbiAgICAgIGRpc3RhbmNlID0gMVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgZm9yICh2YXIgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBhdDogcmFuZ2VcbiAgICB9KSkpIHtcbiAgICAgIGlmIChkID4gZGlzdGFuY2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgIHRhcmdldCA9IHA7XG4gICAgICB9XG5cbiAgICAgIGQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcG9pbnQgYmVmb3JlIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGJlZm9yZShlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBhbmNob3IgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSk7XG4gICAgdmFyIGZvY3VzID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICB9KTtcbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH07XG4gICAgdmFyIHtcbiAgICAgIGRpc3RhbmNlID0gMVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgZm9yICh2YXIgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBhdDogcmFuZ2UsXG4gICAgICByZXZlcnNlOiB0cnVlXG4gICAgfSkpKSB7XG4gICAgICBpZiAoZCA+IGRpc3RhbmNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICB0YXJnZXQgPSBwO1xuICAgICAgfVxuXG4gICAgICBkKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yIGJhY2t3YXJkIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVCYWNrd2FyZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHVuaXQgPSAnY2hhcmFjdGVyJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGVkaXRvci5kZWxldGVCYWNrd2FyZCh1bml0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yIGZvcndhcmQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICovXG4gIGRlbGV0ZUZvcndhcmQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcidcbiAgICB9ID0gb3B0aW9ucztcbiAgICBlZGl0b3IuZGVsZXRlRm9yd2FyZCh1bml0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgdGhlIGNvbnRlbnQgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVGcmFnbWVudChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGRpcmVjdGlvbiA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGVkaXRvci5kZWxldGVGcmFnbWVudChkaXJlY3Rpb24pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZWRnZXMoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBbRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpLCBFZGl0b3IuZW5kKGVkaXRvciwgYXQpXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBlbmQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ2VuZCdcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGZpcnN0IG5vZGUgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZmlyc3QoZWRpdG9yLCBhdCkge1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgIH0pO1xuICAgIHJldHVybiBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZnJhZ21lbnQgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZnJhZ21lbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICB2YXIgZnJhZ21lbnQgPSBOb2RlLmZyYWdtZW50KGVkaXRvciwgcmFuZ2UpO1xuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgaGFzIGJsb2NrIGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNCbG9ja3MoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uc29tZShuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgbm9kZSBoYXMgaW5saW5lIGFuZCB0ZXh0IGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNJbmxpbmVzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLnNvbWUobiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBub2RlIGhhcyB0ZXh0IGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNUZXh0cyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5ldmVyeShuID0+IFRleHQuaXNUZXh0KG4pKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBibG9jayBicmVhayBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0QnJlYWsoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBzb2Z0IGJyZWFrIGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydFNvZnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0U29mdEJyZWFrKCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgZnJhZ21lbnQgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgZXhwYW5kZWQsIGl0IHdpbGwgYmUgZGVsZXRlZCBmaXJzdC5cclxuICAgKi9cbiAgaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCkge1xuICAgIGVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgbm9kZSBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnROb2RlKGVkaXRvciwgbm9kZSkge1xuICAgIGVkaXRvci5pbnNlcnROb2RlKG5vZGUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCB0ZXh0IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgZWRpdG9yLmluc2VydFRleHQodGV4dCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGJsb2NrIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzQmxvY2soZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSkgJiYgIWVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBgRWRpdG9yYCBvYmplY3QuXHJcbiAgICovXG4gIGlzRWRpdG9yKHZhbHVlKSB7XG4gICAgdmFyIGNhY2hlZElzRWRpdG9yID0gSVNfRURJVE9SX0NBQ0hFLmdldCh2YWx1ZSk7XG5cbiAgICBpZiAoY2FjaGVkSXNFZGl0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZElzRWRpdG9yO1xuICAgIH1cblxuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaXNFZGl0b3IgPSB0eXBlb2YgdmFsdWUuYWRkTWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuYXBwbHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmRlbGV0ZUJhY2t3YXJkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5kZWxldGVGb3J3YXJkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5kZWxldGVGcmFnbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0QnJlYWsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydFNvZnRCcmVhayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0RnJhZ21lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydE5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydFRleHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzSW5saW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc1ZvaWQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLm5vcm1hbGl6ZU5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLm9uQ2hhbmdlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5yZW1vdmVNYXJrID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5nZXREaXJ0eVBhdGhzID09PSAnZnVuY3Rpb24nICYmICh2YWx1ZS5tYXJrcyA9PT0gbnVsbCB8fCBpc1BsYWluT2JqZWN0KHZhbHVlLm1hcmtzKSkgJiYgKHZhbHVlLnNlbGVjdGlvbiA9PT0gbnVsbCB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlLnNlbGVjdGlvbikpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbikgJiYgT3BlcmF0aW9uLmlzT3BlcmF0aW9uTGlzdCh2YWx1ZS5vcGVyYXRpb25zKTtcbiAgICBJU19FRElUT1JfQ0FDSEUuc2V0KHZhbHVlLCBpc0VkaXRvcik7XG4gICAgcmV0dXJuIGlzRWRpdG9yO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgdGhlIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBpc0VuZChlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgYXQpO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIGVuZCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBhbiBlZGdlIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGlzRWRnZShlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkgfHwgRWRpdG9yLmlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGVtcHR5LCBhY2NvdW50aW5nIGZvciB2b2lkIG5vZGVzLlxyXG4gICAqL1xuICBpc0VtcHR5KGVkaXRvciwgZWxlbWVudCkge1xuICAgIHZhciB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBlbGVtZW50O1xuICAgIHZhciBbZmlyc3RdID0gY2hpbGRyZW47XG4gICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgVGV4dC5pc1RleHQoZmlyc3QpICYmIGZpcnN0LnRleHQgPT09ICcnICYmICFlZGl0b3IuaXNWb2lkKGVsZW1lbnQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaW5saW5lIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzSW5saW5lKGVkaXRvciwgdmFsdWUpIHtcbiAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQodmFsdWUpICYmIGVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGVkaXRvciBpcyBjdXJyZW50bHkgbm9ybWFsaXppbmcgYWZ0ZXIgZWFjaCBvcGVyYXRpb24uXHJcbiAgICovXG4gIGlzTm9ybWFsaXppbmcoZWRpdG9yKSB7XG4gICAgdmFyIGlzTm9ybWFsaXppbmcgPSBOT1JNQUxJWklORy5nZXQoZWRpdG9yKTtcbiAgICByZXR1cm4gaXNOb3JtYWxpemluZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlzTm9ybWFsaXppbmc7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyB0aGUgc3RhcnQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIC8vIFBFUkY6IElmIHRoZSBvZmZzZXQgaXNuJ3QgYDBgIHdlIGtub3cgaXQncyBub3QgdGhlIHN0YXJ0LlxuICAgIGlmIChwb2ludC5vZmZzZXQgIT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhwb2ludCwgc3RhcnQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSB2b2lkIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzVm9pZChlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KHZhbHVlKSAmJiBlZGl0b3IuaXNWb2lkKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxhc3Qgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBsYXN0KGVkaXRvciwgYXQpIHtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gICAgcmV0dXJuIEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsZWFmIHRleHQgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBsZWFmKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgICB2YXIgbm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIHBhdGgpO1xuICAgIHJldHVybiBbbm9kZSwgcGF0aF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUgbGV2ZWxzIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gICpsZXZlbHMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGV2ZWxzID0gW107XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0KTtcblxuICAgIGZvciAodmFyIFtuLCBwXSBvZiBOb2RlLmxldmVscyhlZGl0b3IsIHBhdGgpKSB7XG4gICAgICBpZiAoIW1hdGNoKG4sIHApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXZlbHMucHVzaChbbiwgcF0pO1xuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgbGV2ZWxzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB5aWVsZCogbGV2ZWxzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWFya3MgdGhhdCB3b3VsZCBiZSBhZGRlZCB0byB0ZXh0IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKi9cbiAgbWFya3MoZWRpdG9yKSB7XG4gICAgdmFyIHtcbiAgICAgIG1hcmtzLFxuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobWFya3MpIHtcbiAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICB2YXIgW21hdGNoXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBbX25vZGVdID0gbWF0Y2g7XG5cbiAgICAgICAgdmFyIF9yZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9ub2RlLCBfZXhjbHVkZWQkNCk7XG5cbiAgICAgICAgcmV0dXJuIF9yZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBhbmNob3JcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIHZhciB7XG4gICAgICBwYXRoXG4gICAgfSA9IGFuY2hvcjtcbiAgICB2YXIgW25vZGVdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBwYXRoKTtcblxuICAgIGlmIChhbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICB2YXIgcHJldiA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgICAgfSk7XG4gICAgICB2YXIgbWFya2VkVm9pZCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pICYmIGVkaXRvci5tYXJrYWJsZVZvaWQobilcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIW1hcmtlZFZvaWQpIHtcbiAgICAgICAgdmFyIGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbilcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHByZXYgJiYgYmxvY2spIHtcbiAgICAgICAgICB2YXIgW3ByZXZOb2RlLCBwcmV2UGF0aF0gPSBwcmV2O1xuICAgICAgICAgIHZhciBbLCBibG9ja1BhdGhdID0gYmxvY2s7XG5cbiAgICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKGJsb2NrUGF0aCwgcHJldlBhdGgpKSB7XG4gICAgICAgICAgICBub2RlID0gcHJldk5vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMiQzKTtcblxuICAgIHJldHVybiByZXN0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWF0Y2hpbmcgbm9kZSBpbiB0aGUgYnJhbmNoIG9mIHRoZSBkb2N1bWVudCBhZnRlciBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBuZXh0KGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaCxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2ludEFmdGVyTG9jYXRpb24gPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBhdCwge1xuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICBpZiAoIXBvaW50QWZ0ZXJMb2NhdGlvbikgcmV0dXJuO1xuICAgIHZhciBbLCB0b10gPSBFZGl0b3IubGFzdChlZGl0b3IsIFtdKTtcbiAgICB2YXIgc3BhbiA9IFtwb2ludEFmdGVyTG9jYXRpb24ucGF0aCwgdG9dO1xuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSAmJiBhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIG5leHQgbm9kZSBmcm9tIHRoZSByb290IG5vZGUhXCIpO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgbWF0Y2ggPSBuID0+IHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgW25leHRdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQ6IHNwYW4sXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBub2RlKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gICAgcmV0dXJuIFtub2RlLCBwYXRoXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBub2RlcyBpbiB0aGUgRWRpdG9yLlxyXG4gICAqL1xuICAqbm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtb2RlID0gJ2FsbCcsXG4gICAgICB1bml2ZXJzYWwgPSBmYWxzZSxcbiAgICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgbWF0Y2hcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuXG4gICAgaWYgKFNwYW4uaXNTcGFuKGF0KSkge1xuICAgICAgZnJvbSA9IGF0WzBdO1xuICAgICAgdG8gPSBhdFsxXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZpcnN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgICBlZGdlOiAnc3RhcnQnXG4gICAgICB9KTtcbiAgICAgIHZhciBsYXN0ID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgICBlZGdlOiAnZW5kJ1xuICAgICAgfSk7XG4gICAgICBmcm9tID0gcmV2ZXJzZSA/IGxhc3QgOiBmaXJzdDtcbiAgICAgIHRvID0gcmV2ZXJzZSA/IGZpcnN0IDogbGFzdDtcbiAgICB9XG5cbiAgICB2YXIgbm9kZUVudHJpZXMgPSBOb2RlLm5vZGVzKGVkaXRvciwge1xuICAgICAgcmV2ZXJzZSxcbiAgICAgIGZyb20sXG4gICAgICB0byxcbiAgICAgIHBhc3M6IF9yZWYgPT4ge1xuICAgICAgICB2YXIgW25dID0gX3JlZjtcbiAgICAgICAgcmV0dXJuIHZvaWRzID8gZmFsc2UgOiBFZGl0b3IuaXNWb2lkKGVkaXRvciwgbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgICB2YXIgaGl0O1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIG5vZGVFbnRyaWVzKSB7XG4gICAgICB2YXIgaXNMb3dlciA9IGhpdCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgaGl0WzFdKSA9PT0gMDsgLy8gSW4gaGlnaGVzdCBtb2RlIGFueSBub2RlIGxvd2VyIHRoYW4gdGhlIGxhc3QgaGl0IGlzIG5vdCBhIG1hdGNoLlxuXG4gICAgICBpZiAobW9kZSA9PT0gJ2hpZ2hlc3QnICYmIGlzTG93ZXIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghbWF0Y2gobm9kZSwgcGF0aCkpIHtcbiAgICAgICAgLy8gSWYgd2UndmUgYXJyaXZlZCBhdCBhIGxlYWYgdGV4dCBub2RlIHRoYXQgaXMgbm90IGxvd2VyIHRoYW4gdGhlIGxhc3RcbiAgICAgICAgLy8gaGl0LCB0aGVuIHdlJ3ZlIGZvdW5kIGEgYnJhbmNoIHRoYXQgZG9lc24ndCBpbmNsdWRlIGEgbWF0Y2gsIHdoaWNoXG4gICAgICAgIC8vIG1lYW5zIHRoZSBtYXRjaCBpcyBub3QgdW5pdmVyc2FsLlxuICAgICAgICBpZiAodW5pdmVyc2FsICYmICFpc0xvd2VyICYmIFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IC8vIElmIHRoZXJlJ3MgYSBtYXRjaCBhbmQgaXQncyBsb3dlciB0aGFuIHRoZSBsYXN0LCB1cGRhdGUgdGhlIGhpdC5cblxuXG4gICAgICBpZiAobW9kZSA9PT0gJ2xvd2VzdCcgJiYgaXNMb3dlcikge1xuICAgICAgICBoaXQgPSBbbm9kZSwgcGF0aF07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBJbiBsb3dlc3QgbW9kZSB3ZSBlbWl0IHRoZSBsYXN0IGhpdCwgb25jZSBpdCdzIGd1YXJhbnRlZWQgbG93ZXN0LlxuXG5cbiAgICAgIHZhciBlbWl0ID0gbW9kZSA9PT0gJ2xvd2VzdCcgPyBoaXQgOiBbbm9kZSwgcGF0aF07XG5cbiAgICAgIGlmIChlbWl0KSB7XG4gICAgICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goZW1pdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgZW1pdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBoaXQgPSBbbm9kZSwgcGF0aF07XG4gICAgfSAvLyBTaW5jZSBsb3dlc3QgaXMgYWx3YXlzIGVtaXR0aW5nIG9uZSBiZWhpbmQsIGNhdGNoIHVwIGF0IHRoZSBlbmQuXG5cblxuICAgIGlmIChtb2RlID09PSAnbG93ZXN0JyAmJiBoaXQpIHtcbiAgICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKGhpdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB5aWVsZCBoaXQ7XG4gICAgICB9XG4gICAgfSAvLyBVbml2ZXJzYWwgZGVmZXJzIHRvIGVuc3VyZSB0aGF0IHRoZSBtYXRjaCBvY2N1cnMgaW4gZXZlcnkgYnJhbmNoLCBzbyB3ZVxuICAgIC8vIHlpZWxkIGFsbCBvZiB0aGUgbWF0Y2hlcyBhZnRlciBpdGVyYXRpbmcuXG5cblxuICAgIGlmICh1bml2ZXJzYWwpIHtcbiAgICAgIHlpZWxkKiBtYXRjaGVzO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBOb3JtYWxpemUgYW55IGRpcnR5IG9iamVjdHMgaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgbm9ybWFsaXplKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZm9yY2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgdmFyIGdldERpcnR5UGF0aHMgPSBlZGl0b3IgPT4ge1xuICAgICAgcmV0dXJuIERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0RGlydHlQYXRoS2V5cyA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gRElSVFlfUEFUSF9LRVlTLmdldChlZGl0b3IpIHx8IG5ldyBTZXQoKTtcbiAgICB9O1xuXG4gICAgdmFyIHBvcERpcnR5UGF0aCA9IGVkaXRvciA9PiB7XG4gICAgICB2YXIgcGF0aCA9IGdldERpcnR5UGF0aHMoZWRpdG9yKS5wb3AoKTtcbiAgICAgIHZhciBrZXkgPSBwYXRoLmpvaW4oJywnKTtcbiAgICAgIGdldERpcnR5UGF0aEtleXMoZWRpdG9yKS5kZWxldGUoa2V5KTtcbiAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG5cbiAgICBpZiAoIUVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZm9yY2UpIHtcbiAgICAgIHZhciBhbGxQYXRocyA9IEFycmF5LmZyb20oTm9kZS5ub2RlcyhlZGl0b3IpLCBfcmVmMiA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWYyO1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFsbFBhdGhLZXlzID0gbmV3IFNldChhbGxQYXRocy5tYXAocCA9PiBwLmpvaW4oJywnKSkpO1xuICAgICAgRElSVFlfUEFUSFMuc2V0KGVkaXRvciwgYWxsUGF0aHMpO1xuICAgICAgRElSVFlfUEFUSF9LRVlTLnNldChlZGl0b3IsIGFsbFBhdGhLZXlzKTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0RGlydHlQYXRocyhlZGl0b3IpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICAvKlxyXG4gICAgICAgIEZpeCBkaXJ0eSBlbGVtZW50cyB3aXRoIG5vIGNoaWxkcmVuLlxyXG4gICAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKCkgZG9lcyBmaXggdGhpcywgYnV0IHNvbWUgbm9ybWFsaXphdGlvbiBmaXhlcyBhbHNvIHJlcXVpcmUgaXQgdG8gd29yay5cclxuICAgICAgICBSdW5uaW5nIGFuIGluaXRpYWwgcGFzcyBhdm9pZHMgdGhlIGNhdGNoLTIyIHJhY2UgY29uZGl0aW9uLlxyXG4gICAgICAqL1xuICAgICAgZm9yICh2YXIgZGlydHlQYXRoIG9mIGdldERpcnR5UGF0aHMoZWRpdG9yKSkge1xuICAgICAgICBpZiAoTm9kZS5oYXMoZWRpdG9yLCBkaXJ0eVBhdGgpKSB7XG4gICAgICAgICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBkaXJ0eVBhdGgpO1xuICAgICAgICAgIHZhciBbbm9kZSwgX10gPSBlbnRyeTtcbiAgICAgICAgICAvKlxyXG4gICAgICAgICAgICBUaGUgZGVmYXVsdCBub3JtYWxpemVyIGluc2VydHMgYW4gZW1wdHkgdGV4dCBub2RlIGluIHRoaXMgc2NlbmFyaW8sIGJ1dCBpdCBjYW4gYmUgY3VzdG9taXNlZC5cclxuICAgICAgICAgICAgU28gdGhlcmUgaXMgc29tZSByaXNrIGhlcmUuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgQXMgbG9uZyBhcyB0aGUgbm9ybWFsaXplciBvbmx5IGluc2VydHMgY2hpbGQgbm9kZXMgZm9yIHRoaXMgY2FzZSBpdCBpcyBzYWZlIHRvIGRvIGluIGFueSBvcmRlcjtcclxuICAgICAgICAgICAgYnkgZGVmaW5pdGlvbiBhZGRpbmcgY2hpbGRyZW4gdG8gYW4gZW1wdHkgbm9kZSBjYW4ndCBjYXVzZSBvdGhlciBwYXRocyB0byBjaGFuZ2UuXHJcbiAgICAgICAgICAqL1xuXG4gICAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBlZGl0b3Iubm9ybWFsaXplTm9kZShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXggPSBnZXREaXJ0eVBhdGhzKGVkaXRvcikubGVuZ3RoICogNDI7IC8vIEhBQ0s6IGJldHRlciB3YXk/XG5cbiAgICAgIHZhciBtID0gMDtcblxuICAgICAgd2hpbGUgKGdldERpcnR5UGF0aHMoZWRpdG9yKS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgaWYgKG0gPiBtYXgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcXG4gICAgICAgICAgICBDb3VsZCBub3QgY29tcGxldGVseSBub3JtYWxpemUgdGhlIGVkaXRvciBhZnRlciBcIi5jb25jYXQobWF4LCBcIiBpdGVyYXRpb25zISBUaGlzIGlzIHVzdWFsbHkgZHVlIHRvIGluY29ycmVjdCBub3JtYWxpemF0aW9uIGxvZ2ljIHRoYXQgbGVhdmVzIGEgbm9kZSBpbiBhbiBpbnZhbGlkIHN0YXRlLlxcbiAgICAgICAgICBcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9kaXJ0eVBhdGggPSBwb3BEaXJ0eVBhdGgoZWRpdG9yKTsgLy8gSWYgdGhlIG5vZGUgZG9lc24ndCBleGlzdCBpbiB0aGUgdHJlZSwgaXQgZG9lcyBub3QgbmVlZCB0byBiZSBub3JtYWxpemVkLlxuXG5cbiAgICAgICAgaWYgKE5vZGUuaGFzKGVkaXRvciwgX2RpcnR5UGF0aCkpIHtcbiAgICAgICAgICB2YXIgX2VudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBfZGlydHlQYXRoKTtcblxuICAgICAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKF9lbnRyeSk7XG4gICAgICAgIH1cblxuICAgICAgICBtKys7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwYXJlbnQgbm9kZSBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBwYXJlbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gICAgdmFyIGVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXJlbnRQYXRoKTtcbiAgICByZXR1cm4gZW50cnk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBwYXRoIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHBhdGgoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZGVwdGgsXG4gICAgICBlZGdlXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICB2YXIgWywgZmlyc3RQYXRoXSA9IE5vZGUuZmlyc3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIGF0ID0gZmlyc3RQYXRoO1xuICAgICAgfSBlbHNlIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgICB2YXIgWywgbGFzdFBhdGhdID0gTm9kZS5sYXN0KGVkaXRvciwgYXQpO1xuICAgICAgICBhdCA9IGxhc3RQYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgICAgYXQgPSBSYW5nZS5zdGFydChhdCk7XG4gICAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICAgIGF0ID0gUmFuZ2UuZW5kKGF0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0ID0gUGF0aC5jb21tb24oYXQuYW5jaG9yLnBhdGgsIGF0LmZvY3VzLnBhdGgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChQb2ludC5pc1BvaW50KGF0KSkge1xuICAgICAgYXQgPSBhdC5wYXRoO1xuICAgIH1cblxuICAgIGlmIChkZXB0aCAhPSBudWxsKSB7XG4gICAgICBhdCA9IGF0LnNsaWNlKDAsIGRlcHRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXQ7XG4gIH0sXG5cbiAgaGFzUGF0aChlZGl0b3IsIHBhdGgpIHtcbiAgICByZXR1cm4gTm9kZS5oYXMoZWRpdG9yLCBwYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBtdXRhYmxlIHJlZiBmb3IgYSBgUGF0aGAgb2JqZWN0LCB3aGljaCB3aWxsIHN0YXkgaW4gc3luYyBhcyBuZXdcclxuICAgKiBvcGVyYXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHBhdGhSZWYoZWRpdG9yLCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiBwYXRoLFxuICAgICAgYWZmaW5pdHksXG5cbiAgICAgIHVucmVmKCkge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgfSA9IHJlZjtcbiAgICAgICAgdmFyIHBhdGhSZWZzID0gRWRpdG9yLnBhdGhSZWZzKGVkaXRvcik7XG4gICAgICAgIHBhdGhSZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuXG4gICAgfTtcbiAgICB2YXIgcmVmcyA9IEVkaXRvci5wYXRoUmVmcyhlZGl0b3IpO1xuICAgIHJlZnMuYWRkKHJlZik7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHNldCBvZiBjdXJyZW50bHkgdHJhY2tlZCBwYXRoIHJlZnMgb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcGF0aFJlZnMoZWRpdG9yKSB7XG4gICAgdmFyIHJlZnMgPSBQQVRIX1JFRlMuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXJlZnMpIHtcbiAgICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgICBQQVRIX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZnM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzdGFydCBvciBlbmQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcG9pbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZWRnZSA9ICdzdGFydCdcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIHZhciBwYXRoO1xuXG4gICAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdmFyIFssIGxhc3RQYXRoXSA9IE5vZGUubGFzdChlZGl0b3IsIGF0KTtcbiAgICAgICAgcGF0aCA9IGxhc3RQYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIFssIGZpcnN0UGF0aF0gPSBOb2RlLmZpcnN0KGVkaXRvciwgYXQpO1xuICAgICAgICBwYXRoID0gZmlyc3RQYXRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG5cbiAgICAgIGlmICghVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgXCIuY29uY2F0KGVkZ2UsIFwiIHBvaW50IGluIHRoZSBub2RlIGF0IHBhdGggW1wiKS5jb25jYXQoYXQsIFwiXSBiZWNhdXNlIGl0IGhhcyBubyBcIikuY29uY2F0KGVkZ2UsIFwiIHRleHQgbm9kZS5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXQ6IGVkZ2UgPT09ICdlbmQnID8gbm9kZS50ZXh0Lmxlbmd0aCA6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgcmV0dXJuIGVkZ2UgPT09ICdzdGFydCcgPyBzdGFydCA6IGVuZDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ3JlYXRlIGEgbXV0YWJsZSByZWYgZm9yIGEgYFBvaW50YCBvYmplY3QsIHdoaWNoIHdpbGwgc3RheSBpbiBzeW5jIGFzIG5ld1xyXG4gICAqIG9wZXJhdGlvbnMgYXJlIGFwcGxpZWQgdG8gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcG9pbnRSZWYoZWRpdG9yLCBwb2ludCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgcmVmID0ge1xuICAgICAgY3VycmVudDogcG9pbnQsXG4gICAgICBhZmZpbml0eSxcblxuICAgICAgdW5yZWYoKSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgY3VycmVudFxuICAgICAgICB9ID0gcmVmO1xuICAgICAgICB2YXIgcG9pbnRSZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICAgICAgICBwb2ludFJlZnMuZGVsZXRlKHJlZik7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG5cbiAgICB9O1xuICAgIHZhciByZWZzID0gRWRpdG9yLnBvaW50UmVmcyhlZGl0b3IpO1xuICAgIHJlZnMuYWRkKHJlZik7XG4gICAgcmV0dXJuIHJlZjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHNldCBvZiBjdXJyZW50bHkgdHJhY2tlZCBwb2ludCByZWZzIG9mIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHBvaW50UmVmcyhlZGl0b3IpIHtcbiAgICB2YXIgcmVmcyA9IFBPSU5UX1JFRlMuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXJlZnMpIHtcbiAgICAgIHJlZnMgPSBuZXcgU2V0KCk7XG4gICAgICBQT0lOVF9SRUZTLnNldChlZGl0b3IsIHJlZnMpO1xuICAgIH1cblxuICAgIHJldHVybiByZWZzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJldHVybiBhbGwgdGhlIHBvc2l0aW9ucyBpbiBgYXRgIHJhbmdlIHdoZXJlIGEgYFBvaW50YCBjYW4gYmUgcGxhY2VkLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCwgbW92ZXMgZm9yd2FyZCBieSBpbmRpdmlkdWFsIG9mZnNldHMgYXQgYSB0aW1lLCBidXRcclxuICAgKiB0aGUgYHVuaXRgIG9wdGlvbiBjYW4gYmUgdXNlZCB0byB0byBtb3ZlIGJ5IGNoYXJhY3Rlciwgd29yZCwgbGluZSwgb3IgYmxvY2suXHJcbiAgICpcclxuICAgKiBUaGUgYHJldmVyc2VgIG9wdGlvbiBjYW4gYmUgdXNlZCB0byBjaGFuZ2UgaXRlcmF0aW9uIGRpcmVjdGlvbi5cclxuICAgKlxyXG4gICAqIE5vdGU6IEJ5IGRlZmF1bHQgdm9pZCBub2RlcyBhcmUgdHJlYXRlZCBhcyBhIHNpbmdsZSBwb2ludCBhbmQgaXRlcmF0aW9uXHJcbiAgICogd2lsbCBub3QgaGFwcGVuIGluc2lkZSB0aGVpciBjb250ZW50IHVubGVzcyB5b3UgcGFzcyBpbiB0cnVlIGZvciB0aGVcclxuICAgKiBgdm9pZHNgIG9wdGlvbiwgdGhlbiBpdGVyYXRpb24gd2lsbCBvY2N1ci5cclxuICAgKi9cbiAgKnBvc2l0aW9ucyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIHVuaXQgPSAnb2Zmc2V0JyxcbiAgICAgIHJldmVyc2UgPSBmYWxzZSxcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBBbGdvcml0aG0gbm90ZXM6XHJcbiAgICAgKlxyXG4gICAgICogRWFjaCBzdGVwIGBkaXN0YW5jZWAgaXMgZHluYW1pYyBkZXBlbmRpbmcgb24gdGhlIHVuZGVybHlpbmcgdGV4dFxyXG4gICAgICogYW5kIHRoZSBgdW5pdGAgc3BlY2lmaWVkLiAgRWFjaCBzdGVwLCBlLmcuLCBhIGxpbmUgb3Igd29yZCwgbWF5XHJcbiAgICAgKiBzcGFuIG11bHRpcGxlIHRleHQgbm9kZXMsIHNvIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgdGV4dCBib3RoIG9uXHJcbiAgICAgKiB0d28gbGV2ZWxzIGluIHN0ZXAtc3luYzpcclxuICAgICAqXHJcbiAgICAgKiBgbGVhZlRleHRgIHN0b3JlcyB0aGUgdGV4dCBvbiBhIHRleHQgbGVhZiBsZXZlbCwgYW5kIGlzIGFkdmFuY2VkXHJcbiAgICAgKiB0aHJvdWdoIHVzaW5nIHRoZSBjb3VudGVycyBgbGVhZlRleHRPZmZzZXRgIGFuZCBgbGVhZlRleHRSZW1haW5pbmdgLlxyXG4gICAgICpcclxuICAgICAqIGBibG9ja1RleHRgIHN0b3JlcyB0aGUgdGV4dCBvbiBhIGJsb2NrIGxldmVsLCBhbmQgaXMgc2hvcnRlbmVkXHJcbiAgICAgKiBieSBgZGlzdGFuY2VgIGV2ZXJ5IHRpbWUgaXQgaXMgYWR2YW5jZWQuXHJcbiAgICAgKlxyXG4gICAgICogV2Ugb25seSBtYWludGFpbiBhIHdpbmRvdyBvZiBvbmUgYmxvY2tUZXh0IGFuZCBvbmUgbGVhZlRleHQgYmVjYXVzZVxyXG4gICAgICogYSBibG9jayBub2RlIGFsd2F5cyBhcHBlYXJzIGJlZm9yZSBhbGwgb2YgaXRzIGxlYWYgbm9kZXMuXHJcbiAgICAgKi9cblxuXG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIGZpcnN0ID0gcmV2ZXJzZSA/IGVuZCA6IHN0YXJ0O1xuICAgIHZhciBpc05ld0Jsb2NrID0gZmFsc2U7XG4gICAgdmFyIGJsb2NrVGV4dCA9ICcnO1xuICAgIHZhciBkaXN0YW5jZSA9IDA7IC8vIERpc3RhbmNlIGZvciBsZWFmVGV4dCB0byBjYXRjaCB1cCB0byBibG9ja1RleHQuXG5cbiAgICB2YXIgbGVhZlRleHRSZW1haW5pbmcgPSAwO1xuICAgIHZhciBsZWFmVGV4dE9mZnNldCA9IDA7IC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgbm9kZXMgaW4gcmFuZ2UsIGdyYWJiaW5nIGVudGlyZSB0ZXh0dWFsIGNvbnRlbnRcbiAgICAvLyBvZiBibG9jayBub2RlcyBpbiBibG9ja1RleHQsIGFuZCB0ZXh0IG5vZGVzIGluIGxlYWZUZXh0LlxuICAgIC8vIEV4cGxvaXRzIHRoZSBmYWN0IHRoYXQgbm9kZXMgYXJlIHNlcXVlbmNlZCBpbiBzdWNoIGEgd2F5IHRoYXQgd2UgZmlyc3RcbiAgICAvLyBlbmNvdW50ZXIgdGhlIGJsb2NrIG5vZGUsIHRoZW4gYWxsIG9mIGl0cyB0ZXh0IG5vZGVzLCBzbyB3aGVuIGl0ZXJhdGluZ1xuICAgIC8vIHRocm91Z2ggdGhlIGJsb2NrVGV4dCBhbmQgbGVhZlRleHQgd2UganVzdCBuZWVkIHRvIHJlbWVtYmVyIGEgd2luZG93IG9mXG4gICAgLy8gb25lIGJsb2NrIG5vZGUgYW5kIGxlYWYgbm9kZSwgcmVzcGVjdGl2ZWx5LlxuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0LFxuICAgICAgcmV2ZXJzZSxcbiAgICAgIHZvaWRzXG4gICAgfSkpIHtcbiAgICAgIC8qXHJcbiAgICAgICAqIEVMRU1FTlQgTk9ERSAtIFlpZWxkIHBvc2l0aW9uKHMpIGZvciB2b2lkcywgY29sbGVjdCBibG9ja1RleHQgZm9yIGJsb2Nrc1xyXG4gICAgICAgKi9cbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSkge1xuICAgICAgICAvLyBWb2lkIG5vZGVzIGFyZSBhIHNwZWNpYWwgY2FzZSwgc28gYnkgZGVmYXVsdCB3ZSB3aWxsIGFsd2F5c1xuICAgICAgICAvLyB5aWVsZCB0aGVpciBmaXJzdCBwb2ludC4gSWYgdGhlIGB2b2lkc2Agb3B0aW9uIGlzIHNldCB0byB0cnVlLFxuICAgICAgICAvLyB0aGVuIHdlIHdpbGwgaXRlcmF0ZSBvdmVyIHRoZWlyIGNvbnRlbnQuXG4gICAgICAgIGlmICghdm9pZHMgJiYgZWRpdG9yLmlzVm9pZChub2RlKSkge1xuICAgICAgICAgIHlpZWxkIEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIElubGluZSBlbGVtZW50IG5vZGVzIGFyZSBpZ25vcmVkIGFzIHRoZXkgZG9uJ3QgdGhlbXNlbHZlc1xuICAgICAgICAvLyBjb250cmlidXRlIHRvIGBibG9ja1RleHRgIG9yIGBsZWFmVGV4dGAgLSB0aGVpciBwYXJlbnQgYW5kXG4gICAgICAgIC8vIGNoaWxkcmVuIGRvLlxuXG5cbiAgICAgICAgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkgY29udGludWU7IC8vIEJsb2NrIGVsZW1lbnQgbm9kZSAtIHNldCBgYmxvY2tUZXh0YCB0byBpdHMgdGV4dCBjb250ZW50LlxuXG4gICAgICAgIGlmIChFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgLy8gV2UgYWx3YXlzIGV4aGF1c3QgYmxvY2sgbm9kZXMgYmVmb3JlIGVuY291bnRlcmluZyBhIG5ldyBvbmU6XG4gICAgICAgICAgLy8gICBjb25zb2xlLmFzc2VydChibG9ja1RleHQgPT09ICcnLFxuICAgICAgICAgIC8vICAgICBgYmxvY2tUZXh0PScke2Jsb2NrVGV4dH0nIC0gYCtcbiAgICAgICAgICAvLyAgICAgYG5vdCBleGhhdXN0ZWQgYmVmb3JlIG5ldyBibG9jayBub2RlYCwgcGF0aClcbiAgICAgICAgICAvLyBFbnN1cmUgcmFuZ2UgY29uc2lkZXJlZCBpcyBjYXBwZWQgdG8gYHJhbmdlYCwgaW4gdGhlXG4gICAgICAgICAgLy8gc3RhcnQvZW5kIGVkZ2UgY2FzZXMgd2hlcmUgYmxvY2sgZXh0ZW5kcyBiZXlvbmQgcmFuZ2UuXG4gICAgICAgICAgLy8gRXF1aXZhbGVudCB0byB0aGlzLCBidXQgcHJlc3VtYWJseSBtb3JlIHBlcmZvcm1hbnQ6XG4gICAgICAgICAgLy8gICBibG9ja1JhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgLi4uRWRpdG9yLmVkZ2VzKGVkaXRvciwgcGF0aCkpXG4gICAgICAgICAgLy8gICBibG9ja1JhbmdlID0gUmFuZ2UuaW50ZXJzZWN0aW9uKHJhbmdlLCBibG9ja1JhbmdlKSAvLyBpbnRlcnNlY3RcbiAgICAgICAgICAvLyAgIGJsb2NrVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCBibG9ja1JhbmdlLCB7IHZvaWRzIH0pXG4gICAgICAgICAgdmFyIGUgPSBQYXRoLmlzQW5jZXN0b3IocGF0aCwgZW5kLnBhdGgpID8gZW5kIDogRWRpdG9yLmVuZChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIHZhciBzID0gUGF0aC5pc0FuY2VzdG9yKHBhdGgsIHN0YXJ0LnBhdGgpID8gc3RhcnQgOiBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICBibG9ja1RleHQgPSBFZGl0b3Iuc3RyaW5nKGVkaXRvciwge1xuICAgICAgICAgICAgYW5jaG9yOiBzLFxuICAgICAgICAgICAgZm9jdXM6IGVcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlzTmV3QmxvY2sgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKlxyXG4gICAgICAgKiBURVhUIExFQUYgTk9ERSAtIEl0ZXJhdGUgdGhyb3VnaCB0ZXh0IGNvbnRlbnQsIHlpZWxkaW5nXHJcbiAgICAgICAqIHBvc2l0aW9ucyBldmVyeSBgZGlzdGFuY2VgIG9mZnNldCBhY2NvcmRpbmcgdG8gYHVuaXRgLlxyXG4gICAgICAgKi9cblxuXG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgdmFyIGlzRmlyc3QgPSBQYXRoLmVxdWFscyhwYXRoLCBmaXJzdC5wYXRoKTsgLy8gUHJvb2YgdGhhdCB3ZSBhbHdheXMgZXhoYXVzdCB0ZXh0IG5vZGVzIGJlZm9yZSBlbmNvdW50ZXJpbmcgYSBuZXcgb25lOlxuICAgICAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGxlYWZUZXh0UmVtYWluaW5nIDw9IDAsXG4gICAgICAgIC8vICAgICBgbGVhZlRleHRSZW1haW5pbmc9JHtsZWFmVGV4dFJlbWFpbmluZ30gLSBgK1xuICAgICAgICAvLyAgICAgYG5vdCBleGhhdXN0ZWQgYmVmb3JlIG5ldyBsZWFmIHRleHQgbm9kZWAsIHBhdGgpXG4gICAgICAgIC8vIFJlc2V0IGBsZWFmVGV4dGAgY291bnRlcnMgZm9yIG5ldyB0ZXh0IG5vZGUuXG5cbiAgICAgICAgaWYgKGlzRmlyc3QpIHtcbiAgICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IHJldmVyc2UgPyBmaXJzdC5vZmZzZXQgOiBub2RlLnRleHQubGVuZ3RoIC0gZmlyc3Qub2Zmc2V0O1xuICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gZmlyc3Qub2Zmc2V0OyAvLyBXb3JrcyBmb3IgcmV2ZXJzZSB0b28uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGVhZlRleHRSZW1haW5pbmcgPSBub2RlLnRleHQubGVuZ3RoO1xuICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gcmV2ZXJzZSA/IGxlYWZUZXh0UmVtYWluaW5nIDogMDtcbiAgICAgICAgfSAvLyBZaWVsZCBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2Ygbm9kZSAocG90ZW50aWFsbHkpLlxuXG5cbiAgICAgICAgaWYgKGlzRmlyc3QgfHwgaXNOZXdCbG9jayB8fCB1bml0ID09PSAnb2Zmc2V0Jykge1xuICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IGxlYWZUZXh0T2Zmc2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpc05ld0Jsb2NrID0gZmFsc2U7XG4gICAgICAgIH0gLy8gWWllbGQgcG9zaXRpb25zIGV2ZXJ5IChkeW5hbWljYWxseSBjYWxjdWxhdGVkKSBgZGlzdGFuY2VgIG9mZnNldC5cblxuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgLy8gSWYgYGxlYWZUZXh0YCBoYXMgY2F1Z2h0IHVwIHdpdGggYGJsb2NrVGV4dGAgKGRpc3RhbmNlPTApLFxuICAgICAgICAgIC8vIGFuZCBpZiBibG9ja1RleHQgaXMgZXhoYXVzdGVkLCBicmVhayB0byBnZXQgYW5vdGhlciBibG9jayBub2RlLFxuICAgICAgICAgIC8vIG90aGVyd2lzZSBhZHZhbmNlIGJsb2NrVGV4dCBmb3J3YXJkIGJ5IHRoZSBuZXcgYGRpc3RhbmNlYC5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChibG9ja1RleHQgPT09ICcnKSBicmVhaztcbiAgICAgICAgICAgIGRpc3RhbmNlID0gY2FsY0Rpc3RhbmNlKGJsb2NrVGV4dCwgdW5pdCwgcmV2ZXJzZSk7IC8vIFNwbGl0IHRoZSBzdHJpbmcgYXQgdGhlIHByZXZpb3VzbHkgZm91bmQgZGlzdGFuY2UgYW5kIHVzZSB0aGVcbiAgICAgICAgICAgIC8vIHJlbWFpbmluZyBzdHJpbmcgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cblxuICAgICAgICAgICAgYmxvY2tUZXh0ID0gc3BsaXRCeUNoYXJhY3RlckRpc3RhbmNlKGJsb2NrVGV4dCwgZGlzdGFuY2UsIHJldmVyc2UpWzFdO1xuICAgICAgICAgIH0gLy8gQWR2YW5jZSBgbGVhZlRleHRgIGJ5IHRoZSBjdXJyZW50IGBkaXN0YW5jZWAuXG5cblxuICAgICAgICAgIGxlYWZUZXh0T2Zmc2V0ID0gcmV2ZXJzZSA/IGxlYWZUZXh0T2Zmc2V0IC0gZGlzdGFuY2UgOiBsZWFmVGV4dE9mZnNldCArIGRpc3RhbmNlO1xuICAgICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gbGVhZlRleHRSZW1haW5pbmcgLSBkaXN0YW5jZTsgLy8gSWYgYGxlYWZUZXh0YCBpcyBleGhhdXN0ZWQsIGJyZWFrIHRvIGdldCBhIG5ldyBsZWFmIG5vZGVcbiAgICAgICAgICAvLyBhbmQgc2V0IGRpc3RhbmNlIHRvIHRoZSBvdmVyZmxvdyBhbW91bnQsIHNvIHdlJ2xsIChtYXliZSlcbiAgICAgICAgICAvLyBjYXRjaCB1cCB0byBibG9ja1RleHQgaW4gdGhlIG5leHQgbGVhZiB0ZXh0IG5vZGUuXG5cbiAgICAgICAgICBpZiAobGVhZlRleHRSZW1haW5pbmcgPCAwKSB7XG4gICAgICAgICAgICBkaXN0YW5jZSA9IC1sZWFmVGV4dFJlbWFpbmluZztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gLy8gU3VjY2Vzc2Z1bGx5IHdhbGtlZCBgZGlzdGFuY2VgIG9mZnNldHMgdGhyb3VnaCBgbGVhZlRleHRgXG4gICAgICAgICAgLy8gdG8gY2F0Y2ggdXAgd2l0aCBgYmxvY2tUZXh0YCwgc28gd2UgY2FuIHJlc2V0IGBkaXN0YW5jZWBcbiAgICAgICAgICAvLyBhbmQgeWllbGQgdGhpcyBwb3NpdGlvbiBpbiB0aGlzIG5vZGUuXG5cblxuICAgICAgICAgIGRpc3RhbmNlID0gMDtcbiAgICAgICAgICB5aWVsZCB7XG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgb2Zmc2V0OiBsZWFmVGV4dE9mZnNldFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFByb29mIHRoYXQgdXBvbiBjb21wbGV0aW9uLCB3ZSd2ZSBleGFodXN0ZWQgYm90aCBsZWFmIGFuZCBibG9jayB0ZXh0OlxuICAgIC8vICAgY29uc29sZS5hc3NlcnQobGVhZlRleHRSZW1haW5pbmcgPD0gMCwgXCJsZWFmVGV4dCB3YXNuJ3QgZXhoYXVzdGVkXCIpXG4gICAgLy8gICBjb25zb2xlLmFzc2VydChibG9ja1RleHQgPT09ICcnLCBcImJsb2NrVGV4dCB3YXNuJ3QgZXhoYXVzdGVkXCIpXG4gICAgLy8gSGVscGVyOlxuICAgIC8vIFJldHVybiB0aGUgZGlzdGFuY2UgaW4gb2Zmc2V0cyBmb3IgYSBzdGVwIG9mIHNpemUgYHVuaXRgIG9uIGdpdmVuIHN0cmluZy5cblxuXG4gICAgZnVuY3Rpb24gY2FsY0Rpc3RhbmNlKHRleHQsIHVuaXQsIHJldmVyc2UpIHtcbiAgICAgIGlmICh1bml0ID09PSAnY2hhcmFjdGVyJykge1xuICAgICAgICByZXR1cm4gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgcmV2ZXJzZSk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQgPT09ICd3b3JkJykge1xuICAgICAgICByZXR1cm4gZ2V0V29yZERpc3RhbmNlKHRleHQsIHJldmVyc2UpO1xuICAgICAgfSBlbHNlIGlmICh1bml0ID09PSAnbGluZScgfHwgdW5pdCA9PT0gJ2Jsb2NrJykge1xuICAgICAgICByZXR1cm4gdGV4dC5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG1hdGNoaW5nIG5vZGUgaW4gdGhlIGJyYW5jaCBvZiB0aGUgZG9jdW1lbnQgYmVmb3JlIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHByZXZpb3VzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaCxcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2ludEJlZm9yZUxvY2F0aW9uID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIGF0LCB7XG4gICAgICB2b2lkc1xuICAgIH0pO1xuXG4gICAgaWYgKCFwb2ludEJlZm9yZUxvY2F0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIFssIHRvXSA9IEVkaXRvci5maXJzdChlZGl0b3IsIFtdKTsgLy8gVGhlIHNlYXJjaCBsb2NhdGlvbiBpcyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgZG9jdW1lbnQgdG8gdGhlIHBhdGggb2ZcbiAgICAvLyB0aGUgcG9pbnQgYmVmb3JlIHRoZSBsb2NhdGlvbiBwYXNzZWQgaW5cblxuICAgIHZhciBzcGFuID0gW3BvaW50QmVmb3JlTG9jYXRpb24ucGF0aCwgdG9dO1xuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSAmJiBhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHByZXZpb3VzIG5vZGUgZnJvbSB0aGUgcm9vdCBub2RlIVwiKTtcbiAgICB9XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgYXQpO1xuXG4gICAgICAgIG1hdGNoID0gbiA9PiBwYXJlbnQuY2hpbGRyZW4uaW5jbHVkZXMobik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaCA9ICgpID0+IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIFtwcmV2aW91c10gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgYXQ6IHNwYW4sXG4gICAgICBtYXRjaCxcbiAgICAgIG1vZGUsXG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIHJldHVybiBwcmV2aW91cztcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgYSByYW5nZSBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICByYW5nZShlZGl0b3IsIGF0LCB0bykge1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSAmJiAhdG8pIHtcbiAgICAgIHJldHVybiBhdDtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gICAgdmFyIGVuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCB0byB8fCBhdCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogZW5kXG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBtdXRhYmxlIHJlZiBmb3IgYSBgUmFuZ2VgIG9iamVjdCwgd2hpY2ggd2lsbCBzdGF5IGluIHN5bmMgYXMgbmV3XHJcbiAgICogb3BlcmF0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICByYW5nZVJlZihlZGl0b3IsIHJhbmdlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiByYW5nZSxcbiAgICAgIGFmZmluaXR5LFxuXG4gICAgICB1bnJlZigpIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBjdXJyZW50XG4gICAgICAgIH0gPSByZWY7XG4gICAgICAgIHZhciByYW5nZVJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gICAgICAgIHJhbmdlUmVmcy5kZWxldGUocmVmKTtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cblxuICAgIH07XG4gICAgdmFyIHJlZnMgPSBFZGl0b3IucmFuZ2VSZWZzKGVkaXRvcik7XG4gICAgcmVmcy5hZGQocmVmKTtcbiAgICByZXR1cm4gcmVmO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2V0IG9mIGN1cnJlbnRseSB0cmFja2VkIHJhbmdlIHJlZnMgb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcmFuZ2VSZWZzKGVkaXRvcikge1xuICAgIHZhciByZWZzID0gUkFOR0VfUkVGUy5nZXQoZWRpdG9yKTtcblxuICAgIGlmICghcmVmcykge1xuICAgICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICAgIFJBTkdFX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZnM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmVtb3ZlIGEgY3VzdG9tIHByb3BlcnR5IGZyb20gYWxsIG9mIHRoZSBsZWFmIHRleHQgbm9kZXMgaW4gdGhlIGN1cnJlbnRcclxuICAgKiBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBjb2xsYXBzZWQsIHRoZSByZW1vdmFsIHdpbGwgYmUgc3RvcmVkIG9uXHJcbiAgICogYGVkaXRvci5tYXJrc2AgYW5kIGFwcGxpZWQgdG8gdGhlIHRleHQgaW5zZXJ0ZWQgbmV4dC5cclxuICAgKi9cbiAgcmVtb3ZlTWFyayhlZGl0b3IsIGtleSkge1xuICAgIGVkaXRvci5yZW1vdmVNYXJrKGtleSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogTWFudWFsbHkgc2V0IGlmIHRoZSBlZGl0b3Igc2hvdWxkIGN1cnJlbnRseSBiZSBub3JtYWxpemluZy5cclxuICAgKlxyXG4gICAqIE5vdGU6IFVzaW5nIHRoaXMgaW5jb3JyZWN0bHkgY2FuIGxlYXZlIHRoZSBlZGl0b3IgaW4gYW4gaW52YWxpZCBzdGF0ZS5cclxuICAgKlxyXG4gICAqL1xuICBzZXROb3JtYWxpemluZyhlZGl0b3IsIGlzTm9ybWFsaXppbmcpIHtcbiAgICBOT1JNQUxJWklORy5zZXQoZWRpdG9yLCBpc05vcm1hbGl6aW5nKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IHBvaW50IG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHN0YXJ0KGVkaXRvciwgYXQpIHtcbiAgICByZXR1cm4gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHRleHQgc3RyaW5nIGNvbnRlbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKlxyXG4gICAqIE5vdGU6IGJ5IGRlZmF1bHQgdGhlIHRleHQgb2Ygdm9pZCBub2RlcyBpcyBjb25zaWRlcmVkIHRvIGJlIGFuIGVtcHR5XHJcbiAgICogc3RyaW5nLCByZWdhcmRsZXNzIG9mIGNvbnRlbnQsIHVubGVzcyB5b3UgcGFzcyBpbiB0cnVlIGZvciB0aGUgdm9pZHMgb3B0aW9uXHJcbiAgICovXG4gIHN0cmluZyhlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIHRleHQgPSAnJztcblxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogcmFuZ2UsXG4gICAgICBtYXRjaDogVGV4dC5pc1RleHQsXG4gICAgICB2b2lkc1xuICAgIH0pKSB7XG4gICAgICB2YXIgdCA9IG5vZGUudGV4dDtcblxuICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICB0ID0gdC5zbGljZSgwLCBlbmQub2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICAgIHQgPSB0LnNsaWNlKHN0YXJ0Lm9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIHRleHQgKz0gdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDb252ZXJ0IGEgcmFuZ2UgaW50byBhIG5vbi1oYW5naW5nIG9uZS5cclxuICAgKi9cbiAgdW5oYW5nUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7IC8vIFBFUkY6IGV4aXQgZWFybHkgaWYgd2UgY2FuIGd1YXJhbnRlZSB0aGF0IHRoZSByYW5nZSBpc24ndCBoYW5naW5nLlxuXG4gICAgaWYgKHN0YXJ0Lm9mZnNldCAhPT0gMCB8fCBlbmQub2Zmc2V0ICE9PSAwIHx8IFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSB8fCBQYXRoLmhhc1ByZXZpb3VzKGVuZC5wYXRoKSkge1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cblxuICAgIHZhciBlbmRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgIGF0OiBlbmQsXG4gICAgICBtYXRjaDogbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgdm9pZHNcbiAgICB9KTtcbiAgICB2YXIgYmxvY2tQYXRoID0gZW5kQmxvY2sgPyBlbmRCbG9ja1sxXSA6IFtdO1xuICAgIHZhciBmaXJzdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIHN0YXJ0KTtcbiAgICB2YXIgYmVmb3JlID0ge1xuICAgICAgYW5jaG9yOiBmaXJzdCxcbiAgICAgIGZvY3VzOiBlbmRcbiAgICB9O1xuICAgIHZhciBza2lwID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogYmVmb3JlLFxuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgIHZvaWRzXG4gICAgfSkpIHtcbiAgICAgIGlmIChza2lwKSB7XG4gICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnRleHQgIT09ICcnIHx8IFBhdGguaXNCZWZvcmUocGF0aCwgYmxvY2tQYXRoKSkge1xuICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IG5vZGUudGV4dC5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogZW5kXG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNYXRjaCBhIHZvaWQgbm9kZSBpbiB0aGUgY3VycmVudCBicmFuY2ggb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgdm9pZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIEVkaXRvci5hYm92ZShlZGl0b3IsIF9vYmplY3RTcHJlYWQkOChfb2JqZWN0U3ByZWFkJDgoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pXG4gICAgfSkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENhbGwgYSBmdW5jdGlvbiwgZGVmZXJyaW5nIG5vcm1hbGl6YXRpb24gdW50aWwgYWZ0ZXIgaXQgY29tcGxldGVzLlxyXG4gICAqL1xuICB3aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmbikge1xuICAgIHZhciB2YWx1ZSA9IEVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcik7XG4gICAgRWRpdG9yLnNldE5vcm1hbGl6aW5nKGVkaXRvciwgZmFsc2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIEVkaXRvci5zZXROb3JtYWxpemluZyhlZGl0b3IsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvcik7XG4gIH1cblxufTtcblxudmFyIExvY2F0aW9uID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBMb2NhdGlvbmAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc0xvY2F0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlKSB8fCBQb2ludC5pc1BvaW50KHZhbHVlKSB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlKTtcbiAgfVxuXG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBTcGFuID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBTcGFuYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzU3Bhbih2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIgJiYgdmFsdWUuZXZlcnkoUGF0aC5pc1BhdGgpO1xuICB9XG5cbn07XG5cbnZhciBfZXhjbHVkZWQkMyA9IFtcImNoaWxkcmVuXCJdLFxuICAgIF9leGNsdWRlZDIkMiA9IFtcInRleHRcIl07XG52YXIgSVNfTk9ERV9MSVNUX0NBQ0hFID0gbmV3IFdlYWtNYXAoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG52YXIgTm9kZSA9IHtcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBub2RlIGF0IGEgc3BlY2lmaWMgcGF0aCwgYXNzZXJ0aW5nIHRoYXQgaXQncyBhbiBhbmNlc3RvciBub2RlLlxyXG4gICAqL1xuICBhbmNlc3Rvcihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgYW5jZXN0b3Igbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgdGV4dCBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCB0aGUgYW5jZXN0b3Igbm9kZXMgYWJvdmUgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCB0aGUgb3JkZXIgaXMgdG9wLWRvd24sIGZyb20gaGlnaGVzdCB0byBsb3dlc3QgYW5jZXN0b3IgaW5cclxuICAgKiB0aGUgdHJlZSwgYnV0IHlvdSBjYW4gcGFzcyB0aGUgYHJldmVyc2U6IHRydWVgIG9wdGlvbiB0byBnbyBib3R0b20tdXAuXHJcbiAgICovXG4gICphbmNlc3RvcnMocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIGZvciAodmFyIHAgb2YgUGF0aC5hbmNlc3RvcnMocGF0aCwgb3B0aW9ucykpIHtcbiAgICAgIHZhciBuID0gTm9kZS5hbmNlc3Rvcihyb290LCBwKTtcbiAgICAgIHZhciBlbnRyeSA9IFtuLCBwXTtcbiAgICAgIHlpZWxkIGVudHJ5O1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGNoaWxkIG9mIGEgbm9kZSBhdCBhIHNwZWNpZmljIGluZGV4LlxyXG4gICAqL1xuICBjaGlsZChyb290LCBpbmRleCkge1xuICAgIGlmIChUZXh0LmlzVGV4dChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgY2hpbGQgb2YgYSB0ZXh0IG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHJvb3QuY2hpbGRyZW5baW5kZXhdO1xuXG4gICAgaWYgKGMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBjaGlsZCBhdCBpbmRleCBgXCIuY29uY2F0KGluZGV4LCBcImAgaW4gbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIG92ZXIgdGhlIGNoaWxkcmVuIG9mIGEgbm9kZSBhdCBhIHNwZWNpZmljIHBhdGguXHJcbiAgICovXG4gICpjaGlsZHJlbihyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgYW5jZXN0b3IgPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHBhdGgpO1xuICAgIHZhciB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBhbmNlc3RvcjtcbiAgICB2YXIgaW5kZXggPSByZXZlcnNlID8gY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG5cbiAgICB3aGlsZSAocmV2ZXJzZSA/IGluZGV4ID49IDAgOiBpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gTm9kZS5jaGlsZChhbmNlc3RvciwgaW5kZXgpO1xuICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGguY29uY2F0KGluZGV4KTtcbiAgICAgIHlpZWxkIFtjaGlsZCwgY2hpbGRQYXRoXTtcbiAgICAgIGluZGV4ID0gcmV2ZXJzZSA/IGluZGV4IC0gMSA6IGluZGV4ICsgMTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGFuIGVudHJ5IGZvciB0aGUgY29tbW9uIGFuY2VzZXRvciBub2RlIG9mIHR3byBwYXRocy5cclxuICAgKi9cbiAgY29tbW9uKHJvb3QsIHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgcCA9IFBhdGguY29tbW9uKHBhdGgsIGFub3RoZXIpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLCBhc3NlcnRpbmcgdGhhdCBpdCdzIGEgZGVzY2VuZGFudCBub2RlLlxyXG4gICAqL1xuICBkZXNjZW5kYW50KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuXG4gICAgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgZGVzY2VuZGFudCBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCByZWZlcnMgdG8gdGhlIHJvb3QgZWRpdG9yIG5vZGUgaW5zdGVhZDogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIHRoZSBkZXNjZW5kYW50IG5vZGUgZW50cmllcyBpbnNpZGUgYSByb290IG5vZGUuXHJcbiAgICovXG4gICpkZXNjZW5kYW50cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpIHtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAvLyBOT1RFOiB3ZSBoYXZlIHRvIGNvZXJjZSBoZXJlIGJlY2F1c2UgY2hlY2tpbmcgdGhlIHBhdGgncyBsZW5ndGggZG9lc1xuICAgICAgICAvLyBndWFyYW50ZWUgdGhhdCBgbm9kZWAgaXMgbm90IGEgYEVkaXRvcmAsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdy5cbiAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIHRoZSBlbGVtZW50IG5vZGVzIGluc2lkZSBhIHJvb3Qgbm9kZS4gRWFjaCBpdGVyYXRpb25cclxuICAgKiB3aWxsIHJldHVybiBhbiBgRWxlbWVudEVudHJ5YCB0dXBsZSBjb25zaXN0aW5nIG9mIGBbRWxlbWVudCwgUGF0aF1gLiBJZiB0aGVcclxuICAgKiByb290IG5vZGUgaXMgYW4gZWxlbWVudCBpdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBpdGVyYXRpb24gYXMgd2VsbC5cclxuICAgKi9cbiAgKmVsZW1lbnRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRXh0cmFjdCBwcm9wcyBmcm9tIGEgTm9kZS5cclxuICAgKi9cbiAgZXh0cmFjdFByb3BzKG5vZGUpIHtcbiAgICBpZiAoRWxlbWVudC5pc0FuY2VzdG9yKG5vZGUpKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQkMyk7XG5cbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyJDIpO1xuXG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBmaXJzdCBub2RlIGVudHJ5IGluIGEgcm9vdCBub2RlIGZyb20gYSBwYXRoLlxyXG4gICAqL1xuICBmaXJzdChyb290LCBwYXRoKSB7XG4gICAgdmFyIHAgPSBwYXRoLnNsaWNlKCk7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcblxuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gbi5jaGlsZHJlblswXTtcbiAgICAgICAgcC5wdXNoKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbiwgcF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzbGljZWQgZnJhZ21lbnQgcmVwcmVzZW50ZWQgYnkgYSByYW5nZSBpbnNpZGUgYSByb290IG5vZGUuXHJcbiAgICovXG4gIGZyYWdtZW50KHJvb3QsIHJhbmdlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KHJvb3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGEgZnJhZ21lbnQgc3RhcnRpbmcgZnJvbSBhIHJvb3QgdGV4dCBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld1Jvb3QgPSBwcm9kdWNlKHtcbiAgICAgIGNoaWxkcmVuOiByb290LmNoaWxkcmVuXG4gICAgfSwgciA9PiB7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgICAgdmFyIG5vZGVFbnRyaWVzID0gTm9kZS5ub2RlcyhyLCB7XG4gICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgIHBhc3M6IF9yZWYgPT4ge1xuICAgICAgICAgIHZhciBbLCBwYXRoXSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuICFSYW5nZS5pbmNsdWRlcyhyYW5nZSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBbLCBwYXRoXSBvZiBub2RlRW50cmllcykge1xuICAgICAgICBpZiAoIVJhbmdlLmluY2x1ZGVzKHJhbmdlLCBwYXRoKSkge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChyLCBwYXRoKTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICAgICAgdmFyIGxlYWYgPSBOb2RlLmxlYWYociwgcGF0aCk7XG4gICAgICAgICAgbGVhZi50ZXh0ID0gbGVhZi50ZXh0LnNsaWNlKDAsIGVuZC5vZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICAgICAgdmFyIF9sZWFmID0gTm9kZS5sZWFmKHIsIHBhdGgpO1xuXG4gICAgICAgICAgX2xlYWYudGV4dCA9IF9sZWFmLnRleHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKHIpKSB7XG4gICAgICAgIHIuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3Um9vdC5jaGlsZHJlbjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGRlc2NlbmRhbnQgbm9kZSByZWZlcnJlZCB0byBieSBhIHNwZWNpZmljIHBhdGguIElmIHRoZSBwYXRoIGlzIGFuXHJcbiAgICogZW1wdHkgYXJyYXksIGl0IHJlZmVycyB0byB0aGUgcm9vdCBub2RlIGl0c2VsZi5cclxuICAgKi9cbiAgZ2V0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcGF0aFtpXTtcblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpIHx8ICFub2RlLmNoaWxkcmVuW3BdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGVzY2VuZGFudCBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGluIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgZGVzY2VuZGFudCBub2RlIGV4aXN0cyBhdCBhIHNwZWNpZmljIHBhdGguXHJcbiAgICovXG4gIGhhcyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSByb290O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBhdGhbaV07XG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSB8fCAhbm9kZS5jaGlsZHJlbltwXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYE5vZGVgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIFRleHQuaXNUZXh0KHZhbHVlKSB8fCBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSkgfHwgRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBgTm9kZWAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNOb2RlTGlzdCh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGVkUmVzdWx0ID0gSVNfTk9ERV9MSVNUX0NBQ0hFLmdldCh2YWx1ZSk7XG5cbiAgICBpZiAoY2FjaGVkUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGlzTm9kZUxpc3QgPSB2YWx1ZS5ldmVyeSh2YWwgPT4gTm9kZS5pc05vZGUodmFsKSk7XG4gICAgSVNfTk9ERV9MSVNUX0NBQ0hFLnNldCh2YWx1ZSwgaXNOb2RlTGlzdCk7XG4gICAgcmV0dXJuIGlzTm9kZUxpc3Q7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsYXN0IG5vZGUgZW50cnkgaW4gYSByb290IG5vZGUgZnJvbSBhIHBhdGguXHJcbiAgICovXG4gIGxhc3Qocm9vdCwgcGF0aCkge1xuICAgIHZhciBwID0gcGF0aC5zbGljZSgpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG5cbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG4pIHx8IG4uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSBuLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIG4gPSBuLmNoaWxkcmVuW2ldO1xuICAgICAgICBwLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLCBlbnN1cmluZyBpdCdzIGEgbGVhZiB0ZXh0IG5vZGUuXHJcbiAgICovXG4gIGxlYWYocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG5cbiAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBsZWFmIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byBhIG5vbi1sZWFmIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIHRoZSBpbiBhIGJyYW5jaCBvZiB0aGUgdHJlZSwgZnJvbSBhIHNwZWNpZmljIHBhdGguXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0IHRoZSBvcmRlciBpcyB0b3AtZG93biwgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCBub2RlIGluIHRoZSB0cmVlLFxyXG4gICAqIGJ1dCB5b3UgY2FuIHBhc3MgdGhlIGByZXZlcnNlOiB0cnVlYCBvcHRpb24gdG8gZ28gYm90dG9tLXVwLlxyXG4gICAqL1xuICAqbGV2ZWxzKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBmb3IgKHZhciBwIG9mIFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpKSB7XG4gICAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgeWllbGQgW24sIHBdO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgbWF0Y2hlcyBhIHNldCBvZiBwcm9wcy5cclxuICAgKi9cbiAgbWF0Y2hlcyhub2RlLCBwcm9wcykge1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50LmlzRWxlbWVudFByb3BzKHByb3BzKSAmJiBFbGVtZW50Lm1hdGNoZXMobm9kZSwgcHJvcHMpIHx8IFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0UHJvcHMocHJvcHMpICYmIFRleHQubWF0Y2hlcyhub2RlLCBwcm9wcyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCB0aGUgbm9kZSBlbnRyaWVzIG9mIGEgcm9vdCBub2RlLiBFYWNoIGVudHJ5IGlzXHJcbiAgICogcmV0dXJuZWQgYXMgYSBgW05vZGUsIFBhdGhdYCB0dXBsZSwgd2l0aCB0aGUgcGF0aCByZWZlcnJpbmcgdG8gdGhlIG5vZGUnc1xyXG4gICAqIHBvc2l0aW9uIGluc2lkZSB0aGUgcm9vdCBub2RlLlxyXG4gICAqL1xuICAqbm9kZXMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgcGFzcyxcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBmcm9tID0gW10sXG4gICAgICB0b1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIHZhciBwID0gW107XG4gICAgdmFyIG4gPSByb290O1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh0byAmJiAocmV2ZXJzZSA/IFBhdGguaXNCZWZvcmUocCwgdG8pIDogUGF0aC5pc0FmdGVyKHAsIHRvKSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikpIHtcbiAgICAgICAgeWllbGQgW24sIHBdO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBhbGxvd2VkIHRvIGdvIGRvd253YXJkIGFuZCB3ZSBoYXZlbid0IGRlc2NlbmRlZCB5ZXQsIGRvLlxuXG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikgJiYgIVRleHQuaXNUZXh0KG4pICYmIG4uY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIChwYXNzID09IG51bGwgfHwgcGFzcyhbbiwgcF0pID09PSBmYWxzZSkpIHtcbiAgICAgICAgdmlzaXRlZC5hZGQobik7XG4gICAgICAgIHZhciBuZXh0SW5kZXggPSByZXZlcnNlID8gbi5jaGlsZHJlbi5sZW5ndGggLSAxIDogMDtcblxuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKHAsIGZyb20pKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZnJvbVtwLmxlbmd0aF07XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5jb25jYXQobmV4dEluZGV4KTtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gSWYgd2UncmUgYXQgdGhlIHJvb3QgYW5kIHdlIGNhbid0IGdvIGRvd24sIHdlJ3JlIGRvbmUuXG5cblxuICAgICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBmb3J3YXJkLi4uXG5cblxuICAgICAgaWYgKCFyZXZlcnNlKSB7XG4gICAgICAgIHZhciBuZXdQYXRoID0gUGF0aC5uZXh0KHApO1xuXG4gICAgICAgIGlmIChOb2RlLmhhcyhyb290LCBuZXdQYXRoKSkge1xuICAgICAgICAgIHAgPSBuZXdQYXRoO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBiYWNrd2FyZC4uLlxuXG5cbiAgICAgIGlmIChyZXZlcnNlICYmIHBbcC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgICB2YXIgX25ld1BhdGggPSBQYXRoLnByZXZpb3VzKHApO1xuXG4gICAgICAgIHAgPSBfbmV3UGF0aDtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIHdlJ3JlIGdvaW5nIHVwd2FyZC4uLlxuXG5cbiAgICAgIHAgPSBQYXRoLnBhcmVudChwKTtcbiAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgIHZpc2l0ZWQuYWRkKG4pO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhcmVudCBvZiBhIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqL1xuICBwYXJlbnQocm9vdCwgcGF0aCkge1xuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gICAgdmFyIHAgPSBOb2RlLmdldChyb290LCBwYXJlbnRQYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IG9mIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgcm9vdC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY29uY2F0ZW5hdGVkIHRleHQgc3RyaW5nIG9mIGEgbm9kZSdzIGNvbnRlbnQuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBpbmNsdWRlIHNwYWNlcyBvciBsaW5lIGJyZWFrcyBiZXR3ZWVuIGJsb2NrIG5vZGVzLlxyXG4gICAqIEl0IGlzIG5vdCBhIHVzZXItZmFjaW5nIHN0cmluZywgYnV0IGEgc3RyaW5nIGZvciBwZXJmb3JtaW5nIG9mZnNldC1yZWxhdGVkXHJcbiAgICogY29tcHV0YXRpb25zIGZvciBhIG5vZGUuXHJcbiAgICovXG4gIHN0cmluZyhub2RlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS50ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoTm9kZS5zdHJpbmcpLmpvaW4oJycpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIGxlYWYgdGV4dCBub2RlcyBpbiBhIHJvb3Qgbm9kZS5cclxuICAgKi9cbiAgKnRleHRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ3KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ3KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDcoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBPcGVyYXRpb24gPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIG9mIGEgdmFsdWUgaXMgYSBgTm9kZU9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc05vZGVPcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfbm9kZScpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIG9mIGEgdmFsdWUgaXMgYW4gYE9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc09wZXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnBvc2l0aW9uID09PSAnbnVtYmVyJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgUGF0aC5pc1BhdGgodmFsdWUubmV3UGF0aCk7XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm9wZXJ0aWVzID09PSBudWxsICYmIFJhbmdlLmlzUmFuZ2UodmFsdWUubmV3UHJvcGVydGllcykgfHwgdmFsdWUubmV3UHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLnByb3BlcnRpZXMpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiB0eXBlb2YgdmFsdWUucG9zaXRpb24gPT09ICdudW1iZXInICYmIGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2YgYE9wZXJhdGlvbmAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNPcGVyYXRpb25MaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgb2YgYSB2YWx1ZSBpcyBhIGBTZWxlY3Rpb25PcGVyYXRpb25gIG9iamVjdC5cclxuICAgKi9cbiAgaXNTZWxlY3Rpb25PcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfc2VsZWN0aW9uJyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgb2YgYSB2YWx1ZSBpcyBhIGBUZXh0T3BlcmF0aW9uYCBvYmplY3QuXHJcbiAgICovXG4gIGlzVGV4dE9wZXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsdWUpICYmIHZhbHVlLnR5cGUuZW5kc1dpdGgoJ190ZXh0Jyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW52ZXJ0IGFuIG9wZXJhdGlvbiwgcmV0dXJuaW5nIGEgbmV3IG9wZXJhdGlvbiB0aGF0IHdpbGwgZXhhY3RseSB1bmRvIHRoZVxyXG4gICAqIG9yaWdpbmFsIHdoZW4gYXBwbGllZC5cclxuICAgKi9cbiAgaW52ZXJzZShvcCkge1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgucHJldmlvdXMob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIG5ld1BhdGgsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfSA9IG9wOyAvLyBQRVJGOiBpbiB0aGlzIGNhc2UgdGhlIG1vdmUgb3BlcmF0aW9uIGlzIGEgbm8tb3AgYW55d2F5cy5cblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXdQYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgaGFwcGVucyBjb21wbGV0ZWx5IHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgdGhlIHBhdGggYW5kXG4gICAgICAgICAgLy8gbmV3UGF0aCBhcmUgc3RhYmxlIHdpdGggcmVzcGVjdCB0byBlYWNoIG90aGVyLlxuXG5cbiAgICAgICAgICBpZiAoUGF0aC5pc1NpYmxpbmcocGF0aCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgICAgICAgIG5ld1BhdGg6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgZG9lcyBub3QgaGFwcGVuIHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgaXQgaXMgcG9zc2libGVcbiAgICAgICAgICAvLyBmb3IgdGhlIG1vdmUgdG8gaW1wYWN0IHRoZSB0cnVlIHBhdGggdG8gdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBub2RlXG4gICAgICAgICAgLy8gd2FzIHJlbW92ZWQgZnJvbSBhbmQgd2hlcmUgaXQgd2FzIGluc2VydGVkLiBXZSBoYXZlIHRvIGFkanVzdCBmb3IgdGhpc1xuICAgICAgICAgIC8vIGFuZCBmaW5kIHRoZSBvcmlnaW5hbCBwYXRoLiBXZSBjYW4gYWNjb21wbGlzaCB0aGlzIChvbmx5IGluIG5vbi1zaWJsaW5nKVxuICAgICAgICAgIC8vIG1vdmVzIGJ5IGxvb2tpbmcgYXQgdGhlIGltcGFjdCBvZiB0aGUgbW92ZSBvcGVyYXRpb24gb24gdGhlIG5vZGVcbiAgICAgICAgICAvLyBhZnRlciB0aGUgb3JpZ2luYWwgbW92ZSBwYXRoLlxuXG5cbiAgICAgICAgICB2YXIgaW52ZXJzZVBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gICAgICAgICAgdmFyIGludmVyc2VOZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0oUGF0aC5uZXh0KHBhdGgpLCBvcCk7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHBhdGg6IGludmVyc2VQYXRoLFxuICAgICAgICAgICAgbmV3UGF0aDogaW52ZXJzZU5ld1BhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBuZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IF9wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogX25ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICBpZiAoX3Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogX25ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLm5leHQob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG52YXIgUGF0aCA9IHtcbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBhbmNlc3RvciBwYXRocyBmb3IgYSBnaXZlbiBwYXRoLlxyXG4gICAqXHJcbiAgICogVGhlIHBhdGhzIGFyZSBzb3J0ZWQgZnJvbSBzaGFsbG93ZXN0IHRvIGRlZXBlc3QgYW5jZXN0b3IuIEhvd2V2ZXIsIGlmIHRoZVxyXG4gICAqIGByZXZlcnNlOiB0cnVlYCBvcHRpb24gaXMgcGFzc2VkLCB0aGV5IGFyZSByZXZlcnNlZC5cclxuICAgKi9cbiAgYW5jZXN0b3JzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBwYXRocyA9IFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMCwgLTEpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRocztcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGNvbW1vbiBhbmNlc3RvciBwYXRoIG9mIHR3byBwYXRocy5cclxuICAgKi9cbiAgY29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgY29tbW9uID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoICYmIGkgPCBhbm90aGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcblxuICAgICAgaWYgKGF2ICE9PSBidikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29tbW9uLnB1c2goYXYpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tb247XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ29tcGFyZSBhIHBhdGggdG8gYW5vdGhlciwgcmV0dXJuaW5nIGFuIGludGVnZXIgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwYXRoXHJcbiAgICogd2FzIGJlZm9yZSwgYXQsIG9yIGFmdGVyIHRoZSBvdGhlci5cclxuICAgKlxyXG4gICAqIE5vdGU6IFR3byBwYXRocyBvZiB1bmVxdWFsIGxlbmd0aCBjYW4gc3RpbGwgcmVjZWl2ZSBhIGAwYCByZXN1bHQgaWYgb25lIGlzXHJcbiAgICogZGlyZWN0bHkgYWJvdmUgb3IgYmVsb3cgdGhlIG90aGVyLiBJZiB5b3Ugd2FudCBleGFjdCBtYXRjaGluZywgdXNlXHJcbiAgICogW1tQYXRoLmVxdWFsc11dIGluc3RlYWQuXHJcbiAgICovXG4gIGNvbXBhcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihwYXRoLmxlbmd0aCwgYW5vdGhlci5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0gPCBhbm90aGVyW2ldKSByZXR1cm4gLTE7XG4gICAgICBpZiAocGF0aFtpXSA+IGFub3RoZXJbaV0pIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBlbmRzIGFmdGVyIG9uZSBvZiB0aGUgaW5kZXhlcyBpbiBhbm90aGVyLlxyXG4gICAqL1xuICBlbmRzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPiBidjtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggZW5kcyBhdCBvbmUgb2YgdGhlIGluZGV4ZXMgaW4gYW5vdGhlci5cclxuICAgKi9cbiAgZW5kc0F0KHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggZW5kcyBiZWZvcmUgb25lIG9mIHRoZSBpbmRleGVzIGluIGFub3RoZXIuXHJcbiAgICovXG4gIGVuZHNCZWZvcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPCBidjtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgZXhhY3RseSBlcXVhbCB0byBhbm90aGVyLlxyXG4gICAqL1xuICBlcXVhbHMocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggJiYgcGF0aC5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYW5vdGhlcltpXSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIHBhdGggb2YgcHJldmlvdXMgc2libGluZyBub2RlIGV4aXN0c1xyXG4gICAqL1xuICBoYXNQcmV2aW91cyhwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA+IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGFmdGVyIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGFuIGFuY2VzdG9yIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQW5jZXN0b3IocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYmVmb3JlIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQmVmb3JlKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAtMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYSBjaGlsZCBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc0NoaWxkKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPT09IGFub3RoZXIubGVuZ3RoICsgMSAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGVxdWFsIHRvIG9yIGFuIGFuY2VzdG9yIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQ29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPD0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIGRlc2NlbmRhbnQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNEZXNjZW5kYW50KHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPiBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIHRoZSBwYXJlbnQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNQYXJlbnQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCArIDEgPT09IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpcyBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBQYXRoYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzUGF0aCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAodmFsdWUubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZVswXSA9PT0gJ251bWJlcicpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIHNpYmxpbmcgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNTaWJsaW5nKHBhdGgsIGFub3RoZXIpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGFsID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHZhciBibCA9IGFub3RoZXJbYW5vdGhlci5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gYWwgIT09IGJsICYmIFBhdGguZXF1YWxzKGFzLCBicyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBwYXRocyBhdCBldmVyeSBsZXZlbCBkb3duIHRvIGEgcGF0aC4gTm90ZTogdGhpcyBpcyB0aGUgc2FtZVxyXG4gICAqIGFzIGBQYXRoLmFuY2VzdG9yc2AsIGJ1dCBpbmNsdWRpbmcgdGhlIHBhdGggaXRzZWxmLlxyXG4gICAqXHJcbiAgICogVGhlIHBhdGhzIGFyZSBzb3J0ZWQgZnJvbSBzaGFsbG93ZXN0IHRvIGRlZXBlc3QuIEhvd2V2ZXIsIGlmIHRoZSBgcmV2ZXJzZTpcclxuICAgKiB0cnVlYCBvcHRpb24gaXMgcGFzc2VkLCB0aGV5IGFyZSByZXZlcnNlZC5cclxuICAgKi9cbiAgbGV2ZWxzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBsaXN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0LnB1c2gocGF0aC5zbGljZSgwLCBpKSk7XG4gICAgfVxuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGxpc3QucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdpdmVuIGEgcGF0aCwgZ2V0IHRoZSBwYXRoIHRvIHRoZSBuZXh0IHNpYmxpbmcgbm9kZS5cclxuICAgKi9cbiAgbmV4dChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBuZXh0IHBhdGggb2YgYSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0sIGJlY2F1c2UgaXQgaGFzIG5vIG5leHQgaW5kZXguXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSkuY29uY2F0KGxhc3QgKyAxKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBvcGVyYXRpb24gY2FuIGFmZmVjdCBwYXRocyBvciBub3QuIFVzZWQgYXMgYW5cclxuICAgKiBvcHRpbWl6YXRpb24gd2hlbiB1cGRhdGluZyBkaXJ0eSBwYXRocyBkdXJpbmcgbm9ybWFsaXphdGlvblxyXG4gICAqXHJcbiAgICogTk9URTogVGhpcyAqbXVzdCogYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIGltcGxlbWVudGF0aW9uIG9mICd0cmFuc2Zvcm0nXHJcbiAgICogYmVsb3dcclxuICAgKi9cbiAgb3BlcmF0aW9uQ2FuVHJhbnNmb3JtUGF0aChvcGVyYXRpb24pIHtcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBwYXRoLCByZXR1cm4gYSBuZXcgcGF0aCByZWZlcnJpbmcgdG8gdGhlIHBhcmVudCBub2RlIGFib3ZlIGl0LlxyXG4gICAqL1xuICBwYXJlbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IHBhdGggb2YgdGhlIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXS5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHaXZlbiBhIHBhdGgsIGdldCB0aGUgcGF0aCB0byB0aGUgcHJldmlvdXMgc2libGluZyBub2RlLlxyXG4gICAqL1xuICBwcmV2aW91cyhwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwcmV2aW91cyBwYXRoIG9mIGEgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLCBiZWNhdXNlIGl0IGhhcyBubyBwcmV2aW91cyBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGxhc3QgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgcGF0aCBvZiBhIGZpcnN0IGNoaWxkIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCB3b3VsZCByZXN1bHQgaW4gYSBuZWdhdGl2ZSBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKS5jb25jYXQobGFzdCAtIDEpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCBhIHBhdGggcmVsYXRpdmUgdG8gYW4gYW5jZXN0b3IuXHJcbiAgICovXG4gIHJlbGF0aXZlKHBhdGgsIGFuY2VzdG9yKSB7XG4gICAgaWYgKCFQYXRoLmlzQW5jZXN0b3IoYW5jZXN0b3IsIHBhdGgpICYmICFQYXRoLmVxdWFscyhwYXRoLCBhbmNlc3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHJlbGF0aXZlIHBhdGggb2YgW1wiLmNvbmNhdChwYXRoLCBcIl0gaW5zaWRlIGFuY2VzdG9yIFtcIikuY29uY2F0KGFuY2VzdG9yLCBcIl0sIGJlY2F1c2UgaXQgaXMgbm90IGFib3ZlIG9yIGVxdWFsIHRvIHRoZSBwYXRoLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoYW5jZXN0b3IubGVuZ3RoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gYSBwYXRoIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHBhdGgsIG9wZXJhdGlvbikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBpZiAoIXBhdGgpIHJldHVybiBudWxsOyAvLyBQRVJGOiB1c2UgZGVzdHJ1Y3RpbmcgaW5zdGVhZCBvZiBpbW1lclxuXG4gICAgdmFyIHAgPSBbLi4ucGF0aF07XG4gICAgdmFyIHtcbiAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgfSA9IG9wdGlvbnM7IC8vIFBFUkY6IEV4aXQgZWFybHkgaWYgdGhlIG9wZXJhdGlvbiBpcyBndWFyYW50ZWVkIG5vdCB0byBoYXZlIGFuIGVmZmVjdC5cblxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuXG4gICAgc3dpdGNoIChvcGVyYXRpb24udHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IG9wXG4gICAgICAgICAgfSA9IG9wZXJhdGlvbjtcblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcCwgcCkgfHwgUGF0aC5lbmRzQmVmb3JlKG9wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3Iob3AsIHApKSB7XG4gICAgICAgICAgICBwW29wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHBhdGg6IF9vcFxuICAgICAgICAgIH0gPSBvcGVyYXRpb247XG5cbiAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3IoX29wLCBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICBwYXRoOiBfb3AyLFxuICAgICAgICAgICAgcG9zaXRpb25cbiAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDIsIHApIHx8IFBhdGguZW5kc0JlZm9yZShfb3AyLCBwKSkge1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMiwgcCkpIHtcbiAgICAgICAgICAgIHBbX29wMi5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgcFtfb3AyLmxlbmd0aF0gKz0gcG9zaXRpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX29wMyxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBfcG9zaXRpb25cbiAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDMsIHApKSB7XG4gICAgICAgICAgICBpZiAoYWZmaW5pdHkgPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgICBwW3AubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdiYWNrd2FyZCcpIDsgZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDMsIHApKSB7XG4gICAgICAgICAgICBwW19vcDMubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3AzLCBwKSAmJiBwYXRoW19vcDMubGVuZ3RoXSA+PSBfcG9zaXRpb24pIHtcbiAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgcFtfb3AzLmxlbmd0aF0gLT0gX3Bvc2l0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgcGF0aDogX29wNCxcbiAgICAgICAgICAgIG5ld1BhdGg6IG9ucFxuICAgICAgICAgIH0gPSBvcGVyYXRpb247IC8vIElmIHRoZSBvbGQgYW5kIG5ldyBwYXRoIGFyZSB0aGUgc2FtZSwgaXQncyBhIG5vLW9wLlxuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDQsIG9ucCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wNCwgcCkgfHwgUGF0aC5lcXVhbHMoX29wNCwgcCkpIHtcbiAgICAgICAgICAgIHZhciBjb3B5ID0gb25wLnNsaWNlKCk7XG5cbiAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgb25wKSAmJiBfb3A0Lmxlbmd0aCA8IG9ucC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29weVtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBjb3B5LmNvbmNhdChwLnNsaWNlKF9vcDQubGVuZ3RoKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzU2libGluZyhfb3A0LCBvbnApICYmIChQYXRoLmlzQW5jZXN0b3Iob25wLCBwKSB8fCBQYXRoLmVxdWFscyhvbnAsIHApKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBbX29wNC5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKG9ucCwgcCkgfHwgUGF0aC5lcXVhbHMob25wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3Iob25wLCBwKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcFtvbnAubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9ucCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtvbnAubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcFtfb3A0Lmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfVxuXG59O1xuXG52YXIgUGF0aFJlZiA9IHtcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIHRoZSBwYXRoIHJlZidzIGN1cnJlbnQgdmFsdWUgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgYWZmaW5pdHlcbiAgICB9ID0gcmVmO1xuXG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gUGF0aC50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwYXRoO1xuXG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG5cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkNihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDYoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ2KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgUG9pbnQgPSB7XG4gIC8qKlxyXG4gICAqIENvbXBhcmUgYSBwb2ludCB0byBhbm90aGVyLCByZXR1cm5pbmcgYW4gaW50ZWdlciBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlXHJcbiAgICogcG9pbnQgd2FzIGJlZm9yZSwgYXQsIG9yIGFmdGVyIHRoZSBvdGhlci5cclxuICAgKi9cbiAgY29tcGFyZShwb2ludCwgYW5vdGhlcikge1xuICAgIHZhciByZXN1bHQgPSBQYXRoLmNvbXBhcmUocG9pbnQucGF0aCwgYW5vdGhlci5wYXRoKTtcblxuICAgIGlmIChyZXN1bHQgPT09IDApIHtcbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPCBhbm90aGVyLm9mZnNldCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA+IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBhZnRlciBhbm90aGVyLlxyXG4gICAqL1xuICBpc0FmdGVyKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAxO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgYmVmb3JlIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQmVmb3JlKHBvaW50LCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmNvbXBhcmUocG9pbnQsIGFub3RoZXIpID09PSAtMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIGV4YWN0bHkgZXF1YWwgdG8gYW5vdGhlci5cclxuICAgKi9cbiAgZXF1YWxzKHBvaW50LCBhbm90aGVyKSB7XG4gICAgLy8gUEVSRjogZW5zdXJlIHRoZSBvZmZzZXRzIGFyZSBlcXVhbCBmaXJzdCBzaW5jZSB0aGV5IGFyZSBjaGVhcGVyIHRvIGNoZWNrLlxuICAgIHJldHVybiBwb2ludC5vZmZzZXQgPT09IGFub3RoZXIub2Zmc2V0ICYmIFBhdGguZXF1YWxzKHBvaW50LnBhdGgsIGFub3RoZXIucGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgUG9pbnRgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNQb2ludCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gYSBwb2ludCBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybShwb2ludCwgb3ApIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIHByb2R1Y2UocG9pbnQsIHAgPT4ge1xuICAgICAgaWYgKHAgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciB7XG4gICAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IHA7XG5cbiAgICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgJiYgKG9wLm9mZnNldCA8IG9mZnNldCB8fCBvcC5vZmZzZXQgPT09IG9mZnNldCAmJiBhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSkge1xuICAgICAgICAgICAgICBwLm9mZnNldCArPSBvcC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgICBwLm9mZnNldCArPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcC5wYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgJiYgb3Aub2Zmc2V0IDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICBwLm9mZnNldCAtPSBNYXRoLm1pbihvZmZzZXQgLSBvcC5vZmZzZXQsIG9wLnRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgUGF0aC5pc0FuY2VzdG9yKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIGlmIChvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcC5wb3NpdGlvbiA8IG9mZnNldCB8fCBvcC5wb3NpdGlvbiA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09PSAnZm9yd2FyZCcpIHtcbiAgICAgICAgICAgICAgICBwLm9mZnNldCAtPSBvcC5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgX29iamVjdFNwcmVhZCQ2KF9vYmplY3RTcHJlYWQkNih7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgICAgICAgICBhZmZpbml0eTogJ2ZvcndhcmQnXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59O1xuXG52YXIgUG9pbnRSZWYgPSB7XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgcG9pbnQgcmVmJ3MgY3VycmVudCB2YWx1ZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBhZmZpbml0eVxuICAgIH0gPSByZWY7XG5cbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvaW50ID0gUG9pbnQudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcG9pbnQ7XG5cbiAgICBpZiAocG9pbnQgPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBfZXhjbHVkZWQkMiA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzJDUob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDUodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ1KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkNShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFJhbmdlID0ge1xuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIG9mIGEgcmFuZ2UsIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IGFwcGVhclxyXG4gICAqIGluIHRoZSBkb2N1bWVudC5cclxuICAgKi9cbiAgZWRnZXMocmFuZ2UpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICByZXR1cm4gUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSkgPT09IHJldmVyc2UgPyBbYW5jaG9yLCBmb2N1c10gOiBbZm9jdXMsIGFuY2hvcl07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBlbmQgcG9pbnQgb2YgYSByYW5nZS5cclxuICAgKi9cbiAgZW5kKHJhbmdlKSB7XG4gICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgcmV0dXJuIGVuZDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGV4YWN0bHkgZXF1YWwgdG8gYW5vdGhlci5cclxuICAgKi9cbiAgZXF1YWxzKHJhbmdlLCBhbm90aGVyKSB7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhyYW5nZS5hbmNob3IsIGFub3RoZXIuYW5jaG9yKSAmJiBQb2ludC5lcXVhbHMocmFuZ2UuZm9jdXMsIGFub3RoZXIuZm9jdXMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaW5jbHVkZXMgYSBwYXRoLCBhIHBvaW50IG9yIHBhcnQgb2YgYW5vdGhlciByYW5nZS5cclxuICAgKi9cbiAgaW5jbHVkZXMocmFuZ2UsIHRhcmdldCkge1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKHRhcmdldCkpIHtcbiAgICAgIGlmIChSYW5nZS5pbmNsdWRlcyhyYW5nZSwgdGFyZ2V0LmFuY2hvcikgfHwgUmFuZ2UuaW5jbHVkZXMocmFuZ2UsIHRhcmdldC5mb2N1cykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBbcnMsIHJlXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICAgIHZhciBbdHMsIHRlXSA9IFJhbmdlLmVkZ2VzKHRhcmdldCk7XG4gICAgICByZXR1cm4gUG9pbnQuaXNCZWZvcmUocnMsIHRzKSAmJiBQb2ludC5pc0FmdGVyKHJlLCB0ZSk7XG4gICAgfVxuXG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgaXNBZnRlclN0YXJ0ID0gZmFsc2U7XG4gICAgdmFyIGlzQmVmb3JlRW5kID0gZmFsc2U7XG5cbiAgICBpZiAoUG9pbnQuaXNQb2ludCh0YXJnZXQpKSB7XG4gICAgICBpc0FmdGVyU3RhcnQgPSBQb2ludC5jb21wYXJlKHRhcmdldCwgc3RhcnQpID49IDA7XG4gICAgICBpc0JlZm9yZUVuZCA9IFBvaW50LmNvbXBhcmUodGFyZ2V0LCBlbmQpIDw9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzQWZ0ZXJTdGFydCA9IFBhdGguY29tcGFyZSh0YXJnZXQsIHN0YXJ0LnBhdGgpID49IDA7XG4gICAgICBpc0JlZm9yZUVuZCA9IFBhdGguY29tcGFyZSh0YXJnZXQsIGVuZC5wYXRoKSA8PSAwO1xuICAgIH1cblxuICAgIHJldHVybiBpc0FmdGVyU3RhcnQgJiYgaXNCZWZvcmVFbmQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBpbnRlcnNlY3Rpb24gb2YgYSByYW5nZSB3aXRoIGFub3RoZXIuXHJcbiAgICovXG4gIGludGVyc2VjdGlvbihyYW5nZSwgYW5vdGhlcikge1xuICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJhbmdlLCBfZXhjbHVkZWQkMik7XG5cbiAgICB2YXIgW3MxLCBlMV0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIFtzMiwgZTJdID0gUmFuZ2UuZWRnZXMoYW5vdGhlcik7XG4gICAgdmFyIHN0YXJ0ID0gUG9pbnQuaXNCZWZvcmUoczEsIHMyKSA/IHMyIDogczE7XG4gICAgdmFyIGVuZCA9IFBvaW50LmlzQmVmb3JlKGUxLCBlMikgPyBlMSA6IGUyO1xuXG4gICAgaWYgKFBvaW50LmlzQmVmb3JlKGVuZCwgc3RhcnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNSh7XG4gICAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICAgIGZvY3VzOiBlbmRcbiAgICAgIH0sIHJlc3QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGJhY2t3YXJkLCBtZWFuaW5nIHRoYXQgaXRzIGFuY2hvciBwb2ludCBhcHBlYXJzIGluIHRoZVxyXG4gICAqIGRvY3VtZW50IF9hZnRlcl8gaXRzIGZvY3VzIHBvaW50LlxyXG4gICAqL1xuICBpc0JhY2t3YXJkKHJhbmdlKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBQb2ludC5pc0FmdGVyKGFuY2hvciwgZm9jdXMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaXMgY29sbGFwc2VkLCBtZWFuaW5nIHRoYXQgYm90aCBpdHMgYW5jaG9yIGFuZCBmb2N1c1xyXG4gICAqIHBvaW50cyByZWZlciB0byB0aGUgZXhhY3Qgc2FtZSBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICovXG4gIGlzQ29sbGFwc2VkKHJhbmdlKSB7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMoYW5jaG9yLCBmb2N1cyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpcyBleHBhbmRlZC5cclxuICAgKlxyXG4gICAqIFRoaXMgaXMgdGhlIG9wcG9zaXRlIG9mIFtbUmFuZ2UuaXNDb2xsYXBzZWRdXSBhbmQgaXMgcHJvdmlkZWQgZm9yIGxlZ2liaWxpdHkuXHJcbiAgICovXG4gIGlzRXhwYW5kZWQocmFuZ2UpIHtcbiAgICByZXR1cm4gIVJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGZvcndhcmQuXHJcbiAgICpcclxuICAgKiBUaGlzIGlzIHRoZSBvcHBvc2l0ZSBvZiBbW1JhbmdlLmlzQmFja3dhcmRdXSBhbmQgaXMgcHJvdmlkZWQgZm9yIGxlZ2liaWxpdHkuXHJcbiAgICovXG4gIGlzRm9yd2FyZChyYW5nZSkge1xuICAgIHJldHVybiAhUmFuZ2UuaXNCYWNrd2FyZChyYW5nZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBbW1JhbmdlXV0gaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1JhbmdlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIFBvaW50LmlzUG9pbnQodmFsdWUuYW5jaG9yKSAmJiBQb2ludC5pc1BvaW50KHZhbHVlLmZvY3VzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBwb2ludCBlbnRyaWVzIGluIGEgcmFuZ2UuXHJcbiAgICovXG4gICpwb2ludHMocmFuZ2UpIHtcbiAgICB5aWVsZCBbcmFuZ2UuYW5jaG9yLCAnYW5jaG9yJ107XG4gICAgeWllbGQgW3JhbmdlLmZvY3VzLCAnZm9jdXMnXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IHBvaW50IG9mIGEgcmFuZ2UuXHJcbiAgICovXG4gIHN0YXJ0KHJhbmdlKSB7XG4gICAgdmFyIFtzdGFydF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgcmV0dXJuIHN0YXJ0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSBhIHJhbmdlIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHJhbmdlLCBvcCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gcHJvZHVjZShyYW5nZSwgciA9PiB7XG4gICAgICBpZiAociA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgYWZmaW5pdHkgPSAnaW53YXJkJ1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIgYWZmaW5pdHlBbmNob3I7XG4gICAgICB2YXIgYWZmaW5pdHlGb2N1cztcblxuICAgICAgaWYgKGFmZmluaXR5ID09PSAnaW53YXJkJykge1xuICAgICAgICAvLyBJZiB0aGUgcmFuZ2UgaXMgY29sbGFwc2VkLCBtYWtlIHN1cmUgdG8gdXNlIHRoZSBzYW1lIGFmZmluaXR5IHRvXG4gICAgICAgIC8vIGF2b2lkIHRoZSB0d28gcG9pbnRzIHBhc3NpbmcgZWFjaCBvdGhlciBhbmQgZXhwYW5kaW5nIGluIHRoZSBvcHBvc2l0ZVxuICAgICAgICAvLyBkaXJlY3Rpb25cbiAgICAgICAgdmFyIGlzQ29sbGFwc2VkID0gUmFuZ2UuaXNDb2xsYXBzZWQocik7XG5cbiAgICAgICAgaWYgKFJhbmdlLmlzRm9yd2FyZChyKSkge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2ZvcndhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFmZmluaXR5QW5jaG9yIDogJ2JhY2t3YXJkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdiYWNrd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9IGlzQ29sbGFwc2VkID8gYWZmaW5pdHlBbmNob3IgOiAnZm9yd2FyZCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdvdXR3YXJkJykge1xuICAgICAgICBpZiAoUmFuZ2UuaXNGb3J3YXJkKHIpKSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnYmFja3dhcmQnO1xuICAgICAgICAgIGFmZmluaXR5Rm9jdXMgPSAnZm9yd2FyZCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnZm9yd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9ICdiYWNrd2FyZCc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFmZmluaXR5QW5jaG9yID0gYWZmaW5pdHk7XG4gICAgICAgIGFmZmluaXR5Rm9jdXMgPSBhZmZpbml0eTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuY2hvciA9IFBvaW50LnRyYW5zZm9ybShyLmFuY2hvciwgb3AsIHtcbiAgICAgICAgYWZmaW5pdHk6IGFmZmluaXR5QW5jaG9yXG4gICAgICB9KTtcbiAgICAgIHZhciBmb2N1cyA9IFBvaW50LnRyYW5zZm9ybShyLmZvY3VzLCBvcCwge1xuICAgICAgICBhZmZpbml0eTogYWZmaW5pdHlGb2N1c1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghYW5jaG9yIHx8ICFmb2N1cykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgci5hbmNob3IgPSBhbmNob3I7XG4gICAgICByLmZvY3VzID0gZm9jdXM7XG4gICAgfSk7XG4gIH1cblxufTtcblxudmFyIFJhbmdlUmVmID0ge1xuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gdGhlIHJhbmdlIHJlZidzIGN1cnJlbnQgdmFsdWUgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm0ocmVmLCBvcCkge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgYWZmaW5pdHlcbiAgICB9ID0gcmVmO1xuXG4gICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gUmFuZ2UudHJhbnNmb3JtKGN1cnJlbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eVxuICAgIH0pO1xuICAgIHJlZi5jdXJyZW50ID0gcGF0aDtcblxuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgIHJlZi51bnJlZigpO1xuICAgIH1cbiAgfVxuXG59O1xuXG52YXIgX3NjcnViYmVyID0gdW5kZWZpbmVkO1xuLyoqXHJcbiAqIFRoaXMgaW50ZXJmYWNlIGltcGxlbWVudHMgYSBzdHJpbmdpZnkoKSBmdW5jdGlvbiwgd2hpY2ggaXMgdXNlZCBieSBTbGF0ZVxyXG4gKiBpbnRlcm5hbGx5IHdoZW4gZ2VuZXJhdGluZyBleGNlcHRpb25zIGNvbnRhaW5pbmcgZW5kIHVzZXIgZGF0YS4gRGV2ZWxvcGVyc1xyXG4gKiB1c2luZyBTbGF0ZSBtYXkgY2FsbCBTY3J1YmJlci5zZXRTY3J1YmJlcigpIHRvIGFsdGVyIHRoZSBiZWhhdmlvciBvZiB0aGlzXHJcbiAqIHN0cmluZ2lmeSgpIGZ1bmN0aW9uLlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZSwgdG8gcHJldmVudCB0aGUgY2xlYXJ0ZXh0IGxvZ2dpbmcgb2YgJ3RleHQnIGZpZWxkcyB3aXRoaW4gTm9kZXM6XHJcbiAqXHJcbiAqICAgIGltcG9ydCB7IFNjcnViYmVyIH0gZnJvbSAnc2xhdGUnO1xyXG4gKiAgICBTY3J1YmJlci5zZXRTY3J1YmJlcigoa2V5LCB2YWwpID0+IHtcclxuICogICAgICBpZiAoa2V5ID09PSAndGV4dCcpIHJldHVybiAnLi4uc2NydWJiZWQuLi4nXHJcbiAqICAgICAgcmV0dXJuIHZhbFxyXG4gKiAgICB9KTtcclxuICpcclxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBTY3J1YmJlciA9IHtcbiAgc2V0U2NydWJiZXIoc2NydWJiZXIpIHtcbiAgICBfc2NydWJiZXIgPSBzY3J1YmJlcjtcbiAgfSxcblxuICBzdHJpbmdpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIF9zY3J1YmJlcik7XG4gIH1cblxufTtcblxuLypcclxuICBDdXN0b20gZGVlcCBlcXVhbCBjb21wYXJpc29uIGZvciBTbGF0ZSBub2Rlcy5cclxuXG4gIFdlIGRvbid0IG5lZWQgZ2VuZXJhbCBwdXJwb3NlIGRlZXAgZXF1YWxpdHk7XHJcbiAgU2xhdGUgb25seSBzdXBwb3J0cyBwbGFpbiB2YWx1ZXMsIEFycmF5cywgYW5kIG5lc3RlZCBvYmplY3RzLlxyXG4gIENvbXBsZXggdmFsdWVzIG5lc3RlZCBpbnNpZGUgQXJyYXlzIGFyZSBub3Qgc3VwcG9ydGVkLlxyXG5cbiAgU2xhdGUgb2JqZWN0cyBhcmUgZGVzaWduZWQgdG8gYmUgc2VyaWFsaXNlZCwgc29cclxuICBtaXNzaW5nIGtleXMgYXJlIGRlbGliZXJhdGVseSBub3JtYWxpc2VkIHRvIHVuZGVmaW5lZC5cclxuICovXG5cbnZhciBpc0RlZXBFcXVhbCA9IChub2RlLCBhbm90aGVyKSA9PiB7XG4gIGZvciAodmFyIGtleSBpbiBub2RlKSB7XG4gICAgdmFyIGEgPSBub2RlW2tleV07XG4gICAgdmFyIGIgPSBhbm90aGVyW2tleV07XG5cbiAgICBpZiAoaXNQbGFpbk9iamVjdChhKSAmJiBpc1BsYWluT2JqZWN0KGIpKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsKGEsIGIpKSByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhICE9PSBiKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qXHJcbiAgICBEZWVwIG9iamVjdCBlcXVhbGl0eSBpcyBvbmx5IG5lY2Vzc2FyeSBpbiBvbmUgZGlyZWN0aW9uOyBpbiB0aGUgcmV2ZXJzZSBkaXJlY3Rpb25cclxuICAgIHdlIGFyZSBvbmx5IGxvb2tpbmcgZm9yIGtleXMgdGhhdCBhcmUgbWlzc2luZy5cclxuICAgIEFzIGFib3ZlLCB1bmRlZmluZWQga2V5cyBhcmUgbm9ybWFsaXNlZCB0byBtaXNzaW5nLlxyXG4gICovXG5cblxuICBmb3IgKHZhciBfa2V5IGluIGFub3RoZXIpIHtcbiAgICBpZiAobm9kZVtfa2V5XSA9PT0gdW5kZWZpbmVkICYmIGFub3RoZXJbX2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIF9leGNsdWRlZCQxID0gW1widGV4dFwiXSxcbiAgICBfZXhjbHVkZWQyJDEgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXTtcblxuZnVuY3Rpb24gb3duS2V5cyQ0KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ0KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNChPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDQoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBUZXh0ID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiB0d28gdGV4dCBub2RlcyBhcmUgZXF1YWwuXHJcbiAgICpcclxuICAgKiBXaGVuIGxvb3NlIGlzIHNldCwgdGhlIHRleHQgaXMgbm90IGNvbXBhcmVkLiBUaGlzIGlzXHJcbiAgICogdXNlZCB0byBjaGVjayB3aGV0aGVyIHNpYmxpbmcgdGV4dCBub2RlcyBjYW4gYmUgbWVyZ2VkLlxyXG4gICAqL1xuICBlcXVhbHModGV4dCwgYW5vdGhlcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgbG9vc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgZnVuY3Rpb24gb21pdFRleHQob2JqKSB7XG4gICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIF9leGNsdWRlZCQxKTtcblxuICAgICAgcmV0dXJuIHJlc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzRGVlcEVxdWFsKGxvb3NlID8gb21pdFRleHQodGV4dCkgOiB0ZXh0LCBsb29zZSA/IG9taXRUZXh0KGFub3RoZXIpIDogYW5vdGhlcik7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpbXBsZW1lbnRzIHRoZSBgVGV4dGAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1RleHQodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlLnRleHQgPT09ICdzdHJpbmcnO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBsaXN0IG9mIGBUZXh0YCBvYmplY3RzLlxyXG4gICAqL1xuICBpc1RleHRMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBUZXh0LmlzVGV4dCh2YWwpKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBzb21lIHByb3BzIGFyZSBhIHBhcnRpYWwgb2YgVGV4dC5cclxuICAgKi9cbiAgaXNUZXh0UHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMudGV4dCAhPT0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGFuIHRleHQgbWF0Y2hlcyBzZXQgb2YgcHJvcGVydGllcy5cclxuICAgKlxyXG4gICAqIE5vdGU6IHRoaXMgaXMgZm9yIG1hdGNoaW5nIGN1c3RvbSBwcm9wZXJ0aWVzLCBhbmQgaXQgZG9lcyBub3QgZW5zdXJlIHRoYXRcclxuICAgKiB0aGUgYHRleHRgIHByb3BlcnR5IGFyZSB0d28gbm9kZXMgZXF1YWwuXHJcbiAgICovXG4gIG1hdGNoZXModGV4dCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICd0ZXh0Jykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0ZXh0Lmhhc093blByb3BlcnR5KGtleSkgfHwgdGV4dFtrZXldICE9PSBwcm9wc1trZXldKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxlYXZlcyBmb3IgYSB0ZXh0IG5vZGUgZ2l2ZW4gZGVjb3JhdGlvbnMuXHJcbiAgICovXG4gIGRlY29yYXRpb25zKG5vZGUsIGRlY29yYXRpb25zKSB7XG4gICAgdmFyIGxlYXZlcyA9IFtfb2JqZWN0U3ByZWFkJDQoe30sIG5vZGUpXTtcblxuICAgIGZvciAodmFyIGRlYyBvZiBkZWNvcmF0aW9ucykge1xuICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoZGVjLCBfZXhjbHVkZWQyJDEpO1xuXG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoZGVjKTtcbiAgICAgIHZhciBuZXh0ID0gW107XG4gICAgICB2YXIgbGVhZkVuZCA9IDA7XG4gICAgICB2YXIgZGVjb3JhdGlvblN0YXJ0ID0gc3RhcnQub2Zmc2V0O1xuICAgICAgdmFyIGRlY29yYXRpb25FbmQgPSBlbmQub2Zmc2V0O1xuXG4gICAgICBmb3IgKHZhciBsZWFmIG9mIGxlYXZlcykge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGxlbmd0aFxuICAgICAgICB9ID0gbGVhZi50ZXh0O1xuICAgICAgICB2YXIgbGVhZlN0YXJ0ID0gbGVhZkVuZDtcbiAgICAgICAgbGVhZkVuZCArPSBsZW5ndGg7IC8vIElmIHRoZSByYW5nZSBlbmNvbXBhc3NlcyB0aGUgZW50aXJlIGxlYWYsIGFkZCB0aGUgcmFuZ2UuXG5cbiAgICAgICAgaWYgKGRlY29yYXRpb25TdGFydCA8PSBsZWFmU3RhcnQgJiYgbGVhZkVuZCA8PSBkZWNvcmF0aW9uRW5kKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihsZWFmLCByZXN0KTtcbiAgICAgICAgICBuZXh0LnB1c2gobGVhZik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gSWYgdGhlIHJhbmdlIGV4cGFuZGVkIGFuZCBtYXRjaCB0aGUgbGVhZiwgb3Igc3RhcnRzIGFmdGVyLCBvciBlbmRzIGJlZm9yZSBpdCwgY29udGludWUuXG5cblxuICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0ICE9PSBkZWNvcmF0aW9uRW5kICYmIChkZWNvcmF0aW9uU3RhcnQgPT09IGxlYWZFbmQgfHwgZGVjb3JhdGlvbkVuZCA9PT0gbGVhZlN0YXJ0KSB8fCBkZWNvcmF0aW9uU3RhcnQgPiBsZWFmRW5kIHx8IGRlY29yYXRpb25FbmQgPCBsZWFmU3RhcnQgfHwgZGVjb3JhdGlvbkVuZCA9PT0gbGVhZlN0YXJ0ICYmIGxlYWZTdGFydCAhPT0gMCkge1xuICAgICAgICAgIG5leHQucHVzaChsZWFmKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byBzcGxpdCB0aGUgbGVhZiwgYXQgdGhlIHN0YXJ0LCBlbmQsIG9yIGJvdGgsXG4gICAgICAgIC8vIGFuZCBhZGQgdGhlIHJhbmdlIHRvIHRoZSBtaWRkbGUgaW50ZXJzZWN0aW5nIHNlY3Rpb24uIERvIHRoZSBlbmRcbiAgICAgICAgLy8gc3BsaXQgZmlyc3Qgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgdGhlIG9mZnNldCB0aGF0IHdheS5cblxuXG4gICAgICAgIHZhciBtaWRkbGUgPSBsZWFmO1xuICAgICAgICB2YXIgYmVmb3JlID0gdm9pZCAwO1xuICAgICAgICB2YXIgYWZ0ZXIgPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGRlY29yYXRpb25FbmQgPCBsZWFmRW5kKSB7XG4gICAgICAgICAgdmFyIG9mZiA9IGRlY29yYXRpb25FbmQgLSBsZWFmU3RhcnQ7XG4gICAgICAgICAgYWZ0ZXIgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2Uob2ZmKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1pZGRsZSA9IF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZSgwLCBvZmYpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0ID4gbGVhZlN0YXJ0KSB7XG4gICAgICAgICAgdmFyIF9vZmYgPSBkZWNvcmF0aW9uU3RhcnQgLSBsZWFmU3RhcnQ7XG5cbiAgICAgICAgICBiZWZvcmUgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoMCwgX29mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBtaWRkbGUgPSBfb2JqZWN0U3ByZWFkJDQoX29iamVjdFNwcmVhZCQ0KHt9LCBtaWRkbGUpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogbWlkZGxlLnRleHQuc2xpY2UoX29mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIE9iamVjdC5hc3NpZ24obWlkZGxlLCByZXN0KTtcblxuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKGJlZm9yZSk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0LnB1c2gobWlkZGxlKTtcblxuICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICBuZXh0LnB1c2goYWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxlYXZlcyA9IG5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxlYXZlcztcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDModGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIGFwcGx5VG9EcmFmdCA9IChlZGl0b3IsIHNlbGVjdGlvbiwgb3ApID0+IHtcbiAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgbm9kZVxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGluZGV4ID4gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhbiBcXFwiaW5zZXJ0X25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgdGhlIGRlc3RpbmF0aW9uIGlzIHBhc3QgdGhlIGVuZCBvZiB0aGUgbm9kZS5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMCwgbm9kZSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtwb2ludCwga2V5XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW2tleV0gPSBQb2ludC50cmFuc2Zvcm0ocG9pbnQsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgdGV4dFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gMCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIF9ub2RlID0gTm9kZS5sZWFmKGVkaXRvciwgX3BhdGgpO1xuXG4gICAgICAgIHZhciBiZWZvcmUgPSBfbm9kZS50ZXh0LnNsaWNlKDAsIG9mZnNldCk7XG5cbiAgICAgICAgdmFyIGFmdGVyID0gX25vZGUudGV4dC5zbGljZShvZmZzZXQpO1xuXG4gICAgICAgIF9ub2RlLnRleHQgPSBiZWZvcmUgKyB0ZXh0ICsgYWZ0ZXI7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQsIF9rZXldIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25bX2tleV0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50LCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDJcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIHZhciBfbm9kZTIgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoMik7XG5cbiAgICAgICAgdmFyIHByZXZQYXRoID0gUGF0aC5wcmV2aW91cyhfcGF0aDIpO1xuICAgICAgICB2YXIgcHJldiA9IE5vZGUuZ2V0KGVkaXRvciwgcHJldlBhdGgpO1xuXG4gICAgICAgIHZhciBfcGFyZW50ID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDIpO1xuXG4gICAgICAgIHZhciBfaW5kZXggPSBfcGF0aDJbX3BhdGgyLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChfbm9kZTIpICYmIFRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgcHJldi50ZXh0ICs9IF9ub2RlMi50ZXh0O1xuICAgICAgICB9IGVsc2UgaWYgKCFUZXh0LmlzVGV4dChfbm9kZTIpICYmICFUZXh0LmlzVGV4dChwcmV2KSkge1xuICAgICAgICAgIHByZXYuY2hpbGRyZW4ucHVzaCguLi5fbm9kZTIuY2hpbGRyZW4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhIFxcXCJtZXJnZV9ub2RlXFxcIiBvcGVyYXRpb24gYXQgcGF0aCBbXCIuY29uY2F0KF9wYXRoMiwgXCJdIHRvIG5vZGVzIG9mIGRpZmZlcmVudCBpbnRlcmZhY2VzOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShfbm9kZTIpLCBcIiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShwcmV2KSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3BhcmVudC5jaGlsZHJlbi5zcGxpY2UoX2luZGV4LCAxKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDIsIF9rZXkyXSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXkyXSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQyLCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoMyxcbiAgICAgICAgICBuZXdQYXRoXG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKF9wYXRoMywgbmV3UGF0aCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbW92ZSBhIHBhdGggW1wiLmNvbmNhdChfcGF0aDMsIFwiXSB0byBuZXcgcGF0aCBbXCIpLmNvbmNhdChuZXdQYXRoLCBcIl0gYmVjYXVzZSB0aGUgZGVzdGluYXRpb24gaXMgaW5zaWRlIGl0c2VsZi5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9ub2RlMyA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGgzKTtcblxuICAgICAgICB2YXIgX3BhcmVudDIgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoMyk7XG5cbiAgICAgICAgdmFyIF9pbmRleDIgPSBfcGF0aDNbX3BhdGgzLmxlbmd0aCAtIDFdOyAvLyBUaGlzIGlzIHRyaWNreSwgYnV0IHNpbmNlIHRoZSBgcGF0aGAgYW5kIGBuZXdQYXRoYCBib3RoIHJlZmVyIHRvXG4gICAgICAgIC8vIHRoZSBzYW1lIHNuYXBzaG90IGluIHRpbWUsIHRoZXJlJ3MgYSBtaXNtYXRjaC4gQWZ0ZXIgZWl0aGVyXG4gICAgICAgIC8vIHJlbW92aW5nIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiwgdGhlIHNlY29uZCBzdGVwJ3MgcGF0aCBjYW4gYmUgb3V0XG4gICAgICAgIC8vIG9mIGRhdGUuIFNvIGluc3RlYWQgb2YgdXNpbmcgdGhlIGBvcC5uZXdQYXRoYCBkaXJlY3RseSwgd2VcbiAgICAgICAgLy8gdHJhbnNmb3JtIGBvcC5wYXRoYCB0byBhc2NlcnRhaW4gd2hhdCB0aGUgYG5ld1BhdGhgIHdvdWxkIGJlIGFmdGVyXG4gICAgICAgIC8vIHRoZSBvcGVyYXRpb24gd2FzIGFwcGxpZWQuXG5cbiAgICAgICAgX3BhcmVudDIuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDIsIDEpO1xuXG4gICAgICAgIHZhciB0cnVlUGF0aCA9IFBhdGgudHJhbnNmb3JtKF9wYXRoMywgb3ApO1xuICAgICAgICB2YXIgbmV3UGFyZW50ID0gTm9kZS5nZXQoZWRpdG9yLCBQYXRoLnBhcmVudCh0cnVlUGF0aCkpO1xuICAgICAgICB2YXIgbmV3SW5kZXggPSB0cnVlUGF0aFt0cnVlUGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgbmV3UGFyZW50LmNoaWxkcmVuLnNwbGljZShuZXdJbmRleCwgMCwgX25vZGUzKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDMsIF9rZXkzXSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXkzXSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQzLCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg0XG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgdmFyIF9pbmRleDMgPSBfcGF0aDRbX3BhdGg0Lmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIHZhciBfcGFyZW50MyA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGg0KTtcblxuICAgICAgICBfcGFyZW50My5jaGlsZHJlbi5zcGxpY2UoX2luZGV4MywgMSk7IC8vIFRyYW5zZm9ybSBhbGwgb2YgdGhlIHBvaW50cyBpbiB0aGUgdmFsdWUsIGJ1dCBpZiB0aGUgcG9pbnQgd2FzIGluIHRoZVxuICAgICAgICAvLyBub2RlIHRoYXQgd2FzIHJlbW92ZWQgd2UgbmVlZCB0byB1cGRhdGUgdGhlIHJhbmdlIG9yIHJlbW92ZSBpdC5cblxuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50NCwgX2tleTRdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDQsIG9wKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiAhPSBudWxsICYmIHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5NF0gPSByZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX3ByZXYgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgdmFyIG5leHQgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgW24sIHBdIG9mIE5vZGUudGV4dHMoZWRpdG9yKSkge1xuICAgICAgICAgICAgICAgIGlmIChQYXRoLmNvbXBhcmUocCwgX3BhdGg0KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIF9wcmV2ID0gW24sIHBdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBuZXh0ID0gW24sIHBdO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIHByZWZlck5leHQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBpZiAoX3ByZXYgJiYgbmV4dCkge1xuICAgICAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXh0WzFdLCBfcGF0aDQpKSB7XG4gICAgICAgICAgICAgICAgICBwcmVmZXJOZXh0ID0gIVBhdGguaGFzUHJldmlvdXMobmV4dFsxXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHByZWZlck5leHQgPSBQYXRoLmNvbW1vbihfcHJldlsxXSwgX3BhdGg0KS5sZW5ndGggPCBQYXRoLmNvbW1vbihuZXh0WzFdLCBfcGF0aDQpLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoX3ByZXYgJiYgIXByZWZlck5leHQpIHtcbiAgICAgICAgICAgICAgICBfcG9pbnQ0LnBhdGggPSBfcHJldlsxXTtcbiAgICAgICAgICAgICAgICBfcG9pbnQ0Lm9mZnNldCA9IF9wcmV2WzBdLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5leHQpIHtcbiAgICAgICAgICAgICAgICBfcG9pbnQ0LnBhdGggPSBuZXh0WzFdO1xuICAgICAgICAgICAgICAgIF9wb2ludDQub2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg1LFxuICAgICAgICAgIG9mZnNldDogX29mZnNldCxcbiAgICAgICAgICB0ZXh0OiBfdGV4dFxuICAgICAgICB9ID0gb3A7XG4gICAgICAgIGlmIChfdGV4dC5sZW5ndGggPT09IDApIGJyZWFrO1xuXG4gICAgICAgIHZhciBfbm9kZTQgPSBOb2RlLmxlYWYoZWRpdG9yLCBfcGF0aDUpO1xuXG4gICAgICAgIHZhciBfYmVmb3JlID0gX25vZGU0LnRleHQuc2xpY2UoMCwgX29mZnNldCk7XG5cbiAgICAgICAgdmFyIF9hZnRlciA9IF9ub2RlNC50ZXh0LnNsaWNlKF9vZmZzZXQgKyBfdGV4dC5sZW5ndGgpO1xuXG4gICAgICAgIF9ub2RlNC50ZXh0ID0gX2JlZm9yZSArIF9hZnRlcjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDUsIF9rZXk1XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk1XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ1LCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzZXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg2LFxuICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgbmV3UHJvcGVydGllc1xuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgaWYgKF9wYXRoNi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHByb3BlcnRpZXMgb24gdGhlIHJvb3Qgbm9kZSFcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX25vZGU1ID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDYpO1xuXG4gICAgICAgIGZvciAodmFyIF9rZXk2IGluIG5ld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAoX2tleTYgPT09ICdjaGlsZHJlbicgfHwgX2tleTYgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCB0aGUgXFxcIlwiLmNvbmNhdChfa2V5NiwgXCJcXFwiIHByb3BlcnR5IG9mIG5vZGVzIVwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHZhbHVlID0gbmV3UHJvcGVydGllc1tfa2V5Nl07XG5cbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVsZXRlIF9ub2RlNVtfa2V5Nl07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9ub2RlNVtfa2V5Nl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gcHJvcGVydGllcyB0aGF0IHdlcmUgcHJldmlvdXNseSBkZWZpbmVkLCBidXQgYXJlIG5vdyBtaXNzaW5nLCBtdXN0IGJlIGRlbGV0ZWRcblxuXG4gICAgICAgIGZvciAodmFyIF9rZXk3IGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICBpZiAoIW5ld1Byb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoX2tleTcpKSB7XG4gICAgICAgICAgICBkZWxldGUgX25vZGU1W19rZXk3XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IF9uZXdQcm9wZXJ0aWVzXG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgIHNlbGVjdGlvbiA9IF9uZXdQcm9wZXJ0aWVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzZWxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFSYW5nZS5pc1JhbmdlKF9uZXdQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYW4gaW5jb21wbGV0ZSBcXFwic2V0X3NlbGVjdGlvblxcXCIgb3BlcmF0aW9uIHByb3BlcnRpZXMgXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShfbmV3UHJvcGVydGllcyksIFwiIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudCBzZWxlY3Rpb24uXCIpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZWN0aW9uID0gX29iamVjdFNwcmVhZCQzKHt9LCBfbmV3UHJvcGVydGllcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgX2tleTggaW4gX25ld1Byb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHZhciBfdmFsdWUgPSBfbmV3UHJvcGVydGllc1tfa2V5OF07XG5cbiAgICAgICAgICAgIGlmIChfdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoX2tleTggPT09ICdhbmNob3InIHx8IF9rZXk4ID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlbW92ZSB0aGUgXFxcIlwiLmNvbmNhdChfa2V5OCwgXCJcXFwiIHNlbGVjdGlvbiBwcm9wZXJ0eVwiKSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBkZWxldGUgc2VsZWN0aW9uW19rZXk4XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5OF0gPSBfdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDcsXG4gICAgICAgICAgcG9zaXRpb24sXG4gICAgICAgICAgcHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIGlmIChfcGF0aDcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGEgXFxcInNwbGl0X25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQoX3BhdGg3LCBcIl0gYmVjYXVzZSB0aGUgcm9vdCBub2RlIGNhbm5vdCBiZSBzcGxpdC5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9ub2RlNiA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGg3KTtcblxuICAgICAgICB2YXIgX3BhcmVudDQgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoNyk7XG5cbiAgICAgICAgdmFyIF9pbmRleDQgPSBfcGF0aDdbX3BhdGg3Lmxlbmd0aCAtIDFdO1xuICAgICAgICB2YXIgbmV3Tm9kZTtcblxuICAgICAgICBpZiAoVGV4dC5pc1RleHQoX25vZGU2KSkge1xuICAgICAgICAgIHZhciBfYmVmb3JlMiA9IF9ub2RlNi50ZXh0LnNsaWNlKDAsIHBvc2l0aW9uKTtcblxuICAgICAgICAgIHZhciBfYWZ0ZXIyID0gX25vZGU2LnRleHQuc2xpY2UocG9zaXRpb24pO1xuXG4gICAgICAgICAgX25vZGU2LnRleHQgPSBfYmVmb3JlMjtcbiAgICAgICAgICBuZXdOb2RlID0gX29iamVjdFNwcmVhZCQzKF9vYmplY3RTcHJlYWQkMyh7fSwgX3Byb3BlcnRpZXMpLCB7fSwge1xuICAgICAgICAgICAgdGV4dDogX2FmdGVyMlxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBfYmVmb3JlMyA9IF9ub2RlNi5jaGlsZHJlbi5zbGljZSgwLCBwb3NpdGlvbik7XG5cbiAgICAgICAgICB2YXIgX2FmdGVyMyA9IF9ub2RlNi5jaGlsZHJlbi5zbGljZShwb3NpdGlvbik7XG5cbiAgICAgICAgICBfbm9kZTYuY2hpbGRyZW4gPSBfYmVmb3JlMztcbiAgICAgICAgICBuZXdOb2RlID0gX29iamVjdFNwcmVhZCQzKF9vYmplY3RTcHJlYWQkMyh7fSwgX3Byb3BlcnRpZXMpLCB7fSwge1xuICAgICAgICAgICAgY2hpbGRyZW46IF9hZnRlcjNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9wYXJlbnQ0LmNoaWxkcmVuLnNwbGljZShfaW5kZXg0ICsgMSwgMCwgbmV3Tm9kZSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQ2LCBfa2V5OV0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5OV0gPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50Niwgb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuXG52YXIgR2VuZXJhbFRyYW5zZm9ybXMgPSB7XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgZWRpdG9yIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKGVkaXRvciwgb3ApIHtcbiAgICBlZGl0b3IuY2hpbGRyZW4gPSBjcmVhdGVEcmFmdChlZGl0b3IuY2hpbGRyZW4pO1xuICAgIHZhciBzZWxlY3Rpb24gPSBlZGl0b3Iuc2VsZWN0aW9uICYmIGNyZWF0ZURyYWZ0KGVkaXRvci5zZWxlY3Rpb24pO1xuXG4gICAgdHJ5IHtcbiAgICAgIHNlbGVjdGlvbiA9IGFwcGx5VG9EcmFmdChlZGl0b3IsIHNlbGVjdGlvbiwgb3ApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBlZGl0b3IuY2hpbGRyZW4gPSBmaW5pc2hEcmFmdChlZGl0b3IuY2hpbGRyZW4pO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGVkaXRvci5zZWxlY3Rpb24gPSBpc0RyYWZ0KHNlbGVjdGlvbikgPyBmaW5pc2hEcmFmdChzZWxlY3Rpb24pIDogc2VsZWN0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJ0ZXh0XCJdLFxuICAgIF9leGNsdWRlZDIgPSBbXCJjaGlsZHJlblwiXTtcblxuZnVuY3Rpb24gb3duS2V5cyQyKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQyKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBOb2RlVHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogSW5zZXJ0IG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gaW4gdGhlIEVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0Tm9kZXMoZWRpdG9yLCBub2Rlcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgICBtb2RlID0gJ2xvd2VzdCdcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBzZWxlY3RcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoTm9kZS5pc05vZGUobm9kZXMpKSB7XG4gICAgICAgIG5vZGVzID0gW25vZGVzXTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBbbm9kZV0gPSBub2RlczsgLy8gQnkgZGVmYXVsdCwgdXNlIHRoZSBzZWxlY3Rpb24gYXMgdGhlIHRhcmdldCBsb2NhdGlvbi4gQnV0IGlmIHRoZXJlIGlzXG4gICAgICAvLyBubyBzZWxlY3Rpb24sIGluc2VydCBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudCBzaW5jZSB0aGF0IGlzIHN1Y2ggYVxuICAgICAgLy8gY29tbW9uIHVzZSBjYXNlIHdoZW4gaW5zZXJ0aW5nIGZyb20gYSBub24tc2VsZWN0ZWQgc3RhdGUuXG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb247XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXQgPSBbMF07XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3QgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZWN0ID09IG51bGwpIHtcbiAgICAgICAgc2VsZWN0ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICAgIG1hdGNoID0gbiA9PiBUZXh0LmlzVGV4dChuKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgICAgbWF0Y2ggPSBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaCA9IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgW2VudHJ5XSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXQucGF0aCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBbLCBfbWF0Y2hQYXRoXSA9IGVudHJ5O1xuICAgICAgICAgIHZhciBwYXRoUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBfbWF0Y2hQYXRoKTtcbiAgICAgICAgICB2YXIgaXNBdEVuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBfbWF0Y2hQYXRoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdCxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgICAgYXQgPSBpc0F0RW5kID8gUGF0aC5uZXh0KHBhdGgpIDogcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChhdCk7XG4gICAgICB2YXIgaW5kZXggPSBhdFthdC5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhcmVudFBhdGhcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX25vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgdmFyIF9wYXRoID0gcGFyZW50UGF0aC5jb25jYXQoaW5kZXgpO1xuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJyxcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBub2RlOiBfbm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgYXQgPSBQYXRoLm5leHQoYXQpO1xuICAgICAgfVxuXG4gICAgICBhdCA9IFBhdGgucHJldmlvdXMoYXQpO1xuXG4gICAgICBpZiAoc2VsZWN0KSB7XG4gICAgICAgIHZhciBwb2ludCA9IEVkaXRvci5lbmQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBMaWZ0IG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gdXB3YXJkcyBpbiB0aGUgZG9jdW1lbnQgdHJlZSwgc3BsaXR0aW5nXHJcbiAgICogdGhlaXIgcGFyZW50IGluIHR3byBpZiBuZWNlc3NhcnkuXHJcbiAgICovXG4gIGxpZnROb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2hlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIF9yZWYgPT4ge1xuICAgICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbGlmdCBub2RlIGF0IGEgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IGhhcyBhIGRlcHRoIG9mIGxlc3MgdGhhbiBgMmAuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnROb2RlRW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIFBhdGgucGFyZW50KHBhdGgpKTtcbiAgICAgICAgdmFyIFtwYXJlbnQsIHBhcmVudFBhdGhdID0gcGFyZW50Tm9kZUVudHJ5O1xuICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbGVuZ3RoXG4gICAgICAgIH0gPSBwYXJlbnQuY2hpbGRyZW47XG5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHZhciB0b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICAgIHRvOiB0b1BhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGFyZW50UGF0aCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IHBhcmVudFBhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIF90b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IF90b1BhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzcGxpdFBhdGggPSBQYXRoLm5leHQocGF0aCk7XG5cbiAgICAgICAgICB2YXIgX3RvUGF0aDIgPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogc3BsaXRQYXRoLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IF90b1BhdGgyLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1lcmdlIGEgbm9kZSBhdCBhIGxvY2F0aW9uIHdpdGggdGhlIHByZXZpb3VzIG5vZGUgb2YgdGhlIHNhbWUgZGVwdGgsXHJcbiAgICogcmVtb3ZpbmcgYW55IGVtcHR5IGNvbnRhaW5pbmcgbm9kZXMgYWZ0ZXIgdGhlIG1lcmdlIGlmIG5lY2Vzc2FyeS5cclxuICAgKi9cbiAgbWVyZ2VOb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgICBtb2RlID0gJ2xvd2VzdCdcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuXG4gICAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBbY3VycmVudF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgdm9pZHMsXG4gICAgICAgIG1vZGVcbiAgICAgIH0pO1xuICAgICAgdmFyIHByZXYgPSBFZGl0b3IucHJldmlvdXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgdm9pZHMsXG4gICAgICAgIG1vZGVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWN1cnJlbnQgfHwgIXByZXYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgW25vZGUsIHBhdGhdID0gY3VycmVudDtcbiAgICAgIHZhciBbcHJldk5vZGUsIHByZXZQYXRoXSA9IHByZXY7XG5cbiAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCB8fCBwcmV2UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3UGF0aCA9IFBhdGgubmV4dChwcmV2UGF0aCk7XG4gICAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguY29tbW9uKHBhdGgsIHByZXZQYXRoKTtcbiAgICAgIHZhciBpc1ByZXZpb3VzU2libGluZyA9IFBhdGguaXNTaWJsaW5nKHBhdGgsIHByZXZQYXRoKTtcbiAgICAgIHZhciBsZXZlbHMgPSBBcnJheS5mcm9tKEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBwYXRoXG4gICAgICB9KSwgX3JlZjIgPT4ge1xuICAgICAgICB2YXIgW25dID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfSkuc2xpY2UoY29tbW9uUGF0aC5sZW5ndGgpLnNsaWNlKDAsIC0xKTsgLy8gRGV0ZXJtaW5lIGlmIHRoZSBtZXJnZSB3aWxsIGxlYXZlIGFuIGFuY2VzdG9yIG9mIHRoZSBwYXRoIGVtcHR5IGFzIGFcbiAgICAgIC8vIHJlc3VsdCwgaW4gd2hpY2ggY2FzZSB3ZSdsbCB3YW50IHRvIHJlbW92ZSBpdCBhZnRlciBtZXJnaW5nLlxuXG4gICAgICB2YXIgZW1wdHlBbmNlc3RvciA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgbWF0Y2g6IG4gPT4gbGV2ZWxzLmluY2x1ZGVzKG4pICYmIGhhc1NpbmdsZUNoaWxkTmVzdChlZGl0b3IsIG4pXG4gICAgICB9KTtcbiAgICAgIHZhciBlbXB0eVJlZiA9IGVtcHR5QW5jZXN0b3IgJiYgRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBlbXB0eUFuY2VzdG9yWzFdKTtcbiAgICAgIHZhciBwcm9wZXJ0aWVzO1xuICAgICAgdmFyIHBvc2l0aW9uOyAvLyBFbnN1cmUgdGhhdCB0aGUgbm9kZXMgYXJlIGVxdWl2YWxlbnQsIGFuZCBmaWd1cmUgb3V0IHdoYXQgdGhlIHBvc2l0aW9uXG4gICAgICAvLyBhbmQgZXh0cmEgcHJvcGVydGllcyBvZiB0aGUgbWVyZ2Ugd2lsbCBiZS5cblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0KHByZXZOb2RlKSkge1xuICAgICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQpO1xuXG4gICAgICAgIHBvc2l0aW9uID0gcHJldk5vZGUudGV4dC5sZW5ndGg7XG4gICAgICAgIHByb3BlcnRpZXMgPSByZXN0O1xuICAgICAgfSBlbHNlIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkpIHtcbiAgICAgICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMobm9kZSwgX2V4Y2x1ZGVkMik7XG5cbiAgICAgICAgcG9zaXRpb24gPSBwcmV2Tm9kZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHByb3BlcnRpZXMgPSByZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1lcmdlIHRoZSBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gd2l0aCB0aGUgcHJldmlvdXMgc2libGluZyBiZWNhdXNlIGl0IGlzIG5vdCB0aGUgc2FtZSBraW5kOiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSwgXCIgXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocHJldk5vZGUpKSk7XG4gICAgICB9IC8vIElmIHRoZSBub2RlIGlzbid0IGFscmVhZHkgdGhlIG5leHQgc2libGluZyBvZiB0aGUgcHJldmlvdXMgbm9kZSwgbW92ZVxuICAgICAgLy8gaXQgc28gdGhhdCBpdCBpcyBiZWZvcmUgbWVyZ2luZy5cblxuXG4gICAgICBpZiAoIWlzUHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIFRyYW5zZm9ybXMubW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgIHRvOiBuZXdQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBJZiB0aGVyZSB3YXMgZ29pbmcgdG8gYmUgYW4gZW1wdHkgYW5jZXN0b3Igb2YgdGhlIG5vZGUgdGhhdCB3YXMgbWVyZ2VkLFxuICAgICAgLy8gd2UgcmVtb3ZlIGl0IGZyb20gdGhlIHRyZWUuXG5cblxuICAgICAgaWYgKGVtcHR5UmVmKSB7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVtcHR5UmVmLmN1cnJlbnQsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIElmIHRoZSB0YXJnZXQgbm9kZSB0aGF0IHdlJ3JlIG1lcmdpbmcgd2l0aCBpcyBlbXB0eSwgcmVtb3ZlIGl0IGluc3RlYWRcbiAgICAgIC8vIG9mIG1lcmdpbmcgdGhlIHR3by4gVGhpcyBpcyBhIGNvbW1vbiByaWNoIHRleHQgZWRpdG9yIGJlaGF2aW9yIHRvXG4gICAgICAvLyBwcmV2ZW50IGxvc2luZyBmb3JtYXR0aW5nIHdoZW4gZGVsZXRpbmcgZW50aXJlIG5vZGVzIHdoZW4geW91IGhhdmUgYVxuICAgICAgLy8gaGFuZ2luZyBzZWxlY3Rpb24uXG4gICAgICAvLyBpZiBwcmV2Tm9kZSBpcyBmaXJzdCBjaGlsZCBpbiBwYXJlbnQsZG9uJ3QgcmVtb3ZlIGl0LlxuXG5cbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChwcmV2Tm9kZSkgJiYgRWRpdG9yLmlzRW1wdHkoZWRpdG9yLCBwcmV2Tm9kZSkgfHwgVGV4dC5pc1RleHQocHJldk5vZGUpICYmIHByZXZOb2RlLnRleHQgPT09ICcnICYmIHByZXZQYXRoW3ByZXZQYXRoLmxlbmd0aCAtIDFdICE9PSAwKSB7XG4gICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHByZXZQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgICAgcGF0aDogbmV3UGF0aCxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW1wdHlSZWYpIHtcbiAgICAgICAgZW1wdHlSZWYudW5yZWYoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNb3ZlIHRoZSBub2RlcyBhdCBhIGxvY2F0aW9uIHRvIGEgbmV3IGxvY2F0aW9uLlxyXG4gICAqL1xuICBtb3ZlTm9kZXMoZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHRvLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBtYXRjaFxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCB0byk7XG4gICAgICB2YXIgdGFyZ2V0cyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKHRhcmdldHMsIF9yZWYzID0+IHtcbiAgICAgICAgdmFyIFssIHBdID0gX3JlZjM7XG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgIHZhciBuZXdQYXRoID0gdG9SZWYuY3VycmVudDtcblxuICAgICAgICBpZiAocGF0aC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ21vdmVfbm9kZScsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgbmV3UGF0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvUmVmLmN1cnJlbnQgJiYgUGF0aC5pc1NpYmxpbmcobmV3UGF0aCwgcGF0aCkgJiYgUGF0aC5pc0FmdGVyKG5ld1BhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgLy8gV2hlbiBwZXJmb3JtaW5nIGEgc2libGluZyBtb3ZlIHRvIGEgbGF0ZXIgaW5kZXgsIHRoZSBwYXRoIGF0IHRoZSBkZXN0aW5hdGlvbiBpcyBzaGlmdGVkXG4gICAgICAgICAgLy8gdG8gYmVmb3JlIHRoZSBpbnNlcnRpb24gcG9pbnQgaW5zdGVhZCBvZiBhZnRlci4gVG8gZW5zdXJlIG91ciBncm91cCBvZiBub2RlcyBhcmUgaW5zZXJ0ZWRcbiAgICAgICAgICAvLyBpbiB0aGUgY29ycmVjdCBvcmRlciB3ZSBpbmNyZW1lbnQgdG9SZWYgdG8gYWNjb3VudCBmb3IgdGhhdFxuICAgICAgICAgIHRvUmVmLmN1cnJlbnQgPSBQYXRoLm5leHQodG9SZWYuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9SZWYudW5yZWYoKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZW1vdmUgdGhlIG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50LlxyXG4gICAqL1xuICByZW1vdmVOb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZSxcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbWF0Y2hcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXB0aHMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShkZXB0aHMsIF9yZWY0ID0+IHtcbiAgICAgICAgdmFyIFssIHBdID0gX3JlZjQ7XG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG5cbiAgICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG5cbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV9ub2RlJyxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBub2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQgbmV3IHByb3BlcnRpZXMgb24gdGhlIG5vZGVzIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHNldE5vZGVzKGVkaXRvciwgcHJvcHMpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIGNvbXBhcmUsXG4gICAgICAgIG1lcmdlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZSxcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICBzcGxpdCA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWhhbmdpbmcgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BsaXQgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSAmJiBFZGl0b3IubGVhZihlZGl0b3IsIGF0LmFuY2hvcilbMF0udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCBpbiBhIG5vbi1lbXB0eSBub2RlIGFuZCAnc3BsaXQnIGlzIHRydWUsIHRoZXJlJ3Mgbm90aGluZyB0b1xuICAgICAgICAgIC8vIHNldCB0aGF0IHdvbid0IGdldCBub3JtYWxpemVkIGF3YXlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIHNwbGl0TW9kZSA9IG1vZGUgPT09ICdsb3dlc3QnID8gJ2xvd2VzdCcgOiAnaGlnaGVzdCc7XG4gICAgICAgIHZhciBlbmRBdEVuZE9mTm9kZSA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGVuZCwgZW5kLnBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgICAgdm9pZHMsXG4gICAgICAgICAgYWx3YXlzOiAhZW5kQXRFbmRPZk5vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzdGFydEF0U3RhcnRPZk5vZGUgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHN0YXJ0LCBzdGFydC5wYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgICAgdm9pZHMsXG4gICAgICAgICAgYWx3YXlzOiAhc3RhcnRBdFN0YXJ0T2ZOb2RlXG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHJhbmdlUmVmLnVucmVmKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY29tcGFyZSkge1xuICAgICAgICBjb21wYXJlID0gKHByb3AsIG5vZGVQcm9wKSA9PiBwcm9wICE9PSBub2RlUHJvcDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgdmFyIG5ld1Byb3BlcnRpZXMgPSB7fTsgLy8gWW91IGNhbid0IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSBlZGl0b3Igbm9kZS5cblxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXNDaGFuZ2VzID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgICAgICAgIGlmIChrID09PSAnY2hpbGRyZW4nIHx8IGsgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbXBhcmUocHJvcHNba10sIG5vZGVba10pKSB7XG4gICAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTsgLy8gT21pdCBuZXcgcHJvcGVydGllcyBmcm9tIHRoZSBvbGQgcHJvcGVydGllcyBsaXN0XG5cbiAgICAgICAgICAgIGlmIChub2RlLmhhc093blByb3BlcnR5KGspKSBwcm9wZXJ0aWVzW2tdID0gbm9kZVtrXTsgLy8gT21pdCBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbmV3IHByb3BlcnRpZXMgbGlzdFxuXG4gICAgICAgICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BzW2tdICE9IG51bGwpIG5ld1Byb3BlcnRpZXNba10gPSBtZXJnZShub2RlW2tdLCBwcm9wc1trXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocHJvcHNba10gIT0gbnVsbCkgbmV3UHJvcGVydGllc1trXSA9IHByb3BzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDaGFuZ2VzKSB7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdzZXRfbm9kZScsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNwbGl0IHRoZSBub2RlcyBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxyXG4gICAqL1xuICBzcGxpdE5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIGhlaWdodCA9IDAsXG4gICAgICAgIGFsd2F5cyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IGRlbGV0ZVJhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfSAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgcGF0aCwgdGhlIGRlZmF1bHQgaGVpZ2h0LXNraXBwaW5nIGFuZCBwb3NpdGlvblxuICAgICAgLy8gY291bnRlcnMgbmVlZCB0byBhY2NvdW50IGZvciB1cyBwb3RlbnRpYWxseSBzcGxpdHRpbmcgYXQgYSBub24tbGVhZi5cblxuXG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIHZhciBwYXRoID0gYXQ7XG4gICAgICAgIHZhciBwb2ludCA9IEVkaXRvci5wb2ludChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgbWF0Y2ggPSBuID0+IG4gPT09IHBhcmVudDtcblxuICAgICAgICBoZWlnaHQgPSBwb2ludC5wYXRoLmxlbmd0aCAtIHBhdGgubGVuZ3RoICsgMTtcbiAgICAgICAgYXQgPSBwb2ludDtcbiAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBiZWZvcmVSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgICAgfSk7XG4gICAgICB2YXIgYWZ0ZXJSZWY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBbaGlnaGVzdF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWhpZ2hlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdm9pZE1hdGNoID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQsXG4gICAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbnVkZ2UgPSAwO1xuXG4gICAgICAgIGlmICghdm9pZHMgJiYgdm9pZE1hdGNoKSB7XG4gICAgICAgICAgdmFyIFt2b2lkTm9kZSwgdm9pZFBhdGhdID0gdm9pZE1hdGNoO1xuXG4gICAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KHZvaWROb2RlKSAmJiBlZGl0b3IuaXNJbmxpbmUodm9pZE5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCB2b2lkUGF0aCk7XG5cbiAgICAgICAgICAgIGlmICghYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdmFyIGFmdGVyUGF0aCA9IFBhdGgubmV4dCh2b2lkUGF0aCk7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB0ZXh0LCB7XG4gICAgICAgICAgICAgICAgYXQ6IGFmdGVyUGF0aCxcbiAgICAgICAgICAgICAgICB2b2lkc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhZnRlclBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdCA9IGFmdGVyO1xuICAgICAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2libGluZ0hlaWdodCA9IGF0LnBhdGgubGVuZ3RoIC0gdm9pZFBhdGgubGVuZ3RoO1xuICAgICAgICAgIGhlaWdodCA9IHNpYmxpbmdIZWlnaHQgKyAxO1xuICAgICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBhZnRlclJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGF0KTtcbiAgICAgICAgdmFyIGRlcHRoID0gYXQucGF0aC5sZW5ndGggLSBoZWlnaHQ7XG4gICAgICAgIHZhciBbLCBoaWdoZXN0UGF0aF0gPSBoaWdoZXN0O1xuICAgICAgICB2YXIgbG93ZXN0UGF0aCA9IGF0LnBhdGguc2xpY2UoMCwgZGVwdGgpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBoZWlnaHQgPT09IDAgPyBhdC5vZmZzZXQgOiBhdC5wYXRoW2RlcHRoXSArIG51ZGdlO1xuXG4gICAgICAgIGZvciAodmFyIFtub2RlLCBfcGF0aDJdIG9mIEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGxvd2VzdFBhdGgsXG4gICAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKF9wYXRoMi5sZW5ndGggPCBoaWdoZXN0UGF0aC5sZW5ndGggfHwgX3BhdGgyLmxlbmd0aCA9PT0gMCB8fCAhdm9pZHMgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3BvaW50ID0gYmVmb3JlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgdmFyIGlzRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgX3BvaW50LCBfcGF0aDIpO1xuXG4gICAgICAgICAgaWYgKGFsd2F5cyB8fCAhYmVmb3JlUmVmIHx8ICFFZGl0b3IuaXNFZGdlKGVkaXRvciwgX3BvaW50LCBfcGF0aDIpKSB7XG4gICAgICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IE5vZGUuZXh0cmFjdFByb3BzKG5vZGUpO1xuICAgICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgICBwYXRoOiBfcGF0aDIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3NpdGlvbiA9IF9wYXRoMltfcGF0aDIubGVuZ3RoIC0gMV0gKyAoc3BsaXQgfHwgaXNFbmQgPyAxIDogMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9wb2ludDIgPSBhZnRlclJlZi5jdXJyZW50IHx8IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIF9wb2ludDIpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB2YXIgX2FmdGVyUmVmO1xuXG4gICAgICAgIGJlZm9yZVJlZi51bnJlZigpO1xuICAgICAgICAoX2FmdGVyUmVmID0gYWZ0ZXJSZWYpID09PSBudWxsIHx8IF9hZnRlclJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FmdGVyUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVW5zZXQgcHJvcGVydGllcyBvbiB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgdW5zZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgICAgcHJvcHMgPSBbcHJvcHNdO1xuICAgIH1cblxuICAgIHZhciBvYmogPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBvZiBwcm9wcykge1xuICAgICAgb2JqW2tleV0gPSBudWxsO1xuICAgIH1cblxuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCBvYmosIG9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFVud3JhcCB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbiBmcm9tIGEgcGFyZW50IG5vZGUsIHNwbGl0dGluZyB0aGUgcGFyZW50IGlmXHJcbiAgICogbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGNvbnRlbnQgaW4gdGhlIHJhbmdlIGlzIHVud3JhcHBlZC5cclxuICAgKi9cbiAgdW53cmFwTm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICAgIHNwbGl0ID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaFxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhbmdlUmVmID0gUmFuZ2UuaXNSYW5nZShhdCkgPyBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCkgOiBudWxsO1xuICAgICAgdmFyIG1hdGNoZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCBfcmVmNSA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWY1O1xuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0gLy8gdW53cmFwTm9kZSB3aWxsIGNhbGwgbGlmdE5vZGUgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBzcGxpdHRpbmcgdGhlIG5vZGUgd2hlbiBuZXN0ZWQuXG4gICAgICAvLyBJZiB3ZSBkbyBub3QgcmV2ZXJzZSB0aGUgb3JkZXIgYW5kIGNhbGwgaXQgZnJvbSB0b3AgdG8gdGhlIGJvdHRvbSwgaXQgd2lsbCByZW1vdmUgYWxsIGJsb2Nrc1xuICAgICAgLy8gdGhhdCB3cmFwIHRhcmdldCBub2RlLiBTbyB3ZSByZXZlcnNlIHRoZSBvcmRlci5cbiAgICAgICkucmV2ZXJzZSgpO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwYXRoUmVmKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuICAgICAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgaWYgKHNwbGl0ICYmIHJhbmdlUmVmKSB7XG4gICAgICAgICAgcmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2VSZWYuY3VycmVudCwgcmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgVHJhbnNmb3Jtcy5saWZ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNBbmNlc3Rvcihub2RlKSAmJiBub2RlLmNoaWxkcmVuLmluY2x1ZGVzKG4pLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgICBfbG9vcChwYXRoUmVmKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJhbmdlUmVmKSB7XG4gICAgICAgIHJhbmdlUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogV3JhcCB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbiBpbiBhIG5ldyBjb250YWluZXIgbm9kZSwgc3BsaXR0aW5nIHRoZSBlZGdlc1xyXG4gICAqIG9mIHRoZSByYW5nZSBmaXJzdCB0byBlbnN1cmUgdGhhdCBvbmx5IHRoZSBjb250ZW50IGluIHRoZSByYW5nZSBpcyB3cmFwcGVkLlxyXG4gICAqL1xuICB3cmFwTm9kZXMoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICAgIHNwbGl0ID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBtYXRjaFBhdGgoZWRpdG9yLCBhdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBuID0+IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pIHx8IFRleHQuaXNUZXh0KG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGxpdCAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgICB9KTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcmFuZ2VSZWYudW5yZWYoKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJvb3RzID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaDogZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpID8gbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pIDogbiA9PiBFZGl0b3IuaXNFZGl0b3IobiksXG4gICAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgICB2b2lkc1xuICAgICAgfSkpO1xuXG4gICAgICBmb3IgKHZhciBbLCByb290UGF0aF0gb2Ygcm9vdHMpIHtcbiAgICAgICAgdmFyIGEgPSBSYW5nZS5pc1JhbmdlKGF0KSA/IFJhbmdlLmludGVyc2VjdGlvbihhdCwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcm9vdFBhdGgpKSA6IGF0O1xuXG4gICAgICAgIGlmICghYSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdGNoZXMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYSxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pKTtcblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIF9yZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgW2ZpcnN0XSA9IG1hdGNoZXM7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gZmlyc3Q7XG4gICAgICAgICAgICB2YXIgWywgbGFzdFBhdGhdID0gbGFzdDtcblxuICAgICAgICAgICAgaWYgKGZpcnN0UGF0aC5sZW5ndGggPT09IDAgJiYgbGFzdFBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgcGFyZW50IC0gdXN1YWxseSBtZWFucyB0aGUgbm9kZSBpcyBhbiBlZGl0b3IgLSBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguZXF1YWxzKGZpcnN0UGF0aCwgbGFzdFBhdGgpID8gUGF0aC5wYXJlbnQoZmlyc3RQYXRoKSA6IFBhdGguY29tbW9uKGZpcnN0UGF0aCwgbGFzdFBhdGgpO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgZmlyc3RQYXRoLCBsYXN0UGF0aCk7XG4gICAgICAgICAgICB2YXIgY29tbW9uTm9kZUVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBjb21tb25QYXRoKTtcbiAgICAgICAgICAgIHZhciBbY29tbW9uTm9kZV0gPSBjb21tb25Ob2RlRW50cnk7XG4gICAgICAgICAgICB2YXIgZGVwdGggPSBjb21tb25QYXRoLmxlbmd0aCArIDE7XG4gICAgICAgICAgICB2YXIgd3JhcHBlclBhdGggPSBQYXRoLm5leHQobGFzdFBhdGguc2xpY2UoMCwgZGVwdGgpKTtcblxuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBlbGVtZW50KSwge30sIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHdyYXBwZXIsIHtcbiAgICAgICAgICAgICAgYXQ6IHdyYXBwZXJQYXRoLFxuICAgICAgICAgICAgICB2b2lkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzQW5jZXN0b3IoY29tbW9uTm9kZSkgJiYgY29tbW9uTm9kZS5jaGlsZHJlbi5pbmNsdWRlcyhuKSxcbiAgICAgICAgICAgICAgdG86IHdyYXBwZXJQYXRoLmNvbmNhdCgwKSxcbiAgICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGlmIChfcmV0ID09PSBcImNvbnRpbnVlXCIpIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufTtcblxudmFyIGhhc1NpbmdsZUNoaWxkTmVzdCA9IChlZGl0b3IsIG5vZGUpID0+IHtcbiAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuXG4gICAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGhhc1NpbmdsZUNoaWxkTmVzdChlZGl0b3IsIGVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbi8qKlxyXG4gKiBDb252ZXJ0IGEgcmFuZ2UgaW50byBhIHBvaW50IGJ5IGRlbGV0aW5nIGl0J3MgY29udGVudC5cclxuICovXG5cblxudmFyIGRlbGV0ZVJhbmdlID0gKGVkaXRvciwgcmFuZ2UpID0+IHtcbiAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIHJldHVybiByYW5nZS5hbmNob3I7XG4gIH0gZWxzZSB7XG4gICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICAgIHJldHVybiBwb2ludFJlZi51bnJlZigpO1xuICB9XG59O1xuXG52YXIgbWF0Y2hQYXRoID0gKGVkaXRvciwgcGF0aCkgPT4ge1xuICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgcmV0dXJuIG4gPT4gbiA9PT0gbm9kZTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgU2VsZWN0aW9uVHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogQ29sbGFwc2UgdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgY29sbGFwc2UoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBlZGdlID0gJ2FuY2hvcidcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnYW5jaG9yJykge1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yKTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uLmZvY3VzKTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIHZhciBbc3RhcnRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKTtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc3RhcnQpO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKTtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgZW5kKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVW5zZXQgdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgZGVzZWxlY3QoZWRpdG9yKSB7XG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgICAgbmV3UHJvcGVydGllczogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1vdmUgdGhlIHNlbGVjdGlvbidzIHBvaW50IGZvcndhcmQgb3IgYmFja3dhcmQuXHJcbiAgICovXG4gIG1vdmUoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuICAgIHZhciB7XG4gICAgICBkaXN0YW5jZSA9IDEsXG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcicsXG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgZWRnZSA9IG51bGxcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnZm9jdXMnIDogJ2FuY2hvcic7XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2FuY2hvcicgOiAnZm9jdXMnO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICBkaXN0YW5jZSxcbiAgICAgIHVuaXRcbiAgICB9O1xuICAgIHZhciBwcm9wcyA9IHt9O1xuXG4gICAgaWYgKGVkZ2UgPT0gbnVsbCB8fCBlZGdlID09PSAnYW5jaG9yJykge1xuICAgICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhbmNob3IsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgYW5jaG9yLCBvcHRzKTtcblxuICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgIHByb3BzLmFuY2hvciA9IHBvaW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlZGdlID09IG51bGwgfHwgZWRnZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgdmFyIF9wb2ludCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgZm9jdXMsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgZm9jdXMsIG9wdHMpO1xuXG4gICAgICBpZiAoX3BvaW50KSB7XG4gICAgICAgIHByb3BzLmZvY3VzID0gX3BvaW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgc2VsZWN0aW9uIHRvIGEgbmV3IHZhbHVlLlxyXG4gICAqL1xuICBzZWxlY3QoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB0YXJnZXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCB0YXJnZXQpO1xuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB0YXJnZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghUmFuZ2UuaXNSYW5nZSh0YXJnZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIHNldHRpbmcgdGhlIHNlbGVjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGBudWxsYCB5b3UgbXVzdCBwcm92aWRlIGF0IGxlYXN0IGFuIGBhbmNob3JgIGFuZCBgZm9jdXNgLCBidXQgeW91IHBhc3NlZDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeSh0YXJnZXQpKSk7XG4gICAgfVxuXG4gICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgIG5ld1Byb3BlcnRpZXM6IHRhcmdldFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCBuZXcgcHJvcGVydGllcyBvbiBvbmUgb2YgdGhlIHNlbGVjdGlvbidzIHBvaW50cy5cclxuICAgKi9cbiAgc2V0UG9pbnQoZWRpdG9yLCBwcm9wcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIge1xuICAgICAgZWRnZSA9ICdib3RoJ1xuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnYW5jaG9yJyA6ICdmb2N1cyc7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICB2YXIgcG9pbnQgPSBlZGdlID09PSAnYW5jaG9yJyA/IGFuY2hvciA6IGZvY3VzO1xuICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgICAgW2VkZ2UgPT09ICdhbmNob3InID8gJ2FuY2hvcicgOiAnZm9jdXMnXTogX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgcG9pbnQpLCBwcm9wcylcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQgbmV3IHByb3BlcnRpZXMgb24gdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpIHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIgb2xkUHJvcHMgPSB7fTtcbiAgICB2YXIgbmV3UHJvcHMgPSB7fTtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgICAgaWYgKGsgPT09ICdhbmNob3InICYmIHByb3BzLmFuY2hvciAhPSBudWxsICYmICFQb2ludC5lcXVhbHMocHJvcHMuYW5jaG9yLCBzZWxlY3Rpb24uYW5jaG9yKSB8fCBrID09PSAnZm9jdXMnICYmIHByb3BzLmZvY3VzICE9IG51bGwgJiYgIVBvaW50LmVxdWFscyhwcm9wcy5mb2N1cywgc2VsZWN0aW9uLmZvY3VzKSB8fCBrICE9PSAnYW5jaG9yJyAmJiBrICE9PSAnZm9jdXMnICYmIHByb3BzW2tdICE9PSBzZWxlY3Rpb25ba10pIHtcbiAgICAgICAgb2xkUHJvcHNba10gPSBzZWxlY3Rpb25ba107XG4gICAgICAgIG5ld1Byb3BzW2tdID0gcHJvcHNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKG9sZFByb3BzKS5sZW5ndGggPiAwKSB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICAgIHByb3BlcnRpZXM6IG9sZFByb3BzLFxuICAgICAgICBuZXdQcm9wZXJ0aWVzOiBuZXdQcm9wc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBUZXh0VHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogRGVsZXRlIGNvbnRlbnQgaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgZGVsZXRlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgcmV2ZXJzZSA9IGZhbHNlLFxuICAgICAgICB1bml0ID0gJ2NoYXJhY3RlcicsXG4gICAgICAgIGRpc3RhbmNlID0gMSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNDb2xsYXBzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpICYmIFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICBpc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgICAgdmFyIGZ1cnRoZXN0Vm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgIGF0LFxuICAgICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXZvaWRzICYmIGZ1cnRoZXN0Vm9pZCkge1xuICAgICAgICAgIHZhciBbLCB2b2lkUGF0aF0gPSBmdXJ0aGVzdFZvaWQ7XG4gICAgICAgICAgYXQgPSB2b2lkUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIG9wdHMpIHx8IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgICAgIGF0ID0ge1xuICAgICAgICAgICAgYW5jaG9yOiBhdCxcbiAgICAgICAgICAgIGZvY3VzOiB0YXJnZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGhhbmdpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICAgIHZhciBbLCBfZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIGVuZE9mRG9jID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcblxuICAgICAgICBpZiAoIVBvaW50LmVxdWFscyhfZW5kLCBlbmRPZkRvYykpIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICB2YXIgc3RhcnRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgZW5kQmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBpc0Fjcm9zc0Jsb2NrcyA9IHN0YXJ0QmxvY2sgJiYgZW5kQmxvY2sgJiYgIVBhdGguZXF1YWxzKHN0YXJ0QmxvY2tbMV0sIGVuZEJsb2NrWzFdKTtcbiAgICAgIHZhciBpc1NpbmdsZVRleHQgPSBQYXRoLmVxdWFscyhzdGFydC5wYXRoLCBlbmQucGF0aCk7XG4gICAgICB2YXIgc3RhcnRWb2lkID0gdm9pZHMgPyBudWxsIDogRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICB9KTtcbiAgICAgIHZhciBlbmRWb2lkID0gdm9pZHMgPyBudWxsIDogRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgfSk7IC8vIElmIHRoZSBzdGFydCBvciBlbmQgcG9pbnRzIGFyZSBpbnNpZGUgYW4gaW5saW5lIHZvaWQsIG51ZGdlIHRoZW0gb3V0LlxuXG4gICAgICBpZiAoc3RhcnRWb2lkKSB7XG4gICAgICAgIHZhciBiZWZvcmUgPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgc3RhcnQpO1xuXG4gICAgICAgIGlmIChiZWZvcmUgJiYgc3RhcnRCbG9jayAmJiBQYXRoLmlzQW5jZXN0b3Ioc3RhcnRCbG9ja1sxXSwgYmVmb3JlLnBhdGgpKSB7XG4gICAgICAgICAgc3RhcnQgPSBiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFZvaWQpIHtcbiAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgZW5kKTtcblxuICAgICAgICBpZiAoYWZ0ZXIgJiYgZW5kQmxvY2sgJiYgUGF0aC5pc0FuY2VzdG9yKGVuZEJsb2NrWzFdLCBhZnRlci5wYXRoKSkge1xuICAgICAgICAgIGVuZCA9IGFmdGVyO1xuICAgICAgICB9XG4gICAgICB9IC8vIEdldCB0aGUgaGlnaGVzdCBub2RlcyB0aGF0IGFyZSBjb21wbGV0ZWx5IGluc2lkZSB0aGUgcmFuZ2UsIGFzIHdlbGwgYXNcbiAgICAgIC8vIHRoZSBzdGFydCBhbmQgZW5kIG5vZGVzLlxuXG5cbiAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICB2YXIgbGFzdFBhdGg7XG5cbiAgICAgIGZvciAodmFyIGVudHJ5IG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KSkge1xuICAgICAgICB2YXIgW25vZGUsIHBhdGhdID0gZW50cnk7XG5cbiAgICAgICAgaWYgKGxhc3RQYXRoICYmIFBhdGguY29tcGFyZShwYXRoLCBsYXN0UGF0aCkgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpIHx8ICFQYXRoLmlzQ29tbW9uKHBhdGgsIHN0YXJ0LnBhdGgpICYmICFQYXRoLmlzQ29tbW9uKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgbGFzdFBhdGggPSBwYXRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgX3JlZiA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgIHZhciByZW1vdmVkVGV4dCA9ICcnO1xuXG4gICAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiAhc3RhcnRWb2lkKSB7XG4gICAgICAgIHZhciBfcG9pbnQgPSBzdGFydFJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgW19ub2RlXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50KTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aFxuICAgICAgICB9ID0gX3BvaW50O1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG9mZnNldFxuICAgICAgICB9ID0gc3RhcnQ7XG5cbiAgICAgICAgdmFyIHRleHQgPSBfbm9kZS50ZXh0LnNsaWNlKG9mZnNldCk7XG5cbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVtb3ZlZFRleHQgPSB0ZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBhdGhSZWZzLnJldmVyc2UoKS5tYXAociA9PiByLnVucmVmKCkpLmZpbHRlcihyID0+IHIgIT09IG51bGwpLmZvckVhY2gocCA9PiBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdDogcCxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pKTtcblxuICAgICAgaWYgKCFlbmRWb2lkKSB7XG4gICAgICAgIHZhciBfcG9pbnQyID0gZW5kUmVmLmN1cnJlbnQ7XG4gICAgICAgIHZhciBbX25vZGUyXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50Mik7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgyXG4gICAgICAgIH0gPSBfcG9pbnQyO1xuXG4gICAgICAgIHZhciBfb2Zmc2V0ID0gaXNTaW5nbGVUZXh0ID8gc3RhcnQub2Zmc2V0IDogMDtcblxuICAgICAgICB2YXIgX3RleHQgPSBfbm9kZTIudGV4dC5zbGljZShfb2Zmc2V0LCBlbmQub2Zmc2V0KTtcblxuICAgICAgICBpZiAoX3RleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgICAgcGF0aDogX3BhdGgyLFxuICAgICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0LFxuICAgICAgICAgICAgdGV4dDogX3RleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZW1vdmVkVGV4dCA9IF90ZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNTaW5nbGVUZXh0ICYmIGlzQWNyb3NzQmxvY2tzICYmIGVuZFJlZi5jdXJyZW50ICYmIHN0YXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5tZXJnZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmRSZWYuY3VycmVudCxcbiAgICAgICAgICBoYW5naW5nOiB0cnVlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBGb3IgVGhhaSBzY3JpcHQsIGRlbGV0aW5nIE4gY2hhcmFjdGVyKHMpIGJhY2t3YXJkIHNob3VsZCBkZWxldGVcbiAgICAgIC8vIE4gY29kZSBwb2ludChzKSBpbnN0ZWFkIG9mIGFuIGVudGlyZSBncmFwaGVtZSBjbHVzdGVyLlxuICAgICAgLy8gVGhlcmVmb3JlLCB0aGUgcmVtYWluaW5nIGNvZGUgcG9pbnRzIHNob3VsZCBiZSBpbnNlcnRlZCBiYWNrLlxuXG5cbiAgICAgIGlmIChpc0NvbGxhcHNlZCAmJiByZXZlcnNlICYmIHVuaXQgPT09ICdjaGFyYWN0ZXInICYmIHJlbW92ZWRUZXh0Lmxlbmd0aCA+IDEgJiYgcmVtb3ZlZFRleHQubWF0Y2goL1tcXHUwRTAwLVxcdTBFN0ZdKy8pKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0VGV4dChlZGl0b3IsIHJlbW92ZWRUZXh0LnNsaWNlKDAsIHJlbW92ZWRUZXh0Lmxlbmd0aCAtIGRpc3RhbmNlKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydFVucmVmID0gc3RhcnRSZWYudW5yZWYoKTtcbiAgICAgIHZhciBlbmRVbnJlZiA9IGVuZFJlZi51bnJlZigpO1xuICAgICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IHN0YXJ0VW5yZWYgfHwgZW5kVW5yZWYgOiBlbmRVbnJlZiB8fCBzdGFydFVucmVmO1xuXG4gICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsICYmIHBvaW50KSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcG9pbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIGZyYWdtZW50IGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghZnJhZ21lbnQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQsIHtcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG5cbiAgICAgICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGVuZFxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYXQgPSBwb2ludFJlZi51bnJlZigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXRcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gSWYgdGhlIGluc2VydCBwb2ludCBpcyBhdCB0aGUgZWRnZSBvZiBhbiBpbmxpbmUgbm9kZSwgbW92ZSBpdCBvdXRzaWRlXG4gICAgICAvLyBpbnN0ZWFkIHNpbmNlIGl0IHdpbGwgbmVlZCB0byBiZSBzcGxpdCBvdGhlcndpc2UuXG5cblxuICAgICAgdmFyIGlubGluZUVsZW1lbnRNYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlubGluZUVsZW1lbnRNYXRjaCkge1xuICAgICAgICB2YXIgWywgX2lubGluZVBhdGhdID0gaW5saW5lRWxlbWVudE1hdGNoO1xuXG4gICAgICAgIGlmIChFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgX2lubGluZVBhdGgpKSB7XG4gICAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgX2lubGluZVBhdGgpO1xuICAgICAgICAgIGF0ID0gYWZ0ZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgX2lubGluZVBhdGgpKSB7XG4gICAgICAgICAgdmFyIGJlZm9yZSA9IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgICAgYXQgPSBiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGJsb2NrTWF0Y2ggPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIGF0LFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgWywgYmxvY2tQYXRoXSA9IGJsb2NrTWF0Y2g7XG4gICAgICB2YXIgaXNCbG9ja1N0YXJ0ID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgYmxvY2tQYXRoKTtcbiAgICAgIHZhciBpc0Jsb2NrRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIGJsb2NrUGF0aCk7XG4gICAgICB2YXIgaXNCbG9ja0VtcHR5ID0gaXNCbG9ja1N0YXJ0ICYmIGlzQmxvY2tFbmQ7XG4gICAgICB2YXIgbWVyZ2VTdGFydCA9ICFpc0Jsb2NrU3RhcnQgfHwgaXNCbG9ja1N0YXJ0ICYmIGlzQmxvY2tFbmQ7XG4gICAgICB2YXIgbWVyZ2VFbmQgPSAhaXNCbG9ja0VuZDtcbiAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gTm9kZS5maXJzdCh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwgW10pO1xuICAgICAgdmFyIFssIGxhc3RQYXRoXSA9IE5vZGUubGFzdCh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwgW10pO1xuICAgICAgdmFyIG1hdGNoZXMgPSBbXTtcblxuICAgICAgdmFyIG1hdGNoZXIgPSBfcmVmMiA9PiB7XG4gICAgICAgIHZhciBbbiwgcF0gPSBfcmVmMjtcbiAgICAgICAgdmFyIGlzUm9vdCA9IHAubGVuZ3RoID09PSAwO1xuXG4gICAgICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNCbG9ja0VtcHR5KSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVyZ2VTdGFydCAmJiBQYXRoLmlzQW5jZXN0b3IocCwgZmlyc3RQYXRoKSAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiAhZWRpdG9yLmlzVm9pZChuKSAmJiAhZWRpdG9yLmlzSW5saW5lKG4pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lcmdlRW5kICYmIFBhdGguaXNBbmNlc3RvcihwLCBsYXN0UGF0aCkgJiYgRWxlbWVudC5pc0VsZW1lbnQobikgJiYgIWVkaXRvci5pc1ZvaWQobikgJiYgIWVkaXRvci5pc0lubGluZShuKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgZW50cnkgb2YgTm9kZS5ub2Rlcyh7XG4gICAgICAgIGNoaWxkcmVuOiBmcmFnbWVudFxuICAgICAgfSwge1xuICAgICAgICBwYXNzOiBtYXRjaGVyXG4gICAgICB9KSkge1xuICAgICAgICBpZiAobWF0Y2hlcihlbnRyeSkpIHtcbiAgICAgICAgICBtYXRjaGVzLnB1c2goZW50cnkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydHMgPSBbXTtcbiAgICAgIHZhciBtaWRkbGVzID0gW107XG4gICAgICB2YXIgZW5kcyA9IFtdO1xuICAgICAgdmFyIHN0YXJ0aW5nID0gdHJ1ZTtcbiAgICAgIHZhciBoYXNCbG9ja3MgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgW25vZGVdIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmICFlZGl0b3IuaXNJbmxpbmUobm9kZSkpIHtcbiAgICAgICAgICBzdGFydGluZyA9IGZhbHNlO1xuICAgICAgICAgIGhhc0Jsb2NrcyA9IHRydWU7XG4gICAgICAgICAgbWlkZGxlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0aW5nKSB7XG4gICAgICAgICAgc3RhcnRzLnB1c2gobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBbaW5saW5lTWF0Y2hdID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2g6IG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIFssIGlubGluZVBhdGhdID0gaW5saW5lTWF0Y2g7XG4gICAgICB2YXIgaXNJbmxpbmVTdGFydCA9IEVkaXRvci5pc1N0YXJ0KGVkaXRvciwgYXQsIGlubGluZVBhdGgpO1xuICAgICAgdmFyIGlzSW5saW5lRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgYXQsIGlubGluZVBhdGgpO1xuICAgICAgdmFyIG1pZGRsZVJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgaXNCbG9ja0VuZCAmJiAhZW5kcy5sZW5ndGggPyBQYXRoLm5leHQoYmxvY2tQYXRoKSA6IGJsb2NrUGF0aCk7XG4gICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBpc0lubGluZUVuZCA/IFBhdGgubmV4dChpbmxpbmVQYXRoKSA6IGlubGluZVBhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2g6IG4gPT4gaGFzQmxvY2tzID8gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSA6IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiBoYXNCbG9ja3MgPyAnbG93ZXN0JyA6ICdoaWdoZXN0JyxcbiAgICAgICAgYWx3YXlzOiBoYXNCbG9ja3MgJiYgKCFpc0Jsb2NrU3RhcnQgfHwgc3RhcnRzLmxlbmd0aCA+IDApICYmICghaXNCbG9ja0VuZCB8fCBlbmRzLmxlbmd0aCA+IDApLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsICFpc0lubGluZVN0YXJ0IHx8IGlzSW5saW5lU3RhcnQgJiYgaXNJbmxpbmVFbmQgPyBQYXRoLm5leHQoaW5saW5lUGF0aCkgOiBpbmxpbmVQYXRoKTtcbiAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBzdGFydHMsIHtcbiAgICAgICAgYXQ6IHN0YXJ0UmVmLmN1cnJlbnQsXG4gICAgICAgIG1hdGNoOiBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKGlzQmxvY2tFbXB0eSAmJiAhc3RhcnRzLmxlbmd0aCAmJiBtaWRkbGVzLmxlbmd0aCAmJiAhZW5kcy5sZW5ndGgpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGJsb2NrUGF0aCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG1pZGRsZXMsIHtcbiAgICAgICAgYXQ6IG1pZGRsZVJlZi5jdXJyZW50LFxuICAgICAgICBtYXRjaDogbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiAnbG93ZXN0JyxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGVuZHMsIHtcbiAgICAgICAgYXQ6IGVuZFJlZi5jdXJyZW50LFxuICAgICAgICBtYXRjaDogbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghb3B0aW9ucy5hdCkge1xuICAgICAgICB2YXIgcGF0aDtcblxuICAgICAgICBpZiAoZW5kcy5sZW5ndGggPiAwICYmIGVuZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMoZW5kUmVmLmN1cnJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKG1pZGRsZXMubGVuZ3RoID4gMCAmJiBtaWRkbGVSZWYuY3VycmVudCkge1xuICAgICAgICAgIHBhdGggPSBQYXRoLnByZXZpb3VzKG1pZGRsZVJlZi5jdXJyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMoc3RhcnRSZWYuY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIHZhciBfZW5kMiA9IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgX2VuZDIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgICBtaWRkbGVSZWYudW5yZWYoKTtcbiAgICAgIGVuZFJlZi51bnJlZigpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCBhIHN0cmluZyBvZiB0ZXh0IGluIHRoZSBFZGl0b3IuXHJcbiAgICovXG4gIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBlbmQgPSBSYW5nZS5lbmQoYXQpO1xuXG4gICAgICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBlbmRcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdGFydCA9IFJhbmdlLnN0YXJ0KGF0KTtcbiAgICAgICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgICAgICAgdmFyIGVuZFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBzdGFydFJlZi51bnJlZigpO1xuICAgICAgICAgIHZhciBlbmRQb2ludCA9IGVuZFJlZi51bnJlZigpO1xuICAgICAgICAgIGF0ID0gc3RhcnRQb2ludCB8fCBlbmRQb2ludDtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlZGl0b3IsIHtcbiAgICAgICAgICAgIGFuY2hvcjogYXQsXG4gICAgICAgICAgICBmb2N1czogYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdFxuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSBhdDtcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA+IDApIGVkaXRvci5hcHBseSh7XG4gICAgICAgIHR5cGU6ICdpbnNlcnRfdGV4dCcsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgdGV4dFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIFRyYW5zZm9ybXMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBHZW5lcmFsVHJhbnNmb3JtcyksIE5vZGVUcmFuc2Zvcm1zKSwgU2VsZWN0aW9uVHJhbnNmb3JtcyksIFRleHRUcmFuc2Zvcm1zKTtcblxuZXhwb3J0IHsgRWRpdG9yLCBFbGVtZW50LCBMb2NhdGlvbiwgTm9kZSwgT3BlcmF0aW9uLCBQYXRoLCBQYXRoUmVmLCBQb2ludCwgUG9pbnRSZWYsIFJhbmdlLCBSYW5nZVJlZiwgU2NydWJiZXIsIFNwYW4sIFRleHQsIFRyYW5zZm9ybXMsIGNyZWF0ZUVkaXRvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iLCJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnaXMtcGxhaW4tb2JqZWN0JztcbmltcG9ydCB7IE9wZXJhdGlvbiwgRWRpdG9yLCBUcmFuc2Zvcm1zLCBQYXRoIH0gZnJvbSAnc2xhdGUnO1xuXG52YXIgSGlzdG9yeSA9IHtcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGBIaXN0b3J5YCBvYmplY3QuXHJcbiAgICovXG4gIGlzSGlzdG9yeSh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlLnJlZG9zKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlLnVuZG9zKSAmJiAodmFsdWUucmVkb3MubGVuZ3RoID09PSAwIHx8IE9wZXJhdGlvbi5pc09wZXJhdGlvbkxpc3QodmFsdWUucmVkb3NbMF0ub3BlcmF0aW9ucykpICYmICh2YWx1ZS51bmRvcy5sZW5ndGggPT09IDAgfHwgT3BlcmF0aW9uLmlzT3BlcmF0aW9uTGlzdCh2YWx1ZS51bmRvc1swXS5vcGVyYXRpb25zKSk7XG4gIH1cblxufTtcblxuLyoqXHJcbiAqIFdlYWttYXBzIGZvciBhdHRhY2hpbmcgc3RhdGUgdG8gdGhlIGVkaXRvci5cclxuICovXG5cbnZhciBISVNUT1JZID0gbmV3IFdlYWtNYXAoKTtcbnZhciBTQVZJTkcgPSBuZXcgV2Vha01hcCgpO1xudmFyIE1FUkdJTkcgPSBuZXcgV2Vha01hcCgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBIaXN0b3J5RWRpdG9yID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgYEhpc3RvcnlFZGl0b3JgIG9iamVjdC5cclxuICAgKi9cbiAgaXNIaXN0b3J5RWRpdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIEhpc3RvcnkuaXNIaXN0b3J5KHZhbHVlLmhpc3RvcnkpICYmIEVkaXRvci5pc0VkaXRvcih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBtZXJnZSBmbGFnJ3MgY3VycmVudCB2YWx1ZS5cclxuICAgKi9cbiAgaXNNZXJnaW5nKGVkaXRvcikge1xuICAgIHJldHVybiBNRVJHSU5HLmdldChlZGl0b3IpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2F2aW5nIGZsYWcncyBjdXJyZW50IHZhbHVlLlxyXG4gICAqL1xuICBpc1NhdmluZyhlZGl0b3IpIHtcbiAgICByZXR1cm4gU0FWSU5HLmdldChlZGl0b3IpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJlZG8gdG8gdGhlIHByZXZpb3VzIHNhdmVkIHN0YXRlLlxyXG4gICAqL1xuICByZWRvKGVkaXRvcikge1xuICAgIGVkaXRvci5yZWRvKCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVW5kbyB0byB0aGUgcHJldmlvdXMgc2F2ZWQgc3RhdGUuXHJcbiAgICovXG4gIHVuZG8oZWRpdG9yKSB7XG4gICAgZWRpdG9yLnVuZG8oKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBBcHBseSBhIHNlcmllcyBvZiBjaGFuZ2VzIGluc2lkZSBhIHN5bmNocm9ub3VzIGBmbmAsIHdpdGhvdXQgbWVyZ2luZyBhbnkgb2ZcclxuICAgKiB0aGUgbmV3IG9wZXJhdGlvbnMgaW50byBwcmV2aW91cyBzYXZlIHBvaW50IGluIHRoZSBoaXN0b3J5LlxyXG4gICAqL1xuICB3aXRob3V0TWVyZ2luZyhlZGl0b3IsIGZuKSB7XG4gICAgdmFyIHByZXYgPSBIaXN0b3J5RWRpdG9yLmlzTWVyZ2luZyhlZGl0b3IpO1xuICAgIE1FUkdJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgIGZuKCk7XG4gICAgTUVSR0lORy5zZXQoZWRpdG9yLCBwcmV2KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBBcHBseSBhIHNlcmllcyBvZiBjaGFuZ2VzIGluc2lkZSBhIHN5bmNocm9ub3VzIGBmbmAsIHdpdGhvdXQgc2F2aW5nIGFueSBvZlxyXG4gICAqIHRoZWlyIG9wZXJhdGlvbnMgaW50byB0aGUgaGlzdG9yeS5cclxuICAgKi9cbiAgd2l0aG91dFNhdmluZyhlZGl0b3IsIGZuKSB7XG4gICAgdmFyIHByZXYgPSBIaXN0b3J5RWRpdG9yLmlzU2F2aW5nKGVkaXRvcik7XG4gICAgU0FWSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICBmbigpO1xuICAgIFNBVklORy5zZXQoZWRpdG9yLCBwcmV2KTtcbiAgfVxuXG59O1xuXG4vKipcclxuICogVGhlIGB3aXRoSGlzdG9yeWAgcGx1Z2luIGtlZXBzIHRyYWNrIG9mIHRoZSBvcGVyYXRpb24gaGlzdG9yeSBvZiBhIFNsYXRlXHJcbiAqIGVkaXRvciBhcyBvcGVyYXRpb25zIGFyZSBhcHBsaWVkIHRvIGl0LCB1c2luZyB1bmRvIGFuZCByZWRvIHN0YWNrcy5cclxuICpcclxuICogSWYgeW91IGFyZSB1c2luZyBUeXBlU2NyaXB0LCB5b3UgbXVzdCBleHRlbmQgU2xhdGUncyBDdXN0b21UeXBlcyB0byB1c2VcclxuICogdGhpcyBwbHVnaW4uXHJcbiAqXHJcbiAqIFNlZSBodHRwczovL2RvY3Muc2xhdGVqcy5vcmcvY29uY2VwdHMvMTEtdHlwZXNjcmlwdCB0byBsZWFybiBob3cuXHJcbiAqL1xuXG52YXIgd2l0aEhpc3RvcnkgPSBlZGl0b3IgPT4ge1xuICB2YXIgZSA9IGVkaXRvcjtcbiAgdmFyIHtcbiAgICBhcHBseVxuICB9ID0gZTtcbiAgZS5oaXN0b3J5ID0ge1xuICAgIHVuZG9zOiBbXSxcbiAgICByZWRvczogW11cbiAgfTtcblxuICBlLnJlZG8gPSAoKSA9PiB7XG4gICAgdmFyIHtcbiAgICAgIGhpc3RvcnlcbiAgICB9ID0gZTtcbiAgICB2YXIge1xuICAgICAgcmVkb3NcbiAgICB9ID0gaGlzdG9yeTtcblxuICAgIGlmIChyZWRvcy5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgYmF0Y2ggPSByZWRvc1tyZWRvcy5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKGJhdGNoLnNlbGVjdGlvbkJlZm9yZSkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlLCBiYXRjaC5zZWxlY3Rpb25CZWZvcmUpO1xuICAgICAgfVxuXG4gICAgICBIaXN0b3J5RWRpdG9yLndpdGhvdXRTYXZpbmcoZSwgKCkgPT4ge1xuICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGUsICgpID0+IHtcbiAgICAgICAgICBmb3IgKHZhciBvcCBvZiBiYXRjaC5vcGVyYXRpb25zKSB7XG4gICAgICAgICAgICBlLmFwcGx5KG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBoaXN0b3J5LnJlZG9zLnBvcCgpO1xuICAgICAgaGlzdG9yeS51bmRvcy5wdXNoKGJhdGNoKTtcbiAgICB9XG4gIH07XG5cbiAgZS51bmRvID0gKCkgPT4ge1xuICAgIHZhciB7XG4gICAgICBoaXN0b3J5XG4gICAgfSA9IGU7XG4gICAgdmFyIHtcbiAgICAgIHVuZG9zXG4gICAgfSA9IGhpc3Rvcnk7XG5cbiAgICBpZiAodW5kb3MubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGJhdGNoID0gdW5kb3NbdW5kb3MubGVuZ3RoIC0gMV07XG4gICAgICBIaXN0b3J5RWRpdG9yLndpdGhvdXRTYXZpbmcoZSwgKCkgPT4ge1xuICAgICAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGUsICgpID0+IHtcbiAgICAgICAgICB2YXIgaW52ZXJzZU9wcyA9IGJhdGNoLm9wZXJhdGlvbnMubWFwKE9wZXJhdGlvbi5pbnZlcnNlKS5yZXZlcnNlKCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBvcCBvZiBpbnZlcnNlT3BzKSB7XG4gICAgICAgICAgICBlLmFwcGx5KG9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYmF0Y2guc2VsZWN0aW9uQmVmb3JlKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNldFNlbGVjdGlvbihlLCBiYXRjaC5zZWxlY3Rpb25CZWZvcmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGhpc3RvcnkucmVkb3MucHVzaChiYXRjaCk7XG4gICAgICBoaXN0b3J5LnVuZG9zLnBvcCgpO1xuICAgIH1cbiAgfTtcblxuICBlLmFwcGx5ID0gb3AgPT4ge1xuICAgIHZhciB7XG4gICAgICBvcGVyYXRpb25zLFxuICAgICAgaGlzdG9yeVxuICAgIH0gPSBlO1xuICAgIHZhciB7XG4gICAgICB1bmRvc1xuICAgIH0gPSBoaXN0b3J5O1xuICAgIHZhciBsYXN0QmF0Y2ggPSB1bmRvc1t1bmRvcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgbGFzdE9wID0gbGFzdEJhdGNoICYmIGxhc3RCYXRjaC5vcGVyYXRpb25zW2xhc3RCYXRjaC5vcGVyYXRpb25zLmxlbmd0aCAtIDFdO1xuICAgIHZhciBzYXZlID0gSGlzdG9yeUVkaXRvci5pc1NhdmluZyhlKTtcbiAgICB2YXIgbWVyZ2UgPSBIaXN0b3J5RWRpdG9yLmlzTWVyZ2luZyhlKTtcblxuICAgIGlmIChzYXZlID09IG51bGwpIHtcbiAgICAgIHNhdmUgPSBzaG91bGRTYXZlKG9wKTtcbiAgICB9XG5cbiAgICBpZiAoc2F2ZSkge1xuICAgICAgaWYgKG1lcmdlID09IG51bGwpIHtcbiAgICAgICAgaWYgKGxhc3RCYXRjaCA9PSBudWxsKSB7XG4gICAgICAgICAgbWVyZ2UgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb25zLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIG1lcmdlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXJnZSA9IHNob3VsZE1lcmdlKG9wLCBsYXN0T3ApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChsYXN0QmF0Y2ggJiYgbWVyZ2UpIHtcbiAgICAgICAgbGFzdEJhdGNoLm9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYmF0Y2ggPSB7XG4gICAgICAgICAgb3BlcmF0aW9uczogW29wXSxcbiAgICAgICAgICBzZWxlY3Rpb25CZWZvcmU6IGUuc2VsZWN0aW9uXG4gICAgICAgIH07XG4gICAgICAgIHVuZG9zLnB1c2goYmF0Y2gpO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAodW5kb3MubGVuZ3RoID4gMTAwKSB7XG4gICAgICAgIHVuZG9zLnNoaWZ0KCk7XG4gICAgICB9XG5cbiAgICAgIGhpc3RvcnkucmVkb3MgPSBbXTtcbiAgICB9XG5cbiAgICBhcHBseShvcCk7XG4gIH07XG5cbiAgcmV0dXJuIGU7XG59O1xuLyoqXHJcbiAqIENoZWNrIHdoZXRoZXIgdG8gbWVyZ2UgYW4gb3BlcmF0aW9uIGludG8gdGhlIHByZXZpb3VzIG9wZXJhdGlvbi5cclxuICovXG5cbnZhciBzaG91bGRNZXJnZSA9IChvcCwgcHJldikgPT4ge1xuICBpZiAocHJldiAmJiBvcC50eXBlID09PSAnaW5zZXJ0X3RleHQnICYmIHByZXYudHlwZSA9PT0gJ2luc2VydF90ZXh0JyAmJiBvcC5vZmZzZXQgPT09IHByZXYub2Zmc2V0ICsgcHJldi50ZXh0Lmxlbmd0aCAmJiBQYXRoLmVxdWFscyhvcC5wYXRoLCBwcmV2LnBhdGgpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAocHJldiAmJiBvcC50eXBlID09PSAncmVtb3ZlX3RleHQnICYmIHByZXYudHlwZSA9PT0gJ3JlbW92ZV90ZXh0JyAmJiBvcC5vZmZzZXQgKyBvcC50ZXh0Lmxlbmd0aCA9PT0gcHJldi5vZmZzZXQgJiYgUGF0aC5lcXVhbHMob3AucGF0aCwgcHJldi5wYXRoKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIGFuIG9wZXJhdGlvbiBuZWVkcyB0byBiZSBzYXZlZCB0byB0aGUgaGlzdG9yeS5cclxuICovXG5cblxudmFyIHNob3VsZFNhdmUgPSAob3AsIHByZXYpID0+IHtcbiAgaWYgKG9wLnR5cGUgPT09ICdzZXRfc2VsZWN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0IHsgSElTVE9SWSwgSGlzdG9yeSwgSGlzdG9yeUVkaXRvciwgTUVSR0lORywgU0FWSU5HLCB3aXRoSGlzdG9yeSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iLCJmdW5jdGlvbiB0KHQpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT10JiYxPT09dC5ub2RlVHlwZX1mdW5jdGlvbiBlKHQsZSl7cmV0dXJuKCFlfHxcImhpZGRlblwiIT09dCkmJlwidmlzaWJsZVwiIT09dCYmXCJjbGlwXCIhPT10fWZ1bmN0aW9uIG4odCxuKXtpZih0LmNsaWVudEhlaWdodDx0LnNjcm9sbEhlaWdodHx8dC5jbGllbnRXaWR0aDx0LnNjcm9sbFdpZHRoKXt2YXIgcj1nZXRDb21wdXRlZFN0eWxlKHQsbnVsbCk7cmV0dXJuIGUoci5vdmVyZmxvd1ksbil8fGUoci5vdmVyZmxvd1gsbil8fGZ1bmN0aW9uKHQpe3ZhciBlPWZ1bmN0aW9uKHQpe2lmKCF0Lm93bmVyRG9jdW1lbnR8fCF0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpcmV0dXJuIG51bGw7dHJ5e3JldHVybiB0Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZnJhbWVFbGVtZW50fWNhdGNoKHQpe3JldHVybiBudWxsfX0odCk7cmV0dXJuISFlJiYoZS5jbGllbnRIZWlnaHQ8dC5zY3JvbGxIZWlnaHR8fGUuY2xpZW50V2lkdGg8dC5zY3JvbGxXaWR0aCl9KHQpfXJldHVybiExfWZ1bmN0aW9uIHIodCxlLG4scixpLG8sbCxkKXtyZXR1cm4gbzx0JiZsPmV8fG8+dCYmbDxlPzA6bzw9dCYmZDw9bnx8bD49ZSYmZD49bj9vLXQtcjpsPmUmJmQ8bnx8bzx0JiZkPm4/bC1lK2k6MH12YXIgaT1mdW5jdGlvbihlLGkpe3ZhciBvPXdpbmRvdyxsPWkuc2Nyb2xsTW9kZSxkPWkuYmxvY2ssZj1pLmlubGluZSxoPWkuYm91bmRhcnksdT1pLnNraXBPdmVyZmxvd0hpZGRlbkVsZW1lbnRzLHM9XCJmdW5jdGlvblwiPT10eXBlb2YgaD9oOmZ1bmN0aW9uKHQpe3JldHVybiB0IT09aH07aWYoIXQoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdGFyZ2V0XCIpO2Zvcih2YXIgYSxjLGc9ZG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudHx8ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LHA9W10sbT1lO3QobSkmJnMobSk7KXtpZigobT1udWxsPT0oYz0oYT1tKS5wYXJlbnRFbGVtZW50KT9hLmdldFJvb3ROb2RlKCkuaG9zdHx8bnVsbDpjKT09PWcpe3AucHVzaChtKTticmVha31udWxsIT1tJiZtPT09ZG9jdW1lbnQuYm9keSYmbihtKSYmIW4oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KXx8bnVsbCE9bSYmbihtLHUpJiZwLnB1c2gobSl9Zm9yKHZhciB3PW8udmlzdWFsVmlld3BvcnQ/by52aXN1YWxWaWV3cG9ydC53aWR0aDppbm5lcldpZHRoLHY9by52aXN1YWxWaWV3cG9ydD9vLnZpc3VhbFZpZXdwb3J0LmhlaWdodDppbm5lckhlaWdodCxXPXdpbmRvdy5zY3JvbGxYfHxwYWdlWE9mZnNldCxIPXdpbmRvdy5zY3JvbGxZfHxwYWdlWU9mZnNldCxiPWUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkseT1iLmhlaWdodCxFPWIud2lkdGgsTT1iLnRvcCxWPWIucmlnaHQseD1iLmJvdHRvbSxJPWIubGVmdCxDPVwic3RhcnRcIj09PWR8fFwibmVhcmVzdFwiPT09ZD9NOlwiZW5kXCI9PT1kP3g6TSt5LzIsUj1cImNlbnRlclwiPT09Zj9JK0UvMjpcImVuZFwiPT09Zj9WOkksVD1bXSxrPTA7azxwLmxlbmd0aDtrKyspe3ZhciBCPXBba10sRD1CLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLE89RC5oZWlnaHQsWD1ELndpZHRoLFk9RC50b3AsTD1ELnJpZ2h0LFM9RC5ib3R0b20saj1ELmxlZnQ7aWYoXCJpZi1uZWVkZWRcIj09PWwmJk0+PTAmJkk+PTAmJng8PXYmJlY8PXcmJk0+PVkmJng8PVMmJkk+PWomJlY8PUwpcmV0dXJuIFQ7dmFyIE49Z2V0Q29tcHV0ZWRTdHlsZShCKSxxPXBhcnNlSW50KE4uYm9yZGVyTGVmdFdpZHRoLDEwKSx6PXBhcnNlSW50KE4uYm9yZGVyVG9wV2lkdGgsMTApLEE9cGFyc2VJbnQoTi5ib3JkZXJSaWdodFdpZHRoLDEwKSxGPXBhcnNlSW50KE4uYm9yZGVyQm90dG9tV2lkdGgsMTApLEc9MCxKPTAsSz1cIm9mZnNldFdpZHRoXCJpbiBCP0Iub2Zmc2V0V2lkdGgtQi5jbGllbnRXaWR0aC1xLUE6MCxQPVwib2Zmc2V0SGVpZ2h0XCJpbiBCP0Iub2Zmc2V0SGVpZ2h0LUIuY2xpZW50SGVpZ2h0LXotRjowLFE9XCJvZmZzZXRXaWR0aFwiaW4gQj8wPT09Qi5vZmZzZXRXaWR0aD8wOlgvQi5vZmZzZXRXaWR0aDowLFU9XCJvZmZzZXRIZWlnaHRcImluIEI/MD09PUIub2Zmc2V0SGVpZ2h0PzA6Ty9CLm9mZnNldEhlaWdodDowO2lmKGc9PT1CKUc9XCJzdGFydFwiPT09ZD9DOlwiZW5kXCI9PT1kP0MtdjpcIm5lYXJlc3RcIj09PWQ/cihILEgrdix2LHosRixIK0MsSCtDK3kseSk6Qy12LzIsSj1cInN0YXJ0XCI9PT1mP1I6XCJjZW50ZXJcIj09PWY/Ui13LzI6XCJlbmRcIj09PWY/Ui13OnIoVyxXK3csdyxxLEEsVytSLFcrUitFLEUpLEc9TWF0aC5tYXgoMCxHK0gpLEo9TWF0aC5tYXgoMCxKK1cpO2Vsc2V7Rz1cInN0YXJ0XCI9PT1kP0MtWS16OlwiZW5kXCI9PT1kP0MtUytGK1A6XCJuZWFyZXN0XCI9PT1kP3IoWSxTLE8seixGK1AsQyxDK3kseSk6Qy0oWStPLzIpK1AvMixKPVwic3RhcnRcIj09PWY/Ui1qLXE6XCJjZW50ZXJcIj09PWY/Ui0oaitYLzIpK0svMjpcImVuZFwiPT09Zj9SLUwrQStLOnIoaixMLFgscSxBK0ssUixSK0UsRSk7dmFyIFo9Qi5zY3JvbGxMZWZ0LCQ9Qi5zY3JvbGxUb3A7Qys9JC0oRz1NYXRoLm1heCgwLE1hdGgubWluKCQrRy9VLEIuc2Nyb2xsSGVpZ2h0LU8vVStQKSkpLFIrPVotKEo9TWF0aC5tYXgoMCxNYXRoLm1pbihaK0ovUSxCLnNjcm9sbFdpZHRoLVgvUStLKSkpfVQucHVzaCh7ZWw6Qix0b3A6RyxsZWZ0Okp9KX1yZXR1cm4gVH07ZXhwb3J0e2kgYXMgZGVmYXVsdH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iLCJpbXBvcnQgY29tcHV0ZSBmcm9tICdjb21wdXRlLXNjcm9sbC1pbnRvLXZpZXcnO1xuZnVuY3Rpb24gaXNPcHRpb25zT2JqZWN0KG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgPT09IE9iamVjdChvcHRpb25zKSAmJiBPYmplY3Qua2V5cyhvcHRpb25zKS5sZW5ndGggIT09IDA7XG59XG5mdW5jdGlvbiBkZWZhdWx0QmVoYXZpb3IoYWN0aW9ucywgYmVoYXZpb3IpIHtcbiAgaWYgKGJlaGF2aW9yID09PSB2b2lkIDApIHtcbiAgICBiZWhhdmlvciA9ICdhdXRvJztcbiAgfVxuICB2YXIgY2FuU21vb3RoU2Nyb2xsID0gKCdzY3JvbGxCZWhhdmlvcicgaW4gZG9jdW1lbnQuYm9keS5zdHlsZSk7XG4gIGFjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBlbCA9IF9yZWYuZWwsXG4gICAgICB0b3AgPSBfcmVmLnRvcCxcbiAgICAgIGxlZnQgPSBfcmVmLmxlZnQ7XG4gICAgaWYgKGVsLnNjcm9sbCAmJiBjYW5TbW9vdGhTY3JvbGwpIHtcbiAgICAgIGVsLnNjcm9sbCh7XG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICBiZWhhdmlvcjogYmVoYXZpb3JcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zY3JvbGxUb3AgPSB0b3A7XG4gICAgICBlbC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgIHJldHVybiB7XG4gICAgICBibG9jazogJ2VuZCcsXG4gICAgICBpbmxpbmU6ICduZWFyZXN0J1xuICAgIH07XG4gIH1cbiAgaWYgKGlzT3B0aW9uc09iamVjdChvcHRpb25zKSkge1xuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIHJldHVybiB7XG4gICAgYmxvY2s6ICdzdGFydCcsXG4gICAgaW5saW5lOiAnbmVhcmVzdCdcbiAgfTtcbn1cbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KHRhcmdldCwgb3B0aW9ucykge1xuICB2YXIgaXNUYXJnZXRBdHRhY2hlZCA9IHRhcmdldC5pc0Nvbm5lY3RlZCB8fCB0YXJnZXQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGFyZ2V0KTtcbiAgaWYgKGlzT3B0aW9uc09iamVjdChvcHRpb25zKSAmJiB0eXBlb2Ygb3B0aW9ucy5iZWhhdmlvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBvcHRpb25zLmJlaGF2aW9yKGlzVGFyZ2V0QXR0YWNoZWQgPyBjb21wdXRlKHRhcmdldCwgb3B0aW9ucykgOiBbXSk7XG4gIH1cbiAgaWYgKCFpc1RhcmdldEF0dGFjaGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBjb21wdXRlT3B0aW9ucyA9IGdldE9wdGlvbnMob3B0aW9ucyk7XG4gIHJldHVybiBkZWZhdWx0QmVoYXZpb3IoY29tcHV0ZSh0YXJnZXQsIGNvbXB1dGVPcHRpb25zKSwgY29tcHV0ZU9wdGlvbnMuYmVoYXZpb3IpO1xufVxuZXhwb3J0IGRlZmF1bHQgc2Nyb2xsSW50b1ZpZXc7IiwiaW1wb3J0IGdldERpcmVjdGlvbiBmcm9tICdkaXJlY3Rpb24nO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC9kZWJvdW5jZSc7XG5pbXBvcnQgdGhyb3R0bGUgZnJvbSAnbG9kYXNoL3Rocm90dGxlJztcbmltcG9ydCBSZWFjdCwgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCwgdXNlUmVmLCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VDYWxsYmFjaywgQ29tcG9uZW50LCB1c2VTdGF0ZSwgdXNlUmVkdWNlciwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBzY3JvbGxJbnRvVmlldyBmcm9tICdzY3JvbGwtaW50by12aWV3LWlmLW5lZWRlZCc7XG5pbXBvcnQgeyBFZGl0b3IsIFNjcnViYmVyLCBUcmFuc2Zvcm1zLCBSYW5nZSwgUGF0aCwgTm9kZSwgVGV4dCBhcyBUZXh0JDEsIEVsZW1lbnQgYXMgRWxlbWVudCQxLCBQb2ludCB9IGZyb20gJ3NsYXRlJztcbmltcG9ydCB7IGlzS2V5SG90a2V5IH0gZnJvbSAnaXMtaG90a2V5JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxyXG4gKiBBbiBhdXRvLWluY3JlbWVudGluZyBpZGVudGlmaWVyIGZvciBrZXlzLlxyXG4gKi9cbnZhciBuID0gMDtcbi8qKlxyXG4gKiBBIGNsYXNzIHRoYXQga2VlcHMgdHJhY2sgb2YgYSBrZXkgc3RyaW5nLiBXZSB1c2UgYSBmdWxsIGNsYXNzIGhlcmUgYmVjYXVzZSB3ZVxyXG4gKiB3YW50IHRvIGJlIGFibGUgdG8gdXNlIHRoZW0gYXMga2V5cyBpbiBgV2Vha01hcGAgb2JqZWN0cy5cclxuICovXG5cbmNsYXNzIEtleSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaWQgPSBcIlwiLmNvbmNhdChuKyspO1xuICB9XG5cbn1cblxuLyoqXHJcbiAqIFR3byB3ZWFrIG1hcHMgdGhhdCBhbGxvdyB1cyByZWJ1aWxkIGEgcGF0aCBnaXZlbiBhIG5vZGUuIFRoZXkgYXJlIHBvcHVsYXRlZFxyXG4gKiBhdCByZW5kZXIgdGltZSBzdWNoIHRoYXQgYWZ0ZXIgYSByZW5kZXIgb2NjdXJzIHdlIGNhbiBhbHdheXMgYmFja3RyYWNrLlxyXG4gKi9cbnZhciBOT0RFX1RPX0lOREVYID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX1BBUkVOVCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogV2VhayBtYXBzIHRoYXQgYWxsb3cgdXMgdG8gZ28gYmV0d2VlbiBTbGF0ZSBub2RlcyBhbmQgRE9NIG5vZGVzLiBUaGVzZVxyXG4gKiBhcmUgdXNlZCB0byByZXNvbHZlIERPTSBldmVudC1yZWxhdGVkIGxvZ2ljIGludG8gU2xhdGUgYWN0aW9ucy5cclxuICovXG5cbnZhciBFRElUT1JfVE9fV0lORE9XID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVMRU1FTlRfVE9fTk9ERSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgTk9ERV9UT19FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT0RFX1RPX0tFWSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX0tFWV9UT19FTEVNRU5UID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fU1RZTEVfRUxFTUVOVCA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogV2VhayBtYXBzIGZvciBzdG9yaW5nIGVkaXRvci1yZWxhdGVkIHN0YXRlLlxyXG4gKi9cblxudmFyIElTX1JFQURfT05MWSA9IG5ldyBXZWFrTWFwKCk7XG52YXIgSVNfRk9DVVNFRCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgSVNfQ09NUE9TSU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04gPSBuZXcgV2Vha01hcCgpO1xuLyoqXHJcbiAqIFdlYWsgbWFwIGZvciBhc3NvY2lhdGluZyB0aGUgY29udGV4dCBgb25DaGFuZ2VgIGNvbnRleHQgd2l0aCB0aGUgcGx1Z2luLlxyXG4gKi9cblxudmFyIEVESVRPUl9UT19PTl9DSEFOR0UgPSBuZXcgV2Vha01hcCgpO1xuLyoqXHJcbiAqIFdlYWsgbWFwcyBmb3Igc2F2aW5nIHBlbmRpbmcgc3RhdGUgb24gY29tcG9zaXRpb24gc3RhZ2UuXHJcbiAqL1xuXG52YXIgRURJVE9SX1RPX1NDSEVEVUxFX0ZMVVNIID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MgPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19VU0VSX01BUktTID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxyXG4gKiBBbmRyb2lkIGlucHV0IGhhbmRsaW5nIHNwZWNpZmljIHdlYWstbWFwc1xyXG4gKi9cblxudmFyIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBFRElUT1JfVE9fUEVORElOR19BQ1RJT04gPSBuZXcgV2Vha01hcCgpO1xudmFyIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTiA9IG5ldyBXZWFrTWFwKCk7XG52YXIgRURJVE9SX1RPX0ZPUkNFX1JFTkRFUiA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogU3ltYm9scy5cclxuICovXG5cbnZhciBQTEFDRUhPTERFUl9TWU1CT0wgPSBTeW1ib2woJ3BsYWNlaG9sZGVyJyk7XG52YXIgTUFSS19QTEFDRUhPTERFUl9TWU1CT0wgPSBTeW1ib2woJ21hcmstcGxhY2Vob2xkZXInKTtcblxuLyoqXHJcbiAqIFR5cGVzLlxyXG4gKi9cbnZhciBET01UZXh0ID0gZ2xvYmFsVGhpcy5UZXh0O1xuLyoqXHJcbiAqIFJldHVybnMgdGhlIGhvc3Qgd2luZG93IG9mIGEgRE9NIG5vZGVcclxuICovXG5cbnZhciBnZXREZWZhdWx0VmlldyA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLm93bmVyRG9jdW1lbnQgJiYgdmFsdWUub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCBudWxsO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIERPTSBub2RlIGlzIGEgY29tbWVudCBub2RlLlxyXG4gKi9cblxudmFyIGlzRE9NQ29tbWVudCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDg7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYW4gZWxlbWVudCBub2RlLlxyXG4gKi9cblxudmFyIGlzRE9NRWxlbWVudCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDE7XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBET00gbm9kZS5cclxuICovXG5cbnZhciBpc0RPTU5vZGUgPSB2YWx1ZSA9PiB7XG4gIHZhciB3aW5kb3cgPSBnZXREZWZhdWx0Vmlldyh2YWx1ZSk7XG4gIHJldHVybiAhIXdpbmRvdyAmJiB2YWx1ZSBpbnN0YW5jZW9mIHdpbmRvdy5Ob2RlO1xufTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgRE9NIHNlbGVjdGlvbi5cclxuICovXG5cbnZhciBpc0RPTVNlbGVjdGlvbiA9IHZhbHVlID0+IHtcbiAgdmFyIHdpbmRvdyA9IHZhbHVlICYmIHZhbHVlLmFuY2hvck5vZGUgJiYgZ2V0RGVmYXVsdFZpZXcodmFsdWUuYW5jaG9yTm9kZSk7XG4gIHJldHVybiAhIXdpbmRvdyAmJiB2YWx1ZSBpbnN0YW5jZW9mIHdpbmRvdy5TZWxlY3Rpb247XG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGEgRE9NIG5vZGUgaXMgYW4gZWxlbWVudCBub2RlLlxyXG4gKi9cblxudmFyIGlzRE9NVGV4dCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIGlzRE9NTm9kZSh2YWx1ZSkgJiYgdmFsdWUubm9kZVR5cGUgPT09IDM7XG59O1xuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIGEgcGFzdGUgZXZlbnQgaXMgYSBwbGFpbnRleHQtb25seSBldmVudC5cclxuICovXG5cbnZhciBpc1BsYWluVGV4dE9ubHlQYXN0ZSA9IGV2ZW50ID0+IHtcbiAgcmV0dXJuIGV2ZW50LmNsaXBib2FyZERhdGEgJiYgZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJykgIT09ICcnICYmIGV2ZW50LmNsaXBib2FyZERhdGEudHlwZXMubGVuZ3RoID09PSAxO1xufTtcbi8qKlxyXG4gKiBOb3JtYWxpemUgYSBET00gcG9pbnQgc28gdGhhdCBpdCBhbHdheXMgcmVmZXJzIHRvIGEgdGV4dCBub2RlLlxyXG4gKi9cblxudmFyIG5vcm1hbGl6ZURPTVBvaW50ID0gZG9tUG9pbnQgPT4ge1xuICB2YXIgW25vZGUsIG9mZnNldF0gPSBkb21Qb2ludDsgLy8gSWYgaXQncyBhbiBlbGVtZW50IG5vZGUsIGl0cyBvZmZzZXQgcmVmZXJzIHRvIHRoZSBpbmRleCBvZiBpdHMgY2hpbGRyZW5cbiAgLy8gaW5jbHVkaW5nIGNvbW1lbnQgbm9kZXMsIHNvIHRyeSB0byBmaW5kIHRoZSByaWdodCB0ZXh0IGNoaWxkIG5vZGUuXG5cbiAgaWYgKGlzRE9NRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgdmFyIGlzTGFzdCA9IG9mZnNldCA9PT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSBpc0xhc3QgPyBvZmZzZXQgLSAxIDogb2Zmc2V0O1xuICAgIFtub2RlLCBpbmRleF0gPSBnZXRFZGl0YWJsZUNoaWxkQW5kSW5kZXgobm9kZSwgaW5kZXgsIGlzTGFzdCA/ICdiYWNrd2FyZCcgOiAnZm9yd2FyZCcpOyAvLyBJZiB0aGUgZWRpdGFibGUgY2hpbGQgZm91bmQgaXMgaW4gZnJvbnQgb2YgaW5wdXQgb2Zmc2V0LCB3ZSBpbnN0ZWFkIHNlZWsgdG8gaXRzIGVuZFxuXG4gICAgaXNMYXN0ID0gaW5kZXggPCBvZmZzZXQ7IC8vIElmIHRoZSBub2RlIGhhcyBjaGlsZHJlbiwgdHJhdmVyc2UgdW50aWwgd2UgaGF2ZSBhIGxlYWYgbm9kZS4gTGVhZiBub2Rlc1xuICAgIC8vIGNhbiBiZSBlaXRoZXIgdGV4dCBub2Rlcywgb3Igb3RoZXIgdm9pZCBET00gbm9kZXMuXG5cbiAgICB3aGlsZSAoaXNET01FbGVtZW50KG5vZGUpICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIHZhciBpID0gaXNMYXN0ID8gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEgOiAwO1xuICAgICAgbm9kZSA9IGdldEVkaXRhYmxlQ2hpbGQobm9kZSwgaSwgaXNMYXN0ID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJyk7XG4gICAgfSAvLyBEZXRlcm1pbmUgdGhlIG5ldyBvZmZzZXQgaW5zaWRlIHRoZSB0ZXh0IG5vZGUuXG5cblxuICAgIG9mZnNldCA9IGlzTGFzdCAmJiBub2RlLnRleHRDb250ZW50ICE9IG51bGwgPyBub2RlLnRleHRDb250ZW50Lmxlbmd0aCA6IDA7XG4gIH0gLy8gUmV0dXJuIHRoZSBub2RlIGFuZCBvZmZzZXQuXG5cblxuICByZXR1cm4gW25vZGUsIG9mZnNldF07XG59O1xuLyoqXHJcbiAqIERldGVybWluZXMgd2V0aGVyIHRoZSBhY3RpdmUgZWxlbWVudCBpcyBuZXN0ZWQgd2l0aGluIGEgc2hhZG93Um9vdFxyXG4gKi9cblxudmFyIGhhc1NoYWRvd1Jvb3QgPSAoKSA9PiB7XG4gIHJldHVybiAhISh3aW5kb3cuZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KTtcbn07XG4vKipcclxuICogR2V0IHRoZSBuZWFyZXN0IGVkaXRhYmxlIGNoaWxkIGFuZCBpbmRleCBhdCBgaW5kZXhgIGluIGEgYHBhcmVudGAsIHByZWZlcnJpbmdcclxuICogYGRpcmVjdGlvbmAuXHJcbiAqL1xuXG52YXIgZ2V0RWRpdGFibGVDaGlsZEFuZEluZGV4ID0gKHBhcmVudCwgaW5kZXgsIGRpcmVjdGlvbikgPT4ge1xuICB2YXIge1xuICAgIGNoaWxkTm9kZXNcbiAgfSA9IHBhcmVudDtcbiAgdmFyIGNoaWxkID0gY2hpbGROb2Rlc1tpbmRleF07XG4gIHZhciBpID0gaW5kZXg7XG4gIHZhciB0cmllZEZvcndhcmQgPSBmYWxzZTtcbiAgdmFyIHRyaWVkQmFja3dhcmQgPSBmYWxzZTsgLy8gV2hpbGUgdGhlIGNoaWxkIGlzIGEgY29tbWVudCBub2RlLCBvciBhbiBlbGVtZW50IG5vZGUgd2l0aCBubyBjaGlsZHJlbixcbiAgLy8ga2VlcCBpdGVyYXRpbmcgdG8gZmluZCBhIHNpYmxpbmcgbm9uLXZvaWQsIG5vbi1jb21tZW50IG5vZGUuXG5cbiAgd2hpbGUgKGlzRE9NQ29tbWVudChjaGlsZCkgfHwgaXNET01FbGVtZW50KGNoaWxkKSAmJiBjaGlsZC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMCB8fCBpc0RPTUVsZW1lbnQoY2hpbGQpICYmIGNoaWxkLmdldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykgPT09ICdmYWxzZScpIHtcbiAgICBpZiAodHJpZWRGb3J3YXJkICYmIHRyaWVkQmFja3dhcmQpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChpID49IGNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICB0cmllZEZvcndhcmQgPSB0cnVlO1xuICAgICAgaSA9IGluZGV4IC0gMTtcbiAgICAgIGRpcmVjdGlvbiA9ICdiYWNrd2FyZCc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoaSA8IDApIHtcbiAgICAgIHRyaWVkQmFja3dhcmQgPSB0cnVlO1xuICAgICAgaSA9IGluZGV4ICsgMTtcbiAgICAgIGRpcmVjdGlvbiA9ICdmb3J3YXJkJztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGROb2Rlc1tpXTtcbiAgICBpbmRleCA9IGk7XG4gICAgaSArPSBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJyA/IDEgOiAtMTtcbiAgfVxuXG4gIHJldHVybiBbY2hpbGQsIGluZGV4XTtcbn07XG4vKipcclxuICogR2V0IHRoZSBuZWFyZXN0IGVkaXRhYmxlIGNoaWxkIGF0IGBpbmRleGAgaW4gYSBgcGFyZW50YCwgcHJlZmVycmluZ1xyXG4gKiBgZGlyZWN0aW9uYC5cclxuICovXG5cbnZhciBnZXRFZGl0YWJsZUNoaWxkID0gKHBhcmVudCwgaW5kZXgsIGRpcmVjdGlvbikgPT4ge1xuICB2YXIgW2NoaWxkXSA9IGdldEVkaXRhYmxlQ2hpbGRBbmRJbmRleChwYXJlbnQsIGluZGV4LCBkaXJlY3Rpb24pO1xuICByZXR1cm4gY2hpbGQ7XG59O1xuLyoqXHJcbiAqIEdldCBhIHBsYWludGV4dCByZXByZXNlbnRhdGlvbiBvZiB0aGUgY29udGVudCBvZiBhIG5vZGUsIGFjY291bnRpbmcgZm9yIGJsb2NrXHJcbiAqIGVsZW1lbnRzIHdoaWNoIGdldCBhIG5ld2xpbmUgYXBwZW5kZWQuXHJcbiAqXHJcbiAqIFRoZSBkb21Ob2RlIG11c3QgYmUgYXR0YWNoZWQgdG8gdGhlIERPTS5cclxuICovXG5cbnZhciBnZXRQbGFpblRleHQgPSBkb21Ob2RlID0+IHtcbiAgdmFyIHRleHQgPSAnJztcblxuICBpZiAoaXNET01UZXh0KGRvbU5vZGUpICYmIGRvbU5vZGUubm9kZVZhbHVlKSB7XG4gICAgcmV0dXJuIGRvbU5vZGUubm9kZVZhbHVlO1xuICB9XG5cbiAgaWYgKGlzRE9NRWxlbWVudChkb21Ob2RlKSkge1xuICAgIGZvciAodmFyIGNoaWxkTm9kZSBvZiBBcnJheS5mcm9tKGRvbU5vZGUuY2hpbGROb2RlcykpIHtcbiAgICAgIHRleHQgKz0gZ2V0UGxhaW5UZXh0KGNoaWxkTm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGRpc3BsYXkgPSBnZXRDb21wdXRlZFN0eWxlKGRvbU5vZGUpLmdldFByb3BlcnR5VmFsdWUoJ2Rpc3BsYXknKTtcblxuICAgIGlmIChkaXNwbGF5ID09PSAnYmxvY2snIHx8IGRpc3BsYXkgPT09ICdsaXN0JyB8fCBkb21Ob2RlLnRhZ05hbWUgPT09ICdCUicpIHtcbiAgICAgIHRleHQgKz0gJ1xcbic7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRleHQ7XG59O1xuLyoqXHJcbiAqIEdldCB4LXNsYXRlLWZyYWdtZW50IGF0dHJpYnV0ZSBmcm9tIGRhdGEtc2xhdGUtZnJhZ21lbnRcclxuICovXG5cbnZhciBjYXRjaFNsYXRlRnJhZ21lbnQgPSAvZGF0YS1zbGF0ZS1mcmFnbWVudD1cIiguKz8pXCIvbTtcbnZhciBnZXRTbGF0ZUZyYWdtZW50QXR0cmlidXRlID0gZGF0YVRyYW5zZmVyID0+IHtcbiAgdmFyIGh0bWxEYXRhID0gZGF0YVRyYW5zZmVyLmdldERhdGEoJ3RleHQvaHRtbCcpO1xuICB2YXIgWywgZnJhZ21lbnRdID0gaHRtbERhdGEubWF0Y2goY2F0Y2hTbGF0ZUZyYWdtZW50KSB8fCBbXTtcbiAgcmV0dXJuIGZyYWdtZW50O1xufTtcbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIGEgbXV0YXRpb24gb3JpZ2luYXRlcyBmcm9tIGEgZWRpdGFibGUgZWxlbWVudCBpbnNpZGUgdGhlIGVkaXRvci5cclxuICovXG5cbnZhciBpc1RyYWNrZWRNdXRhdGlvbiA9IChlZGl0b3IsIG11dGF0aW9uLCBiYXRjaCkgPT4ge1xuICB2YXIge1xuICAgIHRhcmdldFxuICB9ID0gbXV0YXRpb247XG5cbiAgaWYgKGlzRE9NRWxlbWVudCh0YXJnZXQpICYmIHRhcmdldC5tYXRjaGVzKCdbY29udGVudEVkaXRhYmxlPVwiZmFsc2VcIl0nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB7XG4gICAgZG9jdW1lbnRcbiAgfSA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuXG4gIGlmIChkb2N1bWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgcmV0dXJuIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCB0YXJnZXQsIHtcbiAgICAgIGVkaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICB2YXIgcGFyZW50TXV0YXRpb24gPSBiYXRjaC5maW5kKF9yZWYgPT4ge1xuICAgIHZhciB7XG4gICAgICBhZGRlZE5vZGVzLFxuICAgICAgcmVtb3ZlZE5vZGVzXG4gICAgfSA9IF9yZWY7XG5cbiAgICBmb3IgKHZhciBub2RlIG9mIGFkZGVkTm9kZXMpIHtcbiAgICAgIGlmIChub2RlID09PSB0YXJnZXQgfHwgbm9kZS5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9ub2RlIG9mIHJlbW92ZWROb2Rlcykge1xuICAgICAgaWYgKF9ub2RlID09PSB0YXJnZXQgfHwgX25vZGUuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIGlmICghcGFyZW50TXV0YXRpb24gfHwgcGFyZW50TXV0YXRpb24gPT09IG11dGF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRhcmdldCBhZGQvcmVtb3ZlIGlzIHRyYWNrZWQuIFRyYWNrIHRoZSBtdXRhdGlvbiBpZiB3ZSB0cmFjayB0aGUgcGFyZW50IG11dGF0aW9uLlxuXG5cbiAgcmV0dXJuIGlzVHJhY2tlZE11dGF0aW9uKGVkaXRvciwgcGFyZW50TXV0YXRpb24sIGJhdGNoKTtcbn07XG5cbnZhciBJU19SRUFDVF9WRVJTSU9OXzE3X09SX0FCT1ZFID0gcGFyc2VJbnQoUmVhY3QudmVyc2lvbi5zcGxpdCgnLicpWzBdLCAxMCkgPj0gMTc7XG52YXIgSVNfSU9TID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbTtcbnZhciBJU19BUFBMRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9NYWMgT1MgWC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19BTkRST0lEID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0FuZHJvaWQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG52YXIgSVNfRklSRUZPWCA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9eKD8hLipTZWFtb25rZXkpKD89LipGaXJlZm94KS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbnZhciBJU19TQUZBUkkgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvVmVyc2lvblxcL1tcXGRcXC5dKy4qU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBcIm1vZGVyblwiIEVkZ2Ugd2FzIHJlbGVhc2VkIGF0IDc5LnhcblxudmFyIElTX0VER0VfTEVHQUNZID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL0VkZ2U/XFwvKD86WzAtNl1bMC05XXxbMC03XVswLThdKSg/OlxcLikvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xudmFyIElTX0NIUk9NRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9DaHJvbWUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpOyAvLyBOYXRpdmUgYGJlZm9yZUlucHV0YCBldmVudHMgZG9uJ3Qgd29yayB3ZWxsIHdpdGggcmVhY3Qgb24gQ2hyb21lIDc1XG4vLyBhbmQgb2xkZXIsIENocm9tZSA3NisgY2FuIHVzZSBgYmVmb3JlSW5wdXRgIHRob3VnaC5cblxudmFyIElTX0NIUk9NRV9MRUdBQ1kgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvQ2hyb21lP1xcLyg/OlswLTddWzAtNV18WzAtNl1bMC05XSkoPzpcXC4pL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gRmlyZWZveCBkaWQgbm90IHN1cHBvcnQgYGJlZm9yZUlucHV0YCB1bnRpbCBgdjg3YC5cblxudmFyIElTX0ZJUkVGT1hfTEVHQUNZID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3hcXC8oPzpbMC03XVswLTldfFswLThdWzAtNl0pKD86XFwuKSkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIHFxIGJyb3dzZXJcblxudmFyIElTX1FRQlJPV1NFUiA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC8uKlFRQnJvd3Nlci8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gVUMgbW9iaWxlIGJyb3dzZXJcblxudmFyIElTX1VDX01PQklMRSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC8uKlVDQnJvd3Nlci8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTsgLy8gV2VjaGF0IGJyb3dzZXJcblxudmFyIElTX1dFQ0hBVEJST1dTRVIgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvLipXZWNoYXQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7IC8vIENoZWNrIGlmIERPTSBpcyBhdmFpbGFibGUgYXMgUmVhY3QgZG9lcyBpbnRlcm5hbGx5LlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3NoYXJlZC9FeGVjdXRpb25FbnZpcm9ubWVudC5qc1xuXG52YXIgQ0FOX1VTRV9ET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnKTsgLy8gQ09NUEFUOiBGaXJlZm94L0VkZ2UgTGVnYWN5IGRvbid0IHN1cHBvcnQgdGhlIGBiZWZvcmVpbnB1dGAgZXZlbnRcbi8vIENocm9tZSBMZWdhY3kgZG9lc24ndCBzdXBwb3J0IGBiZWZvcmVpbnB1dGAgY29ycmVjdGx5XG5cbnZhciBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgPSAhSVNfQ0hST01FX0xFR0FDWSAmJiAhSVNfRURHRV9MRUdBQ1kgJiYgLy8gZ2xvYmFsVGhpcyBpcyB1bmRlZmluZWQgaW4gb2xkZXIgYnJvd3NlcnNcbnR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzLklucHV0RXZlbnQgJiYgLy8gQHRzLWlnbm9yZSBUaGUgYGdldFRhcmdldFJhbmdlc2AgcHJvcGVydHkgaXNuJ3QgcmVjb2duaXplZC5cbnR5cGVvZiBnbG9iYWxUaGlzLklucHV0RXZlbnQucHJvdG90eXBlLmdldFRhcmdldFJhbmdlcyA9PT0gJ2Z1bmN0aW9uJztcblxudmFyIFJlYWN0RWRpdG9yID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgdXNlciBpcyBjdXJyZW50bHkgY29tcG9zaW5nIGluc2lkZSB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBpc0NvbXBvc2luZyhlZGl0b3IpIHtcbiAgICByZXR1cm4gISFJU19DT01QT1NJTkcuZ2V0KGVkaXRvcik7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBob3N0IHdpbmRvdyBvZiB0aGUgY3VycmVudCBlZGl0b3IuXHJcbiAgICovXG4gIGdldFdpbmRvdyhlZGl0b3IpIHtcbiAgICB2YXIgd2luZG93ID0gRURJVE9SX1RPX1dJTkRPVy5nZXQoZWRpdG9yKTtcblxuICAgIGlmICghd2luZG93KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGEgaG9zdCB3aW5kb3cgZWxlbWVudCBmb3IgdGhpcyBlZGl0b3InKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd2luZG93O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZpbmQgYSBrZXkgZm9yIGEgU2xhdGUgbm9kZS5cclxuICAgKi9cbiAgZmluZEtleShlZGl0b3IsIG5vZGUpIHtcbiAgICB2YXIga2V5ID0gTk9ERV9UT19LRVkuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIGtleSA9IG5ldyBLZXkoKTtcbiAgICAgIE5PREVfVE9fS0VZLnNldChub2RlLCBrZXkpO1xuICAgIH1cblxuICAgIHJldHVybiBrZXk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRmluZCB0aGUgcGF0aCBvZiBTbGF0ZSBub2RlLlxyXG4gICAqL1xuICBmaW5kUGF0aChlZGl0b3IsIG5vZGUpIHtcbiAgICB2YXIgcGF0aCA9IFtdO1xuICAgIHZhciBjaGlsZCA9IG5vZGU7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgdmFyIHBhcmVudCA9IE5PREVfVE9fUEFSRU5ULmdldChjaGlsZCk7XG5cbiAgICAgIGlmIChwYXJlbnQgPT0gbnVsbCkge1xuICAgICAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKGNoaWxkKSkge1xuICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpID0gTk9ERV9UT19JTkRFWC5nZXQoY2hpbGQpO1xuXG4gICAgICBpZiAoaSA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBwYXRoLnVuc2hpZnQoaSk7XG4gICAgICBjaGlsZCA9IHBhcmVudDtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCB0aGUgcGF0aCBmb3IgU2xhdGUgbm9kZTogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShub2RlKSkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZpbmQgdGhlIERPTSBub2RlIHRoYXQgaW1wbGVtZW50cyBEb2N1bWVudE9yU2hhZG93Um9vdCBmb3IgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcikge1xuICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHJvb3QgPSBlbC5nZXRSb290Tm9kZSgpO1xuXG4gICAgaWYgKChyb290IGluc3RhbmNlb2YgRG9jdW1lbnQgfHwgcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpICYmIHJvb3QuZ2V0U2VsZWN0aW9uICE9IG51bGwpIHtcbiAgICAgIHJldHVybiByb290O1xuICAgIH1cblxuICAgIHJldHVybiBlbC5vd25lckRvY3VtZW50O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBlZGl0b3IgaXMgZm9jdXNlZC5cclxuICAgKi9cbiAgaXNGb2N1c2VkKGVkaXRvcikge1xuICAgIHJldHVybiAhIUlTX0ZPQ1VTRUQuZ2V0KGVkaXRvcik7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGVkaXRvciBpcyBpbiByZWFkLW9ubHkgbW9kZS5cclxuICAgKi9cbiAgaXNSZWFkT25seShlZGl0b3IpIHtcbiAgICByZXR1cm4gISFJU19SRUFEX09OTFkuZ2V0KGVkaXRvcik7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQmx1ciB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBibHVyKGVkaXRvcikge1xuICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICBJU19GT0NVU0VELnNldChlZGl0b3IsIGZhbHNlKTtcblxuICAgIGlmIChyb290LmFjdGl2ZUVsZW1lbnQgPT09IGVsKSB7XG4gICAgICBlbC5ibHVyKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZvY3VzIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGZvY3VzKGVkaXRvcikge1xuICAgIHZhciBlbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHJvb3QgPSBSZWFjdEVkaXRvci5maW5kRG9jdW1lbnRPclNoYWRvd1Jvb3QoZWRpdG9yKTtcbiAgICBJU19GT0NVU0VELnNldChlZGl0b3IsIHRydWUpO1xuXG4gICAgaWYgKHJvb3QuYWN0aXZlRWxlbWVudCAhPT0gZWwpIHtcbiAgICAgIGVsLmZvY3VzKHtcbiAgICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIERlc2VsZWN0IHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGRlc2VsZWN0KGVkaXRvcikge1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuICAgIHZhciByb290ID0gUmVhY3RFZGl0b3IuZmluZERvY3VtZW50T3JTaGFkb3dSb290KGVkaXRvcik7XG4gICAgdmFyIGRvbVNlbGVjdGlvbiA9IHJvb3QuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoZG9tU2VsZWN0aW9uICYmIGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgIH1cblxuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIFRyYW5zZm9ybXMuZGVzZWxlY3QoZWRpdG9yKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBET00gbm9kZSBpcyB3aXRoaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgaGFzRE9NTm9kZShlZGl0b3IsIHRhcmdldCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZWRpdGFibGUgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBlZGl0b3JFbCA9IFJlYWN0RWRpdG9yLnRvRE9NTm9kZShlZGl0b3IsIGVkaXRvcik7XG4gICAgdmFyIHRhcmdldEVsOyAvLyBDT01QQVQ6IEluIEZpcmVmb3gsIHJlYWRpbmcgYHRhcmdldC5ub2RlVHlwZWAgd2lsbCB0aHJvdyBhbiBlcnJvciBpZlxuICAgIC8vIHRhcmdldCBpcyBvcmlnaW5hdGluZyBmcm9tIGFuIGludGVybmFsIFwicmVzdHJpY3RlZFwiIGVsZW1lbnQgKGUuZy4gYVxuICAgIC8vIHN0ZXBwZXIgYXJyb3cgb24gYSBudW1iZXIgaW5wdXQpLiAoMjAxOC8wNS8wNClcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvaXNzdWVzLzE4MTlcblxuICAgIHRyeSB7XG4gICAgICB0YXJnZXRFbCA9IGlzRE9NRWxlbWVudCh0YXJnZXQpID8gdGFyZ2V0IDogdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWVyci5tZXNzYWdlLmluY2x1ZGVzKCdQZXJtaXNzaW9uIGRlbmllZCB0byBhY2Nlc3MgcHJvcGVydHkgXCJub2RlVHlwZVwiJykpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGFyZ2V0RWwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0RWwuY2xvc2VzdChcIltkYXRhLXNsYXRlLWVkaXRvcl1cIikgPT09IGVkaXRvckVsICYmICghZWRpdGFibGUgfHwgdGFyZ2V0RWwuaXNDb250ZW50RWRpdGFibGUgPyB0cnVlIDogdHlwZW9mIHRhcmdldEVsLmlzQ29udGVudEVkaXRhYmxlID09PSAnYm9vbGVhbicgJiYgLy8gaXNDb250ZW50RWRpdGFibGUgZXhpc3RzIG9ubHkgb24gSFRNTEVsZW1lbnQsIGFuZCBvbiBvdGhlciBub2RlcyBpdCB3aWxsIGJlIHVuZGVmaW5lZFxuICAgIC8vIHRoaXMgaXMgdGhlIGNvcmUgbG9naWMgdGhhdCBsZXRzIHlvdSBrbm93IHlvdSBnb3QgdGhlIHJpZ2h0IGVkaXRvci5zZWxlY3Rpb24gaW5zdGVhZCBvZiBudWxsIHdoZW4gZWRpdG9yIGlzIGNvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCIocmVhZE9ubHkpXG4gICAgdGFyZ2V0RWwuY2xvc2VzdCgnW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdJykgPT09IGVkaXRvckVsIHx8ICEhdGFyZ2V0RWwuZ2V0QXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGRhdGEgZnJvbSBhIGBEYXRhVHJhbnNmZXJgIGludG8gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0RGF0YShlZGl0b3IsIGRhdGEpIHtcbiAgICBlZGl0b3IuaW5zZXJ0RGF0YShkYXRhKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgZnJhZ21lbnQgZGF0YSBmcm9tIGEgYERhdGFUcmFuc2ZlcmAgaW50byB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBpbnNlcnRGcmFnbWVudERhdGEoZWRpdG9yLCBkYXRhKSB7XG4gICAgcmV0dXJuIGVkaXRvci5pbnNlcnRGcmFnbWVudERhdGEoZGF0YSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IHRleHQgZGF0YSBmcm9tIGEgYERhdGFUcmFuc2ZlcmAgaW50byB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBpbnNlcnRUZXh0RGF0YShlZGl0b3IsIGRhdGEpIHtcbiAgICByZXR1cm4gZWRpdG9yLmluc2VydFRleHREYXRhKGRhdGEpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldHMgZGF0YSBmcm9tIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZnJhZ21lbnQgb24gYSBgRGF0YVRyYW5zZmVyYC5cclxuICAgKi9cbiAgc2V0RnJhZ21lbnREYXRhKGVkaXRvciwgZGF0YSwgb3JpZ2luRXZlbnQpIHtcbiAgICBlZGl0b3Iuc2V0RnJhZ21lbnREYXRhKGRhdGEsIG9yaWdpbkV2ZW50KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBGaW5kIHRoZSBuYXRpdmUgRE9NIGVsZW1lbnQgZnJvbSBhIFNsYXRlIG5vZGUuXHJcbiAgICovXG4gIHRvRE9NTm9kZShlZGl0b3IsIG5vZGUpIHtcbiAgICB2YXIgS0VZX1RPX0VMRU1FTlQgPSBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG4gICAgdmFyIGRvbU5vZGUgPSBFZGl0b3IuaXNFZGl0b3Iobm9kZSkgPyBFRElUT1JfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKSA6IEtFWV9UT19FTEVNRU5UID09PSBudWxsIHx8IEtFWV9UT19FTEVNRU5UID09PSB2b2lkIDAgPyB2b2lkIDAgOiBLRVlfVE9fRUxFTUVOVC5nZXQoUmVhY3RFZGl0b3IuZmluZEtleShlZGl0b3IsIG5vZGUpKTtcblxuICAgIGlmICghZG9tTm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBET00gbm9kZSBmcm9tIFNsYXRlIG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9tTm9kZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBGaW5kIGEgbmF0aXZlIERPTSBzZWxlY3Rpb24gcG9pbnQgZnJvbSBhIFNsYXRlIHBvaW50LlxyXG4gICAqL1xuICB0b0RPTVBvaW50KGVkaXRvciwgcG9pbnQpIHtcbiAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwb2ludC5wYXRoKTtcbiAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBub2RlKTtcbiAgICB2YXIgZG9tUG9pbnQ7IC8vIElmIHdlJ3JlIGluc2lkZSBhIHZvaWQgbm9kZSwgZm9yY2UgdGhlIG9mZnNldCB0byAwLCBvdGhlcndpc2UgdGhlIHplcm9cbiAgICAvLyB3aWR0aCBzcGFjaW5nIGNoYXJhY3RlciB3aWxsIHJlc3VsdCBpbiBhbiBpbmNvcnJlY3Qgb2Zmc2V0IG9mIDFcblxuICAgIGlmIChFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgIGF0OiBwb2ludFxuICAgIH0pKSB7XG4gICAgICBwb2ludCA9IHtcbiAgICAgICAgcGF0aDogcG9pbnQucGF0aCxcbiAgICAgICAgb2Zmc2V0OiAwXG4gICAgICB9O1xuICAgIH0gLy8gRm9yIGVhY2ggbGVhZiwgd2UgbmVlZCB0byBpc29sYXRlIGl0cyBjb250ZW50LCB3aGljaCBtZWFucyBmaWx0ZXJpbmdcbiAgICAvLyB0byBpdHMgZGlyZWN0IHRleHQgYW5kIHplcm8td2lkdGggc3BhbnMuIChXZSBoYXZlIHRvIGZpbHRlciBvdXQgYW55XG4gICAgLy8gb3RoZXIgc2libGluZ3MgdGhhdCBtYXkgaGF2ZSBiZWVuIHJlbmRlcmVkIGFsb25nc2lkZSB0aGVtLilcblxuXG4gICAgdmFyIHNlbGVjdG9yID0gXCJbZGF0YS1zbGF0ZS1zdHJpbmddLCBbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXVwiO1xuICAgIHZhciB0ZXh0cyA9IEFycmF5LmZyb20oZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgIHZhciBzdGFydCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdGV4dCA9IHRleHRzW2ldO1xuICAgICAgdmFyIGRvbU5vZGUgPSB0ZXh0LmNoaWxkTm9kZXNbMF07XG5cbiAgICAgIGlmIChkb21Ob2RlID09IG51bGwgfHwgZG9tTm9kZS50ZXh0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0gPSBkb21Ob2RlLnRleHRDb250ZW50O1xuICAgICAgdmFyIGF0dHIgPSB0ZXh0LmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1sZW5ndGgnKTtcbiAgICAgIHZhciB0cnVlTGVuZ3RoID0gYXR0ciA9PSBudWxsID8gbGVuZ3RoIDogcGFyc2VJbnQoYXR0ciwgMTApO1xuICAgICAgdmFyIGVuZCA9IHN0YXJ0ICsgdHJ1ZUxlbmd0aDsgLy8gUHJlZmVyIHB1dHRpbmcgdGhlIHNlbGVjdGlvbiBpbnNpZGUgdGhlIG1hcmsgcGxhY2Vob2xkZXIgdG8gZW5zdXJlXG4gICAgICAvLyBjb21wb3NlZCB0ZXh0IGlzIGRpc3BsYXllZCB3aXRoIHRoZSBjb3JyZWN0IG1hcmtzLlxuXG4gICAgICB2YXIgbmV4dFRleHQgPSB0ZXh0c1tpICsgMV07XG5cbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPT09IGVuZCAmJiBuZXh0VGV4dCAhPT0gbnVsbCAmJiBuZXh0VGV4dCAhPT0gdm9pZCAwICYmIG5leHRUZXh0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1tYXJrLXBsYWNlaG9sZGVyJykpIHtcbiAgICAgICAgdmFyIF9uZXh0VGV4dCR0ZXh0Q29udGVudDtcblxuICAgICAgICB2YXIgZG9tVGV4dCA9IG5leHRUZXh0LmNoaWxkTm9kZXNbMF07XG4gICAgICAgIGRvbVBvaW50ID0gWy8vIENPTVBBVDogSWYgd2UgZG9uJ3QgZXhwbGljaXR5IHNldCB0aGUgZG9tIHBvaW50IHRvIGJlIG9uIHRoZSBhY3R1YWxcbiAgICAgICAgLy8gZG9tIHRleHQgZWxlbWVudCwgY2hyb21lIHdpbGwgcHV0IHRoZSBzZWxlY3Rpb24gYmVoaW5kIHRoZSBhY3R1YWwgZG9tXG4gICAgICAgIC8vIHRleHQgZWxlbWVudCwgY2F1c2luZyBkb21SYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSBjYWxscyBvbiBhIGNvbGxhcHNlZFxuICAgICAgICAvLyBzZWxlY3Rpb24gdG8gcmV0dXJuIGluY29ycmVjdCB6ZXJvIHZhbHVlcyAoaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDM1NDM4KVxuICAgICAgICAvLyB3aGljaCB3aWxsIGNhdXNlIGlzc3VlcyB3aGVuIHNjcm9sbGluZyB0byBpdC5cbiAgICAgICAgZG9tVGV4dCBpbnN0YW5jZW9mIERPTVRleHQgPyBkb21UZXh0IDogbmV4dFRleHQsIChfbmV4dFRleHQkdGV4dENvbnRlbnQgPSBuZXh0VGV4dC50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgX25leHRUZXh0JHRleHRDb250ZW50ICE9PSB2b2lkIDAgJiYgX25leHRUZXh0JHRleHRDb250ZW50LnN0YXJ0c1dpdGgoJ1xcdUZFRkYnKSA/IDEgOiAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb2ludC5vZmZzZXQgPD0gZW5kKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBNYXRoLm1pbihsZW5ndGgsIE1hdGgubWF4KDAsIHBvaW50Lm9mZnNldCAtIHN0YXJ0KSk7XG4gICAgICAgIGRvbVBvaW50ID0gW2RvbU5vZGUsIG9mZnNldF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzdGFydCA9IGVuZDtcbiAgICB9XG5cbiAgICBpZiAoIWRvbVBvaW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIERPTSBwb2ludCBmcm9tIFNsYXRlIHBvaW50OiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHBvaW50KSkpO1xuICAgIH1cblxuICAgIHJldHVybiBkb21Qb2ludDtcbiAgfSxcblxuICAvKipcclxuICAgKiBGaW5kIGEgbmF0aXZlIERPTSByYW5nZSBmcm9tIGEgU2xhdGUgYHJhbmdlYC5cclxuICAgKlxyXG4gICAqIE5vdGljZTogdGhlIHJldHVybmVkIHJhbmdlIHdpbGwgYWx3YXlzIGJlIG9yZGluYWwgcmVnYXJkbGVzcyBvZiB0aGUgZGlyZWN0aW9uIG9mIFNsYXRlIGByYW5nZWAgZHVlIHRvIERPTSBBUEkgbGltaXQuXHJcbiAgICpcclxuICAgKiB0aGVyZSBpcyBubyB3YXkgdG8gY3JlYXRlIGEgcmV2ZXJzZSBET00gUmFuZ2UgdXNpbmcgUmFuZ2Uuc2V0U3RhcnQvc2V0RW5kXHJcbiAgICogYWNjb3JkaW5nIHRvIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1yYW5nZS1icC1zZXQuXHJcbiAgICovXG4gIHRvRE9NUmFuZ2UoZWRpdG9yLCByYW5nZSkge1xuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSByYW5nZTtcbiAgICB2YXIgaXNCYWNrd2FyZCA9IFJhbmdlLmlzQmFja3dhcmQocmFuZ2UpO1xuICAgIHZhciBkb21BbmNob3IgPSBSZWFjdEVkaXRvci50b0RPTVBvaW50KGVkaXRvciwgYW5jaG9yKTtcbiAgICB2YXIgZG9tRm9jdXMgPSBSYW5nZS5pc0NvbGxhcHNlZChyYW5nZSkgPyBkb21BbmNob3IgOiBSZWFjdEVkaXRvci50b0RPTVBvaW50KGVkaXRvciwgZm9jdXMpO1xuICAgIHZhciB3aW5kb3cgPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICB2YXIgZG9tUmFuZ2UgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICB2YXIgW3N0YXJ0Tm9kZSwgc3RhcnRPZmZzZXRdID0gaXNCYWNrd2FyZCA/IGRvbUZvY3VzIDogZG9tQW5jaG9yO1xuICAgIHZhciBbZW5kTm9kZSwgZW5kT2Zmc2V0XSA9IGlzQmFja3dhcmQgPyBkb21BbmNob3IgOiBkb21Gb2N1czsgLy8gQSBzbGF0ZSBQb2ludCBhdCB6ZXJvLXdpZHRoIExlYWYgYWx3YXlzIGhhcyBhbiBvZmZzZXQgb2YgMCBidXQgYSBuYXRpdmUgRE9NIHNlbGVjdGlvbiBhdFxuICAgIC8vIHplcm8td2lkdGggbm9kZSBoYXMgYW4gb2Zmc2V0IG9mIDEgc28gd2UgaGF2ZSB0byBjaGVjayBpZiB3ZSBhcmUgaW4gYSB6ZXJvLXdpZHRoIG5vZGUgYW5kXG4gICAgLy8gYWRqdXN0IHRoZSBvZmZzZXQgYWNjb3JkaW5nbHkuXG5cbiAgICB2YXIgc3RhcnRFbCA9IGlzRE9NRWxlbWVudChzdGFydE5vZGUpID8gc3RhcnROb2RlIDogc3RhcnROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgdmFyIGlzU3RhcnRBdFplcm9XaWR0aCA9ICEhc3RhcnRFbC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpO1xuICAgIHZhciBlbmRFbCA9IGlzRE9NRWxlbWVudChlbmROb2RlKSA/IGVuZE5vZGUgOiBlbmROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgdmFyIGlzRW5kQXRaZXJvV2lkdGggPSAhIWVuZEVsLmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJyk7XG4gICAgZG9tUmFuZ2Uuc2V0U3RhcnQoc3RhcnROb2RlLCBpc1N0YXJ0QXRaZXJvV2lkdGggPyAxIDogc3RhcnRPZmZzZXQpO1xuICAgIGRvbVJhbmdlLnNldEVuZChlbmROb2RlLCBpc0VuZEF0WmVyb1dpZHRoID8gMSA6IGVuZE9mZnNldCk7XG4gICAgcmV0dXJuIGRvbVJhbmdlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEZpbmQgYSBTbGF0ZSBub2RlIGZyb20gYSBuYXRpdmUgRE9NIGBlbGVtZW50YC5cclxuICAgKi9cbiAgdG9TbGF0ZU5vZGUoZWRpdG9yLCBkb21Ob2RlKSB7XG4gICAgdmFyIGRvbUVsID0gaXNET01FbGVtZW50KGRvbU5vZGUpID8gZG9tTm9kZSA6IGRvbU5vZGUucGFyZW50RWxlbWVudDtcblxuICAgIGlmIChkb21FbCAmJiAhZG9tRWwuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLW5vZGUnKSkge1xuICAgICAgZG9tRWwgPSBkb21FbC5jbG9zZXN0KFwiW2RhdGEtc2xhdGUtbm9kZV1cIik7XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBkb21FbCA/IEVMRU1FTlRfVE9fTk9ERS5nZXQoZG9tRWwpIDogbnVsbDtcblxuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc29sdmUgYSBTbGF0ZSBub2RlIGZyb20gRE9NIG5vZGU6IFwiLmNvbmNhdChkb21FbCkpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgdGFyZ2V0IHJhbmdlIGZyb20gYSBET00gYGV2ZW50YC5cclxuICAgKi9cbiAgZmluZEV2ZW50UmFuZ2UoZWRpdG9yLCBldmVudCkge1xuICAgIGlmICgnbmF0aXZlRXZlbnQnIGluIGV2ZW50KSB7XG4gICAgICBldmVudCA9IGV2ZW50Lm5hdGl2ZUV2ZW50O1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBjbGllbnRYOiB4LFxuICAgICAgY2xpZW50WTogeSxcbiAgICAgIHRhcmdldFxuICAgIH0gPSBldmVudDtcblxuICAgIGlmICh4ID09IG51bGwgfHwgeSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gYSBET00gZXZlbnQ6IFwiLmNvbmNhdChldmVudCkpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBldmVudC50YXJnZXQpO1xuICAgIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTsgLy8gSWYgdGhlIGRyb3AgdGFyZ2V0IGlzIGluc2lkZSBhIHZvaWQgbm9kZSwgbW92ZSBpdCBpbnRvIGVpdGhlciB0aGVcbiAgICAvLyBuZXh0IG9yIHByZXZpb3VzIG5vZGUsIGRlcGVuZGluZyBvbiB3aGljaCBzaWRlIHRoZSBgeGAgYW5kIGB5YFxuICAgIC8vIGNvb3JkaW5hdGVzIGFyZSBjbG9zZXN0IHRvLlxuXG4gICAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgdmFyIHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgaXNQcmV2ID0gZWRpdG9yLmlzSW5saW5lKG5vZGUpID8geCAtIHJlY3QubGVmdCA8IHJlY3QubGVmdCArIHJlY3Qud2lkdGggLSB4IDogeSAtIHJlY3QudG9wIDwgcmVjdC50b3AgKyByZWN0LmhlaWdodCAtIHk7XG4gICAgICB2YXIgZWRnZSA9IEVkaXRvci5wb2ludChlZGl0b3IsIHBhdGgsIHtcbiAgICAgICAgZWRnZTogaXNQcmV2ID8gJ3N0YXJ0JyA6ICdlbmQnXG4gICAgICB9KTtcbiAgICAgIHZhciBwb2ludCA9IGlzUHJldiA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBlZGdlKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGVkZ2UpO1xuXG4gICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgdmFyIF9yYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBvaW50KTtcblxuICAgICAgICByZXR1cm4gX3JhbmdlO1xuICAgICAgfVxuICAgIH0gLy8gRWxzZSByZXNvbHZlIGEgcmFuZ2UgZnJvbSB0aGUgY2FyZXQgcG9zaXRpb24gd2hlcmUgdGhlIGRyb3Agb2NjdXJlZC5cblxuXG4gICAgdmFyIGRvbVJhbmdlO1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudFxuICAgIH0gPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTsgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCBgY2FyZXRSYW5nZUZyb21Qb2ludGAgZG9lc24ndCBleGlzdC4gKDIwMTYvMDcvMjUpXG5cbiAgICBpZiAoZG9jdW1lbnQuY2FyZXRSYW5nZUZyb21Qb2ludCkge1xuICAgICAgZG9tUmFuZ2UgPSBkb2N1bWVudC5jYXJldFJhbmdlRnJvbVBvaW50KHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcG9zaXRpb24gPSBkb2N1bWVudC5jYXJldFBvc2l0aW9uRnJvbVBvaW50KHgsIHkpO1xuXG4gICAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgZG9tUmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICBkb21SYW5nZS5zZXRTdGFydChwb3NpdGlvbi5vZmZzZXROb2RlLCBwb3NpdGlvbi5vZmZzZXQpO1xuICAgICAgICBkb21SYW5nZS5zZXRFbmQocG9zaXRpb24ub2Zmc2V0Tm9kZSwgcG9zaXRpb24ub2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWRvbVJhbmdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gYSBET00gZXZlbnQ6IFwiLmNvbmNhdChldmVudCkpO1xuICAgIH0gLy8gUmVzb2x2ZSBhIFNsYXRlIHJhbmdlIGZyb20gdGhlIERPTSByYW5nZS5cblxuXG4gICAgdmFyIHJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tUmFuZ2UsIHtcbiAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgc3VwcHJlc3NUaHJvdzogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gcmFuZ2U7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRmluZCBhIFNsYXRlIHBvaW50IGZyb20gYSBET00gc2VsZWN0aW9uJ3MgYGRvbU5vZGVgIGFuZCBgZG9tT2Zmc2V0YC5cclxuICAgKi9cbiAgdG9TbGF0ZVBvaW50KGVkaXRvciwgZG9tUG9pbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIge1xuICAgICAgZXhhY3RNYXRjaCxcbiAgICAgIHN1cHByZXNzVGhyb3dcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgW25lYXJlc3ROb2RlLCBuZWFyZXN0T2Zmc2V0XSA9IGV4YWN0TWF0Y2ggPyBkb21Qb2ludCA6IG5vcm1hbGl6ZURPTVBvaW50KGRvbVBvaW50KTtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IG5lYXJlc3ROb2RlLnBhcmVudE5vZGU7XG4gICAgdmFyIHRleHROb2RlID0gbnVsbDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIGlmIChwYXJlbnROb2RlKSB7XG4gICAgICB2YXIgX2RvbU5vZGUkdGV4dENvbnRlbnQsIF9kb21Ob2RlJHRleHRDb250ZW50MjtcblxuICAgICAgdmFyIGVkaXRvckVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgIHZhciBwb3RlbnRpYWxWb2lkTm9kZSA9IHBhcmVudE5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtdm9pZD1cInRydWVcIl0nKTsgLy8gTmVlZCB0byBlbnN1cmUgdGhhdCB0aGUgY2xvc2VzdCB2b2lkIG5vZGUgaXMgYWN0dWFsbHkgYSB2b2lkIG5vZGVcbiAgICAgIC8vIHdpdGhpbiB0aGlzIGVkaXRvciwgYW5kIG5vdCBhIHZvaWQgbm9kZSB3aXRoaW4gc29tZSBwYXJlbnQgZWRpdG9yLiBUaGlzIGNhbiBoYXBwZW5cbiAgICAgIC8vIGlmIHRoaXMgZWRpdG9yIGlzIHdpdGhpbiBhIHZvaWQgbm9kZSBvZiBhbm90aGVyIGVkaXRvciAoXCJuZXN0ZWQgZWRpdG9yc1wiLCBsaWtlIGluXG4gICAgICAvLyB0aGUgXCJFZGl0YWJsZSBWb2lkc1wiIGV4YW1wbGUgb24gdGhlIGRvY3Mgc2l0ZSkuXG5cbiAgICAgIHZhciB2b2lkTm9kZSA9IHBvdGVudGlhbFZvaWROb2RlICYmIGVkaXRvckVsLmNvbnRhaW5zKHBvdGVudGlhbFZvaWROb2RlKSA/IHBvdGVudGlhbFZvaWROb2RlIDogbnVsbDtcbiAgICAgIHZhciBsZWFmTm9kZSA9IHBhcmVudE5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbGVhZl0nKTtcbiAgICAgIHZhciBkb21Ob2RlID0gbnVsbDsgLy8gQ2FsY3VsYXRlIGhvdyBmYXIgaW50byB0aGUgdGV4dCBub2RlIHRoZSBgbmVhcmVzdE5vZGVgIGlzLCBzbyB0aGF0IHdlXG4gICAgICAvLyBjYW4gZGV0ZXJtaW5lIHdoYXQgdGhlIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgdGV4dCBub2RlIGlzLlxuXG4gICAgICBpZiAobGVhZk5vZGUpIHtcbiAgICAgICAgdGV4dE5vZGUgPSBsZWFmTm9kZS5jbG9zZXN0KCdbZGF0YS1zbGF0ZS1ub2RlPVwidGV4dFwiXScpO1xuXG4gICAgICAgIGlmICh0ZXh0Tm9kZSkge1xuICAgICAgICAgIHZhciB3aW5kb3cgPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcbiAgICAgICAgICB2YXIgcmFuZ2UgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICByYW5nZS5zZXRTdGFydCh0ZXh0Tm9kZSwgMCk7XG4gICAgICAgICAgcmFuZ2Uuc2V0RW5kKG5lYXJlc3ROb2RlLCBuZWFyZXN0T2Zmc2V0KTtcbiAgICAgICAgICB2YXIgY29udGVudHMgPSByYW5nZS5jbG9uZUNvbnRlbnRzKCk7XG4gICAgICAgICAgdmFyIHJlbW92YWxzID0gWy4uLkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLXplcm8td2lkdGhdJykpLCAuLi5BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250ZW50cy5xdWVyeVNlbGVjdG9yQWxsKCdbY29udGVudGVkaXRhYmxlPWZhbHNlXScpKV07XG4gICAgICAgICAgcmVtb3ZhbHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICAvLyBDT01QQVQ6IFdoaWxlIGNvbXBvc2luZyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0IG5vZGUsIHNvbWUga2V5Ym9hcmRzIHB1dFxuICAgICAgICAgICAgLy8gdGhlIHRleHQgY29udGVudCBpbnNpZGUgdGhlIHplcm8gd2lkdGggc3BhY2UuXG4gICAgICAgICAgICBpZiAoSVNfQU5EUk9JRCAmJiAhZXhhY3RNYXRjaCAmJiBlbC5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpICYmIGVsLnRleHRDb250ZW50Lmxlbmd0aCA+IDAgJiYgZWwudGV4dENvbnRleHQgIT09ICdcXHVGRUZGJykge1xuICAgICAgICAgICAgICBpZiAoZWwudGV4dENvbnRlbnQuc3RhcnRzV2l0aCgnXFx1RkVGRicpKSB7XG4gICAgICAgICAgICAgICAgZWwudGV4dENvbnRlbnQgPSBlbC50ZXh0Q29udGVudC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgfSk7IC8vIENPTVBBVDogRWRnZSBoYXMgYSBidWcgd2hlcmUgUmFuZ2UucHJvdG90eXBlLnRvU3RyaW5nKCkgd2lsbFxuICAgICAgICAgIC8vIGNvbnZlcnQgXFxuIGludG8gXFxyXFxuLiBUaGUgYnVnIGNhdXNlcyBhIGxvb3Agd2hlbiBzbGF0ZS1yZWFjdFxuICAgICAgICAgIC8vIGF0dGVtcHRzIHRvIHJlcG9zaXRpb24gaXRzIGN1cnNvciB0byBtYXRjaCB0aGUgbmF0aXZlIHBvc2l0aW9uLiBVc2VcbiAgICAgICAgICAvLyB0ZXh0Q29udGVudC5sZW5ndGggaW5zdGVhZC5cbiAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMDI5MTExNi9cblxuICAgICAgICAgIG9mZnNldCA9IGNvbnRlbnRzLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICBkb21Ob2RlID0gdGV4dE5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodm9pZE5vZGUpIHtcbiAgICAgICAgLy8gRm9yIHZvaWQgbm9kZXMsIHRoZSBlbGVtZW50IHdpdGggdGhlIG9mZnNldCBrZXkgd2lsbCBiZSBhIGNvdXNpbiwgbm90IGFuXG4gICAgICAgIC8vIGFuY2VzdG9yLCBzbyBmaW5kIGl0IGJ5IGdvaW5nIGRvd24gZnJvbSB0aGUgbmVhcmVzdCB2b2lkIHBhcmVudCBhbmQgdGFraW5nIHRoZVxuICAgICAgICAvLyBmaXJzdCBvbmUgdGhhdCBpc24ndCBpbnNpZGUgYSBuZXN0ZWQgZWRpdG9yLlxuICAgICAgICB2YXIgbGVhZk5vZGVzID0gdm9pZE5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtc2xhdGUtbGVhZl0nKTtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVhZk5vZGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gbGVhZk5vZGVzW2luZGV4XTtcblxuICAgICAgICAgIGlmIChSZWFjdEVkaXRvci5oYXNET01Ob2RlKGVkaXRvciwgY3VycmVudCkpIHtcbiAgICAgICAgICAgIGxlYWZOb2RlID0gY3VycmVudDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDT01QQVQ6IEluIHJlYWQtb25seSBlZGl0b3JzIHRoZSBsZWFmIGlzIG5vdCByZW5kZXJlZC5cblxuXG4gICAgICAgIGlmICghbGVhZk5vZGUpIHtcbiAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRleHROb2RlID0gbGVhZk5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZT1cInRleHRcIl0nKTtcbiAgICAgICAgICBkb21Ob2RlID0gbGVhZk5vZGU7XG4gICAgICAgICAgb2Zmc2V0ID0gZG9tTm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICAgICAgZG9tTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1zbGF0ZS16ZXJvLXdpZHRoXScpLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgICAgb2Zmc2V0IC09IGVsLnRleHRDb250ZW50Lmxlbmd0aDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZG9tTm9kZSAmJiBvZmZzZXQgPT09IGRvbU5vZGUudGV4dENvbnRlbnQubGVuZ3RoICYmIC8vIENPTVBBVDogQW5kcm9pZCBJTUVzIG1pZ2h0IHJlbW92ZSB0aGUgemVybyB3aWR0aCBzcGFjZSB3aGlsZSBjb21wb3NpbmcsXG4gICAgICAvLyBhbmQgd2UgZG9uJ3QgYWRkIGl0IGZvciBsaW5lLWJyZWFrcy5cbiAgICAgIElTX0FORFJPSUQgJiYgZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtemVyby13aWR0aCcpID09PSAneicgJiYgKF9kb21Ob2RlJHRleHRDb250ZW50ID0gZG9tTm9kZS50ZXh0Q29udGVudCkgIT09IG51bGwgJiYgX2RvbU5vZGUkdGV4dENvbnRlbnQgIT09IHZvaWQgMCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudC5zdGFydHNXaXRoKCdcXHVGRUZGJykgJiYgKHBhcmVudE5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLXplcm8td2lkdGgnKSB8fCBJU19GSVJFRk9YICYmIChfZG9tTm9kZSR0ZXh0Q29udGVudDIgPSBkb21Ob2RlLnRleHRDb250ZW50KSAhPT0gbnVsbCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudDIgIT09IHZvaWQgMCAmJiBfZG9tTm9kZSR0ZXh0Q29udGVudDIuZW5kc1dpdGgoJ1xcblxcbicpKSkge1xuICAgICAgICBvZmZzZXQtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoSVNfQU5EUk9JRCAmJiAhdGV4dE5vZGUgJiYgIWV4YWN0TWF0Y2gpIHtcbiAgICAgIHZhciBub2RlID0gcGFyZW50Tm9kZS5oYXNBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtbm9kZScpID8gcGFyZW50Tm9kZSA6IHBhcmVudE5vZGUuY2xvc2VzdCgnW2RhdGEtc2xhdGUtbm9kZV0nKTtcblxuICAgICAgaWYgKG5vZGUgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIG5vZGUsIHtcbiAgICAgICAgZWRpdGFibGU6IHRydWVcbiAgICAgIH0pKSB7XG4gICAgICAgIHZhciBfc2xhdGVOb2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBub2RlKTtcblxuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgIG9mZnNldDogX29mZnNldFxuICAgICAgICB9ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBfc2xhdGVOb2RlKSk7XG5cbiAgICAgICAgaWYgKCFub2RlLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXNsYXRlLWxlYWZdJykpIHtcbiAgICAgICAgICBfb2Zmc2V0ID0gbmVhcmVzdE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0ZXh0Tm9kZSkge1xuICAgICAgaWYgKHN1cHByZXNzVGhyb3cpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcG9pbnQgZnJvbSBET00gcG9pbnQ6IFwiLmNvbmNhdChkb21Qb2ludCkpO1xuICAgIH0gLy8gQ09NUEFUOiBJZiBzb21lb25lIGlzIGNsaWNraW5nIGZyb20gb25lIFNsYXRlIGVkaXRvciBpbnRvIGFub3RoZXIsXG4gICAgLy8gdGhlIHNlbGVjdCBldmVudCBmaXJlcyB0d2ljZSwgb25jZSBmb3IgdGhlIG9sZCBlZGl0b3IncyBgZWxlbWVudGBcbiAgICAvLyBmaXJzdCwgYW5kIHRoZW4gYWZ0ZXJ3YXJkcyBmb3IgdGhlIGNvcnJlY3QgYGVsZW1lbnRgLiAoMjAxNy8wMy8wMylcblxuXG4gICAgdmFyIHNsYXRlTm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgdGV4dE5vZGUpO1xuICAgIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBzbGF0ZU5vZGUpO1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoLFxuICAgICAgb2Zmc2V0XG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBGaW5kIGEgU2xhdGUgcmFuZ2UgZnJvbSBhIERPTSByYW5nZSBvciBzZWxlY3Rpb24uXHJcbiAgICovXG4gIHRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVJhbmdlLCBvcHRpb25zKSB7XG4gICAgdmFyIHtcbiAgICAgIGV4YWN0TWF0Y2gsXG4gICAgICBzdXBwcmVzc1Rocm93XG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIGVsID0gaXNET01TZWxlY3Rpb24oZG9tUmFuZ2UpID8gZG9tUmFuZ2UuYW5jaG9yTm9kZSA6IGRvbVJhbmdlLnN0YXJ0Q29udGFpbmVyO1xuICAgIHZhciBhbmNob3JOb2RlO1xuICAgIHZhciBhbmNob3JPZmZzZXQ7XG4gICAgdmFyIGZvY3VzTm9kZTtcbiAgICB2YXIgZm9jdXNPZmZzZXQ7XG4gICAgdmFyIGlzQ29sbGFwc2VkO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICBpZiAoaXNET01TZWxlY3Rpb24oZG9tUmFuZ2UpKSB7XG4gICAgICAgIGFuY2hvck5vZGUgPSBkb21SYW5nZS5hbmNob3JOb2RlO1xuICAgICAgICBhbmNob3JPZmZzZXQgPSBkb21SYW5nZS5hbmNob3JPZmZzZXQ7XG4gICAgICAgIGZvY3VzTm9kZSA9IGRvbVJhbmdlLmZvY3VzTm9kZTtcbiAgICAgICAgZm9jdXNPZmZzZXQgPSBkb21SYW5nZS5mb2N1c09mZnNldDsgLy8gQ09NUEFUOiBUaGVyZSdzIGEgYnVnIGluIGNocm9tZSB0aGF0IGFsd2F5cyByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgICAgLy8gYGlzQ29sbGFwc2VkYCBmb3IgYSBTZWxlY3Rpb24gdGhhdCBjb21lcyBmcm9tIGEgU2hhZG93Um9vdC5cbiAgICAgICAgLy8gKDIwMjAvMDgvMDgpXG4gICAgICAgIC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0NzUyM1xuXG4gICAgICAgIGlmIChJU19DSFJPTUUgJiYgaGFzU2hhZG93Um9vdCgpKSB7XG4gICAgICAgICAgaXNDb2xsYXBzZWQgPSBkb21SYW5nZS5hbmNob3JOb2RlID09PSBkb21SYW5nZS5mb2N1c05vZGUgJiYgZG9tUmFuZ2UuYW5jaG9yT2Zmc2V0ID09PSBkb21SYW5nZS5mb2N1c09mZnNldDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0NvbGxhcHNlZCA9IGRvbVJhbmdlLmlzQ29sbGFwc2VkO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbmNob3JOb2RlID0gZG9tUmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgIGFuY2hvck9mZnNldCA9IGRvbVJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICBmb2N1c05vZGUgPSBkb21SYW5nZS5lbmRDb250YWluZXI7XG4gICAgICAgIGZvY3VzT2Zmc2V0ID0gZG9tUmFuZ2UuZW5kT2Zmc2V0O1xuICAgICAgICBpc0NvbGxhcHNlZCA9IGRvbVJhbmdlLmNvbGxhcHNlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYW5jaG9yTm9kZSA9PSBudWxsIHx8IGZvY3VzTm9kZSA9PSBudWxsIHx8IGFuY2hvck9mZnNldCA9PSBudWxsIHx8IGZvY3VzT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGEgU2xhdGUgcmFuZ2UgZnJvbSBET00gcmFuZ2U6IFwiLmNvbmNhdChkb21SYW5nZSkpO1xuICAgIH1cblxuICAgIHZhciBhbmNob3IgPSBSZWFjdEVkaXRvci50b1NsYXRlUG9pbnQoZWRpdG9yLCBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0XSwge1xuICAgICAgZXhhY3RNYXRjaCxcbiAgICAgIHN1cHByZXNzVGhyb3dcbiAgICB9KTtcblxuICAgIGlmICghYW5jaG9yKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZm9jdXMgPSBpc0NvbGxhcHNlZCA/IGFuY2hvciA6IFJlYWN0RWRpdG9yLnRvU2xhdGVQb2ludChlZGl0b3IsIFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSwge1xuICAgICAgZXhhY3RNYXRjaCxcbiAgICAgIHN1cHByZXNzVGhyb3dcbiAgICB9KTtcblxuICAgIGlmICghZm9jdXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciByYW5nZSA9IHtcbiAgICAgIGFuY2hvcjogYW5jaG9yLFxuICAgICAgZm9jdXM6IGZvY3VzXG4gICAgfTsgLy8gaWYgdGhlIHNlbGVjdGlvbiBpcyBhIGhhbmdpbmcgcmFuZ2UgdGhhdCBlbmRzIGluIGEgdm9pZFxuICAgIC8vIGFuZCB0aGUgRE9NIGZvY3VzIGlzIGFuIEVsZW1lbnRcbiAgICAvLyAobWVhbmluZyB0aGF0IHRoZSBzZWxlY3Rpb24gZW5kcyBiZWZvcmUgdGhlIGVsZW1lbnQpXG4gICAgLy8gdW5oYW5nIHRoZSByYW5nZSB0byBhdm9pZCBtaXN0YWtlbmx5IGluY2x1ZGluZyB0aGUgdm9pZFxuXG4gICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQocmFuZ2UpICYmIFJhbmdlLmlzRm9yd2FyZChyYW5nZSkgJiYgaXNET01FbGVtZW50KGZvY3VzTm9kZSkgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICBhdDogcmFuZ2UuZm9jdXMsXG4gICAgICBtb2RlOiAnaGlnaGVzdCdcbiAgICB9KSkge1xuICAgICAgcmFuZ2UgPSBFZGl0b3IudW5oYW5nUmFuZ2UoZWRpdG9yLCByYW5nZSwge1xuICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9LFxuXG4gIGhhc1JhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgcmV0dXJuIEVkaXRvci5oYXNQYXRoKGVkaXRvciwgYW5jaG9yLnBhdGgpICYmIEVkaXRvci5oYXNQYXRoKGVkaXRvciwgZm9jdXMucGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIHRhcmdldCBpcyBpbiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBoYXNUYXJnZXQoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gaXNET01Ob2RlKHRhcmdldCkgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIHRhcmdldCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIHRhcmdldCBpcyBlZGl0YWJsZSBhbmQgaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gaXNET01Ob2RlKHRhcmdldCkgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIHRhcmdldCwge1xuICAgICAgZWRpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgdGFyZ2V0IGNhbiBiZSBzZWxlY3RhYmxlXHJcbiAgICovXG4gIGhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCB0YXJnZXQpIHx8IFJlYWN0RWRpdG9yLmlzVGFyZ2V0SW5zaWRlTm9uUmVhZG9ubHlWb2lkKGVkaXRvciwgdGFyZ2V0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiB0aGUgdGFyZ2V0IGlzIGluc2lkZSB2b2lkIGFuZCBpbiBhbiBub24tcmVhZG9ubHkgZWRpdG9yLlxyXG4gICAqL1xuICBpc1RhcmdldEluc2lkZU5vblJlYWRvbmx5Vm9pZChlZGl0b3IsIHRhcmdldCkge1xuICAgIGlmIChJU19SRUFEX09OTFkuZ2V0KGVkaXRvcikpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgc2xhdGVOb2RlID0gUmVhY3RFZGl0b3IuaGFzVGFyZ2V0KGVkaXRvciwgdGFyZ2V0KSAmJiBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIHRhcmdldCk7XG4gICAgcmV0dXJuIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBzbGF0ZU5vZGUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEV4cGVyaW1lbnRhbCBhbmQgYW5kcm9pZCBzcGVjaWZpYzogRmx1c2ggYWxsIHBlbmRpbmcgZGlmZnMgYW5kIGNhbmNlbCBjb21wb3NpdGlvbiBhdCB0aGUgbmV4dCBwb3NzaWJsZSB0aW1lLlxyXG4gICAqL1xuICBhbmRyb2lkU2NoZWR1bGVGbHVzaChlZGl0b3IpIHtcbiAgICB2YXIgX0VESVRPUl9UT19TQ0hFRFVMRV9GO1xuXG4gICAgKF9FRElUT1JfVE9fU0NIRURVTEVfRiA9IEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSC5nZXQoZWRpdG9yKSkgPT09IG51bGwgfHwgX0VESVRPUl9UT19TQ0hFRFVMRV9GID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfRURJVE9SX1RPX1NDSEVEVUxFX0YoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBFeHBlcmltZW50YWwgYW5kIGFuZHJvaWQgc3BlY2lmaWM6IEdldCBwZW5kaW5nIGRpZmZzXHJcbiAgICovXG4gIGFuZHJvaWRQZW5kaW5nRGlmZnMoZWRpdG9yKSB7XG4gICAgcmV0dXJuIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpO1xuICB9XG5cbn07XG5cbi8qKlxyXG4gKiBQcmV2ZW50IHdhcm5pbmcgb24gU1NSIGJ5IGZhbGxpbmcgYmFjayB0byB1c2VFZmZlY3Qgd2hlbiBET00gaXNuJ3QgYXZhaWxhYmxlXHJcbiAqL1xuXG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IENBTl9VU0VfRE9NID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuXG52YXIgX2V4Y2x1ZGVkJDMgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXSxcbiAgICBfZXhjbHVkZWQyJDEgPSBbXCJhbmNob3JcIiwgXCJmb2N1c1wiXTtcbnZhciBzaGFsbG93Q29tcGFyZSA9IChvYmoxLCBvYmoyKSA9PiBPYmplY3Qua2V5cyhvYmoxKS5sZW5ndGggPT09IE9iamVjdC5rZXlzKG9iajIpLmxlbmd0aCAmJiBPYmplY3Qua2V5cyhvYmoxKS5ldmVyeShrZXkgPT4gb2JqMi5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG9iajFba2V5XSA9PT0gb2JqMltrZXldKTtcbi8qKlxyXG4gKiBDaGVjayBpZiBhIGxpc3Qgb2YgZGVjb3JhdG9yIHJhbmdlcyBhcmUgZXF1YWwgdG8gYW5vdGhlci5cclxuICpcclxuICogUEVSRjogdGhpcyByZXF1aXJlcyB0aGUgdHdvIGxpc3RzIHRvIGFsc28gaGF2ZSB0aGUgcmFuZ2VzIGluc2lkZSB0aGVtIGluIHRoZVxyXG4gKiBzYW1lIG9yZGVyLCBidXQgdGhpcyBpcyBhbiBva2F5IGNvbnN0cmFpbnQgZm9yIHVzIHNpbmNlIGRlY29yYXRpb25zIGFyZVxyXG4gKiBrZXB0IGluIG9yZGVyLCBhbmQgdGhlIG9kZCBjYXNlIHdoZXJlIHRoZXkgYXJlbid0IGlzIG9rYXkgdG8gcmUtcmVuZGVyIGZvci5cclxuICovXG5cbnZhciBpc0RlY29yYXRvclJhbmdlTGlzdEVxdWFsID0gKGxpc3QsIGFub3RoZXIpID0+IHtcbiAgaWYgKGxpc3QubGVuZ3RoICE9PSBhbm90aGVyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciByYW5nZSA9IGxpc3RbaV07XG4gICAgdmFyIG90aGVyID0gYW5vdGhlcltpXTtcblxuICAgIHZhciByYW5nZU93blByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJhbmdlLCBfZXhjbHVkZWQkMyk7XG5cbiAgICB2YXIgb3RoZXJPd25Qcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvdGhlciwgX2V4Y2x1ZGVkMiQxKTtcblxuICAgIGlmICghUmFuZ2UuZXF1YWxzKHJhbmdlLCBvdGhlcikgfHwgcmFuZ2VbUExBQ0VIT0xERVJfU1lNQk9MXSAhPT0gb3RoZXJbUExBQ0VIT0xERVJfU1lNQk9MXSB8fCAhc2hhbGxvd0NvbXBhcmUocmFuZ2VPd25Qcm9wcywgb3RoZXJPd25Qcm9wcykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxyXG4gKiBMZWFmIGNvbnRlbnQgc3RyaW5ncy5cclxuICovXG5cbnZhciBTdHJpbmcgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgaXNMYXN0LFxuICAgIGxlYWYsXG4gICAgcGFyZW50LFxuICAgIHRleHRcbiAgfSA9IHByb3BzO1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIHBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIHRleHQpO1xuICB2YXIgcGFyZW50UGF0aCA9IFBhdGgucGFyZW50KHBhdGgpO1xuICB2YXIgaXNNYXJrUGxhY2Vob2xkZXIgPSBsZWFmW01BUktfUExBQ0VIT0xERVJfU1lNQk9MXSA9PT0gdHJ1ZTsgLy8gQ09NUEFUOiBSZW5kZXIgdGV4dCBpbnNpZGUgdm9pZCBub2RlcyB3aXRoIGEgemVyby13aWR0aCBzcGFjZS5cbiAgLy8gU28gdGhlIG5vZGUgY2FuIGNvbnRhaW4gc2VsZWN0aW9uIGJ1dCB0aGUgdGV4dCBpcyBub3QgdmlzaWJsZS5cblxuICBpZiAoZWRpdG9yLmlzVm9pZChwYXJlbnQpKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFplcm9XaWR0aFN0cmluZywge1xuICAgICAgbGVuZ3RoOiBOb2RlLnN0cmluZyhwYXJlbnQpLmxlbmd0aFxuICAgIH0pO1xuICB9IC8vIENPTVBBVDogSWYgdGhpcyBpcyB0aGUgbGFzdCB0ZXh0IG5vZGUgaW4gYW4gZW1wdHkgYmxvY2ssIHJlbmRlciBhIHplcm8tXG4gIC8vIHdpZHRoIHNwYWNlIHRoYXQgd2lsbCBjb252ZXJ0IGludG8gYSBsaW5lIGJyZWFrIHdoZW4gY29weWluZyBhbmQgcGFzdGluZ1xuICAvLyB0byBzdXBwb3J0IGV4cGVjdGVkIHBsYWluIHRleHQuXG5cblxuICBpZiAobGVhZi50ZXh0ID09PSAnJyAmJiBwYXJlbnQuY2hpbGRyZW5bcGFyZW50LmNoaWxkcmVuLmxlbmd0aCAtIDFdID09PSB0ZXh0ICYmICFlZGl0b3IuaXNJbmxpbmUocGFyZW50KSAmJiBFZGl0b3Iuc3RyaW5nKGVkaXRvciwgcGFyZW50UGF0aCkgPT09ICcnKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFplcm9XaWR0aFN0cmluZywge1xuICAgICAgaXNMaW5lQnJlYWs6IHRydWUsXG4gICAgICBpc01hcmtQbGFjZWhvbGRlcjogaXNNYXJrUGxhY2Vob2xkZXJcbiAgICB9KTtcbiAgfSAvLyBDT01QQVQ6IElmIHRoZSB0ZXh0IGlzIGVtcHR5LCBpdCdzIGJlY2F1c2UgaXQncyBvbiB0aGUgZWRnZSBvZiBhbiBpbmxpbmVcbiAgLy8gbm9kZSwgc28gd2UgcmVuZGVyIGEgemVyby13aWR0aCBzcGFjZSBzbyB0aGF0IHRoZSBzZWxlY3Rpb24gY2FuIGJlXG4gIC8vIGluc2VydGVkIG5leHQgdG8gaXQgc3RpbGwuXG5cblxuICBpZiAobGVhZi50ZXh0ID09PSAnJykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChaZXJvV2lkdGhTdHJpbmcsIHtcbiAgICAgIGlzTWFya1BsYWNlaG9sZGVyOiBpc01hcmtQbGFjZWhvbGRlclxuICAgIH0pO1xuICB9IC8vIENPTVBBVDogQnJvd3NlcnMgd2lsbCBjb2xsYXBzZSB0cmFpbGluZyBuZXcgbGluZXMgYXQgdGhlIGVuZCBvZiBibG9ja3MsXG4gIC8vIHNvIHdlIG5lZWQgdG8gYWRkIGFuIGV4dHJhIHRyYWlsaW5nIG5ldyBsaW5lcyB0byBwcmV2ZW50IHRoYXQuXG5cblxuICBpZiAoaXNMYXN0ICYmIGxlYWYudGV4dC5zbGljZSgtMSkgPT09ICdcXG4nKSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRleHRTdHJpbmcsIHtcbiAgICAgIGlzVHJhaWxpbmc6IHRydWUsXG4gICAgICB0ZXh0OiBsZWFmLnRleHRcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUZXh0U3RyaW5nLCB7XG4gICAgdGV4dDogbGVhZi50ZXh0XG4gIH0pO1xufTtcbi8qKlxyXG4gKiBMZWFmIHN0cmluZ3Mgd2l0aCB0ZXh0IGluIHRoZW0uXHJcbiAqL1xuXG5cbnZhciBUZXh0U3RyaW5nID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIHRleHQsXG4gICAgaXNUcmFpbGluZyA9IGZhbHNlXG4gIH0gPSBwcm9wcztcbiAgdmFyIHJlZiA9IHVzZVJlZihudWxsKTtcblxuICB2YXIgZ2V0VGV4dENvbnRlbnQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHRleHQgIT09IG51bGwgJiYgdGV4dCAhPT0gdm9pZCAwID8gdGV4dCA6ICcnKS5jb25jYXQoaXNUcmFpbGluZyA/ICdcXG4nIDogJycpO1xuICB9OyAvLyBUaGlzIGlzIHRoZSBhY3R1YWwgdGV4dCByZW5kZXJpbmcgYm91bmRhcnkgd2hlcmUgd2UgaW50ZXJmYWNlIHdpdGggdGhlIERPTVxuICAvLyBUaGUgdGV4dCBpcyBub3QgcmVuZGVyZWQgYXMgcGFydCBvZiB0aGUgdmlydHVhbCBET00sIGFzIHNpbmNlIHdlIGhhbmRsZSBiYXNpYyBjaGFyYWN0ZXIgaW5zZXJ0aW9ucyBuYXRpdmVseSxcbiAgLy8gdXBkYXRpbmcgdGhlIERPTSBpcyBub3QgYSBvbmUgd2F5IGRhdGFmbG93IGFueW1vcmUuIFdoYXQgd2UgbmVlZCBoZXJlIGlzIG5vdCByZWNvbmNpbGlhdGlvbiBhbmQgZGlmZmluZ1xuICAvLyB3aXRoIHByZXZpb3VzIHZlcnNpb24gb2YgdGhlIHZpcnR1YWwgRE9NLCBidXQgcmF0aGVyIGRpZmZpbmcgd2l0aCB0aGUgYWN0dWFsIERPTSBlbGVtZW50LCBhbmQgcmVwbGFjZSB0aGUgRE9NIDxzcGFuPiBjb250ZW50XG4gIC8vIGV4YWN0bHkgaWYgYW5kIG9ubHkgaWYgaXRzIGN1cnJlbnQgY29udGVudCBkb2VzIG5vdCBtYXRjaCBvdXIgY3VycmVudCB2aXJ0dWFsIERPTS5cbiAgLy8gT3RoZXJ3aXNlIHRoZSBET00gVGV4dE5vZGUgd291bGQgYWx3YXlzIGJlIHJlcGxhY2VkIGJ5IFJlYWN0IGFzIHRoZSB1c2VyIHR5cGVzLCB3aGljaCBpbnRlcmZlcmVzIHdpdGggbmF0aXZlIHRleHQgZmVhdHVyZXMsXG4gIC8vIGVnIG1ha2VzIG5hdGl2ZSBzcGVsbGNoZWNrIG9wdCBvdXQgZnJvbSBjaGVja2luZyB0aGUgdGV4dCBub2RlLlxuICAvLyB1c2VMYXlvdXRFZmZlY3Q6IHVwZGF0aW5nIG91ciBzcGFuIGJlZm9yZSBicm93c2VyIHBhaW50XG5cblxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAvLyBudWxsIGNvYWxlc2NpbmcgdGV4dCB0byBtYWtlIHN1cmUgd2UncmUgbm90IG91dHB1dGluZyBcIm51bGxcIiBhcyBhIHN0cmluZyBpbiB0aGUgZXh0cmVtZSBjYXNlIGl0IGlzIG51bGxpc2ggYXQgcnVudGltZVxuICAgIHZhciB0ZXh0V2l0aFRyYWlsaW5nID0gZ2V0VGV4dENvbnRlbnQoKTtcblxuICAgIGlmIChyZWYuY3VycmVudCAmJiByZWYuY3VycmVudC50ZXh0Q29udGVudCAhPT0gdGV4dFdpdGhUcmFpbGluZykge1xuICAgICAgcmVmLmN1cnJlbnQudGV4dENvbnRlbnQgPSB0ZXh0V2l0aFRyYWlsaW5nO1xuICAgIH0gLy8gaW50ZW50aW9uYWxseSBub3Qgc3BlY2lmeWluZyBkZXBlbmRlbmNpZXMsIHNvIHRoYXQgdGhpcyBlZmZlY3QgcnVucyBvbiBldmVyeSByZW5kZXJcbiAgICAvLyBhcyB0aGlzIGVmZmVjdGl2ZWx5IHJlcGxhY2VzIFwic3BlY2lmeWluZyB0aGUgdGV4dCBpbiB0aGUgdmlydHVhbCBET00gdW5kZXIgdGhlIDxzcGFuPiBiZWxvd1wiIG9uIGVhY2ggcmVuZGVyXG5cbiAgfSk7IC8vIFJlbmRlciB0ZXh0IGNvbnRlbnQgaW1tZWRpYXRlbHkgaWYgaXQncyB0aGUgZmlyc3QtdGltZSByZW5kZXJcbiAgLy8gRW5zdXJlIHRoYXQgdGV4dCBjb250ZW50IGlzIHJlbmRlcmVkIG9uIHNlcnZlci1zaWRlIHJlbmRlcmluZ1xuXG4gIGlmICghcmVmLmN1cnJlbnQpIHtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICAgIFwiZGF0YS1zbGF0ZS1zdHJpbmdcIjogdHJ1ZSxcbiAgICAgIHJlZjogcmVmXG4gICAgfSwgZ2V0VGV4dENvbnRlbnQoKSk7XG4gIH0gLy8gdGhlIHNwYW4gaXMgaW50ZW50aW9uYWxseSBzYW1lIG9uIGV2ZXJ5IHJlbmRlciBpbiB2aXJ0dWFsIERPTSwgYWN0dWFsIHJlbmRlcmluZyBoYXBwZW5zIGluIHRoZSBsYXlvdXQgZWZmZWN0IGFib3ZlXG5cblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHtcbiAgICBcImRhdGEtc2xhdGUtc3RyaW5nXCI6IHRydWUsXG4gICAgcmVmOiByZWZcbiAgfSk7XG59O1xuLyoqXHJcbiAqIExlYWYgc3RyaW5ncyB3aXRob3V0IHRleHQsIHJlbmRlciBhcyB6ZXJvLXdpZHRoIHN0cmluZ3MuXHJcbiAqL1xuXG5cbnZhciBaZXJvV2lkdGhTdHJpbmcgPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgbGVuZ3RoID0gMCxcbiAgICBpc0xpbmVCcmVhayA9IGZhbHNlLFxuICAgIGlzTWFya1BsYWNlaG9sZGVyID0gZmFsc2VcbiAgfSA9IHByb3BzO1xuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJzogaXNMaW5lQnJlYWsgPyAnbicgOiAneicsXG4gICAgJ2RhdGEtc2xhdGUtbGVuZ3RoJzogbGVuZ3RoXG4gIH07XG5cbiAgaWYgKGlzTWFya1BsYWNlaG9sZGVyKSB7XG4gICAgYXR0cmlidXRlc1snZGF0YS1zbGF0ZS1tYXJrLXBsYWNlaG9sZGVyJ10gPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKSwgIUlTX0FORFJPSUQgfHwgIWlzTGluZUJyZWFrID8gJ1xcdUZFRkYnIDogbnVsbCwgaXNMaW5lQnJlYWsgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImJyXCIsIG51bGwpIDogbnVsbCk7XG59O1xuXG4vKipcclxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBlZGl0b3Igb2JqZWN0LlxyXG4gKi9cblxudmFyIEVkaXRvckNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dChudWxsKTtcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgZWRpdG9yIG9iamVjdCBmcm9tIHRoZSBSZWFjdCBjb250ZXh0LlxyXG4gKi9cblxudmFyIHVzZVNsYXRlU3RhdGljID0gKCkgPT4ge1xuICB2YXIgZWRpdG9yID0gdXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcblxuICBpZiAoIWVkaXRvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlU2xhdGVTdGF0aWNgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuXG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG4vKipcclxuICogSW5kaXZpZHVhbCBsZWF2ZXMgaW4gYSB0ZXh0IG5vZGUgd2l0aCB1bmlxdWUgZm9ybWF0dGluZy5cclxuICovXG5cbnZhciBMZWFmID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGxlYWYsXG4gICAgaXNMYXN0LFxuICAgIHRleHQsXG4gICAgcGFyZW50LFxuICAgIHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWYgPSBwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0TGVhZiwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHMpKVxuICB9ID0gcHJvcHM7XG4gIHZhciBwbGFjZWhvbGRlclJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyID0gdXNlUmVmKG51bGwpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAocGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50KSB7XG4gICAgICAgIHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudC5kaXNjb25uZWN0KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBwbGFjZWhvbGRlckVsID0gcGxhY2Vob2xkZXJSZWYgPT09IG51bGwgfHwgcGxhY2Vob2xkZXJSZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBsYWNlaG9sZGVyUmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAocGxhY2Vob2xkZXJFbCkge1xuICAgICAgRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQuc2V0KGVkaXRvciwgcGxhY2Vob2xkZXJFbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEVESVRPUl9UT19QTEFDRUhPTERFUl9FTEVNRU5ULmRlbGV0ZShlZGl0b3IpO1xuICAgIH1cblxuICAgIGlmIChwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQpIHtcbiAgICAgIC8vIFVwZGF0ZSBleGlzdGluZyBvYnNlcnZlci5cbiAgICAgIHBsYWNlaG9sZGVyUmVzaXplT2JzZXJ2ZXIuY3VycmVudC5kaXNjb25uZWN0KCk7XG4gICAgICBpZiAocGxhY2Vob2xkZXJFbCkgcGxhY2Vob2xkZXJSZXNpemVPYnNlcnZlci5jdXJyZW50Lm9ic2VydmUocGxhY2Vob2xkZXJFbCk7XG4gICAgfSBlbHNlIGlmIChwbGFjZWhvbGRlckVsKSB7XG4gICAgICAvLyBDcmVhdGUgYSBuZXcgb2JzZXJ2ZXIgYW5kIG9ic2VydmUgdGhlIHBsYWNlaG9sZGVyIGVsZW1lbnQuXG4gICAgICBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoX3JlZiA9PiB7XG4gICAgICAgIHZhciBbe1xuICAgICAgICAgIHRhcmdldFxuICAgICAgICB9XSA9IF9yZWY7XG4gICAgICAgIHZhciBzdHlsZUVsZW1lbnQgPSBFRElUT1JfVE9fU1RZTEVfRUxFTUVOVC5nZXQoZWRpdG9yKTtcblxuICAgICAgICBpZiAoc3R5bGVFbGVtZW50KSB7XG4gICAgICAgICAgLy8gTWFrZSB0aGUgbWluLWhlaWdodCB0aGUgaGVpZ2h0IG9mIHRoZSBwbGFjZWhvbGRlci5cbiAgICAgICAgICB2YXIgbWluSGVpZ2h0ID0gXCJcIi5jb25jYXQodGFyZ2V0LmNsaWVudEhlaWdodCwgXCJweFwiKTtcbiAgICAgICAgICBzdHlsZUVsZW1lbnQuaW5uZXJIVE1MID0gXCI6d2hlcmUoW2RhdGEtc2xhdGUtZWRpdG9yLWlkPVxcXCJcIi5jb25jYXQoZWRpdG9yLmlkLCBcIlxcXCJdKSB7IG1pbi1oZWlnaHQ6IFwiKS5jb25jYXQobWluSGVpZ2h0LCBcIjsgfVwiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBwbGFjZWhvbGRlclJlc2l6ZU9ic2VydmVyLmN1cnJlbnQub2JzZXJ2ZShwbGFjZWhvbGRlckVsKTtcbiAgICB9XG5cbiAgICBpZiAoIXBsYWNlaG9sZGVyRWwpIHtcbiAgICAgIC8vIE5vIHBsYWNlaG9sZGVyIGVsZW1lbnQsIHNvIG5vIG5lZWQgZm9yIGEgcmVzaXplIG9ic2VydmVyLlxuICAgICAgdmFyIHN0eWxlRWxlbWVudCA9IEVESVRPUl9UT19TVFlMRV9FTEVNRU5ULmdldChlZGl0b3IpO1xuXG4gICAgICBpZiAoc3R5bGVFbGVtZW50KSB7XG4gICAgICAgIC8vIE5vIG1pbi1oZWlnaHQgaWYgdGhlcmUgaXMgbm8gcGxhY2Vob2xkZXIuXG4gICAgICAgIHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSAnJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQuZGVsZXRlKGVkaXRvcik7XG4gICAgfTtcbiAgfSwgW3BsYWNlaG9sZGVyUmVmLCBsZWFmXSk7XG4gIHZhciBjaGlsZHJlbiA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFN0cmluZywge1xuICAgIGlzTGFzdDogaXNMYXN0LFxuICAgIGxlYWY6IGxlYWYsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgdGV4dDogdGV4dFxuICB9KTtcblxuICBpZiAobGVhZltQTEFDRUhPTERFUl9TWU1CT0xdKSB7XG4gICAgdmFyIHBsYWNlaG9sZGVyUHJvcHMgPSB7XG4gICAgICBjaGlsZHJlbjogbGVhZi5wbGFjZWhvbGRlcixcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgJ2RhdGEtc2xhdGUtcGxhY2Vob2xkZXInOiB0cnVlLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICAgIG1heFdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICBvcGFjaXR5OiAnMC4zMzMnLFxuICAgICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRlbnRFZGl0YWJsZTogZmFsc2UsXG4gICAgICAgIHJlZjogcGxhY2Vob2xkZXJSZWZcbiAgICAgIH1cbiAgICB9O1xuICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHJlbmRlclBsYWNlaG9sZGVyKHBsYWNlaG9sZGVyUHJvcHMpLCBjaGlsZHJlbik7XG4gIH0gLy8gQ09NUEFUOiBIYXZpbmcgdGhlIGBkYXRhLWAgYXR0cmlidXRlcyBvbiB0aGVzZSBsZWFmIGVsZW1lbnRzIGVuc3VyZXMgdGhhdFxuICAvLyBpbiBjZXJ0YWluIG1pc2JlaGF2aW5nIGJyb3dzZXJzIHRoZXkgYXJlbid0IHdlaXJkbHkgY2xvbmVkL2Rlc3Ryb3llZCBieVxuICAvLyBjb250ZW50ZWRpdGFibGUgYmVoYXZpb3JzLiAoMjAxOS8wNS8wOClcblxuXG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICdkYXRhLXNsYXRlLWxlYWYnOiB0cnVlXG4gIH07XG4gIHJldHVybiByZW5kZXJMZWFmKHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuLFxuICAgIGxlYWYsXG4gICAgdGV4dFxuICB9KTtcbn07XG5cbnZhciBNZW1vaXplZExlYWYgPSAvKiNfX1BVUkVfXyovUmVhY3QubWVtbyhMZWFmLCAocHJldiwgbmV4dCkgPT4ge1xuICByZXR1cm4gbmV4dC5wYXJlbnQgPT09IHByZXYucGFyZW50ICYmIG5leHQuaXNMYXN0ID09PSBwcmV2LmlzTGFzdCAmJiBuZXh0LnJlbmRlckxlYWYgPT09IHByZXYucmVuZGVyTGVhZiAmJiBuZXh0LnJlbmRlclBsYWNlaG9sZGVyID09PSBwcmV2LnJlbmRlclBsYWNlaG9sZGVyICYmIG5leHQudGV4dCA9PT0gcHJldi50ZXh0ICYmIFRleHQkMS5lcXVhbHMobmV4dC5sZWFmLCBwcmV2LmxlYWYpICYmIG5leHQubGVhZltQTEFDRUhPTERFUl9TWU1CT0xdID09PSBwcmV2LmxlYWZbUExBQ0VIT0xERVJfU1lNQk9MXTtcbn0pO1xudmFyIERlZmF1bHRMZWFmID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW5cbiAgfSA9IHByb3BzO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIE9iamVjdC5hc3NpZ24oe30sIGF0dHJpYnV0ZXMpLCBjaGlsZHJlbik7XG59O1xuXG4vKipcclxuICogVGV4dC5cclxuICovXG5cbnZhciBUZXh0ID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGRlY29yYXRpb25zLFxuICAgIGlzTGFzdCxcbiAgICBwYXJlbnQsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZixcbiAgICB0ZXh0XG4gIH0gPSBwcm9wcztcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBsZWF2ZXMgPSBUZXh0JDEuZGVjb3JhdGlvbnModGV4dCwgZGVjb3JhdGlvbnMpO1xuICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlZGl0b3IsIHRleHQpO1xuICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlYXZlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsZWFmID0gbGVhdmVzW2ldO1xuICAgIGNoaWxkcmVuLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lbW9pemVkTGVhZiwge1xuICAgICAgaXNMYXN0OiBpc0xhc3QgJiYgaSA9PT0gbGVhdmVzLmxlbmd0aCAtIDEsXG4gICAgICBrZXk6IFwiXCIuY29uY2F0KGtleS5pZCwgXCItXCIpLmNvbmNhdChpKSxcbiAgICAgIHJlbmRlclBsYWNlaG9sZGVyOiByZW5kZXJQbGFjZWhvbGRlcixcbiAgICAgIGxlYWY6IGxlYWYsXG4gICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICByZW5kZXJMZWFmOiByZW5kZXJMZWFmXG4gICAgfSkpO1xuICB9IC8vIFVwZGF0ZSBlbGVtZW50LXJlbGF0ZWQgd2VhayBtYXBzIHdpdGggdGhlIERPTSBlbGVtZW50IHJlZi5cblxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBLRVlfVE9fRUxFTUVOVCA9IEVESVRPUl9UT19LRVlfVE9fRUxFTUVOVC5nZXQoZWRpdG9yKTtcblxuICAgIGlmIChyZWYuY3VycmVudCkge1xuICAgICAgS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IEtFWV9UT19FTEVNRU5ULnNldChrZXksIHJlZi5jdXJyZW50KTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5zZXQodGV4dCwgcmVmLmN1cnJlbnQpO1xuICAgICAgRUxFTUVOVF9UT19OT0RFLnNldChyZWYuY3VycmVudCwgdGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEtFWV9UT19FTEVNRU5UID09PSBudWxsIHx8IEtFWV9UT19FTEVNRU5UID09PSB2b2lkIDAgPyB2b2lkIDAgOiBLRVlfVE9fRUxFTUVOVC5kZWxldGUoa2V5KTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5kZWxldGUodGV4dCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgXCJkYXRhLXNsYXRlLW5vZGVcIjogXCJ0ZXh0XCIsXG4gICAgcmVmOiByZWZcbiAgfSwgY2hpbGRyZW4pO1xufTtcblxudmFyIE1lbW9pemVkVGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5tZW1vKFRleHQsIChwcmV2LCBuZXh0KSA9PiB7XG4gIHJldHVybiBuZXh0LnBhcmVudCA9PT0gcHJldi5wYXJlbnQgJiYgbmV4dC5pc0xhc3QgPT09IHByZXYuaXNMYXN0ICYmIG5leHQucmVuZGVyTGVhZiA9PT0gcHJldi5yZW5kZXJMZWFmICYmIG5leHQudGV4dCA9PT0gcHJldi50ZXh0ICYmIGlzRGVjb3JhdG9yUmFuZ2VMaXN0RXF1YWwobmV4dC5kZWNvcmF0aW9ucywgcHJldi5kZWNvcmF0aW9ucyk7XG59KTtcblxuLyoqXHJcbiAqIEVsZW1lbnQuXHJcbiAqL1xuXG52YXIgRWxlbWVudCA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBkZWNvcmF0aW9ucyxcbiAgICBlbGVtZW50LFxuICAgIHJlbmRlckVsZW1lbnQgPSBwID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERlZmF1bHRFbGVtZW50LCBPYmplY3QuYXNzaWduKHt9LCBwKSksXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgcmVuZGVyTGVhZixcbiAgICBzZWxlY3Rpb25cbiAgfSA9IHByb3BzO1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIHJlYWRPbmx5ID0gdXNlUmVhZE9ubHkoKTtcbiAgdmFyIGlzSW5saW5lID0gZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpO1xuICB2YXIga2V5ID0gUmVhY3RFZGl0b3IuZmluZEtleShlZGl0b3IsIGVsZW1lbnQpO1xuICB2YXIgcmVmID0gdXNlQ2FsbGJhY2socmVmID0+IHtcbiAgICAvLyBVcGRhdGUgZWxlbWVudC1yZWxhdGVkIHdlYWsgbWFwcyB3aXRoIHRoZSBET00gZWxlbWVudCByZWYuXG4gICAgdmFyIEtFWV9UT19FTEVNRU5UID0gRURJVE9SX1RPX0tFWV9UT19FTEVNRU5ULmdldChlZGl0b3IpO1xuXG4gICAgaWYgKHJlZikge1xuICAgICAgS0VZX1RPX0VMRU1FTlQgPT09IG51bGwgfHwgS0VZX1RPX0VMRU1FTlQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IEtFWV9UT19FTEVNRU5ULnNldChrZXksIHJlZik7XG4gICAgICBOT0RFX1RPX0VMRU1FTlQuc2V0KGVsZW1lbnQsIHJlZik7XG4gICAgICBFTEVNRU5UX1RPX05PREUuc2V0KHJlZiwgZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIEtFWV9UT19FTEVNRU5UID09PSBudWxsIHx8IEtFWV9UT19FTEVNRU5UID09PSB2b2lkIDAgPyB2b2lkIDAgOiBLRVlfVE9fRUxFTUVOVC5kZWxldGUoa2V5KTtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5kZWxldGUoZWxlbWVudCk7XG4gICAgfVxuICB9LCBbZWRpdG9yLCBrZXksIGVsZW1lbnRdKTtcbiAgdmFyIGNoaWxkcmVuID0gdXNlQ2hpbGRyZW4oe1xuICAgIGRlY29yYXRpb25zLFxuICAgIG5vZGU6IGVsZW1lbnQsXG4gICAgcmVuZGVyRWxlbWVudCxcbiAgICByZW5kZXJQbGFjZWhvbGRlcixcbiAgICByZW5kZXJMZWFmLFxuICAgIHNlbGVjdGlvblxuICB9KTsgLy8gQXR0cmlidXRlcyB0aGF0IHRoZSBkZXZlbG9wZXIgbXVzdCBtaXggaW50byB0aGUgZWxlbWVudCBpbiB0aGVpclxuICAvLyBjdXN0b20gbm9kZSByZW5kZXJlciBjb21wb25lbnQuXG5cbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ2RhdGEtc2xhdGUtbm9kZSc6ICdlbGVtZW50JyxcbiAgICByZWZcbiAgfTtcblxuICBpZiAoaXNJbmxpbmUpIHtcbiAgICBhdHRyaWJ1dGVzWydkYXRhLXNsYXRlLWlubGluZSddID0gdHJ1ZTtcbiAgfSAvLyBJZiBpdCdzIGEgYmxvY2sgbm9kZSB3aXRoIGlubGluZSBjaGlsZHJlbiwgYWRkIHRoZSBwcm9wZXIgYGRpcmAgYXR0cmlidXRlXG4gIC8vIGZvciB0ZXh0IGRpcmVjdGlvbi5cblxuXG4gIGlmICghaXNJbmxpbmUgJiYgRWRpdG9yLmhhc0lubGluZXMoZWRpdG9yLCBlbGVtZW50KSkge1xuICAgIHZhciB0ZXh0ID0gTm9kZS5zdHJpbmcoZWxlbWVudCk7XG4gICAgdmFyIGRpciA9IGdldERpcmVjdGlvbih0ZXh0KTtcblxuICAgIGlmIChkaXIgPT09ICdydGwnKSB7XG4gICAgICBhdHRyaWJ1dGVzLmRpciA9IGRpcjtcbiAgICB9XG4gIH0gLy8gSWYgaXQncyBhIHZvaWQgbm9kZSwgd3JhcCB0aGUgY2hpbGRyZW4gaW4gZXh0cmEgdm9pZC1zcGVjaWZpYyBlbGVtZW50cy5cblxuXG4gIGlmIChFZGl0b3IuaXNWb2lkKGVkaXRvciwgZWxlbWVudCkpIHtcbiAgICBhdHRyaWJ1dGVzWydkYXRhLXNsYXRlLXZvaWQnXSA9IHRydWU7XG5cbiAgICBpZiAoIXJlYWRPbmx5ICYmIGlzSW5saW5lKSB7XG4gICAgICBhdHRyaWJ1dGVzLmNvbnRlbnRFZGl0YWJsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBUYWcgPSBpc0lubGluZSA/ICdzcGFuJyA6ICdkaXYnO1xuICAgIHZhciBbW190ZXh0XV0gPSBOb2RlLnRleHRzKGVsZW1lbnQpO1xuICAgIGNoaWxkcmVuID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGFnLCB7XG4gICAgICBcImRhdGEtc2xhdGUtc3BhY2VyXCI6IHRydWUsXG4gICAgICBzdHlsZToge1xuICAgICAgICBoZWlnaHQ6ICcwJyxcbiAgICAgICAgY29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgIG91dGxpbmU6ICdub25lJyxcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICAgIH1cbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChNZW1vaXplZFRleHQsIHtcbiAgICAgIHJlbmRlclBsYWNlaG9sZGVyOiByZW5kZXJQbGFjZWhvbGRlcixcbiAgICAgIGRlY29yYXRpb25zOiBbXSxcbiAgICAgIGlzTGFzdDogZmFsc2UsXG4gICAgICBwYXJlbnQ6IGVsZW1lbnQsXG4gICAgICB0ZXh0OiBfdGV4dFxuICAgIH0pKTtcbiAgICBOT0RFX1RPX0lOREVYLnNldChfdGV4dCwgMCk7XG4gICAgTk9ERV9UT19QQVJFTlQuc2V0KF90ZXh0LCBlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiByZW5kZXJFbGVtZW50KHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuLFxuICAgIGVsZW1lbnRcbiAgfSk7XG59O1xuXG52YXIgTWVtb2l6ZWRFbGVtZW50ID0gLyojX19QVVJFX18qL1JlYWN0Lm1lbW8oRWxlbWVudCwgKHByZXYsIG5leHQpID0+IHtcbiAgcmV0dXJuIHByZXYuZWxlbWVudCA9PT0gbmV4dC5lbGVtZW50ICYmIHByZXYucmVuZGVyRWxlbWVudCA9PT0gbmV4dC5yZW5kZXJFbGVtZW50ICYmIHByZXYucmVuZGVyTGVhZiA9PT0gbmV4dC5yZW5kZXJMZWFmICYmIGlzRGVjb3JhdG9yUmFuZ2VMaXN0RXF1YWwocHJldi5kZWNvcmF0aW9ucywgbmV4dC5kZWNvcmF0aW9ucykgJiYgKHByZXYuc2VsZWN0aW9uID09PSBuZXh0LnNlbGVjdGlvbiB8fCAhIXByZXYuc2VsZWN0aW9uICYmICEhbmV4dC5zZWxlY3Rpb24gJiYgUmFuZ2UuZXF1YWxzKHByZXYuc2VsZWN0aW9uLCBuZXh0LnNlbGVjdGlvbikpO1xufSk7XG4vKipcclxuICogVGhlIGRlZmF1bHQgZWxlbWVudCByZW5kZXJlci5cclxuICovXG5cbnZhciBEZWZhdWx0RWxlbWVudCA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBhdHRyaWJ1dGVzLFxuICAgIGNoaWxkcmVuLFxuICAgIGVsZW1lbnRcbiAgfSA9IHByb3BzO1xuICB2YXIgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKTtcbiAgdmFyIFRhZyA9IGVkaXRvci5pc0lubGluZShlbGVtZW50KSA/ICdzcGFuJyA6ICdkaXYnO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVGFnLCBPYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgfVxuICB9KSwgY2hpbGRyZW4pO1xufTtcblxuLyoqXHJcbiAqIEEgUmVhY3QgY29udGV4dCBmb3Igc2hhcmluZyB0aGUgYGRlY29yYXRlYCBwcm9wIG9mIHRoZSBlZGl0YWJsZS5cclxuICovXG5cbnZhciBEZWNvcmF0ZUNvbnRleHQgPSAvKiNfX1BVUkVfXyovY3JlYXRlQ29udGV4dCgoKSA9PiBbXSk7XG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IGBkZWNvcmF0ZWAgcHJvcCBvZiB0aGUgZWRpdGFibGUuXHJcbiAqL1xuXG52YXIgdXNlRGVjb3JhdGUgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KERlY29yYXRlQ29udGV4dCk7XG59O1xuXG4vKipcclxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgc2VsZWN0ZWRgIHN0YXRlIG9mIGFuIGVsZW1lbnQuXHJcbiAqL1xuXG52YXIgU2VsZWN0ZWRDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoZmFsc2UpO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBgc2VsZWN0ZWRgIHN0YXRlIG9mIGFuIGVsZW1lbnQuXHJcbiAqL1xuXG52YXIgdXNlU2VsZWN0ZWQgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KFNlbGVjdGVkQ29udGV4dCk7XG59O1xuXG4vKipcclxuICogQ2hpbGRyZW4uXHJcbiAqL1xuXG52YXIgdXNlQ2hpbGRyZW4gPSBwcm9wcyA9PiB7XG4gIHZhciB7XG4gICAgZGVjb3JhdGlvbnMsXG4gICAgbm9kZSxcbiAgICByZW5kZXJFbGVtZW50LFxuICAgIHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWYsXG4gICAgc2VsZWN0aW9uXG4gIH0gPSBwcm9wcztcbiAgdmFyIGRlY29yYXRlID0gdXNlRGVjb3JhdGUoKTtcbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTtcbiAgdmFyIGNoaWxkcmVuID0gW107XG4gIHZhciBpc0xlYWZCbG9jayA9IEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc0lubGluZShub2RlKSAmJiBFZGl0b3IuaGFzSW5saW5lcyhlZGl0b3IsIG5vZGUpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwID0gcGF0aC5jb25jYXQoaSk7XG4gICAgdmFyIG4gPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgIHZhciBrZXkgPSBSZWFjdEVkaXRvci5maW5kS2V5KGVkaXRvciwgbik7XG4gICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcCk7XG4gICAgdmFyIHNlbCA9IHNlbGVjdGlvbiAmJiBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2UsIHNlbGVjdGlvbik7XG4gICAgdmFyIGRzID0gZGVjb3JhdGUoW24sIHBdKTtcblxuICAgIGZvciAodmFyIGRlYyBvZiBkZWNvcmF0aW9ucykge1xuICAgICAgdmFyIGQgPSBSYW5nZS5pbnRlcnNlY3Rpb24oZGVjLCByYW5nZSk7XG5cbiAgICAgIGlmIChkKSB7XG4gICAgICAgIGRzLnB1c2goZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobikpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFNlbGVjdGVkQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICBrZXk6IFwicHJvdmlkZXItXCIuY29uY2F0KGtleS5pZCksXG4gICAgICAgIHZhbHVlOiAhIXNlbFxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTWVtb2l6ZWRFbGVtZW50LCB7XG4gICAgICAgIGRlY29yYXRpb25zOiBkcyxcbiAgICAgICAgZWxlbWVudDogbixcbiAgICAgICAga2V5OiBrZXkuaWQsXG4gICAgICAgIHJlbmRlckVsZW1lbnQ6IHJlbmRlckVsZW1lbnQsXG4gICAgICAgIHJlbmRlclBsYWNlaG9sZGVyOiByZW5kZXJQbGFjZWhvbGRlcixcbiAgICAgICAgcmVuZGVyTGVhZjogcmVuZGVyTGVhZixcbiAgICAgICAgc2VsZWN0aW9uOiBzZWxcbiAgICAgIH0pKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkcmVuLnB1c2goIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE1lbW9pemVkVGV4dCwge1xuICAgICAgICBkZWNvcmF0aW9uczogZHMsXG4gICAgICAgIGtleToga2V5LmlkLFxuICAgICAgICBpc0xhc3Q6IGlzTGVhZkJsb2NrICYmIGkgPT09IG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSxcbiAgICAgICAgcGFyZW50OiBub2RlLFxuICAgICAgICByZW5kZXJQbGFjZWhvbGRlcjogcmVuZGVyUGxhY2Vob2xkZXIsXG4gICAgICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgICAgIHRleHQ6IG5cbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBOT0RFX1RPX0lOREVYLnNldChuLCBpKTtcbiAgICBOT0RFX1RPX1BBUkVOVC5zZXQobiwgbm9kZSk7XG4gIH1cblxuICByZXR1cm4gY2hpbGRyZW47XG59O1xuXG4vKipcclxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgcmVhZE9ubHlgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgUmVhZE9ubHlDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQoZmFsc2UpO1xuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBgcmVhZE9ubHlgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgdXNlUmVhZE9ubHkgPSAoKSA9PiB7XG4gIHJldHVybiB1c2VDb250ZXh0KFJlYWRPbmx5Q29udGV4dCk7XG59O1xuXG52YXIgU2xhdGVDb250ZXh0ID0gLyojX19QVVJFX18qL2NyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBvYmplY3QgZnJvbSB0aGUgUmVhY3QgY29udGV4dC5cclxuICovXG5cbnZhciB1c2VTbGF0ZSA9ICgpID0+IHtcbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KFNsYXRlQ29udGV4dCk7XG5cbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGB1c2VTbGF0ZWAgaG9vayBtdXN0IGJlIHVzZWQgaW5zaWRlIHRoZSA8U2xhdGU+IGNvbXBvbmVudCdzIGNvbnRleHQuXCIpO1xuICB9XG5cbiAgdmFyIHtcbiAgICBlZGl0b3JcbiAgfSA9IGNvbnRleHQ7XG4gIHJldHVybiBlZGl0b3I7XG59O1xudmFyIHVzZVNsYXRlV2l0aFYgPSAoKSA9PiB7XG4gIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChTbGF0ZUNvbnRleHQpO1xuXG4gIGlmICghY29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlU2xhdGVgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuXG4gIHJldHVybiBjb250ZXh0O1xufTtcblxudmFyIFRSSVBMRV9DTElDSyA9IDM7XG5cbi8qKlxyXG4gKiBIb3RrZXkgbWFwcGluZ3MgZm9yIGVhY2ggcGxhdGZvcm0uXHJcbiAqL1xuXG52YXIgSE9US0VZUyA9IHtcbiAgYm9sZDogJ21vZCtiJyxcbiAgY29tcG9zZTogWydkb3duJywgJ2xlZnQnLCAncmlnaHQnLCAndXAnLCAnYmFja3NwYWNlJywgJ2VudGVyJ10sXG4gIG1vdmVCYWNrd2FyZDogJ2xlZnQnLFxuICBtb3ZlRm9yd2FyZDogJ3JpZ2h0JyxcbiAgbW92ZVdvcmRCYWNrd2FyZDogJ2N0cmwrbGVmdCcsXG4gIG1vdmVXb3JkRm9yd2FyZDogJ2N0cmwrcmlnaHQnLFxuICBkZWxldGVCYWNrd2FyZDogJ3NoaWZ0PytiYWNrc3BhY2UnLFxuICBkZWxldGVGb3J3YXJkOiAnc2hpZnQ/K2RlbGV0ZScsXG4gIGV4dGVuZEJhY2t3YXJkOiAnc2hpZnQrbGVmdCcsXG4gIGV4dGVuZEZvcndhcmQ6ICdzaGlmdCtyaWdodCcsXG4gIGl0YWxpYzogJ21vZCtpJyxcbiAgaW5zZXJ0U29mdEJyZWFrOiAnc2hpZnQrZW50ZXInLFxuICBzcGxpdEJsb2NrOiAnZW50ZXInLFxuICB1bmRvOiAnbW9kK3onXG59O1xudmFyIEFQUExFX0hPVEtFWVMgPSB7XG4gIG1vdmVMaW5lQmFja3dhcmQ6ICdvcHQrdXAnLFxuICBtb3ZlTGluZUZvcndhcmQ6ICdvcHQrZG93bicsXG4gIG1vdmVXb3JkQmFja3dhcmQ6ICdvcHQrbGVmdCcsXG4gIG1vdmVXb3JkRm9yd2FyZDogJ29wdCtyaWdodCcsXG4gIGRlbGV0ZUJhY2t3YXJkOiBbJ2N0cmwrYmFja3NwYWNlJywgJ2N0cmwraCddLFxuICBkZWxldGVGb3J3YXJkOiBbJ2N0cmwrZGVsZXRlJywgJ2N0cmwrZCddLFxuICBkZWxldGVMaW5lQmFja3dhcmQ6ICdjbWQrc2hpZnQ/K2JhY2tzcGFjZScsXG4gIGRlbGV0ZUxpbmVGb3J3YXJkOiBbJ2NtZCtzaGlmdD8rZGVsZXRlJywgJ2N0cmwrayddLFxuICBkZWxldGVXb3JkQmFja3dhcmQ6ICdvcHQrc2hpZnQ/K2JhY2tzcGFjZScsXG4gIGRlbGV0ZVdvcmRGb3J3YXJkOiAnb3B0K3NoaWZ0PytkZWxldGUnLFxuICBleHRlbmRMaW5lQmFja3dhcmQ6ICdvcHQrc2hpZnQrdXAnLFxuICBleHRlbmRMaW5lRm9yd2FyZDogJ29wdCtzaGlmdCtkb3duJyxcbiAgcmVkbzogJ2NtZCtzaGlmdCt6JyxcbiAgdHJhbnNwb3NlQ2hhcmFjdGVyOiAnY3RybCt0J1xufTtcbnZhciBXSU5ET1dTX0hPVEtFWVMgPSB7XG4gIGRlbGV0ZVdvcmRCYWNrd2FyZDogJ2N0cmwrc2hpZnQ/K2JhY2tzcGFjZScsXG4gIGRlbGV0ZVdvcmRGb3J3YXJkOiAnY3RybCtzaGlmdD8rZGVsZXRlJyxcbiAgcmVkbzogWydjdHJsK3knLCAnY3RybCtzaGlmdCt6J11cbn07XG4vKipcclxuICogQ3JlYXRlIGEgcGxhdGZvcm0tYXdhcmUgaG90a2V5IGNoZWNrZXIuXHJcbiAqL1xuXG52YXIgY3JlYXRlID0ga2V5ID0+IHtcbiAgdmFyIGdlbmVyaWMgPSBIT1RLRVlTW2tleV07XG4gIHZhciBhcHBsZSA9IEFQUExFX0hPVEtFWVNba2V5XTtcbiAgdmFyIHdpbmRvd3MgPSBXSU5ET1dTX0hPVEtFWVNba2V5XTtcbiAgdmFyIGlzR2VuZXJpYyA9IGdlbmVyaWMgJiYgaXNLZXlIb3RrZXkoZ2VuZXJpYyk7XG4gIHZhciBpc0FwcGxlID0gYXBwbGUgJiYgaXNLZXlIb3RrZXkoYXBwbGUpO1xuICB2YXIgaXNXaW5kb3dzID0gd2luZG93cyAmJiBpc0tleUhvdGtleSh3aW5kb3dzKTtcbiAgcmV0dXJuIGV2ZW50ID0+IHtcbiAgICBpZiAoaXNHZW5lcmljICYmIGlzR2VuZXJpYyhldmVudCkpIHJldHVybiB0cnVlO1xuICAgIGlmIChJU19BUFBMRSAmJiBpc0FwcGxlICYmIGlzQXBwbGUoZXZlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIUlTX0FQUExFICYmIGlzV2luZG93cyAmJiBpc1dpbmRvd3MoZXZlbnQpKSByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59O1xuLyoqXHJcbiAqIEhvdGtleXMuXHJcbiAqL1xuXG5cbnZhciBIb3RrZXlzID0ge1xuICBpc0JvbGQ6IGNyZWF0ZSgnYm9sZCcpLFxuICBpc0NvbXBvc2U6IGNyZWF0ZSgnY29tcG9zZScpLFxuICBpc01vdmVCYWNrd2FyZDogY3JlYXRlKCdtb3ZlQmFja3dhcmQnKSxcbiAgaXNNb3ZlRm9yd2FyZDogY3JlYXRlKCdtb3ZlRm9yd2FyZCcpLFxuICBpc0RlbGV0ZUJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZUJhY2t3YXJkJyksXG4gIGlzRGVsZXRlRm9yd2FyZDogY3JlYXRlKCdkZWxldGVGb3J3YXJkJyksXG4gIGlzRGVsZXRlTGluZUJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZUxpbmVCYWNrd2FyZCcpLFxuICBpc0RlbGV0ZUxpbmVGb3J3YXJkOiBjcmVhdGUoJ2RlbGV0ZUxpbmVGb3J3YXJkJyksXG4gIGlzRGVsZXRlV29yZEJhY2t3YXJkOiBjcmVhdGUoJ2RlbGV0ZVdvcmRCYWNrd2FyZCcpLFxuICBpc0RlbGV0ZVdvcmRGb3J3YXJkOiBjcmVhdGUoJ2RlbGV0ZVdvcmRGb3J3YXJkJyksXG4gIGlzRXh0ZW5kQmFja3dhcmQ6IGNyZWF0ZSgnZXh0ZW5kQmFja3dhcmQnKSxcbiAgaXNFeHRlbmRGb3J3YXJkOiBjcmVhdGUoJ2V4dGVuZEZvcndhcmQnKSxcbiAgaXNFeHRlbmRMaW5lQmFja3dhcmQ6IGNyZWF0ZSgnZXh0ZW5kTGluZUJhY2t3YXJkJyksXG4gIGlzRXh0ZW5kTGluZUZvcndhcmQ6IGNyZWF0ZSgnZXh0ZW5kTGluZUZvcndhcmQnKSxcbiAgaXNJdGFsaWM6IGNyZWF0ZSgnaXRhbGljJyksXG4gIGlzTW92ZUxpbmVCYWNrd2FyZDogY3JlYXRlKCdtb3ZlTGluZUJhY2t3YXJkJyksXG4gIGlzTW92ZUxpbmVGb3J3YXJkOiBjcmVhdGUoJ21vdmVMaW5lRm9yd2FyZCcpLFxuICBpc01vdmVXb3JkQmFja3dhcmQ6IGNyZWF0ZSgnbW92ZVdvcmRCYWNrd2FyZCcpLFxuICBpc01vdmVXb3JkRm9yd2FyZDogY3JlYXRlKCdtb3ZlV29yZEZvcndhcmQnKSxcbiAgaXNSZWRvOiBjcmVhdGUoJ3JlZG8nKSxcbiAgaXNTb2Z0QnJlYWs6IGNyZWF0ZSgnaW5zZXJ0U29mdEJyZWFrJyksXG4gIGlzU3BsaXRCbG9jazogY3JlYXRlKCdzcGxpdEJsb2NrJyksXG4gIGlzVHJhbnNwb3NlQ2hhcmFjdGVyOiBjcmVhdGUoJ3RyYW5zcG9zZUNoYXJhY3RlcicpLFxuICBpc1VuZG86IGNyZWF0ZSgndW5kbycpXG59O1xuXG52YXIgY3JlYXRlUmVzdG9yZURvbU1hbmFnZXIgPSAoZWRpdG9yLCByZWNlaXZlZFVzZXJJbnB1dCkgPT4ge1xuICB2YXIgYnVmZmVyZWRNdXRhdGlvbnMgPSBbXTtcblxuICB2YXIgY2xlYXIgPSAoKSA9PiB7XG4gICAgYnVmZmVyZWRNdXRhdGlvbnMgPSBbXTtcbiAgfTtcblxuICB2YXIgcmVnaXN0ZXJNdXRhdGlvbnMgPSBtdXRhdGlvbnMgPT4ge1xuICAgIGlmICghcmVjZWl2ZWRVc2VySW5wdXQuY3VycmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0cmFja2VkTXV0YXRpb25zID0gbXV0YXRpb25zLmZpbHRlcihtdXRhdGlvbiA9PiBpc1RyYWNrZWRNdXRhdGlvbihlZGl0b3IsIG11dGF0aW9uLCBtdXRhdGlvbnMpKTtcbiAgICBidWZmZXJlZE11dGF0aW9ucy5wdXNoKC4uLnRyYWNrZWRNdXRhdGlvbnMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlc3RvcmVET00oKSB7XG4gICAgYnVmZmVyZWRNdXRhdGlvbnMucmV2ZXJzZSgpLmZvckVhY2gobXV0YXRpb24gPT4ge1xuICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdjaGFyYWN0ZXJEYXRhJykge1xuICAgICAgICBtdXRhdGlvbi50YXJnZXQudGV4dENvbnRlbnQgPSBtdXRhdGlvbi5vbGRWYWx1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBtdXRhdGlvbi5yZW1vdmVkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgbXV0YXRpb24udGFyZ2V0Lmluc2VydEJlZm9yZShub2RlLCBtdXRhdGlvbi5uZXh0U2libGluZyk7XG4gICAgICB9KTtcbiAgICAgIG11dGF0aW9uLmFkZGVkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgbXV0YXRpb24udGFyZ2V0LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgfSk7XG4gICAgfSk7IC8vIENsZWFyIGJ1ZmZlcmVkIG11dGF0aW9ucyB0byBlbnN1cmUgd2UgZG9uJ3QgdW5kbyB0aGVtIHR3aWNlXG5cbiAgICBjbGVhcigpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZWdpc3Rlck11dGF0aW9ucyxcbiAgICByZXN0b3JlRE9NLFxuICAgIGNsZWFyXG4gIH07XG59O1xuXG52YXIgTVVUQVRJT05fT0JTRVJWRVJfQ09ORklHJDEgPSB7XG4gIHN1YnRyZWU6IHRydWUsXG4gIGNoaWxkTGlzdDogdHJ1ZSxcbiAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlXG59OyAvLyBXZSBoYXZlIHRvIHVzZSBhIGNsYXNzIGNvbXBvbmVudCBoZXJlIHNpbmNlIHdlIHJlbHkgb24gYGdldFNuYXBzaG90QmVmb3JlVXBkYXRlYCB3aGljaCBoYXMgbm8gRkMgZXF1aXZhbGVudFxuLy8gdG8gcnVuIGNvZGUgc3luY2hyb25vdXNseSBpbW1lZGlhdGVseSBiZWZvcmUgcmVhY3QgY29tbWl0cyB0aGUgY29tcG9uZW50IHVwZGF0ZSB0byB0aGUgRE9NLlxuXG5jbGFzcyBSZXN0b3JlRE9NQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMubWFuYWdlciA9IG51bGw7XG4gICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyID0gbnVsbDtcbiAgfVxuXG4gIG9ic2VydmUoKSB7XG4gICAgdmFyIF90aGlzJG11dGF0aW9uT2JzZXJ2ZTtcblxuICAgIHZhciB7XG4gICAgICBub2RlXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoIW5vZGUuY3VycmVudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gYXR0YWNoIE11dGF0aW9uT2JzZXJ2ZXIsIGBub2RlYCBpcyB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICAoX3RoaXMkbXV0YXRpb25PYnNlcnZlID0gdGhpcy5tdXRhdGlvbk9ic2VydmVyKSA9PT0gbnVsbCB8fCBfdGhpcyRtdXRhdGlvbk9ic2VydmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG11dGF0aW9uT2JzZXJ2ZS5vYnNlcnZlKG5vZGUuY3VycmVudCwgTVVUQVRJT05fT0JTRVJWRVJfQ09ORklHJDEpO1xuICB9XG5cbiAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdmFyIHtcbiAgICAgIHJlY2VpdmVkVXNlcklucHV0XG4gICAgfSA9IHRoaXMucHJvcHM7XG4gICAgdmFyIGVkaXRvciA9IHRoaXMuY29udGV4dDtcbiAgICB0aGlzLm1hbmFnZXIgPSBjcmVhdGVSZXN0b3JlRG9tTWFuYWdlcihlZGl0b3IsIHJlY2VpdmVkVXNlcklucHV0KTtcbiAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLm1hbmFnZXIucmVnaXN0ZXJNdXRhdGlvbnMpO1xuICAgIHRoaXMub2JzZXJ2ZSgpO1xuICB9XG5cbiAgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSB7XG4gICAgdmFyIF90aGlzJG11dGF0aW9uT2JzZXJ2ZTIsIF90aGlzJG11dGF0aW9uT2JzZXJ2ZTMsIF90aGlzJG1hbmFnZXIyO1xuXG4gICAgdmFyIHBlbmRpbmdNdXRhdGlvbnMgPSAoX3RoaXMkbXV0YXRpb25PYnNlcnZlMiA9IHRoaXMubXV0YXRpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbXV0YXRpb25PYnNlcnZlMi50YWtlUmVjb3JkcygpO1xuXG4gICAgaWYgKHBlbmRpbmdNdXRhdGlvbnMgIT09IG51bGwgJiYgcGVuZGluZ011dGF0aW9ucyAhPT0gdm9pZCAwICYmIHBlbmRpbmdNdXRhdGlvbnMubGVuZ3RoKSB7XG4gICAgICB2YXIgX3RoaXMkbWFuYWdlcjtcblxuICAgICAgKF90aGlzJG1hbmFnZXIgPSB0aGlzLm1hbmFnZXIpID09PSBudWxsIHx8IF90aGlzJG1hbmFnZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG1hbmFnZXIucmVnaXN0ZXJNdXRhdGlvbnMocGVuZGluZ011dGF0aW9ucyk7XG4gICAgfVxuXG4gICAgKF90aGlzJG11dGF0aW9uT2JzZXJ2ZTMgPSB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG11dGF0aW9uT2JzZXJ2ZTMuZGlzY29ubmVjdCgpO1xuICAgIChfdGhpcyRtYW5hZ2VyMiA9IHRoaXMubWFuYWdlcikgPT09IG51bGwgfHwgX3RoaXMkbWFuYWdlcjIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG1hbmFnZXIyLnJlc3RvcmVET00oKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMkbWFuYWdlcjM7XG5cbiAgICAoX3RoaXMkbWFuYWdlcjMgPSB0aGlzLm1hbmFnZXIpID09PSBudWxsIHx8IF90aGlzJG1hbmFnZXIzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRtYW5hZ2VyMy5jbGVhcigpO1xuICAgIHRoaXMub2JzZXJ2ZSgpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdmFyIF90aGlzJG11dGF0aW9uT2JzZXJ2ZTQ7XG5cbiAgICAoX3RoaXMkbXV0YXRpb25PYnNlcnZlNCA9IHRoaXMubXV0YXRpb25PYnNlcnZlcikgPT09IG51bGwgfHwgX3RoaXMkbXV0YXRpb25PYnNlcnZlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkbXV0YXRpb25PYnNlcnZlNC5kaXNjb25uZWN0KCk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cblxufVxuXG5SZXN0b3JlRE9NQ29tcG9uZW50LmNvbnRleHRUeXBlID0gRWRpdG9yQ29udGV4dDtcbnZhciBSZXN0b3JlRE9NID0gSVNfQU5EUk9JRCA/IFJlc3RvcmVET01Db21wb25lbnQgOiBfcmVmID0+IHtcbiAgdmFyIHtcbiAgICBjaGlsZHJlblxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBjaGlsZHJlbik7XG59O1xuXG4vKipcclxuICogQ2hlY2sgd2hldGhlciBhIHRleHQgZGlmZiB3YXMgYXBwbGllZCBpbiBhIHdheSB3ZSBjYW4gcGVyZm9ybSB0aGUgcGVuZGluZyBhY3Rpb24gb24gL1xyXG4gKiByZWNvdmVyIHRoZSBwZW5kaW5nIHNlbGVjdGlvbi5cclxuICovXG5cbmZ1bmN0aW9uIHZlcmlmeURpZmZTdGF0ZShlZGl0b3IsIHRleHREaWZmKSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBkaWZmXG4gIH0gPSB0ZXh0RGlmZjtcblxuICBpZiAoIUVkaXRvci5oYXNQYXRoKGVkaXRvciwgcGF0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgbm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG5cbiAgaWYgKCFUZXh0JDEuaXNUZXh0KG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGRpZmYuc3RhcnQgIT09IG5vZGUudGV4dC5sZW5ndGggfHwgZGlmZi50ZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBub2RlLnRleHQuc2xpY2UoZGlmZi5zdGFydCwgZGlmZi5zdGFydCArIGRpZmYudGV4dC5sZW5ndGgpID09PSBkaWZmLnRleHQ7XG4gIH1cblxuICB2YXIgbmV4dFBhdGggPSBQYXRoLm5leHQocGF0aCk7XG5cbiAgaWYgKCFFZGl0b3IuaGFzUGF0aChlZGl0b3IsIG5leHRQYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBuZXh0Tm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgbmV4dFBhdGgpO1xuICByZXR1cm4gVGV4dCQxLmlzVGV4dChuZXh0Tm9kZSkgJiYgbmV4dE5vZGUudGV4dC5zdGFydHNXaXRoKGRpZmYudGV4dCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5U3RyaW5nRGlmZih0ZXh0KSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBkaWZmcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgZGlmZnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIGRpZmZzLnJlZHVjZSgodGV4dCwgZGlmZikgPT4gdGV4dC5zbGljZSgwLCBkaWZmLnN0YXJ0KSArIGRpZmYudGV4dCArIHRleHQuc2xpY2UoZGlmZi5lbmQpLCB0ZXh0KTtcbn1cblxuZnVuY3Rpb24gbG9uZ2VzdENvbW1vblByZWZpeExlbmd0aChzdHIsIGFub3RoZXIpIHtcbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGFub3RoZXIubGVuZ3RoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0ci5jaGFyQXQoaSkgIT09IGFub3RoZXIuY2hhckF0KGkpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBsb25nZXN0Q29tbW9uU3VmZml4TGVuZ3RoKHN0ciwgYW5vdGhlciwgbWF4KSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBhbm90aGVyLmxlbmd0aCwgbWF4KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0ci5jaGFyQXQoc3RyLmxlbmd0aCAtIGkgLSAxKSAhPT0gYW5vdGhlci5jaGFyQXQoYW5vdGhlci5sZW5ndGggLSBpIC0gMSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBsZW5ndGg7XG59XG4vKipcclxuICogUmVtb3ZlIHJlZHVuZGFudCBjaGFuZ2VzIGZyb20gdGhlIGRpZmYgc28gdGhhdCBpdCBzcGFucyB0aGUgbWluaW1hbCBwb3NzaWJsZSByYW5nZVxyXG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdEaWZmKHRhcmdldFRleHQsIGRpZmYpIHtcbiAgdmFyIHtcbiAgICBzdGFydCxcbiAgICBlbmQsXG4gICAgdGV4dFxuICB9ID0gZGlmZjtcbiAgdmFyIHJlbW92ZWRUZXh0ID0gdGFyZ2V0VGV4dC5zbGljZShzdGFydCwgZW5kKTtcbiAgdmFyIHByZWZpeExlbmd0aCA9IGxvbmdlc3RDb21tb25QcmVmaXhMZW5ndGgocmVtb3ZlZFRleHQsIHRleHQpO1xuICB2YXIgbWF4ID0gTWF0aC5taW4ocmVtb3ZlZFRleHQubGVuZ3RoIC0gcHJlZml4TGVuZ3RoLCB0ZXh0Lmxlbmd0aCAtIHByZWZpeExlbmd0aCk7XG4gIHZhciBzdWZmaXhMZW5ndGggPSBsb25nZXN0Q29tbW9uU3VmZml4TGVuZ3RoKHJlbW92ZWRUZXh0LCB0ZXh0LCBtYXgpO1xuICB2YXIgbm9ybWFsaXplZCA9IHtcbiAgICBzdGFydDogc3RhcnQgKyBwcmVmaXhMZW5ndGgsXG4gICAgZW5kOiBlbmQgLSBzdWZmaXhMZW5ndGgsXG4gICAgdGV4dDogdGV4dC5zbGljZShwcmVmaXhMZW5ndGgsIHRleHQubGVuZ3RoIC0gc3VmZml4TGVuZ3RoKVxuICB9O1xuXG4gIGlmIChub3JtYWxpemVkLnN0YXJ0ID09PSBub3JtYWxpemVkLmVuZCAmJiBub3JtYWxpemVkLnRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gbm9ybWFsaXplZDtcbn1cbi8qKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgZGlmZiB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gYXBwbHlpbmcgYiBhZnRlciBhIHNwYW5uaW5nIHRoZSByYW5nZSBvZlxyXG4gKiBib3RoIGNoYW5nZXNcclxuICovXG5cbmZ1bmN0aW9uIG1lcmdlU3RyaW5nRGlmZnModGFyZ2V0VGV4dCwgYSwgYikge1xuICB2YXIgc3RhcnQgPSBNYXRoLm1pbihhLnN0YXJ0LCBiLnN0YXJ0KTtcbiAgdmFyIG92ZXJsYXAgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihhLnN0YXJ0ICsgYS50ZXh0Lmxlbmd0aCwgYi5lbmQpIC0gYi5zdGFydCk7XG4gIHZhciBhcHBsaWVkID0gYXBwbHlTdHJpbmdEaWZmKHRhcmdldFRleHQsIGEsIGIpO1xuICB2YXIgc2xpY2VFbmQgPSBNYXRoLm1heChiLnN0YXJ0ICsgYi50ZXh0Lmxlbmd0aCwgYS5zdGFydCArIGEudGV4dC5sZW5ndGggKyAoYS5zdGFydCArIGEudGV4dC5sZW5ndGggPiBiLnN0YXJ0ID8gYi50ZXh0Lmxlbmd0aCA6IDApIC0gb3ZlcmxhcCk7XG4gIHZhciB0ZXh0ID0gYXBwbGllZC5zbGljZShzdGFydCwgc2xpY2VFbmQpO1xuICB2YXIgZW5kID0gTWF0aC5tYXgoYS5lbmQsIGIuZW5kIC0gYS50ZXh0Lmxlbmd0aCArIChhLmVuZCAtIGEuc3RhcnQpKTtcbiAgcmV0dXJuIG5vcm1hbGl6ZVN0cmluZ0RpZmYodGFyZ2V0VGV4dCwge1xuICAgIHN0YXJ0LFxuICAgIGVuZCxcbiAgICB0ZXh0XG4gIH0pO1xufVxuLyoqXHJcbiAqIEdldCB0aGUgc2xhdGUgcmFuZ2UgdGhlIHRleHQgZGlmZiBzcGFucy5cclxuICovXG5cbmZ1bmN0aW9uIHRhcmdldFJhbmdlKHRleHREaWZmKSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBkaWZmXG4gIH0gPSB0ZXh0RGlmZjtcbiAgcmV0dXJuIHtcbiAgICBhbmNob3I6IHtcbiAgICAgIHBhdGgsXG4gICAgICBvZmZzZXQ6IGRpZmYuc3RhcnRcbiAgICB9LFxuICAgIGZvY3VzOiB7XG4gICAgICBwYXRoLFxuICAgICAgb2Zmc2V0OiBkaWZmLmVuZFxuICAgIH1cbiAgfTtcbn1cbi8qKlxyXG4gKiBOb3JtYWxpemUgYSAncGVuZGluZyBwb2ludCcgYS5rLmEgYSBwb2ludCBiYXNlZCBvbiB0aGUgZG9tIHN0YXRlIGJlZm9yZSBhcHBseWluZ1xyXG4gKiB0aGUgcGVuZGluZyBkaWZmcy4gU2luY2UgdGhlIHBlbmRpbmcgZGlmZnMgbWlnaHQgaGF2ZSBiZWVuIGluc2VydGVkIHdpdGggZGlmZmVyZW50XHJcbiAqIG1hcmtzIHdlIGhhdmUgdG8gJ3dhbGsnIHRoZSBvZmZzZXQgZnJvbSB0aGUgc3RhcnRpbmcgcG9zaXRpb24gdG8gZW5zdXJlIHdlIHN0aWxsXHJcbiAqIGhhdmUgYSB2YWxpZCBwb2ludCBpbnNpZGUgdGhlIGRvY3VtZW50XHJcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVQb2ludChlZGl0b3IsIHBvaW50KSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBvZmZzZXRcbiAgfSA9IHBvaW50O1xuXG4gIGlmICghRWRpdG9yLmhhc1BhdGgoZWRpdG9yLCBwYXRoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGxlYWYgPSBOb2RlLmdldChlZGl0b3IsIHBhdGgpO1xuXG4gIGlmICghVGV4dCQxLmlzVGV4dChsZWFmKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHBhcmVudEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgYXQ6IHBhdGhcbiAgfSk7XG5cbiAgaWYgKCFwYXJlbnRCbG9jaykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgd2hpbGUgKG9mZnNldCA+IGxlYWYudGV4dC5sZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBFZGl0b3IubmV4dChlZGl0b3IsIHtcbiAgICAgIGF0OiBwYXRoLFxuICAgICAgbWF0Y2g6IFRleHQkMS5pc1RleHRcbiAgICB9KTtcblxuICAgIGlmICghZW50cnkgfHwgIVBhdGguaXNEZXNjZW5kYW50KGVudHJ5WzFdLCBwYXJlbnRCbG9ja1sxXSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIG9mZnNldCAtPSBsZWFmLnRleHQubGVuZ3RoO1xuICAgIGxlYWYgPSBlbnRyeVswXTtcbiAgICBwYXRoID0gZW50cnlbMV07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGgsXG4gICAgb2Zmc2V0XG4gIH07XG59XG4vKipcclxuICogTm9ybWFsaXplIGEgJ3BlbmRpbmcgc2VsZWN0aW9uJyB0byBlbnN1cmUgaXQncyB2YWxpZCBpbiB0aGUgY3VycmVudCBkb2N1bWVudCBzdGF0ZS5cclxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgdmFyIGFuY2hvciA9IG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgcmFuZ2UuYW5jaG9yKTtcblxuICBpZiAoIWFuY2hvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIHJldHVybiB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1czogYW5jaG9yXG4gICAgfTtcbiAgfVxuXG4gIHZhciBmb2N1cyA9IG5vcm1hbGl6ZVBvaW50KGVkaXRvciwgcmFuZ2UuZm9jdXMpO1xuXG4gIGlmICghZm9jdXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYW5jaG9yLFxuICAgIGZvY3VzXG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1QZW5kaW5nUG9pbnQoZWRpdG9yLCBwb2ludCwgb3ApIHtcbiAgdmFyIHBlbmRpbmdEaWZmcyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpO1xuICB2YXIgdGV4dERpZmYgPSBwZW5kaW5nRGlmZnMgPT09IG51bGwgfHwgcGVuZGluZ0RpZmZzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZW5kaW5nRGlmZnMuZmluZChfcmVmID0+IHtcbiAgICB2YXIge1xuICAgICAgcGF0aFxuICAgIH0gPSBfcmVmO1xuICAgIHJldHVybiBQYXRoLmVxdWFscyhwYXRoLCBwb2ludC5wYXRoKTtcbiAgfSk7XG5cbiAgaWYgKCF0ZXh0RGlmZiB8fCBwb2ludC5vZmZzZXQgPD0gdGV4dERpZmYuZGlmZi5zdGFydCkge1xuICAgIHJldHVybiBQb2ludC50cmFuc2Zvcm0ocG9pbnQsIG9wLCB7XG4gICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHtcbiAgICBkaWZmXG4gIH0gPSB0ZXh0RGlmZjsgLy8gUG9pbnQgcmVmZXJlbmNlcyBsb2NhdGlvbiBpbnNpZGUgdGhlIGRpZmYgPT4gdHJhbnNmb3JtIHRoZSBwb2ludCBiYXNlZCBvbiB0aGUgbG9jYXRpb25cbiAgLy8gdGhlIGRpZmYgd2lsbCBiZSBhcHBsaWVkIHRvIGFuZCBhZGQgdGhlIG9mZnNldCBpbnNpZGUgdGhlIGRpZmYuXG5cbiAgaWYgKHBvaW50Lm9mZnNldCA8PSBkaWZmLnN0YXJ0ICsgZGlmZi50ZXh0Lmxlbmd0aCkge1xuICAgIHZhciBfYW5jaG9yID0ge1xuICAgICAgcGF0aDogcG9pbnQucGF0aCxcbiAgICAgIG9mZnNldDogZGlmZi5zdGFydFxuICAgIH07XG5cbiAgICB2YXIgX3RyYW5zZm9ybWVkID0gUG9pbnQudHJhbnNmb3JtKF9hbmNob3IsIG9wLCB7XG4gICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgIH0pO1xuXG4gICAgaWYgKCFfdHJhbnNmb3JtZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBfdHJhbnNmb3JtZWQucGF0aCxcbiAgICAgIG9mZnNldDogX3RyYW5zZm9ybWVkLm9mZnNldCArIHBvaW50Lm9mZnNldCAtIGRpZmYuc3RhcnRcbiAgICB9O1xuICB9IC8vIFBvaW50IHJlZmVyZW5jZXMgbG9jYXRpb24gYWZ0ZXIgdGhlIGRpZmZcblxuXG4gIHZhciBhbmNob3IgPSB7XG4gICAgcGF0aDogcG9pbnQucGF0aCxcbiAgICBvZmZzZXQ6IHBvaW50Lm9mZnNldCAtIGRpZmYudGV4dC5sZW5ndGggKyBkaWZmLmVuZCAtIGRpZmYuc3RhcnRcbiAgfTtcbiAgdmFyIHRyYW5zZm9ybWVkID0gUG9pbnQudHJhbnNmb3JtKGFuY2hvciwgb3AsIHtcbiAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICB9KTtcblxuICBpZiAoIXRyYW5zZm9ybWVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAob3AudHlwZSA9PT0gJ3NwbGl0X25vZGUnICYmIFBhdGguZXF1YWxzKG9wLnBhdGgsIHBvaW50LnBhdGgpICYmIGFuY2hvci5vZmZzZXQgPCBvcC5wb3NpdGlvbiAmJiBkaWZmLnN0YXJ0IDwgb3AucG9zaXRpb24pIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtZWQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBhdGg6IHRyYW5zZm9ybWVkLnBhdGgsXG4gICAgb2Zmc2V0OiB0cmFuc2Zvcm1lZC5vZmZzZXQgKyBkaWZmLnRleHQubGVuZ3RoIC0gZGlmZi5lbmQgKyBkaWZmLnN0YXJ0XG4gIH07XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1QZW5kaW5nUmFuZ2UoZWRpdG9yLCByYW5nZSwgb3ApIHtcbiAgdmFyIGFuY2hvciA9IHRyYW5zZm9ybVBlbmRpbmdQb2ludChlZGl0b3IsIHJhbmdlLmFuY2hvciwgb3ApO1xuXG4gIGlmICghYW5jaG9yKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzOiBhbmNob3JcbiAgICB9O1xuICB9XG5cbiAgdmFyIGZvY3VzID0gdHJhbnNmb3JtUGVuZGluZ1BvaW50KGVkaXRvciwgcmFuZ2UuZm9jdXMsIG9wKTtcblxuICBpZiAoIWZvY3VzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFuY2hvcixcbiAgICBmb2N1c1xuICB9O1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtVGV4dERpZmYodGV4dERpZmYsIG9wKSB7XG4gIHZhciB7XG4gICAgcGF0aCxcbiAgICBkaWZmLFxuICAgIGlkXG4gIH0gPSB0ZXh0RGlmZjtcblxuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICB7XG4gICAgICAgIGlmICghUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgb3Aub2Zmc2V0ID49IGRpZmYuZW5kKSB7XG4gICAgICAgICAgcmV0dXJuIHRleHREaWZmO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wLm9mZnNldCA8PSBkaWZmLnN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IG9wLnRleHQubGVuZ3RoICsgZGlmZi5zdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBvcC50ZXh0Lmxlbmd0aCArIGRpZmYuZW5kLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgKyBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGF0aFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAge1xuICAgICAgICBpZiAoIVBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpIHx8IG9wLm9mZnNldCA+PSBkaWZmLmVuZCkge1xuICAgICAgICAgIHJldHVybiB0ZXh0RGlmZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcC5vZmZzZXQgKyBvcC50ZXh0Lmxlbmd0aCA8PSBkaWZmLnN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpZmY6IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGRpZmYuc3RhcnQgLSBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCAtIG9wLnRleHQubGVuZ3RoLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCxcbiAgICAgICAgICAgIGVuZDogZGlmZi5lbmQgLSBvcC50ZXh0Lmxlbmd0aCxcbiAgICAgICAgICAgIHRleHQ6IGRpZmYudGV4dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgcGF0aFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIGlmICghUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkgfHwgb3AucG9zaXRpb24gPj0gZGlmZi5lbmQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGF0aDogUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3AsIHtcbiAgICAgICAgICAgICAgYWZmaW5pdHk6ICdiYWNrd2FyZCdcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcC5wb3NpdGlvbiA+IGRpZmYuc3RhcnQpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlmZjoge1xuICAgICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBNYXRoLm1pbihvcC5wb3NpdGlvbiwgZGlmZi5lbmQpLFxuICAgICAgICAgICAgICB0ZXh0OiBkaWZmLnRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCAtIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCAtIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoOiBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwge1xuICAgICAgICAgICAgYWZmaW5pdHk6ICdmb3J3YXJkJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaWZmLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaWZmOiB7XG4gICAgICAgICAgICBzdGFydDogZGlmZi5zdGFydCArIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgZW5kOiBkaWZmLmVuZCArIG9wLnBvc2l0aW9uLFxuICAgICAgICAgICAgdGV4dDogZGlmZi50ZXh0XG4gICAgICAgICAgfSxcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBwYXRoOiBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgfVxuXG4gIHZhciBuZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0ocGF0aCwgb3ApO1xuXG4gIGlmICghbmV3UGF0aCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkaWZmLFxuICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgaWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyQzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQzKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkMyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG4vLyBXaGVuIHVzaW5nIGtleWJvYXJkIEVuZ2xpc2ggYXNzb2NpYXRpb24gZnVuY3Rpb24sIGNvbnBvc2l0aW9uRW5kIHRyaWdnZXJlZCB0b28gZmFzdCwgcmVzdWx0aW5nIGluIGFmdGVyIGBpbnNlcnRUZXh0YCBzdGlsbCBtYWludGFpbiBhc3NvY2lhdGlvbiBzdGF0ZS5cblxudmFyIFJFU09MVkVfREVMQVkgPSAyNTsgLy8gVGltZSB3aXRoIG5vIHVzZXIgaW50ZXJhY3Rpb24gYmVmb3JlIHRoZSBjdXJyZW50IHVzZXIgYWN0aW9uIGlzIGNvbnNpZGVyZWQgYXMgZG9uZS5cblxudmFyIEZMVVNIX0RFTEFZID0gMjAwOyAvLyBSZXBsYWNlIHdpdGggYGNvbnN0IGRlYnVnID0gY29uc29sZS5sb2dgIHRvIGRlYnVnXG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuZHJvaWRJbnB1dE1hbmFnZXIoX3JlZikge1xuICB2YXIge1xuICAgIGVkaXRvcixcbiAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLFxuICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlXG4gIH0gPSBfcmVmO1xuICB2YXIgZmx1c2hpbmcgPSBmYWxzZTtcbiAgdmFyIGNvbXBvc2l0aW9uRW5kVGltZW91dElkID0gbnVsbDtcbiAgdmFyIGZsdXNoVGltZW91dElkID0gbnVsbDtcbiAgdmFyIGFjdGlvblRpbWVvdXRJZCA9IG51bGw7XG4gIHZhciBpZENvdW50ZXIgPSAwO1xuICB2YXIgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG5cbiAgdmFyIGFwcGx5UGVuZGluZ1NlbGVjdGlvbiA9ICgpID0+IHtcbiAgICB2YXIgcGVuZGluZ1NlbGVjdGlvbiA9IEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5nZXQoZWRpdG9yKTtcbiAgICBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uZGVsZXRlKGVkaXRvcik7XG5cbiAgICBpZiAocGVuZGluZ1NlbGVjdGlvbikge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVSYW5nZShlZGl0b3IsIHBlbmRpbmdTZWxlY3Rpb24pO1xuXG4gICAgICBpZiAobm9ybWFsaXplZCAmJiAoIXNlbGVjdGlvbiB8fCAhUmFuZ2UuZXF1YWxzKG5vcm1hbGl6ZWQsIHNlbGVjdGlvbikpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgbm9ybWFsaXplZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBwZXJmb3JtQWN0aW9uID0gKCkgPT4ge1xuICAgIHZhciBhY3Rpb24gPSBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZ2V0KGVkaXRvcik7XG4gICAgRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLmRlbGV0ZShlZGl0b3IpO1xuXG4gICAgaWYgKCFhY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYWN0aW9uLmF0KSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gUG9pbnQuaXNQb2ludChhY3Rpb24uYXQpID8gbm9ybWFsaXplUG9pbnQoZWRpdG9yLCBhY3Rpb24uYXQpIDogbm9ybWFsaXplUmFuZ2UoZWRpdG9yLCBhY3Rpb24uYXQpO1xuXG4gICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfdGFyZ2V0UmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCB0YXJnZXQpO1xuXG4gICAgICBpZiAoIWVkaXRvci5zZWxlY3Rpb24gfHwgIVJhbmdlLmVxdWFscyhlZGl0b3Iuc2VsZWN0aW9uLCBfdGFyZ2V0UmFuZ2UpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgdGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhY3Rpb24ucnVuKCk7XG4gIH07XG5cbiAgdmFyIGZsdXNoID0gKCkgPT4ge1xuICAgIHZhciBfRURJVE9SX1RPX1BFTkRJTkdfREk7XG5cbiAgICBpZiAoZmx1c2hUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChmbHVzaFRpbWVvdXRJZCk7XG4gICAgICBmbHVzaFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGFjdGlvblRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGFjdGlvblRpbWVvdXRJZCk7XG4gICAgICBhY3Rpb25UaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghaGFzUGVuZGluZ0RpZmZzKCkgJiYgIWhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgYXBwbHlQZW5kaW5nU2VsZWN0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiBmbHVzaGluZyA9IGZhbHNlKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICBmbHVzaGluZyA9ICdhY3Rpb24nO1xuICAgIH1cblxuICAgIHZhciBzZWxlY3Rpb25SZWYgPSBlZGl0b3Iuc2VsZWN0aW9uICYmIEVkaXRvci5yYW5nZVJlZihlZGl0b3IsIGVkaXRvci5zZWxlY3Rpb24sIHtcbiAgICAgIGFmZmluaXR5OiAnZm9yd2FyZCdcbiAgICB9KTtcbiAgICBFRElUT1JfVE9fVVNFUl9NQVJLUy5zZXQoZWRpdG9yLCBlZGl0b3IubWFya3MpO1xuICAgIGRlYnVnKCdmbHVzaCcsIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5nZXQoZWRpdG9yKSwgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpO1xuICAgIHZhciBzY2hlZHVsZVNlbGVjdGlvbkNoYW5nZSA9ICEhKChfRURJVE9SX1RPX1BFTkRJTkdfREkgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZWRpdG9yKSkgIT09IG51bGwgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJICE9PSB2b2lkIDAgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJLmxlbmd0aCk7XG4gICAgdmFyIGRpZmY7XG5cbiAgICB3aGlsZSAoZGlmZiA9IChfRURJVE9SX1RPX1BFTkRJTkdfREkyID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fUEVORElOR19ESTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9FRElUT1JfVE9fUEVORElOR19ESTJbMF0pIHtcbiAgICAgIHZhciBfRURJVE9SX1RPX1BFTkRJTkdfREkyLCBfRURJVE9SX1RPX1BFTkRJTkdfREkzO1xuXG4gICAgICB2YXIgcGVuZGluZ01hcmtzID0gRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmdldChlZGl0b3IpO1xuXG4gICAgICBpZiAocGVuZGluZ01hcmtzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICBlZGl0b3IubWFya3MgPSBwZW5kaW5nTWFya3M7XG4gICAgICB9XG5cbiAgICAgIGlmIChwZW5kaW5nTWFya3MgJiYgaW5zZXJ0UG9zaXRpb25IaW50ID09PSBmYWxzZSkge1xuICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmFuZ2UgPSB0YXJnZXRSYW5nZShkaWZmKTtcblxuICAgICAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMoZWRpdG9yLnNlbGVjdGlvbiwgcmFuZ2UpKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlmZi5kaWZmLnRleHQpIHtcbiAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBkaWZmLmRpZmYudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKTtcbiAgICAgIH0gLy8gUmVtb3ZlIGRpZmYgb25seSBhZnRlciB3ZSBoYXZlIGFwcGxpZWQgaXQgdG8gYWNjb3VudCBmb3IgaXQgd2hlbiB0cmFuc2Zvcm1pbmdcbiAgICAgIC8vIHBlbmRpbmcgcmFuZ2VzLlxuXG5cbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLnNldChlZGl0b3IsIChfRURJVE9SX1RPX1BFTkRJTkdfREkzID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fUEVORElOR19ESTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9FRElUT1JfVE9fUEVORElOR19ESTMuZmlsdGVyKF9yZWYyID0+IHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBpZCAhPT0gZGlmZi5pZDtcbiAgICAgIH0pKTtcblxuICAgICAgaWYgKCF2ZXJpZnlEaWZmU3RhdGUoZWRpdG9yLCBkaWZmKSkge1xuICAgICAgICBzY2hlZHVsZVNlbGVjdGlvbkNoYW5nZSA9IGZhbHNlO1xuICAgICAgICBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uZGVsZXRlKGVkaXRvcik7XG4gICAgICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICBmbHVzaGluZyA9ICdhY3Rpb24nOyAvLyBFbnN1cmUgd2UgZG9uJ3QgcmVzdG9yZSB0aGUgcGVuZGluZyB1c2VyIChkb20pIHNlbGVjdGlvblxuICAgICAgICAvLyBzaW5jZSB0aGUgZG9jdW1lbnQgYW5kIGRvbSBzdGF0ZSBkbyBub3QgbWF0Y2guXG5cbiAgICAgICAgRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgICAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZS5jYW5jZWwoKTtcbiAgICAgICAgc2VsZWN0aW9uUmVmID09PSBudWxsIHx8IHNlbGVjdGlvblJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VsZWN0aW9uUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGlvblJlZiA9PT0gbnVsbCB8fCBzZWxlY3Rpb25SZWYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGlvblJlZi51bnJlZigpO1xuXG4gICAgaWYgKHNlbGVjdGlvbiAmJiAhRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmdldChlZGl0b3IpICYmICghZWRpdG9yLnNlbGVjdGlvbiB8fCAhUmFuZ2UuZXF1YWxzKHNlbGVjdGlvbiwgZWRpdG9yLnNlbGVjdGlvbikpKSB7XG4gICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHNlbGVjdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKGhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgcGVyZm9ybUFjdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ09NUEFUOiBUaGUgc2VsZWN0aW9uQ2hhbmdlIGV2ZW50IGlzIGZpcmVkIGFmdGVyIHRoZSBhY3Rpb24gaXMgcGVyZm9ybWVkLFxuICAgIC8vIHNvIHdlIGhhdmUgdG8gbWFudWFsbHkgc2NoZWR1bGUgaXQgdG8gZW5zdXJlIHdlIGRvbid0ICd0aHJvdyBhd2F5JyB0aGUgc2VsZWN0aW9uXG4gICAgLy8gd2hpbGUgcmVuZGVyaW5nIGlmIHdlIGhhdmUgcGVuZGluZyBjaGFuZ2VzLlxuXG5cbiAgICBpZiAoc2NoZWR1bGVTZWxlY3Rpb25DaGFuZ2UpIHtcbiAgICAgIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UoKTtcbiAgICB9XG5cbiAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmZsdXNoKCk7XG4gICAgb25ET01TZWxlY3Rpb25DaGFuZ2UuZmx1c2goKTtcbiAgICBhcHBseVBlbmRpbmdTZWxlY3Rpb24oKTtcbiAgICB2YXIgdXNlck1hcmtzID0gRURJVE9SX1RPX1VTRVJfTUFSS1MuZ2V0KGVkaXRvcik7XG4gICAgRURJVE9SX1RPX1VTRVJfTUFSS1MuZGVsZXRlKGVkaXRvcik7XG5cbiAgICBpZiAodXNlck1hcmtzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVkaXRvci5tYXJrcyA9IHVzZXJNYXJrcztcbiAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlQ29tcG9zaXRpb25FbmQgPSBfZXZlbnQgPT4ge1xuICAgIGlmIChjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbXBvc2l0aW9uRW5kVGltZW91dElkKTtcbiAgICB9XG5cbiAgICBjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgIGZsdXNoKCk7XG4gICAgfSwgUkVTT0xWRV9ERUxBWSk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZUNvbXBvc2l0aW9uU3RhcnQgPSBfZXZlbnQgPT4ge1xuICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCB0cnVlKTtcblxuICAgIGlmIChjb21wb3NpdGlvbkVuZFRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGNvbXBvc2l0aW9uRW5kVGltZW91dElkKTtcbiAgICAgIGNvbXBvc2l0aW9uRW5kVGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSA9IGZ1bmN0aW9uIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSgpIHtcbiAgICB2YXIgZm9yY2VIaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB2YXIgcGxhY2Vob2xkZXJFbGVtZW50ID0gRURJVE9SX1RPX1BMQUNFSE9MREVSX0VMRU1FTlQuZ2V0KGVkaXRvcik7XG5cbiAgICBpZiAoIXBsYWNlaG9sZGVyRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChoYXNQZW5kaW5nRGlmZnMoKSB8fCBmb3JjZUhpZGUpIHtcbiAgICAgIHBsYWNlaG9sZGVyRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBsYWNlaG9sZGVyRWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnZGlzcGxheScpO1xuICB9O1xuXG4gIHZhciBzdG9yZURpZmYgPSAocGF0aCwgZGlmZikgPT4ge1xuICAgIHZhciBfRURJVE9SX1RPX1BFTkRJTkdfREk0O1xuICAgIHZhciBwZW5kaW5nRGlmZnMgPSAoX0VESVRPUl9UT19QRU5ESU5HX0RJNCA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlZGl0b3IpKSAhPT0gbnVsbCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREk0ICE9PSB2b2lkIDAgPyBfRURJVE9SX1RPX1BFTkRJTkdfREk0IDogW107XG4gICAgRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuc2V0KGVkaXRvciwgcGVuZGluZ0RpZmZzKTtcbiAgICB2YXIgdGFyZ2V0ID0gTm9kZS5sZWFmKGVkaXRvciwgcGF0aCk7XG4gICAgdmFyIGlkeCA9IHBlbmRpbmdEaWZmcy5maW5kSW5kZXgoY2hhbmdlID0+IFBhdGguZXF1YWxzKGNoYW5nZS5wYXRoLCBwYXRoKSk7XG5cbiAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBub3JtYWxpemVTdHJpbmdEaWZmKHRhcmdldC50ZXh0LCBkaWZmKTtcblxuICAgICAgaWYgKG5vcm1hbGl6ZWQpIHtcbiAgICAgICAgcGVuZGluZ0RpZmZzLnB1c2goe1xuICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgZGlmZixcbiAgICAgICAgICBpZDogaWRDb3VudGVyKytcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZVBsYWNlaG9sZGVyVmlzaWJpbGl0eSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtZXJnZWQgPSBtZXJnZVN0cmluZ0RpZmZzKHRhcmdldC50ZXh0LCBwZW5kaW5nRGlmZnNbaWR4XS5kaWZmLCBkaWZmKTtcblxuICAgIGlmICghbWVyZ2VkKSB7XG4gICAgICBwZW5kaW5nRGlmZnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB1cGRhdGVQbGFjZWhvbGRlclZpc2liaWxpdHkoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwZW5kaW5nRGlmZnNbaWR4XSA9IF9vYmplY3RTcHJlYWQkMyhfb2JqZWN0U3ByZWFkJDMoe30sIHBlbmRpbmdEaWZmc1tpZHhdKSwge30sIHtcbiAgICAgIGRpZmY6IG1lcmdlZFxuICAgIH0pO1xuICB9O1xuXG4gIHZhciBzY2hlZHVsZUFjdGlvbiA9IGZ1bmN0aW9uIHNjaGVkdWxlQWN0aW9uKHJ1bikge1xuICAgIHZhciB7XG4gICAgICBhdFxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5kZWxldGUoZWRpdG9yKTtcbiAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuICAgIG9uRE9NU2VsZWN0aW9uQ2hhbmdlLmNhbmNlbCgpO1xuXG4gICAgaWYgKGhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgZmx1c2goKTtcbiAgICB9XG5cbiAgICBFRElUT1JfVE9fUEVORElOR19BQ1RJT04uc2V0KGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICBydW5cbiAgICB9KTsgLy8gQ09NUEFUOiBXaGVuIGRlbGV0aW5nIGJlZm9yZSBhIG5vbi1jb250ZW50ZWRpdGFibGUgZWxlbWVudCBjaHJvbWUgb25seSBmaXJlcyBhIGJlZm9yZWlucHV0LFxuICAgIC8vIChubyBpbnB1dCkgYW5kIGRvZXNuJ3QgcGVyZm9ybSBhbnkgZG9tIG11dGF0aW9ucy4gV2l0aG91dCBhIGZsdXNoIHRpbWVvdXQgd2Ugd291bGQgbmV2ZXIgZmx1c2hcbiAgICAvLyBpbiB0aGlzIGNhc2UgYW5kIHRodXMgbmV2ZXIgYWN0dWFsbHkgcGVyZm9ybSB0aGUgYWN0aW9uLlxuXG4gICAgYWN0aW9uVGltZW91dElkID0gc2V0VGltZW91dChmbHVzaCk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZURPTUJlZm9yZUlucHV0ID0gZXZlbnQgPT4ge1xuICAgIHZhciBfdGFyZ2V0UmFuZ2UyO1xuXG4gICAgaWYgKGZsdXNoVGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQoZmx1c2hUaW1lb3V0SWQpO1xuICAgICAgZmx1c2hUaW1lb3V0SWQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBpbnB1dFR5cGU6IHR5cGVcbiAgICB9ID0gZXZlbnQ7XG4gICAgdmFyIHRhcmdldFJhbmdlID0gbnVsbDtcbiAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGFUcmFuc2ZlciB8fCBldmVudC5kYXRhIHx8IHVuZGVmaW5lZDtcblxuICAgIGlmIChpbnNlcnRQb3NpdGlvbkhpbnQgIT09IGZhbHNlICYmIHR5cGUgIT09ICdpbnNlcnRUZXh0JyAmJiB0eXBlICE9PSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0Jykge1xuICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIFtuYXRpdmVUYXJnZXRSYW5nZV0gPSBldmVudC5nZXRUYXJnZXRSYW5nZXMoKTtcblxuICAgIGlmIChuYXRpdmVUYXJnZXRSYW5nZSkge1xuICAgICAgdGFyZ2V0UmFuZ2UgPSBSZWFjdEVkaXRvci50b1NsYXRlUmFuZ2UoZWRpdG9yLCBuYXRpdmVUYXJnZXRSYW5nZSwge1xuICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSAvLyBDT01QQVQ6IFNlbGVjdGlvbkNoYW5nZSBldmVudCBpcyBmaXJlZCBhZnRlciB0aGUgYWN0aW9uIGlzIHBlcmZvcm1lZCwgc28gd2VcbiAgICAvLyBoYXZlIHRvIG1hbnVhbGx5IGdldCB0aGUgc2VsZWN0aW9uIGhlcmUgdG8gZW5zdXJlIGl0J3MgdXAtdG8tZGF0ZS5cblxuXG4gICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIHZhciBkb21TZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICBpZiAoIXRhcmdldFJhbmdlICYmIGRvbVNlbGVjdGlvbikge1xuICAgICAgbmF0aXZlVGFyZ2V0UmFuZ2UgPSBkb21TZWxlY3Rpb247XG4gICAgICB0YXJnZXRSYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVNlbGVjdGlvbiwge1xuICAgICAgICBleGFjdE1hdGNoOiBmYWxzZSxcbiAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGFyZ2V0UmFuZ2UgPSAoX3RhcmdldFJhbmdlMiA9IHRhcmdldFJhbmdlKSAhPT0gbnVsbCAmJiBfdGFyZ2V0UmFuZ2UyICE9PSB2b2lkIDAgPyBfdGFyZ2V0UmFuZ2UyIDogZWRpdG9yLnNlbGVjdGlvbjtcblxuICAgIGlmICghdGFyZ2V0UmFuZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZCh0YXJnZXRSYW5nZSkgJiYgdHlwZS5zdGFydHNXaXRoKCdkZWxldGUnKSkge1xuICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHRhcmdldFJhbmdlKTtcbiAgICAgIHZhciBsZWFmID0gTm9kZS5sZWFmKGVkaXRvciwgc3RhcnQucGF0aCk7XG5cbiAgICAgIGlmIChsZWFmLnRleHQubGVuZ3RoID09PSBzdGFydC5vZmZzZXQgJiYgZW5kLm9mZnNldCA9PT0gMCkge1xuICAgICAgICB2YXIgbmV4dCA9IEVkaXRvci5uZXh0KGVkaXRvciwge1xuICAgICAgICAgIGF0OiBzdGFydC5wYXRoLFxuICAgICAgICAgIG1hdGNoOiBUZXh0JDEuaXNUZXh0XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChuZXh0ICYmIFBhdGguZXF1YWxzKG5leHRbMV0sIGVuZC5wYXRoKSkge1xuICAgICAgICAgIHRhcmdldFJhbmdlID0ge1xuICAgICAgICAgICAgYW5jaG9yOiBlbmQsXG4gICAgICAgICAgICBmb2N1czogZW5kXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHRhcmdldFJhbmdlKSAmJiB0eXBlLnN0YXJ0c1dpdGgoJ2RlbGV0ZScpKSB7XG4gICAgICBpZiAoUGF0aC5lcXVhbHModGFyZ2V0UmFuZ2UuYW5jaG9yLnBhdGgsIHRhcmdldFJhbmdlLmZvY3VzLnBhdGgpKSB7XG4gICAgICAgIHZhciBbX3N0YXJ0LCBfZW5kXSA9IFJhbmdlLmVkZ2VzKHRhcmdldFJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHN0b3JlRGlmZih0YXJnZXRSYW5nZS5hbmNob3IucGF0aCwge1xuICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgIGVuZDogX2VuZC5vZmZzZXQsXG4gICAgICAgICAgc3RhcnQ6IF9zdGFydC5vZmZzZXRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXJlY3Rpb24gPSB0eXBlLmVuZHNXaXRoKCdCYWNrd2FyZCcpID8gJ2JhY2t3YXJkJyA6ICdmb3J3YXJkJztcbiAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgIGRpcmVjdGlvblxuICAgICAgfSksIHtcbiAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2RlbGV0ZUJ5Q29tcG9zaXRpb24nOlxuICAgICAgY2FzZSAnZGVsZXRlQnlDdXQnOlxuICAgICAgY2FzZSAnZGVsZXRlQnlEcmFnJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yKSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlQ29udGVudCc6XG4gICAgICBjYXNlICdkZWxldGVDb250ZW50Rm9yd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgYW5jaG9yXG4gICAgICAgICAgfSA9IHRhcmdldFJhbmdlO1xuXG4gICAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHRhcmdldFJhbmdlKSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldE5vZGUgPSBOb2RlLmxlYWYoZWRpdG9yLCBhbmNob3IucGF0aCk7XG5cbiAgICAgICAgICAgIGlmIChhbmNob3Iub2Zmc2V0IDwgdGFyZ2V0Tm9kZS50ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXR1cm4gc3RvcmVEaWZmKGFuY2hvci5wYXRoLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogJycsXG4gICAgICAgICAgICAgICAgc3RhcnQ6IGFuY2hvci5vZmZzZXQsXG4gICAgICAgICAgICAgICAgZW5kOiBhbmNob3Iub2Zmc2V0ICsgMVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yKSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnZGVsZXRlQ29udGVudEJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfbmF0aXZlVGFyZ2V0UmFuZ2U7XG5cbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgYW5jaG9yOiBfYW5jaG9yXG4gICAgICAgICAgfSA9IHRhcmdldFJhbmdlOyAvLyBJZiB3ZSBoYXZlIGEgbWlzbWF0Y2ggYmV0d2VlbiB0aGUgbmF0aXZlIGFuZCBzbGF0ZSBzZWxlY3Rpb24gYmVpbmcgY29sbGFwc2VkXG4gICAgICAgICAgLy8gd2UgYXJlIG1vc3QgbGlrZWx5IGRlbGV0aW5nIGEgemVyby13aWR0aCBwbGFjZWhvbGRlciBhbmQgdGh1cyBzaG91bGQgcGVyZm9ybSBpdFxuICAgICAgICAgIC8vIGFzIGFuIGFjdGlvbiB0byBlbnN1cmUgY29ycmVjdCBiZWhhdmlvciAobW9zdGx5IGhhcHBlbnMgd2l0aCBtYXJrIHBsYWNlaG9sZGVycylcblxuICAgICAgICAgIHZhciBuYXRpdmVDb2xsYXBzZWQgPSBpc0RPTVNlbGVjdGlvbihuYXRpdmVUYXJnZXRSYW5nZSkgPyBuYXRpdmVUYXJnZXRSYW5nZS5pc0NvbGxhcHNlZCA6ICEhKChfbmF0aXZlVGFyZ2V0UmFuZ2UgPSBuYXRpdmVUYXJnZXRSYW5nZSkgIT09IG51bGwgJiYgX25hdGl2ZVRhcmdldFJhbmdlICE9PSB2b2lkIDAgJiYgX25hdGl2ZVRhcmdldFJhbmdlLmNvbGxhcHNlZCk7XG5cbiAgICAgICAgICBpZiAobmF0aXZlQ29sbGFwc2VkICYmIFJhbmdlLmlzQ29sbGFwc2VkKHRhcmdldFJhbmdlKSAmJiBfYW5jaG9yLm9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZURpZmYoX2FuY2hvci5wYXRoLCB7XG4gICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICBzdGFydDogX2FuY2hvci5vZmZzZXQgLSAxLFxuICAgICAgICAgICAgICBlbmQ6IF9hbmNob3Iub2Zmc2V0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZUVudGlyZVNvZnRMaW5lJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVIYXJkTGluZUJhY2t3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZVNvZnRMaW5lQmFja3dhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVIYXJkTGluZUZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2Jsb2NrJ1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUZvcndhcmQnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRCYWNrd2FyZCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gc2NoZWR1bGVBY3Rpb24oKCkgPT4gRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgfSksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRGb3J3YXJkJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgIH0pLCB7XG4gICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRMaW5lQnJlYWsnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5pbnNlcnRTb2Z0QnJlYWsoZWRpdG9yKSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaW5zZXJ0UGFyYWdyYXBoJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuaW5zZXJ0QnJlYWsoZWRpdG9yKSwge1xuICAgICAgICAgICAgYXQ6IHRhcmdldFJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0JzpcbiAgICAgIGNhc2UgJ2RlbGV0ZUNvbXBvc2l0aW9uVGV4dCc6XG4gICAgICBjYXNlICdpbnNlcnRGcm9tQ29tcG9zaXRpb24nOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbURyb3AnOlxuICAgICAgY2FzZSAnaW5zZXJ0RnJvbVBhc3RlJzpcbiAgICAgIGNhc2UgJ2luc2VydEZyb21ZYW5rJzpcbiAgICAgIGNhc2UgJ2luc2VydFJlcGxhY2VtZW50VGV4dCc6XG4gICAgICBjYXNlICdpbnNlcnRUZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIGlmICgoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLmNvbnN0cnVjdG9yLm5hbWUpID09PSAnRGF0YVRyYW5zZmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IFJlYWN0RWRpdG9yLmluc2VydERhdGEoZWRpdG9yLCBkYXRhKSwge1xuICAgICAgICAgICAgICBhdDogdGFyZ2V0UmFuZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgJiYgZGF0YS5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgICAgIHJldHVybiBzY2hlZHVsZUFjdGlvbigoKSA9PiBFZGl0b3IuaW5zZXJ0U29mdEJyZWFrKGVkaXRvciksIHtcbiAgICAgICAgICAgICAgYXQ6IFJhbmdlLmVuZCh0YXJnZXRSYW5nZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB0ZXh0ID0gZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB2b2lkIDAgPyBkYXRhIDogJyc7IC8vIENPTVBBVDogSWYgd2UgYXJlIHdyaXRpbmcgaW5zaWRlIGEgcGxhY2Vob2xkZXIsIHRoZSBpbWUgaW5zZXJ0cyB0aGUgdGV4dCBpbnNpZGVcbiAgICAgICAgICAvLyB0aGUgcGxhY2Vob2xkZXIgaXRzZWxmIGFuZCB0aHVzIGluY2x1ZGVzIHRoZSB6ZXJvLXdpZHRoIHNwYWNlIGluc2lkZSBlZGl0IGV2ZW50cy5cblxuICAgICAgICAgIGlmIChFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoJ1xcdUZFRkYnLCAnJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFBhdGguZXF1YWxzKHRhcmdldFJhbmdlLmFuY2hvci5wYXRoLCB0YXJnZXRSYW5nZS5mb2N1cy5wYXRoKSkge1xuICAgICAgICAgICAgdmFyIFtfc3RhcnQyLCBfZW5kMl0gPSBSYW5nZS5lZGdlcyh0YXJnZXRSYW5nZSk7XG4gICAgICAgICAgICB2YXIgZGlmZiA9IHtcbiAgICAgICAgICAgICAgc3RhcnQ6IF9zdGFydDIub2Zmc2V0LFxuICAgICAgICAgICAgICBlbmQ6IF9lbmQyLm9mZnNldCxcbiAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgfTsgLy8gQ09NUEFUOiBTd2lmdGtleSBoYXMgYSB3ZWlyZCBidWcgd2hlcmUgdGhlIHRhcmdldCByYW5nZSBvZiB0aGUgMm5kIHdvcmRcbiAgICAgICAgICAgIC8vIGluc2VydGVkIGFmdGVyIGEgbWFyayBwbGFjZWhvbGRlciBpcyBpbnNlcnRlZCB3aXRoIGFuIGFuY2hvciBvZmZzZXQgb2ZmIGJ5IDEuXG4gICAgICAgICAgICAvLyBTbyB3cml0aW5nICdzb21lIHRleHQnIHdpbGwgcmVzdWx0IGluICdzb21lIHR0ZXh0Jy4gTHVja2lseSBhbGwgJ25vcm1hbCcgaW5zZXJ0XG4gICAgICAgICAgICAvLyB0ZXh0IGV2ZW50cyBhcmUgZmlyZWQgd2l0aCB0aGUgY29ycmVjdCB0YXJnZXQgcmFuZ2VzLCBvbmx5IHRoZSBmaW5hbCAnaW5zZXJ0Q29tcG9zaXRpb24nXG4gICAgICAgICAgICAvLyBpc24ndCwgc28gd2UgY2FuIGFkanVzdCB0aGUgdGFyZ2V0IHJhbmdlIHN0YXJ0IG9mZnNldCBpZiB3ZSBhcmUgY29uZmlkZW50IHRoaXMgaXMgdGhlXG4gICAgICAgICAgICAvLyBzd2lmdGtleSBpbnNlcnQgY2F1c2luZyB0aGUgaXNzdWUuXG5cbiAgICAgICAgICAgIGlmICh0ZXh0ICYmIGluc2VydFBvc2l0aW9uSGludCAmJiB0eXBlID09PSAnaW5zZXJ0Q29tcG9zaXRpb25UZXh0Jykge1xuICAgICAgICAgICAgICB2YXIgaGludFBvc2l0aW9uID0gaW5zZXJ0UG9zaXRpb25IaW50LnN0YXJ0ICsgaW5zZXJ0UG9zaXRpb25IaW50LnRleHQuc2VhcmNoKC9cXFN8JC8pO1xuICAgICAgICAgICAgICB2YXIgZGlmZlBvc2l0aW9uID0gZGlmZi5zdGFydCArIGRpZmYudGV4dC5zZWFyY2goL1xcU3wkLyk7XG5cbiAgICAgICAgICAgICAgaWYgKGRpZmZQb3NpdGlvbiA9PT0gaGludFBvc2l0aW9uICsgMSAmJiBkaWZmLmVuZCA9PT0gaW5zZXJ0UG9zaXRpb25IaW50LnN0YXJ0ICsgaW5zZXJ0UG9zaXRpb25IaW50LnRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGlmZi5zdGFydCAtPSAxO1xuICAgICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdpbnNlcnRUZXh0Jykge1xuICAgICAgICAgICAgICBpZiAoaW5zZXJ0UG9zaXRpb25IaW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gZGlmZjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnNlcnRQb3NpdGlvbkhpbnQgJiYgUmFuZ2UuaXNDb2xsYXBzZWQodGFyZ2V0UmFuZ2UpICYmIGluc2VydFBvc2l0aW9uSGludC5lbmQgKyBpbnNlcnRQb3NpdGlvbkhpbnQudGV4dC5sZW5ndGggPT09IF9zdGFydDIub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0UG9zaXRpb25IaW50ID0gX29iamVjdFNwcmVhZCQzKF9vYmplY3RTcHJlYWQkMyh7fSwgaW5zZXJ0UG9zaXRpb25IaW50KSwge30sIHtcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGluc2VydFBvc2l0aW9uSGludC50ZXh0ICsgdGV4dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnNlcnRQb3NpdGlvbkhpbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RvcmVEaWZmKF9zdGFydDIucGF0aCwgZGlmZik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHNjaGVkdWxlQWN0aW9uKCgpID0+IEVkaXRvci5pbnNlcnRUZXh0KGVkaXRvciwgdGV4dCksIHtcbiAgICAgICAgICAgIGF0OiB0YXJnZXRSYW5nZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYXNQZW5kaW5nQWN0aW9uID0gKCkgPT4ge1xuICAgIHJldHVybiAhIUVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5nZXQoZWRpdG9yKTtcbiAgfTtcblxuICB2YXIgaGFzUGVuZGluZ0RpZmZzID0gKCkgPT4ge1xuICAgIHZhciBfRURJVE9SX1RPX1BFTkRJTkdfREk1O1xuXG4gICAgcmV0dXJuICEhKChfRURJVE9SX1RPX1BFTkRJTkdfREk1ID0gRURJVE9SX1RPX1BFTkRJTkdfRElGRlMuZ2V0KGVkaXRvcikpICE9PSBudWxsICYmIF9FRElUT1JfVE9fUEVORElOR19ESTUgIT09IHZvaWQgMCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREk1Lmxlbmd0aCk7XG4gIH07XG5cbiAgdmFyIGhhc1BlbmRpbmdDaGFuZ2VzID0gKCkgPT4ge1xuICAgIHJldHVybiBoYXNQZW5kaW5nQWN0aW9uKCkgfHwgaGFzUGVuZGluZ0RpZmZzKCk7XG4gIH07XG5cbiAgdmFyIGlzRmx1c2hpbmcgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGZsdXNoaW5nO1xuICB9O1xuXG4gIHZhciBoYW5kbGVVc2VyU2VsZWN0ID0gcmFuZ2UgPT4ge1xuICAgIEVESVRPUl9UT19QRU5ESU5HX1NFTEVDVElPTi5zZXQoZWRpdG9yLCByYW5nZSk7XG5cbiAgICBpZiAoZmx1c2hUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dChmbHVzaFRpbWVvdXRJZCk7XG4gICAgICBmbHVzaFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG5cbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGhDaGFuZ2VkID0gIXNlbGVjdGlvbiB8fCAhUGF0aC5lcXVhbHMoc2VsZWN0aW9uLmFuY2hvci5wYXRoLCByYW5nZS5hbmNob3IucGF0aCk7XG4gICAgdmFyIHBhcmVudFBhdGhDaGFuZ2VkID0gIXNlbGVjdGlvbiB8fCAhUGF0aC5lcXVhbHMoc2VsZWN0aW9uLmFuY2hvci5wYXRoLnNsaWNlKDAsIC0xKSwgcmFuZ2UuYW5jaG9yLnBhdGguc2xpY2UoMCwgLTEpKTtcblxuICAgIGlmIChwYXRoQ2hhbmdlZCAmJiBpbnNlcnRQb3NpdGlvbkhpbnQgfHwgcGFyZW50UGF0aENoYW5nZWQpIHtcbiAgICAgIGluc2VydFBvc2l0aW9uSGludCA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChwYXRoQ2hhbmdlZCB8fCAhaGFzUGVuZGluZ0RpZmZzKCkpIHtcbiAgICAgIGZsdXNoVGltZW91dElkID0gc2V0VGltZW91dChmbHVzaCwgRkxVU0hfREVMQVkpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgaGFuZGxlSW5wdXQgPSAoKSA9PiB7XG4gICAgaWYgKGhhc1BlbmRpbmdBY3Rpb24oKSB8fCAhaGFzUGVuZGluZ0RpZmZzKCkpIHtcbiAgICAgIGZsdXNoKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVLZXlEb3duID0gXyA9PiB7XG4gICAgLy8gQ09NUEFUOiBTd2lmdGtleSBjbG9zZXMgdGhlIGtleWJvYXJkIHdoZW4gdHlwaW5nIGluc2lkZSBhIGVtcHR5IG5vZGVcbiAgICAvLyBkaXJlY3RseSBuZXh0IHRvIGEgbm9uLWNvbnRlbnRlZGl0YWJsZSBlbGVtZW50ICg9IHRoZSBwbGFjZWhvbGRlcikuXG4gICAgLy8gVGhlIG9ubHkgZXZlbnQgZmlyZWQgc29vbiBlbm91Z2ggZm9yIHVzIHRvIGFsbG93IGhpZGluZyB0aGUgcGxhY2Vob2xkZXJcbiAgICAvLyB3aXRob3V0IHN3aWZ0a2V5IHBpY2tpbmcgaXQgdXAgaXMgdGhlIGtleWRvd24gZXZlbnQsIHNvIHdlIGhhdmUgdG8gaGlkZSBpdFxuICAgIC8vIGhlcmUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vaWFuc3Rvcm10YXlsb3Ivc2xhdGUvcHVsbC80OTg4I2lzc3VlY29tbWVudC0xMjAxMDUwNTM1XG4gICAgaWYgKCFoYXNQZW5kaW5nRGlmZnMoKSkge1xuICAgICAgdXBkYXRlUGxhY2Vob2xkZXJWaXNpYmlsaXR5KHRydWUpO1xuICAgICAgc2V0VGltZW91dCh1cGRhdGVQbGFjZWhvbGRlclZpc2liaWxpdHkpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc2NoZWR1bGVGbHVzaCA9ICgpID0+IHtcbiAgICBpZiAoIWhhc1BlbmRpbmdBY3Rpb24oKSkge1xuICAgICAgYWN0aW9uVGltZW91dElkID0gc2V0VGltZW91dChmbHVzaCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVEb21NdXRhdGlvbnMgPSBtdXRhdGlvbnMgPT4ge1xuICAgIGlmIChoYXNQZW5kaW5nRGlmZnMoKSB8fCBoYXNQZW5kaW5nQWN0aW9uKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobXV0YXRpb25zLnNvbWUobXV0YXRpb24gPT4gaXNUcmFja2VkTXV0YXRpb24oZWRpdG9yLCBtdXRhdGlvbiwgbXV0YXRpb25zKSkpIHtcbiAgICAgIHZhciBfRURJVE9SX1RPX0ZPUkNFX1JFTkQ7XG5cbiAgICAgIC8vIENhdXNlIGEgcmUtcmVuZGVyIHRvIHJlc3RvcmUgdGhlIGRvbSBzdGF0ZSBpZiB3ZSBlbmNvdW50ZXIgdHJhY2tlZCBtdXRhdGlvbnMgd2l0aG91dFxuICAgICAgLy8gYSBjb3JyZXNwb25kaW5nIHBlbmRpbmcgYWN0aW9uLlxuICAgICAgKF9FRElUT1JfVE9fRk9SQ0VfUkVORCA9IEVESVRPUl9UT19GT1JDRV9SRU5ERVIuZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fRk9SQ0VfUkVORCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19GT1JDRV9SRU5EKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgZmx1c2gsXG4gICAgc2NoZWR1bGVGbHVzaCxcbiAgICBoYXNQZW5kaW5nRGlmZnMsXG4gICAgaGFzUGVuZGluZ0FjdGlvbixcbiAgICBoYXNQZW5kaW5nQ2hhbmdlcyxcbiAgICBpc0ZsdXNoaW5nLFxuICAgIGhhbmRsZVVzZXJTZWxlY3QsXG4gICAgaGFuZGxlQ29tcG9zaXRpb25FbmQsXG4gICAgaGFuZGxlQ29tcG9zaXRpb25TdGFydCxcbiAgICBoYW5kbGVET01CZWZvcmVJbnB1dCxcbiAgICBoYW5kbGVLZXlEb3duLFxuICAgIGhhbmRsZURvbU11dGF0aW9ucyxcbiAgICBoYW5kbGVJbnB1dFxuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VJc01vdW50ZWQoKSB7XG4gIHZhciBpc01vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlzTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBpc01vdW50ZWRSZWYuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gdXNlTXV0YXRpb25PYnNlcnZlcihub2RlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgW211dGF0aW9uT2JzZXJ2ZXJdID0gdXNlU3RhdGUoKCkgPT4gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgLy8gRGlzY2FyZCBtdXRhdGlvbnMgY2F1c2VkIGR1cmluZyByZW5kZXIgcGhhc2UuIFRoaXMgd29ya3MgZHVlIHRvIHJlYWN0IGNhbGxpbmdcbiAgICAvLyB1c2VMYXlvdXRFZmZlY3Qgc3luY2hyb25vdXNseSBhZnRlciB0aGUgcmVuZGVyIHBoYXNlIGJlZm9yZSB0aGUgbmV4dCB0aWNrLlxuICAgIG11dGF0aW9uT2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFub2RlLmN1cnJlbnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGF0dGFjaCBNdXRhdGlvbk9ic2VydmVyLCBgbm9kZWAgaXMgdW5kZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgbXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKG5vZGUuY3VycmVudCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuICgpID0+IG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9LCBbXSk7XG59XG5cbnZhciBfZXhjbHVkZWQkMiA9IFtcIm5vZGVcIl07XG5cbmZ1bmN0aW9uIG93bktleXMkMihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxudmFyIE1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyA9IHtcbiAgc3VidHJlZTogdHJ1ZSxcbiAgY2hpbGRMaXN0OiB0cnVlLFxuICBjaGFyYWN0ZXJEYXRhOiB0cnVlXG59O1xuZnVuY3Rpb24gdXNlQW5kcm9pZElucHV0TWFuYWdlcihfcmVmKSB7XG4gIHZhciB7XG4gICAgbm9kZVxuICB9ID0gX3JlZixcbiAgICAgIG9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkJDIpO1xuXG4gIGlmICghSVNfQU5EUk9JRCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGVkaXRvciA9IHVzZVNsYXRlU3RhdGljKCk7XG4gIHZhciBpc01vdW50ZWQgPSB1c2VJc01vdW50ZWQoKTtcbiAgdmFyIFtpbnB1dE1hbmFnZXJdID0gdXNlU3RhdGUoKCkgPT4gY3JlYXRlQW5kcm9pZElucHV0TWFuYWdlcihfb2JqZWN0U3ByZWFkJDIoe1xuICAgIGVkaXRvclxuICB9LCBvcHRpb25zKSkpO1xuICB1c2VNdXRhdGlvbk9ic2VydmVyKG5vZGUsIGlucHV0TWFuYWdlci5oYW5kbGVEb21NdXRhdGlvbnMsIE1VVEFUSU9OX09CU0VSVkVSX0NPTkZJRyk7XG4gIEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSC5zZXQoZWRpdG9yLCBpbnB1dE1hbmFnZXIuc2NoZWR1bGVGbHVzaCk7XG5cbiAgaWYgKGlzTW91bnRlZCkge1xuICAgIGlucHV0TWFuYWdlci5mbHVzaCgpO1xuICB9XG5cbiAgcmV0dXJuIGlucHV0TWFuYWdlcjtcbn1cblxuZnVuY3Rpb24gdXNlVHJhY2tVc2VySW5wdXQoKSB7XG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZVN0YXRpYygpO1xuICB2YXIgcmVjZWl2ZWRVc2VySW5wdXQgPSB1c2VSZWYoZmFsc2UpO1xuICB2YXIgYW5pbWF0aW9uRnJhbWVJZFJlZiA9IHVzZVJlZigwKTtcbiAgdmFyIG9uVXNlcklucHV0ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChyZWNlaXZlZFVzZXJJbnB1dC5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVjZWl2ZWRVc2VySW5wdXQuY3VycmVudCA9IHRydWU7XG4gICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZUlkUmVmLmN1cnJlbnQpO1xuICAgIGFuaW1hdGlvbkZyYW1lSWRSZWYuY3VycmVudCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgcmVjZWl2ZWRVc2VySW5wdXQuY3VycmVudCA9IGZhbHNlO1xuICAgIH0pO1xuICB9LCBbXSk7XG4gIHVzZUVmZmVjdCgoKSA9PiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZUlkUmVmLmN1cnJlbnQpLCBbXSk7XG4gIHJldHVybiB7XG4gICAgcmVjZWl2ZWRVc2VySW5wdXQsXG4gICAgb25Vc2VySW5wdXRcbiAgfTtcbn1cblxudmFyIF9leGNsdWRlZCQxID0gW1wiYXV0b0ZvY3VzXCIsIFwiZGVjb3JhdGVcIiwgXCJvbkRPTUJlZm9yZUlucHV0XCIsIFwicGxhY2Vob2xkZXJcIiwgXCJyZWFkT25seVwiLCBcInJlbmRlckVsZW1lbnRcIiwgXCJyZW5kZXJMZWFmXCIsIFwicmVuZGVyUGxhY2Vob2xkZXJcIiwgXCJzY3JvbGxTZWxlY3Rpb25JbnRvVmlld1wiLCBcInN0eWxlXCIsIFwiYXNcIl0sXG4gICAgX2V4Y2x1ZGVkMiA9IFtcInRleHRcIl07XG5cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgQ2hpbGRyZW4gPSBwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgdXNlQ2hpbGRyZW4ocHJvcHMpKTsgLy8gVGhlIG51bWJlciBvZiBFZGl0YWJsZSBjb21wb25lbnRzIGN1cnJlbnRseSBtb3VudGVkLlxuXG5cbnZhciBtb3VudGVkQ291bnQgPSAwO1xuLyoqXHJcbiAqIEVkaXRhYmxlLlxyXG4gKi9cblxudmFyIEVkaXRhYmxlID0gcHJvcHMgPT4ge1xuICB2YXIge1xuICAgIGF1dG9Gb2N1cyxcbiAgICBkZWNvcmF0ZSA9IGRlZmF1bHREZWNvcmF0ZSxcbiAgICBvbkRPTUJlZm9yZUlucHV0OiBwcm9wc09uRE9NQmVmb3JlSW5wdXQsXG4gICAgcGxhY2Vob2xkZXIsXG4gICAgcmVhZE9ubHkgPSBmYWxzZSxcbiAgICByZW5kZXJFbGVtZW50LFxuICAgIHJlbmRlckxlYWYsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXIgPSBwcm9wcyA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0UGxhY2Vob2xkZXIsIE9iamVjdC5hc3NpZ24oe30sIHByb3BzKSksXG4gICAgc2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcgPSBkZWZhdWx0U2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXcsXG4gICAgc3R5bGUgPSB7fSxcbiAgICBhczogQ29tcG9uZW50ID0gJ2RpdidcbiAgfSA9IHByb3BzLFxuICAgICAgYXR0cmlidXRlcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkJDEpO1xuXG4gIHZhciBlZGl0b3IgPSB1c2VTbGF0ZSgpOyAvLyBSZXJlbmRlciBlZGl0b3Igd2hlbiBjb21wb3NpdGlvbiBzdGF0dXMgY2hhbmdlZFxuXG4gIHZhciBbaXNDb21wb3NpbmcsIHNldElzQ29tcG9zaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgdmFyIHJlZiA9IHVzZVJlZihudWxsKTtcbiAgdmFyIGRlZmVycmVkT3BlcmF0aW9ucyA9IHVzZVJlZihbXSk7XG4gIHZhciB7XG4gICAgb25Vc2VySW5wdXQsXG4gICAgcmVjZWl2ZWRVc2VySW5wdXRcbiAgfSA9IHVzZVRyYWNrVXNlcklucHV0KCk7XG4gIHZhciBbLCBmb3JjZVJlbmRlcl0gPSB1c2VSZWR1Y2VyKHMgPT4gcyArIDEsIDApO1xuICBFRElUT1JfVE9fRk9SQ0VfUkVOREVSLnNldChlZGl0b3IsIGZvcmNlUmVuZGVyKTsgLy8gVXBkYXRlIGludGVybmFsIHN0YXRlIG9uIGVhY2ggcmVuZGVyLlxuXG4gIElTX1JFQURfT05MWS5zZXQoZWRpdG9yLCByZWFkT25seSk7IC8vIEtlZXAgdHJhY2sgb2Ygc29tZSBzdGF0ZSBmb3IgdGhlIGV2ZW50IGhhbmRsZXIgbG9naWMuXG5cbiAgdmFyIHN0YXRlID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIGlzRHJhZ2dpbmdJbnRlcm5hbGx5OiBmYWxzZSxcbiAgICBpc1VwZGF0aW5nU2VsZWN0aW9uOiBmYWxzZSxcbiAgICBsYXRlc3RFbGVtZW50OiBudWxsLFxuICAgIGhhc01hcmtQbGFjZWhvbGRlcjogZmFsc2VcbiAgfSksIFtdKTsgLy8gVGhlIGF1dG9Gb2N1cyBUZXh0YXJlYUhUTUxBdHRyaWJ1dGUgZG9lc24ndCBkbyBhbnl0aGluZyBvbiBhIGRpdiwgc28gaXRcbiAgLy8gbmVlZHMgdG8gYmUgbWFudWFsbHkgZm9jdXNlZC5cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudCAmJiBhdXRvRm9jdXMpIHtcbiAgICAgIHJlZi5jdXJyZW50LmZvY3VzKCk7XG4gICAgfVxuICB9LCBbYXV0b0ZvY3VzXSk7IC8vIExpc3RlbiBvbiB0aGUgbmF0aXZlIGBzZWxlY3Rpb25jaGFuZ2VgIGV2ZW50IHRvIGJlIGFibGUgdG8gdXBkYXRlIGFueSB0aW1lXG4gIC8vIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy4gVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIFJlYWN0J3MgYG9uU2VsZWN0YCBpcyBsZWFreVxuICAvLyBhbmQgbm9uLXN0YW5kYXJkIHNvIGl0IGRvZXNuJ3QgZmlyZSB1bnRpbCBhZnRlciBhIHNlbGVjdGlvbiBoYXMgYmVlblxuICAvLyByZWxlYXNlZC4gVGhpcyBjYXVzZXMgaXNzdWVzIGluIHNpdHVhdGlvbnMgd2hlcmUgYW5vdGhlciBjaGFuZ2UgaGFwcGVuc1xuICAvLyB3aGlsZSBhIHNlbGVjdGlvbiBpcyBiZWluZyBkcmFnZ2VkLlxuXG4gIHZhciBvbkRPTVNlbGVjdGlvbkNoYW5nZSA9IHVzZUNhbGxiYWNrKHRocm90dGxlKCgpID0+IHtcbiAgICBpZiAoKElTX0FORFJPSUQgfHwgIVJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpICYmICghc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiB8fCBhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSBudWxsICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IHZvaWQgMCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmlzRmx1c2hpbmcoKSkgJiYgIXN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5KSB7XG4gICAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgICAgdmFyIHtcbiAgICAgICAgYWN0aXZlRWxlbWVudFxuICAgICAgfSA9IHJvb3Q7XG4gICAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgdmFyIGRvbVNlbGVjdGlvbiA9IHJvb3QuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgICAgIGlmIChhY3RpdmVFbGVtZW50ID09PSBlbCkge1xuICAgICAgICBzdGF0ZS5sYXRlc3RFbGVtZW50ID0gYWN0aXZlRWxlbWVudDtcbiAgICAgICAgSVNfRk9DVVNFRC5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIElTX0ZPQ1VTRUQuZGVsZXRlKGVkaXRvcik7XG4gICAgICB9XG5cbiAgICAgIGlmICghZG9tU2VsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1zLmRlc2VsZWN0KGVkaXRvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciB7XG4gICAgICAgIGFuY2hvck5vZGUsXG4gICAgICAgIGZvY3VzTm9kZVxuICAgICAgfSA9IGRvbVNlbGVjdGlvbjtcbiAgICAgIHZhciBhbmNob3JOb2RlU2VsZWN0YWJsZSA9IFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgYW5jaG9yTm9kZSkgfHwgUmVhY3RFZGl0b3IuaXNUYXJnZXRJbnNpZGVOb25SZWFkb25seVZvaWQoZWRpdG9yLCBhbmNob3JOb2RlKTtcbiAgICAgIHZhciBmb2N1c05vZGVTZWxlY3RhYmxlID0gUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBmb2N1c05vZGUpIHx8IFJlYWN0RWRpdG9yLmlzVGFyZ2V0SW5zaWRlTm9uUmVhZG9ubHlWb2lkKGVkaXRvciwgZm9jdXNOb2RlKTtcblxuICAgICAgaWYgKGFuY2hvck5vZGVTZWxlY3RhYmxlICYmIGZvY3VzTm9kZVNlbGVjdGFibGUpIHtcbiAgICAgICAgdmFyIHJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgZG9tU2VsZWN0aW9uLCB7XG4gICAgICAgICAgZXhhY3RNYXRjaDogZmFsc2UsXG4gICAgICAgICAgc3VwcHJlc3NUaHJvdzogdHJ1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICBpZiAoIVJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikgJiYgIShhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSBudWxsICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IHZvaWQgMCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmhhc1BlbmRpbmdDaGFuZ2VzKCkpICYmICEoYW5kcm9pZElucHV0TWFuYWdlciAhPT0gbnVsbCAmJiBhbmRyb2lkSW5wdXRNYW5hZ2VyICE9PSB2b2lkIDAgJiYgYW5kcm9pZElucHV0TWFuYWdlci5pc0ZsdXNoaW5nKCkpKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5kcm9pZElucHV0TWFuYWdlciA9PT0gbnVsbCB8fCBhbmRyb2lkSW5wdXRNYW5hZ2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmhhbmRsZVVzZXJTZWxlY3QocmFuZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBEZXNlbGVjdCB0aGUgZWRpdG9yIGlmIHRoZSBkb20gc2VsZWN0aW9uIGlzIG5vdCBzZWxlY3RhYmxlIGluIHJlYWRvbmx5IG1vZGVcblxuXG4gICAgICBpZiAocmVhZE9ubHkgJiYgKCFhbmNob3JOb2RlU2VsZWN0YWJsZSB8fCAhZm9jdXNOb2RlU2VsZWN0YWJsZSkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZXNlbGVjdChlZGl0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgMTAwKSwgW3JlYWRPbmx5XSk7XG4gIHZhciBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlID0gdXNlTWVtbygoKSA9PiBkZWJvdW5jZShvbkRPTVNlbGVjdGlvbkNoYW5nZSwgMCksIFtvbkRPTVNlbGVjdGlvbkNoYW5nZV0pO1xuICB2YXIgYW5kcm9pZElucHV0TWFuYWdlciA9IHVzZUFuZHJvaWRJbnB1dE1hbmFnZXIoe1xuICAgIG5vZGU6IHJlZixcbiAgICBvbkRPTVNlbGVjdGlvbkNoYW5nZSxcbiAgICBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlXG4gIH0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAvLyBVcGRhdGUgZWxlbWVudC1yZWxhdGVkIHdlYWsgbWFwcyB3aXRoIHRoZSBET00gZWxlbWVudCByZWYuXG4gICAgdmFyIHdpbmRvdztcblxuICAgIGlmIChyZWYuY3VycmVudCAmJiAod2luZG93ID0gZ2V0RGVmYXVsdFZpZXcocmVmLmN1cnJlbnQpKSkge1xuICAgICAgRURJVE9SX1RPX1dJTkRPVy5zZXQoZWRpdG9yLCB3aW5kb3cpO1xuICAgICAgRURJVE9SX1RPX0VMRU1FTlQuc2V0KGVkaXRvciwgcmVmLmN1cnJlbnQpO1xuICAgICAgTk9ERV9UT19FTEVNRU5ULnNldChlZGl0b3IsIHJlZi5jdXJyZW50KTtcbiAgICAgIEVMRU1FTlRfVE9fTk9ERS5zZXQocmVmLmN1cnJlbnQsIGVkaXRvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIE5PREVfVE9fRUxFTUVOVC5kZWxldGUoZWRpdG9yKTtcbiAgICB9IC8vIE1ha2Ugc3VyZSB0aGUgRE9NIHNlbGVjdGlvbiBzdGF0ZSBpcyBpbiBzeW5jLlxuXG5cbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgIHZhciBkb21TZWxlY3Rpb24gPSByb290LmdldFNlbGVjdGlvbigpO1xuXG4gICAgaWYgKCFkb21TZWxlY3Rpb24gfHwgIVJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpIHx8IGFuZHJvaWRJbnB1dE1hbmFnZXIgIT09IG51bGwgJiYgYW5kcm9pZElucHV0TWFuYWdlciAhPT0gdm9pZCAwICYmIGFuZHJvaWRJbnB1dE1hbmFnZXIuaGFzUGVuZGluZ0FjdGlvbigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNldERvbVNlbGVjdGlvbiA9IGZvcmNlQ2hhbmdlID0+IHtcbiAgICAgIHZhciBoYXNEb21TZWxlY3Rpb24gPSBkb21TZWxlY3Rpb24udHlwZSAhPT0gJ05vbmUnOyAvLyBJZiB0aGUgRE9NIHNlbGVjdGlvbiBpcyBwcm9wZXJseSB1bnNldCwgd2UncmUgZG9uZS5cblxuICAgICAgaWYgKCFzZWxlY3Rpb24gJiYgIWhhc0RvbVNlbGVjdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIHZlcmlmeSB0aGF0IHRoZSBkb20gc2VsZWN0aW9uIGlzIGluIHRoZSBlZGl0b3JcblxuXG4gICAgICB2YXIgZWRpdG9yRWxlbWVudCA9IEVESVRPUl9UT19FTEVNRU5ULmdldChlZGl0b3IpO1xuICAgICAgdmFyIGhhc0RvbVNlbGVjdGlvbkluRWRpdG9yID0gZmFsc2U7XG5cbiAgICAgIGlmIChlZGl0b3JFbGVtZW50LmNvbnRhaW5zKGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlKSAmJiBlZGl0b3JFbGVtZW50LmNvbnRhaW5zKGRvbVNlbGVjdGlvbi5mb2N1c05vZGUpKSB7XG4gICAgICAgIGhhc0RvbVNlbGVjdGlvbkluRWRpdG9yID0gdHJ1ZTtcbiAgICAgIH0gLy8gSWYgdGhlIERPTSBzZWxlY3Rpb24gaXMgaW4gdGhlIGVkaXRvciBhbmQgdGhlIGVkaXRvciBzZWxlY3Rpb24gaXMgYWxyZWFkeSBjb3JyZWN0LCB3ZSdyZSBkb25lLlxuXG5cbiAgICAgIGlmIChoYXNEb21TZWxlY3Rpb24gJiYgaGFzRG9tU2VsZWN0aW9uSW5FZGl0b3IgJiYgc2VsZWN0aW9uICYmICFmb3JjZUNoYW5nZSkge1xuICAgICAgICB2YXIgc2xhdGVSYW5nZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVNlbGVjdGlvbiwge1xuICAgICAgICAgIGV4YWN0TWF0Y2g6IHRydWUsXG4gICAgICAgICAgLy8gZG9tU2VsZWN0aW9uIGlzIG5vdCBuZWNlc3NhcmlseSBhIHZhbGlkIFNsYXRlIHJhbmdlXG4gICAgICAgICAgLy8gKGUuZy4gd2hlbiBjbGlja2luZyBvbiBjb250ZW50RWRpdGFibGU6ZmFsc2UgZWxlbWVudClcbiAgICAgICAgICBzdXBwcmVzc1Rocm93OiB0cnVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChzbGF0ZVJhbmdlICYmIFJhbmdlLmVxdWFscyhzbGF0ZVJhbmdlLCBzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgdmFyIF9hbmNob3JOb2RlJHBhcmVudEVsZTtcblxuICAgICAgICAgIGlmICghc3RhdGUuaGFzTWFya1BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBFbnN1cmUgc2VsZWN0aW9uIGlzIGluc2lkZSB0aGUgbWFyayBwbGFjZWhvbGRlclxuXG5cbiAgICAgICAgICB2YXIge1xuICAgICAgICAgICAgYW5jaG9yTm9kZVxuICAgICAgICAgIH0gPSBkb21TZWxlY3Rpb247XG5cbiAgICAgICAgICBpZiAoYW5jaG9yTm9kZSAhPT0gbnVsbCAmJiBhbmNob3JOb2RlICE9PSB2b2lkIDAgJiYgKF9hbmNob3JOb2RlJHBhcmVudEVsZSA9IGFuY2hvck5vZGUucGFyZW50RWxlbWVudCkgIT09IG51bGwgJiYgX2FuY2hvck5vZGUkcGFyZW50RWxlICE9PSB2b2lkIDAgJiYgX2FuY2hvck5vZGUkcGFyZW50RWxlLmhhc0F0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1tYXJrLXBsYWNlaG9sZGVyJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gd2hlbiA8RWRpdGFibGUvPiBpcyBiZWluZyBjb250cm9sbGVkIHRocm91Z2ggZXh0ZXJuYWwgdmFsdWVcbiAgICAgIC8vIHRoZW4gaXRzIGNoaWxkcmVuIG1pZ2h0IGp1c3QgY2hhbmdlIC0gRE9NIHJlc3BvbmRzIHRvIGl0IG9uIGl0cyBvd25cbiAgICAgIC8vIGJ1dCBTbGF0ZSdzIHZhbHVlIGlzIG5vdCBiZWluZyB1cGRhdGVkIHRocm91Z2ggYW55IG9wZXJhdGlvblxuICAgICAgLy8gYW5kIHRodXMgaXQgZG9lc24ndCB0cmFuc2Zvcm0gc2VsZWN0aW9uIG9uIGl0cyBvd25cblxuXG4gICAgICBpZiAoc2VsZWN0aW9uICYmICFSZWFjdEVkaXRvci5oYXNSYW5nZShlZGl0b3IsIHNlbGVjdGlvbikpIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IFJlYWN0RWRpdG9yLnRvU2xhdGVSYW5nZShlZGl0b3IsIGRvbVNlbGVjdGlvbiwge1xuICAgICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICAgIHN1cHByZXNzVGhyb3c6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIHRoZSBET00gc2VsZWN0aW9uIGlzIG91dCBvZiBzeW5jLCBzbyB1cGRhdGUgaXQuXG5cblxuICAgICAgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiA9IHRydWU7XG4gICAgICB2YXIgbmV3RG9tUmFuZ2UgPSBzZWxlY3Rpb24gJiYgUmVhY3RFZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIHNlbGVjdGlvbik7XG5cbiAgICAgIGlmIChuZXdEb21SYW5nZSkge1xuICAgICAgICBpZiAoUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgZG9tU2VsZWN0aW9uLnNldEJhc2VBbmRFeHRlbnQobmV3RG9tUmFuZ2UuZW5kQ29udGFpbmVyLCBuZXdEb21SYW5nZS5lbmRPZmZzZXQsIG5ld0RvbVJhbmdlLnN0YXJ0Q29udGFpbmVyLCBuZXdEb21SYW5nZS5zdGFydE9mZnNldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9tU2VsZWN0aW9uLnNldEJhc2VBbmRFeHRlbnQobmV3RG9tUmFuZ2Uuc3RhcnRDb250YWluZXIsIG5ld0RvbVJhbmdlLnN0YXJ0T2Zmc2V0LCBuZXdEb21SYW5nZS5lbmRDb250YWluZXIsIG5ld0RvbVJhbmdlLmVuZE9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyhlZGl0b3IsIG5ld0RvbVJhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0RvbVJhbmdlO1xuICAgIH07XG5cbiAgICB2YXIgbmV3RG9tUmFuZ2UgPSBzZXREb21TZWxlY3Rpb24oKTtcbiAgICB2YXIgZW5zdXJlU2VsZWN0aW9uID0gKGFuZHJvaWRJbnB1dE1hbmFnZXIgPT09IG51bGwgfHwgYW5kcm9pZElucHV0TWFuYWdlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5kcm9pZElucHV0TWFuYWdlci5pc0ZsdXNoaW5nKCkpID09PSAnYWN0aW9uJztcblxuICAgIGlmICghSVNfQU5EUk9JRCB8fCAhZW5zdXJlU2VsZWN0aW9uKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgLy8gQ09NUEFUOiBJbiBGaXJlZm94LCBpdCdzIG5vdCBlbm91Z2ggdG8gY3JlYXRlIGEgcmFuZ2UsIHlvdSBhbHNvIG5lZWRcbiAgICAgICAgLy8gdG8gZm9jdXMgdGhlIGNvbnRlbnRlZGl0YWJsZSBlbGVtZW50IHRvby4gKDIwMTYvMTEvMTYpXG4gICAgICAgIGlmIChuZXdEb21SYW5nZSAmJiBJU19GSVJFRk9YKSB7XG4gICAgICAgICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTtcbiAgICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRpbWVvdXRJZCA9IG51bGw7XG4gICAgdmFyIGFuaW1hdGlvbkZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKGVuc3VyZVNlbGVjdGlvbikge1xuICAgICAgICB2YXIgZW5zdXJlRG9tU2VsZWN0aW9uID0gZm9yY2VDaGFuZ2UgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgICAgICAgZWwuZm9jdXMoKTtcbiAgICAgICAgICAgIHNldERvbVNlbGVjdGlvbihmb3JjZUNoYW5nZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkgey8vIElnbm9yZSwgZG9tIGFuZCBzdGF0ZSBtaWdodCBiZSBvdXQgb2Ygc3luY1xuICAgICAgICAgIH1cbiAgICAgICAgfTsgLy8gQ29tcGF0OiBBbmRyb2lkIElNRXMgdHJ5IHRvIGZvcmNlIHRoZWlyIHNlbGVjdGlvbiBieSBtYW51YWxseSByZS1hcHBseWluZyBpdCBldmVuIGFmdGVyIHdlIHNldCBpdC5cbiAgICAgICAgLy8gVGhpcyBlc3NlbnRpYWxseSB3b3VsZCBtYWtlIHNldHRpbmcgdGhlIHNsYXRlIHNlbGVjdGlvbiBkdXJpbmcgYW4gdXBkYXRlIG1lYW5pbmdsZXNzLCBzbyB3ZSBmb3JjZSBpdFxuICAgICAgICAvLyBhZ2FpbiBoZXJlLiBXZSBjYW4ndCBvbmx5IGRvIGl0IGluIHRoZSBzZXRUaW1lb3V0IGFmdGVyIHRoZSBhbmltYXRpb24gZnJhbWUgc2luY2UgdGhhdCB3b3VsZCBjYXVzZSBhXG4gICAgICAgIC8vIHZpc2libGUgZmxpY2tlci5cblxuXG4gICAgICAgIGVuc3VyZURvbVNlbGVjdGlvbigpO1xuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAvLyBDT01QQVQ6IFdoaWxlIHNldHRpbmcgdGhlIHNlbGVjdGlvbiBpbiBhbiBhbmltYXRpb24gZnJhbWUgdmlzdWFsbHkgY29ycmVjdGx5IHNldHMgdGhlIHNlbGVjdGlvbixcbiAgICAgICAgICAvLyBpdCBkb2Vzbid0IHVwZGF0ZSBHQm9hcmRzIHNwZWxsY2hlY2tlciBzdGF0ZS4gV2UgaGF2ZSB0byBtYW51YWxseSB0cmlnZ2VyIGEgc2VsZWN0aW9uIGNoYW5nZSBhZnRlclxuICAgICAgICAgIC8vIHRoZSBhbmltYXRpb24gZnJhbWUgdG8gZW5zdXJlIGl0IGRpc3BsYXlzIHRoZSBjb3JyZWN0IHN0YXRlLlxuICAgICAgICAgIGVuc3VyZURvbVNlbGVjdGlvbih0cnVlKTtcbiAgICAgICAgICBzdGF0ZS5pc1VwZGF0aW5nU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhbmltYXRpb25GcmFtZUlkKTtcblxuICAgICAgaWYgKHRpbWVvdXRJZCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTsgLy8gTGlzdGVuIG9uIHRoZSBuYXRpdmUgYGJlZm9yZWlucHV0YCBldmVudCB0byBnZXQgcmVhbCBcIkxldmVsIDJcIiBldmVudHMuIFRoaXNcbiAgLy8gaXMgcmVxdWlyZWQgYmVjYXVzZSBSZWFjdCdzIGBiZWZvcmVpbnB1dGAgaXMgZmFrZSBhbmQgbmV2ZXIgcmVhbGx5IGF0dGFjaGVzXG4gIC8vIHRvIHRoZSByZWFsIGV2ZW50IHNhZGx5LiAoMjAxOS8xMS8wMSlcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTIxMVxuXG4gIHZhciBvbkRPTUJlZm9yZUlucHV0ID0gdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgIG9uVXNlcklucHV0KCk7XG5cbiAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNET01FdmVudEhhbmRsZWQoZXZlbnQsIHByb3BzT25ET01CZWZvcmVJbnB1dCkpIHtcbiAgICAgIHZhciBfRURJVE9SX1RPX1VTRVJfU0VMRUM7XG5cbiAgICAgIC8vIENPTVBBVDogQmVmb3JlSW5wdXQgZXZlbnRzIGFyZW4ndCBjYW5jZWxhYmxlIG9uIGFuZHJvaWQsIHNvIHdlIGhhdmUgdG8gaGFuZGxlIHRoZW0gZGlmZmVyZW50bHkgdXNpbmcgdGhlIGFuZHJvaWQgaW5wdXQgbWFuYWdlci5cbiAgICAgIGlmIChhbmRyb2lkSW5wdXRNYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmhhbmRsZURPTUJlZm9yZUlucHV0KGV2ZW50KTtcbiAgICAgIH0gLy8gU29tZSBJTUVzL0Nocm9tZSBleHRlbnNpb25zIGxpa2UgZS5nLiBHcmFtbWFybHkgc2V0IHRoZSBzZWxlY3Rpb24gaW1tZWRpYXRlbHkgYmVmb3JlXG4gICAgICAvLyB0cmlnZ2VyaW5nIGEgYGJlZm9yZWlucHV0YCBleHBlY3RpbmcgdGhlIGNoYW5nZSB0byBiZSBhcHBsaWVkIHRvIHRoZSBpbW1lZGlhdGVseSBiZWZvcmVcbiAgICAgIC8vIHNldCBzZWxlY3Rpb24uXG5cblxuICAgICAgc2NoZWR1bGVPbkRPTVNlbGVjdGlvbkNoYW5nZS5mbHVzaCgpO1xuICAgICAgb25ET01TZWxlY3Rpb25DaGFuZ2UuZmx1c2goKTtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcbiAgICAgIHZhciB7XG4gICAgICAgIGlucHV0VHlwZTogdHlwZVxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhVHJhbnNmZXIgfHwgZXZlbnQuZGF0YSB8fCB1bmRlZmluZWQ7XG4gICAgICB2YXIgaXNDb21wb3NpdGlvbkNoYW5nZSA9IHR5cGUgPT09ICdpbnNlcnRDb21wb3NpdGlvblRleHQnIHx8IHR5cGUgPT09ICdkZWxldGVDb21wb3NpdGlvblRleHQnOyAvLyBDT01QQVQ6IHVzZSBjb21wb3NpdGlvbiBjaGFuZ2UgZXZlbnRzIGFzIGEgaGludCB0byB3aGVyZSB3ZSBzaG91bGQgaW5zZXJ0XG4gICAgICAvLyBjb21wb3NpdGlvbiB0ZXh0IGlmIHdlIGFyZW4ndCBjb21wb3NpbmcgdG8gd29yayBhcm91bmQgaHR0cHM6Ly9naXRodWIuY29tL2lhbnN0b3JtdGF5bG9yL3NsYXRlL2lzc3Vlcy81MDM4XG5cbiAgICAgIGlmIChpc0NvbXBvc2l0aW9uQ2hhbmdlICYmIFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmF0aXZlID0gZmFsc2U7XG5cbiAgICAgIGlmICh0eXBlID09PSAnaW5zZXJ0VGV4dCcgJiYgc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikgJiYgLy8gT25seSB1c2UgbmF0aXZlIGNoYXJhY3RlciBpbnNlcnRpb24gZm9yIHNpbmdsZSBjaGFyYWN0ZXJzIGEteiBvciBzcGFjZSBmb3Igbm93LlxuICAgICAgLy8gTG9uZy1wcmVzcyBldmVudHMgKGhvbGQgYSArIHByZXNzIDQgPSDDpCkgdG8gY2hvb3NlIGEgc3BlY2lhbCBjaGFyYWN0ZXIgb3RoZXJ3aXNlXG4gICAgICAvLyBjYXVzZXMgZHVwbGljYXRlIGluc2VydHMuXG4gICAgICBldmVudC5kYXRhICYmIGV2ZW50LmRhdGEubGVuZ3RoID09PSAxICYmIC9bYS16IF0vaS50ZXN0KGV2ZW50LmRhdGEpICYmIC8vIENocm9tZSBoYXMgaXNzdWVzIGNvcnJlY3RseSBlZGl0aW5nIHRoZSBzdGFydCBvZiBub2RlczogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTI0OTQwNVxuICAgICAgLy8gV2hlbiB0aGVyZSBpcyBhbiBpbmxpbmUgZWxlbWVudCwgZS5nLiBhIGxpbmssIGFuZCB5b3Ugc2VsZWN0XG4gICAgICAvLyByaWdodCBhZnRlciBpdCAodGhlIHN0YXJ0IG9mIHRoZSBuZXh0IG5vZGUpLlxuICAgICAgc2VsZWN0aW9uLmFuY2hvci5vZmZzZXQgIT09IDApIHtcbiAgICAgICAgdmFyIF9ub2RlJHBhcmVudEVsZW1lbnQsIF93aW5kb3ckZ2V0Q29tcHV0ZWRTdDtcblxuICAgICAgICBuYXRpdmUgPSB0cnVlOyAvLyBTa2lwIG5hdGl2ZSBpZiB0aGVyZSBhcmUgbWFya3MsIGFzXG4gICAgICAgIC8vIGBpbnNlcnRUZXh0YCB3aWxsIGluc2VydCBhIG5vZGUsIG5vdCBqdXN0IHRleHQuXG5cbiAgICAgICAgaWYgKGVkaXRvci5tYXJrcykge1xuICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9IC8vIENocm9tZSBhbHNvIGhhcyBpc3N1ZXMgY29ycmVjdGx5IGVkaXRpbmcgdGhlIGVuZCBvZiBhbmNob3IgZWxlbWVudHM6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyNTkxMDBcbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIGRvbid0IGFsbG93IG5hdGl2ZSBldmVudHMgdG8gaW5zZXJ0IHRleHQgYXQgdGhlIGVuZCBvZiBhbmNob3Igbm9kZXMuXG5cblxuICAgICAgICB2YXIge1xuICAgICAgICAgIGFuY2hvclxuICAgICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgICB2YXIgW25vZGUsIG9mZnNldF0gPSBSZWFjdEVkaXRvci50b0RPTVBvaW50KGVkaXRvciwgYW5jaG9yKTtcbiAgICAgICAgdmFyIGFuY2hvck5vZGUgPSAoX25vZGUkcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX25vZGUkcGFyZW50RWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkcGFyZW50RWxlbWVudC5jbG9zZXN0KCdhJyk7XG4gICAgICAgIHZhciB3aW5kb3cgPSBSZWFjdEVkaXRvci5nZXRXaW5kb3coZWRpdG9yKTtcblxuICAgICAgICBpZiAobmF0aXZlICYmIGFuY2hvck5vZGUgJiYgUmVhY3RFZGl0b3IuaGFzRE9NTm9kZShlZGl0b3IsIGFuY2hvck5vZGUpKSB7XG4gICAgICAgICAgdmFyIF9sYXN0VGV4dCR0ZXh0Q29udGVudDtcblxuICAgICAgICAgIC8vIEZpbmQgdGhlIGxhc3QgdGV4dCBub2RlIGluc2lkZSB0aGUgYW5jaG9yLlxuICAgICAgICAgIHZhciBsYXN0VGV4dCA9IHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGFuY2hvck5vZGUsIE5vZGVGaWx0ZXIuU0hPV19URVhUKS5sYXN0Q2hpbGQoKTtcblxuICAgICAgICAgIGlmIChsYXN0VGV4dCA9PT0gbm9kZSAmJiAoKF9sYXN0VGV4dCR0ZXh0Q29udGVudCA9IGxhc3RUZXh0LnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBfbGFzdFRleHQkdGV4dENvbnRlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sYXN0VGV4dCR0ZXh0Q29udGVudC5sZW5ndGgpID09PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBDaHJvbWUgaGFzIGlzc3VlcyB3aXRoIHRoZSBwcmVzZW5jZSBvZiB0YWIgY2hhcmFjdGVycyBpbnNpZGUgZWxlbWVudHMgd2l0aCB3aGl0ZVNwYWNlID0gJ3ByZSdcbiAgICAgICAgLy8gY2F1c2luZyBhYm5vcm1hbCBpbnNlcnQgYmVoYXZpb3I6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTEyMTkxMzlcblxuXG4gICAgICAgIGlmIChuYXRpdmUgJiYgbm9kZS5wYXJlbnRFbGVtZW50ICYmICh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX3dpbmRvdyRnZXRDb21wdXRlZFN0ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZS5wYXJlbnRFbGVtZW50KSkgPT09IG51bGwgfHwgX3dpbmRvdyRnZXRDb21wdXRlZFN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfd2luZG93JGdldENvbXB1dGVkU3Qud2hpdGVTcGFjZSkgPT09ICdwcmUnKSB7XG4gICAgICAgICAgdmFyIGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGFuY2hvci5wYXRoLFxuICAgICAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGJsb2NrICYmIE5vZGUuc3RyaW5nKGJsb2NrWzBdKS5pbmNsdWRlcygnXFx0JykpIHtcbiAgICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyBDT01QQVQ6IEZvciB0aGUgZGVsZXRpbmcgZm9yd2FyZC9iYWNrd2FyZCBpbnB1dCB0eXBlcyB3ZSBkb24ndCB3YW50XG4gICAgICAvLyB0byBjaGFuZ2UgdGhlIHNlbGVjdGlvbiBiZWNhdXNlIGl0IGlzIHRoZSByYW5nZSB0aGF0IHdpbGwgYmUgZGVsZXRlZCxcbiAgICAgIC8vIGFuZCB0aG9zZSBjb21tYW5kcyBkZXRlcm1pbmUgdGhhdCBmb3IgdGhlbXNlbHZlcy5cblxuXG4gICAgICBpZiAoIXR5cGUuc3RhcnRzV2l0aCgnZGVsZXRlJykgfHwgdHlwZS5zdGFydHNXaXRoKCdkZWxldGVCeScpKSB7XG4gICAgICAgIHZhciBbdGFyZ2V0UmFuZ2VdID0gZXZlbnQuZ2V0VGFyZ2V0UmFuZ2VzKCk7XG5cbiAgICAgICAgaWYgKHRhcmdldFJhbmdlKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gUmVhY3RFZGl0b3IudG9TbGF0ZVJhbmdlKGVkaXRvciwgdGFyZ2V0UmFuZ2UsIHtcbiAgICAgICAgICAgIGV4YWN0TWF0Y2g6IGZhbHNlLFxuICAgICAgICAgICAgc3VwcHJlc3NUaHJvdzogZmFsc2VcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICghc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMoc2VsZWN0aW9uLCByYW5nZSkpIHtcbiAgICAgICAgICAgIG5hdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHNlbGVjdGlvblJlZiA9ICFpc0NvbXBvc2l0aW9uQ2hhbmdlICYmIGVkaXRvci5zZWxlY3Rpb24gJiYgRWRpdG9yLnJhbmdlUmVmKGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbik7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvblJlZikge1xuICAgICAgICAgICAgICBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uc2V0KGVkaXRvciwgc2VsZWN0aW9uUmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ29tcG9zaXRpb24gY2hhbmdlIHR5cGVzIG9jY3VyIHdoaWxlIGEgdXNlciBpcyBjb21wb3NpbmcgdGV4dCBhbmQgY2FuJ3QgYmVcbiAgICAgIC8vIGNhbmNlbGxlZC4gTGV0IHRoZW0gdGhyb3VnaCBhbmQgd2FpdCBmb3IgdGhlIGNvbXBvc2l0aW9uIHRvIGVuZC5cblxuXG4gICAgICBpZiAoaXNDb21wb3NpdGlvbkNoYW5nZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghbmF0aXZlKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IC8vIENPTVBBVDogSWYgdGhlIHNlbGVjdGlvbiBpcyBleHBhbmRlZCwgZXZlbiBpZiB0aGUgY29tbWFuZCBzZWVtcyBsaWtlXG4gICAgICAvLyBhIGRlbGV0ZSBmb3J3YXJkL2JhY2t3YXJkIGNvbW1hbmQgaXQgc2hvdWxkIGRlbGV0ZSB0aGUgc2VsZWN0aW9uLlxuXG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pICYmIHR5cGUuc3RhcnRzV2l0aCgnZGVsZXRlJykpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHR5cGUuZW5kc1dpdGgoJ0JhY2t3YXJkJykgPyAnYmFja3dhcmQnIDogJ2ZvcndhcmQnO1xuICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgZGlyZWN0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdkZWxldGVCeUNvbXBvc2l0aW9uJzpcbiAgICAgICAgY2FzZSAnZGVsZXRlQnlDdXQnOlxuICAgICAgICBjYXNlICdkZWxldGVCeURyYWcnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZUNvbnRlbnQnOlxuICAgICAgICBjYXNlICdkZWxldGVDb250ZW50Rm9yd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZvcndhcmQoZWRpdG9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVDb250ZW50QmFja3dhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZUVudGlyZVNvZnRMaW5lJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVIYXJkTGluZUJhY2t3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIHVuaXQ6ICdibG9jaydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZVNvZnRMaW5lQmFja3dhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVCYWNrd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ2xpbmUnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVIYXJkTGluZUZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnYmxvY2snXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdkZWxldGVTb2Z0TGluZUZvcndhcmQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRCYWNrd2FyZCc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICB1bml0OiAnd29yZCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2RlbGV0ZVdvcmRGb3J3YXJkJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdpbnNlcnRMaW5lQnJlYWsnOlxuICAgICAgICAgIEVkaXRvci5pbnNlcnRTb2Z0QnJlYWsoZWRpdG9yKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdpbnNlcnRQYXJhZ3JhcGgnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEVkaXRvci5pbnNlcnRCcmVhayhlZGl0b3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2luc2VydEZyb21Db21wb3NpdGlvbic6XG4gICAgICAgIGNhc2UgJ2luc2VydEZyb21Ecm9wJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbVBhc3RlJzpcbiAgICAgICAgY2FzZSAnaW5zZXJ0RnJvbVlhbmsnOlxuICAgICAgICBjYXNlICdpbnNlcnRSZXBsYWNlbWVudFRleHQnOlxuICAgICAgICBjYXNlICdpbnNlcnRUZXh0JzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ2luc2VydEZyb21Db21wb3NpdGlvbicpIHtcbiAgICAgICAgICAgICAgLy8gQ09NUEFUOiBpbiBTYWZhcmksIGBjb21wb3NpdGlvbmVuZGAgaXMgZGlzcGF0Y2hlZCBhZnRlciB0aGVcbiAgICAgICAgICAgICAgLy8gYGJlZm9yZWlucHV0YCBmb3IgXCJpbnNlcnRGcm9tQ29tcG9zaXRpb25cIi4gQnV0IGlmIHdlIHdhaXQgZm9yIGl0XG4gICAgICAgICAgICAgIC8vIHRoZW4gd2Ugd2lsbCBhYm9ydCBiZWNhdXNlIHdlJ3JlIHN0aWxsIGNvbXBvc2luZyBhbmQgdGhlIHNlbGVjdGlvblxuICAgICAgICAgICAgICAvLyB3b24ndCBiZSB1cGRhdGVkIHByb3Blcmx5LlxuICAgICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaW5wdXQtZXZlbnRzLTIvXG4gICAgICAgICAgICAgIGlmIChSZWFjdEVkaXRvci5pc0NvbXBvc2luZyhlZGl0b3IpKSB7XG4gICAgICAgICAgICAgICAgc2V0SXNDb21wb3NpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIElTX0NPTVBPU0lORy5zZXQoZWRpdG9yLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gdXNlIGEgd2VhayBjb21wYXJpc29uIGluc3RlYWQgb2YgJ2luc3RhbmNlb2YnIHRvIGFsbG93XG4gICAgICAgICAgICAvLyBwcm9ncmFtbWF0aWMgYWNjZXNzIG9mIHBhc3RlIGV2ZW50cyBjb21pbmcgZnJvbSBleHRlcm5hbCB3aW5kb3dzXG4gICAgICAgICAgICAvLyBsaWtlIGN5cHJlc3Mgd2hlcmUgY3kud2luZG93IGRvZXMgbm90IHdvcmsgcmVhbGlibHlcblxuXG4gICAgICAgICAgICBpZiAoKGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5jb25zdHJ1Y3Rvci5uYW1lKSA9PT0gJ0RhdGFUcmFuc2ZlcicpIHtcbiAgICAgICAgICAgICAgUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGRhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgLy8gT25seSBpbnNlcnRUZXh0IG9wZXJhdGlvbnMgdXNlIHRoZSBuYXRpdmUgZnVuY3Rpb25hbGl0eSwgZm9yIG5vdy5cbiAgICAgICAgICAgICAgLy8gUG90ZW50aWFsbHkgZXhwYW5kIHRvIHNpbmdsZSBjaGFyYWN0ZXIgZGVsZXRlcywgYXMgd2VsbC5cbiAgICAgICAgICAgICAgaWYgKG5hdGl2ZSkge1xuICAgICAgICAgICAgICAgIGRlZmVycmVkT3BlcmF0aW9ucy5jdXJyZW50LnB1c2goKCkgPT4gRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBkYXRhKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBkYXRhKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9IC8vIFJlc3RvcmUgdGhlIGFjdHVhbCB1c2VyIHNlY3Rpb24gaWYgbm90aGluZyBtYW51YWxseSBzZXQgaXQuXG5cblxuICAgICAgdmFyIHRvUmVzdG9yZSA9IChfRURJVE9SX1RPX1VTRVJfU0VMRUMgPSBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uZ2V0KGVkaXRvcikpID09PSBudWxsIHx8IF9FRElUT1JfVE9fVVNFUl9TRUxFQyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19VU0VSX1NFTEVDLnVucmVmKCk7XG4gICAgICBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uZGVsZXRlKGVkaXRvcik7XG5cbiAgICAgIGlmICh0b1Jlc3RvcmUgJiYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8ICFSYW5nZS5lcXVhbHMoZWRpdG9yLnNlbGVjdGlvbiwgdG9SZXN0b3JlKSkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCB0b1Jlc3RvcmUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgW3JlYWRPbmx5LCBwcm9wc09uRE9NQmVmb3JlSW5wdXRdKTsgLy8gQXR0YWNoIGEgbmF0aXZlIERPTSBldmVudCBoYW5kbGVyIGZvciBgYmVmb3JlaW5wdXRgIGV2ZW50cywgYmVjYXVzZSBSZWFjdCdzXG4gIC8vIGJ1aWx0LWluIGBvbkJlZm9yZUlucHV0YCBpcyBhY3R1YWxseSBhIGxlYWt5IHBvbHlmaWxsIHRoYXQgZG9lc24ndCBleHBvc2VcbiAgLy8gcmVhbCBgYmVmb3JlaW5wdXRgIGV2ZW50cyBzYWRseS4uLiAoMjAxOS8xMS8wNClcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMTIxMVxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChyZWYuY3VycmVudCAmJiBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgVGhlIGBiZWZvcmVpbnB1dGAgZXZlbnQgaXNuJ3QgcmVjb2duaXplZC5cbiAgICAgIHJlZi5jdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZWlucHV0Jywgb25ET01CZWZvcmVJbnB1dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChyZWYuY3VycmVudCAmJiBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBUaGUgYGJlZm9yZWlucHV0YCBldmVudCBpc24ndCByZWNvZ25pemVkLlxuICAgICAgICByZWYuY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdiZWZvcmVpbnB1dCcsIG9uRE9NQmVmb3JlSW5wdXQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtvbkRPTUJlZm9yZUlucHV0XSk7IC8vIEF0dGFjaCBhIG5hdGl2ZSBET00gZXZlbnQgaGFuZGxlciBmb3IgYHNlbGVjdGlvbmNoYW5nZWAsIGJlY2F1c2UgUmVhY3Qnc1xuICAvLyBidWlsdC1pbiBgb25TZWxlY3RgIGhhbmRsZXIgZG9lc24ndCBmaXJlIGZvciBhbGwgc2VsZWN0aW9uIGNoYW5nZXMuIEl0J3MgYVxuICAvLyBsZWFreSBwb2x5ZmlsbCB0aGF0IG9ubHkgZmlyZXMgb24ga2V5cHJlc3NlcyBvciBjbGlja3MuIEluc3RlYWQsIHdlIHdhbnQgdG9cbiAgLy8gZmlyZSBmb3IgYW55IGNoYW5nZSB0byB0aGUgc2VsZWN0aW9uIGluc2lkZSB0aGUgZWRpdG9yLiAoMjAxOS8xMS8wNClcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy81Nzg1XG5cbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIHdpbmRvdyA9IFJlYWN0RWRpdG9yLmdldFdpbmRvdyhlZGl0b3IpO1xuICAgIHdpbmRvdy5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdzZWxlY3Rpb25jaGFuZ2UnLCBzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93LmRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIHNjaGVkdWxlT25ET01TZWxlY3Rpb25DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtzY2hlZHVsZU9uRE9NU2VsZWN0aW9uQ2hhbmdlXSk7XG4gIHZhciBkZWNvcmF0aW9ucyA9IGRlY29yYXRlKFtlZGl0b3IsIFtdXSk7XG5cbiAgaWYgKHBsYWNlaG9sZGVyICYmIGVkaXRvci5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgQXJyYXkuZnJvbShOb2RlLnRleHRzKGVkaXRvcikpLmxlbmd0aCA9PT0gMSAmJiBOb2RlLnN0cmluZyhlZGl0b3IpID09PSAnJyAmJiAhaXNDb21wb3NpbmcpIHtcbiAgICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSk7XG4gICAgZGVjb3JhdGlvbnMucHVzaCh7XG4gICAgICBbUExBQ0VIT0xERVJfU1lNQk9MXTogdHJ1ZSxcbiAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgIGZvY3VzOiBzdGFydFxuICAgIH0pO1xuICB9XG5cbiAgdmFyIHtcbiAgICBtYXJrc1xuICB9ID0gZWRpdG9yO1xuICBzdGF0ZS5oYXNNYXJrUGxhY2Vob2xkZXIgPSBmYWxzZTtcblxuICBpZiAoZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKSAmJiBtYXJrcykge1xuICAgIHZhciB7XG4gICAgICBhbmNob3JcbiAgICB9ID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICB2YXIgbGVhZiA9IE5vZGUubGVhZihlZGl0b3IsIGFuY2hvci5wYXRoKTtcblxuICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGxlYWYsIF9leGNsdWRlZDIpOyAvLyBXaGlsZSBtYXJrcyBpc24ndCBhICdjb21wbGV0ZScgdGV4dCwgd2UgY2FuIHN0aWxsIHVzZSBsb29zZSBUZXh0LmVxdWFsc1xuICAgIC8vIGhlcmUgd2hpY2ggb25seSBjb21wYXJlcyBtYXJrcyBhbnl3YXkuXG5cblxuICAgIGlmICghVGV4dCQxLmVxdWFscyhsZWFmLCBtYXJrcywge1xuICAgICAgbG9vc2U6IHRydWVcbiAgICB9KSkge1xuICAgICAgc3RhdGUuaGFzTWFya1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHZhciB1bnNldCA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3Qua2V5cyhyZXN0KS5tYXAobWFyayA9PiBbbWFyaywgbnVsbF0pKTtcbiAgICAgIGRlY29yYXRpb25zLnB1c2goX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMShfb2JqZWN0U3ByZWFkJDEoe1xuICAgICAgICBbTUFSS19QTEFDRUhPTERFUl9TWU1CT0xdOiB0cnVlXG4gICAgICB9LCB1bnNldCksIG1hcmtzKSwge30sIHtcbiAgICAgICAgYW5jaG9yLFxuICAgICAgICBmb2N1czogYW5jaG9yXG4gICAgICB9KSk7XG4gICAgfVxuICB9IC8vIFVwZGF0ZSBFRElUT1JfVE9fTUFSS19QTEFDRUhPTERFUl9NQVJLUyBpbiBzZXRUaW1lb3V0IHVzZUVmZmVjdCB0byBlbnN1cmUgd2UgZG9uJ3Qgc2V0IGl0XG4gIC8vIGJlZm9yZSB3ZSByZWNlaXZlIHRoZSBjb21wb3NpdGlvbiBlbmQgZXZlbnQuXG5cblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgYW5jaG9yOiBfYW5jaG9yXG4gICAgICAgIH0gPSBzZWxlY3Rpb247XG5cbiAgICAgICAgdmFyIF90ZXh0ID0gTm9kZS5sZWFmKGVkaXRvciwgX2FuY2hvci5wYXRoKTsgLy8gV2hpbGUgbWFya3MgaXNuJ3QgYSAnY29tcGxldGUnIHRleHQsIHdlIGNhbiBzdGlsbCB1c2UgbG9vc2UgVGV4dC5lcXVhbHNcbiAgICAgICAgLy8gaGVyZSB3aGljaCBvbmx5IGNvbXBhcmVzIG1hcmtzIGFueXdheS5cblxuXG4gICAgICAgIGlmIChtYXJrcyAmJiAhVGV4dCQxLmVxdWFscyhfdGV4dCwgbWFya3MsIHtcbiAgICAgICAgICBsb29zZTogdHJ1ZVxuICAgICAgICB9KSkge1xuICAgICAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5zZXQoZWRpdG9yLCBtYXJrcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5kZWxldGUoZWRpdG9yKTtcbiAgICB9KTtcbiAgfSk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbW91bnRlZENvdW50Kys7XG5cbiAgICBpZiAobW91bnRlZENvdW50ID09PSAxKSB7XG4gICAgICAvLyBTZXQgZ2xvYmFsIGRlZmF1bHQgc3R5bGVzIGZvciBlZGl0b3JzLlxuICAgICAgdmFyIGRlZmF1bHRTdHlsZXNFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIGRlZmF1bHRTdHlsZXNFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS1kZWZhdWx0LXN0eWxlcycsICd0cnVlJyk7XG4gICAgICBkZWZhdWx0U3R5bGVzRWxlbWVudC5pbm5lckhUTUwgPSAvLyA6d2hlcmUgaXMgdXNlZCB0byBnaXZlIHRoZXNlIHJ1bGVzIGxvd2VyIHNwZWNpZmljaXR5IHNvIHVzZXIgc3R5bGVzaGVldHMgY2FuIG92ZXJyaWRlIHRoZW0uXG4gICAgICBcIjp3aGVyZShbZGF0YS1zbGF0ZS1lZGl0b3JdKSB7XCIgKyAvLyBBbGxvdyBwb3NpdGlvbmluZyByZWxhdGl2ZSB0byB0aGUgZWRpdGFibGUgZWxlbWVudC5cbiAgICAgIFwicG9zaXRpb246IHJlbGF0aXZlO1wiICsgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBvdXRsaW5lIHN0eWxlcy5cbiAgICAgIFwib3V0bGluZTogbm9uZTtcIiArIC8vIFByZXNlcnZlIGFkamFjZW50IHdoaXRlc3BhY2UgYW5kIG5ldyBsaW5lcy5cbiAgICAgIFwid2hpdGUtc3BhY2U6IHByZS13cmFwO1wiICsgLy8gQWxsb3cgd29yZHMgdG8gYnJlYWsgaWYgdGhleSBhcmUgdG9vIGxvbmcuXG4gICAgICBcIndvcmQtd3JhcDogYnJlYWstd29yZDtcIiArIFwifVwiO1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChkZWZhdWx0U3R5bGVzRWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHZhciBfZG9jdW1lbnQkcXVlcnlTZWxlY3Q7XG5cbiAgICAgIG1vdW50ZWRDb3VudC0tO1xuICAgICAgaWYgKG1vdW50ZWRDb3VudCA8PSAwKSAoX2RvY3VtZW50JHF1ZXJ5U2VsZWN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS1zbGF0ZS1kZWZhdWx0LXN0eWxlc10nKSkgPT09IG51bGwgfHwgX2RvY3VtZW50JHF1ZXJ5U2VsZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZG9jdW1lbnQkcXVlcnlTZWxlY3QucmVtb3ZlKCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICBFRElUT1JfVE9fU1RZTEVfRUxFTUVOVC5zZXQoZWRpdG9yLCBzdHlsZUVsZW1lbnQpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdHlsZUVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICBFRElUT1JfVE9fU1RZTEVfRUxFTUVOVC5kZWxldGUoZWRpdG9yKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFkT25seUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogcmVhZE9ubHlcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGVjb3JhdGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGRlY29yYXRlXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlc3RvcmVET00sIHtcbiAgICBub2RlOiByZWYsXG4gICAgcmVjZWl2ZWRVc2VySW5wdXQ6IHJlY2VpdmVkVXNlcklucHV0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgT2JqZWN0LmFzc2lnbih7XG4gICAgcm9sZTogcmVhZE9ubHkgPyB1bmRlZmluZWQgOiAndGV4dGJveCcsXG4gICAgXCJhcmlhLW11bHRpbGluZVwiOiByZWFkT25seSA/IHVuZGVmaW5lZCA6IHRydWVcbiAgfSwgYXR0cmlidXRlcywge1xuICAgIC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50LCBzbyB3ZSdkXG4gICAgLy8gaGF2ZSB0byB1c2UgaGFja3MgdG8gbWFrZSB0aGVzZSByZXBsYWNlbWVudC1iYXNlZCBmZWF0dXJlcyB3b3JrLlxuICAgIC8vIEZvciBTU1Igc2l0dWF0aW9ucyBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgaXMgZmFsc2UgYW5kIHJlc3VsdHMgaW4gcHJvcFxuICAgIC8vIG1pc21hdGNoIHdhcm5pbmcgYXBwIG1vdmVzIHRvIGJyb3dzZXIuIFBhc3MtdGhyb3VnaCBjb25zdW1lciBwcm9wcyB3aGVuXG4gICAgLy8gbm90IENBTl9VU0VfRE9NIChTU1IpIGFuZCBkZWZhdWx0IHRvIGZhbHN5IHZhbHVlXG4gICAgc3BlbGxDaGVjazogSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIHx8ICFDQU5fVVNFX0RPTSA/IGF0dHJpYnV0ZXMuc3BlbGxDaGVjayA6IGZhbHNlLFxuICAgIGF1dG9Db3JyZWN0OiBIQVNfQkVGT1JFX0lOUFVUX1NVUFBPUlQgfHwgIUNBTl9VU0VfRE9NID8gYXR0cmlidXRlcy5hdXRvQ29ycmVjdCA6ICdmYWxzZScsXG4gICAgYXV0b0NhcGl0YWxpemU6IEhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCB8fCAhQ0FOX1VTRV9ET00gPyBhdHRyaWJ1dGVzLmF1dG9DYXBpdGFsaXplIDogJ2ZhbHNlJyxcbiAgICBcImRhdGEtc2xhdGUtZWRpdG9yXCI6IHRydWUsXG4gICAgXCJkYXRhLXNsYXRlLWVkaXRvci1pZFwiOiBlZGl0b3IuaWQsXG4gICAgXCJkYXRhLXNsYXRlLW5vZGVcIjogXCJ2YWx1ZVwiLFxuICAgIC8vIGV4cGxpY2l0bHkgc2V0IHRoaXNcbiAgICBjb250ZW50RWRpdGFibGU6ICFyZWFkT25seSxcbiAgICAvLyBpbiBzb21lIGNhc2VzLCBhIGRlY29yYXRpb24gbmVlZHMgYWNjZXNzIHRvIHRoZSByYW5nZSAvIHNlbGVjdGlvbiB0byBkZWNvcmF0ZSBhIHRleHQgbm9kZSxcbiAgICAvLyB0aGVuIHlvdSB3aWxsIHNlbGVjdCB0aGUgd2hvbGUgdGV4dCBub2RlIHdoZW4geW91IHNlbGVjdCBwYXJ0IHRoZSBvZiB0ZXh0XG4gICAgLy8gdGhpcyBtYWdpYyB6SW5kZXg9XCItMVwiIHdpbGwgZml4IGl0XG4gICAgemluZGV4OiAtMSxcbiAgICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gICAgcmVmOiByZWYsXG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIG9uQmVmb3JlSW5wdXQ6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIC8vIENPTVBBVDogQ2VydGFpbiBicm93c2VycyBkb24ndCBzdXBwb3J0IHRoZSBgYmVmb3JlaW5wdXRgIGV2ZW50LCBzbyB3ZVxuICAgICAgLy8gZmFsbCBiYWNrIHRvIFJlYWN0J3MgbGVha3kgcG9seWZpbGwgaW5zdGVhZCBqdXN0IGZvciBpdC4gSXRcbiAgICAgIC8vIG9ubHkgd29ya3MgZm9yIHRoZSBgaW5zZXJ0VGV4dGAgaW5wdXQgdHlwZS5cbiAgICAgIGlmICghSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUICYmICFyZWFkT25seSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25CZWZvcmVJbnB1dCkgJiYgUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAoIVJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICB2YXIgX3RleHQyID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICBFZGl0b3IuaW5zZXJ0VGV4dChlZGl0b3IsIF90ZXh0Mik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbcmVhZE9ubHldKSxcbiAgICBvbklucHV0OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoYW5kcm9pZElucHV0TWFuYWdlcikge1xuICAgICAgICBhbmRyb2lkSW5wdXRNYW5hZ2VyLmhhbmRsZUlucHV0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRmx1c2ggbmF0aXZlIG9wZXJhdGlvbnMsIGFzIG5hdGl2ZSBldmVudHMgd2lsbCBoYXZlIHByb3BvZ2F0ZWRcbiAgICAgIC8vIGFuZCB3ZSBjYW4gY29ycmVjdGx5IGNvbXBhcmUgRE9NIHRleHQgdmFsdWVzIGluIGNvbXBvbmVudHNcbiAgICAgIC8vIHRvIHN0b3AgcmVuZGVyaW5nLCBzbyB0aGF0IGJyb3dzZXIgZnVuY3Rpb25zIGxpa2UgYXV0b2NvcnJlY3RcbiAgICAgIC8vIGFuZCBzcGVsbGNoZWNrIHdvcmsgYXMgZXhwZWN0ZWQuXG5cblxuICAgICAgZm9yICh2YXIgb3Agb2YgZGVmZXJyZWRPcGVyYXRpb25zLmN1cnJlbnQpIHtcbiAgICAgICAgb3AoKTtcbiAgICAgIH1cblxuICAgICAgZGVmZXJyZWRPcGVyYXRpb25zLmN1cnJlbnQgPSBbXTtcbiAgICB9LCBbXSksXG4gICAgb25CbHVyOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAocmVhZE9ubHkgfHwgc3RhdGUuaXNVcGRhdGluZ1NlbGVjdGlvbiB8fCAhUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgfHwgaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25CbHVyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIENPTVBBVDogSWYgdGhlIGN1cnJlbnQgYGFjdGl2ZUVsZW1lbnRgIGlzIHN0aWxsIHRoZSBwcmV2aW91c1xuICAgICAgLy8gb25lLCB0aGlzIGlzIGR1ZSB0byB0aGUgd2luZG93IGJlaW5nIGJsdXJyZWQgd2hlbiB0aGUgdGFiXG4gICAgICAvLyBpdHNlbGYgYmVjb21lcyB1bmZvY3VzZWQsIHNvIHdlIHdhbnQgdG8gYWJvcnQgZWFybHkgdG8gYWxsb3cgdG9cbiAgICAgIC8vIGVkaXRvciB0byBzdGF5IGZvY3VzZWQgd2hlbiB0aGUgdGFiIGJlY29tZXMgZm9jdXNlZCBhZ2Fpbi5cblxuXG4gICAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuXG4gICAgICBpZiAoc3RhdGUubGF0ZXN0RWxlbWVudCA9PT0gcm9vdC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldFxuICAgICAgfSA9IGV2ZW50O1xuICAgICAgdmFyIGVsID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGVkaXRvciwgZWRpdG9yKTsgLy8gQ09NUEFUOiBUaGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgaWYgdGhlIGZvY3VzIGlzIHJldHVybmluZ1xuICAgICAgLy8gdG8gdGhlIGVkaXRvciBmcm9tIGFuIGVtYmVkZGVkIGVkaXRhYmxlIGVsZW1lbnQgKGVnLiBhbiA8aW5wdXQ+XG4gICAgICAvLyBlbGVtZW50IGluc2lkZSBhIHZvaWQgbm9kZSkuXG5cbiAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ID09PSBlbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIENPTVBBVDogVGhlIGV2ZW50IHNob3VsZCBiZSBpZ25vcmVkIGlmIHRoZSBmb2N1cyBpcyBtb3ZpbmcgZnJvbVxuICAgICAgLy8gdGhlIGVkaXRvciB0byBpbnNpZGUgYSB2b2lkIG5vZGUncyBzcGFjZXIgZWxlbWVudC5cblxuXG4gICAgICBpZiAoaXNET01FbGVtZW50KHJlbGF0ZWRUYXJnZXQpICYmIHJlbGF0ZWRUYXJnZXQuaGFzQXR0cmlidXRlKCdkYXRhLXNsYXRlLXNwYWNlcicpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gQ09NUEFUOiBUaGUgZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQgaWYgdGhlIGZvY3VzIGlzIG1vdmluZyB0byBhXG4gICAgICAvLyBub24tIGVkaXRhYmxlIHNlY3Rpb24gb2YgYW4gZWxlbWVudCB0aGF0IGlzbid0IGEgdm9pZCBub2RlIChlZy5cbiAgICAgIC8vIGEgbGlzdCBpdGVtIG9mIHRoZSBjaGVjayBsaXN0IGV4YW1wbGUpLlxuXG5cbiAgICAgIGlmIChyZWxhdGVkVGFyZ2V0ICE9IG51bGwgJiYgaXNET01Ob2RlKHJlbGF0ZWRUYXJnZXQpICYmIFJlYWN0RWRpdG9yLmhhc0RPTU5vZGUoZWRpdG9yLCByZWxhdGVkVGFyZ2V0KSkge1xuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgcmVsYXRlZFRhcmdldCk7XG5cbiAgICAgICAgaWYgKEVsZW1lbnQkMS5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc1ZvaWQobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQ09NUEFUOiBTYWZhcmkgZG9lc24ndCBhbHdheXMgcmVtb3ZlIHRoZSBzZWxlY3Rpb24gZXZlbiBpZiB0aGUgY29udGVudC1cbiAgICAgIC8vIGVkaXRhYmxlIGVsZW1lbnQgbm8gbG9uZ2VyIGhhcyBmb2N1cy4gUmVmZXIgdG86XG4gICAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMjM1MzI0Ny9mb3JjZS1jb250ZW50ZWRpdGFibGUtZGl2LXRvLXN0b3AtYWNjZXB0aW5nLWlucHV0LWFmdGVyLWl0LWxvc2VzLWZvY3VzLXVuZGVyLXdlYlxuXG5cbiAgICAgIGlmIChJU19TQUZBUkkpIHtcbiAgICAgICAgdmFyIGRvbVNlbGVjdGlvbiA9IHJvb3QuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGRvbVNlbGVjdGlvbiA9PT0gbnVsbCB8fCBkb21TZWxlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cblxuICAgICAgSVNfRk9DVVNFRC5kZWxldGUoZWRpdG9yKTtcbiAgICB9LCBbcmVhZE9ubHksIGF0dHJpYnV0ZXMub25CbHVyXSksXG4gICAgb25DbGljazogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ2xpY2spICYmIGlzRE9NTm9kZShldmVudC50YXJnZXQpKSB7XG4gICAgICAgIHZhciBub2RlID0gUmVhY3RFZGl0b3IudG9TbGF0ZU5vZGUoZWRpdG9yLCBldmVudC50YXJnZXQpO1xuICAgICAgICB2YXIgcGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgbm9kZSk7IC8vIEF0IHRoaXMgdGltZSwgdGhlIFNsYXRlIGRvY3VtZW50IG1heSBiZSBhcmJpdHJhcmlseSBkaWZmZXJlbnQsXG4gICAgICAgIC8vIGJlY2F1c2Ugb25DbGljayBoYW5kbGVycyBjYW4gY2hhbmdlIHRoZSBkb2N1bWVudCBiZWZvcmUgd2UgZ2V0IGhlcmUuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhpcyBwYXRoIGFjdHVhbGx5IGV4aXN0cyxcbiAgICAgICAgLy8gYW5kIHRoYXQgaXQgc3RpbGwgcmVmZXJzIHRvIHRoZSBzYW1lIG5vZGUuXG5cbiAgICAgICAgaWYgKCFFZGl0b3IuaGFzUGF0aChlZGl0b3IsIHBhdGgpIHx8IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCkgIT09IG5vZGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQuZGV0YWlsID09PSBUUklQTEVfQ0xJQ0sgJiYgcGF0aC5sZW5ndGggPj0gMSkge1xuICAgICAgICAgIHZhciBibG9ja1BhdGggPSBwYXRoO1xuXG4gICAgICAgICAgaWYgKCFFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgX2Jsb2NrJDtcblxuICAgICAgICAgICAgdmFyIGJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgICBtYXRjaDogbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pLFxuICAgICAgICAgICAgICBhdDogcGF0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBibG9ja1BhdGggPSAoX2Jsb2NrJCA9IGJsb2NrID09PSBudWxsIHx8IGJsb2NrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBibG9ja1sxXSkgIT09IG51bGwgJiYgX2Jsb2NrJCAhPT0gdm9pZCAwID8gX2Jsb2NrJCA6IHBhdGguc2xpY2UoMCwgMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgYmxvY2tQYXRoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVhZE9ubHkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXJ0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgdmFyIGVuZCA9IEVkaXRvci5lbmQoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgdmFyIHN0YXJ0Vm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBfc3RhcnRcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBlbmRWb2lkID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoc3RhcnRWb2lkICYmIGVuZFZvaWQgJiYgUGF0aC5lcXVhbHMoc3RhcnRWb2lkWzFdLCBlbmRWb2lkWzFdKSkge1xuICAgICAgICAgIHZhciBfcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBfc3RhcnQpO1xuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBfcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBhdHRyaWJ1dGVzLm9uQ2xpY2tdKSxcbiAgICBvbkNvbXBvc2l0aW9uRW5kOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgaWYgKFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICBzZXRJc0NvbXBvc2luZyhmYWxzZSk7XG4gICAgICAgICAgSVNfQ09NUE9TSU5HLnNldChlZGl0b3IsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFuZHJvaWRJbnB1dE1hbmFnZXIgPT09IG51bGwgfHwgYW5kcm9pZElucHV0TWFuYWdlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5kcm9pZElucHV0TWFuYWdlci5oYW5kbGVDb21wb3NpdGlvbkVuZChldmVudCk7XG5cbiAgICAgICAgaWYgKGlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ29tcG9zaXRpb25FbmQpIHx8IElTX0FORFJPSUQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ09NUEFUOiBJbiBDaHJvbWUsIGBiZWZvcmVpbnB1dGAgZXZlbnRzIGZvciBjb21wb3NpdGlvbnNcbiAgICAgICAgLy8gYXJlbid0IGNvcnJlY3QgYW5kIG5ldmVyIGZpcmUgdGhlIFwiaW5zZXJ0RnJvbUNvbXBvc2l0aW9uXCJcbiAgICAgICAgLy8gdHlwZSB0aGF0IHdlIG5lZWQuIFNvIGluc3RlYWQsIGluc2VydCB3aGVuZXZlciBhIGNvbXBvc2l0aW9uXG4gICAgICAgIC8vIGVuZHMgc2luY2UgaXQgd2lsbCBhbHJlYWR5IGhhdmUgYmVlbiBjb21taXR0ZWQgdG8gdGhlIERPTS5cblxuXG4gICAgICAgIGlmICghSVNfU0FGQVJJICYmICFJU19GSVJFRk9YX0xFR0FDWSAmJiAhSVNfSU9TICYmICFJU19RUUJST1dTRVIgJiYgIUlTX1dFQ0hBVEJST1dTRVIgJiYgIUlTX1VDX01PQklMRSAmJiBldmVudC5kYXRhKSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyTWFya3MgPSBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1MuZ2V0KGVkaXRvcik7XG4gICAgICAgICAgRURJVE9SX1RPX1BFTkRJTkdfSU5TRVJUSU9OX01BUktTLmRlbGV0ZShlZGl0b3IpOyAvLyBFbnN1cmUgd2UgaW5zZXJ0IHRleHQgd2l0aCB0aGUgbWFya3MgdGhlIHVzZXIgd2FzIGFjdHVhbGx5IHNlZWluZ1xuXG4gICAgICAgICAgaWYgKHBsYWNlaG9sZGVyTWFya3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgRURJVE9SX1RPX1VTRVJfTUFSS1Muc2V0KGVkaXRvciwgZWRpdG9yLm1hcmtzKTtcbiAgICAgICAgICAgIGVkaXRvci5tYXJrcyA9IHBsYWNlaG9sZGVyTWFya3M7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgRWRpdG9yLmluc2VydFRleHQoZWRpdG9yLCBldmVudC5kYXRhKTtcbiAgICAgICAgICB2YXIgdXNlck1hcmtzID0gRURJVE9SX1RPX1VTRVJfTUFSS1MuZ2V0KGVkaXRvcik7XG4gICAgICAgICAgRURJVE9SX1RPX1VTRVJfTUFSS1MuZGVsZXRlKGVkaXRvcik7XG5cbiAgICAgICAgICBpZiAodXNlck1hcmtzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXRvci5tYXJrcyA9IHVzZXJNYXJrcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uRW5kXSksXG4gICAgb25Db21wb3NpdGlvblVwZGF0ZTogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uVXBkYXRlKSkge1xuICAgICAgICBpZiAoIVJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICBzZXRJc0NvbXBvc2luZyh0cnVlKTtcbiAgICAgICAgICBJU19DT01QT1NJTkcuc2V0KGVkaXRvciwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uVXBkYXRlXSksXG4gICAgb25Db21wb3NpdGlvblN0YXJ0OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgYW5kcm9pZElucHV0TWFuYWdlciA9PT0gbnVsbCB8fCBhbmRyb2lkSW5wdXRNYW5hZ2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmRyb2lkSW5wdXRNYW5hZ2VyLmhhbmRsZUNvbXBvc2l0aW9uU3RhcnQoZXZlbnQpO1xuXG4gICAgICAgIGlmIChpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkNvbXBvc2l0aW9uU3RhcnQpIHx8IElTX0FORFJPSUQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzZXRJc0NvbXBvc2luZyh0cnVlKTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlubGluZSA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoaW5saW5lKSB7XG4gICAgICAgICAgICB2YXIgWywgaW5saW5lUGF0aF0gPSBpbmxpbmU7XG5cbiAgICAgICAgICAgIGlmIChFZGl0b3IuaXNFbmQoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yLCBpbmxpbmVQYXRoKSkge1xuICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBpbmxpbmVQYXRoKTtcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYW5jaG9yOiBwb2ludCxcbiAgICAgICAgICAgICAgICBmb2N1czogcG9pbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW2F0dHJpYnV0ZXMub25Db21wb3NpdGlvblN0YXJ0XSksXG4gICAgb25Db3B5OiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoUmVhY3RFZGl0b3IuaGFzU2VsZWN0YWJsZVRhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uQ29weSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgUmVhY3RFZGl0b3Iuc2V0RnJhZ21lbnREYXRhKGVkaXRvciwgZXZlbnQuY2xpcGJvYXJkRGF0YSwgJ2NvcHknKTtcbiAgICAgIH1cbiAgICB9LCBbYXR0cmlidXRlcy5vbkNvcHldKSxcbiAgICBvbkN1dDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBSZWFjdEVkaXRvci5oYXNTZWxlY3RhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSAmJiAhaXNFdmVudEhhbmRsZWQoZXZlbnQsIGF0dHJpYnV0ZXMub25DdXQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFJlYWN0RWRpdG9yLnNldEZyYWdtZW50RGF0YShlZGl0b3IsIGV2ZW50LmNsaXBib2FyZERhdGEsICdjdXQnKTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBzZWxlY3Rpb25cbiAgICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUZyYWdtZW50KGVkaXRvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yLnBhdGgpO1xuXG4gICAgICAgICAgICBpZiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBhdHRyaWJ1dGVzLm9uQ3V0XSksXG4gICAgb25EcmFnT3ZlcjogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRHJhZ092ZXIpKSB7XG4gICAgICAgIC8vIE9ubHkgd2hlbiB0aGUgdGFyZ2V0IGlzIHZvaWQsIGNhbGwgYHByZXZlbnREZWZhdWx0YCB0byBzaWduYWxcbiAgICAgICAgLy8gdGhhdCBkcm9wcyBhcmUgYWxsb3dlZC4gRWRpdGFibGUgY29udGVudCBpcyBkcm9wcGFibGUgYnlcbiAgICAgICAgLy8gZGVmYXVsdCwgYW5kIGNhbGxpbmcgYHByZXZlbnREZWZhdWx0YCBoaWRlcyB0aGUgY3Vyc29yLlxuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0RWRpdG9yLnRvU2xhdGVOb2RlKGVkaXRvciwgZXZlbnQudGFyZ2V0KTtcblxuICAgICAgICBpZiAoRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFthdHRyaWJ1dGVzLm9uRHJhZ092ZXJdKSxcbiAgICBvbkRyYWdTdGFydDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBSZWFjdEVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkRyYWdTdGFydCkpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBSZWFjdEVkaXRvci50b1NsYXRlTm9kZShlZGl0b3IsIGV2ZW50LnRhcmdldCk7XG4gICAgICAgIHZhciBwYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBub2RlKTtcbiAgICAgICAgdmFyIHZvaWRNYXRjaCA9IEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSB8fCBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICB9KTsgLy8gSWYgc3RhcnRpbmcgYSBkcmFnIG9uIGEgdm9pZCBub2RlLCBtYWtlIHN1cmUgaXQgaXMgc2VsZWN0ZWRcbiAgICAgICAgLy8gc28gdGhhdCBpdCBzaG93cyB1cCBpbiB0aGUgc2VsZWN0aW9uJ3MgZnJhZ21lbnQuXG5cbiAgICAgICAgaWYgKHZvaWRNYXRjaCkge1xuICAgICAgICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgcmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkgPSB0cnVlO1xuICAgICAgICBSZWFjdEVkaXRvci5zZXRGcmFnbWVudERhdGEoZWRpdG9yLCBldmVudC5kYXRhVHJhbnNmZXIsICdkcmFnJyk7XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBhdHRyaWJ1dGVzLm9uRHJhZ1N0YXJ0XSksXG4gICAgb25Ecm9wOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc1RhcmdldChlZGl0b3IsIGV2ZW50LnRhcmdldCkgJiYgIWlzRXZlbnRIYW5kbGVkKGV2ZW50LCBhdHRyaWJ1dGVzLm9uRHJvcCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgZHJhZ2dlZCByYW5nZSBiZWZvcmUgdXBkYXRpbmcgc2VsZWN0aW9uXG5cbiAgICAgICAgdmFyIGRyYWdnZWRSYW5nZSA9IGVkaXRvci5zZWxlY3Rpb247IC8vIEZpbmQgdGhlIHJhbmdlIHdoZXJlIHRoZSBkcm9wIGhhcHBlbmVkXG5cbiAgICAgICAgdmFyIHJhbmdlID0gUmVhY3RFZGl0b3IuZmluZEV2ZW50UmFuZ2UoZWRpdG9yLCBldmVudCk7XG4gICAgICAgIHZhciBkYXRhID0gZXZlbnQuZGF0YVRyYW5zZmVyO1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHJhbmdlKTtcblxuICAgICAgICBpZiAoc3RhdGUuaXNEcmFnZ2luZ0ludGVybmFsbHkpIHtcbiAgICAgICAgICBpZiAoZHJhZ2dlZFJhbmdlICYmICFSYW5nZS5lcXVhbHMoZHJhZ2dlZFJhbmdlLCByYW5nZSkgJiYgIUVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIGF0OiBkcmFnZ2VkUmFuZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIFJlYWN0RWRpdG9yLmluc2VydERhdGEoZWRpdG9yLCBkYXRhKTsgLy8gV2hlbiBkcmFnZ2luZyBmcm9tIGFub3RoZXIgc291cmNlIGludG8gdGhlIGVkaXRvciwgaXQncyBwb3NzaWJsZVxuICAgICAgICAvLyB0aGF0IHRoZSBjdXJyZW50IGVkaXRvciBkb2VzIG5vdCBoYXZlIGZvY3VzLlxuXG4gICAgICAgIGlmICghUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikpIHtcbiAgICAgICAgICBSZWFjdEVkaXRvci5mb2N1cyhlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5ID0gZmFsc2U7XG4gICAgfSwgW3JlYWRPbmx5LCBhdHRyaWJ1dGVzLm9uRHJvcF0pLFxuICAgIG9uRHJhZ0VuZDogdXNlQ2FsbGJhY2soZXZlbnQgPT4ge1xuICAgICAgaWYgKCFyZWFkT25seSAmJiBzdGF0ZS5pc0RyYWdnaW5nSW50ZXJuYWxseSAmJiBhdHRyaWJ1dGVzLm9uRHJhZ0VuZCAmJiBSZWFjdEVkaXRvci5oYXNUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMub25EcmFnRW5kKGV2ZW50KTtcbiAgICAgIH0gLy8gV2hlbiBkcm9wcGluZyBvbiBhIGRpZmZlcmVudCBkcm9wcGFibGUgZWxlbWVudCB0aGFuIHRoZSBjdXJyZW50IGVkaXRvcixcbiAgICAgIC8vIGBvbkRyb3BgIGlzIG5vdCBjYWxsZWQuIFNvIHdlIG5lZWQgdG8gY2xlYW4gdXAgaW4gYG9uRHJhZ0VuZGAgaW5zdGVhZC5cbiAgICAgIC8vIE5vdGU6IGBvbkRyYWdFbmRgIGlzIG9ubHkgY2FsbGVkIHdoZW4gYG9uRHJvcGAgaXMgbm90IGNhbGxlZFxuXG5cbiAgICAgIHN0YXRlLmlzRHJhZ2dpbmdJbnRlcm5hbGx5ID0gZmFsc2U7XG4gICAgfSwgW3JlYWRPbmx5LCBhdHRyaWJ1dGVzLm9uRHJhZ0VuZF0pLFxuICAgIG9uRm9jdXM6IHVzZUNhbGxiYWNrKGV2ZW50ID0+IHtcbiAgICAgIGlmICghcmVhZE9ubHkgJiYgIXN0YXRlLmlzVXBkYXRpbmdTZWxlY3Rpb24gJiYgUmVhY3RFZGl0b3IuaGFzRWRpdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbkZvY3VzKSkge1xuICAgICAgICB2YXIgZWwgPSBSZWFjdEVkaXRvci50b0RPTU5vZGUoZWRpdG9yLCBlZGl0b3IpO1xuICAgICAgICB2YXIgcm9vdCA9IFJlYWN0RWRpdG9yLmZpbmREb2N1bWVudE9yU2hhZG93Um9vdChlZGl0b3IpO1xuICAgICAgICBzdGF0ZS5sYXRlc3RFbGVtZW50ID0gcm9vdC5hY3RpdmVFbGVtZW50OyAvLyBDT01QQVQ6IElmIHRoZSBlZGl0b3IgaGFzIG5lc3RlZCBlZGl0YWJsZSBlbGVtZW50cywgdGhlIGZvY3VzXG4gICAgICAgIC8vIGNhbiBnbyB0byB0aGVtLiBJbiBGaXJlZm94LCB0aGlzIG11c3QgYmUgcHJldmVudGVkIGJlY2F1c2UgaXRcbiAgICAgICAgLy8gcmVzdWx0cyBpbiBpc3N1ZXMgd2l0aCBrZXlib2FyZCBuYXZpZ2F0aW9uLiAoMjAxNy8wMy8zMClcblxuICAgICAgICBpZiAoSVNfRklSRUZPWCAmJiBldmVudC50YXJnZXQgIT09IGVsKSB7XG4gICAgICAgICAgZWwuZm9jdXMoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBJU19GT0NVU0VELnNldChlZGl0b3IsIHRydWUpO1xuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgYXR0cmlidXRlcy5vbkZvY3VzXSksXG4gICAgb25LZXlEb3duOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc0VkaXRhYmxlVGFyZ2V0KGVkaXRvciwgZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICBhbmRyb2lkSW5wdXRNYW5hZ2VyID09PSBudWxsIHx8IGFuZHJvaWRJbnB1dE1hbmFnZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFuZHJvaWRJbnB1dE1hbmFnZXIuaGFuZGxlS2V5RG93bihldmVudCk7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbmF0aXZlRXZlbnRcbiAgICAgICAgfSA9IGV2ZW50OyAvLyBDT01QQVQ6IFRoZSBjb21wb3NpdGlvbiBlbmQgZXZlbnQgaXNuJ3QgZmlyZWQgcmVsaWFibHkgaW4gYWxsIGJyb3dzZXJzLFxuICAgICAgICAvLyBzbyB3ZSBzb21ldGltZXMgbWlnaHQgZW5kIHVwIHN0dWNrIGluIGEgY29tcG9zaXRpb24gc3RhdGUgZXZlbiB0aG91Z2ggd2VcbiAgICAgICAgLy8gYXJlbid0IGNvbXBvc2luZyBhbnkgbW9yZS5cblxuICAgICAgICBpZiAoUmVhY3RFZGl0b3IuaXNDb21wb3NpbmcoZWRpdG9yKSAmJiBuYXRpdmVFdmVudC5pc0NvbXBvc2luZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBJU19DT01QT1NJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgICAgICAgIHNldElzQ29tcG9zaW5nKGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vbktleURvd24pIHx8IFJlYWN0RWRpdG9yLmlzQ29tcG9zaW5nKGVkaXRvcikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIge1xuICAgICAgICAgIHNlbGVjdGlvblxuICAgICAgICB9ID0gZWRpdG9yO1xuICAgICAgICB2YXIgZWxlbWVudCA9IGVkaXRvci5jaGlsZHJlbltzZWxlY3Rpb24gIT09IG51bGwgPyBzZWxlY3Rpb24uZm9jdXMucGF0aFswXSA6IDBdO1xuICAgICAgICB2YXIgaXNSVEwgPSBnZXREaXJlY3Rpb24oTm9kZS5zdHJpbmcoZWxlbWVudCkpID09PSAncnRsJzsgLy8gQ09NUEFUOiBTaW5jZSB3ZSBwcmV2ZW50IHRoZSBkZWZhdWx0IGJlaGF2aW9yIG9uXG4gICAgICAgIC8vIGBiZWZvcmVpbnB1dGAgZXZlbnRzLCB0aGUgYnJvd3NlciBkb2Vzbid0IHRoaW5rIHRoZXJlJ3MgZXZlclxuICAgICAgICAvLyBhbnkgaGlzdG9yeSBzdGFjayB0byB1bmRvIG9yIHJlZG8sIHNvIHdlIGhhdmUgdG8gbWFuYWdlIHRoZXNlXG4gICAgICAgIC8vIGhvdGtleXMgb3Vyc2VsdmVzLiAoMjAxOS8xMS8wNilcblxuICAgICAgICBpZiAoSG90a2V5cy5pc1JlZG8obmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB2YXIgbWF5YmVIaXN0b3J5RWRpdG9yID0gZWRpdG9yO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBtYXliZUhpc3RvcnlFZGl0b3IucmVkbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbWF5YmVIaXN0b3J5RWRpdG9yLnJlZG8oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc1VuZG8obmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB2YXIgX21heWJlSGlzdG9yeUVkaXRvciA9IGVkaXRvcjtcblxuICAgICAgICAgIGlmICh0eXBlb2YgX21heWJlSGlzdG9yeUVkaXRvci51bmRvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBfbWF5YmVIaXN0b3J5RWRpdG9yLnVuZG8oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ09NUEFUOiBDZXJ0YWluIGJyb3dzZXJzIGRvbid0IGhhbmRsZSB0aGUgc2VsZWN0aW9uIHVwZGF0ZXNcbiAgICAgICAgLy8gcHJvcGVybHkuIEluIENocm9tZSwgdGhlIHNlbGVjdGlvbiBpc24ndCBwcm9wZXJseSBleHRlbmRlZC5cbiAgICAgICAgLy8gQW5kIGluIEZpcmVmb3gsIHRoZSBzZWxlY3Rpb24gaXNuJ3QgcHJvcGVybHkgY29sbGFwc2VkLlxuICAgICAgICAvLyAoMjAxNy8xMC8xNylcblxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzTW92ZUxpbmVCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJyxcbiAgICAgICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVMaW5lRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChIb3RrZXlzLmlzRXh0ZW5kTGluZUJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnLFxuICAgICAgICAgICAgZWRnZTogJ2ZvY3VzJyxcbiAgICAgICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc0V4dGVuZExpbmVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ2xpbmUnLFxuICAgICAgICAgICAgZWRnZTogJ2ZvY3VzJ1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBDT01QQVQ6IElmIGEgdm9pZCBub2RlIGlzIHNlbGVjdGVkLCBvciBhIHplcm8td2lkdGggdGV4dCBub2RlXG4gICAgICAgIC8vIGFkamFjZW50IHRvIGFuIGlubGluZSBpcyBzZWxlY3RlZCwgd2UgbmVlZCB0byBoYW5kbGUgdGhlc2VcbiAgICAgICAgLy8gaG90a2V5cyBtYW51YWxseSBiZWNhdXNlIGJyb3dzZXJzIHdvbid0IGJlIGFibGUgdG8gc2tpcCBvdmVyXG4gICAgICAgIC8vIHRoZSB2b2lkIG5vZGUgd2l0aCB0aGUgemVyby13aWR0aCBzcGFjZSBub3QgYmVpbmcgYW4gZW1wdHlcbiAgICAgICAgLy8gc3RyaW5nLlxuXG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgICByZXZlcnNlOiAhaXNSVExcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmNvbGxhcHNlKGVkaXRvciwge1xuICAgICAgICAgICAgICBlZGdlOiAnc3RhcnQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSG90a2V5cy5pc01vdmVGb3J3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgcmV2ZXJzZTogaXNSVExcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmNvbGxhcHNlKGVkaXRvciwge1xuICAgICAgICAgICAgICBlZGdlOiAnZW5kJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlV29yZEJhY2t3YXJkKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgVHJhbnNmb3Jtcy5jb2xsYXBzZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgZWRnZTogJ2ZvY3VzJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgICAgICAgdW5pdDogJ3dvcmQnLFxuICAgICAgICAgICAgcmV2ZXJzZTogIWlzUlRMXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEhvdGtleXMuaXNNb3ZlV29yZEZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLmNvbGxhcHNlKGVkaXRvciwge1xuICAgICAgICAgICAgICBlZGdlOiAnZm9jdXMnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgICB1bml0OiAnd29yZCcsXG4gICAgICAgICAgICByZXZlcnNlOiBpc1JUTFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudCwgc28gd2VcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGd1ZXNzaW5nIGF0IHRoZSBpbnB1dCBpbnRlbnRpb24gZm9yIGhvdGtleXMuXG4gICAgICAgIC8vIENPTVBBVDogSW4gaU9TLCBzb21lIG9mIHRoZXNlIGhvdGtleXMgYXJlIGhhbmRsZWQgaW4gdGhlXG5cblxuICAgICAgICBpZiAoIUhBU19CRUZPUkVfSU5QVVRfU1VQUE9SVCkge1xuICAgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgYSBjb3JlIGJlaGF2aW9yIGZvciB0aGVzZSwgYnV0IHRoZXkgY2hhbmdlIHRoZVxuICAgICAgICAgIC8vIERPTSBpZiB3ZSBkb24ndCBwcmV2ZW50IHRoZW0sIHNvIHdlIGhhdmUgdG8uXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNCb2xkKG5hdGl2ZUV2ZW50KSB8fCBIb3RrZXlzLmlzSXRhbGljKG5hdGl2ZUV2ZW50KSB8fCBIb3RrZXlzLmlzVHJhbnNwb3NlQ2hhcmFjdGVyKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc1NvZnRCcmVhayhuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBFZGl0b3IuaW5zZXJ0U29mdEJyZWFrKGVkaXRvcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNTcGxpdEJsb2NrKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIEVkaXRvci5pbnNlcnRCcmVhayhlZGl0b3IpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnZm9yd2FyZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVMaW5lQmFja3dhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnYmFja3dhcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIHVuaXQ6ICdsaW5lJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChIb3RrZXlzLmlzRGVsZXRlTGluZUZvcndhcmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzRXhwYW5kZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRnJhZ21lbnQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uOiAnZm9yd2FyZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlRm9yd2FyZChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICB1bml0OiAnbGluZSdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoSG90a2V5cy5pc0RlbGV0ZVdvcmRCYWNrd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdiYWNrd2FyZCdcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBFZGl0b3IuZGVsZXRlQmFja3dhcmQoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgdW5pdDogJ3dvcmQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKEhvdGtleXMuaXNEZWxldGVXb3JkRm9yd2FyZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGcmFnbWVudChlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246ICdmb3J3YXJkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIEVkaXRvci5kZWxldGVGb3J3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIHVuaXQ6ICd3b3JkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoSVNfQ0hST01FIHx8IElTX1NBRkFSSSkge1xuICAgICAgICAgICAgLy8gQ09NUEFUOiBDaHJvbWUgYW5kIFNhZmFyaSBzdXBwb3J0IGBiZWZvcmVpbnB1dGAgZXZlbnQgYnV0IGRvIG5vdCBmaXJlXG4gICAgICAgICAgICAvLyBhbiBldmVudCB3aGVuIGRlbGV0aW5nIGJhY2t3YXJkcyBpbiBhIHNlbGVjdGVkIHZvaWQgaW5saW5lIG5vZGVcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gJiYgKEhvdGtleXMuaXNEZWxldGVCYWNrd2FyZChuYXRpdmVFdmVudCkgfHwgSG90a2V5cy5pc0RlbGV0ZUZvcndhcmQobmF0aXZlRXZlbnQpKSAmJiBSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IE5vZGUucGFyZW50KGVkaXRvciwgc2VsZWN0aW9uLmFuY2hvci5wYXRoKTtcblxuICAgICAgICAgICAgICBpZiAoRWxlbWVudCQxLmlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIGN1cnJlbnROb2RlKSAmJiAoRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgY3VycmVudE5vZGUpIHx8IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgY3VycmVudE5vZGUpKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgRWRpdG9yLmRlbGV0ZUJhY2t3YXJkKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgdW5pdDogJ2Jsb2NrJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIFtyZWFkT25seSwgYXR0cmlidXRlcy5vbktleURvd25dKSxcbiAgICBvblBhc3RlOiB1c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgICBpZiAoIXJlYWRPbmx5ICYmIFJlYWN0RWRpdG9yLmhhc1NlbGVjdGFibGVUYXJnZXQoZWRpdG9yLCBldmVudC50YXJnZXQpICYmICFpc0V2ZW50SGFuZGxlZChldmVudCwgYXR0cmlidXRlcy5vblBhc3RlKSkge1xuICAgICAgICAvLyBDT01QQVQ6IENlcnRhaW4gYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgYGJlZm9yZWlucHV0YCBldmVudCwgc28gd2VcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIFJlYWN0J3MgYG9uUGFzdGVgIGhlcmUgaW5zdGVhZC5cbiAgICAgICAgLy8gQ09NUEFUOiBGaXJlZm94LCBDaHJvbWUgYW5kIFNhZmFyaSBkb24ndCBlbWl0IGBiZWZvcmVpbnB1dGAgZXZlbnRzXG4gICAgICAgIC8vIHdoZW4gXCJwYXN0ZSB3aXRob3V0IGZvcm1hdHRpbmdcIiBpcyB1c2VkLCBzbyBmYWxsYmFjay4gKDIwMjAvMDIvMjApXG4gICAgICAgIGlmICghSEFTX0JFRk9SRV9JTlBVVF9TVVBQT1JUIHx8IGlzUGxhaW5UZXh0T25seVBhc3RlKGV2ZW50Lm5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgUmVhY3RFZGl0b3IuaW5zZXJ0RGF0YShlZGl0b3IsIGV2ZW50LmNsaXBib2FyZERhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwgW3JlYWRPbmx5LCBhdHRyaWJ1dGVzLm9uUGFzdGVdKVxuICB9KSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQ2hpbGRyZW4sIHtcbiAgICBkZWNvcmF0aW9uczogZGVjb3JhdGlvbnMsXG4gICAgbm9kZTogZWRpdG9yLFxuICAgIHJlbmRlckVsZW1lbnQ6IHJlbmRlckVsZW1lbnQsXG4gICAgcmVuZGVyUGxhY2Vob2xkZXI6IHJlbmRlclBsYWNlaG9sZGVyLFxuICAgIHJlbmRlckxlYWY6IHJlbmRlckxlYWYsXG4gICAgc2VsZWN0aW9uOiBlZGl0b3Iuc2VsZWN0aW9uXG4gIH0pKSkpKTtcbn07XG4vKipcclxuICogVGhlIGRlZmF1bHQgcGxhY2Vob2xkZXIgZWxlbWVudFxyXG4gKi9cblxudmFyIERlZmF1bHRQbGFjZWhvbGRlciA9IF9yZWYgPT4ge1xuICB2YXIge1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWY7XG4gIHJldHVybiAoXG4gICAgLyojX19QVVJFX18qL1xuICAgIC8vIENPTVBBVDogQXJ0aWZpY2lhbGx5IGFkZCBhIGxpbmUtYnJlYWsgdG8gdGhlIGVuZCBvbiB0aGUgcGxhY2Vob2xkZXIgZWxlbWVudFxuICAgIC8vIHRvIHByZXZlbnQgQW5kcm9pZCBJTUVzIHRvIHBpY2sgdXAgaXRzIGNvbnRlbnQgaW4gYXV0b2NvcnJlY3QgYW5kIHRvIGF1dG8tY2FwaXRhbGl6ZSB0aGUgZmlyc3QgbGV0dGVyXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgT2JqZWN0LmFzc2lnbih7fSwgYXR0cmlidXRlcyksIGNoaWxkcmVuLCBJU19BTkRST0lEICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYnJcIiwgbnVsbCkpXG4gICk7XG59O1xuLyoqXHJcbiAqIEEgZGVmYXVsdCBtZW1vaXplZCBkZWNvcmF0ZSBmdW5jdGlvbi5cclxuICovXG5cbnZhciBkZWZhdWx0RGVjb3JhdGUgPSAoKSA9PiBbXTtcbi8qKlxyXG4gKiBBIGRlZmF1bHQgaW1wbGVtZW50IHRvIHNjcm9sbCBkb20gcmFuZ2UgaW50byB2aWV3LlxyXG4gKi9cblxudmFyIGRlZmF1bHRTY3JvbGxTZWxlY3Rpb25JbnRvVmlldyA9IChlZGl0b3IsIGRvbVJhbmdlKSA9PiB7XG4gIC8vIFRoaXMgd2FzIGFmZmVjdGluZyB0aGUgc2VsZWN0aW9uIG9mIG11bHRpcGxlIGJsb2NrcyBhbmQgZHJhZ2dpbmcgYmVoYXZpb3IsXG4gIC8vIHNvIGVuYWJsZWQgb25seSBpZiB0aGUgc2VsZWN0aW9uIGhhcyBiZWVuIGNvbGxhcHNlZC5cbiAgaWYgKCFlZGl0b3Iuc2VsZWN0aW9uIHx8IGVkaXRvci5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZWRpdG9yLnNlbGVjdGlvbikpIHtcbiAgICB2YXIgbGVhZkVsID0gZG9tUmFuZ2Uuc3RhcnRDb250YWluZXIucGFyZW50RWxlbWVudDtcbiAgICBsZWFmRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gZG9tUmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmJpbmQoZG9tUmFuZ2UpO1xuICAgIHNjcm9sbEludG9WaWV3KGxlYWZFbCwge1xuICAgICAgc2Nyb2xsTW9kZTogJ2lmLW5lZWRlZCdcbiAgICB9KTsgLy8gQHRzLWV4cGVjdC1lcnJvciBhbiB1bm9ydGhvZG94IGRlbGV0ZSBEOlxuXG4gICAgZGVsZXRlIGxlYWZFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3Q7XG4gIH1cbn07XG4vKipcclxuICogQ2hlY2sgaWYgYW4gZXZlbnQgaXMgb3ZlcnJpZGVkIGJ5IGEgaGFuZGxlci5cclxuICovXG5cblxudmFyIGlzRXZlbnRIYW5kbGVkID0gKGV2ZW50LCBoYW5kbGVyKSA9PiB7XG4gIGlmICghaGFuZGxlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBUaGUgY3VzdG9tIGV2ZW50IGhhbmRsZXIgbWF5IHJldHVybiBhIGJvb2xlYW4gdG8gc3BlY2lmeSB3aGV0aGVyIHRoZSBldmVudFxuICAvLyBzaGFsbCBiZSB0cmVhdGVkIGFzIGJlaW5nIGhhbmRsZWQgb3Igbm90LlxuXG5cbiAgdmFyIHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQgPSBoYW5kbGVyKGV2ZW50KTtcblxuICBpZiAoc2hvdWxkVHJlYXRFdmVudEFzSGFuZGxlZCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQ7XG4gIH1cblxuICByZXR1cm4gZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBET00gZXZlbnQgaXMgb3ZlcnJpZGVkIGJ5IGEgaGFuZGxlci5cclxuICovXG5cbnZhciBpc0RPTUV2ZW50SGFuZGxlZCA9IChldmVudCwgaGFuZGxlcikgPT4ge1xuICBpZiAoIWhhbmRsZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gVGhlIGN1c3RvbSBldmVudCBoYW5kbGVyIG1heSByZXR1cm4gYSBib29sZWFuIHRvIHNwZWNpZnkgd2hldGhlciB0aGUgZXZlbnRcbiAgLy8gc2hhbGwgYmUgdHJlYXRlZCBhcyBiZWluZyBoYW5kbGVkIG9yIG5vdC5cblxuXG4gIHZhciBzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkID0gaGFuZGxlcihldmVudCk7XG5cbiAgaWYgKHNob3VsZFRyZWF0RXZlbnRBc0hhbmRsZWQgIT0gbnVsbCkge1xuICAgIHJldHVybiBzaG91bGRUcmVhdEV2ZW50QXNIYW5kbGVkO1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQ7XG59O1xuXG4vKipcclxuICogQSBSZWFjdCBjb250ZXh0IGZvciBzaGFyaW5nIHRoZSBgZm9jdXNlZGAgc3RhdGUgb2YgdGhlIGVkaXRvci5cclxuICovXG5cbnZhciBGb2N1c2VkQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KGZhbHNlKTtcbi8qKlxyXG4gKiBHZXQgdGhlIGN1cnJlbnQgYGZvY3VzZWRgIHN0YXRlIG9mIHRoZSBlZGl0b3IuXHJcbiAqL1xuXG52YXIgdXNlRm9jdXNlZCA9ICgpID0+IHtcbiAgcmV0dXJuIHVzZUNvbnRleHQoRm9jdXNlZENvbnRleHQpO1xufTtcblxuZnVuY3Rpb24gaXNFcnJvcihlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbi8qKlxyXG4gKiBBIFJlYWN0IGNvbnRleHQgZm9yIHNoYXJpbmcgdGhlIGVkaXRvciBzZWxlY3RvciBjb250ZXh0IGluIGEgd2F5IHRvIGNvbnRyb2wgcmVyZW5kZXJzXHJcbiAqL1xuXG5cbnZhciBTbGF0ZVNlbGVjdG9yQ29udGV4dCA9IC8qI19fUFVSRV9fKi9jcmVhdGVDb250ZXh0KHt9KTtcblxudmFyIHJlZkVxdWFsaXR5ID0gKGEsIGIpID0+IGEgPT09IGI7XG4vKipcclxuICogdXNlIHJlZHV4IHN0eWxlIHNlbGVjdG9ycyB0byBwcmV2ZW50IHJlcmVuZGVyaW5nIG9uIGV2ZXJ5IGtleXN0cm9rZS5cclxuICogQmVhciBpbiBtaW5kIHJlcmVuZGVyaW5nIGNhbiBvbmx5IHByZXZlbnRlZCBpZiB0aGUgcmV0dXJuZWQgdmFsdWUgaXMgYSB2YWx1ZSB0eXBlIG9yIGZvciByZWZlcmVuY2UgdHlwZXMgKGUuZy4gb2JqZWN0cyBhbmQgYXJyYXlzKSBhZGQgYSBjdXN0b20gZXF1YWxpdHkgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEV4YW1wbGU6XHJcbiAqIGBgYFxyXG4gKiAgY29uc3QgaXNTZWxlY3Rpb25BY3RpdmUgPSB1c2VTbGF0ZVNlbGVjdG9yKGVkaXRvciA9PiBCb29sZWFuKGVkaXRvci5zZWxlY3Rpb24pKTtcclxuICogYGBgXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHVzZVNsYXRlU2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgdmFyIGVxdWFsaXR5Rm4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHJlZkVxdWFsaXR5O1xuICB2YXIgWywgZm9yY2VSZW5kZXJdID0gdXNlUmVkdWNlcihzID0+IHMgKyAxLCAwKTtcbiAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KFNsYXRlU2VsZWN0b3JDb250ZXh0KTtcblxuICBpZiAoIWNvbnRleHQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgYHVzZVNsYXRlU2VsZWN0b3JgIGhvb2sgbXVzdCBiZSB1c2VkIGluc2lkZSB0aGUgPFNsYXRlPiBjb21wb25lbnQncyBjb250ZXh0LlwiKTtcbiAgfVxuXG4gIHZhciB7XG4gICAgZ2V0U2xhdGUsXG4gICAgYWRkRXZlbnRMaXN0ZW5lclxuICB9ID0gY29udGV4dDtcbiAgdmFyIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IgPSB1c2VSZWYoKTtcbiAgdmFyIGxhdGVzdFNlbGVjdG9yID0gdXNlUmVmKCgpID0+IG51bGwpO1xuICB2YXIgbGF0ZXN0U2VsZWN0ZWRTdGF0ZSA9IHVzZVJlZihudWxsKTtcbiAgdmFyIHNlbGVjdGVkU3RhdGU7XG5cbiAgdHJ5IHtcbiAgICBpZiAoc2VsZWN0b3IgIT09IGxhdGVzdFNlbGVjdG9yLmN1cnJlbnQgfHwgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50KSB7XG4gICAgICBzZWxlY3RlZFN0YXRlID0gc2VsZWN0b3IoZ2V0U2xhdGUoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdGVkU3RhdGUgPSBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQ7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAobGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ICYmIGlzRXJyb3IoZXJyKSkge1xuICAgICAgZXJyLm1lc3NhZ2UgKz0gXCJcXG5UaGUgZXJyb3IgbWF5IGJlIGNvcnJlbGF0ZWQgd2l0aCB0aGlzIHByZXZpb3VzIGVycm9yOlxcblwiLmNvbmNhdChsYXRlc3RTdWJzY3JpcHRpb25DYWxsYmFja0Vycm9yLmN1cnJlbnQuc3RhY2ssIFwiXFxuXFxuXCIpO1xuICAgIH1cblxuICAgIHRocm93IGVycjtcbiAgfVxuXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGxhdGVzdFNlbGVjdG9yLmN1cnJlbnQgPSBzZWxlY3RvcjtcbiAgICBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQgPSBzZWxlY3RlZFN0YXRlO1xuICAgIGxhdGVzdFN1YnNjcmlwdGlvbkNhbGxiYWNrRXJyb3IuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgfSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGZ1bmN0aW9uIGNoZWNrRm9yVXBkYXRlcygpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3RlZFN0YXRlID0gbGF0ZXN0U2VsZWN0b3IuY3VycmVudChnZXRTbGF0ZSgpKTtcblxuICAgICAgICBpZiAoZXF1YWxpdHlGbihuZXdTZWxlY3RlZFN0YXRlLCBsYXRlc3RTZWxlY3RlZFN0YXRlLmN1cnJlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGF0ZXN0U2VsZWN0ZWRTdGF0ZS5jdXJyZW50ID0gbmV3U2VsZWN0ZWRTdGF0ZTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyB3ZSBpZ25vcmUgYWxsIGVycm9ycyBoZXJlLCBzaW5jZSB3aGVuIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gaXMgcmUtcmVuZGVyZWQsIHRoZSBzZWxlY3RvcnMgYXJlIGNhbGxlZCBhZ2FpbiwgYW5kXG4gICAgICAgIC8vIHdpbGwgdGhyb3cgYWdhaW4sIGlmIG5laXRoZXIgcHJvcHMgbm9yIHN0b3JlIHN0YXRlXG4gICAgICAgIC8vIGNoYW5nZWRcbiAgICAgICAgbGF0ZXN0U3Vic2NyaXB0aW9uQ2FsbGJhY2tFcnJvci5jdXJyZW50ID0gZXJyO1xuICAgICAgfVxuXG4gICAgICBmb3JjZVJlbmRlcigpO1xuICAgIH1cblxuICAgIHZhciB1bnN1YnNjcmliZSA9IGFkZEV2ZW50TGlzdGVuZXIoY2hlY2tGb3JVcGRhdGVzKTtcbiAgICBjaGVja0ZvclVwZGF0ZXMoKTtcbiAgICByZXR1cm4gKCkgPT4gdW5zdWJzY3JpYmUoKTtcbiAgfSwgLy8gZG9uJ3QgcmVyZW5kZXIgb24gZXF1YWxpdHlGbiBjaGFuZ2Ugc2luY2Ugd2Ugd2FudCB0byBiZSBhYmxlIHRvIGRlZmluZSBpdCBpbmxpbmVcbiAgW2FkZEV2ZW50TGlzdGVuZXIsIGdldFNsYXRlXSk7XG4gIHJldHVybiBzZWxlY3RlZFN0YXRlO1xufVxuLyoqXHJcbiAqIENyZWF0ZSBzZWxlY3RvciBjb250ZXh0IHdpdGggZWRpdG9yIHVwZGF0aW5nIG9uIGV2ZXJ5IGVkaXRvciBjaGFuZ2VcclxuICovXG5cbmZ1bmN0aW9uIGdldFNlbGVjdG9yQ29udGV4dChlZGl0b3IpIHtcbiAgdmFyIGV2ZW50TGlzdGVuZXJzID0gdXNlUmVmKFtdKS5jdXJyZW50O1xuICB2YXIgc2xhdGVSZWYgPSB1c2VSZWYoe1xuICAgIGVkaXRvclxuICB9KS5jdXJyZW50O1xuICB2YXIgb25DaGFuZ2UgPSB1c2VDYWxsYmFjayhlZGl0b3IgPT4ge1xuICAgIHNsYXRlUmVmLmVkaXRvciA9IGVkaXRvcjtcbiAgICBldmVudExpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKGVkaXRvcikpO1xuICB9LCBbXSk7XG4gIHZhciBzZWxlY3RvckNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0U2xhdGU6ICgpID0+IHNsYXRlUmVmLmVkaXRvcixcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGNhbGxiYWNrID0+IHtcbiAgICAgICAgZXZlbnRMaXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgZXZlbnRMaXN0ZW5lcnMuc3BsaWNlKGV2ZW50TGlzdGVuZXJzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbZXZlbnRMaXN0ZW5lcnMsIHNsYXRlUmVmXSk7XG4gIHJldHVybiB7XG4gICAgc2VsZWN0b3JDb250ZXh0LFxuICAgIG9uQ2hhbmdlXG4gIH07XG59XG5cbnZhciBfZXhjbHVkZWQgPSBbXCJlZGl0b3JcIiwgXCJjaGlsZHJlblwiLCBcIm9uQ2hhbmdlXCIsIFwidmFsdWVcIl07XG4vKipcclxuICogQSB3cmFwcGVyIGFyb3VuZCB0aGUgcHJvdmlkZXIgdG8gaGFuZGxlIGBvbkNoYW5nZWAgZXZlbnRzLCBiZWNhdXNlIHRoZSBlZGl0b3JcclxuICogaXMgYSBtdXRhYmxlIHNpbmdsZXRvbiBzbyBpdCB3b24ndCBldmVyIHJlZ2lzdGVyIGFzIFwiY2hhbmdlZFwiIG90aGVyd2lzZS5cclxuICovXG5cbnZhciBTbGF0ZSA9IHByb3BzID0+IHtcbiAgdmFyIHtcbiAgICBlZGl0b3IsXG4gICAgY2hpbGRyZW4sXG4gICAgb25DaGFuZ2UsXG4gICAgdmFsdWVcbiAgfSA9IHByb3BzLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgX2V4Y2x1ZGVkKTtcblxuICB2YXIgdW5tb3VudFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gIHZhciBbY29udGV4dCwgc2V0Q29udGV4dF0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB7XG4gICAgaWYgKCFOb2RlLmlzTm9kZUxpc3QodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJbU2xhdGVdIHZhbHVlIGlzIGludmFsaWQhIEV4cGVjdGVkIGEgbGlzdCBvZiBlbGVtZW50cyBidXQgZ290OiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHZhbHVlKSkpO1xuICAgIH1cblxuICAgIGlmICghRWRpdG9yLmlzRWRpdG9yKGVkaXRvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIltTbGF0ZV0gZWRpdG9yIGlzIGludmFsaWQhIFlvdSBwYXNzZWQ6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkoZWRpdG9yKSkpO1xuICAgIH1cblxuICAgIGVkaXRvci5jaGlsZHJlbiA9IHZhbHVlO1xuICAgIE9iamVjdC5hc3NpZ24oZWRpdG9yLCByZXN0KTtcbiAgICByZXR1cm4ge1xuICAgICAgdjogMCxcbiAgICAgIGVkaXRvclxuICAgIH07XG4gIH0pO1xuICB2YXIge1xuICAgIHNlbGVjdG9yQ29udGV4dCxcbiAgICBvbkNoYW5nZTogaGFuZGxlU2VsZWN0b3JDaGFuZ2VcbiAgfSA9IGdldFNlbGVjdG9yQ29udGV4dChlZGl0b3IpO1xuICB2YXIgb25Db250ZXh0Q2hhbmdlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGlmIChvbkNoYW5nZSkge1xuICAgICAgb25DaGFuZ2UoZWRpdG9yLmNoaWxkcmVuKTtcbiAgICB9XG5cbiAgICBzZXRDb250ZXh0KHByZXZDb250ZXh0ID0+ICh7XG4gICAgICB2OiBwcmV2Q29udGV4dC52ICsgMSxcbiAgICAgIGVkaXRvclxuICAgIH0pKTtcbiAgICBoYW5kbGVTZWxlY3RvckNoYW5nZShlZGl0b3IpO1xuICB9LCBbb25DaGFuZ2VdKTtcbiAgRURJVE9SX1RPX09OX0NIQU5HRS5zZXQoZWRpdG9yLCBvbkNvbnRleHRDaGFuZ2UpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBFRElUT1JfVE9fT05fQ0hBTkdFLnNldChlZGl0b3IsICgpID0+IHt9KTtcbiAgICAgIHVubW91bnRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgfTtcbiAgfSwgW10pO1xuICB2YXIgW2lzRm9jdXNlZCwgc2V0SXNGb2N1c2VkXSA9IHVzZVN0YXRlKFJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRJc0ZvY3VzZWQoUmVhY3RFZGl0b3IuaXNGb2N1c2VkKGVkaXRvcikpO1xuICB9KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdmFyIGZuID0gKCkgPT4gc2V0SXNGb2N1c2VkKFJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpKTtcblxuICAgIGlmIChJU19SRUFDVF9WRVJTSU9OXzE3X09SX0FCT1ZFKSB7XG4gICAgICAvLyBJbiBSZWFjdCA+PSAxNyBvbkZvY3VzIGFuZCBvbkJsdXIgbGlzdGVuIHRvIHRoZSBmb2N1c2luIGFuZCBmb2N1c291dCBldmVudHMgZHVyaW5nIHRoZSBidWJibGluZyBwaGFzZS5cbiAgICAgIC8vIFRoZXJlZm9yZSBpbiBvcmRlciBmb3IgPEVkaXRhYmxlIC8+J3MgaGFuZGxlcnMgdG8gcnVuIGZpcnN0LCB3aGljaCBpcyBuZWNlc3NhcnkgZm9yIFJlYWN0RWRpdG9yLmlzRm9jdXNlZChlZGl0b3IpXG4gICAgICAvLyB0byByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWUsIHdlIGhhdmUgdG8gbGlzdGVuIHRvIHRoZSBmb2N1c2luIGFuZCBmb2N1c291dCBldmVudHMgd2l0aG91dCB1c2VDYXB0dXJlIGhlcmUuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgZm4pO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBmbik7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgZm4pO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIGZuKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZm4sIHRydWUpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGZuLCB0cnVlKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgZm4sIHRydWUpO1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgZm4sIHRydWUpO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFNsYXRlU2VsZWN0b3JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHNlbGVjdG9yQ29udGV4dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChTbGF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogY29udGV4dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChFZGl0b3JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGNvbnRleHQuZWRpdG9yXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvY3VzZWRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGlzRm9jdXNlZFxuICB9LCBjaGlsZHJlbikpKSk7XG59O1xuXG4vKipcclxuICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBvYmplY3QgZnJvbSB0aGUgUmVhY3QgY29udGV4dC5cclxuICogQGRlcHJlY2F0ZWQgVXNlIHVzZVNsYXRlU3RhdGljIGluc3RlYWQuXHJcbiAqL1xuXG52YXIgdXNlRWRpdG9yID0gKCkgPT4ge1xuICB2YXIgZWRpdG9yID0gdXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcblxuICBpZiAoIWVkaXRvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBgdXNlRWRpdG9yYCBob29rIG11c3QgYmUgdXNlZCBpbnNpZGUgdGhlIDxTbGF0ZT4gY29tcG9uZW50J3MgY29udGV4dC5cIik7XG4gIH1cblxuICByZXR1cm4gZWRpdG9yO1xufTtcblxuLyoqXHJcbiAqIEdldCB0aGUgY3VycmVudCBzbGF0ZSBzZWxlY3Rpb24uXHJcbiAqIE9ubHkgdHJpZ2dlcnMgYSByZXJlbmRlciB3aGVuIHRoZSBzZWxlY3Rpb24gYWN0dWFsbHkgY2hhbmdlc1xyXG4gKi9cblxudmFyIHVzZVNsYXRlU2VsZWN0aW9uID0gKCkgPT4ge1xuICByZXR1cm4gdXNlU2xhdGVTZWxlY3RvcihlZGl0b3IgPT4gZWRpdG9yLnNlbGVjdGlvbiwgaXNTZWxlY3Rpb25FcXVhbCk7XG59O1xuXG52YXIgaXNTZWxlY3Rpb25FcXVhbCA9IChhLCBiKSA9PiB7XG4gIGlmICghYSAmJiAhYikgcmV0dXJuIHRydWU7XG4gIGlmICghYSB8fCAhYikgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gUmFuZ2UuZXF1YWxzKGEsIGIpO1xufTtcblxuLyoqXHJcbiAqIFV0aWxpdGllcyBmb3Igc2luZ2xlLWxpbmUgZGVsZXRpb25cclxuICovXG5cbnZhciBkb1JlY3RzSW50ZXJzZWN0ID0gKHJlY3QsIGNvbXBhcmVSZWN0KSA9PiB7XG4gIHZhciBtaWRkbGUgPSAoY29tcGFyZVJlY3QudG9wICsgY29tcGFyZVJlY3QuYm90dG9tKSAvIDI7XG4gIHJldHVybiByZWN0LnRvcCA8PSBtaWRkbGUgJiYgcmVjdC5ib3R0b20gPj0gbWlkZGxlO1xufTtcblxudmFyIGFyZVJhbmdlc1NhbWVMaW5lID0gKGVkaXRvciwgcmFuZ2UxLCByYW5nZTIpID0+IHtcbiAgdmFyIHJlY3QxID0gUmVhY3RFZGl0b3IudG9ET01SYW5nZShlZGl0b3IsIHJhbmdlMSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciByZWN0MiA9IFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCByYW5nZTIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gZG9SZWN0c0ludGVyc2VjdChyZWN0MSwgcmVjdDIpICYmIGRvUmVjdHNJbnRlcnNlY3QocmVjdDIsIHJlY3QxKTtcbn07XG4vKipcclxuICogQSBoZWxwZXIgdXRpbGl0eSB0aGF0IHJldHVybnMgdGhlIGVuZCBwb3J0aW9uIG9mIGEgYFJhbmdlYFxyXG4gKiB3aGljaCBpcyBsb2NhdGVkIG9uIGEgc2luZ2xlIGxpbmUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7RWRpdG9yfSBlZGl0b3IgVGhlIGVkaXRvciBvYmplY3QgdG8gY29tcGFyZSBhZ2FpbnN0XHJcbiAqIEBwYXJhbSB7UmFuZ2V9IHBhcmVudFJhbmdlIFRoZSBwYXJlbnQgcmFuZ2UgdG8gY29tcGFyZSBhZ2FpbnN0XHJcbiAqIEByZXR1cm5zIHtSYW5nZX0gQSB2YWxpZCBwb3J0aW9uIG9mIHRoZSBwYXJlbnRSYW5nZSB3aGljaCBpcyBvbmUgYSBzaW5nbGUgbGluZVxyXG4gKi9cblxuXG52YXIgZmluZEN1cnJlbnRMaW5lUmFuZ2UgPSAoZWRpdG9yLCBwYXJlbnRSYW5nZSkgPT4ge1xuICB2YXIgcGFyZW50UmFuZ2VCb3VuZGFyeSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIFJhbmdlLmVuZChwYXJlbnRSYW5nZSkpO1xuICB2YXIgcG9zaXRpb25zID0gQXJyYXkuZnJvbShFZGl0b3IucG9zaXRpb25zKGVkaXRvciwge1xuICAgIGF0OiBwYXJlbnRSYW5nZVxuICB9KSk7XG4gIHZhciBsZWZ0ID0gMDtcbiAgdmFyIHJpZ2h0ID0gcG9zaXRpb25zLmxlbmd0aDtcbiAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IocmlnaHQgLyAyKTtcblxuICBpZiAoYXJlUmFuZ2VzU2FtZUxpbmUoZWRpdG9yLCBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbbGVmdF0pLCBwYXJlbnRSYW5nZUJvdW5kYXJ5KSkge1xuICAgIHJldHVybiBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbbGVmdF0sIHBhcmVudFJhbmdlQm91bmRhcnkpO1xuICB9XG5cbiAgaWYgKHBvc2l0aW9ucy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIEVkaXRvci5yYW5nZShlZGl0b3IsIHBvc2l0aW9uc1twb3NpdGlvbnMubGVuZ3RoIC0gMV0sIHBhcmVudFJhbmdlQm91bmRhcnkpO1xuICB9XG5cbiAgd2hpbGUgKG1pZGRsZSAhPT0gcG9zaXRpb25zLmxlbmd0aCAmJiBtaWRkbGUgIT09IGxlZnQpIHtcbiAgICBpZiAoYXJlUmFuZ2VzU2FtZUxpbmUoZWRpdG9yLCBFZGl0b3IucmFuZ2UoZWRpdG9yLCBwb3NpdGlvbnNbbWlkZGxlXSksIHBhcmVudFJhbmdlQm91bmRhcnkpKSB7XG4gICAgICByaWdodCA9IG1pZGRsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IG1pZGRsZTtcbiAgICB9XG5cbiAgICBtaWRkbGUgPSBNYXRoLmZsb29yKChsZWZ0ICsgcmlnaHQpIC8gMik7XG4gIH1cblxuICByZXR1cm4gRWRpdG9yLnJhbmdlKGVkaXRvciwgcG9zaXRpb25zW3JpZ2h0XSwgcGFyZW50UmFuZ2VCb3VuZGFyeSk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG4vKipcclxuICogYHdpdGhSZWFjdGAgYWRkcyBSZWFjdCBhbmQgRE9NIHNwZWNpZmljIGJlaGF2aW9ycyB0byB0aGUgZWRpdG9yLlxyXG4gKlxyXG4gKiBJZiB5b3UgYXJlIHVzaW5nIFR5cGVTY3JpcHQsIHlvdSBtdXN0IGV4dGVuZCBTbGF0ZSdzIEN1c3RvbVR5cGVzIHRvIHVzZVxyXG4gKiB0aGlzIHBsdWdpbi5cclxuICpcclxuICogU2VlIGh0dHBzOi8vZG9jcy5zbGF0ZWpzLm9yZy9jb25jZXB0cy8xMS10eXBlc2NyaXB0IHRvIGxlYXJuIGhvdy5cclxuICovXG5cbnZhciB3aXRoUmVhY3QgPSBlZGl0b3IgPT4ge1xuICB2YXIgZSA9IGVkaXRvcjtcbiAgdmFyIHtcbiAgICBhcHBseSxcbiAgICBvbkNoYW5nZSxcbiAgICBkZWxldGVCYWNrd2FyZCxcbiAgICBhZGRNYXJrLFxuICAgIHJlbW92ZU1hcmtcbiAgfSA9IGU7IC8vIFRoZSBXZWFrTWFwIHdoaWNoIG1hcHMgYSBrZXkgdG8gYSBzcGVjaWZpYyBIVE1MRWxlbWVudCBtdXN0IGJlIHNjb3BlZCB0byB0aGUgZWRpdG9yIGluc3RhbmNlIHRvXG4gIC8vIGF2b2lkIGNvbGxpc2lvbnMgYmV0d2VlbiBlZGl0b3JzIGluIHRoZSBET00gdGhhdCBzaGFyZSB0aGUgc2FtZSB2YWx1ZS5cblxuICBFRElUT1JfVE9fS0VZX1RPX0VMRU1FTlQuc2V0KGUsIG5ldyBXZWFrTWFwKCkpO1xuXG4gIGUuYWRkTWFyayA9IChrZXksIHZhbHVlKSA9PiB7XG4gICAgdmFyIF9FRElUT1JfVE9fU0NIRURVTEVfRiwgX0VESVRPUl9UT19QRU5ESU5HX0RJO1xuXG4gICAgKF9FRElUT1JfVE9fU0NIRURVTEVfRiA9IEVESVRPUl9UT19TQ0hFRFVMRV9GTFVTSC5nZXQoZSkpID09PSBudWxsIHx8IF9FRElUT1JfVE9fU0NIRURVTEVfRiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX0VESVRPUl9UT19TQ0hFRFVMRV9GKCk7XG5cbiAgICBpZiAoIUVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZSkgJiYgKF9FRElUT1JfVE9fUEVORElOR19ESSA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlKSkgIT09IG51bGwgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJICE9PSB2b2lkIDAgJiYgX0VESVRPUl9UT19QRU5ESU5HX0RJLmxlbmd0aCkge1xuICAgICAgLy8gRW5zdXJlIHRoZSBjdXJyZW50IHBlbmRpbmcgZGlmZnMgb3JpZ2luYXRpbmcgZnJvbSBjaGFuZ2VzIGJlZm9yZSB0aGUgYWRkTWFya1xuICAgICAgLy8gYXJlIGFwcGxpZWQgd2l0aCB0aGUgY3VycmVudCBmb3JtYXR0aW5nXG4gICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1Muc2V0KGUsIG51bGwpO1xuICAgIH1cblxuICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlKTtcbiAgICBhZGRNYXJrKGtleSwgdmFsdWUpO1xuICB9O1xuXG4gIGUucmVtb3ZlTWFyayA9IGtleSA9PiB7XG4gICAgdmFyIF9FRElUT1JfVE9fUEVORElOR19ESTI7XG5cbiAgICBpZiAoIUVESVRPUl9UT19QRU5ESU5HX0lOU0VSVElPTl9NQVJLUy5nZXQoZSkgJiYgKF9FRElUT1JfVE9fUEVORElOR19ESTIgPSBFRElUT1JfVE9fUEVORElOR19ESUZGUy5nZXQoZSkpICE9PSBudWxsICYmIF9FRElUT1JfVE9fUEVORElOR19ESTIgIT09IHZvaWQgMCAmJiBfRURJVE9SX1RPX1BFTkRJTkdfREkyLmxlbmd0aCkge1xuICAgICAgLy8gRW5zdXJlIHRoZSBjdXJyZW50IHBlbmRpbmcgZGlmZnMgb3JpZ2luYXRpbmcgZnJvbSBjaGFuZ2VzIGJlZm9yZSB0aGUgYWRkTWFya1xuICAgICAgLy8gYXJlIGFwcGxpZWQgd2l0aCB0aGUgY3VycmVudCBmb3JtYXR0aW5nXG4gICAgICBFRElUT1JfVE9fUEVORElOR19JTlNFUlRJT05fTUFSS1Muc2V0KGUsIG51bGwpO1xuICAgIH1cblxuICAgIEVESVRPUl9UT19VU0VSX01BUktTLmRlbGV0ZShlKTtcbiAgICByZW1vdmVNYXJrKGtleSk7XG4gIH07XG5cbiAgZS5kZWxldGVCYWNrd2FyZCA9IHVuaXQgPT4ge1xuICAgIGlmICh1bml0ICE9PSAnbGluZScpIHtcbiAgICAgIHJldHVybiBkZWxldGVCYWNrd2FyZCh1bml0KTtcbiAgICB9XG5cbiAgICBpZiAoZS5zZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoZS5zZWxlY3Rpb24pKSB7XG4gICAgICB2YXIgcGFyZW50QmxvY2tFbnRyeSA9IEVkaXRvci5hYm92ZShlLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGUsIG4pLFxuICAgICAgICBhdDogZS5zZWxlY3Rpb25cbiAgICAgIH0pO1xuXG4gICAgICBpZiAocGFyZW50QmxvY2tFbnRyeSkge1xuICAgICAgICB2YXIgWywgcGFyZW50QmxvY2tQYXRoXSA9IHBhcmVudEJsb2NrRW50cnk7XG4gICAgICAgIHZhciBwYXJlbnRFbGVtZW50UmFuZ2UgPSBFZGl0b3IucmFuZ2UoZSwgcGFyZW50QmxvY2tQYXRoLCBlLnNlbGVjdGlvbi5hbmNob3IpO1xuICAgICAgICB2YXIgY3VycmVudExpbmVSYW5nZSA9IGZpbmRDdXJyZW50TGluZVJhbmdlKGUsIHBhcmVudEVsZW1lbnRSYW5nZSk7XG5cbiAgICAgICAgaWYgKCFSYW5nZS5pc0NvbGxhcHNlZChjdXJyZW50TGluZVJhbmdlKSkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGUsIHtcbiAgICAgICAgICAgIGF0OiBjdXJyZW50TGluZVJhbmdlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIFRoaXMgYXR0ZW1wdHMgdG8gcmVzZXQgdGhlIE5PREVfVE9fS0VZIGVudHJ5IHRvIHRoZSBjb3JyZWN0IHZhbHVlXG4gIC8vIGFzIGFwcGx5KCkgY2hhbmdlcyB0aGUgb2JqZWN0IHJlZmVyZW5jZSBhbmQgaGVuY2UgaW52YWxpZGF0ZXMgdGhlIE5PREVfVE9fS0VZIGVudHJ5XG5cblxuICBlLmFwcGx5ID0gb3AgPT4ge1xuICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgdmFyIHBlbmRpbmdEaWZmcyA9IEVESVRPUl9UT19QRU5ESU5HX0RJRkZTLmdldChlKTtcblxuICAgIGlmIChwZW5kaW5nRGlmZnMgIT09IG51bGwgJiYgcGVuZGluZ0RpZmZzICE9PSB2b2lkIDAgJiYgcGVuZGluZ0RpZmZzLmxlbmd0aCkge1xuICAgICAgdmFyIHRyYW5zZm9ybWVkID0gcGVuZGluZ0RpZmZzLm1hcCh0ZXh0RGlmZiA9PiB0cmFuc2Zvcm1UZXh0RGlmZih0ZXh0RGlmZiwgb3ApKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgICBFRElUT1JfVE9fUEVORElOR19ESUZGUy5zZXQoZSwgdHJhbnNmb3JtZWQpO1xuICAgIH1cblxuICAgIHZhciBwZW5kaW5nU2VsZWN0aW9uID0gRURJVE9SX1RPX1BFTkRJTkdfU0VMRUNUSU9OLmdldChlKTtcblxuICAgIGlmIChwZW5kaW5nU2VsZWN0aW9uKSB7XG4gICAgICBFRElUT1JfVE9fUEVORElOR19TRUxFQ1RJT04uc2V0KGUsIHRyYW5zZm9ybVBlbmRpbmdSYW5nZShlLCBwZW5kaW5nU2VsZWN0aW9uLCBvcCkpO1xuICAgIH1cblxuICAgIHZhciBwZW5kaW5nQWN0aW9uID0gRURJVE9SX1RPX1BFTkRJTkdfQUNUSU9OLmdldChlKTtcblxuICAgIGlmIChwZW5kaW5nQWN0aW9uICE9PSBudWxsICYmIHBlbmRpbmdBY3Rpb24gIT09IHZvaWQgMCAmJiBwZW5kaW5nQWN0aW9uLmF0KSB7XG4gICAgICB2YXIgYXQgPSBQb2ludC5pc1BvaW50KHBlbmRpbmdBY3Rpb24gPT09IG51bGwgfHwgcGVuZGluZ0FjdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVuZGluZ0FjdGlvbi5hdCkgPyB0cmFuc2Zvcm1QZW5kaW5nUG9pbnQoZSwgcGVuZGluZ0FjdGlvbi5hdCwgb3ApIDogdHJhbnNmb3JtUGVuZGluZ1JhbmdlKGUsIHBlbmRpbmdBY3Rpb24uYXQsIG9wKTtcbiAgICAgIEVESVRPUl9UT19QRU5ESU5HX0FDVElPTi5zZXQoZSwgYXQgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBlbmRpbmdBY3Rpb24pLCB7fSwge1xuICAgICAgICBhdFxuICAgICAgfSkgOiBudWxsKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKC4uLmdldE1hdGNoZXMoZSwgb3AucGF0aCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9FRElUT1JfVE9fVVNFUl9TRUxFQztcblxuICAgICAgICAgIC8vIFNlbGVjdGlvbiB3YXMgbWFudWFsbHkgc2V0LCBkb24ndCByZXN0b3JlIHRoZSB1c2VyIHNlbGVjdGlvbiBhZnRlciB0aGUgY2hhbmdlLlxuICAgICAgICAgIChfRURJVE9SX1RPX1VTRVJfU0VMRUMgPSBFRElUT1JfVE9fVVNFUl9TRUxFQ1RJT04uZ2V0KGUpKSA9PT0gbnVsbCB8fCBfRURJVE9SX1RPX1VTRVJfU0VMRUMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9FRElUT1JfVE9fVVNFUl9TRUxFQy51bnJlZigpO1xuICAgICAgICAgIEVESVRPUl9UT19VU0VSX1NFTEVDVElPTi5kZWxldGUoZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKC4uLmdldE1hdGNoZXMoZSwgUGF0aC5wYXJlbnQob3AucGF0aCkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBwcmV2UGF0aCA9IFBhdGgucHJldmlvdXMob3AucGF0aCk7XG4gICAgICAgICAgbWF0Y2hlcy5wdXNoKC4uLmdldE1hdGNoZXMoZSwgcHJldlBhdGgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbW1vblBhdGggPSBQYXRoLmNvbW1vbihQYXRoLnBhcmVudChvcC5wYXRoKSwgUGF0aC5wYXJlbnQob3AubmV3UGF0aCkpO1xuICAgICAgICAgIG1hdGNoZXMucHVzaCguLi5nZXRNYXRjaGVzKGUsIGNvbW1vblBhdGgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGFwcGx5KG9wKTtcblxuICAgIGZvciAodmFyIFtwYXRoLCBrZXldIG9mIG1hdGNoZXMpIHtcbiAgICAgIHZhciBbbm9kZV0gPSBFZGl0b3Iubm9kZShlLCBwYXRoKTtcbiAgICAgIE5PREVfVE9fS0VZLnNldChub2RlLCBrZXkpO1xuICAgIH1cbiAgfTtcblxuICBlLnNldEZyYWdtZW50RGF0YSA9IGRhdGEgPT4ge1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZTtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHNlbGVjdGlvbik7XG4gICAgdmFyIHN0YXJ0Vm9pZCA9IEVkaXRvci52b2lkKGUsIHtcbiAgICAgIGF0OiBzdGFydC5wYXRoXG4gICAgfSk7XG4gICAgdmFyIGVuZFZvaWQgPSBFZGl0b3Iudm9pZChlLCB7XG4gICAgICBhdDogZW5kLnBhdGhcbiAgICB9KTtcblxuICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChzZWxlY3Rpb24pICYmICFzdGFydFZvaWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENyZWF0ZSBhIGZha2Ugc2VsZWN0aW9uIHNvIHRoYXQgd2UgY2FuIGFkZCBhIEJhc2U2NC1lbmNvZGVkIGNvcHkgb2YgdGhlXG4gICAgLy8gZnJhZ21lbnQgdG8gdGhlIEhUTUwsIHRvIGRlY29kZSBvbiBmdXR1cmUgcGFzdGVzLlxuXG5cbiAgICB2YXIgZG9tUmFuZ2UgPSBSZWFjdEVkaXRvci50b0RPTVJhbmdlKGUsIHNlbGVjdGlvbik7XG4gICAgdmFyIGNvbnRlbnRzID0gZG9tUmFuZ2UuY2xvbmVDb250ZW50cygpO1xuICAgIHZhciBhdHRhY2ggPSBjb250ZW50cy5jaGlsZE5vZGVzWzBdOyAvLyBNYWtlIHN1cmUgYXR0YWNoIGlzIG5vbi1lbXB0eSwgc2luY2UgZW1wdHkgbm9kZXMgd2lsbCBub3QgZ2V0IGNvcGllZC5cblxuICAgIGNvbnRlbnRzLmNoaWxkTm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGlmIChub2RlLnRleHRDb250ZW50ICYmIG5vZGUudGV4dENvbnRlbnQudHJpbSgpICE9PSAnJykge1xuICAgICAgICBhdHRhY2ggPSBub2RlO1xuICAgICAgfVxuICAgIH0pOyAvLyBDT01QQVQ6IElmIHRoZSBlbmQgbm9kZSBpcyBhIHZvaWQgbm9kZSwgd2UgbmVlZCB0byBtb3ZlIHRoZSBlbmQgb2YgdGhlXG4gICAgLy8gcmFuZ2UgZnJvbSB0aGUgdm9pZCBub2RlJ3Mgc3BhY2VyIHNwYW4sIHRvIHRoZSBlbmQgb2YgdGhlIHZvaWQgbm9kZSdzXG4gICAgLy8gY29udGVudCwgc2luY2UgdGhlIHNwYWNlciBpcyBiZWZvcmUgdm9pZCdzIGNvbnRlbnQgaW4gdGhlIERPTS5cblxuICAgIGlmIChlbmRWb2lkKSB7XG4gICAgICB2YXIgW3ZvaWROb2RlXSA9IGVuZFZvaWQ7XG4gICAgICB2YXIgciA9IGRvbVJhbmdlLmNsb25lUmFuZ2UoKTtcbiAgICAgIHZhciBkb21Ob2RlID0gUmVhY3RFZGl0b3IudG9ET01Ob2RlKGUsIHZvaWROb2RlKTtcbiAgICAgIHIuc2V0RW5kQWZ0ZXIoZG9tTm9kZSk7XG4gICAgICBjb250ZW50cyA9IHIuY2xvbmVDb250ZW50cygpO1xuICAgIH0gLy8gQ09NUEFUOiBJZiB0aGUgc3RhcnQgbm9kZSBpcyBhIHZvaWQgbm9kZSwgd2UgbmVlZCB0byBhdHRhY2ggdGhlIGVuY29kZWRcbiAgICAvLyBmcmFnbWVudCB0byB0aGUgdm9pZCBub2RlJ3MgY29udGVudCBub2RlIGluc3RlYWQgb2YgdGhlIHNwYWNlciwgYmVjYXVzZVxuICAgIC8vIGF0dGFjaGluZyBpdCB0byBlbXB0eSBgPGRpdj4vPHNwYW4+YCBub2RlcyB3aWxsIGVuZCB1cCBoYXZpbmcgaXQgZXJhc2VkIGJ5XG4gICAgLy8gbW9zdCBicm93c2Vycy4gKDIwMTgvMDQvMjcpXG5cblxuICAgIGlmIChzdGFydFZvaWQpIHtcbiAgICAgIGF0dGFjaCA9IGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLXNsYXRlLXNwYWNlcl0nKTtcbiAgICB9IC8vIFJlbW92ZSBhbnkgemVyby13aWR0aCBzcGFjZSBzcGFucyBmcm9tIHRoZSBjbG9uZWQgRE9NIHNvIHRoYXQgdGhleSBkb24ndFxuICAgIC8vIHNob3cgdXAgZWxzZXdoZXJlIHdoZW4gcGFzdGVkLlxuXG5cbiAgICBBcnJheS5mcm9tKGNvbnRlbnRzLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXNsYXRlLXplcm8td2lkdGhdJykpLmZvckVhY2goencgPT4ge1xuICAgICAgdmFyIGlzTmV3bGluZSA9IHp3LmdldEF0dHJpYnV0ZSgnZGF0YS1zbGF0ZS16ZXJvLXdpZHRoJykgPT09ICduJztcbiAgICAgIHp3LnRleHRDb250ZW50ID0gaXNOZXdsaW5lID8gJ1xcbicgOiAnJztcbiAgICB9KTsgLy8gU2V0IGEgYGRhdGEtc2xhdGUtZnJhZ21lbnRgIGF0dHJpYnV0ZSBvbiBhIG5vbi1lbXB0eSBub2RlLCBzbyBpdCBzaG93cyB1cFxuICAgIC8vIGluIHRoZSBIVE1MLCBhbmQgY2FuIGJlIHVzZWQgZm9yIGludHJhLVNsYXRlIHBhc3RpbmcuIElmIGl0J3MgYSB0ZXh0XG4gICAgLy8gbm9kZSwgd3JhcCBpdCBpbiBhIGA8c3Bhbj5gIHNvIHdlIGhhdmUgc29tZXRoaW5nIHRvIHNldCBhbiBhdHRyaWJ1dGUgb24uXG5cbiAgICBpZiAoaXNET01UZXh0KGF0dGFjaCkpIHtcbiAgICAgIHZhciBzcGFuID0gYXR0YWNoLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpOyAvLyBDT01QQVQ6IEluIENocm9tZSBhbmQgU2FmYXJpLCBpZiB3ZSBkb24ndCBhZGQgdGhlIGB3aGl0ZS1zcGFjZWAgc3R5bGVcbiAgICAgIC8vIHRoZW4gbGVhZGluZyBhbmQgdHJhaWxpbmcgc3BhY2VzIHdpbGwgYmUgaWdub3JlZC4gKDIwMTcvMDkvMjEpXG5cbiAgICAgIHNwYW4uc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUnO1xuICAgICAgc3Bhbi5hcHBlbmRDaGlsZChhdHRhY2gpO1xuICAgICAgY29udGVudHMuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgICBhdHRhY2ggPSBzcGFuO1xuICAgIH1cblxuICAgIHZhciBmcmFnbWVudCA9IGUuZ2V0RnJhZ21lbnQoKTtcbiAgICB2YXIgc3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZnJhZ21lbnQpO1xuICAgIHZhciBlbmNvZGVkID0gd2luZG93LmJ0b2EoZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZykpO1xuICAgIGF0dGFjaC5zZXRBdHRyaWJ1dGUoJ2RhdGEtc2xhdGUtZnJhZ21lbnQnLCBlbmNvZGVkKTtcbiAgICBkYXRhLnNldERhdGEoJ2FwcGxpY2F0aW9uL3gtc2xhdGUtZnJhZ21lbnQnLCBlbmNvZGVkKTsgLy8gQWRkIHRoZSBjb250ZW50IHRvIGEgPGRpdj4gc28gdGhhdCB3ZSBjYW4gZ2V0IGl0cyBpbm5lciBIVE1MLlxuXG4gICAgdmFyIGRpdiA9IGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGNvbnRlbnRzKTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAndHJ1ZScpO1xuICAgIGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgIGRhdGEuc2V0RGF0YSgndGV4dC9odG1sJywgZGl2LmlubmVySFRNTCk7XG4gICAgZGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJywgZ2V0UGxhaW5UZXh0KGRpdikpO1xuICAgIGNvbnRlbnRzLm93bmVyRG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICAgIHJldHVybiBkYXRhO1xuICB9O1xuXG4gIGUuaW5zZXJ0RGF0YSA9IGRhdGEgPT4ge1xuICAgIGlmICghZS5pbnNlcnRGcmFnbWVudERhdGEoZGF0YSkpIHtcbiAgICAgIGUuaW5zZXJ0VGV4dERhdGEoZGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIGUuaW5zZXJ0RnJhZ21lbnREYXRhID0gZGF0YSA9PiB7XG4gICAgLyoqXHJcbiAgICAgKiBDaGVja2luZyBjb3BpZWQgZnJhZ21lbnQgZnJvbSBhcHBsaWNhdGlvbi94LXNsYXRlLWZyYWdtZW50IG9yIGRhdGEtc2xhdGUtZnJhZ21lbnRcclxuICAgICAqL1xuICAgIHZhciBmcmFnbWVudCA9IGRhdGEuZ2V0RGF0YSgnYXBwbGljYXRpb24veC1zbGF0ZS1mcmFnbWVudCcpIHx8IGdldFNsYXRlRnJhZ21lbnRBdHRyaWJ1dGUoZGF0YSk7XG5cbiAgICBpZiAoZnJhZ21lbnQpIHtcbiAgICAgIHZhciBkZWNvZGVkID0gZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5hdG9iKGZyYWdtZW50KSk7XG4gICAgICB2YXIgcGFyc2VkID0gSlNPTi5wYXJzZShkZWNvZGVkKTtcbiAgICAgIGUuaW5zZXJ0RnJhZ21lbnQocGFyc2VkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBlLmluc2VydFRleHREYXRhID0gZGF0YSA9PiB7XG4gICAgdmFyIHRleHQgPSBkYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcblxuICAgIGlmICh0ZXh0KSB7XG4gICAgICB2YXIgbGluZXMgPSB0ZXh0LnNwbGl0KC9cXHJcXG58XFxyfFxcbi8pO1xuICAgICAgdmFyIHNwbGl0ID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgaWYgKHNwbGl0KSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGUsIHtcbiAgICAgICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZS5pbnNlcnRUZXh0KGxpbmUpO1xuICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICBlLm9uQ2hhbmdlID0gKCkgPT4ge1xuICAgIC8vIENPTVBBVDogUmVhY3QgZG9lc24ndCBiYXRjaCBgc2V0U3RhdGVgIGhvb2sgY2FsbHMsIHdoaWNoIG1lYW5zIHRoYXQgdGhlXG4gICAgLy8gY2hpbGRyZW4gYW5kIHNlbGVjdGlvbiBjYW4gZ2V0IG91dCBvZiBzeW5jIGZvciBvbmUgcmVuZGVyIHBhc3MuIFNvIHdlXG4gICAgLy8gaGF2ZSB0byB1c2UgdGhpcyB1bnN0YWJsZSBBUEkgdG8gZW5zdXJlIGl0IGJhdGNoZXMgdGhlbS4gKDIwMTkvMTIvMDMpXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDI1OSNpc3N1ZWNvbW1lbnQtNDM5NzAyMzY3XG4gICAgUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgdmFyIG9uQ29udGV4dENoYW5nZSA9IEVESVRPUl9UT19PTl9DSEFOR0UuZ2V0KGUpO1xuXG4gICAgICBpZiAob25Db250ZXh0Q2hhbmdlKSB7XG4gICAgICAgIG9uQ29udGV4dENoYW5nZSgpO1xuICAgICAgfVxuXG4gICAgICBvbkNoYW5nZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBlO1xufTtcblxudmFyIGdldE1hdGNoZXMgPSAoZSwgcGF0aCkgPT4ge1xuICB2YXIgbWF0Y2hlcyA9IFtdO1xuXG4gIGZvciAodmFyIFtuLCBwXSBvZiBFZGl0b3IubGV2ZWxzKGUsIHtcbiAgICBhdDogcGF0aFxuICB9KSkge1xuICAgIHZhciBrZXkgPSBSZWFjdEVkaXRvci5maW5kS2V5KGUsIG4pO1xuICAgIG1hdGNoZXMucHVzaChbcCwga2V5XSk7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hlcztcbn07XG5cbmV4cG9ydCB7IERlZmF1bHRFbGVtZW50LCBEZWZhdWx0TGVhZiwgRGVmYXVsdFBsYWNlaG9sZGVyLCBFZGl0YWJsZSwgUmVhY3RFZGl0b3IsIFNsYXRlLCB1c2VFZGl0b3IsIHVzZUZvY3VzZWQsIHVzZVJlYWRPbmx5LCB1c2VTZWxlY3RlZCwgdXNlU2xhdGUsIHVzZVNsYXRlU2VsZWN0aW9uLCB1c2VTbGF0ZVNlbGVjdG9yLCB1c2VTbGF0ZVN0YXRpYywgdXNlU2xhdGVXaXRoViwgd2l0aFJlYWN0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiIsImZ1bmN0aW9uIG4obil7Zm9yKHZhciByPWFyZ3VtZW50cy5sZW5ndGgsdD1BcnJheShyPjE/ci0xOjApLGU9MTtlPHI7ZSsrKXRbZS0xXT1hcmd1bWVudHNbZV07aWYoXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOVil7dmFyIGk9WVtuXSxvPWk/XCJmdW5jdGlvblwiPT10eXBlb2YgaT9pLmFwcGx5KG51bGwsdCk6aTpcInVua25vd24gZXJyb3IgbnI6IFwiK247dGhyb3cgRXJyb3IoXCJbSW1tZXJdIFwiK28pfXRocm93IEVycm9yKFwiW0ltbWVyXSBtaW5pZmllZCBlcnJvciBucjogXCIrbisodC5sZW5ndGg/XCIgXCIrdC5tYXAoKGZ1bmN0aW9uKG4pe3JldHVyblwiJ1wiK24rXCInXCJ9KSkuam9pbihcIixcIik6XCJcIikrXCIuIEZpbmQgdGhlIGZ1bGwgZXJyb3IgYXQ6IGh0dHBzOi8vYml0Lmx5LzNjWEVLV2ZcIil9ZnVuY3Rpb24gcihuKXtyZXR1cm4hIW4mJiEhbltRXX1mdW5jdGlvbiB0KG4pe3ZhciByO3JldHVybiEhbiYmKGZ1bmN0aW9uKG4pe2lmKCFufHxcIm9iamVjdFwiIT10eXBlb2YgbilyZXR1cm4hMTt2YXIgcj1PYmplY3QuZ2V0UHJvdG90eXBlT2Yobik7aWYobnVsbD09PXIpcmV0dXJuITA7dmFyIHQ9T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwocixcImNvbnN0cnVjdG9yXCIpJiZyLmNvbnN0cnVjdG9yO3JldHVybiB0PT09T2JqZWN0fHxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiZGdW5jdGlvbi50b1N0cmluZy5jYWxsKHQpPT09Wn0obil8fEFycmF5LmlzQXJyYXkobil8fCEhbltMXXx8ISEobnVsbD09PShyPW4uY29uc3RydWN0b3IpfHx2b2lkIDA9PT1yP3ZvaWQgMDpyW0xdKXx8cyhuKXx8dihuKSl9ZnVuY3Rpb24gZSh0KXtyZXR1cm4gcih0KXx8bigyMyx0KSx0W1FdLnR9ZnVuY3Rpb24gaShuLHIsdCl7dm9pZCAwPT09dCYmKHQ9ITEpLDA9PT1vKG4pPyh0P09iamVjdC5rZXlzOm5uKShuKS5mb3JFYWNoKChmdW5jdGlvbihlKXt0JiZcInN5bWJvbFwiPT10eXBlb2YgZXx8cihlLG5bZV0sbil9KSk6bi5mb3JFYWNoKChmdW5jdGlvbih0LGUpe3JldHVybiByKGUsdCxuKX0pKX1mdW5jdGlvbiBvKG4pe3ZhciByPW5bUV07cmV0dXJuIHI/ci5pPjM/ci5pLTQ6ci5pOkFycmF5LmlzQXJyYXkobik/MTpzKG4pPzI6dihuKT8zOjB9ZnVuY3Rpb24gdShuLHIpe3JldHVybiAyPT09byhuKT9uLmhhcyhyKTpPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobixyKX1mdW5jdGlvbiBhKG4scil7cmV0dXJuIDI9PT1vKG4pP24uZ2V0KHIpOm5bcl19ZnVuY3Rpb24gZihuLHIsdCl7dmFyIGU9byhuKTsyPT09ZT9uLnNldChyLHQpOjM9PT1lP24uYWRkKHQpOm5bcl09dH1mdW5jdGlvbiBjKG4scil7cmV0dXJuIG49PT1yPzAhPT1ufHwxL249PTEvcjpuIT1uJiZyIT1yfWZ1bmN0aW9uIHMobil7cmV0dXJuIFgmJm4gaW5zdGFuY2VvZiBNYXB9ZnVuY3Rpb24gdihuKXtyZXR1cm4gcSYmbiBpbnN0YW5jZW9mIFNldH1mdW5jdGlvbiBwKG4pe3JldHVybiBuLm98fG4udH1mdW5jdGlvbiBsKG4pe2lmKEFycmF5LmlzQXJyYXkobikpcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG4pO3ZhciByPXJuKG4pO2RlbGV0ZSByW1FdO2Zvcih2YXIgdD1ubihyKSxlPTA7ZTx0Lmxlbmd0aDtlKyspe3ZhciBpPXRbZV0sbz1yW2ldOyExPT09by53cml0YWJsZSYmKG8ud3JpdGFibGU9ITAsby5jb25maWd1cmFibGU9ITApLChvLmdldHx8by5zZXQpJiYocltpXT17Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLGVudW1lcmFibGU6by5lbnVtZXJhYmxlLHZhbHVlOm5baV19KX1yZXR1cm4gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yobikscil9ZnVuY3Rpb24gZChuLGUpe3JldHVybiB2b2lkIDA9PT1lJiYoZT0hMSkseShuKXx8cihuKXx8IXQobil8fChvKG4pPjEmJihuLnNldD1uLmFkZD1uLmNsZWFyPW4uZGVsZXRlPWgpLE9iamVjdC5mcmVlemUobiksZSYmaShuLChmdW5jdGlvbihuLHIpe3JldHVybiBkKHIsITApfSksITApKSxufWZ1bmN0aW9uIGgoKXtuKDIpfWZ1bmN0aW9uIHkobil7cmV0dXJuIG51bGw9PW58fFwib2JqZWN0XCIhPXR5cGVvZiBufHxPYmplY3QuaXNGcm96ZW4obil9ZnVuY3Rpb24gYihyKXt2YXIgdD10bltyXTtyZXR1cm4gdHx8bigxOCxyKSx0fWZ1bmN0aW9uIG0obixyKXt0bltuXXx8KHRuW25dPXIpfWZ1bmN0aW9uIF8oKXtyZXR1cm5cInByb2R1Y3Rpb25cIj09PXByb2Nlc3MuZW52Lk5PREVfRU5WfHxVfHxuKDApLFV9ZnVuY3Rpb24gaihuLHIpe3ImJihiKFwiUGF0Y2hlc1wiKSxuLnU9W10sbi5zPVtdLG4udj1yKX1mdW5jdGlvbiBPKG4pe2cobiksbi5wLmZvckVhY2goUyksbi5wPW51bGx9ZnVuY3Rpb24gZyhuKXtuPT09VSYmKFU9bi5sKX1mdW5jdGlvbiB3KG4pe3JldHVybiBVPXtwOltdLGw6VSxoOm4sbTohMCxfOjB9fWZ1bmN0aW9uIFMobil7dmFyIHI9bltRXTswPT09ci5pfHwxPT09ci5pP3IuaigpOnIuTz0hMH1mdW5jdGlvbiBQKHIsZSl7ZS5fPWUucC5sZW5ndGg7dmFyIGk9ZS5wWzBdLG89dm9pZCAwIT09ciYmciE9PWk7cmV0dXJuIGUuaC5nfHxiKFwiRVM1XCIpLlMoZSxyLG8pLG8/KGlbUV0uUCYmKE8oZSksbig0KSksdChyKSYmKHI9TShlLHIpLGUubHx8eChlLHIpKSxlLnUmJmIoXCJQYXRjaGVzXCIpLk0oaVtRXS50LHIsZS51LGUucykpOnI9TShlLGksW10pLE8oZSksZS51JiZlLnYoZS51LGUucyksciE9PUg/cjp2b2lkIDB9ZnVuY3Rpb24gTShuLHIsdCl7aWYoeShyKSlyZXR1cm4gcjt2YXIgZT1yW1FdO2lmKCFlKXJldHVybiBpKHIsKGZ1bmN0aW9uKGksbyl7cmV0dXJuIEEobixlLHIsaSxvLHQpfSksITApLHI7aWYoZS5BIT09bilyZXR1cm4gcjtpZighZS5QKXJldHVybiB4KG4sZS50LCEwKSxlLnQ7aWYoIWUuSSl7ZS5JPSEwLGUuQS5fLS07dmFyIG89ND09PWUuaXx8NT09PWUuaT9lLm89bChlLmspOmUubyx1PW8sYT0hMTszPT09ZS5pJiYodT1uZXcgU2V0KG8pLG8uY2xlYXIoKSxhPSEwKSxpKHUsKGZ1bmN0aW9uKHIsaSl7cmV0dXJuIEEobixlLG8scixpLHQsYSl9KSkseChuLG8sITEpLHQmJm4udSYmYihcIlBhdGNoZXNcIikuTihlLHQsbi51LG4ucyl9cmV0dXJuIGUub31mdW5jdGlvbiBBKGUsaSxvLGEsYyxzLHYpe2lmKFwicHJvZHVjdGlvblwiIT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJmM9PT1vJiZuKDUpLHIoYykpe3ZhciBwPU0oZSxjLHMmJmkmJjMhPT1pLmkmJiF1KGkuUixhKT9zLmNvbmNhdChhKTp2b2lkIDApO2lmKGYobyxhLHApLCFyKHApKXJldHVybjtlLm09ITF9ZWxzZSB2JiZvLmFkZChjKTtpZih0KGMpJiYheShjKSl7aWYoIWUuaC5EJiZlLl88MSlyZXR1cm47TShlLGMpLGkmJmkuQS5sfHx4KGUsYyl9fWZ1bmN0aW9uIHgobixyLHQpe3ZvaWQgMD09PXQmJih0PSExKSwhbi5sJiZuLmguRCYmbi5tJiZkKHIsdCl9ZnVuY3Rpb24geihuLHIpe3ZhciB0PW5bUV07cmV0dXJuKHQ/cCh0KTpuKVtyXX1mdW5jdGlvbiBJKG4scil7aWYociBpbiBuKWZvcih2YXIgdD1PYmplY3QuZ2V0UHJvdG90eXBlT2Yobik7dDspe3ZhciBlPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxyKTtpZihlKXJldHVybiBlO3Q9T2JqZWN0LmdldFByb3RvdHlwZU9mKHQpfX1mdW5jdGlvbiBrKG4pe24uUHx8KG4uUD0hMCxuLmwmJmsobi5sKSl9ZnVuY3Rpb24gRShuKXtuLm98fChuLm89bChuLnQpKX1mdW5jdGlvbiBOKG4scix0KXt2YXIgZT1zKHIpP2IoXCJNYXBTZXRcIikuRihyLHQpOnYocik/YihcIk1hcFNldFwiKS5UKHIsdCk6bi5nP2Z1bmN0aW9uKG4scil7dmFyIHQ9QXJyYXkuaXNBcnJheShuKSxlPXtpOnQ/MTowLEE6cj9yLkE6XygpLFA6ITEsSTohMSxSOnt9LGw6cix0Om4sazpudWxsLG86bnVsbCxqOm51bGwsQzohMX0saT1lLG89ZW47dCYmKGk9W2VdLG89b24pO3ZhciB1PVByb3h5LnJldm9jYWJsZShpLG8pLGE9dS5yZXZva2UsZj11LnByb3h5O3JldHVybiBlLms9ZixlLmo9YSxmfShyLHQpOmIoXCJFUzVcIikuSihyLHQpO3JldHVybih0P3QuQTpfKCkpLnAucHVzaChlKSxlfWZ1bmN0aW9uIFIoZSl7cmV0dXJuIHIoZSl8fG4oMjIsZSksZnVuY3Rpb24gbihyKXtpZighdChyKSlyZXR1cm4gcjt2YXIgZSx1PXJbUV0sYz1vKHIpO2lmKHUpe2lmKCF1LlAmJih1Lmk8NHx8IWIoXCJFUzVcIikuSyh1KSkpcmV0dXJuIHUudDt1Lkk9ITAsZT1EKHIsYyksdS5JPSExfWVsc2UgZT1EKHIsYyk7cmV0dXJuIGkoZSwoZnVuY3Rpb24ocix0KXt1JiZhKHUudCxyKT09PXR8fGYoZSxyLG4odCkpfSkpLDM9PT1jP25ldyBTZXQoZSk6ZX0oZSl9ZnVuY3Rpb24gRChuLHIpe3N3aXRjaChyKXtjYXNlIDI6cmV0dXJuIG5ldyBNYXAobik7Y2FzZSAzOnJldHVybiBBcnJheS5mcm9tKG4pfXJldHVybiBsKG4pfWZ1bmN0aW9uIEYoKXtmdW5jdGlvbiB0KG4scil7dmFyIHQ9c1tuXTtyZXR1cm4gdD90LmVudW1lcmFibGU9cjpzW25dPXQ9e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOnIsZ2V0OmZ1bmN0aW9uKCl7dmFyIHI9dGhpc1tRXTtyZXR1cm5cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZmKHIpLGVuLmdldChyLG4pfSxzZXQ6ZnVuY3Rpb24ocil7dmFyIHQ9dGhpc1tRXTtcInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZmKHQpLGVuLnNldCh0LG4scil9fSx0fWZ1bmN0aW9uIGUobil7Zm9yKHZhciByPW4ubGVuZ3RoLTE7cj49MDtyLS0pe3ZhciB0PW5bcl1bUV07aWYoIXQuUClzd2l0Y2godC5pKXtjYXNlIDU6YSh0KSYmayh0KTticmVhaztjYXNlIDQ6byh0KSYmayh0KX19fWZ1bmN0aW9uIG8obil7Zm9yKHZhciByPW4udCx0PW4uayxlPW5uKHQpLGk9ZS5sZW5ndGgtMTtpPj0wO2ktLSl7dmFyIG89ZVtpXTtpZihvIT09USl7dmFyIGE9cltvXTtpZih2b2lkIDA9PT1hJiYhdShyLG8pKXJldHVybiEwO3ZhciBmPXRbb10scz1mJiZmW1FdO2lmKHM/cy50IT09YTohYyhmLGEpKXJldHVybiEwfX12YXIgdj0hIXJbUV07cmV0dXJuIGUubGVuZ3RoIT09bm4ocikubGVuZ3RoKyh2PzA6MSl9ZnVuY3Rpb24gYShuKXt2YXIgcj1uLms7aWYoci5sZW5ndGghPT1uLnQubGVuZ3RoKXJldHVybiEwO3ZhciB0PU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocixyLmxlbmd0aC0xKTtpZih0JiYhdC5nZXQpcmV0dXJuITA7Zm9yKHZhciBlPTA7ZTxyLmxlbmd0aDtlKyspaWYoIXIuaGFzT3duUHJvcGVydHkoZSkpcmV0dXJuITA7cmV0dXJuITF9ZnVuY3Rpb24gZihyKXtyLk8mJm4oMyxKU09OLnN0cmluZ2lmeShwKHIpKSl9dmFyIHM9e307bShcIkVTNVwiLHtKOmZ1bmN0aW9uKG4scil7dmFyIGU9QXJyYXkuaXNBcnJheShuKSxpPWZ1bmN0aW9uKG4scil7aWYobil7Zm9yKHZhciBlPUFycmF5KHIubGVuZ3RoKSxpPTA7aTxyLmxlbmd0aDtpKyspT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJcIitpLHQoaSwhMCkpO3JldHVybiBlfXZhciBvPXJuKHIpO2RlbGV0ZSBvW1FdO2Zvcih2YXIgdT1ubihvKSxhPTA7YTx1Lmxlbmd0aDthKyspe3ZhciBmPXVbYV07b1tmXT10KGYsbnx8ISFvW2ZdLmVudW1lcmFibGUpfXJldHVybiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihyKSxvKX0oZSxuKSxvPXtpOmU/NTo0LEE6cj9yLkE6XygpLFA6ITEsSTohMSxSOnt9LGw6cix0Om4sazppLG86bnVsbCxPOiExLEM6ITF9O3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoaSxRLHt2YWx1ZTpvLHdyaXRhYmxlOiEwfSksaX0sUzpmdW5jdGlvbihuLHQsbyl7bz9yKHQpJiZ0W1FdLkE9PT1uJiZlKG4ucCk6KG4udSYmZnVuY3Rpb24gbihyKXtpZihyJiZcIm9iamVjdFwiPT10eXBlb2Ygcil7dmFyIHQ9cltRXTtpZih0KXt2YXIgZT10LnQsbz10LmssZj10LlIsYz10Lmk7aWYoND09PWMpaShvLChmdW5jdGlvbihyKXtyIT09USYmKHZvaWQgMCE9PWVbcl18fHUoZSxyKT9mW3JdfHxuKG9bcl0pOihmW3JdPSEwLGsodCkpKX0pKSxpKGUsKGZ1bmN0aW9uKG4pe3ZvaWQgMCE9PW9bbl18fHUobyxuKXx8KGZbbl09ITEsayh0KSl9KSk7ZWxzZSBpZig1PT09Yyl7aWYoYSh0KSYmKGsodCksZi5sZW5ndGg9ITApLG8ubGVuZ3RoPGUubGVuZ3RoKWZvcih2YXIgcz1vLmxlbmd0aDtzPGUubGVuZ3RoO3MrKylmW3NdPSExO2Vsc2UgZm9yKHZhciB2PWUubGVuZ3RoO3Y8by5sZW5ndGg7disrKWZbdl09ITA7Zm9yKHZhciBwPU1hdGgubWluKG8ubGVuZ3RoLGUubGVuZ3RoKSxsPTA7bDxwO2wrKylvLmhhc093blByb3BlcnR5KGwpfHwoZltsXT0hMCksdm9pZCAwPT09ZltsXSYmbihvW2xdKX19fX0obi5wWzBdKSxlKG4ucCkpfSxLOmZ1bmN0aW9uKG4pe3JldHVybiA0PT09bi5pP28obik6YShuKX19KX1mdW5jdGlvbiBUKCl7ZnVuY3Rpb24gZShuKXtpZighdChuKSlyZXR1cm4gbjtpZihBcnJheS5pc0FycmF5KG4pKXJldHVybiBuLm1hcChlKTtpZihzKG4pKXJldHVybiBuZXcgTWFwKEFycmF5LmZyb20obi5lbnRyaWVzKCkpLm1hcCgoZnVuY3Rpb24obil7cmV0dXJuW25bMF0sZShuWzFdKV19KSkpO2lmKHYobikpcmV0dXJuIG5ldyBTZXQoQXJyYXkuZnJvbShuKS5tYXAoZSkpO3ZhciByPU9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG4pKTtmb3IodmFyIGkgaW4gbilyW2ldPWUobltpXSk7cmV0dXJuIHUobixMKSYmKHJbTF09bltMXSkscn1mdW5jdGlvbiBmKG4pe3JldHVybiByKG4pP2Uobik6bn12YXIgYz1cImFkZFwiO20oXCJQYXRjaGVzXCIseyQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gdC5mb3JFYWNoKChmdW5jdGlvbih0KXtmb3IodmFyIGk9dC5wYXRoLHU9dC5vcCxmPXIscz0wO3M8aS5sZW5ndGgtMTtzKyspe3ZhciB2PW8oZikscD1cIlwiK2lbc107MCE9PXYmJjEhPT12fHxcIl9fcHJvdG9fX1wiIT09cCYmXCJjb25zdHJ1Y3RvclwiIT09cHx8bigyNCksXCJmdW5jdGlvblwiPT10eXBlb2YgZiYmXCJwcm90b3R5cGVcIj09PXAmJm4oMjQpLFwib2JqZWN0XCIhPXR5cGVvZihmPWEoZixwKSkmJm4oMTUsaS5qb2luKFwiL1wiKSl9dmFyIGw9byhmKSxkPWUodC52YWx1ZSksaD1pW2kubGVuZ3RoLTFdO3N3aXRjaCh1KXtjYXNlXCJyZXBsYWNlXCI6c3dpdGNoKGwpe2Nhc2UgMjpyZXR1cm4gZi5zZXQoaCxkKTtjYXNlIDM6bigxNik7ZGVmYXVsdDpyZXR1cm4gZltoXT1kfWNhc2UgYzpzd2l0Y2gobCl7Y2FzZSAxOnJldHVyblwiLVwiPT09aD9mLnB1c2goZCk6Zi5zcGxpY2UoaCwwLGQpO2Nhc2UgMjpyZXR1cm4gZi5zZXQoaCxkKTtjYXNlIDM6cmV0dXJuIGYuYWRkKGQpO2RlZmF1bHQ6cmV0dXJuIGZbaF09ZH1jYXNlXCJyZW1vdmVcIjpzd2l0Y2gobCl7Y2FzZSAxOnJldHVybiBmLnNwbGljZShoLDEpO2Nhc2UgMjpyZXR1cm4gZi5kZWxldGUoaCk7Y2FzZSAzOnJldHVybiBmLmRlbGV0ZSh0LnZhbHVlKTtkZWZhdWx0OnJldHVybiBkZWxldGUgZltoXX1kZWZhdWx0Om4oMTcsdSl9fSkpLHJ9LE46ZnVuY3Rpb24obixyLHQsZSl7c3dpdGNoKG4uaSl7Y2FzZSAwOmNhc2UgNDpjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKG4scix0LGUpe3ZhciBvPW4udCxzPW4ubztpKG4uUiwoZnVuY3Rpb24obixpKXt2YXIgdj1hKG8sbikscD1hKHMsbiksbD1pP3UobyxuKT9cInJlcGxhY2VcIjpjOlwicmVtb3ZlXCI7aWYodiE9PXB8fFwicmVwbGFjZVwiIT09bCl7dmFyIGQ9ci5jb25jYXQobik7dC5wdXNoKFwicmVtb3ZlXCI9PT1sP3tvcDpsLHBhdGg6ZH06e29wOmwscGF0aDpkLHZhbHVlOnB9KSxlLnB1c2gobD09PWM/e29wOlwicmVtb3ZlXCIscGF0aDpkfTpcInJlbW92ZVwiPT09bD97b3A6YyxwYXRoOmQsdmFsdWU6Zih2KX06e29wOlwicmVwbGFjZVwiLHBhdGg6ZCx2YWx1ZTpmKHYpfSl9fSkpfShuLHIsdCxlKTtjYXNlIDU6Y2FzZSAxOnJldHVybiBmdW5jdGlvbihuLHIsdCxlKXt2YXIgaT1uLnQsbz1uLlIsdT1uLm87aWYodS5sZW5ndGg8aS5sZW5ndGgpe3ZhciBhPVt1LGldO2k9YVswXSx1PWFbMV07dmFyIHM9W2UsdF07dD1zWzBdLGU9c1sxXX1mb3IodmFyIHY9MDt2PGkubGVuZ3RoO3YrKylpZihvW3ZdJiZ1W3ZdIT09aVt2XSl7dmFyIHA9ci5jb25jYXQoW3ZdKTt0LnB1c2goe29wOlwicmVwbGFjZVwiLHBhdGg6cCx2YWx1ZTpmKHVbdl0pfSksZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOnAsdmFsdWU6ZihpW3ZdKX0pfWZvcih2YXIgbD1pLmxlbmd0aDtsPHUubGVuZ3RoO2wrKyl7dmFyIGQ9ci5jb25jYXQoW2xdKTt0LnB1c2goe29wOmMscGF0aDpkLHZhbHVlOmYodVtsXSl9KX1pLmxlbmd0aDx1Lmxlbmd0aCYmZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOnIuY29uY2F0KFtcImxlbmd0aFwiXSksdmFsdWU6aS5sZW5ndGh9KX0obixyLHQsZSk7Y2FzZSAzOnJldHVybiBmdW5jdGlvbihuLHIsdCxlKXt2YXIgaT1uLnQsbz1uLm8sdT0wO2kuZm9yRWFjaCgoZnVuY3Rpb24obil7aWYoIW8uaGFzKG4pKXt2YXIgaT1yLmNvbmNhdChbdV0pO3QucHVzaCh7b3A6XCJyZW1vdmVcIixwYXRoOmksdmFsdWU6bn0pLGUudW5zaGlmdCh7b3A6YyxwYXRoOmksdmFsdWU6bn0pfXUrK30pKSx1PTAsby5mb3JFYWNoKChmdW5jdGlvbihuKXtpZighaS5oYXMobikpe3ZhciBvPXIuY29uY2F0KFt1XSk7dC5wdXNoKHtvcDpjLHBhdGg6byx2YWx1ZTpufSksZS51bnNoaWZ0KHtvcDpcInJlbW92ZVwiLHBhdGg6byx2YWx1ZTpufSl9dSsrfSkpfShuLHIsdCxlKX19LE06ZnVuY3Rpb24obixyLHQsZSl7dC5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOltdLHZhbHVlOnI9PT1IP3ZvaWQgMDpyfSksZS5wdXNoKHtvcDpcInJlcGxhY2VcIixwYXRoOltdLHZhbHVlOm59KX19KX1mdW5jdGlvbiBDKCl7ZnVuY3Rpb24gcihuLHIpe2Z1bmN0aW9uIHQoKXt0aGlzLmNvbnN0cnVjdG9yPW59YShuLHIpLG4ucHJvdG90eXBlPSh0LnByb3RvdHlwZT1yLnByb3RvdHlwZSxuZXcgdCl9ZnVuY3Rpb24gZShuKXtuLm98fChuLlI9bmV3IE1hcCxuLm89bmV3IE1hcChuLnQpKX1mdW5jdGlvbiBvKG4pe24ub3x8KG4ubz1uZXcgU2V0LG4udC5mb3JFYWNoKChmdW5jdGlvbihyKXtpZih0KHIpKXt2YXIgZT1OKG4uQS5oLHIsbik7bi5wLnNldChyLGUpLG4uby5hZGQoZSl9ZWxzZSBuLm8uYWRkKHIpfSkpKX1mdW5jdGlvbiB1KHIpe3IuTyYmbigzLEpTT04uc3RyaW5naWZ5KHAocikpKX12YXIgYT1mdW5jdGlvbihuLHIpe3JldHVybihhPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihuLHIpe24uX19wcm90b19fPXJ9fHxmdW5jdGlvbihuLHIpe2Zvcih2YXIgdCBpbiByKXIuaGFzT3duUHJvcGVydHkodCkmJihuW3RdPXJbdF0pfSkobixyKX0sZj1mdW5jdGlvbigpe2Z1bmN0aW9uIG4obixyKXtyZXR1cm4gdGhpc1tRXT17aToyLGw6cixBOnI/ci5BOl8oKSxQOiExLEk6ITEsbzp2b2lkIDAsUjp2b2lkIDAsdDpuLGs6dGhpcyxDOiExLE86ITF9LHRoaXN9cihuLE1hcCk7dmFyIG89bi5wcm90b3R5cGU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLFwic2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5zaXplfX0pLG8uaGFzPWZ1bmN0aW9uKG4pe3JldHVybiBwKHRoaXNbUV0pLmhhcyhuKX0sby5zZXQ9ZnVuY3Rpb24obixyKXt2YXIgdD10aGlzW1FdO3JldHVybiB1KHQpLHAodCkuaGFzKG4pJiZwKHQpLmdldChuKT09PXJ8fChlKHQpLGsodCksdC5SLnNldChuLCEwKSx0Lm8uc2V0KG4sciksdC5SLnNldChuLCEwKSksdGhpc30sby5kZWxldGU9ZnVuY3Rpb24obil7aWYoIXRoaXMuaGFzKG4pKXJldHVybiExO3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksZShyKSxrKHIpLHIudC5oYXMobik/ci5SLnNldChuLCExKTpyLlIuZGVsZXRlKG4pLHIuby5kZWxldGUobiksITB9LG8uY2xlYXI9ZnVuY3Rpb24oKXt2YXIgbj10aGlzW1FdO3UobikscChuKS5zaXplJiYoZShuKSxrKG4pLG4uUj1uZXcgTWFwLGkobi50LChmdW5jdGlvbihyKXtuLlIuc2V0KHIsITEpfSkpLG4uby5jbGVhcigpKX0sby5mb3JFYWNoPWZ1bmN0aW9uKG4scil7dmFyIHQ9dGhpcztwKHRoaXNbUV0pLmZvckVhY2goKGZ1bmN0aW9uKGUsaSl7bi5jYWxsKHIsdC5nZXQoaSksaSx0KX0pKX0sby5nZXQ9ZnVuY3Rpb24obil7dmFyIHI9dGhpc1tRXTt1KHIpO3ZhciBpPXAocikuZ2V0KG4pO2lmKHIuSXx8IXQoaSkpcmV0dXJuIGk7aWYoaSE9PXIudC5nZXQobikpcmV0dXJuIGk7dmFyIG89TihyLkEuaCxpLHIpO3JldHVybiBlKHIpLHIuby5zZXQobixvKSxvfSxvLmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5rZXlzKCl9LG8udmFsdWVzPWZ1bmN0aW9uKCl7dmFyIG4scj10aGlzLHQ9dGhpcy5rZXlzKCk7cmV0dXJuKG49e30pW1ZdPWZ1bmN0aW9uKCl7cmV0dXJuIHIudmFsdWVzKCl9LG4ubmV4dD1mdW5jdGlvbigpe3ZhciBuPXQubmV4dCgpO3JldHVybiBuLmRvbmU/bjp7ZG9uZTohMSx2YWx1ZTpyLmdldChuLnZhbHVlKX19LG59LG8uZW50cmllcz1mdW5jdGlvbigpe3ZhciBuLHI9dGhpcyx0PXRoaXMua2V5cygpO3JldHVybihuPXt9KVtWXT1mdW5jdGlvbigpe3JldHVybiByLmVudHJpZXMoKX0sbi5uZXh0PWZ1bmN0aW9uKCl7dmFyIG49dC5uZXh0KCk7aWYobi5kb25lKXJldHVybiBuO3ZhciBlPXIuZ2V0KG4udmFsdWUpO3JldHVybntkb25lOiExLHZhbHVlOltuLnZhbHVlLGVdfX0sbn0sb1tWXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVudHJpZXMoKX0sbn0oKSxjPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbihuLHIpe3JldHVybiB0aGlzW1FdPXtpOjMsbDpyLEE6cj9yLkE6XygpLFA6ITEsSTohMSxvOnZvaWQgMCx0Om4sazp0aGlzLHA6bmV3IE1hcCxPOiExLEM6ITF9LHRoaXN9cihuLFNldCk7dmFyIHQ9bi5wcm90b3R5cGU7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwic2l6ZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcCh0aGlzW1FdKS5zaXplfX0pLHQuaGFzPWZ1bmN0aW9uKG4pe3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksci5vPyEhci5vLmhhcyhuKXx8ISghci5wLmhhcyhuKXx8IXIuby5oYXMoci5wLmdldChuKSkpOnIudC5oYXMobil9LHQuYWRkPWZ1bmN0aW9uKG4pe3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksdGhpcy5oYXMobil8fChvKHIpLGsociksci5vLmFkZChuKSksdGhpc30sdC5kZWxldGU9ZnVuY3Rpb24obil7aWYoIXRoaXMuaGFzKG4pKXJldHVybiExO3ZhciByPXRoaXNbUV07cmV0dXJuIHUociksbyhyKSxrKHIpLHIuby5kZWxldGUobil8fCEhci5wLmhhcyhuKSYmci5vLmRlbGV0ZShyLnAuZ2V0KG4pKX0sdC5jbGVhcj1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07dShuKSxwKG4pLnNpemUmJihvKG4pLGsobiksbi5vLmNsZWFyKCkpfSx0LnZhbHVlcz1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07cmV0dXJuIHUobiksbyhuKSxuLm8udmFsdWVzKCl9LHQuZW50cmllcz1mdW5jdGlvbigpe3ZhciBuPXRoaXNbUV07cmV0dXJuIHUobiksbyhuKSxuLm8uZW50cmllcygpfSx0LmtleXM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZXMoKX0sdFtWXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlcygpfSx0LmZvckVhY2g9ZnVuY3Rpb24obixyKXtmb3IodmFyIHQ9dGhpcy52YWx1ZXMoKSxlPXQubmV4dCgpOyFlLmRvbmU7KW4uY2FsbChyLGUudmFsdWUsZS52YWx1ZSx0aGlzKSxlPXQubmV4dCgpfSxufSgpO20oXCJNYXBTZXRcIix7RjpmdW5jdGlvbihuLHIpe3JldHVybiBuZXcgZihuLHIpfSxUOmZ1bmN0aW9uKG4scil7cmV0dXJuIG5ldyBjKG4scil9fSl9ZnVuY3Rpb24gSigpe0YoKSxDKCksVCgpfWZ1bmN0aW9uIEsobil7cmV0dXJuIG59ZnVuY3Rpb24gJChuKXtyZXR1cm4gbn12YXIgRyxVLFc9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbChcInhcIiksWD1cInVuZGVmaW5lZFwiIT10eXBlb2YgTWFwLHE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFNldCxCPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBQcm94eSYmdm9pZCAwIT09UHJveHkucmV2b2NhYmxlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCxIPVc/U3ltYm9sLmZvcihcImltbWVyLW5vdGhpbmdcIik6KChHPXt9KVtcImltbWVyLW5vdGhpbmdcIl09ITAsRyksTD1XP1N5bWJvbC5mb3IoXCJpbW1lci1kcmFmdGFibGVcIik6XCJfXyRpbW1lcl9kcmFmdGFibGVcIixRPVc/U3ltYm9sLmZvcihcImltbWVyLXN0YXRlXCIpOlwiX18kaW1tZXJfc3RhdGVcIixWPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcnx8XCJAQGl0ZXJhdG9yXCIsWT17MDpcIklsbGVnYWwgc3RhdGVcIiwxOlwiSW1tZXIgZHJhZnRzIGNhbm5vdCBoYXZlIGNvbXB1dGVkIHByb3BlcnRpZXNcIiwyOlwiVGhpcyBvYmplY3QgaGFzIGJlZW4gZnJvemVuIGFuZCBzaG91bGQgbm90IGJlIG11dGF0ZWRcIiwzOmZ1bmN0aW9uKG4pe3JldHVyblwiQ2Fubm90IHVzZSBhIHByb3h5IHRoYXQgaGFzIGJlZW4gcmV2b2tlZC4gRGlkIHlvdSBwYXNzIGFuIG9iamVjdCBmcm9tIGluc2lkZSBhbiBpbW1lciBmdW5jdGlvbiB0byBhbiBhc3luYyBwcm9jZXNzPyBcIitufSw0OlwiQW4gaW1tZXIgcHJvZHVjZXIgcmV0dXJuZWQgYSBuZXcgdmFsdWUgKmFuZCogbW9kaWZpZWQgaXRzIGRyYWZ0LiBFaXRoZXIgcmV0dXJuIGEgbmV3IHZhbHVlICpvciogbW9kaWZ5IHRoZSBkcmFmdC5cIiw1OlwiSW1tZXIgZm9yYmlkcyBjaXJjdWxhciByZWZlcmVuY2VzXCIsNjpcIlRoZSBmaXJzdCBvciBzZWNvbmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvblwiLDc6XCJUaGUgdGhpcmQgYXJndW1lbnQgdG8gYHByb2R1Y2VgIG11c3QgYmUgYSBmdW5jdGlvbiBvciB1bmRlZmluZWRcIiw4OlwiRmlyc3QgYXJndW1lbnQgdG8gYGNyZWF0ZURyYWZ0YCBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LCBhbiBhcnJheSwgb3IgYW4gaW1tZXJhYmxlIG9iamVjdFwiLDk6XCJGaXJzdCBhcmd1bWVudCB0byBgZmluaXNoRHJhZnRgIG11c3QgYmUgYSBkcmFmdCByZXR1cm5lZCBieSBgY3JlYXRlRHJhZnRgXCIsMTA6XCJUaGUgZ2l2ZW4gZHJhZnQgaXMgYWxyZWFkeSBmaW5hbGl6ZWRcIiwxMTpcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eSgpIGNhbm5vdCBiZSB1c2VkIG9uIGFuIEltbWVyIGRyYWZ0XCIsMTI6XCJPYmplY3Quc2V0UHJvdG90eXBlT2YoKSBjYW5ub3QgYmUgdXNlZCBvbiBhbiBJbW1lciBkcmFmdFwiLDEzOlwiSW1tZXIgb25seSBzdXBwb3J0cyBkZWxldGluZyBhcnJheSBpbmRpY2VzXCIsMTQ6XCJJbW1lciBvbmx5IHN1cHBvcnRzIHNldHRpbmcgYXJyYXkgaW5kaWNlcyBhbmQgdGhlICdsZW5ndGgnIHByb3BlcnR5XCIsMTU6ZnVuY3Rpb24obil7cmV0dXJuXCJDYW5ub3QgYXBwbHkgcGF0Y2gsIHBhdGggZG9lc24ndCByZXNvbHZlOiBcIitufSwxNjonU2V0cyBjYW5ub3QgaGF2ZSBcInJlcGxhY2VcIiBwYXRjaGVzLicsMTc6ZnVuY3Rpb24obil7cmV0dXJuXCJVbnN1cHBvcnRlZCBwYXRjaCBvcGVyYXRpb246IFwiK259LDE4OmZ1bmN0aW9uKG4pe3JldHVyblwiVGhlIHBsdWdpbiBmb3IgJ1wiK24rXCInIGhhcyBub3QgYmVlbiBsb2FkZWQgaW50byBJbW1lci4gVG8gZW5hYmxlIHRoZSBwbHVnaW4sIGltcG9ydCBhbmQgY2FsbCBgZW5hYmxlXCIrbitcIigpYCB3aGVuIGluaXRpYWxpemluZyB5b3VyIGFwcGxpY2F0aW9uLlwifSwyMDpcIkNhbm5vdCB1c2UgcHJveGllcyBpZiBQcm94eSwgUHJveHkucmV2b2NhYmxlIG9yIFJlZmxlY3QgYXJlIG5vdCBhdmFpbGFibGVcIiwyMTpmdW5jdGlvbihuKXtyZXR1cm5cInByb2R1Y2UgY2FuIG9ubHkgYmUgY2FsbGVkIG9uIHRoaW5ncyB0aGF0IGFyZSBkcmFmdGFibGU6IHBsYWluIG9iamVjdHMsIGFycmF5cywgTWFwLCBTZXQgb3IgY2xhc3NlcyB0aGF0IGFyZSBtYXJrZWQgd2l0aCAnW2ltbWVyYWJsZV06IHRydWUnLiBHb3QgJ1wiK24rXCInXCJ9LDIyOmZ1bmN0aW9uKG4pe3JldHVyblwiJ2N1cnJlbnQnIGV4cGVjdHMgYSBkcmFmdCwgZ290OiBcIitufSwyMzpmdW5jdGlvbihuKXtyZXR1cm5cIidvcmlnaW5hbCcgZXhwZWN0cyBhIGRyYWZ0LCBnb3Q6IFwiK259LDI0OlwiUGF0Y2hpbmcgcmVzZXJ2ZWQgYXR0cmlidXRlcyBsaWtlIF9fcHJvdG9fXywgcHJvdG90eXBlIGFuZCBjb25zdHJ1Y3RvciBpcyBub3QgYWxsb3dlZFwifSxaPVwiXCIrT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcixubj1cInVuZGVmaW5lZFwiIT10eXBlb2YgUmVmbGVjdCYmUmVmbGVjdC5vd25LZXlzP1JlZmxlY3Qub3duS2V5czp2b2lkIDAhPT1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzP2Z1bmN0aW9uKG4pe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhuKS5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhuKSl9Ok9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLHJuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzfHxmdW5jdGlvbihuKXt2YXIgcj17fTtyZXR1cm4gbm4obikuZm9yRWFjaCgoZnVuY3Rpb24odCl7clt0XT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sdCl9KSkscn0sdG49e30sZW49e2dldDpmdW5jdGlvbihuLHIpe2lmKHI9PT1RKXJldHVybiBuO3ZhciBlPXAobik7aWYoIXUoZSxyKSlyZXR1cm4gZnVuY3Rpb24obixyLHQpe3ZhciBlLGk9SShyLHQpO3JldHVybiBpP1widmFsdWVcImluIGk/aS52YWx1ZTpudWxsPT09KGU9aS5nZXQpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLmNhbGwobi5rKTp2b2lkIDB9KG4sZSxyKTt2YXIgaT1lW3JdO3JldHVybiBuLkl8fCF0KGkpP2k6aT09PXoobi50LHIpPyhFKG4pLG4ub1tyXT1OKG4uQS5oLGksbikpOml9LGhhczpmdW5jdGlvbihuLHIpe3JldHVybiByIGluIHAobil9LG93bktleXM6ZnVuY3Rpb24obil7cmV0dXJuIFJlZmxlY3Qub3duS2V5cyhwKG4pKX0sc2V0OmZ1bmN0aW9uKG4scix0KXt2YXIgZT1JKHAobikscik7aWYobnVsbD09ZT92b2lkIDA6ZS5zZXQpcmV0dXJuIGUuc2V0LmNhbGwobi5rLHQpLCEwO2lmKCFuLlApe3ZhciBpPXoocChuKSxyKSxvPW51bGw9PWk/dm9pZCAwOmlbUV07aWYobyYmby50PT09dClyZXR1cm4gbi5vW3JdPXQsbi5SW3JdPSExLCEwO2lmKGModCxpKSYmKHZvaWQgMCE9PXR8fHUobi50LHIpKSlyZXR1cm4hMDtFKG4pLGsobil9cmV0dXJuIG4ub1tyXT09PXQmJih2b2lkIDAhPT10fHxyIGluIG4ubyl8fE51bWJlci5pc05hTih0KSYmTnVtYmVyLmlzTmFOKG4ub1tyXSl8fChuLm9bcl09dCxuLlJbcl09ITApLCEwfSxkZWxldGVQcm9wZXJ0eTpmdW5jdGlvbihuLHIpe3JldHVybiB2b2lkIDAhPT16KG4udCxyKXx8ciBpbiBuLnQ/KG4uUltyXT0hMSxFKG4pLGsobikpOmRlbGV0ZSBuLlJbcl0sbi5vJiZkZWxldGUgbi5vW3JdLCEwfSxnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ZnVuY3Rpb24obixyKXt2YXIgdD1wKG4pLGU9UmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCxyKTtyZXR1cm4gZT97d3JpdGFibGU6ITAsY29uZmlndXJhYmxlOjEhPT1uLml8fFwibGVuZ3RoXCIhPT1yLGVudW1lcmFibGU6ZS5lbnVtZXJhYmxlLHZhbHVlOnRbcl19OmV9LGRlZmluZVByb3BlcnR5OmZ1bmN0aW9uKCl7bigxMSl9LGdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKG4pe3JldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobi50KX0sc2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24oKXtuKDEyKX19LG9uPXt9O2koZW4sKGZ1bmN0aW9uKG4scil7b25bbl09ZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzWzBdPWFyZ3VtZW50c1swXVswXSxyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19KSksb24uZGVsZXRlUHJvcGVydHk9ZnVuY3Rpb24ocix0KXtyZXR1cm5cInByb2R1Y3Rpb25cIiE9PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZpc05hTihwYXJzZUludCh0KSkmJm4oMTMpLG9uLnNldC5jYWxsKHRoaXMscix0LHZvaWQgMCl9LG9uLnNldD1mdW5jdGlvbihyLHQsZSl7cmV0dXJuXCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmXCJsZW5ndGhcIiE9PXQmJmlzTmFOKHBhcnNlSW50KHQpKSYmbigxNCksZW4uc2V0LmNhbGwodGhpcyxyWzBdLHQsZSxyWzBdKX07dmFyIHVuPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShyKXt2YXIgZT10aGlzO3RoaXMuZz1CLHRoaXMuRD0hMCx0aGlzLnByb2R1Y2U9ZnVuY3Rpb24ocixpLG8pe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHImJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGkpe3ZhciB1PWk7aT1yO3ZhciBhPWU7cmV0dXJuIGZ1bmN0aW9uKG4pe3ZhciByPXRoaXM7dm9pZCAwPT09biYmKG49dSk7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsZT1BcnJheSh0PjE/dC0xOjApLG89MTtvPHQ7bysrKWVbby0xXT1hcmd1bWVudHNbb107cmV0dXJuIGEucHJvZHVjZShuLChmdW5jdGlvbihuKXt2YXIgdDtyZXR1cm4odD1pKS5jYWxsLmFwcGx5KHQsW3Isbl0uY29uY2F0KGUpKX0pKX19dmFyIGY7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgaSYmbig2KSx2b2lkIDAhPT1vJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBvJiZuKDcpLHQocikpe3ZhciBjPXcoZSkscz1OKGUscix2b2lkIDApLHY9ITA7dHJ5e2Y9aShzKSx2PSExfWZpbmFsbHl7dj9PKGMpOmcoYyl9cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb21pc2UmJmYgaW5zdGFuY2VvZiBQcm9taXNlP2YudGhlbigoZnVuY3Rpb24obil7cmV0dXJuIGooYyxvKSxQKG4sYyl9KSwoZnVuY3Rpb24obil7dGhyb3cgTyhjKSxufSkpOihqKGMsbyksUChmLGMpKX1pZighcnx8XCJvYmplY3RcIiE9dHlwZW9mIHIpe2lmKHZvaWQgMD09PShmPWkocikpJiYoZj1yKSxmPT09SCYmKGY9dm9pZCAwKSxlLkQmJmQoZiwhMCksbyl7dmFyIHA9W10sbD1bXTtiKFwiUGF0Y2hlc1wiKS5NKHIsZixwLGwpLG8ocCxsKX1yZXR1cm4gZn1uKDIxLHIpfSx0aGlzLnByb2R1Y2VXaXRoUGF0Y2hlcz1mdW5jdGlvbihuLHIpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG4pcmV0dXJuIGZ1bmN0aW9uKHIpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLGk9QXJyYXkodD4xP3QtMTowKSxvPTE7bzx0O28rKylpW28tMV09YXJndW1lbnRzW29dO3JldHVybiBlLnByb2R1Y2VXaXRoUGF0Y2hlcyhyLChmdW5jdGlvbihyKXtyZXR1cm4gbi5hcHBseSh2b2lkIDAsW3JdLmNvbmNhdChpKSl9KSl9O3ZhciB0LGksbz1lLnByb2R1Y2UobixyLChmdW5jdGlvbihuLHIpe3Q9bixpPXJ9KSk7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFByb21pc2UmJm8gaW5zdGFuY2VvZiBQcm9taXNlP28udGhlbigoZnVuY3Rpb24obil7cmV0dXJuW24sdCxpXX0pKTpbbyx0LGldfSxcImJvb2xlYW5cIj09dHlwZW9mKG51bGw9PXI/dm9pZCAwOnIudXNlUHJveGllcykmJnRoaXMuc2V0VXNlUHJveGllcyhyLnVzZVByb3hpZXMpLFwiYm9vbGVhblwiPT10eXBlb2YobnVsbD09cj92b2lkIDA6ci5hdXRvRnJlZXplKSYmdGhpcy5zZXRBdXRvRnJlZXplKHIuYXV0b0ZyZWV6ZSl9dmFyIGk9ZS5wcm90b3R5cGU7cmV0dXJuIGkuY3JlYXRlRHJhZnQ9ZnVuY3Rpb24oZSl7dChlKXx8big4KSxyKGUpJiYoZT1SKGUpKTt2YXIgaT13KHRoaXMpLG89Tih0aGlzLGUsdm9pZCAwKTtyZXR1cm4gb1tRXS5DPSEwLGcoaSksb30saS5maW5pc2hEcmFmdD1mdW5jdGlvbihyLHQpe3ZhciBlPXImJnJbUV07XCJwcm9kdWN0aW9uXCIhPT1wcm9jZXNzLmVudi5OT0RFX0VOViYmKGUmJmUuQ3x8big5KSxlLkkmJm4oMTApKTt2YXIgaT1lLkE7cmV0dXJuIGooaSx0KSxQKHZvaWQgMCxpKX0saS5zZXRBdXRvRnJlZXplPWZ1bmN0aW9uKG4pe3RoaXMuRD1ufSxpLnNldFVzZVByb3hpZXM9ZnVuY3Rpb24ocil7ciYmIUImJm4oMjApLHRoaXMuZz1yfSxpLmFwcGx5UGF0Y2hlcz1mdW5jdGlvbihuLHQpe3ZhciBlO2ZvcihlPXQubGVuZ3RoLTE7ZT49MDtlLS0pe3ZhciBpPXRbZV07aWYoMD09PWkucGF0aC5sZW5ndGgmJlwicmVwbGFjZVwiPT09aS5vcCl7bj1pLnZhbHVlO2JyZWFrfX1lPi0xJiYodD10LnNsaWNlKGUrMSkpO3ZhciBvPWIoXCJQYXRjaGVzXCIpLiQ7cmV0dXJuIHIobik/byhuLHQpOnRoaXMucHJvZHVjZShuLChmdW5jdGlvbihuKXtyZXR1cm4gbyhuLHQpfSkpfSxlfSgpLGFuPW5ldyB1bixmbj1hbi5wcm9kdWNlLGNuPWFuLnByb2R1Y2VXaXRoUGF0Y2hlcy5iaW5kKGFuKSxzbj1hbi5zZXRBdXRvRnJlZXplLmJpbmQoYW4pLHZuPWFuLnNldFVzZVByb3hpZXMuYmluZChhbikscG49YW4uYXBwbHlQYXRjaGVzLmJpbmQoYW4pLGxuPWFuLmNyZWF0ZURyYWZ0LmJpbmQoYW4pLGRuPWFuLmZpbmlzaERyYWZ0LmJpbmQoYW4pO2V4cG9ydCBkZWZhdWx0IGZuO2V4cG9ydHt1biBhcyBJbW1lcixwbiBhcyBhcHBseVBhdGNoZXMsSyBhcyBjYXN0RHJhZnQsJCBhcyBjYXN0SW1tdXRhYmxlLGxuIGFzIGNyZWF0ZURyYWZ0LFIgYXMgY3VycmVudCxKIGFzIGVuYWJsZUFsbFBsdWdpbnMsRiBhcyBlbmFibGVFUzUsQyBhcyBlbmFibGVNYXBTZXQsVCBhcyBlbmFibGVQYXRjaGVzLGRuIGFzIGZpbmlzaERyYWZ0LGQgYXMgZnJlZXplLEwgYXMgaW1tZXJhYmxlLHIgYXMgaXNEcmFmdCx0IGFzIGlzRHJhZnRhYmxlLEggYXMgbm90aGluZyxlIGFzIG9yaWdpbmFsLGZuIGFzIHByb2R1Y2UsY24gYXMgcHJvZHVjZVdpdGhQYXRjaGVzLHNuIGFzIHNldEF1dG9GcmVlemUsdm4gYXMgc2V0VXNlUHJveGllc307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbW1lci5lc20uanMubWFwXG4iLCJpbXBvcnQgeyBTdG9yZSB9IGZyb20gJ0B6ZWR1eC9yZWFjdCdcbmltcG9ydCBwcm9kdWNlLCB7IERyYWZ0IH0gZnJvbSAnaW1tZXInXG5cbmV4cG9ydCBjbGFzcyBJbW1lclN0b3JlPFN0YXRlPiBleHRlbmRzIFN0b3JlPFN0YXRlPiB7XG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihpbml0aWFsU3RhdGU/OiBTdGF0ZSkge1xuICAgIHN1cGVyKG51bGwsIGluaXRpYWxTdGF0ZSlcbiAgfVxuXG4gIHB1YmxpYyBwcm9kdWNlKHJlY2lwZTogKGRyYWZ0OiBEcmFmdDxTdGF0ZT4pID0+IGFueSkge1xuICAgIHRoaXMuc2V0U3RhdGUoXG4gICAgICBwcm9kdWNlKHRoaXMuZ2V0U3RhdGUoKSwgZHJhZnQgPT4ge1xuICAgICAgICByZWNpcGUoZHJhZnQpIC8vIGRvbid0IHJldHVybiB0aGUgcmVzdWx0IC0gdXNlciBzaG91bGQgdXNlIHN0b3JlLnNldFN0YXRlKCkgdG8gb3ZlcnJpZGUgc3RhdGVcbiAgICAgIH0pXG4gICAgKVxuICB9XG59XG4iLCJpbXBvcnQgeyBJbW1lclN0b3JlIH0gZnJvbSAnLi9JbW1lclN0b3JlJ1xuXG5leHBvcnQgY29uc3QgY3JlYXRlSW1tZXJTdG9yZSA9IDxTdGF0ZT4oaW5pdGlhbFN0YXRlPzogU3RhdGUpID0+XG4gIG5ldyBJbW1lclN0b3JlPFN0YXRlPihpbml0aWFsU3RhdGUpXG4iLCJpbXBvcnQge1xuICBjcmVhdGVJbmplY3RvcixcbiAgSW5qZWN0U3RvcmVDb25maWcsXG4gIGludGVybmFsVHlwZXMsXG4gIFBhcnRpYWxBdG9tSW5zdGFuY2UsXG4gIFN0b3JlLFxufSBmcm9tICdAemVkdXgvcmVhY3QnXG5pbXBvcnQgeyBjcmVhdGVJbW1lclN0b3JlIH0gZnJvbSAnLi9jcmVhdGVJbW1lclN0b3JlJ1xuaW1wb3J0IHsgSW1tZXJTdG9yZSB9IGZyb20gJy4vSW1tZXJTdG9yZSdcblxuY29uc3Qgb3BlcmF0aW9uID0gJ2luamVjdEltbWVyU3RvcmUnXG5cbmNvbnN0IGRvU3Vic2NyaWJlID0gPFN0YXRlPihcbiAgaW5zdGFuY2U6IFBhcnRpYWxBdG9tSW5zdGFuY2UsXG4gIHN0b3JlOiBTdG9yZTxTdGF0ZT5cbikgPT5cbiAgc3RvcmUuc3Vic2NyaWJlKHtcbiAgICBlZmZlY3RzOiAoeyBhY3Rpb24sIG5ld1N0YXRlLCBvbGRTdGF0ZSB9KSA9PiB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGRvIGlmIHRoZSBzdGF0ZSBoYXNuJ3QgY2hhbmdlZC4gQWxzbywgaWdub3JlIHN0YXRlIHVwZGF0ZXNcbiAgICAgIC8vIGR1cmluZyBldmFsdWF0aW9uLiBUT0RPOiBDcmVhdGUgYW4gZWNvc3lzdGVtLWxldmVsIGZsYWcgdG8gdHVybiBvblxuICAgICAgLy8gd2FybmluZyBsb2dnaW5nIGZvciBzdGF0ZS11cGRhdGVzLWR1cmluZy1ldmFsdWF0aW9uLCBzaW5jZSB0aGlzIG1heSBiZVxuICAgICAgLy8gY29uc2lkZXJlZCBhbiBhbnRpLXBhdHRlcm4uXG4gICAgICBpZiAoXG4gICAgICAgIG5ld1N0YXRlID09PSBvbGRTdGF0ZSB8fFxuICAgICAgICBpbnN0YW5jZS5lY29zeXN0ZW0uX2V2YWx1YXRpb25TdGFjay5pc0V2YWx1YXRpbmcoaW5zdGFuY2Uua2V5SGFzaCkgfHxcbiAgICAgICAgYWN0aW9uPy5tZXRhID09PSBpbnRlcm5hbFR5cGVzLmlnbm9yZVxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZS5fc2NoZWR1bGVFdmFsdWF0aW9uKFxuICAgICAgICB7XG4gICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgb2xkU3RhdGUsXG4gICAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICAgIHJlYXNvbnM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgICAgb2xkU3RhdGUsXG4gICAgICAgICAgICAgIG9wZXJhdGlvbjogJ2Rpc3BhdGNoJyxcbiAgICAgICAgICAgICAgc291cmNlVHlwZTogJ1N0b3JlJyxcbiAgICAgICAgICAgICAgdHlwZTogJ3N0YXRlIGNoYW5nZWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICAgIHNvdXJjZVR5cGU6ICdJbmplY3RvcicsXG4gICAgICAgICAgdHlwZTogJ3N0YXRlIGNoYW5nZWQnLFxuICAgICAgICB9LFxuICAgICAgICBmYWxzZVxuICAgICAgKVxuXG4gICAgICAvLyBydW4gdGhlIHNjaGVkdWxlciBzeW5jaHJvbm91c2x5IGFmdGVyIGFueSBzdG9yZSB1cGRhdGVcbiAgICAgIGluc3RhbmNlLmVjb3N5c3RlbS5fc2NoZWR1bGVyLmZsdXNoKClcbiAgICB9LFxuICB9KVxuXG5leHBvcnQgY29uc3QgaW5qZWN0SW1tZXJTdG9yZToge1xuICA8U3RhdGUgPSBhbnk+KHN0YXRlOiBTdGF0ZSwgY29uZmlnPzogSW5qZWN0U3RvcmVDb25maWcpOiBTdG9yZTxTdGF0ZT5cbiAgPFN0YXRlID0gdW5kZWZpbmVkPigpOiBTdG9yZTxTdGF0ZT5cbn0gPSBjcmVhdGVJbmplY3RvcihcbiAgb3BlcmF0aW9uLFxuICA8U3RhdGUgPSBhbnk+KFxuICAgIGluc3RhbmNlOiBQYXJ0aWFsQXRvbUluc3RhbmNlLFxuICAgIHN0YXRlPzogU3RhdGUsXG4gICAgY29uZmlnPzogSW5qZWN0U3RvcmVDb25maWdcbiAgKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaWJlID0gY29uZmlnPy5zdWJzY3JpYmUgPz8gdHJ1ZVxuICAgIGNvbnN0IGh5ZHJhdGlvbiA9IGluc3RhbmNlLmVjb3N5c3RlbS5fY29uc3VtZUh5ZHJhdGlvbihpbnN0YW5jZSlcbiAgICBjb25zdCBzdG9yZSA9IGNyZWF0ZUltbWVyU3RvcmU8U3RhdGU+KGh5ZHJhdGlvbiA/PyBzdGF0ZSlcblxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IHN1YnNjcmliZSAmJiBkb1N1YnNjcmliZShpbnN0YW5jZSwgc3RvcmUpXG5cbiAgICByZXR1cm4ge1xuICAgICAgY2xlYW51cDogc3Vic2NyaXB0aW9uID8gKCkgPT4gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCkgOiB1bmRlZmluZWQsXG4gICAgICByZXN1bHQ6IHN0b3JlLFxuICAgICAgdHlwZTogJ0BAemVkdXgvaW1tZXJTdG9yZScsXG4gICAgfVxuICB9LFxuICA8U3RhdGUgPSBhbnk+KFxuICAgIHByZXZEZXNjcmlwdG9yOiB7XG4gICAgICBjbGVhbnVwPzogKCkgPT4gdm9pZFxuICAgICAgcmVzdWx0OiBJbW1lclN0b3JlPFN0YXRlPlxuICAgICAgdHlwZTogc3RyaW5nXG4gICAgfSxcbiAgICBpbnN0YW5jZTogUGFydGlhbEF0b21JbnN0YW5jZSxcbiAgICBzdGF0ZT86IFN0YXRlLFxuICAgIGNvbmZpZz86IEluamVjdFN0b3JlQ29uZmlnXG4gICkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IGNvbmZpZz8uc3Vic2NyaWJlID8/IHRydWVcbiAgICBjb25zdCBwcmV2c3Vic2NyaWJlID0gISFwcmV2RGVzY3JpcHRvci5jbGVhbnVwXG5cbiAgICBpZiAocHJldnN1YnNjcmliZSA9PT0gc3Vic2NyaWJlKSByZXR1cm4gcHJldkRlc2NyaXB0b3JcblxuICAgIC8vIHdlIHdlcmUgc3Vic2NyaWJlZCwgbm93IHdlJ3JlIG5vdFxuICAgIGlmICghc3Vic2NyaWJlKSB7XG4gICAgICBwcmV2RGVzY3JpcHRvci5jbGVhbnVwPy4oKVxuICAgICAgcHJldkRlc2NyaXB0b3IuY2xlYW51cCA9IHVuZGVmaW5lZFxuICAgICAgcmV0dXJuIHByZXZEZXNjcmlwdG9yXG4gICAgfVxuXG4gICAgLy8gd2Ugd2VyZW4ndCBzdWJzY3JpYmVkLCBub3cgd2UgYXJlXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gZG9TdWJzY3JpYmUoaW5zdGFuY2UsIHByZXZEZXNjcmlwdG9yLnJlc3VsdClcbiAgICBwcmV2RGVzY3JpcHRvci5jbGVhbnVwID0gKCkgPT4gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKClcblxuICAgIHJldHVybiBwcmV2RGVzY3JpcHRvclxuICB9XG4pXG4iLCJleHBvcnQgKiBmcm9tICcuL2NyZWF0ZUltbWVyU3RvcmUnXG5leHBvcnQgKiBmcm9tICcuL0ltbWVyU3RvcmUnXG5leHBvcnQgKiBmcm9tICcuL2luamVjdEltbWVyU3RvcmUnXG4iLCJpbXBvcnQgeyBSZWFjdGFibGUgfSBmcm9tICcuLi90eXBlcydcblxuLyoqXG4gIFB1bGxzIHRoZSBzdHJpbmcgYWN0aW9uIHR5cGUgb3V0IG9mIGFuIEFjdGlvbkZhY3Rvcnkgb3IgcmV0dXJuc1xuICBhIGdpdmVuIHN0cmluZyBhY3Rpb24gdHlwZSBhcy1pcy5cbiovXG5leHBvcnQgY29uc3QgZXh0cmFjdEFjdGlvblR5cGUgPSAocmVhY3RhYmxlOiBSZWFjdGFibGUsIG1ldGhvZDogc3RyaW5nKSA9PiB7XG4gIC8vIFRoZSByZWFjdGFibGUgbWF5IGJlIGEgbGl0ZXJhbCBhY3Rpb24gdHlwZSBzdHJpbmdcbiAgaWYgKHR5cGVvZiByZWFjdGFibGUgPT09ICdzdHJpbmcnKSByZXR1cm4gcmVhY3RhYmxlXG5cbiAgaWYgKFxuICAgIERFViAmJlxuICAgICh0eXBlb2YgcmVhY3RhYmxlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiByZWFjdGFibGUudHlwZSAhPT0gJ3N0cmluZycpXG4gICkge1xuICAgIGNvbnN0IHR5cGUgPVxuICAgICAgdHlwZW9mIHJlYWN0YWJsZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGBmdW5jdGlvbiB3aXRoIGludmFsaWQgXCJ0eXBlXCIgcHJvcGVydHkgLSAke3R5cGVvZiByZWFjdGFibGUudHlwZX1gXG4gICAgICAgIDogdHlwZW9mIHJlYWN0YWJsZVxuXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBaZWR1eDogJHttZXRob2R9IC0gcmVhY3RhYmxlIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24gd2l0aCBhIFwidHlwZVwiIHByb3BlcnR5LiBSZWNlaXZlZCAke3R5cGV9YFxuICAgIClcbiAgfVxuXG4gIHJldHVybiByZWFjdGFibGUudHlwZVxufVxuXG4vKipcbiAgUHVsbHMgdGhlIHN0cmluZyBhY3Rpb24gdHlwZXMgb3V0IG9mIGEgbGlzdCBvZiAocG9zc2libHkpIG1peGVkXG4gIHJlYWN0YWJsZXMgYW5kIHN0cmluZyBhY3Rpb24gdHlwZXMuXG4qL1xuZXhwb3J0IGNvbnN0IGV4dHJhY3RBY3Rpb25UeXBlcyA9IChyZWFjdGFibGVzOiBSZWFjdGFibGVbXSwgbWV0aG9kOiBzdHJpbmcpID0+XG4gIHJlYWN0YWJsZXMubWFwKHJlYWN0YWJsZSA9PiBleHRyYWN0QWN0aW9uVHlwZShyZWFjdGFibGUsIG1ldGhvZCkpXG4iLCJpbXBvcnQgeyBBY3Rpb24sIFJlYWN0YWJsZSwgUmVkdWNlckJ1aWxkZXIsIFN1YlJlZHVjZXIgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IGV4dHJhY3RBY3Rpb25UeXBlLCBleHRyYWN0QWN0aW9uVHlwZXMgfSBmcm9tICcuLi91dGlscy9hY3Rpb25zJ1xuXG5pbnRlcmZhY2UgUmVkdWNlcnNNYXA8U3RhdGU+IHtcbiAgW2tleTogc3RyaW5nXTogU3ViUmVkdWNlcjxTdGF0ZT5bXVxufVxuXG4vKipcbiAgQ3JlYXRlcyBhIG5ldyBSZWR1Y2VyQnVpbGRlci5cblxuICBBIFJlZHVjZXJCdWlsZGVyIGlzIGp1c3QgYSByZWR1Y2VyIHdpdGggYSBzcGVjaWFsIGAucmVkdWNlcigpYCBtZXRob2QgZm9yXG4gIGVhc2lseSBtYXBwaW5nIGFjdGlvbiB0eXBlcyB0byBzdWItcmVkdWNlcnMgdGhhdCBoYW5kbGUgdGhlbS5cbiovXG5leHBvcnQgY29uc3QgY3JlYXRlUmVkdWNlciA9IDxTdGF0ZSA9IGFueT4oaW5pdGlhbFN0YXRlPzogU3RhdGUpID0+IHtcbiAgY29uc3QgYWN0aW9uVG9SZWR1Y2Vyc01hcDogUmVkdWNlcnNNYXA8U3RhdGU+ID0ge31cblxuICBjb25zdCByZWR1Y2VyID0gKChzdGF0ZTogU3RhdGUgPSBpbml0aWFsU3RhdGUgYXMgU3RhdGUsIGFjdGlvbjogQWN0aW9uKSA9PiB7XG4gICAgY29uc3QgcmVkdWNlcnMgPSBhY3Rpb25Ub1JlZHVjZXJzTWFwW2FjdGlvbi50eXBlXSB8fCBbXVxuXG4gICAgcmV0dXJuIHJ1blJlZHVjZXJzKHJlZHVjZXJzLCBzdGF0ZSwgYWN0aW9uKVxuICB9KSBhcyBSZWR1Y2VyQnVpbGRlcjxTdGF0ZT5cblxuICByZWR1Y2VyLnJlZHVjZSA9IDxQYXlsb2FkID0gYW55LCBUeXBlIGV4dGVuZHMgc3RyaW5nID0gYW55LCBNZXRhID0gYW55PihcbiAgICByZWFjdGFibGU6IFJlYWN0YWJsZTxQYXlsb2FkLCBUeXBlPiB8IFJlYWN0YWJsZTxQYXlsb2FkLCBUeXBlPltdLFxuICAgIHN1YlJlZHVjZXI6IFN1YlJlZHVjZXI8U3RhdGUsIFBheWxvYWQsIFR5cGUsIE1ldGE+XG4gICkgPT4ge1xuICAgIGNvbnN0IG1ldGhvZCA9ICdSZWR1Y2VyQnVpbGRlci5yZWR1Y2UoKSdcbiAgICBjb25zdCBhY3Rpb25UeXBlcyA9IEFycmF5LmlzQXJyYXkocmVhY3RhYmxlKVxuICAgICAgPyBleHRyYWN0QWN0aW9uVHlwZXMocmVhY3RhYmxlLCBtZXRob2QpXG4gICAgICA6IFtleHRyYWN0QWN0aW9uVHlwZShyZWFjdGFibGUsIG1ldGhvZCldXG5cbiAgICBtYXBBY3Rpb25UeXBlc1RvUmVkdWNlcihhY3Rpb25Ub1JlZHVjZXJzTWFwLCBhY3Rpb25UeXBlcywgc3ViUmVkdWNlcilcblxuICAgIHJldHVybiByZWR1Y2VyXG4gIH1cblxuICByZXR1cm4gcmVkdWNlclxufVxuXG5mdW5jdGlvbiBtYXBBY3Rpb25UeXBlc1RvUmVkdWNlcjxTdGF0ZT4oXG4gIG1hcDogUmVkdWNlcnNNYXA8U3RhdGU+LFxuICBhY3Rpb25UeXBlczogc3RyaW5nW10sXG4gIGNvbnN1bWVyOiBTdWJSZWR1Y2VyXG4pIHtcbiAgYWN0aW9uVHlwZXMuZm9yRWFjaChhY3Rpb25UeXBlID0+IHtcbiAgICBpZiAoIW1hcFthY3Rpb25UeXBlXSkge1xuICAgICAgbWFwW2FjdGlvblR5cGVdID0gW11cbiAgICB9XG5cbiAgICBtYXBbYWN0aW9uVHlwZV0ucHVzaChjb25zdW1lcilcbiAgfSlcbn1cblxuZnVuY3Rpb24gcnVuUmVkdWNlcnM8U3RhdGU+KFxuICByZWR1Y2VyczogU3ViUmVkdWNlcltdLFxuICBzdGF0ZTogU3RhdGUsXG4gIGFjdGlvbjogQWN0aW9uXG4pIHtcbiAgcmV0dXJuIHJlZHVjZXJzLnJlZHVjZShcbiAgICAoYWNjdW11bGF0ZWRTdGF0ZSwgcmVkdWNlcikgPT5cbiAgICAgIHJlZHVjZXIoYWNjdW11bGF0ZWRTdGF0ZSwgYWN0aW9uLnBheWxvYWQsIGFjdGlvbiksXG4gICAgc3RhdGVcbiAgKVxufVxuIiwiaW1wb3J0IHsgUmVjdXJzaXZlUGFydGlhbCwgU2V0dGFibGUgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IE1hY2hpbmVTdGF0ZVR5cGUgfSBmcm9tICcuLi91dGlscy90eXBlcydcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnLi9jcmVhdGVTdG9yZSdcblxuLyoqXG4gKiBBbiBleHRyZW1lbHkgbG93LWxldmVsIFN0b3JlIGNsYXNzIHRoYXQgcmVwcmVzZW50cyBhIHN0YXRlIG1hY2hpbmUuIERvbid0XG4gKiBjcmVhdGUgdGhpcyBjbGFzcyB5b3Vyc2VsZiwgdXNlIGEgaGVscGVyIHN1Y2ggYXMgQHplZHV4L3JlYWN0J3NcbiAqIGBpbmplY3RNYWNoaW5lU3RvcmUoKWBcbiAqL1xuZXhwb3J0IGNsYXNzIE1hY2hpbmVTdG9yZTxcbiAgU3RhdGVOYW1lcyBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgRXZlbnROYW1lcyBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgQ29udGV4dCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbj4gZXh0ZW5kcyBTdG9yZTxNYWNoaW5lU3RhdGVUeXBlPFN0YXRlTmFtZXMsIENvbnRleHQ+PiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGluaXRpYWxTdGF0ZTogU3RhdGVOYW1lcyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgc3RhdGVzOiBSZWNvcmQ8XG4gICAgICBTdGF0ZU5hbWVzLFxuICAgICAgUmVjb3JkPFxuICAgICAgICBFdmVudE5hbWVzLFxuICAgICAgICB7IG5hbWU6IFN0YXRlTmFtZXM7IGd1YXJkPzogKGNvbnRleHQ6IENvbnRleHQpID0+IGJvb2xlYW4gfVxuICAgICAgPlxuICAgID4sXG4gICAgaW5pdGlhbENvbnRleHQ/OiBDb250ZXh0LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZ3VhcmQ/OiAoXG4gICAgICBjdXJyZW50U3RhdGU6IE1hY2hpbmVTdGF0ZVR5cGU8U3RhdGVOYW1lcywgQ29udGV4dD4sXG4gICAgICBuZXh0VmFsdWU6IFN0YXRlTmFtZXNcbiAgICApID0+IGJvb2xlYW5cbiAgKSB7XG4gICAgc3VwZXIobnVsbCwge1xuICAgICAgY29udGV4dDogaW5pdGlhbENvbnRleHQgYXMgQ29udGV4dCxcbiAgICAgIHZhbHVlOiBpbml0aWFsU3RhdGUsXG4gICAgfSlcbiAgfVxuXG4gIHB1YmxpYyBnZXRDb250ZXh0ID0gKCkgPT4gdGhpcy5nZXRTdGF0ZSgpLmNvbnRleHRcblxuICBwdWJsaWMgZ2V0VmFsdWUgPSAoKSA9PiB0aGlzLmdldFN0YXRlKCkudmFsdWVcblxuICBwdWJsaWMgaXMgPSAoc3RhdGVOYW1lOiBTdGF0ZU5hbWVzKSA9PiB0aGlzLmdldFN0YXRlKCkudmFsdWUgPT09IHN0YXRlTmFtZVxuXG4gIHB1YmxpYyBzZW5kID0gKGV2ZW50TmFtZTogRXZlbnROYW1lcywgbWV0YT86IGFueSkgPT5cbiAgICB0aGlzLnNldFN0YXRlKGN1cnJlbnRTdGF0ZSA9PiB7XG4gICAgICBjb25zdCBuZXh0VmFsdWUgPSB0aGlzLnN0YXRlc1tjdXJyZW50U3RhdGUudmFsdWVdW2V2ZW50TmFtZV1cblxuICAgICAgaWYgKFxuICAgICAgICAhbmV4dFZhbHVlIHx8XG4gICAgICAgIChuZXh0VmFsdWU/Lmd1YXJkICYmICFuZXh0VmFsdWUuZ3VhcmQoY3VycmVudFN0YXRlLmNvbnRleHQpKSB8fFxuICAgICAgICAodGhpcy5ndWFyZCAmJiAhdGhpcy5ndWFyZChjdXJyZW50U3RhdGUsIG5leHRWYWx1ZS5uYW1lKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gY3VycmVudFN0YXRlXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IGNvbnRleHQ6IGN1cnJlbnRTdGF0ZS5jb250ZXh0LCB2YWx1ZTogbmV4dFZhbHVlLm5hbWUgfVxuICAgIH0sIG1ldGEpXG5cbiAgcHVibGljIHNldENvbnRleHQgPSAoY29udGV4dDogU2V0dGFibGU8Q29udGV4dD4sIG1ldGE/OiBhbnkpID0+XG4gICAgdGhpcy5zZXRTdGF0ZShcbiAgICAgIHN0YXRlID0+ICh7XG4gICAgICAgIGNvbnRleHQ6XG4gICAgICAgICAgdHlwZW9mIGNvbnRleHQgPT09ICdmdW5jdGlvbicgPyBjb250ZXh0KHN0YXRlLmNvbnRleHQpIDogY29udGV4dCxcbiAgICAgICAgdmFsdWU6IHN0YXRlLnZhbHVlLFxuICAgICAgfSksXG4gICAgICBtZXRhXG4gICAgKVxuXG4gIHB1YmxpYyBzZXRDb250ZXh0RGVlcCA9IChcbiAgICBwYXJ0aWFsQ29udGV4dDogU2V0dGFibGU8UmVjdXJzaXZlUGFydGlhbDxDb250ZXh0PiwgQ29udGV4dD4sXG4gICAgbWV0YT86IGFueVxuICApID0+XG4gICAgdGhpcy5zZXRTdGF0ZURlZXAoXG4gICAgICBzdGF0ZSA9PiAoe1xuICAgICAgICBjb250ZXh0OlxuICAgICAgICAgIHR5cGVvZiBwYXJ0aWFsQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwYXJ0aWFsQ29udGV4dChzdGF0ZS5jb250ZXh0KVxuICAgICAgICAgICAgOiBwYXJ0aWFsQ29udGV4dCxcbiAgICAgIH0pLFxuICAgICAgbWV0YVxuICAgIClcbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vYXBpL2NvbnN0YW50cydcbmV4cG9ydCAqIGZyb20gJy4vYXBpL2FjdGlvbkZhY3RvcnknXG5leHBvcnQgKiBmcm9tICcuL2FwaS9jcmVhdGVSZWR1Y2VyJ1xuZXhwb3J0ICogZnJvbSAnLi9hcGkvY3JlYXRlU3RvcmUnXG5leHBvcnQgKiBmcm9tICcuL2FwaS9NYWNoaW5lU3RvcmUnXG5leHBvcnQgKiBmcm9tICcuL2FwaS9tZXRhJ1xuZXhwb3J0ICogZnJvbSAnLi9hcGkvaXMnXG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJ1xuIiwiaW1wb3J0IHsgU3RvcmUsIFN0b3JlU3RhdGVUeXBlIH0gZnJvbSAnQHplZHV4L2NvcmUnXG5pbXBvcnQgeyBBdG9tQXBpIH0gZnJvbSAnLi4vY2xhc3NlcydcbmltcG9ydCB7IElvbiB9IGZyb20gJy4uL2NsYXNzZXMvYXRvbXMvSW9uJ1xuaW1wb3J0IHtcbiAgQXRvbUNvbmZpZyxcbiAgQXRvbUdldHRlcnMsXG4gIEF0b21BcGlQcm9taXNlLFxuICBJb25TdGF0ZUZhY3RvcnksXG4gIFByb21pc2VTdGF0ZSxcbn0gZnJvbSAnLi4vdHlwZXMnXG5cbmV4cG9ydCBjb25zdCBpb246IHtcbiAgLy8gUXVlcnkgQXRvbXNcbiAgPFxuICAgIFN0YXRlID0gYW55LFxuICAgIFBhcmFtcyBleHRlbmRzIGFueVtdID0gW10sXG4gICAgRXhwb3J0cyBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4gPSBSZWNvcmQ8c3RyaW5nLCBuZXZlcj5cbiAgPihcbiAgICBrZXk6IHN0cmluZyxcbiAgICB2YWx1ZTogKFxuICAgICAgZ2V0dGVyczogQXRvbUdldHRlcnMsXG4gICAgICAuLi5wYXJhbXM6IFBhcmFtc1xuICAgICkgPT4gQXRvbUFwaTxQcm9taXNlPFN0YXRlPiwgRXhwb3J0cywgdW5kZWZpbmVkLCBhbnk+LFxuICAgIGNvbmZpZz86IEF0b21Db25maWc8U3RhdGU+XG4gICk6IElvbjxcbiAgICBQcm9taXNlU3RhdGU8U3RhdGU+LFxuICAgIFBhcmFtcyxcbiAgICBFeHBvcnRzLFxuICAgIFN0b3JlPFByb21pc2VTdGF0ZTxTdGF0ZT4+LFxuICAgIFByb21pc2U8U3RhdGU+XG4gID5cblxuICAvLyBDdXN0b20gU3RvcmVzXG4gIDxcbiAgICBTdG9yZVR5cGUgZXh0ZW5kcyBTdG9yZTxhbnk+ID0gU3RvcmU8YW55PixcbiAgICBQYXJhbXMgZXh0ZW5kcyBhbnlbXSA9IFtdLFxuICAgIEV4cG9ydHMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gUmVjb3JkPHN0cmluZywgbmV2ZXI+LFxuICAgIFByb21pc2VUeXBlIGV4dGVuZHMgQXRvbUFwaVByb21pc2UgPSB1bmRlZmluZWRcbiAgPihcbiAgICBrZXk6IHN0cmluZyxcbiAgICBnZXQ6IChcbiAgICAgIGdldHRlcnM6IEF0b21HZXR0ZXJzLFxuICAgICAgLi4ucGFyYW1zOiBQYXJhbXNcbiAgICApID0+XG4gICAgICB8IFN0b3JlVHlwZVxuICAgICAgfCBBdG9tQXBpPFN0b3JlU3RhdGVUeXBlPFN0b3JlPiwgRXhwb3J0cywgU3RvcmVUeXBlLCBQcm9taXNlVHlwZT4sXG4gICAgY29uZmlnPzogQXRvbUNvbmZpZzxTdG9yZVN0YXRlVHlwZTxTdG9yZVR5cGU+PlxuICApOiBJb248U3RvcmVTdGF0ZVR5cGU8U3RvcmVUeXBlPiwgUGFyYW1zLCBFeHBvcnRzLCBTdG9yZVR5cGUsIFByb21pc2VUeXBlPlxuXG4gIC8vIE5vIFN0b3JlXG4gIDxcbiAgICBTdGF0ZSA9IGFueSxcbiAgICBQYXJhbXMgZXh0ZW5kcyBhbnlbXSA9IFtdLFxuICAgIEV4cG9ydHMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gUmVjb3JkPHN0cmluZywgbmV2ZXI+LFxuICAgIFByb21pc2VUeXBlIGV4dGVuZHMgQXRvbUFwaVByb21pc2UgPSB1bmRlZmluZWRcbiAgPihcbiAgICBrZXk6IHN0cmluZyxcbiAgICBnZXQ6IChcbiAgICAgIGdldHRlcnM6IEF0b21HZXR0ZXJzLFxuICAgICAgLi4ucGFyYW1zOiBQYXJhbXNcbiAgICApID0+IEF0b21BcGk8U3RhdGUsIEV4cG9ydHMsIHVuZGVmaW5lZCwgUHJvbWlzZVR5cGU+IHwgU3RhdGUsXG4gICAgY29uZmlnPzogQXRvbUNvbmZpZzxTdGF0ZT5cbiAgKTogSW9uPFN0YXRlLCBQYXJhbXMsIEV4cG9ydHMsIFN0b3JlPFN0YXRlPiwgUHJvbWlzZVR5cGU+XG5cbiAgLy8gQ2F0Y2gtYWxsXG4gIDxcbiAgICBTdGF0ZSA9IGFueSxcbiAgICBQYXJhbXMgZXh0ZW5kcyBhbnlbXSA9IFtdLFxuICAgIEV4cG9ydHMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gUmVjb3JkPHN0cmluZywgbmV2ZXI+LFxuICAgIFN0b3JlVHlwZSBleHRlbmRzIFN0b3JlPGFueT4gPSBTdG9yZTxhbnk+LFxuICAgIFByb21pc2VUeXBlIGV4dGVuZHMgQXRvbUFwaVByb21pc2UgPSB1bmRlZmluZWRcbiAgPihcbiAgICBrZXk6IHN0cmluZyxcbiAgICBnZXQ6IElvblN0YXRlRmFjdG9yeTxTdGF0ZSwgUGFyYW1zLCBFeHBvcnRzLCBTdG9yZVR5cGUsIFByb21pc2VUeXBlPixcbiAgICBjb25maWc/OiBBdG9tQ29uZmlnPFN0YXRlPlxuICApOiBJb248U3RhdGUsIFBhcmFtcywgRXhwb3J0cywgU3RvcmVUeXBlLCBQcm9taXNlVHlwZT5cbn0gPSA8XG4gIFN0YXRlID0gYW55LFxuICBQYXJhbXMgZXh0ZW5kcyBhbnlbXSA9IFtdLFxuICBFeHBvcnRzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiA9IFJlY29yZDxzdHJpbmcsIG5ldmVyPixcbiAgU3RvcmVUeXBlIGV4dGVuZHMgU3RvcmU8U3RhdGU+ID0gU3RvcmU8U3RhdGU+LFxuICBQcm9taXNlVHlwZSBleHRlbmRzIEF0b21BcGlQcm9taXNlID0gdW5kZWZpbmVkXG4+KFxuICBrZXk6IHN0cmluZyxcbiAgZ2V0OiBJb25TdGF0ZUZhY3Rvcnk8U3RhdGUsIFBhcmFtcywgRXhwb3J0cywgU3RvcmVUeXBlLCBQcm9taXNlVHlwZT4sXG4gIGNvbmZpZz86IEF0b21Db25maWc8U3RhdGU+XG4pID0+IG5ldyBJb24oa2V5LCBnZXQsIGNvbmZpZylcbiIsImltcG9ydCB7IHJlYWRJbnN0YW5jZSB9IGZyb20gJy4uL2NsYXNzZXMvRXZhbHVhdGlvblN0YWNrJ1xuXG4vKipcbiAqIGluamVjdEF0b21HZXR0ZXJzXG4gKlxuICogQW4gaW5qZWN0b3IgdGhhdCByZXR1cm5zIGFuIEF0b21HZXR0ZXJzIG9iamVjdC4gVGhlIHJldHVybmVkIEF0b21HZXR0ZXJzXG4gKiBkeW5hbWljYWxseSByZWdpc3RlciBkZXBlbmRlbmNpZXMgZm9yIHRoZSBjdXJyZW50IGF0b20gaW5zdGFuY2Ugd2hlbiBjYWxsZWRcbiAqIHN5bmNocm9ub3VzbHkgZHVyaW5nIGF0b20gZXZhbHVhdGlvbi5cbiAqXG4gKiBgYGB0c1xuICogY29uc3QgZXhhbXBsZUF0b20gPSBhdG9tKCdleGFtcGxlJywgKCkgPT4ge1xuICogICBjb25zdCB7wqBlY29zeXN0ZW0sIGdldCwgZ2V0SW5zdGFuY2UgfSA9IGluamVjdEF0b21HZXR0ZXJzKClcbiAqICAgY29uc3QgZHluYW1pY1ZhbCA9IGdldChteUF0b20pIC8vIHJlZ2lzdGVycyBhIGR5bmFtaWMgZ3JhcGggZWRnZVxuICogICBjb25zdCBpbnN0YW5jZSA9IGdldEluc3RhbmNlKG15QXRvbSkgLy8gcmVnaXN0ZXJzIGEgc3RhdGljIGdyYXBoIGVkZ2VcbiAqICAgY29uc3QgZnJvbUVjb3N5c3RlbSA9IGVjb3N5c3RlbS5nZXQobXlBdG9tKSAvLyBkb2Vzbid0IHJlZ2lzdGVyIGFueXRoaW5nXG4gKlxuICogICBpbmplY3RFZmZlY3QoKCkgPT4ge1xuICogICAgIGNvbnN0IGR5bmFtaWNWYWwyID0gZ2V0KG15QXRvbSkgLy8gZG9lc24ndCByZWdpc3RlciBhbnl0aGluZ1xuICogICAgIGNvbnN0IGluc3RhbmNlMiA9IGdldEluc3RhbmNlKG15QXRvbSkgLy8gZG9lc24ndCByZWdpc3RlciBhbnl0aGluZ1xuICogICAgIGNvbnN0IGZyb21FY29zeXN0ZW0yID0gZWNvc3lzdGVtLmdldChteUF0b20pIC8vIGRvZXNuJ3QgcmVnaXN0ZXIgYW55dGhpbmdcbiAqICAgfSwgW10pIC8vIG5vIG5lZWQgdG8gcGFzcyBBdG9tR2V0dGVycyBhcyBkZXBzOyB0aGV5J3JlIHN0YWJsZSByZWZlcmVuY2VzXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHNlZSBBdG9tR2V0dGVyc1xuICovXG5leHBvcnQgY29uc3QgaW5qZWN0QXRvbUdldHRlcnMgPSAoKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlID0gcmVhZEluc3RhbmNlKClcblxuICByZXR1cm4gaW5zdGFuY2UuZWNvc3lzdGVtLl9ldmFsdWF0aW9uU3RhY2suYXRvbUdldHRlcnNcbn1cbiIsImltcG9ydCB7IFN0b3JlIH0gZnJvbSAnQHplZHV4L2NvcmUnXG5pbXBvcnQgeyBpb24gfSBmcm9tICdAemVkdXgvcmVhY3QvZmFjdG9yaWVzL2lvbidcbmltcG9ydCB7IGluamVjdEF0b21HZXR0ZXJzIH0gZnJvbSAnQHplZHV4L3JlYWN0L2luamVjdG9ycydcbmltcG9ydCB7IEF0b21Db25maWcsIElvblN0YXRlRmFjdG9yeSwgQXRvbUFwaVByb21pc2UgfSBmcm9tICdAemVkdXgvcmVhY3QvdHlwZXMnXG5pbXBvcnQgeyBBdG9tSW5zdGFuY2UgfSBmcm9tICcuLi9pbnN0YW5jZXMvQXRvbUluc3RhbmNlJ1xuaW1wb3J0IHsgRWNvc3lzdGVtIH0gZnJvbSAnLi4vRWNvc3lzdGVtJ1xuaW1wb3J0IHsgQXRvbUJhc2UgfSBmcm9tICcuL0F0b21CYXNlJ1xuXG5leHBvcnQgY2xhc3MgSW9uPFxuICBTdGF0ZSxcbiAgUGFyYW1zIGV4dGVuZHMgYW55W10sXG4gIEV4cG9ydHMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBTdG9yZVR5cGUgZXh0ZW5kcyBTdG9yZTxTdGF0ZT4sXG4gIFByb21pc2VUeXBlIGV4dGVuZHMgQXRvbUFwaVByb21pc2Vcbj4gZXh0ZW5kcyBBdG9tQmFzZTxcbiAgU3RhdGUsXG4gIFBhcmFtcyxcbiAgRXhwb3J0cyxcbiAgU3RvcmVUeXBlLFxuICBQcm9taXNlVHlwZSxcbiAgQXRvbUluc3RhbmNlPFN0YXRlLCBQYXJhbXMsIEV4cG9ydHMsIFN0b3JlVHlwZSwgUHJvbWlzZVR5cGU+XG4+IHtcbiAgcHJpdmF0ZSBfZ2V0OiBJb25TdGF0ZUZhY3Rvcnk8U3RhdGUsIFBhcmFtcywgRXhwb3J0cywgU3RvcmVUeXBlLCBQcm9taXNlVHlwZT5cblxuICBjb25zdHJ1Y3RvcihcbiAgICBrZXk6IHN0cmluZyxcbiAgICBzdGF0ZUZhY3Rvcnk6IElvblN0YXRlRmFjdG9yeTxcbiAgICAgIFN0YXRlLFxuICAgICAgUGFyYW1zLFxuICAgICAgRXhwb3J0cyxcbiAgICAgIFN0b3JlVHlwZSxcbiAgICAgIFByb21pc2VUeXBlXG4gICAgPixcbiAgICBfY29uZmlnPzogQXRvbUNvbmZpZzxTdGF0ZT5cbiAgKSB7XG4gICAgc3VwZXIoXG4gICAgICBrZXksXG4gICAgICAoLi4ucGFyYW1zOiBQYXJhbXMpID0+IHN0YXRlRmFjdG9yeShpbmplY3RBdG9tR2V0dGVycygpLCAuLi5wYXJhbXMpLFxuICAgICAgX2NvbmZpZ1xuICAgIClcblxuICAgIHRoaXMuX2dldCA9IHN0YXRlRmFjdG9yeVxuICB9XG5cbiAgcHVibGljIF9jcmVhdGVJbnN0YW5jZShcbiAgICBlY29zeXN0ZW06IEVjb3N5c3RlbSxcbiAgICBrZXlIYXNoOiBzdHJpbmcsXG4gICAgcGFyYW1zOiBQYXJhbXNcbiAgKTogQXRvbUluc3RhbmNlPFN0YXRlLCBQYXJhbXMsIEV4cG9ydHMsIFN0b3JlVHlwZSwgUHJvbWlzZVR5cGU+IHtcbiAgICByZXR1cm4gbmV3IEF0b21JbnN0YW5jZTxTdGF0ZSwgUGFyYW1zLCBFeHBvcnRzLCBTdG9yZVR5cGUsIFByb21pc2VUeXBlPihcbiAgICAgIGVjb3N5c3RlbSxcbiAgICAgIHRoaXMsXG4gICAgICBrZXlIYXNoLFxuICAgICAgcGFyYW1zXG4gICAgKVxuICB9XG5cbiAgcHVibGljIGdldEtleUhhc2goZWNvc3lzdGVtOiBFY29zeXN0ZW0sIHBhcmFtcz86IFBhcmFtcykge1xuICAgIGNvbnN0IGJhc2UgPSB0aGlzLmtleVxuXG4gICAgaWYgKCFwYXJhbXM/Lmxlbmd0aCkgcmV0dXJuIGJhc2VcblxuICAgIHJldHVybiBgJHtiYXNlfS0ke2Vjb3N5c3RlbS5faWRHZW5lcmF0b3IuaGFzaFBhcmFtcyhcbiAgICAgIHBhcmFtcyxcbiAgICAgIGVjb3N5c3RlbS5jb21wbGV4UGFyYW1zXG4gICAgKX1gXG4gIH1cblxuICBwdWJsaWMgb3ZlcnJpZGUoXG4gICAgbmV3R2V0PzogSW9uU3RhdGVGYWN0b3J5PFN0YXRlLCBQYXJhbXMsIEV4cG9ydHMsIFN0b3JlVHlwZSwgUHJvbWlzZVR5cGU+XG4gICkge1xuICAgIHJldHVybiBpb24odGhpcy5rZXksIG5ld0dldCB8fCB0aGlzLl9nZXQsIHRoaXMuX2NvbmZpZylcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgQWN0aW9uRmFjdG9yeUFjdGlvblR5cGUsXG4gIEFjdGlvbkZhY3RvcnlQYXlsb2FkVHlwZSxcbiAgY3JlYXRlU3RvcmUsXG4gIFN0b3JlLFxufSBmcm9tICdAemVkdXgvY29yZSdcbmltcG9ydCB7IEVjb3N5c3RlbSB9IGZyb20gJy4vRWNvc3lzdGVtJ1xuaW1wb3J0IHsgTWF5YmVDbGVhbnVwIH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBwbHVnaW5BY3Rpb25zIH0gZnJvbSAnLi4vdXRpbHMvcGx1Z2luLWFjdGlvbnMnXG5cbnR5cGUgVmFsdWVzT2Y8UmVjIGV4dGVuZHMgUmVjb3JkPGFueSwgYW55Pj4gPSBSZWMgZXh0ZW5kcyBSZWNvcmQ8YW55LCBpbmZlciBUPlxuICA/IFRcbiAgOiBuZXZlclxuXG5leHBvcnQgdHlwZSBNb2QgPSBrZXlvZiB0eXBlb2YgcGx1Z2luQWN0aW9uc1xuZXhwb3J0IHR5cGUgTW9kQWN0aW9uID0gQWN0aW9uRmFjdG9yeUFjdGlvblR5cGU8VmFsdWVzT2Y8dHlwZW9mIHBsdWdpbkFjdGlvbnM+PlxuZXhwb3J0IHR5cGUgTW9kUGF5bG9hZE1hcCA9IHtcbiAgW0sgaW4gTW9kXTogQWN0aW9uRmFjdG9yeVBheWxvYWRUeXBlPHR5cGVvZiBwbHVnaW5BY3Rpb25zW0tdPlxufVxuXG5leHBvcnQgY2xhc3MgWmVkdXhQbHVnaW4ge1xuICAvKipcbiAgICogVGhlc2UgYWN0aW9ucyBzaG91bGQgb25seSBiZSBkaXNwYXRjaGVkIHRvIGFuIGVjb3N5c3RlbSdzIG1vZEJ1c1xuICAgKiBzdG9yZSwgc28gdGhleSBkb24ndCBuZWVkIHByZWZpeGVzXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFjdGlvbnMgPSBwbHVnaW5BY3Rpb25zXG5cbiAgcHVibGljIG1vZFN0b3JlOiBTdG9yZTxNb2RbXT5cbiAgcHVibGljIHJlZ2lzdGVyRWNvc3lzdGVtOiAoZWNvc3lzdGVtOiBFY29zeXN0ZW0pID0+IE1heWJlQ2xlYW51cFxuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBpbml0aWFsTW9kcyA9IFtdLFxuICAgIHJlZ2lzdGVyRWNvc3lzdGVtLFxuICB9OiB7XG4gICAgaW5pdGlhbE1vZHM/OiBNb2RbXVxuICAgIHJlZ2lzdGVyRWNvc3lzdGVtPzogKGVjb3N5c3RlbTogRWNvc3lzdGVtKSA9PiBNYXliZUNsZWFudXBcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5tb2RTdG9yZSA9IGNyZWF0ZVN0b3JlKG51bGwsIGluaXRpYWxNb2RzKVxuXG4gICAgdGhpcy5yZWdpc3RlckVjb3N5c3RlbSA9IHJlZ2lzdGVyRWNvc3lzdGVtIHx8ICgoKSA9PiB7fSlcbiAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9hdG9tcy9Jb24nIC8vIHRoaXMgLi4gaGFzIHRvIGJlIGltcG9ydGVkIGJlZm9yZSBBdG9tIG9yIHRoZSBidWlsZCBicmVha3MgOmV4cGxvZGluZ19oZWFkOlxuZXhwb3J0ICogZnJvbSAnLi9hdG9tcy9BdG9tJ1xuZXhwb3J0ICogZnJvbSAnLi9hdG9tcy9BdG9tQmFzZSdcbmV4cG9ydCAqIGZyb20gJy4vaW5zdGFuY2VzL0F0b21JbnN0YW5jZSdcbmV4cG9ydCAqIGZyb20gJy4vaW5zdGFuY2VzL0F0b21JbnN0YW5jZUJhc2UnXG5leHBvcnQgKiBmcm9tICcuL0F0b21BcGknXG5leHBvcnQgKiBmcm9tICcuL0Vjb3N5c3RlbSdcbmV4cG9ydCAqIGZyb20gJy4vWmVkdXhQbHVnaW4nXG4iLCJpbXBvcnQgUmVhY3QsIHsgRkMsIFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQW55QXRvbSB9IGZyb20gJy4uL3R5cGVzJ1xuaW1wb3J0IHsgQXRvbUluc3RhbmNlQmFzZSB9IGZyb20gJy4uL2NsYXNzZXMnXG5pbXBvcnQgeyB1c2VFY29zeXN0ZW0gfSBmcm9tICcuLi9ob29rcydcblxuZXhwb3J0IGNvbnN0IEF0b21JbnN0YW5jZVByb3ZpZGVyOiBGQzxcbiAgfCB7XG4gICAgICBjaGlsZHJlbj86IFJlYWN0Tm9kZVxuICAgICAgaW5zdGFuY2U6IEF0b21JbnN0YW5jZUJhc2U8YW55LCBhbnksIEFueUF0b20+XG4gICAgICBpbnN0YW5jZXM/OiB1bmRlZmluZWRcbiAgICB9XG4gIHwge1xuICAgICAgY2hpbGRyZW4/OiBSZWFjdE5vZGVcbiAgICAgIGluc3RhbmNlPzogdW5kZWZpbmVkXG4gICAgICBpbnN0YW5jZXM6IEF0b21JbnN0YW5jZUJhc2U8YW55LCBhbnksIEFueUF0b20+W11cbiAgICB9XG4+ID0gKHsgY2hpbGRyZW4sIGluc3RhbmNlLCBpbnN0YW5jZXMgfSkgPT4ge1xuICBjb25zdCBlY29zeXN0ZW0gPSB1c2VFY29zeXN0ZW0oKVxuXG4gIGlmIChERVYgJiYgIWluc3RhbmNlICYmICFpbnN0YW5jZXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnWmVkdXg6IEF0b21JbnN0YW5jZVByb3ZpZGVyIHJlcXVpcmVzIGVpdGhlciBhbiBgaW5zdGFuY2VgIG9yIGBpbnN0YW5jZXNgIHByb3AnXG4gICAgKVxuICB9XG5cbiAgY29uc3QgYWxsSW5zdGFuY2VzID1cbiAgICBpbnN0YW5jZXMgfHwgKFtpbnN0YW5jZV0gYXMgQXRvbUluc3RhbmNlQmFzZTxhbnksIGFueSwgQW55QXRvbT5bXSlcblxuICBpZiAoYWxsSW5zdGFuY2VzLmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSBlY29zeXN0ZW0uX2dldFJlYWN0Q29udGV4dChhbGxJbnN0YW5jZXNbMF0uYXRvbSlcblxuICAgIHJldHVybiAoXG4gICAgICA8Y29udGV4dC5Qcm92aWRlciB2YWx1ZT17YWxsSW5zdGFuY2VzWzBdfT57Y2hpbGRyZW59PC9jb250ZXh0LlByb3ZpZGVyPlxuICAgIClcbiAgfVxuXG4gIGNvbnN0IFtwYXJlbnRJbnN0YW5jZSwgLi4uY2hpbGRJbnN0YW5jZXNdID0gYWxsSW5zdGFuY2VzXG4gIGNvbnN0IGNvbnRleHQgPSBlY29zeXN0ZW0uX2dldFJlYWN0Q29udGV4dChwYXJlbnRJbnN0YW5jZS5hdG9tKVxuXG4gIHJldHVybiAoXG4gICAgPGNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3BhcmVudEluc3RhbmNlfT5cbiAgICAgIDxBdG9tSW5zdGFuY2VQcm92aWRlciBpbnN0YW5jZXM9e2NoaWxkSW5zdGFuY2VzfT5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9BdG9tSW5zdGFuY2VQcm92aWRlcj5cbiAgICA8L2NvbnRleHQuUHJvdmlkZXI+XG4gIClcbn1cbiIsImltcG9ydCBSZWFjdCwgeyBSZWFjdE5vZGUsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBFY29zeXN0ZW0gfSBmcm9tICcuLi9jbGFzc2VzL0Vjb3N5c3RlbSdcbmltcG9ydCB7IGNyZWF0ZUVjb3N5c3RlbSB9IGZyb20gJy4uL2ZhY3Rvcmllcy9jcmVhdGVFY29zeXN0ZW0nXG5pbXBvcnQgeyBFY29zeXN0ZW1Db25maWcgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IGVjb3N5c3RlbUNvbnRleHQgfSBmcm9tICcuLi91dGlscy9nZW5lcmFsJ1xuXG4vKipcbiAqIEVjb3N5c3RlbVByb3ZpZGVyXG4gKlxuICogQ3JlYXRlcyBhbiBhdG9tIGVjb3N5c3RlbS4gVGhlIGJlaGF2aW9yIG9mIGF0b21zIGluc2lkZSB0aGlzIEVjb3N5c3RlbVByb3ZpZGVyIGNhblxuICogYmUgY29uZmlndXJlZCB3aXRoIHByb3BzIHBhc3NlZCBoZXJlLlxuICovXG5leHBvcnQgY29uc3QgRWNvc3lzdGVtUHJvdmlkZXIgPSAoe1xuICBjaGlsZHJlbixcbiAgZWNvc3lzdGVtOiBwYXNzZWRFY29zeXN0ZW0sXG4gIC4uLmVjb3N5c3RlbUNvbmZpZ1xufTpcbiAgfCAoUGFydGlhbDx7IFtrIGluIGtleW9mIEVjb3N5c3RlbUNvbmZpZ106IHVuZGVmaW5lZCB9PiAmIHtcbiAgICAgIGNoaWxkcmVuPzogUmVhY3ROb2RlXG4gICAgICBlY29zeXN0ZW0/OiBFY29zeXN0ZW1cbiAgICB9KVxuICB8IChQYXJ0aWFsPEVjb3N5c3RlbUNvbmZpZz4gJiB7XG4gICAgICBjaGlsZHJlbj86IFJlYWN0Tm9kZVxuICAgICAgZWNvc3lzdGVtPzogdW5kZWZpbmVkXG4gICAgfSkpID0+IHtcbiAgY29uc3QgW3N1YnNjcmliZSwgZ2V0U25hcHNob3RdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgcmVzb2x2ZWRFY29zeXN0ZW0gPVxuICAgICAgcGFzc2VkRWNvc3lzdGVtIHx8XG4gICAgICBjcmVhdGVFY29zeXN0ZW0oe1xuICAgICAgICBkZXN0cm95T25Vbm1vdW50OiB0cnVlLFxuICAgICAgICAuLi5lY29zeXN0ZW1Db25maWcsXG4gICAgICB9KVxuXG4gICAgcmV0dXJuIFtcbiAgICAgICgpID0+IHtcbiAgICAgICAgcmVzb2x2ZWRFY29zeXN0ZW0uX2luY3JlbWVudFJlZkNvdW50KClcblxuICAgICAgICByZXR1cm4gKCkgPT4gcmVzb2x2ZWRFY29zeXN0ZW0uX2RlY3JlbWVudFJlZkNvdW50KClcbiAgICAgIH0sXG4gICAgICAoKSA9PiByZXNvbHZlZEVjb3N5c3RlbSxcbiAgICBdXG4gIH0sIFtlY29zeXN0ZW1Db25maWcuaWQsIHBhc3NlZEVjb3N5c3RlbV0pIC8vIGRvbid0IHBhc3Mgb3RoZXIgdmFsczsganVzdCBnZXQgc25hcHNob3Qgd2hlbiB0aGVzZSBjaGFuZ2VcblxuICBjb25zdCBlY29zeXN0ZW0gPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTbmFwc2hvdClcblxuICByZXR1cm4gKFxuICAgIDxlY29zeXN0ZW1Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXtlY29zeXN0ZW0uaWR9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvZWNvc3lzdGVtQ29udGV4dC5Qcm92aWRlcj5cbiAgKVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9BdG9tSW5zdGFuY2VQcm92aWRlcidcbmV4cG9ydCAqIGZyb20gJy4vRWNvc3lzdGVtUHJvdmlkZXInXG4iLCJleHBvcnQgKiBmcm9tICcuL2FwaSdcbmV4cG9ydCAqIGZyb20gJy4vYXRvbSdcbmV4cG9ydCAqIGZyb20gJy4vY3JlYXRlRWNvc3lzdGVtJ1xuZXhwb3J0ICogZnJvbSAnLi9jcmVhdGVJbmplY3RvcidcbmV4cG9ydCAqIGZyb20gJy4vaW9uJ1xuIiwiaW1wb3J0IHsgaXMgfSBmcm9tICdAemVkdXgvY29yZSdcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IEF0b21JbnN0YW5jZUJhc2UgfSBmcm9tICcuLi9jbGFzc2VzJ1xuaW1wb3J0IHsgQW55QXRvbSwgQXRvbUluc3RhbmNlVHlwZSwgQXRvbVBhcmFtc1R5cGUgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IHVzZUVjb3N5c3RlbSB9IGZyb20gJy4vdXNlRWNvc3lzdGVtJ1xuXG5leHBvcnQgY29uc3QgdXNlQXRvbUNvbnN1bWVyOiB7XG4gIDxBIGV4dGVuZHMgQW55QXRvbT4oYXRvbTogQSk6IEF0b21JbnN0YW5jZVR5cGU8QT4gfCB1bmRlZmluZWRcblxuICA8QSBleHRlbmRzIEFueUF0b20+KFxuICAgIGF0b206IEEsXG4gICAgZGVmYXVsdFBhcmFtczogQXRvbVBhcmFtc1R5cGU8QT5cbiAgKTogQXRvbUluc3RhbmNlVHlwZTxBPlxuXG4gIDxBIGV4dGVuZHMgQW55QXRvbT4oYXRvbTogQSwgdGhyb3dJZk5vdFByb3ZpZGVkOiBib29sZWFuKTogQXRvbUluc3RhbmNlVHlwZTxBPlxufSA9IDxBIGV4dGVuZHMgQW55QXRvbT4oXG4gIGF0b206IEEsXG4gIGRlZmF1bHRQYXJhbXM/OiBBdG9tUGFyYW1zVHlwZTxBPiB8IGJvb2xlYW5cbikgPT4ge1xuICBjb25zdCBlY29zeXN0ZW0gPSB1c2VFY29zeXN0ZW0oKVxuICBjb25zdCBpbnN0YW5jZSA9IHVzZUNvbnRleHQoZWNvc3lzdGVtLl9nZXRSZWFjdENvbnRleHQoYXRvbSkpXG5cbiAgaWYgKCFkZWZhdWx0UGFyYW1zIHx8IGlzKGluc3RhbmNlLCBBdG9tSW5zdGFuY2VCYXNlKSkge1xuICAgIGlmIChERVYgJiYgKGluc3RhbmNlIGFzIEF0b21JbnN0YW5jZVR5cGU8QT4pLmFjdGl2ZVN0YXRlID09PSAnRGVzdHJveWVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWmVkdXg6IHVzZUF0b21Db25zdW1lciAtIEEgZGVzdHJveWVkIGF0b20gaW5zdGFuY2Ugd2FzIHByb3ZpZGVkIHdpdGgga2V5IFwiJHtcbiAgICAgICAgICAoaW5zdGFuY2UgYXMgQXRvbUluc3RhbmNlVHlwZTxBPikua2V5SGFzaFxuICAgICAgICB9XCIuIFRoaXMgaXMgbm90IHN1cHBvcnRlZC4gUHJvdmlkZSBhbiBhY3RpdmUgYXRvbSBpbnN0YW5jZSBpbnN0ZWFkLmBcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2UgYXMgQXRvbUluc3RhbmNlVHlwZTxBPlxuICB9XG5cbiAgaWYgKHR5cGVvZiBkZWZhdWx0UGFyYW1zID09PSAnYm9vbGVhbicpIHtcbiAgICBpZiAoREVWKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXG4gICAgICAgIGBaZWR1eDogdXNlQXRvbUNvbnN1bWVyIC0gTm8gYXRvbSBpbnN0YW5jZSB3YXMgcHJvdmlkZWQgZm9yIGF0b20gXCIke2F0b20ua2V5fVwiLmBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluc3RhbmNlIGFzIEF0b21JbnN0YW5jZVR5cGU8QT5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWNvc3lzdGVtLmdldEluc3RhbmNlKGF0b20sIGRlZmF1bHRQYXJhbXMpXG59XG4iLCJpbXBvcnQgeyBBdG9tU2VsZWN0b3JDb25maWcsIEF0b21TZWxlY3Rvck9yQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBNdXRhYmxlUmVmT2JqZWN0LCB1c2VNZW1vLCB1c2VSZWYsIHVzZVN5bmNFeHRlcm5hbFN0b3JlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBkZXN0cm95ZWQsIEV4dGVybmFsLCBoYXZlRGVwc0NoYW5nZWQgfSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IHVzZUVjb3N5c3RlbSB9IGZyb20gJy4vdXNlRWNvc3lzdGVtJ1xuaW1wb3J0IHsgdXNlUmVhY3RDb21wb25lbnRJZCB9IGZyb20gJy4vdXNlUmVhY3RDb21wb25lbnRJZCdcbmltcG9ydCB7IEVjb3N5c3RlbSB9IGZyb20gJy4uL2NsYXNzZXMvRWNvc3lzdGVtJ1xuaW1wb3J0IHsgU2VsZWN0b3JDYWNoZUl0ZW0gfSBmcm9tICcuLi9jbGFzc2VzL1NlbGVjdG9yQ2FjaGUnXG5cbmNvbnN0IGdsb2IgPSAoKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWxUaGlzKSB8fCB7fSkgYXMgYW55XG5jb25zdCBJTlZBTElEQVRFX1JFQUNUID0gYElOVkFMSURBVEVfUkVBQ1RfJHtNYXRoLnJhbmRvbSgpfWBcbmNvbnN0IE9QRVJBVElPTiA9ICd1c2VBdG9tU2VsZWN0b3InXG5cbi8qKlxuICogSWYgd2UgZGV0ZWN0IGFuIGlubGluZSBzZWxlY3RvciB1c2luZyB0aGVzZSBub3QtZXhhY3RseS1jaGVhcCBjaGVja3MsIHdlIGNhblxuICogcHJldmVudCB0aGUgZ3JhcGggZnJvbSBjaGFuZ2luZyBieSBzd2FwcGluZyBvdXQgaXRzIHJlZmVyZW5jZSBhbmRcbiAqIGludmFsaWRhdGluZyB0aGUgY2FjaGUuIEl0J3MgdW5mb3J0dW5hdGVseSBwcm9iYWJseSBub3QgYSBnb29kIHRyYWRlLW9mZlxuICogcGVyZm9ybWFuY2Utd2lzZSwgYnV0IGl0J3MgbmVjZXNzYXJ5IHRvIHByZXZlbnQgUmVhY3QncyByZW5kZXItbG9vcC1vZi1kZWF0aFxuICogaW4gYHVzZVN5bmNFeHRlcm5hbFN0b3JlYCB3aGVuIGJvdGggdGhlIHN1YnNjcmliZSByZWZlcmVuY2UgYW5kIHRoZSBzZWxlY3RvclxuICogcmVzdWx0IGNoYW5nZSBldmVyeSByZW5kZXIuIFNpbXBsZSByZXByb2R1Y3Rpb246XG4gKlxuICogYGBgdHN4XG4gKiAvLyBzdWJzY3JpYmUgcmVmIGFuZCBnZXRTbmFwc2hvdCByZXN1bHQgcmVmIGNoYW5nZSBldmVyeSByZW5kZXIgPSBkZWF0aFxuICogdXNlU3luY0V4dGVybmFsU3RvcmUoKCkgPT4gKCkgPT4ge30sICgpID0+ICh7fSkpXG4gKiBgYGBcbiAqXG4gKiBJdCdzIGFsc28gYmV0dGVyIGRldi1YIHdoZW4gdGhlIGdyYXBoIGRvZXNuJ3QgY2hhbmdlIHVubmVjZXNzYXJpbHkuXG4gKlxuICogSW5saW5lIHNlbGVjdG9ycyB0aGF0IGhhdmVuJ3QgX2FjdHVhbGx5XyBjaGFuZ2VkIG11c3QgYmUgZXhhY3RseSB0aGUgc2FtZSxcbiAqIHN0cmluZ2lmaWVkLiBUaGUgc3RyaW5naWZpZWQgYHJlc3VsdHNDb21wYXJhdG9yYCBtdXN0IGFsc28gYmUgZXhhY3RseSB0aGVcbiAqIHNhbWUuIGBhcmdzQ29tcGFyYXRvcmAgZG9lc24ndCBtYXR0ZXIgc2luY2UgaXQgb25seSBydW5zIGF0IHRoZSBob29rIGxldmVsLlxuICpcbiAqIEltcG9ydGFudGx5LCBhbiBpbmxpbmUgc2VsZWN0b3IncyBncmFwaCBub2RlIG11c3QgaGF2ZSBleGFjdGx5IG9uZSBkZXBlbmRlbnRcbiAqIHRvbyAtIHRoZSBSZWFjdCBjb21wb25lbnQgdGhhdCBjYWxsZWQgYHVzZUF0b21TZWxlY3RvcihpbmxpbmVTZWxlY3RvcilgLlxuICovXG5jb25zdCBpc1JlZkRpZmZlcmVudCA9IChcbiAgZWNvc3lzdGVtOiBFY29zeXN0ZW0sXG4gIG5ld1NlbGVjdG9yOiBBdG9tU2VsZWN0b3JPckNvbmZpZzxhbnksIGFueT4sXG4gIGNhY2hlUmVmOiBNdXRhYmxlUmVmT2JqZWN0PFNlbGVjdG9yQ2FjaGVJdGVtPGFueSwgYW55PiB8IHVuZGVmaW5lZD5cbikgPT4ge1xuICBpZiAoIWNhY2hlUmVmLmN1cnJlbnQpIHJldHVybiB0cnVlXG5cbiAgY29uc3Qgb2xkU2VsZWN0b3IgPSBjYWNoZVJlZi5jdXJyZW50LnNlbGVjdG9yUmVmXG5cbiAgaWYgKG5ld1NlbGVjdG9yID09PSBvbGRTZWxlY3RvcikgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3QgZGVwZW5kZW50cyA9XG4gICAgZWNvc3lzdGVtLl9ncmFwaC5ub2Rlc1tjYWNoZVJlZi5jdXJyZW50LmNhY2hlS2V5XT8uZGVwZW5kZW50c1xuXG4gIGlmIChkZXBlbmRlbnRzICYmIE9iamVjdC5rZXlzKGRlcGVuZGVudHMpLmxlbmd0aCAhPT0gMSkgcmV0dXJuIHRydWVcblxuICBjb25zdCBuZXdJc0Z1bmN0aW9uID0gdHlwZW9mIG5ld1NlbGVjdG9yID09PSAnZnVuY3Rpb24nXG4gIGNvbnN0IG9sZElzRnVuY3Rpb24gPSB0eXBlb2Ygb2xkU2VsZWN0b3IgPT09ICdmdW5jdGlvbidcblxuICBpZiAobmV3SXNGdW5jdGlvbiAhPT0gb2xkSXNGdW5jdGlvbikgcmV0dXJuIHRydWVcblxuICBjb25zdCBuZXdLZXkgPSBlY29zeXN0ZW0uc2VsZWN0b3JDYWNoZS5fZ2V0SWRlYWxDYWNoZUtleShuZXdTZWxlY3RvcilcbiAgY29uc3Qgb2xkS2V5ID0gZWNvc3lzdGVtLnNlbGVjdG9yQ2FjaGUuX2dldElkZWFsQ2FjaGVLZXkob2xkU2VsZWN0b3IpXG5cbiAgaWYgKG5ld0tleSAhPT0gb2xkS2V5KSByZXR1cm4gdHJ1ZVxuXG4gIGlmIChcbiAgICAhbmV3SXNGdW5jdGlvbiAmJlxuICAgICFvbGRJc0Z1bmN0aW9uICYmXG4gICAgbmV3U2VsZWN0b3IucmVzdWx0c0NvbXBhcmF0b3IgIT09IG9sZFNlbGVjdG9yLnJlc3VsdHNDb21wYXJhdG9yXG4gICkge1xuICAgIGNvbnN0IG5ld1Jlc3VsdHNDb21wYXJhdG9yU3RyID1cbiAgICAgIG5ld1NlbGVjdG9yLnJlc3VsdHNDb21wYXJhdG9yPy50b1N0cmluZygpIHx8ICcnXG5cbiAgICBjb25zdCBvbGRSZXN1bHRzQ29tcGFyYXRvclN0ciA9XG4gICAgICBvbGRTZWxlY3Rvci5yZXN1bHRzQ29tcGFyYXRvcj8udG9TdHJpbmcoKSB8fCAnJ1xuXG4gICAgaWYgKG5ld1Jlc3VsdHNDb21wYXJhdG9yU3RyICE9PSBvbGRSZXN1bHRzQ29tcGFyYXRvclN0cikgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIGxhc3QgdGhpbmcgdG8gY29tcGFyZSBpcyB0aGUgc2VsZWN0b3JzIHRoZW1zZWx2ZXNcbiAgaWYgKG5ld0lzRnVuY3Rpb24gJiYgb2xkSXNGdW5jdGlvbikge1xuICAgIHJldHVybiBuZXdTZWxlY3Rvci50b1N0cmluZygpICE9PSBvbGRTZWxlY3Rvci50b1N0cmluZygpXG4gIH1cblxuICAvLyB3ZSBrbm93IHRoZXkncmUgYm90aCBvYmplY3RzIGF0IHRoaXMgcG9pbnRcbiAgaWYgKFxuICAgIChuZXdTZWxlY3RvciBhcyBBdG9tU2VsZWN0b3JDb25maWcpLnNlbGVjdG9yID09PVxuICAgIChvbGRTZWxlY3RvciBhcyBBdG9tU2VsZWN0b3JDb25maWcpLnNlbGVjdG9yXG4gICkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgbmV3UmVmU3RyID0gKG5ld1NlbGVjdG9yIGFzIEF0b21TZWxlY3RvckNvbmZpZykuc2VsZWN0b3IudG9TdHJpbmcoKVxuICBjb25zdCBvbGRSZWZTdHIgPSAob2xkU2VsZWN0b3IgYXMgQXRvbVNlbGVjdG9yQ29uZmlnKS5zZWxlY3Rvci50b1N0cmluZygpXG5cbiAgcmV0dXJuIG5ld1JlZlN0ciAhPT0gb2xkUmVmU3RyXG59XG5cbi8qKlxuICogR2V0IHRoZSByZXN1bHQgb2YgcnVubmluZyBhbiBBdG9tU2VsZWN0b3IgaW4gdGhlIGN1cnJlbnQgZWNvc3lzdGVtLlxuICpcbiAqIElmIHRoZSBleGFjdCBzZWxlY3RvciBmdW5jdGlvbiAob3Igb2JqZWN0IGlmIGl0J3MgYW4gQXRvbVNlbGVjdG9yQ29uZmlnXG4gKiBvYmplY3QpIHJlZmVyZW5jZSArIHBhcmFtcyBjb21ibyBoYXMgYmVlbiB1c2VkIGluIHRoaXMgZWNvc3lzdGVtIGJlZm9yZSxcbiAqIHJldHVybiB0aGUgY2FjaGVkIHJlc3VsdC5cbiAqXG4gKiBSZWdpc3RlciBhIGR5bmFtaWMgZ3JhcGggZGVwZW5kZW5jeSBiZXR3ZWVuIHRoaXMgUmVhY3QgY29tcG9uZW50IChhcyBhIG5ld1xuICogZXh0ZXJuYWwgbm9kZSkgYW5kIHRoZSBBdG9tU2VsZWN0b3IuXG4gKi9cbmV4cG9ydCBjb25zdCB1c2VBdG9tU2VsZWN0b3IgPSA8VCwgQXJncyBleHRlbmRzIGFueVtdPihcbiAgc2VsZWN0b3JPckNvbmZpZzogQXRvbVNlbGVjdG9yT3JDb25maWc8VCwgQXJncz4sXG4gIC4uLmFyZ3M6IEFyZ3Ncbik6IFQgPT4ge1xuICBjb25zdCBlY29zeXN0ZW0gPSB1c2VFY29zeXN0ZW0oKVxuICBjb25zdCBkZXBlbmRlbnRLZXkgPSB1c2VSZWFjdENvbXBvbmVudElkKClcbiAgY29uc3QgY2FjaGVSZWYgPSB1c2VSZWY8U2VsZWN0b3JDYWNoZUl0ZW08VCwgQXJncz4+KClcbiAgY29uc3Qgc2tpcFN0YXRlID0gdXNlUmVmPFQ+KClcbiAgY29uc3QgaXNDb25maWcgPSB0eXBlb2Ygc2VsZWN0b3JPckNvbmZpZyAhPT0gJ2Z1bmN0aW9uJ1xuXG4gIGNvbnN0IGFyZ3NDaGFuZ2VkID1cbiAgICBpc0NvbmZpZyAmJiBzZWxlY3Rvck9yQ29uZmlnLmFyZ3NDb21wYXJhdG9yICYmIGNhY2hlUmVmLmN1cnJlbnQ/LmFyZ3NcbiAgICAgID8gc2VsZWN0b3JPckNvbmZpZy5hcmdzQ29tcGFyYXRvcihhcmdzLCBjYWNoZVJlZi5jdXJyZW50LmFyZ3MpXG4gICAgICA6IGhhdmVEZXBzQ2hhbmdlZChjYWNoZVJlZi5jdXJyZW50Py5hcmdzLCBhcmdzKVxuXG4gIGNvbnN0IHJlc29sdmVkQXJncyA9IGFyZ3NDaGFuZ2VkXG4gICAgPyBhcmdzXG4gICAgOiBjYWNoZVJlZi5jdXJyZW50Py5hcmdzIHx8ICgoW10gYXMgdW5rbm93bikgYXMgQXJncylcblxuICBjb25zdCBoYXNSZWZDaGFuZ2VkID0gc2VsZWN0b3JPckNvbmZpZyAhPT0gY2FjaGVSZWYuY3VycmVudD8uc2VsZWN0b3JSZWZcbiAgY29uc3QgaXNEaWZmZXJlbnQgPVxuICAgIGFyZ3NDaGFuZ2VkIHx8IGlzUmVmRGlmZmVyZW50KGVjb3N5c3RlbSwgc2VsZWN0b3JPckNvbmZpZywgY2FjaGVSZWYpXG5cbiAgaWYgKGlzRGlmZmVyZW50IHx8ICFjYWNoZVJlZi5jdXJyZW50KSB7XG4gICAgLy8geWVzLCB0aGlzIG11dGF0aW9uIGlzIGZpbmVcbiAgICBjYWNoZVJlZi5jdXJyZW50ID0gZWNvc3lzdGVtLnNlbGVjdG9yQ2FjaGUuZ2V0Q2FjaGUoXG4gICAgICBzZWxlY3Rvck9yQ29uZmlnLFxuICAgICAgcmVzb2x2ZWRBcmdzXG4gICAgKVxuICB9XG5cbiAgY29uc3QgY2FjaGUgPSBjYWNoZVJlZi5jdXJyZW50IGFzIFNlbGVjdG9yQ2FjaGVJdGVtPFQsIEFyZ3M+XG5cbiAgY29uc3QgW3N1YnNjcmliZSwgZ2V0U25hcHNob3RdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IGlzSW52YWxpZGF0ZWQgPSBmYWxzZVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIChvblN0b3JlQ2hhbmdlOiAoKSA9PiB2b2lkKSA9PiB7XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gZmlyZSBhbiBleHRyYSB1cGRhdGUgb24gc3Vic2NyaWJlIGluIHRlc3QgZW52cyBiZWNhdXNlXG4gICAgICAgIC8vIHRoZXJlJ3MgYSBidWcgaW4gUmVhY3QgKGJ1dCBvbmx5IGluIHRlc3QgZW52aXJvbm1lbnRzKSB3aGVyZVxuICAgICAgICAvLyB1c2VFZmZlY3RzIGluIGNoaWxkIGNvbXBvbmVudHMgcnVuIGJlZm9yZSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVxuICAgICAgICAvLyBzdWJzY3JpYmUgaXMgY2FsbGVkIGluIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICAgICAgICBpZiAoZ2xvYi5JU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQpIG9uU3RvcmVDaGFuZ2UoKVxuXG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBpZGVtcG90ZW50XG4gICAgICAgIGlmICghZWNvc3lzdGVtLl9ncmFwaC5ub2Rlc1tjYWNoZS5jYWNoZUtleV0/LmRlcGVuZGVudHNbZGVwZW5kZW50S2V5XSkge1xuICAgICAgICAgIC8vIFJlYWN0IGNhbiB1bm1vdW50IG90aGVyIGNvbXBvbmVudHMgYmVmb3JlIGNhbGxpbmcgdGhpcyBzdWJzY3JpYmVcbiAgICAgICAgICAvLyBmdW5jdGlvbiBidXQgYWZ0ZXIgd2UgZ290IHRoZSBjYWNoZSBhYm92ZS4gUmUtZ2V0IHRoZSBjYWNoZVxuICAgICAgICAgIC8vIGlmIHN1Y2ggdW5tb3VudGluZ3MgZGVzdHJveWVkIGl0IGluIHRoZSBtZWFudGltZTpcbiAgICAgICAgICBpZiAoY2FjaGUuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIDsoY2FjaGVSZWYuY3VycmVudCBhcyBhbnkpID0gZGVzdHJveWVkXG4gICAgICAgICAgICBpc0ludmFsaWRhdGVkID0gdHJ1ZVxuXG4gICAgICAgICAgICBvblN0b3JlQ2hhbmdlKClcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHt9IC8vIGxldCB0aGUgbmV4dCByZW5kZXIgcmVnaXN0ZXIgdGhlIGdyYXBoIGVkZ2VcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlY29zeXN0ZW0uX2dyYXBoLmFkZEVkZ2UoXG4gICAgICAgICAgICBkZXBlbmRlbnRLZXksXG4gICAgICAgICAgICBjYWNoZS5jYWNoZUtleSxcbiAgICAgICAgICAgIE9QRVJBVElPTixcbiAgICAgICAgICAgIEV4dGVybmFsLFxuICAgICAgICAgICAgKHNpZ25hbCwgbmV3U3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSBza2lwU3RhdGUuY3VycmVudCkgcmV0dXJuXG4gICAgICAgICAgICAgIGlmIChzaWduYWwgPT09ICdEZXN0cm95ZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gc2VlIGNvbW1lbnQgaW4gdXNlQXRvbUluc3RhbmNlIGFib3V0IHdoeSByZXR1cm5pbmdcbiAgICAgICAgICAgICAgICAvLyBhIG5vbnNlbnNlIHZhbHVlIGZyb20gYGdldFNuYXBzaG90YCB3b3Jrc1xuICAgICAgICAgICAgICAgIDsoY2FjaGVSZWYuY3VycmVudCBhcyBhbnkpID0gZGVzdHJveWVkXG4gICAgICAgICAgICAgICAgaXNJbnZhbGlkYXRlZCA9IHRydWVcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9uU3RvcmVDaGFuZ2UoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgLy8gSSBkb24ndCB0aGluayB3ZSBuZWVkIHRvIHVuc2V0IGFueSBvZiB0aGUgY2FjaGUgcmVmcyBoZXJlXG4gICAgICAgICAgZWNvc3lzdGVtLl9ncmFwaC5yZW1vdmVFZGdlKGRlcGVuZGVudEtleSwgY2FjaGUuY2FjaGVLZXkpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoKSA9PiAoaXNJbnZhbGlkYXRlZCA/IElOVkFMSURBVEVfUkVBQ1QgOiBjYWNoZS5yZXN1bHQpLFxuICAgIF1cbiAgfSwgW2Vjb3N5c3RlbSwgY2FjaGVdKVxuXG4gIC8vIGlmIHJlZiBjaGFuZ2VkIGJ1dCBpcyBjbGVhcmx5IHRoZSBcInNhbWVcIiBzZWxlY3Rvciwgc3dhcCBvdXQgdGhlIHJlZiBhbmRcbiAgLy8gaW52YWxpZGF0ZSB0aGUgY2FjaGVcbiAgaWYgKGhhc1JlZkNoYW5nZWQgJiYgIWlzRGlmZmVyZW50KSB7XG4gICAgZWNvc3lzdGVtLnNlbGVjdG9yQ2FjaGUuX3N3YXBSZWZzKFxuICAgICAgY2FjaGUuc2VsZWN0b3JSZWYgYXMgQXRvbVNlbGVjdG9yT3JDb25maWc8YW55LCBhbnlbXT4sXG4gICAgICBzZWxlY3Rvck9yQ29uZmlnIGFzIEF0b21TZWxlY3Rvck9yQ29uZmlnPGFueSwgYW55W10+LFxuICAgICAgcmVzb2x2ZWRBcmdzXG4gICAgKVxuICAgIC8vIHByZXZlbnQgc3RhdGUgdXBkYXRlIGxvb3AgaWYgbmV3IHNlbGVjdG9yIHJlZiBqdXN0IHJldHVybmVkIGEgbmV3IHJlc3VsdDpcbiAgICBza2lwU3RhdGUuY3VycmVudCA9IGNhY2hlLnJlc3VsdFxuICB9XG5cbiAgcmV0dXJuIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNuYXBzaG90KSBhcyBUXG59XG4iLCJpbXBvcnQgeyBBdG9tSW5zdGFuY2UsIEF0b21CYXNlIH0gZnJvbSAnLi4vY2xhc3NlcydcbmltcG9ydCB7XG4gIEFueUF0b20sXG4gIEF0b21FeHBvcnRzVHlwZSxcbiAgQXRvbUluc3RhbmNlRXhwb3J0c1R5cGUsXG4gIEF0b21JbnN0YW5jZVN0YXRlVHlwZSxcbiAgQXRvbVBhcmFtc1R5cGUsXG4gIEF0b21TdGF0ZVR5cGUsXG4gIFN0YXRlSG9va1R1cGxlLFxuICBaZWR1eEhvb2tDb25maWcsXG59IGZyb20gJy4uL3R5cGVzJ1xuaW1wb3J0IHsgdXNlQXRvbUluc3RhbmNlIH0gZnJvbSAnLi91c2VBdG9tSW5zdGFuY2UnXG5cbmV4cG9ydCBjb25zdCB1c2VBdG9tU3RhdGU6IHtcbiAgPEEgZXh0ZW5kcyBBdG9tQmFzZTxhbnksIFtdLCBhbnksIGFueSwgYW55LCBhbnk+PihhdG9tOiBBKTogU3RhdGVIb29rVHVwbGU8XG4gICAgQXRvbVN0YXRlVHlwZTxBPixcbiAgICBBdG9tRXhwb3J0c1R5cGU8QT5cbiAgPlxuXG4gIDxBIGV4dGVuZHMgQW55QXRvbT4oXG4gICAgYXRvbTogQSxcbiAgICBwYXJhbXM6IEF0b21QYXJhbXNUeXBlPEE+LFxuICAgIGNvbmZpZz86IE9taXQ8WmVkdXhIb29rQ29uZmlnLCAnc3Vic2NyaWJlJz5cbiAgKTogU3RhdGVIb29rVHVwbGU8QXRvbVN0YXRlVHlwZTxBPiwgQXRvbUV4cG9ydHNUeXBlPEE+PlxuXG4gIDxBSSBleHRlbmRzIEF0b21JbnN0YW5jZTxhbnksIFsuLi5hbnldLCBhbnksIGFueSwgYW55Pj4oXG4gICAgaW5zdGFuY2U6IEFJLFxuICAgIHBhcmFtcz86IFtdLFxuICAgIGNvbmZpZz86IE9taXQ8WmVkdXhIb29rQ29uZmlnLCAnc3Vic2NyaWJlJz5cbiAgKTogU3RhdGVIb29rVHVwbGU8QXRvbUluc3RhbmNlU3RhdGVUeXBlPEFJPiwgQXRvbUluc3RhbmNlRXhwb3J0c1R5cGU8QUk+PlxufSA9IDxBIGV4dGVuZHMgQW55QXRvbT4oXG4gIGF0b206IEEsXG4gIHBhcmFtcz86IEF0b21QYXJhbXNUeXBlPEE+LFxuICBjb25maWc6IE9taXQ8WmVkdXhIb29rQ29uZmlnLCAnc3Vic2NyaWJlJz4gPSB7IG9wZXJhdGlvbjogJ3VzZUF0b21TdGF0ZScgfVxuKTogU3RhdGVIb29rVHVwbGU8QXRvbVN0YXRlVHlwZTxBPiwgQXRvbUV4cG9ydHNUeXBlPEE+PiA9PiB7XG4gIGNvbnN0IGluc3RhbmNlID0gdXNlQXRvbUluc3RhbmNlKGF0b20sIHBhcmFtcyBhcyBBdG9tUGFyYW1zVHlwZTxBPiwge1xuICAgIC4uLmNvbmZpZyxcbiAgICBzdWJzY3JpYmU6IHRydWUsXG4gIH0pXG5cbiAgcmV0dXJuIFtpbnN0YW5jZS5nZXRTdGF0ZSgpLCBpbnN0YW5jZS5faW5mdXNlZFNldHRlcl1cbn1cbiIsImltcG9ydCB7IEF0b21CYXNlLCBBdG9tSW5zdGFuY2VCYXNlIH0gZnJvbSAnLi4vY2xhc3NlcydcbmltcG9ydCB7XG4gIEF0b21JbnN0YW5jZVN0YXRlVHlwZSxcbiAgQXRvbVBhcmFtc1R5cGUsXG4gIEF0b21TdGF0ZVR5cGUsXG4gIFplZHV4SG9va0NvbmZpZyxcbn0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyB1c2VBdG9tSW5zdGFuY2UgfSBmcm9tICcuL3VzZUF0b21JbnN0YW5jZSdcblxuZXhwb3J0IGNvbnN0IHVzZUF0b21WYWx1ZToge1xuICA8QSBleHRlbmRzIEF0b21CYXNlPGFueSwgW10sIGFueSwgYW55LCBhbnksIGFueT4+KGF0b206IEEpOiBBdG9tU3RhdGVUeXBlPEE+XG5cbiAgPEEgZXh0ZW5kcyBBdG9tQmFzZTxhbnksIFsuLi5hbnldLCBhbnksIGFueSwgYW55LCBhbnk+PihcbiAgICBhdG9tOiBBLFxuICAgIHBhcmFtczogQXRvbVBhcmFtc1R5cGU8QT4sXG4gICAgY29uZmlnPzogT21pdDxaZWR1eEhvb2tDb25maWcsICdzdWJzY3JpYmUnPlxuICApOiBBdG9tU3RhdGVUeXBlPEE+XG5cbiAgPEFJIGV4dGVuZHMgQXRvbUluc3RhbmNlQmFzZTxhbnksIFsuLi5hbnldLCBhbnk+PihcbiAgICBpbnN0YW5jZTogQUksXG4gICAgcGFyYW1zPzogW10sXG4gICAgY29uZmlnPzogT21pdDxaZWR1eEhvb2tDb25maWcsICdzdWJzY3JpYmUnPlxuICApOiBBdG9tSW5zdGFuY2VTdGF0ZVR5cGU8QUk+XG59ID0gPEEgZXh0ZW5kcyBBdG9tQmFzZTxhbnksIFsuLi5hbnldLCBhbnksIGFueSwgYW55LCBhbnk+PihcbiAgYXRvbTogQSxcbiAgcGFyYW1zPzogQXRvbVBhcmFtc1R5cGU8QT4sXG4gIGNvbmZpZzogT21pdDxaZWR1eEhvb2tDb25maWcsICdzdWJzY3JpYmUnPiA9IHsgb3BlcmF0aW9uOiAndXNlQXRvbVZhbHVlJyB9XG4pID0+IHtcbiAgY29uc3QgaW5zdGFuY2UgPSB1c2VBdG9tSW5zdGFuY2UoYXRvbSwgcGFyYW1zIGFzIEF0b21QYXJhbXNUeXBlPEE+LCB7XG4gICAgLi4uY29uZmlnLFxuICAgIHN1YnNjcmliZTogdHJ1ZSxcbiAgfSlcblxuICByZXR1cm4gaW5zdGFuY2UuZ2V0U3RhdGUoKVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi91c2VBdG9tQ29uc3VtZXInXG5leHBvcnQgKiBmcm9tICcuL3VzZUF0b21JbnN0YW5jZSdcbmV4cG9ydCAqIGZyb20gJy4vdXNlQXRvbVNlbGVjdG9yJ1xuZXhwb3J0ICogZnJvbSAnLi91c2VBdG9tU3RhdGUnXG5leHBvcnQgKiBmcm9tICcuL3VzZUF0b21WYWx1ZSdcbmV4cG9ydCAqIGZyb20gJy4vdXNlRWNvc3lzdGVtJ1xuIiwiaW1wb3J0IHsgSW5qZWN0b3JEZXNjcmlwdG9yLCBwcmVmaXgsIFN0YXRpYyB9IGZyb20gJy4uL3V0aWxzJ1xuaW1wb3J0IHtcbiAgQW55QXRvbUluc3RhbmNlQmFzZSxcbiAgQXRvbUluc3RhbmNlVHlwZSxcbiAgQXRvbVBhcmFtc1R5cGUsXG4gIEluamVjdEF0b21JbnN0YW5jZUNvbmZpZyxcbiAgUGFydGlhbEF0b21JbnN0YW5jZSxcbn0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBBdG9tQmFzZSwgQXRvbUluc3RhbmNlQmFzZSB9IGZyb20gJy4uL2NsYXNzZXMnXG5pbXBvcnQgeyBjcmVhdGVJbmplY3RvciB9IGZyb20gJy4uL2ZhY3RvcmllcydcblxuY29uc3QgZGVmYXVsdE9wZXJhdGlvbiA9ICdpbmplY3RBdG9tSW5zdGFuY2UnXG5cbi8qKlxuICogaW5qZWN0QXRvbUluc3RhbmNlXG4gKlxuICogQ3JlYXRlcyBhbiBhdG9tIGluc3RhbmNlIGZvciB0aGUgcGFzc2VkIGF0b20gYmFzZWQgb24gdGhlIHBhc3NlZCBwYXJhbXMuIElmXG4gKiBhbiBpbnN0YW5jZSBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQgZm9yIHRoZSBwYXNzZWQgcGFyYW1zLCByZXVzZXMgdGhlXG4gKiBleGlzdGluZyBpbnN0YW5jZS5cbiAqXG4gKiBSZWdpc3RlcnMgYSBzdGF0aWMgZ3JhcGggZGVwZW5kZW5jeSBvbiB0aGUgYXRvbSBpbnN0YW5jZS4gVGhpcyBtZWFucyBhdG9tc1xuICogdGhhdCB1c2UgdGhpcyBpbmplY3RvciB3aWxsICpub3QqIHJlZXZhbHVhdGUgd2hlbiB0aGlzIGF0b20gaW5zdGFuY2UncyBzdGF0ZVxuICogY2hhbmdlcy5cbiAqXG4gKiBQYXNzIGZhbHNlIGFzIHRoZSA0dGggcGFyYW0gdG8gcHJldmVudCB0aGlzIGdyYXBoIGRlcGVuZGVuY3kgZnJvbSBiZWluZ1xuICogcmVnaXN0ZXJlZC4gVXNlZnVsIHdoZW4geW91IG5lZWQgdG8gY29udHJvbCB0aGUgZ3JhcGggZGVwZW5kZW5jeSBtYW51YWxseS5cbiAqIGBpbmplY3RBdG9tU2VsZWN0b3JgIGRvZXMgdGhpcyBpbnRlcm5hbGx5LlxuICpcbiAqIEBwYXJhbSBhdG9tIFRoZSBhdG9tIHRvIGluc3RhbnRpYXRlIG9yIHJldXNlIGFuIGluc3RhbnRpYXRpb24gb2YuXG4gKiBAcGFyYW0gcGFyYW1zIFRoZSBwYXJhbXMgZm9yIGdlbmVyYXRpbmcgdGhlIGluc3RhbmNlJ3Mga2V5LlxuICogQHBhcmFtIG9wZXJhdGlvbiBUaGUgb3BlcmF0aW9uIG5hbWUgKGUuZy4gbmFtZSBvZiB0aGUgaW5qZWN0b3IgZnVuY3Rpb24pXG4gKiB0aGF0J3MgdHJpZ2dlcmluZyB0aGlzIGdyYXBoIGRlcGVuZGVuY3kuIElmIHlvdSdyZSB1c2luZyB0aGlzIGluamVjdG9yXG4gKiBkaXJlY3RseSBpbiBhbiBhdG9tLCBpdCdzIGZpbmUgdG8gb21pdCB0aGlzIHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIEFuIGF0b20gaW5zdGFuY2UsIGtleWVkIGJhc2VkIG9uIHRoZSBwYXNzZWQgcGFyYW1zLlxuICovXG5leHBvcnQgY29uc3QgaW5qZWN0QXRvbUluc3RhbmNlOiB7XG4gIDxBIGV4dGVuZHMgQXRvbUJhc2U8YW55LCBbXSwgYW55LCBhbnksIGFueSwgYW55Pj4oXG4gICAgYXRvbTogQVxuICApOiBBdG9tSW5zdGFuY2VUeXBlPEE+XG5cbiAgPEEgZXh0ZW5kcyBBdG9tQmFzZTxhbnksIFsuLi5hbnldLCBhbnksIGFueSwgYW55LCBhbnk+PihcbiAgICBhdG9tOiBBLFxuICAgIHBhcmFtczogQXRvbVBhcmFtc1R5cGU8QT4sXG4gICAgY29uZmlnPzogSW5qZWN0QXRvbUluc3RhbmNlQ29uZmlnXG4gICk6IEF0b21JbnN0YW5jZVR5cGU8QT5cblxuICA8QUkgZXh0ZW5kcyBBdG9tSW5zdGFuY2VCYXNlPGFueSwgWy4uLmFueV0sIGFueT4+KFxuICAgIGluc3RhbmNlOiBBSSxcbiAgICBwYXJhbXM/OiBbXSxcbiAgICBjb25maWc/OiBJbmplY3RBdG9tSW5zdGFuY2VDb25maWdcbiAgKTogQUlcbn0gPSBjcmVhdGVJbmplY3RvcihcbiAgZGVmYXVsdE9wZXJhdGlvbixcbiAgPEEgZXh0ZW5kcyBBdG9tQmFzZTxhbnksIFsuLi5hbnldLCBhbnksIGFueSwgYW55LCBhbnk+PihcbiAgICBpbnN0YW5jZTogUGFydGlhbEF0b21JbnN0YW5jZSxcbiAgICBhdG9tOiBBIHwgQW55QXRvbUluc3RhbmNlQmFzZSxcbiAgICBwYXJhbXM/OiBBdG9tUGFyYW1zVHlwZTxBPixcbiAgICBjb25maWc/OiBJbmplY3RBdG9tSW5zdGFuY2VDb25maWdcbiAgKSA9PiB7XG4gICAgY29uc3QgaW5qZWN0ZWRJbnN0YW5jZSA9IGluc3RhbmNlLmVjb3N5c3RlbS5fZXZhbHVhdGlvblN0YWNrLmF0b21HZXR0ZXJzLmdldEluc3RhbmNlKFxuICAgICAgYXRvbSBhcyBBLFxuICAgICAgcGFyYW1zIGFzIEF0b21QYXJhbXNUeXBlPEE+LFxuICAgICAgW2NvbmZpZz8uc3Vic2NyaWJlID8gMCA6IFN0YXRpYywgY29uZmlnPy5vcGVyYXRpb24gfHwgZGVmYXVsdE9wZXJhdGlvbl1cbiAgICApXG5cbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBpbmplY3RlZEluc3RhbmNlIGFzIEF0b21JbnN0YW5jZVR5cGU8QT4sXG4gICAgICB0eXBlOiBgJHtwcmVmaXh9L2F0b21gLFxuICAgIH0gYXMgSW5qZWN0b3JEZXNjcmlwdG9yPEF0b21JbnN0YW5jZVR5cGU8QT4+XG4gIH0sXG4gIDxBIGV4dGVuZHMgQXRvbUJhc2U8YW55LCBbLi4uYW55XSwgYW55LCBhbnksIGFueSwgYW55Pj4oXG4gICAgcHJldkRlc2NyaXB0b3I6IEluamVjdG9yRGVzY3JpcHRvcjxBdG9tSW5zdGFuY2VUeXBlPEE+PixcbiAgICBpbnN0YW5jZTogUGFydGlhbEF0b21JbnN0YW5jZSxcbiAgICBhdG9tOiBBIHwgQW55QXRvbUluc3RhbmNlQmFzZSxcbiAgICBwYXJhbXM/OiBBdG9tUGFyYW1zVHlwZTxBPixcbiAgICBjb25maWc/OiBJbmplY3RBdG9tSW5zdGFuY2VDb25maWdcbiAgKSA9PiB7XG4gICAgLy8gbWFrZSBzdXJlIHRoZSBkZXBlbmRlbmN5IGdldHMgcmVnaXN0ZXJlZCBmb3IgdGhpcyBldmFsdWF0aW9uXG4gICAgY29uc3QgaW5qZWN0ZWRJbnN0YW5jZSA9IGluc3RhbmNlLmVjb3N5c3RlbS5fZXZhbHVhdGlvblN0YWNrLmF0b21HZXR0ZXJzLmdldEluc3RhbmNlKFxuICAgICAgYXRvbSBhcyBBLFxuICAgICAgcGFyYW1zIGFzIEF0b21QYXJhbXNUeXBlPEE+LFxuICAgICAgW2NvbmZpZz8uc3Vic2NyaWJlID8gMCA6IFN0YXRpYywgY29uZmlnPy5vcGVyYXRpb24gfHwgZGVmYXVsdE9wZXJhdGlvbl1cbiAgICApXG5cbiAgICBwcmV2RGVzY3JpcHRvci5yZXN1bHQgPSBpbmplY3RlZEluc3RhbmNlIGFzIEF0b21JbnN0YW5jZVR5cGU8QT5cblxuICAgIHJldHVybiBwcmV2RGVzY3JpcHRvclxuICB9XG4pXG4iLCJpbXBvcnQgeyByZWFkSW5zdGFuY2UgfSBmcm9tICcuLi9jbGFzc2VzL0V2YWx1YXRpb25TdGFjaydcbmltcG9ydCB7IFNlbGVjdGFibGUgfSBmcm9tICcuLi90eXBlcydcblxuZXhwb3J0IGNvbnN0IGluamVjdEF0b21TZWxlY3RvciA9IDxULCBBcmdzIGV4dGVuZHMgYW55W10+KFxuICBzZWxlY3RhYmxlOiBTZWxlY3RhYmxlPFQsIEFyZ3M+LFxuICAuLi5hcmdzOiBBcmdzXG4pOiBUID0+IHtcbiAgY29uc3QgaW5zdGFuY2UgPSByZWFkSW5zdGFuY2UoKVxuXG4gIHJldHVybiBpbnN0YW5jZS5lY29zeXN0ZW0uX2V2YWx1YXRpb25TdGFjay5hdG9tR2V0dGVycy5zZWxlY3QoXG4gICAgc2VsZWN0YWJsZSxcbiAgICAuLi5hcmdzXG4gIClcbn1cbiIsImltcG9ydCB7IEF0b21JbnN0YW5jZSwgQXRvbUJhc2UgfSBmcm9tICcuLi9jbGFzc2VzJ1xuaW1wb3J0IHtcbiAgQW55QXRvbSxcbiAgQXRvbUV4cG9ydHNUeXBlLFxuICBBdG9tSW5zdGFuY2VFeHBvcnRzVHlwZSxcbiAgQXRvbUluc3RhbmNlU3RhdGVUeXBlLFxuICBBdG9tUGFyYW1zVHlwZSxcbiAgQXRvbVN0YXRlVHlwZSxcbiAgU3RhdGVIb29rVHVwbGUsXG59IGZyb20gJy4uL3R5cGVzJ1xuaW1wb3J0IHsgaW5qZWN0QXRvbUluc3RhbmNlIH0gZnJvbSAnLi9pbmplY3RBdG9tSW5zdGFuY2UnXG5cbmV4cG9ydCBjb25zdCBpbmplY3RBdG9tU3RhdGU6IHtcbiAgPEEgZXh0ZW5kcyBBdG9tQmFzZTxhbnksIFtdLCBhbnksIGFueSwgYW55LCBhbnk+PihhdG9tOiBBKTogU3RhdGVIb29rVHVwbGU8XG4gICAgQXRvbVN0YXRlVHlwZTxBPixcbiAgICBBdG9tRXhwb3J0c1R5cGU8QT5cbiAgPlxuXG4gIDxBIGV4dGVuZHMgQW55QXRvbT4oYXRvbTogQSwgcGFyYW1zOiBBdG9tUGFyYW1zVHlwZTxBPik6IFN0YXRlSG9va1R1cGxlPFxuICAgIEF0b21TdGF0ZVR5cGU8QT4sXG4gICAgQXRvbUV4cG9ydHNUeXBlPEE+XG4gID5cblxuICA8QUkgZXh0ZW5kcyBBdG9tSW5zdGFuY2U8YW55LCBbLi4uYW55XSwgYW55LCBhbnksIGFueT4+KFxuICAgIGluc3RhbmNlOiBBSVxuICApOiBTdGF0ZUhvb2tUdXBsZTxBdG9tSW5zdGFuY2VTdGF0ZVR5cGU8QUk+LCBBdG9tSW5zdGFuY2VFeHBvcnRzVHlwZTxBST4+XG59ID0gPEEgZXh0ZW5kcyBBbnlBdG9tPihcbiAgYXRvbTogQSxcbiAgcGFyYW1zPzogQXRvbVBhcmFtc1R5cGU8QT5cbik6IFN0YXRlSG9va1R1cGxlPEF0b21TdGF0ZVR5cGU8QT4sIEF0b21FeHBvcnRzVHlwZTxBPj4gPT4ge1xuICBjb25zdCBpbnN0YW5jZSA9IGluamVjdEF0b21JbnN0YW5jZShhdG9tLCBwYXJhbXMgYXMgQXRvbVBhcmFtc1R5cGU8QT4sIHtcbiAgICBvcGVyYXRpb246ICdpbmplY3RBdG9tU3RhdGUnLFxuICAgIHN1YnNjcmliZTogdHJ1ZSxcbiAgfSkgYXMgQXRvbUluc3RhbmNlPEF0b21TdGF0ZVR5cGU8QT4sIFsuLi5hbnldLCBhbnksIGFueSwgYW55PlxuXG4gIGNvbnN0IHNldFN0YXRlOiBhbnkgPSAoc2V0dGFibGU6IGFueSwgbWV0YT86IGFueSkgPT5cbiAgICBpbnN0YW5jZS5zZXRTdGF0ZShzZXR0YWJsZSwgbWV0YSlcblxuICBPYmplY3QuYXNzaWduKHNldFN0YXRlLCBpbnN0YW5jZS5leHBvcnRzKVxuXG4gIHJldHVybiBbaW5zdGFuY2Uuc3RvcmUuZ2V0U3RhdGUoKSwgc2V0U3RhdGVdXG59XG4iLCJpbXBvcnQgeyBBdG9tQmFzZSwgQXRvbUluc3RhbmNlQmFzZSB9IGZyb20gJy4uL2NsYXNzZXMnXG5pbXBvcnQgeyBBdG9tSW5zdGFuY2VTdGF0ZVR5cGUsIEF0b21QYXJhbXNUeXBlLCBBdG9tU3RhdGVUeXBlIH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBpbmplY3RBdG9tSW5zdGFuY2UgfSBmcm9tICcuL2luamVjdEF0b21JbnN0YW5jZSdcblxuZXhwb3J0IGNvbnN0IGluamVjdEF0b21WYWx1ZToge1xuICA8QSBleHRlbmRzIEF0b21CYXNlPGFueSwgW10sIGFueSwgYW55LCBhbnksIGFueT4+KGF0b206IEEpOiBBdG9tU3RhdGVUeXBlPEE+XG5cbiAgPEEgZXh0ZW5kcyBBdG9tQmFzZTxhbnksIFsuLi5hbnldLCBhbnksIGFueSwgYW55LCBhbnk+PihcbiAgICBhdG9tOiBBLFxuICAgIHBhcmFtczogQXRvbVBhcmFtc1R5cGU8QT5cbiAgKTogQXRvbVN0YXRlVHlwZTxBPlxuXG4gIDxBSSBleHRlbmRzIEF0b21JbnN0YW5jZUJhc2U8YW55LCBbLi4uYW55XSwgYW55Pj4oXG4gICAgaW5zdGFuY2U6IEFJXG4gICk6IEF0b21JbnN0YW5jZVN0YXRlVHlwZTxBST5cbn0gPSA8QSBleHRlbmRzIEF0b21CYXNlPGFueSwgWy4uLmFueV0sIGFueSwgYW55LCBhbnksIGFueT4+KFxuICBhdG9tOiBBLFxuICBwYXJhbXM/OiBBdG9tUGFyYW1zVHlwZTxBPlxuKSA9PiB7XG4gIGNvbnN0IGluc3RhbmNlID0gaW5qZWN0QXRvbUluc3RhbmNlKGF0b20sIHBhcmFtcyBhcyBBdG9tUGFyYW1zVHlwZTxBPiwge1xuICAgIG9wZXJhdGlvbjogJ2luamVjdEF0b21WYWx1ZScsXG4gICAgc3Vic2NyaWJlOiB0cnVlLFxuICB9KSBhcyBBdG9tSW5zdGFuY2VCYXNlPEF0b21TdGF0ZVR5cGU8QT4sIFsuLi5hbnldLCBhbnk+XG5cbiAgcmV0dXJuIGluc3RhbmNlLnN0b3JlLmdldFN0YXRlKClcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUluamVjdG9yIH0gZnJvbSAnLi4vZmFjdG9yaWVzJ1xuaW1wb3J0IHsgSW5qZWN0b3JEZXBzLCBQYXJ0aWFsQXRvbUluc3RhbmNlIH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBoYXZlRGVwc0NoYW5nZWQsIHByZWZpeCB9IGZyb20gJy4uL3V0aWxzJ1xuXG50eXBlIE1lbW9JbmplY3RvckRlc2NyaXB0b3I8VD4gPSB7XG4gIGRlcHM6IEluamVjdG9yRGVwc1xuICByZXN1bHQ6IFRcbiAgdHlwZTogc3RyaW5nXG59XG5cbmV4cG9ydCBjb25zdCBpbmplY3RNZW1vID0gY3JlYXRlSW5qZWN0b3IoXG4gICdpbmplY3RNZW1vJyxcbiAgPFZhbHVlID0gYW55PihcbiAgICBpbnN0YW5jZTogUGFydGlhbEF0b21JbnN0YW5jZSxcbiAgICB2YWx1ZUZhY3Rvcnk6ICgpID0+IFZhbHVlLFxuICAgIGRlcHM/OiBJbmplY3RvckRlcHNcbiAgKSA9PlxuICAgICh7XG4gICAgICB0eXBlOiBgJHtwcmVmaXh9L21lbW9gLFxuICAgICAgZGVwcyxcbiAgICAgIHJlc3VsdDogdmFsdWVGYWN0b3J5KCksXG4gICAgfSBhcyBNZW1vSW5qZWN0b3JEZXNjcmlwdG9yPFZhbHVlPiksXG4gIDxWYWx1ZSA9IGFueT4oXG4gICAgcHJldkRlc2NyaXB0b3I6IE1lbW9JbmplY3RvckRlc2NyaXB0b3I8VmFsdWU+LFxuICAgIGluc3RhbmNlOiBQYXJ0aWFsQXRvbUluc3RhbmNlLFxuICAgIHZhbHVlRmFjdG9yeTogKCkgPT4gVmFsdWUsXG4gICAgZGVwcz86IEluamVjdG9yRGVwc1xuICApID0+IHtcbiAgICBjb25zdCBkZXBzSGF2ZUNoYW5nZWQgPSBoYXZlRGVwc0NoYW5nZWQocHJldkRlc2NyaXB0b3IuZGVwcywgZGVwcylcblxuICAgIGNvbnN0IHJlc3VsdCA9IGRlcHNIYXZlQ2hhbmdlZCA/IHZhbHVlRmFjdG9yeSgpIDogcHJldkRlc2NyaXB0b3IucmVzdWx0XG5cbiAgICBwcmV2RGVzY3JpcHRvci5kZXBzID0gZGVwc1xuICAgIHByZXZEZXNjcmlwdG9yLnJlc3VsdCA9IHJlc3VsdFxuXG4gICAgcmV0dXJuIHByZXZEZXNjcmlwdG9yXG4gIH1cbilcbiIsImltcG9ydCB7IEluamVjdG9yRGVwcyB9IGZyb20gJy4uL3R5cGVzJ1xuaW1wb3J0IHsgaW5qZWN0TWVtbyB9IGZyb20gJy4vaW5qZWN0TWVtbydcblxuZXhwb3J0IGNvbnN0IGluamVjdENhbGxiYWNrID0gPEFyZ3MgZXh0ZW5kcyBhbnlbXSA9IFtdLCBSZXQgPSBhbnk+KFxuICBjYWxsYmFjazogKC4uLmFyZ3M6IEFyZ3MpID0+IFJldCxcbiAgZGVwcz86IEluamVjdG9yRGVwc1xuKSA9PiBpbmplY3RNZW1vKCgpID0+IGNhbGxiYWNrLCBkZXBzKVxuIiwiaW1wb3J0IHsgcmVhZEluc3RhbmNlIH0gZnJvbSAnLi4vY2xhc3Nlcy9FdmFsdWF0aW9uU3RhY2snXG5cbmV4cG9ydCBjb25zdCBpbmplY3RJbnZhbGlkYXRlID0gKCkgPT4ge1xuICBjb25zdCBpbnN0YW5jZSA9IHJlYWRJbnN0YW5jZSgpXG5cbiAgcmV0dXJuICgpID0+IGluc3RhbmNlLmludmFsaWRhdGUoJ2luamVjdEludmFsaWRhdGUnLCAnSW5qZWN0b3InKVxufVxuIiwiaW1wb3J0IHsgTWFjaGluZUhvb2ssIE1hY2hpbmVTdG9yZSB9IGZyb20gJ0B6ZWR1eC9jb3JlJ1xuaW1wb3J0IHsgTWFjaGluZVN0YXRlVHlwZSB9IGZyb20gJ0B6ZWR1eC9jb3JlL3V0aWxzL3R5cGVzJ1xuaW1wb3J0IHsgY3JlYXRlSW5qZWN0b3IgfSBmcm9tICcuLi9mYWN0b3JpZXMnXG5pbXBvcnQgeyBJbmplY3RTdG9yZUNvbmZpZywgUGFydGlhbEF0b21JbnN0YW5jZSB9IGZyb20gJy4uL3R5cGVzJ1xuaW1wb3J0IHsgSW5qZWN0b3JEZXNjcmlwdG9yLCBwcmVmaXggfSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IGRvU3Vic2NyaWJlIH0gZnJvbSAnLi9pbmplY3RTdG9yZSdcblxudHlwZSBBcnJUb1VuaW9uPFMgZXh0ZW5kcyBzdHJpbmdbXT4gPSBTIGV4dGVuZHMgW2luZmVyIEssIC4uLmluZmVyIFJlc3RdXG4gID8gUmVzdCBleHRlbmRzIHN0cmluZ1tdXG4gICAgPyBLIHwgQXJyVG9VbmlvbjxSZXN0PlxuICAgIDogbmV2ZXJcbiAgOiBuZXZlclxuXG5leHBvcnQgdHlwZSBJbmplY3RNYWNoaW5lU3RvcmVQYXJhbXM8XG4gIFN0YXRlcyBleHRlbmRzIE1hY2hpbmVTdGF0ZVtdLFxuICBDb250ZXh0IGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuPiA9IFtcbiAgc3RhdGVzRmFjdG9yeTogKFxuICAgIHN0YXRlOiA8TmFtZSBleHRlbmRzIHN0cmluZz4oc3RhdGVOYW1lOiBOYW1lKSA9PiBNYWNoaW5lU3RhdGU8Q29udGV4dCwgTmFtZT5cbiAgKSA9PiBbLi4uU3RhdGVzXSxcbiAgaW5pdGlhbENvbnRleHQ/OiBDb250ZXh0LFxuICBjb25maWc/OiB7XG4gICAgZ3VhcmQ/OiAoXG4gICAgICBjdXJyZW50U3RhdGU6IE1hY2hpbmVTdGF0ZVR5cGU8TWFwU3RhdGVzVG9TdGF0ZU5hbWVzPFN0YXRlcz4sIENvbnRleHQ+LFxuICAgICAgbmV4dFZhbHVlOiBNYXBTdGF0ZXNUb1N0YXRlTmFtZXM8U3RhdGVzPlxuICAgICkgPT4gYm9vbGVhblxuICAgIG9uVHJhbnNpdGlvbj86IE1hY2hpbmVIb29rPFxuICAgICAgTWFwU3RhdGVzVG9TdGF0ZU5hbWVzPFN0YXRlcz4sXG4gICAgICBNYXBTdGF0ZXNUb0V2ZW50czxTdGF0ZXMsIENvbnRleHQ+LFxuICAgICAgQ29udGV4dFxuICAgID5cbiAgfSAmIEluamVjdFN0b3JlQ29uZmlnXG5dXG5cbmV4cG9ydCBpbnRlcmZhY2UgTWFjaGluZVN0YXRlPFxuICBDb250ZXh0IGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCA9IGFueSxcbiAgTmFtZSBleHRlbmRzIHN0cmluZyA9IHN0cmluZyxcbiAgRXZlbnRzIGV4dGVuZHMgc3RyaW5nW10gPSBbXSxcbiAgQ2hpbGRTdGF0ZXMgZXh0ZW5kcyBzdHJpbmdbXSA9IFtdXG4+IHtcbiAgb246IDxFIGV4dGVuZHMgc3RyaW5nLCBTIGV4dGVuZHMgc3RyaW5nPihcbiAgICBldmVudE5hbWU6IEUsXG4gICAgbmV4dFN0YXRlOiBTLFxuICAgIGd1YXJkPzogKGNvbnRleHQ6IENvbnRleHQpID0+IGJvb2xlYW5cbiAgKSA9PiBNYWNoaW5lU3RhdGU8Q29udGV4dCwgTmFtZSwgWy4uLkV2ZW50cywgRV0sIFsuLi5DaGlsZFN0YXRlcywgU10+XG4gIG9uRW50ZXI6IChcbiAgICBsaXN0ZW5lcjogTWFjaGluZUhvb2s8QXJyVG9VbmlvbjxDaGlsZFN0YXRlcz4sIEFyclRvVW5pb248RXZlbnRzPiwgQ29udGV4dD5cbiAgKSA9PiBNYWNoaW5lU3RhdGU8Q29udGV4dCwgTmFtZSwgRXZlbnRzLCBDaGlsZFN0YXRlcz5cbiAgb25MZWF2ZTogKFxuICAgIGxpc3RlbmVyOiBNYWNoaW5lSG9vazxBcnJUb1VuaW9uPENoaWxkU3RhdGVzPiwgQXJyVG9VbmlvbjxFdmVudHM+LCBDb250ZXh0PlxuICApID0+IE1hY2hpbmVTdGF0ZTxDb250ZXh0LCBOYW1lLCBFdmVudHMsIENoaWxkU3RhdGVzPlxuICBzdGF0ZU5hbWU6IE5hbWVcbn1cblxudHlwZSBNYXBTdGF0ZXNUb1N0YXRlTmFtZXM8XG4gIFN0YXRlcyBleHRlbmRzIE1hY2hpbmVTdGF0ZVtdLFxuICBDb250ZXh0IGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuPiA9IFN0YXRlcyBleHRlbmRzIFtpbmZlciBLLCAuLi5pbmZlciBSZXN0XVxuICA/IEsgZXh0ZW5kcyBNYWNoaW5lU3RhdGVcbiAgICA/IFJlc3QgZXh0ZW5kcyBNYWNoaW5lU3RhdGVbXVxuICAgICAgP1xuICAgICAgICAgIHwgU3RhdGVOYW1lVHlwZTxLPlxuICAgICAgICAgIHwgQXJyVG9VbmlvbjxTdGF0ZUNoaWxkU3RhdGVzVHlwZTxLPj5cbiAgICAgICAgICB8IE1hcFN0YXRlc1RvU3RhdGVOYW1lczxSZXN0LCBDb250ZXh0PlxuICAgICAgOiBuZXZlclxuICAgIDogbmV2ZXJcbiAgOiBuZXZlclxuXG50eXBlIE1hcFN0YXRlc1RvRXZlbnRzPFxuICBTdGF0ZXMgZXh0ZW5kcyBNYWNoaW5lU3RhdGVbXSxcbiAgQ29udGV4dCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbj4gPSBTdGF0ZXMgZXh0ZW5kcyBbaW5mZXIgSywgLi4uaW5mZXIgUmVzdF1cbiAgPyBLIGV4dGVuZHMgTWFjaGluZVN0YXRlXG4gICAgPyBSZXN0IGV4dGVuZHMgTWFjaGluZVN0YXRlW11cbiAgICAgID8gQXJyVG9VbmlvbjxTdGF0ZUV2ZW50c1R5cGU8Sz4+IHwgTWFwU3RhdGVzVG9FdmVudHM8UmVzdCwgQ29udGV4dD5cbiAgICAgIDogQXJyVG9VbmlvbjxTdGF0ZUV2ZW50c1R5cGU8Sz4+XG4gICAgOiBuZXZlclxuICA6IG5ldmVyXG5cbnR5cGUgU3RhdGVDaGlsZFN0YXRlc1R5cGU8UyBleHRlbmRzIE1hY2hpbmVTdGF0ZT4gPSBTIGV4dGVuZHMgTWFjaGluZVN0YXRlPFxuICBhbnksXG4gIHN0cmluZyxcbiAgc3RyaW5nW10sXG4gIGluZmVyIENoaWxkU3RhdGVzXG4+XG4gID8gQ2hpbGRTdGF0ZXNcbiAgOiBuZXZlclxuXG50eXBlIFN0YXRlRXZlbnRzVHlwZTxTIGV4dGVuZHMgTWFjaGluZVN0YXRlPiA9IFMgZXh0ZW5kcyBNYWNoaW5lU3RhdGU8XG4gIGFueSxcbiAgc3RyaW5nLFxuICBpbmZlciBFdmVudHNcbj5cbiAgPyBFdmVudHNcbiAgOiBuZXZlclxuXG50eXBlIFN0YXRlTmFtZVR5cGU8UyBleHRlbmRzIE1hY2hpbmVTdGF0ZT4gPSBTIGV4dGVuZHMgTWFjaGluZVN0YXRlPFxuICBhbnksXG4gIGluZmVyIE5hbWVcbj5cbiAgPyBOYW1lXG4gIDogbmV2ZXJcblxuLyoqXG4gKiBDcmVhdGUgYSBNYWNoaW5lU3RvcmUuIFBhc3MgYSBzdGF0ZXNGYWN0b3J5XG4gKlxuICogVGhlIGZpcnN0IHN0YXRlIGluIHRoZSBzdGF0ZSBsaXN0IHJldHVybmVkIGZyb20geW91ciBzdGF0ZXNGYWN0b3J5IHdpbGxcbiAqIGJlY29tZSB0aGUgaW5pdGlhbCBzdGF0ZSAoYC52YWx1ZWApIG9mIHRoZSBzdG9yZS5cbiAqXG4gKiBSZWdpc3RlcnMgYW4gZWZmZWN0IHRoYXQgbGlzdGVucyB0byBhbGwgc3RvcmUgY2hhbmdlcyBhbmQgY2FsbHMgdGhlXG4gKiBjb25maWd1cmVkIGxpc3RlbmVycyBhcHByb3ByaWF0ZWx5LlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBzdG9yZSA9IGluamVjdE1hY2hpbmVTdG9yZShzdGF0ZSA9PiBbXG4gKiAgIHN0YXRlKCdhJylcbiAqICAgICAub24oJ25leHQnLCAnYicsIGxvY2FsR3VhcmQpXG4gKiAgICAgLm9uRW50ZXIoZW50ZXJMaXN0ZW5lcilcbiAqICAgICAub25MZWF2ZShsZWF2ZUxpc3RlbmVyKSxcbiAqICAgc3RhdGUoJ2InKS5vbignbmV4dCcsICdhJylcbiAqIF0sIGluaXRpYWxDb250ZXh0LCB7IGd1YXJkLCBvblRyYW5zaXRpb24gfSlcbiAqIGBgYFxuICpcbiAqIFNldCBhIHVuaXZlcnNhbCB0cmFuc2l0aW9uIGd1YXJkIHZpYSB0aGUgM3JkIGBjb25maWdgIG9iamVjdCBwYXJhbS4gVGhpc1xuICogZ3VhcmQgd2lsbCBiZSBjYWxsZWQgZXZlcnkgdGltZSBhIHZhbGlkIHRyYW5zaXRpb24gaXMgYWJvdXQgdG8gb2NjdXIuIEl0IHdpbGxcbiAqIGJlIGNhbGxlZCB3aXRoIHRoZSBjdXJyZW50IGAuY29udGV4dGAgdmFsdWUgYW5kIHNob3VsZCByZXR1cm4gYSBib29sZWFuLlxuICogUmV0dXJuIHRydWUgdG8gYWxsb3cgdGhlIHRyYW5zaXRpb24sIG9yIGFueSBmYWxzeSB2YWx1ZSB0byBkZW55IGl0LlxuICpcbiAqIFNldCBhIHVuaXZlcnNhbCBgb25UcmFuc2l0aW9uYCBsaXN0ZW5lciB2aWEgdGhlIDNyZCBgY29uZmlnYCBvYmplY3QgcGFyYW0uXG4gKiBUaGlzIGxpc3RlbmVyIHdpbGwgYmUgY2FsbGVkIGV2ZXJ5IHRpbWUgdGhlIG1hY2hpbmUgdHJhbnNpdGlvbnMgdG8gYSBuZXdcbiAqIHN0YXRlIChhZnRlciB0aGUgc3RhdGUgaXMgdXBkYXRlZCkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggMiBwYXJhbXM6IFRoZVxuICogY3VycmVudCBNYWNoaW5lU3RvcmUgYW5kIHRoZSBzdG9yZUVmZmVjdCBvZiB0aGUgYWN0aW9uIHRoYXQgdHJhbnNpdGlvbmVkIHRoZVxuICogc3RvcmUuIEZvciBleGFtcGxlLCB1c2UgYHN0b3JlRWZmZWN0Lm9sZFN0YXRlLnZhbHVlYCB0byBzZWUgd2hhdCBzdGF0ZSB0aGVcbiAqIG1hY2hpbmUganVzdCB0cmFuc2l0aW9uZWQgZnJvbS5cbiAqXG4gKiBAcGFyYW0gc3RhdGVzRmFjdG9yeSBSZXF1aXJlZC4gQSBmdW5jdGlvbi4gVXNlIHRoZSByZWNlaXZlZCBzdGF0ZSBmYWN0b3J5IHRvXG4gKiBjcmVhdGUgYSBsaXN0IG9mIHN0YXRlcyBmb3IgdGhlIG1hY2hpbmUgYW5kIHNwZWNpZnkgdGhlaXIgdHJhbnNpdGlvbnMsXG4gKiBndWFyZHMsIGFuZCBsaXN0ZW5lcnMuXG4gKiBAcGFyYW0gaW5pdGlhbENvbnRleHQgT3B0aW9uYWwuIEFuIG9iamVjdCBvciB1bmRlZmluZWQuIFdpbGwgYmUgc2V0IGFzIHRoZVxuICogaW5pdGlhbCBgLmNvbnRleHRgIHZhbHVlIG9mIHRoZSBtYWNoaW5lIHN0b3JlJ3Mgc3RhdGUuXG4gKiBAcGFyYW0gY29uZmlnIE9wdGlvbmFsLiBBbiBvYmplY3Qgd2l0aCAyIGFkZGl0aW9uYWwgcHJvcGVydGllczogYGd1YXJkYCBhbmRcbiAqIGBvblRyYW5zaXRpb25gLlxuICovXG5leHBvcnQgY29uc3QgaW5qZWN0TWFjaGluZVN0b3JlOiA8XG4gIFN0YXRlcyBleHRlbmRzIE1hY2hpbmVTdGF0ZVtdLFxuICBDb250ZXh0IGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZFxuPihcbiAgLi4uW3N0YXRlc0ZhY3RvcnksIGluaXRpYWxDb250ZXh0LCBjb25maWddOiBJbmplY3RNYWNoaW5lU3RvcmVQYXJhbXM8XG4gICAgU3RhdGVzLFxuICAgIENvbnRleHRcbiAgPlxuKSA9PiBNYWNoaW5lU3RvcmU8XG4gIE1hcFN0YXRlc1RvU3RhdGVOYW1lczxTdGF0ZXMsIENvbnRleHQ+LFxuICBNYXBTdGF0ZXNUb0V2ZW50czxTdGF0ZXMsIENvbnRleHQ+LFxuICBDb250ZXh0XG4+ID0gY3JlYXRlSW5qZWN0b3IoXG4gICdpbmplY3RNYWNoaW5lU3RvcmUnLFxuICA8XG4gICAgU3RhdGVzIGV4dGVuZHMgTWFjaGluZVN0YXRlW10sXG4gICAgQ29udGV4dCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQgPSB1bmRlZmluZWRcbiAgPihcbiAgICBpbnN0YW5jZTogUGFydGlhbEF0b21JbnN0YW5jZSxcbiAgICAuLi5bc3RhdGVzRmFjdG9yeSwgaW5pdGlhbENvbnRleHQsIGNvbmZpZ106IEluamVjdE1hY2hpbmVTdG9yZVBhcmFtczxcbiAgICAgIFN0YXRlcyxcbiAgICAgIENvbnRleHRcbiAgICA+XG4gICkgPT4ge1xuICAgIHR5cGUgRXZlbnROYW1lcyA9IE1hcFN0YXRlc1RvRXZlbnRzPFN0YXRlcywgQ29udGV4dD5cbiAgICB0eXBlIFN0YXRlTmFtZXMgPSBNYXBTdGF0ZXNUb1N0YXRlTmFtZXM8U3RhdGVzLCBDb250ZXh0PlxuXG4gICAgY29uc3QgZW50ZXJIb29rczogUmVjb3JkPFxuICAgICAgc3RyaW5nLFxuICAgICAgTWFjaGluZUhvb2s8U3RhdGVOYW1lcywgRXZlbnROYW1lcywgQ29udGV4dD5bXVxuICAgID4gPSB7fVxuXG4gICAgY29uc3QgbGVhdmVIb29rczogUmVjb3JkPFxuICAgICAgc3RyaW5nLFxuICAgICAgTWFjaGluZUhvb2s8U3RhdGVOYW1lcywgRXZlbnROYW1lcywgQ29udGV4dD5bXVxuICAgID4gPSB7fVxuXG4gICAgY29uc3Qgc3RhdGVzID0ge30gYXMgUmVjb3JkPFxuICAgICAgU3RhdGVOYW1lcyxcbiAgICAgIFJlY29yZDxcbiAgICAgICAgRXZlbnROYW1lcyxcbiAgICAgICAgeyBuYW1lOiBTdGF0ZU5hbWVzOyBndWFyZD86IChjb250ZXh0OiBDb250ZXh0KSA9PiBib29sZWFuIH1cbiAgICAgID5cbiAgICA+XG5cbiAgICBjb25zdCBjcmVhdGVTdGF0ZSA9IDxOYW1lIGV4dGVuZHMgc3RyaW5nPihzdGF0ZU5hbWU6IE5hbWUpID0+IHtcbiAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICBvbjogKFxuICAgICAgICAgIGV2ZW50TmFtZTogc3RyaW5nLFxuICAgICAgICAgIG5leHRTdGF0ZTogc3RyaW5nLFxuICAgICAgICAgIGd1YXJkPzogKGNvbnRleHQ6IENvbnRleHQpID0+IGJvb2xlYW5cbiAgICAgICAgKSA9PiB7XG4gICAgICAgICAgaWYgKCFzdGF0ZXNbc3RhdGVOYW1lIGFzIFN0YXRlTmFtZXNdKSB7XG4gICAgICAgICAgICBzdGF0ZXNbc3RhdGVOYW1lIGFzIFN0YXRlTmFtZXNdID0ge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXN0YXRlc1tuZXh0U3RhdGUgYXMgU3RhdGVOYW1lc10pIHtcbiAgICAgICAgICAgIHN0YXRlc1tuZXh0U3RhdGUgYXMgU3RhdGVOYW1lc10gPSB7fVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0YXRlc1tzdGF0ZU5hbWUgYXMgU3RhdGVOYW1lc11bZXZlbnROYW1lIGFzIEV2ZW50TmFtZXNdID0ge1xuICAgICAgICAgICAgbmFtZTogbmV4dFN0YXRlIGFzIFN0YXRlTmFtZXMsXG4gICAgICAgICAgICBndWFyZCxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgICAgfSxcbiAgICAgICAgb25FbnRlcjogKGNhbGxiYWNrOiBhbnkpID0+IHtcbiAgICAgICAgICBpZiAoIWVudGVySG9va3Nbc3RhdGVOYW1lXSkge1xuICAgICAgICAgICAgZW50ZXJIb29rc1tzdGF0ZU5hbWVdID0gW11cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbnRlckhvb2tzW3N0YXRlTmFtZV0ucHVzaChjYWxsYmFjaylcblxuICAgICAgICAgIHJldHVybiBzdGF0ZVxuICAgICAgICB9LFxuICAgICAgICBvbkxlYXZlOiAoY2FsbGJhY2s6IGFueSkgPT4ge1xuICAgICAgICAgIGlmICghbGVhdmVIb29rc1tzdGF0ZU5hbWVdKSB7XG4gICAgICAgICAgICBsZWF2ZUhvb2tzW3N0YXRlTmFtZV0gPSBbXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxlYXZlSG9va3Nbc3RhdGVOYW1lXS5wdXNoKGNhbGxiYWNrKVxuXG4gICAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXRlTmFtZSxcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXRlXG4gICAgfVxuXG4gICAgY29uc3QgW2luaXRpYWxTdGF0ZV0gPSBzdGF0ZXNGYWN0b3J5KGNyZWF0ZVN0YXRlKVxuICAgIGNvbnN0IGh5ZHJhdGlvbiA9XG4gICAgICBjb25maWc/Lmh5ZHJhdGUgJiYgaW5zdGFuY2UuZWNvc3lzdGVtLl9jb25zdW1lSHlkcmF0aW9uKGluc3RhbmNlKVxuXG4gICAgY29uc3Qgc3RvcmUgPSBuZXcgTWFjaGluZVN0b3JlPFN0YXRlTmFtZXMsIEV2ZW50TmFtZXMsIENvbnRleHQ+KFxuICAgICAgaHlkcmF0aW9uPy52YWx1ZSA/PyAoaW5pdGlhbFN0YXRlLnN0YXRlTmFtZSBhcyBTdGF0ZU5hbWVzKSxcbiAgICAgIHN0YXRlcyxcbiAgICAgIGh5ZHJhdGlvbj8uY29udGV4dCA/PyBpbml0aWFsQ29udGV4dCxcbiAgICAgIGNvbmZpZz8uZ3VhcmRcbiAgICApXG5cbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBzdG9yZS5zdWJzY3JpYmUoe1xuICAgICAgZWZmZWN0czogc3RvcmVFZmZlY3QgPT4ge1xuICAgICAgICBjb25zdCB7IG5ld1N0YXRlLCBvbGRTdGF0ZSB9ID0gc3RvcmVFZmZlY3RcblxuICAgICAgICBpZiAobmV3U3RhdGUudmFsdWUgPT09IG9sZFN0YXRlPy52YWx1ZSkgcmV0dXJuXG5cbiAgICAgICAgaWYgKG9sZFN0YXRlICYmIGxlYXZlSG9va3Nbb2xkU3RhdGUudmFsdWVdKSB7XG4gICAgICAgICAgbGVhdmVIb29rc1tvbGRTdGF0ZS52YWx1ZV0uZm9yRWFjaChjYWxsYmFjayA9PlxuICAgICAgICAgICAgY2FsbGJhY2soc3RvcmUsIHN0b3JlRWZmZWN0KVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50ZXJIb29rc1tuZXdTdGF0ZS52YWx1ZV0pIHtcbiAgICAgICAgICBlbnRlckhvb2tzW25ld1N0YXRlLnZhbHVlXS5mb3JFYWNoKGNhbGxiYWNrID0+XG4gICAgICAgICAgICBjYWxsYmFjayhzdG9yZSwgc3RvcmVFZmZlY3QpXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWc/Lm9uVHJhbnNpdGlvbikge1xuICAgICAgICAgIGNvbmZpZy5vblRyYW5zaXRpb24oc3RvcmUsIHN0b3JlRWZmZWN0KVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pXG4gICAgY29uc3QgdXBkYXRlclN1YiA9IGNvbmZpZz8uc3Vic2NyaWJlICYmIGRvU3Vic2NyaWJlKGluc3RhbmNlLCBzdG9yZSlcblxuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKClcblxuICAgIGlmIChlbnRlckhvb2tzW2N1cnJlbnRTdGF0ZS52YWx1ZV0pIHtcbiAgICAgIGVudGVySG9va3NbY3VycmVudFN0YXRlLnZhbHVlXS5mb3JFYWNoKGNhbGxiYWNrID0+XG4gICAgICAgIGNhbGxiYWNrKHN0b3JlLCB7XG4gICAgICAgICAgbmV3U3RhdGU6IGN1cnJlbnRTdGF0ZSxcbiAgICAgICAgICBzdG9yZSxcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBkZXNjcmlwdG9yOiBJbmplY3RvckRlc2NyaXB0b3I8XG4gICAgICBNYWNoaW5lU3RvcmU8U3RhdGVOYW1lcywgRXZlbnROYW1lcywgQ29udGV4dD5cbiAgICA+ICYgeyBjbGVhbnVwVXBkYXRlcj86ICgpID0+IHZvaWQgfSA9IHtcbiAgICAgIGNsZWFudXA6ICgpID0+IHtcbiAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKClcbiAgICAgICAgZGVzY3JpcHRvci5jbGVhbnVwVXBkYXRlcj8uKClcbiAgICAgIH0sXG4gICAgICByZXN1bHQ6IHN0b3JlLFxuICAgICAgdHlwZTogYCR7cHJlZml4fS9tYWNoaW5lU3RvcmVgLFxuICAgIH1cblxuICAgIGlmICh1cGRhdGVyU3ViKSB7XG4gICAgICBkZXNjcmlwdG9yLmNsZWFudXBVcGRhdGVyID0gKCkgPT4gdXBkYXRlclN1Yi51bnN1YnNjcmliZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3JcbiAgfSxcbiAgPFxuICAgIFN0YXRlcyBleHRlbmRzIE1hY2hpbmVTdGF0ZVtdLFxuICAgIENvbnRleHQgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkXG4gID4oXG4gICAgcHJldkRlc2NyaXB0b3I6IEluamVjdG9yRGVzY3JpcHRvcjxcbiAgICAgIE1hY2hpbmVTdG9yZTxcbiAgICAgICAgTWFwU3RhdGVzVG9TdGF0ZU5hbWVzPFN0YXRlcywgQ29udGV4dD4sXG4gICAgICAgIE1hcFN0YXRlc1RvRXZlbnRzPFN0YXRlcywgQ29udGV4dD4sXG4gICAgICAgIENvbnRleHRcbiAgICAgID5cbiAgICA+ICYgeyBjbGVhbnVwVXBkYXRlcj86ICgpID0+IHZvaWQgfSxcbiAgICBpbnN0YW5jZTogUGFydGlhbEF0b21JbnN0YW5jZSxcbiAgICAuLi5bLCAsIGNvbmZpZ106IEluamVjdE1hY2hpbmVTdG9yZVBhcmFtczxTdGF0ZXMsIENvbnRleHQ+XG4gICkgPT4ge1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IGNvbmZpZz8uc3Vic2NyaWJlID8/IHRydWVcbiAgICBjb25zdCBwcmV2c3Vic2NyaWJlID0gISFwcmV2RGVzY3JpcHRvci5jbGVhbnVwVXBkYXRlclxuXG4gICAgaWYgKHByZXZzdWJzY3JpYmUgPT09IHN1YnNjcmliZSkgcmV0dXJuIHByZXZEZXNjcmlwdG9yXG5cbiAgICAvLyB3ZSB3ZXJlIHN1YnNjcmliZWQsIG5vdyB3ZSdyZSBub3RcbiAgICBpZiAoIXN1YnNjcmliZSkge1xuICAgICAgcHJldkRlc2NyaXB0b3IuY2xlYW51cFVwZGF0ZXI/LigpXG4gICAgICBwcmV2RGVzY3JpcHRvci5jbGVhbnVwVXBkYXRlciA9IHVuZGVmaW5lZFxuICAgICAgcmV0dXJuIHByZXZEZXNjcmlwdG9yXG4gICAgfVxuXG4gICAgLy8gd2Ugd2VyZW4ndCBzdWJzY3JpYmVkLCBub3cgd2UgYXJlXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gZG9TdWJzY3JpYmUoaW5zdGFuY2UsIHByZXZEZXNjcmlwdG9yLnJlc3VsdClcbiAgICBwcmV2RGVzY3JpcHRvci5jbGVhbnVwVXBkYXRlciA9ICgpID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpXG5cbiAgICByZXR1cm4gcHJldkRlc2NyaXB0b3JcbiAgfVxuKVxuIiwiaW1wb3J0IHsgU3RvcmUgfSBmcm9tICdAemVkdXgvY29yZSdcbmltcG9ydCB7IGRldGFpbGVkVHlwZW9mIH0gZnJvbSAnQHplZHV4L2NvcmUvdXRpbHMvZ2VuZXJhbCdcbmltcG9ydCB7IGFwaSB9IGZyb20gJy4uL2ZhY3RvcmllcydcbmltcG9ydCB7XG4gIGdldEVycm9yUHJvbWlzZVN0YXRlLFxuICBnZXRJbml0aWFsUHJvbWlzZVN0YXRlLFxuICBnZXRTdWNjZXNzUHJvbWlzZVN0YXRlLFxufSBmcm9tICcuLi91dGlscy9wcm9taXNlVXRpbHMnXG5pbXBvcnQgeyBJbmplY3RvckRlcHMsIEluamVjdFN0b3JlQ29uZmlnLCBQcm9taXNlU3RhdGUgfSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IGluamVjdEVmZmVjdCB9IGZyb20gJy4vaW5qZWN0RWZmZWN0J1xuaW1wb3J0IHsgaW5qZWN0TWVtbyB9IGZyb20gJy4vaW5qZWN0TWVtbydcbmltcG9ydCB7IGluamVjdFN0b3JlIH0gZnJvbSAnLi9pbmplY3RTdG9yZSdcbmltcG9ydCB7IGluamVjdFJlZiB9IGZyb20gJy4vaW5qZWN0UmVmJ1xuaW1wb3J0IHsgQXRvbUFwaSB9IGZyb20gJy4uL2NsYXNzZXMnXG5cbi8qKlxuICogQ3JlYXRlIGEgbWVtb2l6ZWQgcHJvbWlzZSByZWZlcmVuY2UuIEtpY2tzIG9mZiB0aGUgcHJvbWlzZSBpbW1lZGlhdGVseVxuICogKHVubGlrZSBpbmplY3RFZmZlY3Qgd2hpY2ggd2FpdHMgYSB0aWNrKS4gQ3JlYXRlcyBhIHN0b3JlIHRvIHRyYWNrIHByb21pc2VcbiAqIHN0YXRlLiBUaGlzIHN0b3JlJ3Mgc3RhdGUgc2hhcGUgaXMgYmFzZWQgb2ZmIFJlYWN0IFF1ZXJ5OlxuICpcbiAqIGBgYHRzXG4gKiB7XG4gKiAgIGRhdGE/OiA8cHJvbWlzZSByZXN1bHQgdHlwZT5cbiAqICAgZXJyb3I/OiBFcnJvclxuICogICBpc0Vycm9yOiBib29sZWFuXG4gKiAgIGlzTG9hZGluZzogYm9vbGVhblxuICogICBpc1N1Y2Nlc3M6IGJvb2xlYW5cbiAqICAgc3RhdHVzOiAnZXJyb3InIHwgJ2xvYWRpbmcnIHwgJ3N1Y2Nlc3MnXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBSZXR1cm5zIGFuIEF0b20gQVBJIHdpdGggYC5zdG9yZWAgYW5kIGAucHJvbWlzZWAgc2V0LlxuICpcbiAqIFRoZSAybmQgYGRlcHNgIHBhcmFtIGlzIGp1c3QgbGlrZSBgaW5qZWN0TWVtb2AgLSB0aGVzZSBkZXBzIGRldGVybWluZSB3aGVuXG4gKiB0aGUgcHJvbWlzZSdzIHJlZmVyZW5jZSBzaG91bGQgY2hhbmdlLlxuICpcbiAqIFRoZSAzcmQgYGNvbmZpZ2AgcGFyYW0gY2FuIHRha2UgdGhlIGZvbGxvd2luZyBvcHRpb25zOlxuICpcbiAqIC0gYGRhdGFPbmx5YDogU2V0IHRoaXMgdG8gdHJ1ZSB0byBwcmV2ZW50IHRoZSBzdG9yZSBmcm9tIHRyYWNraW5nIHByb21pc2VcbiAqICAgc3RhdHVzIGFuZCBtYWtlIHlvdXIgcHJvbWlzZSdzIGBkYXRhYCB0aGUgZW50aXJlIHN0YXRlLlxuICpcbiAqIC0gYGluaXRpYWxTdGF0ZWA6IFNldCB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgc3RvcmUgKGUuZy4gYSBwbGFjZWhvbGRlclxuICogICB2YWx1ZSBiZWZvcmUgdGhlIHByb21pc2UgcmVzb2x2ZXMpXG4gKlxuICogLSBzdG9yZSBjb25maWc6IEFueSBvdGhlciBjb25maWcgb3B0aW9ucyB3aWxsIGJlIHBhc3NlZCBkaXJlY3RseSB0b1xuICogICBgaW5qZWN0U3RvcmVgJ3MgY29uZmlnLiBGb3IgZXhhbXBsZSwgcGFzcyBgc3Vic2NyaWJlOiBmYWxzZWAgdG9cbiAqICAgcHJldmVudCB0aGUgc3RvcmUgZnJvbSByZWV2YWx1YXRpbmcgdGhlIGN1cnJlbnQgYXRvbSBvbiB1cGRhdGUuXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IHByb21pc2VBcGkgPSBpbmplY3RQcm9taXNlKGFzeW5jICgpID0+IHtcbiAqICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpXG4gKiAgIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKClcbiAqIH0sIFt1cmxdLCB7XG4gKiAgIGRhdGFPbmx5OiB0cnVlLFxuICogICBpbml0aWFsU3RhdGU6ICcnLFxuICogICBzdWJzY3JpYmU6IGZhbHNlXG4gKiB9KVxuICogYGBgXG4gKi9cbmV4cG9ydCBjb25zdCBpbmplY3RQcm9taXNlOiB7XG4gIDxUPihcbiAgICBwcm9taXNlRmFjdG9yeTogKGNvbnRyb2xsZXI/OiBBYm9ydENvbnRyb2xsZXIpID0+IFByb21pc2U8VD4sXG4gICAgZGVwczogSW5qZWN0b3JEZXBzLFxuICAgIGNvbmZpZzogeyBpbml0aWFsU3RhdGU/OiBUOyBkYXRhT25seTogdHJ1ZSB9ICYgSW5qZWN0U3RvcmVDb25maWdcbiAgKTogQXRvbUFwaTxULCBSZWNvcmQ8c3RyaW5nLCBhbnk+LCBTdG9yZTxUPiwgUHJvbWlzZTxUPj5cblxuICA8VD4oXG4gICAgcHJvbWlzZUZhY3Rvcnk6IChjb250cm9sbGVyPzogQWJvcnRDb250cm9sbGVyKSA9PiBQcm9taXNlPFQ+LFxuICAgIGRlcHM/OiBJbmplY3RvckRlcHMsXG4gICAgY29uZmlnPzogeyBpbml0aWFsU3RhdGU/OiBUOyBkYXRhT25seT86IGJvb2xlYW4gfSAmIEluamVjdFN0b3JlQ29uZmlnXG4gICk6IEF0b21BcGk8XG4gICAgUHJvbWlzZVN0YXRlPFQ+LFxuICAgIFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgU3RvcmU8UHJvbWlzZVN0YXRlPFQ+PixcbiAgICBQcm9taXNlPFQ+XG4gID5cbn0gPSA8VD4oXG4gIHByb21pc2VGYWN0b3J5OiAoY29udHJvbGxlcj86IEFib3J0Q29udHJvbGxlcikgPT4gUHJvbWlzZTxUPixcbiAgZGVwcz86IEluamVjdG9yRGVwcyxcbiAge1xuICAgIGRhdGFPbmx5LFxuICAgIGluaXRpYWxTdGF0ZSxcbiAgICAuLi5zdG9yZUNvbmZpZ1xuICB9OiB7IGRhdGFPbmx5PzogYm9vbGVhbjsgaW5pdGlhbFN0YXRlPzogVCB9ICYgSW5qZWN0U3RvcmVDb25maWcgPSB7fVxuKSA9PiB7XG4gIGNvbnN0IHJlZnMgPSBpbmplY3RSZWYoXG4gICAge30gYXMgeyBjb250cm9sbGVyPzogQWJvcnRDb250cm9sbGVyOyBwcm9taXNlOiBQcm9taXNlPFQ+IH1cbiAgKVxuXG4gIGNvbnN0IHN0b3JlID0gaW5qZWN0U3RvcmUoXG4gICAgZGF0YU9ubHkgPyBpbml0aWFsU3RhdGUgOiBnZXRJbml0aWFsUHJvbWlzZVN0YXRlPFQ+KGluaXRpYWxTdGF0ZSksXG4gICAgc3RvcmVDb25maWdcbiAgKVxuXG4gIC8vIHNldHRpbmcgYSByZWYgZHVyaW5nIGV2YWx1YXRpb24gaXMgcGVyZmVjdGx5IGZpbmUgaW4gWmVkdXhcbiAgcmVmcy5jdXJyZW50LnByb21pc2UgPSBpbmplY3RNZW1vKCgpID0+IHtcbiAgICBjb25zdCBwcmV2Q29udHJvbGxlciA9IHJlZnMuY3VycmVudC5jb250cm9sbGVyXG4gICAgY29uc3QgbmV4dENvbnRyb2xsZXIgPVxuICAgICAgdHlwZW9mIEFib3J0Q29udHJvbGxlciAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgQWJvcnRDb250cm9sbGVyKCkgOiB1bmRlZmluZWRcblxuICAgIHJlZnMuY3VycmVudC5jb250cm9sbGVyID0gbmV4dENvbnRyb2xsZXJcbiAgICBjb25zdCBwcm9taXNlID0gcHJvbWlzZUZhY3RvcnkocmVmcy5jdXJyZW50LmNvbnRyb2xsZXIpXG5cbiAgICBpZiAoREVWICYmIHR5cGVvZiBwcm9taXNlPy50aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgWmVkdXg6IGluamVjdFByb21pc2UgZXhwZWN0ZWQgY2FsbGJhY2sgdG8gcmV0dXJuIGEgcHJvbWlzZS4gUmVjZWl2ZWQgJHtkZXRhaWxlZFR5cGVvZihcbiAgICAgICAgICBwcm9taXNlXG4gICAgICAgICl9YFxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChwcm9taXNlID09PSByZWZzLmN1cnJlbnQucHJvbWlzZSkgcmV0dXJuIHJlZnMuY3VycmVudC5wcm9taXNlXG4gICAgOyhwcmV2Q29udHJvbGxlcj8uYWJvcnQgYXMgKChyZWFzb24/OiBhbnkpID0+IHZvaWQpIHwgdW5kZWZpbmVkKT8uKFxuICAgICAgJ3VwZGF0ZWQnXG4gICAgKVxuXG4gICAgaWYgKCFkYXRhT25seSkge1xuICAgICAgLy8gcHJlc2VydmUgcHJldmlvdXMgZGF0YSBhbmQgZXJyb3IgdXNpbmcgc2V0U3RhdGVEZWVwOlxuICAgICAgc3RvcmUuc2V0U3RhdGVEZWVwKGdldEluaXRpYWxQcm9taXNlU3RhdGUoKSlcbiAgICB9XG5cbiAgICBwcm9taXNlXG4gICAgICAudGhlbihkYXRhID0+IHtcbiAgICAgICAgaWYgKG5leHRDb250cm9sbGVyPy5zaWduYWwuYWJvcnRlZCkgcmV0dXJuXG5cbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoZGF0YU9ubHkgPyBkYXRhIDogZ2V0U3VjY2Vzc1Byb21pc2VTdGF0ZShkYXRhKSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBpZiAoZGF0YU9ubHkgfHwgbmV4dENvbnRyb2xsZXI/LnNpZ25hbC5hYm9ydGVkKSByZXR1cm5cblxuICAgICAgICAvLyBwcmVzZXJ2ZSBwcmV2aW91cyBkYXRhIHVzaW5nIHNldFN0YXRlRGVlcDpcbiAgICAgICAgc3RvcmUuc2V0U3RhdGVEZWVwKGdldEVycm9yUHJvbWlzZVN0YXRlKGVycm9yKSlcbiAgICAgIH0pXG5cbiAgICByZXR1cm4gcHJvbWlzZVxuICB9LCBkZXBzKVxuXG4gIGluamVjdEVmZmVjdChcbiAgICAoKSA9PiAoKSA9PiAocmVmcy5jdXJyZW50LmNvbnRyb2xsZXI/LmFib3J0IGFzIGFueSk/LignZGVzdHJveWVkJyksXG4gICAgW11cbiAgKVxuXG4gIHJldHVybiBhcGkoc3RvcmUpLnNldFByb21pc2UocmVmcy5jdXJyZW50LnByb21pc2UpXG59XG4iLCJpbXBvcnQgeyByZWFkSW5zdGFuY2UgfSBmcm9tICcuLi9jbGFzc2VzL0V2YWx1YXRpb25TdGFjaydcblxuLyoqXG4gKiBBIGZha2UgaW5qZWN0b3IgKGNhbiBhY3R1YWxseSBiZSB1c2VkIGluIGxvb3BzIGFuZCBpZiBzdGF0ZW1lbnRzKS4gQW4gYWxpYXNcbiAqIGZvcjpcbiAqXG4gKiBgYGB0c1xuICogY29uc3QgeyBlY29zeXN0ZW0gfSA9IGluamVjdEF0b21HZXR0ZXJzKClcbiAqIGNvbnN0IHJlYXNvbnMgPSBlY29zeXN0ZW0ud2h5KClcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3QgaW5qZWN0V2h5ID0gKCkgPT4gcmVhZEluc3RhbmNlKCkuX25leHRFdmFsdWF0aW9uUmVhc29uc1xuIiwiZXhwb3J0ICogZnJvbSAnLi9pbmplY3RBdG9tR2V0dGVycydcbmV4cG9ydCAqIGZyb20gJy4vaW5qZWN0QXRvbUluc3RhbmNlJ1xuZXhwb3J0ICogZnJvbSAnLi9pbmplY3RBdG9tU2VsZWN0b3InXG5leHBvcnQgKiBmcm9tICcuL2luamVjdEF0b21TdGF0ZSdcbmV4cG9ydCAqIGZyb20gJy4vaW5qZWN0QXRvbVZhbHVlJ1xuZXhwb3J0ICogZnJvbSAnLi9pbmplY3RDYWxsYmFjaydcbmV4cG9ydCAqIGZyb20gJy4vaW5qZWN0RWZmZWN0J1xuZXhwb3J0ICogZnJvbSAnLi9pbmplY3RJbnZhbGlkYXRlJ1xuZXhwb3J0ICogZnJvbSAnLi9pbmplY3RNYWNoaW5lU3RvcmUnXG5leHBvcnQgKiBmcm9tICcuL2luamVjdE1lbW8nXG5leHBvcnQgKiBmcm9tICcuL2luamVjdFByb21pc2UnXG5leHBvcnQgKiBmcm9tICcuL2luamVjdFJlZidcbmV4cG9ydCB7IGluamVjdFN0b3JlIH0gZnJvbSAnLi9pbmplY3RTdG9yZSdcbmV4cG9ydCAqIGZyb20gJy4vaW5qZWN0V2h5J1xuIiwiZXhwb3J0ICogZnJvbSAnQHplZHV4L2NvcmUnXG5leHBvcnQgKiBmcm9tICcuL2NsYXNzZXMnXG5leHBvcnQgKiBmcm9tICcuL2NvbXBvbmVudHMnXG5leHBvcnQgKiBmcm9tICcuL2ZhY3RvcmllcydcbmV4cG9ydCAqIGZyb20gJy4vaG9va3MnXG5leHBvcnQgKiBmcm9tICcuL2luamVjdG9ycydcbmV4cG9ydCAqIGZyb20gJy4vc3RvcmUnXG5leHBvcnQgKiBmcm9tICcuL3R5cGVzJ1xuIiwiaW1wb3J0IFJlYWN0LCB7IE11dGFibGVSZWZPYmplY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgc3R5bGVkIGZyb20gJ0BzaXRlL3NyYy9zc2MnXG5pbXBvcnQgKiBhcyBSZWFjdFplZHV4IGZyb20gJy4uLy4uLy4uLy4uL3BhY2thZ2VzL3JlYWN0L3NyYydcblxuY29uc3Qgb3B0aW9ucyA9IHtcbiAgQXRvbVN0YXRlOiAnQXRvbSBTdGF0ZScsXG4gIFNlbGVjdG9yQ2FjaGU6ICdTZWxlY3RvciBDYWNoZScsXG4gIEVjb3N5c3RlbTogJ0Vjb3N5c3RlbScsXG4gIEdyYXBoOiAnR3JhcGgnLFxuICBTY29wZTogJ1NhbmRib3ggU2NvcGUnLFxufVxuXG5jb25zdCBCYWNrZHJvcCA9IHN0eWxlZC5kaXZgXG4gIGhlaWdodDogMTAwJTtcbiAgbGVmdDogMDtcbiAgcG9zaXRpb246IGZpeGVkO1xuICB0b3A6IDA7XG4gIHdpZHRoOiAxMDAlO1xuICB6LWluZGV4OiAxMDAwMDAwO1xuYFxuXG5jb25zdCBCdXR0b24gPSBzdHlsZWQuYnV0dG9uYFxuICBiYWNrZ3JvdW5kOiBub25lO1xuICBib3JkZXI6IG5vbmU7XG4gIGNvbG9yOiAjZmZmO1xuICBjdXJzb3I6IHBvaW50ZXI7XG5gXG5cbmNvbnN0IERyb3Bkb3duID0gc3R5bGVkLmJ1dHRvbmBcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gIGJvcmRlcjogbm9uZTtcbiAgY29sb3I6ICNmZmY7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1mbG93OiByb3cgbm93cmFwO1xuICBmb250LXNpemU6IGluaGVyaXQ7XG4gIGdhcDogMC41cmVtO1xuYFxuXG5jb25zdCBPcHRpb24gPSBzdHlsZWQuc3BhbmBcbiAgYmFja2dyb3VuZDogI2ZmYTM1OTtcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xuICBib3gtc2hhZG93OiA1cHggNXB4IDhweCAjMDAwNDtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBwYWRkaW5nOiAwLjJyZW0gMXJlbTtcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgdHJhbnNmb3JtOiBzY2FsZSgxKTtcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMXM7XG5cbiAgJjpob3ZlciB7XG4gICAgdHJhbnNmb3JtOiBzY2FsZSgxLjA1KTtcbiAgfVxuYFxuXG5jb25zdCBPcHRpb25zID0gc3R5bGVkLnNwYW5gXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZmxvdzogY29sdW1uIG5vd3JhcDtcbiAgZ2FwOiAxcmVtO1xuICBsZWZ0OiA1MCU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKC01MCUpO1xuICB0b3A6IGNhbGMoMTAwJSArIDFyZW0pO1xuICB6LWluZGV4OiAxMDAwMDAxO1xuYFxuXG5jb25zdCBXcmFwcGVyID0gc3R5bGVkLnNwYW5gXG4gIGJvcmRlcjogMXB4IHNvbGlkICNmZmY7XG4gIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1mbG93OiByb3cgbm93cmFwO1xuICBmb250LXNpemU6IDAuOGVtO1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgPiBidXR0b24ge1xuICAgIHBhZGRpbmc6IDJweCAwLjhyZW07XG5cbiAgICAmOmhvdmVyIHtcbiAgICAgIGJhY2tncm91bmQ6ICNmZmY0O1xuICAgIH1cbiAgfVxuYFxuXG5jb25zdCBDYXJldERvd25JY29uID0gKCkgPT4gKFxuICA8c3ZnXG4gICAgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gICAgd2lkdGg9XCIxMlwiXG4gICAgaGVpZ2h0PVwiOFwiXG4gICAgdmlld0JveD1cIjAgMCAxMiA4XCJcbiAgPlxuICAgIDxwYXRoIGZpbGw9XCJ0cmFuc3BhcmVudFwiIHN0cm9rZT1cIiNmZmZcIiBkPVwiTTAgMCBMIDYgOCBMIDEyIDBcIiAvPlxuICA8L3N2Zz5cbilcblxuZXhwb3J0IGNvbnN0IExvZ0FjdGlvbnMgPSAoe1xuICBlY29zeXN0ZW1JZFJlZixcbiAgWmVkdXgsXG59OiB7XG4gIGVjb3N5c3RlbUlkUmVmOiBNdXRhYmxlUmVmT2JqZWN0PHN0cmluZz5cbiAgWmVkdXg6IHR5cGVvZiBSZWFjdFplZHV4XG59KSA9PiB7XG4gIGNvbnN0IFtpc09wZW4sIHNldElzT3Blbl0gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgW2xhc3RTZWxlY3Rpb24sIHNldExhc3RTZWxlY3Rpb25dID0gdXNlU3RhdGU8a2V5b2YgdHlwZW9mIG9wdGlvbnM+KClcblxuICBjb25zdCBhY3Rpb25zID0gdXNlTWVtbzxSZWNvcmQ8a2V5b2YgdHlwZW9mIG9wdGlvbnMsICgpID0+IHZvaWQ+PihcbiAgICAoKSA9PiAoe1xuICAgICAgQXRvbVN0YXRlOiAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZ3JvdXAoJ0N1cnJlbnQgc3RhdGUgb2YgYWxsIGF0b20gaW5zdGFuY2VzOicpXG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIFplZHV4LmdldEVjb3N5c3RlbShlY29zeXN0ZW1JZFJlZi5jdXJyZW50KS5kZWh5ZHJhdGUoe1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBmYWxzZSxcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICAgICAgfSxcbiAgICAgIEVjb3N5c3RlbTogKCkgPT4ge1xuICAgICAgICBjb25zb2xlLmdyb3VwKCdFY29zeXN0ZW06JylcbiAgICAgICAgY29uc29sZS5sb2coWmVkdXguZ2V0RWNvc3lzdGVtKGVjb3N5c3RlbUlkUmVmLmN1cnJlbnQpKVxuICAgICAgICBjb25zb2xlLmdyb3VwRW5kKClcbiAgICAgIH0sXG4gICAgICBHcmFwaDogKCkgPT4ge1xuICAgICAgICBjb25zdCBlY29zeXN0ZW0gPSBaZWR1eC5nZXRFY29zeXN0ZW0oZWNvc3lzdGVtSWRSZWYuY3VycmVudClcbiAgICAgICAgY29uc29sZS5ncm91cCgnQ3VycmVudCBncmFwaDonKVxuICAgICAgICBjb25zb2xlLmxvZygnRmxhdDonLCBlY29zeXN0ZW0udmlld0dyYXBoKCdmbGF0JykpXG4gICAgICAgIGNvbnNvbGUubG9nKCdUb3AtRG93bjonLCBlY29zeXN0ZW0udmlld0dyYXBoKCd0b3AtZG93bicpKVxuICAgICAgICBjb25zb2xlLmxvZygnQm90dG9tLVVwOicsIGVjb3N5c3RlbS52aWV3R3JhcGgoJ2JvdHRvbS11cCcpKVxuICAgICAgICBjb25zb2xlLmdyb3VwRW5kKClcbiAgICAgIH0sXG4gICAgICBTZWxlY3RvckNhY2hlOiAoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUuZ3JvdXAoJ0NhY2hlZCBzZWxlY3RvcnM6JylcbiAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgWmVkdXguZ2V0RWNvc3lzdGVtKFxuICAgICAgICAgICAgZWNvc3lzdGVtSWRSZWYuY3VycmVudFxuICAgICAgICAgICkuc2VsZWN0b3JDYWNoZS5pbnNwZWN0SXRlbVZhbHVlcygpXG4gICAgICAgIClcbiAgICAgICAgY29uc29sZS5ncm91cEVuZCgpXG4gICAgICB9LFxuICAgICAgU2NvcGU6ICgpID0+IHtcbiAgICAgICAgY29uc29sZS5ncm91cCgnRXhwb3J0cyBhdmFpbGFibGUgaW4gdGhlIHNhbmRib3g6JylcbiAgICAgICAgY29uc29sZS5sb2coJ1plZHV4OicsIFplZHV4KVxuICAgICAgICBjb25zb2xlLmxvZygnUmVhY3Q6JywgUmVhY3QpXG4gICAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICAgICAgfSxcbiAgICB9KSxcbiAgICBbWmVkdXhdXG4gIClcblxuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICB7aXNPcGVuICYmIDxCYWNrZHJvcCBvbkNsaWNrPXsoKSA9PiBzZXRJc09wZW4oZmFsc2UpfSAvPn1cbiAgICAgIDxXcmFwcGVyPlxuICAgICAgICB7bGFzdFNlbGVjdGlvbiAmJiAoXG4gICAgICAgICAgPEJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBhY3Rpb25zW2xhc3RTZWxlY3Rpb25dKCl9PlxuICAgICAgICAgICAgTG9nIHtvcHRpb25zW2xhc3RTZWxlY3Rpb25dfVxuICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICApfVxuICAgICAgICA8RHJvcGRvd24gb25DbGljaz17KCkgPT4gc2V0SXNPcGVuKHRydWUpfT5cbiAgICAgICAgICB7IWxhc3RTZWxlY3Rpb24gJiYgPHNwYW4+TG9nPC9zcGFuPn1cbiAgICAgICAgICA8Q2FyZXREb3duSWNvbiAvPlxuICAgICAgICA8L0Ryb3Bkb3duPlxuICAgICAgICB7aXNPcGVuICYmIChcbiAgICAgICAgICA8T3B0aW9uc1xuICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICBzZXRJc09wZW4oZmFsc2UpXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtPYmplY3Qua2V5cyhvcHRpb25zKS5tYXAoKG9wdGlvbjoga2V5b2YgdHlwZW9mIG9wdGlvbnMpID0+IChcbiAgICAgICAgICAgICAgPE9wdGlvblxuICAgICAgICAgICAgICAgIGtleT17b3B0aW9ufVxuICAgICAgICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHtcbiAgICAgICAgICAgICAgICAgIHNldExhc3RTZWxlY3Rpb24ob3B0aW9uKVxuICAgICAgICAgICAgICAgICAgYWN0aW9uc1tvcHRpb25dKClcbiAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAge29wdGlvbnNbb3B0aW9uXX1cbiAgICAgICAgICAgICAgPC9PcHRpb24+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L09wdGlvbnM+XG4gICAgICAgICl9XG4gICAgICA8L1dyYXBwZXI+XG4gICAgPC8+XG4gIClcbn1cbiIsImltcG9ydCB7IEtleWJvYXJkRXZlbnQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFJlYWN0RWRpdG9yIH0gZnJvbSAnc2xhdGUtcmVhY3QnXG5pbXBvcnQgeyBUcmFuc2Zvcm1zIH0gZnJvbSAnc2xhdGUnXG5cbmNvbnN0IG9wZW5pbmdDaGFycyA9IFsneycsICdbJywgJygnLCAnPCddXG5jb25zdCBjbG9zaW5nQ2hhcnMgPSBbJ30nLCAnXScsICcpJywgJz4nXVxuXG5leHBvcnQgY29uc3Qgb25LZXlEb3duID0gKFxuICBlZGl0b3I6IFJlYWN0RWRpdG9yLFxuICBldmVudDogS2V5Ym9hcmRFdmVudDxIVE1MRGl2RWxlbWVudD5cbikgPT4ge1xuICBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcblxuICAgIGVkaXRvci5pbnNlcnRUZXh0KCcgICcpXG5cbiAgICByZXR1cm5cbiAgfVxuXG4gIGlmIChldmVudC5rZXkgPT09ICd7Jykge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICBlZGl0b3IuaW5zZXJ0VGV4dCgne30nKVxuICAgIFRyYW5zZm9ybXMubW92ZShlZGl0b3IsIHtcbiAgICAgIGRpc3RhbmNlOiAxLFxuICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgIHVuaXQ6ICdjaGFyYWN0ZXInLFxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoZXZlbnQua2V5ID09PSAnWycpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgZWRpdG9yLmluc2VydFRleHQoJ1tdJylcbiAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICBkaXN0YW5jZTogMSxcbiAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICB1bml0OiAnY2hhcmFjdGVyJyxcbiAgICB9KVxuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKGV2ZW50LmtleSA9PT0gJygnKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGVkaXRvci5pbnNlcnRUZXh0KCcoKScpXG4gICAgVHJhbnNmb3Jtcy5tb3ZlKGVkaXRvciwge1xuICAgICAgZGlzdGFuY2U6IDEsXG4gICAgICByZXZlcnNlOiB0cnVlLFxuICAgICAgdW5pdDogJ2NoYXJhY3RlcicsXG4gICAgfSlcbiAgICByZXR1cm5cbiAgfVxuXG4gIGNvbnN0IGRvbVJhbmdlID1cbiAgICBlZGl0b3Iuc2VsZWN0aW9uICYmIFJlYWN0RWRpdG9yLnRvRE9NUmFuZ2UoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uKVxuXG4gIGlmICghZG9tUmFuZ2UpIHJldHVyblxuXG4gIGxldCBsaW5lID0gZG9tUmFuZ2Uuc3RhcnRDb250YWluZXIucGFyZW50RWxlbWVudFxuICB3aGlsZSAobGluZS5kYXRhc2V0LnNsYXRlTm9kZSAhPT0gJ3RleHQnKSB7XG4gICAgbGluZSA9IGxpbmUucGFyZW50RWxlbWVudFxuICB9XG5cbiAgY29uc3QgbGluZVRleHQgPSBsaW5lLmlubmVyVGV4dFxuICBjb25zdCBzcGFjZXMgPSBsaW5lVGV4dC5tYXRjaCgvXiArLyk/LlswXSB8fCAnJ1xuICBjb25zdCBoYXNTZWxlY3Rpb24gPSBkb21SYW5nZS5zdGFydE9mZnNldCAhPT0gZG9tUmFuZ2UuZW5kT2Zmc2V0XG4gIGNvbnN0IGVuZE9mZnNldCA9IGhhc1NlbGVjdGlvblxuICAgID8gZG9tUmFuZ2UuZW5kT2Zmc2V0XG4gICAgOiBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLm9mZnNldFxuICBjb25zdCBzdGFydE9mZnNldCA9IGhhc1NlbGVjdGlvbiA/IGRvbVJhbmdlLnN0YXJ0T2Zmc2V0IDogZW5kT2Zmc2V0XG4gIGNvbnN0IHByZXZDaGFyID0gbGluZVRleHRbc3RhcnRPZmZzZXQgLSAxXSB8fCAnJ1xuICBjb25zdCBuZXh0Q2hhciA9IGxpbmVUZXh0W2VuZE9mZnNldF0gfHwgJydcblxuICBpZiAoXG4gICAgKGV2ZW50LmtleSA9PT0gJ30nICYmIG5leHRDaGFyID09PSAnfScpIHx8XG4gICAgKGV2ZW50LmtleSA9PT0gJ10nICYmIG5leHRDaGFyID09PSAnXScpIHx8XG4gICAgKGV2ZW50LmtleSA9PT0gJyknICYmIG5leHRDaGFyID09PSAnKScpIHx8XG4gICAgKGV2ZW50LmtleSA9PT0gJ1wiJyAmJiBuZXh0Q2hhciA9PT0gJ1wiJykgfHxcbiAgICAoZXZlbnQua2V5ID09PSBcIidcIiAmJiBuZXh0Q2hhciA9PT0gXCInXCIpIHx8XG4gICAgKGV2ZW50LmtleSA9PT0gJ2AnICYmIG5leHRDaGFyID09PSAnYCcpXG4gICkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICBkaXN0YW5jZTogMSxcbiAgICAgIHVuaXQ6ICdjaGFyYWN0ZXInLFxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgIGVkaXRvci5pbnNlcnRCcmVhaygpXG5cbiAgICBpZiAob3BlbmluZ0NoYXJzLmluY2x1ZGVzKHByZXZDaGFyKSkge1xuICAgICAgZWRpdG9yLmluc2VydFRleHQoYCR7c3BhY2VzfSAgYClcblxuICAgICAgaWYgKGNsb3NpbmdDaGFycy5pbmNsdWRlcyhuZXh0Q2hhcikpIHtcbiAgICAgICAgZWRpdG9yLmluc2VydEJyZWFrKClcbiAgICAgICAgZWRpdG9yLmluc2VydFRleHQoc3BhY2VzKVxuICAgICAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7XG4gICAgICAgICAgZGlzdGFuY2U6IHNwYWNlcy5sZW5ndGggKyAxLFxuICAgICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgICAgdW5pdDogJ2NoYXJhY3RlcicsXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGVkaXRvci5pbnNlcnRUZXh0KHNwYWNlcylcblxuICAgIHJldHVyblxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyA9IChcbiAgZWRpdG9yOiBSZWFjdEVkaXRvcixcbiAgZG9tUmFuZ2U6IFJhbmdlXG4pID0+IHtcbiAgY29uc3QgZWwgPSBkb21SYW5nZS5zdGFydENvbnRhaW5lci5wYXJlbnRFbGVtZW50XG4gIGxldCBlZGl0b3JFbCA9IGRvbVJhbmdlLnN0YXJ0Q29udGFpbmVyLnBhcmVudEVsZW1lbnRcblxuICB3aGlsZSAoIWVkaXRvckVsLmRhdGFzZXQuc2xhdGVFZGl0b3IpIHtcbiAgICBlZGl0b3JFbCA9IGVkaXRvckVsLnBhcmVudEVsZW1lbnRcbiAgfVxuXG4gIGNvbnN0IGNoYXJXaWR0aCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gZWwuaW5uZXJUZXh0Lmxlbmd0aFxuXG4gIGNvbnN0IHByZXZQb3MgPSBlZGl0b3JFbC5zY3JvbGxMZWZ0XG4gIGRvbVJhbmdlLnN0YXJ0Q29udGFpbmVyLnBhcmVudEVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcoe1xuICAgIGJsb2NrOiAnbmVhcmVzdCcsXG4gIH0pXG5cbiAgaWYgKCFjaGFyV2lkdGgpIHtcbiAgICAvLyB0aGlzIG1lYW5zIHRoZSBjdXJyZW50IGxpbmUgaXMgZW1wdHkgLSBzZXQgc2Nyb2xsUG9zIHRvIHRoZSBmYXIgbGVmdFxuICAgIGVkaXRvckVsLnNjcm9sbExlZnQgPSAwXG4gICAgcmV0dXJuXG4gIH1cblxuICBjb25zdCB3aWR0aCA9IGVkaXRvckVsLmNsaWVudFdpZHRoXG4gIGNvbnN0IGNoYXJOdW0gPSBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLm9mZnNldFxuICBjb25zdCBvZmZzZXQgPSBjaGFyTnVtICogY2hhcldpZHRoXG4gIGNvbnN0IEJVRkZFUiA9IDI0XG5cbiAgaWYgKG9mZnNldCArIChCVUZGRVIgKyA4KSAtIHdpZHRoID4gcHJldlBvcykge1xuICAgIC8vIG1vdmUgcmlnaHRcbiAgICBlZGl0b3JFbC5zY3JvbGxMZWZ0ID0gb2Zmc2V0ICsgKEJVRkZFUiArIDgpIC0gd2lkdGhcbiAgfSBlbHNlIGlmIChvZmZzZXQgLSAoQlVGRkVSIC0gOCkgPCBwcmV2UG9zKSB7XG4gICAgLy8gbW92ZSBsZWZ0XG4gICAgZWRpdG9yRWwuc2Nyb2xsTGVmdCA9IG9mZnNldCAtIChCVUZGRVIgLSA4KVxuICB9IGVsc2Uge1xuICAgIGVkaXRvckVsLnNjcm9sbExlZnQgPSBwcmV2UG9zXG4gIH1cbn1cbiIsImltcG9ydCB7IHVzZVByaXNtVGhlbWUgfSBmcm9tICdAZG9jdXNhdXJ1cy90aGVtZS1jb21tb24nXG5pbXBvcnQgeyBFZGl0YWJsZSB9IGZyb20gJ3NsYXRlLXJlYWN0J1xuaW1wb3J0IHN0eWxlZCwgeyBjc3MgfSBmcm9tICdAc2l0ZS9zcmMvc3NjJ1xuXG5leHBvcnQgY29uc3QgRWRpdG9yV3JhcHBlciA9IHN0eWxlZC5kaXZgXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZmxvdzogcm93IG5vd3JhcDtcbiAgZm9udC1mYW1pbHk6ICdTb3VyY2UgQ29kZSBQcm8nLCBtb25vc3BhY2U7XG4gIGZvbnQtc2l6ZTogdmFyKC0taWZtLWNvZGUtZm9udC1zaXplKTtcbiAgbGV0dGVyLXNwYWNpbmc6IC0wLjJweDtcbiAgbWF4LWhlaWdodDogNTAwcHg7XG4gIG92ZXJmbG93LXk6IGF1dG87XG5gXG5cbmV4cG9ydCBjb25zdCBHdXR0ZXIgPSBzdHlsZWQuZGl2YFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiAxMnB4O1xuICBkaXNwbGF5OiBmbGV4O1xuICBmbGV4LWZsb3c6IGNvbHVtbiBub3dyYXA7XG4gIGhlaWdodDogZml0LWNvbnRlbnQ7XG4gIG1pbi1oZWlnaHQ6IDEwMCU7XG4gIG1pbi13aWR0aDogMS43cmVtO1xuICBwYWRkaW5nOiAwLjVyZW0gNXB4IDFyZW07XG4gIHRleHQtYWxpZ246IHJpZ2h0O1xuXG4gID4gc3BhbiB7XG4gICAgY29sb3I6ICNmZmZiO1xuICAgIHRyYW5zZm9ybTogc2NhbGUoMC44KTtcbiAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICB9XG5gXG5cbmV4cG9ydCBjb25zdCBIZWFkZXIgPSBzdHlsZWQuZGl2YFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xuICBiYWNrZ3JvdW5kOiAjZmZhMzU5O1xuICBib3JkZXItcmFkaXVzOiAxMnB4IDEycHggMCAwO1xuICBjb2xvcjogI2ZmZjtcbiAgZGlzcGxheTogZmxleDtcbiAgZmxleC1mbG93OiByb3cgbm93cmFwO1xuICBnYXA6IDFyZW07XG4gIGdyaWQtY29sdW1uOiBzcGFuIDI7XG4gIHBhZGRpbmc6IDAuNXJlbTtcblxuICA+IGltZyB7XG4gICAgZmlsdGVyOiBicmlnaHRuZXNzKDApIGludmVydCgxKTtcbiAgICBmb250LXNpemU6IDA7XG4gICAgaGVpZ2h0OiAxcmVtO1xuICB9XG5gXG5cbmV4cG9ydCBjb25zdCBIZWFkZXJBY3Rpb25zID0gc3R5bGVkLnNwYW5gXG4gIGRpc3BsYXk6IGZsZXg7XG4gIGZsZXgtZmxvdzogcm93IG5vd3JhcDtcbiAgZ2FwOiAxcmVtO1xuYFxuXG5leHBvcnQgY29uc3QgSGVhZGVyVGV4dCA9IHN0eWxlZC5zcGFuYFxuICBmbGV4OiAxO1xuYFxuXG5leHBvcnQgY29uc3QgUmVzZXRCdXR0b24gPSBzdHlsZWQuYnV0dG9uYFxuICBiYWNrZ3JvdW5kOiAjZmZmO1xuICBib3JkZXI6IG5vbmU7XG4gIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgY29sb3I6ICNmZjQ1NDU7XG4gIGN1cnNvcjogcG9pbnRlcjtcbiAgZm9udC1zaXplOiAwLjhlbTtcbiAgcGFkZGluZzogMnB4IDFyZW07XG5cbiAgJjpob3ZlciB7XG4gICAgYmFja2dyb3VuZDogI2ZmZmI7XG4gIH1cbmBcblxuZXhwb3J0IGNvbnN0IFJlc3VsdCA9IHN0eWxlZC5kaXZgXG4gIGJhY2tncm91bmQ6ICNmZmY7XG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiAxMnB4O1xuICBib3gtc2hhZG93OiBpbnNldCA0cHggNHB4IDZweCAjODg4O1xuICBjb2xvcjogIzFjMWUyMTtcbiAgY29sb3Itc2NoZW1lOiBsaWdodDtcbiAgbWF4LWhlaWdodDogNTAwcHg7XG4gIG92ZXJmbG93OiBhdXRvO1xuICBwYWRkaW5nOiAwLjVyZW07XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbmBcblxuZXhwb3J0IGNvbnN0IFN0eWxlZEVkaXRhYmxlID0gc3R5bGVkKEVkaXRhYmxlKTx7XG4gICRzc2NQcm9wczogUmV0dXJuVHlwZTx0eXBlb2YgdXNlUHJpc21UaGVtZT5cbn0+YFxuICBiYWNrZ3JvdW5kOiAjMmIzMTNhO1xuICBmbGV4OiAxO1xuICBoZWlnaHQ6IGZpdC1jb250ZW50O1xuICBtaW4taGVpZ2h0OiAxMDAlO1xuICBvdmVyZmxvdy14OiBhdXRvO1xuICBwYWRkaW5nOiAwLjVyZW0gMC41cmVtIDFyZW07XG4gIHdoaXRlLXNwYWNlOiBwcmUgIWltcG9ydGFudDtcblxuICA+IGRpdiB7XG4gICAgbWluLXdpZHRoOiBmaXQtY29udGVudDtcbiAgICBwYWRkaW5nLXJpZ2h0OiAwLjVyZW07XG4gIH1cblxuICAudG9rZW4ge1xuICAgIGNvbG9yOiAjZDdkZmVjO1xuXG4gICAgJHsoeyAkc3NjUHJvcHMgfSkgPT5cbiAgICAgICRzc2NQcm9wcy5zdHlsZXNcbiAgICAgICAgLm1hcCgoeyBzdHlsZSwgdHlwZXMgfSkgPT5cbiAgICAgICAgICB0eXBlc1xuICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgdHlwZSA9PlxuICAgICAgICAgICAgICAgIGAmLiR7dHlwZX0geyAke2NzcyhcbiAgICAgICAgICAgICAgICAgIHN0eWxlIGFzIGFueSAvKiBQcmlzbSBmb250LXdlaWdodCB0eXBlIGlzIHdyb25nICovXG4gICAgICAgICAgICAgICAgKX0gfWBcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKVxuICAgICAgICApXG4gICAgICAgIC5qb2luKCdcXG4nKX1cblxuICAgICYuY29tbWVudCB7XG4gICAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gICAgfVxuXG4gICAgJi5rZXl3b3JkIHtcbiAgICAgIGNvbG9yOiAjZTA4YTU3O1xuICAgIH1cbiAgfVxuYFxuXG5leHBvcnQgY29uc3QgV3JhcHBlciA9IHN0eWxlZC5zZWN0aW9uYFxuICBiYWNrZ3JvdW5kOiAjNDc0YzU0O1xuICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICBib3gtc2hhZG93OiAxMHB4IDEwcHggN3B4IHJnYmEoMCwgMCwgMCwgMC40KTtcbiAgZGlzcGxheTogZ3JpZDtcbiAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiBtaW5tYXgoMTgwcHgsIDlmcikgbWlubWF4KDE0MHB4LCA1ZnIpO1xuICBncmlkLXRlbXBsYXRlLXJvd3M6IGF1dG8gYXV0bztcbiAgbGluZS1oZWlnaHQ6IDEuNDU7XG4gIG1hcmdpbjogMCAtMC42cmVtIDJlbTtcblxuICBAbWVkaWEgKG1pbi13aWR0aDogMTYwMHB4KSB7XG4gICAgbWFyZ2luLWxlZnQ6IC0xLjhyZW07XG4gICAgbWFyZ2luLXJpZ2h0OiAtMS44cmVtO1xuICB9XG5gXG4iLCJpbXBvcnQgeyB1c2VQcmlzbVRoZW1lIH0gZnJvbSAnQGRvY3VzYXVydXMvdGhlbWUtY29tbW9uJ1xuaW1wb3J0IHVzZURvY3VzYXVydXNDb250ZXh0IGZyb20gJ0Bkb2N1c2F1cnVzL3VzZURvY3VzYXVydXNDb250ZXh0J1xuaW1wb3J0IFByaXNtIGZyb20gJ3ByaXNtanMnXG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1qc3gnXG5pbXBvcnQgJ3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS10eXBlc2NyaXB0J1xuaW1wb3J0ICdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tdHN4J1xuaW1wb3J0IFJlYWN0LCB7XG4gIE11dGFibGVSZWZPYmplY3QsXG4gIHVzZUNhbGxiYWNrLFxuICB1c2VFZmZlY3QsXG4gIHVzZU1lbW8sXG4gIHVzZVJlZixcbiAgdXNlU3RhdGUsXG59IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHtcbiAgVGV4dCxcbiAgY3JlYXRlRWRpdG9yLFxuICBEZXNjZW5kYW50LFxuICBCYXNlRWxlbWVudCxcbiAgRWxlbWVudCxcbiAgTm9kZUVudHJ5LFxuICBQYXRoLFxuICBCYXNlUmFuZ2UsXG4gIFJhbmdlLFxufSBmcm9tICdzbGF0ZSdcbmltcG9ydCB7IHdpdGhIaXN0b3J5IH0gZnJvbSAnc2xhdGUtaGlzdG9yeSdcbmltcG9ydCB7IFNsYXRlLCB3aXRoUmVhY3QsIFJlYWN0RWRpdG9yLCBSZW5kZXJMZWFmUHJvcHMgfSBmcm9tICdzbGF0ZS1yZWFjdCdcbmltcG9ydCAqIGFzIFJlYWN0SW1tZXIgZnJvbSAnLi4vLi4vLi4vLi4vcGFja2FnZXMvaW1tZXIvc3JjJ1xuaW1wb3J0ICogYXMgUmVhY3RaZWR1eCBmcm9tICcuLi8uLi8uLi8uLi9wYWNrYWdlcy9yZWFjdC9zcmMnXG5pbXBvcnQgeyBMb2dBY3Rpb25zIH0gZnJvbSAnLi9Mb2dBY3Rpb25zJ1xuaW1wb3J0IHsgb25LZXlEb3duLCBzY3JvbGxTZWxlY3Rpb25JbnRvVmlldyB9IGZyb20gJy4vZWRpdG9yVXRpbHMnXG5pbXBvcnQge1xuICBFZGl0b3JXcmFwcGVyLFxuICBHdXR0ZXIsXG4gIEhlYWRlcixcbiAgSGVhZGVyQWN0aW9ucyxcbiAgSGVhZGVyVGV4dCxcbiAgUmVzZXRCdXR0b24sXG4gIFJlc3VsdCxcbiAgU3R5bGVkRWRpdGFibGUsXG4gIFdyYXBwZXIsXG59IGZyb20gJy4vc3R5bGVzJ1xuXG5kZWNsYXJlIG1vZHVsZSAnc2xhdGUnIHtcbiAgaW50ZXJmYWNlIEN1c3RvbVR5cGVzIHtcbiAgICAvLyA/PyBzbGF0ZSdzIHR5cGVzIHdyb25nLi5cbiAgICBFbGVtZW50OiB7IHR5cGU6IHN0cmluZyB9ICYgQmFzZUVsZW1lbnRcbiAgICBFZGl0b3I6IFJlYWN0RWRpdG9yXG4gICAgVGV4dDogeyB0ZXh0OiBzdHJpbmc7IHRva2VuVHlwZT86IHN0cmluZyB9XG4gICAgUmFuZ2U6IHsgdG9rZW5UeXBlPzogc3RyaW5nIH0gJiBCYXNlUmFuZ2VcbiAgfVxufVxuXG5jb25zdCBaZWR1eCA9IHsgLi4uUmVhY3RaZWR1eCwgLi4uUmVhY3RJbW1lciB9IC8vIHJlc29sdmVzIGFsbCB0aGUgZ2V0dGVyc1xuXG5jb25zdCBzY29wZSA9IHtcbiAgLi4uWmVkdXgsXG4gIC4uLlJlYWN0LFxufVxuY29uc3Qgc2NvcGVLZXlzID0gT2JqZWN0LmtleXMoc2NvcGUpXG5jb25zdCBzY29wZVZhbHVlcyA9IHNjb3BlS2V5cy5tYXAoa2V5ID0+IHNjb3BlW2tleV0pXG5cbmNvbnN0IGRlY29yYXRlVG9rZW5zID0gKFxuICBwYXRoOiBQYXRoLFxuICB0b2tlbnM6IFJldHVyblR5cGU8dHlwZW9mIFByaXNtLnRva2VuaXplPixcbiAgcGFyYW1zOiB7IHJhbmdlczogUmFuZ2VbXTsgc3RhcnQ6IG51bWJlciB9LFxuICBwYXJlbnRUeXBlPzogc3RyaW5nXG4pID0+IHtcbiAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICBjb25zdCBlbmQgPSBwYXJhbXMuc3RhcnQgKyB0b2tlbi5sZW5ndGhcblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICBpZiAocGFyZW50VHlwZSkge1xuICAgICAgICBwYXJhbXMucmFuZ2VzLnB1c2goe1xuICAgICAgICAgIGFuY2hvcjogeyBwYXRoLCBvZmZzZXQ6IHBhcmFtcy5zdGFydCB9LFxuICAgICAgICAgIGZvY3VzOiB7IHBhdGgsIG9mZnNldDogZW5kIH0sXG4gICAgICAgICAgdG9rZW5UeXBlOiBwYXJlbnRUeXBlLFxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBwYXJhbXMuc3RhcnQgPSBlbmRcblxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRva2VuLmNvbnRlbnQgPT09ICdzdHJpbmcnIHx8ICFBcnJheS5pc0FycmF5KHRva2VuLmNvbnRlbnQpKSB7XG4gICAgICBwYXJhbXMucmFuZ2VzLnB1c2goe1xuICAgICAgICBhbmNob3I6IHsgcGF0aCwgb2Zmc2V0OiBwYXJhbXMuc3RhcnQgfSxcbiAgICAgICAgZm9jdXM6IHsgcGF0aCwgb2Zmc2V0OiBlbmQgfSxcbiAgICAgICAgdG9rZW5UeXBlOiB0b2tlbi50eXBlLFxuICAgICAgfSlcblxuICAgICAgcGFyYW1zLnN0YXJ0ID0gZW5kXG5cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgZGVjb3JhdGVUb2tlbnMocGF0aCwgdG9rZW4uY29udGVudCwgcGFyYW1zLCB0b2tlbi50eXBlKVxuICB9XG5cbiAgcmV0dXJuIHBhcmFtcy5yYW5nZXNcbn1cblxuY29uc3QgZGVjb3JhdGUgPSAoW25vZGUsIHBhdGhdOiBOb2RlRW50cnkpID0+IHtcbiAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgY29uc3QgdG9rZW5zID0gUHJpc20udG9rZW5pemUobm9kZS50ZXh0LCBQcmlzbS5sYW5ndWFnZXMudHN4KVxuXG4gIHJldHVybiBkZWNvcmF0ZVRva2VucyhwYXRoLCB0b2tlbnMsIHsgcmFuZ2VzOiBbXSwgc3RhcnQ6IDAgfSlcbn1cblxuY29uc3QgZXZhbENvZGUgPSAoXG4gIGNvZGU6IHN0cmluZyxcbiAgcmVzdWx0VmFyTmFtZTogc3RyaW5nLFxuICBlY29zeXN0ZW1JZFJlZj86IE11dGFibGVSZWZPYmplY3Q8c3RyaW5nPixcbiAgZXh0cmFTY29wZT86IFJlY29yZDxzdHJpbmcsIGFueT5cbikgPT4ge1xuICBjb25zdCByZXN1bHRTdHIgPSBgdmFyICR7cmVzdWx0VmFyTmFtZX07ICR7Y29kZX07IHZhciBfJF8kcmVzID0gdHlwZW9mICR7cmVzdWx0VmFyTmFtZX0gPT09ICdmdW5jdGlvbicgPyBSZWFjdC5jcmVhdGVFbGVtZW50KCR7cmVzdWx0VmFyTmFtZX0pIDogdHlwZW9mICR7cmVzdWx0VmFyTmFtZX0gPT09ICdzdHJpbmcnID8gJHtyZXN1bHRWYXJOYW1lfSA6IFJlYWN0LmNyZWF0ZUVsZW1lbnQoJ3ByZScsIG51bGwsIEpTT04uc3RyaW5naWZ5KCR7cmVzdWx0VmFyTmFtZX0sIG51bGwsIDIpKTtgXG4gIGNvbnN0IHdyYXBwZWQgPSBgJHtyZXN1bHRTdHJ9IHJldHVybiBfJF8kcmVzYFxuXG4gIGNvbnN0IGV4dHJhU2NvcGVLZXlzID0gZXh0cmFTY29wZSA/IFsuLi5PYmplY3Qua2V5cyhleHRyYVNjb3BlKV0gOiBbXVxuICBjb25zdCBrZXlzID0gZXh0cmFTY29wZSA/IFsuLi5zY29wZUtleXMsIC4uLmV4dHJhU2NvcGVLZXlzXSA6IHNjb3BlS2V5c1xuICBjb25zdCB2YWxzID0gZXh0cmFTY29wZVxuICAgID8gWy4uLnNjb3BlVmFsdWVzLCAuLi5leHRyYVNjb3BlS2V5cy5tYXAoa2V5ID0+IGV4dHJhU2NvcGVba2V5XSldXG4gICAgOiBzY29wZVZhbHVlc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICBjb25zdCBmbiA9IG5ldyBGdW5jdGlvbignUmVhY3QnLCAuLi5rZXlzLCB3cmFwcGVkKVxuXG4gIGNvbnN0IGVjb3N5c3RlbXNCZWZvcmUgPSBSZWFjdFplZHV4LmludGVybmFsU3RvcmUuZ2V0U3RhdGUoKVxuICBjb25zdCByZXN1bHQgPSBmbi5jYWxsKG51bGwsIFJlYWN0LCAuLi52YWxzKVxuICBjb25zdCBlY29zeXN0ZW1zQWZ0ZXIgPSBSZWFjdFplZHV4LmludGVybmFsU3RvcmUuZ2V0U3RhdGUoKVxuXG4gIGlmICghZWNvc3lzdGVtSWRSZWYuY3VycmVudCkge1xuICAgIE9iamVjdC5rZXlzKGVjb3N5c3RlbXNBZnRlcikuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKCFlY29zeXN0ZW1zQmVmb3JlW2tleV0pIGVjb3N5c3RlbUlkUmVmLmN1cnJlbnQgPSBrZXlcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5jb25zdCBwYXJzZSA9ICh0ZXh0OiBzdHJpbmcpOiBEZXNjZW5kYW50W10gPT5cbiAgdGV4dFxuICAgIC5zcGxpdCgnXFxuJylcbiAgICAuc2xpY2UoMCwgLTEpXG4gICAgLm1hcChsaW5lID0+ICh7XG4gICAgICB0eXBlOiAncGFyYWdyYXBoJyxcbiAgICAgIGNoaWxkcmVuOiBbeyB0ZXh0OiBsaW5lIH1dLFxuICAgIH0pKVxuXG5jb25zdCBzZXJpYWxpemUgPSAobm9kZXM6IERlc2NlbmRhbnRbXSkgPT5cbiAgbm9kZXNcbiAgICAubWFwKG5vZGUgPT5cbiAgICAgIChub2RlIGFzIEVsZW1lbnQpLmNoaWxkcmVuLm1hcChjaGlsZCA9PiAoY2hpbGQgYXMgVGV4dCkudGV4dCkuam9pbignJylcbiAgICApXG4gICAgLmpvaW4oJ1xcbicpXG5cbmNsYXNzIEVycm9yQm91bmRhcnkgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQ8YW55LCB7IGhhc0Vycm9yOiBib29sZWFuIH0+IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLnN0YXRlID0geyBoYXNFcnJvcjogZmFsc2UgfVxuICB9XG5cbiAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7IGhhc0Vycm9yOiBmYWxzZSB9KVxuICB9XG5cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpIHtcbiAgICByZXR1cm4geyBoYXNFcnJvcjogdHJ1ZSB9XG4gIH1cblxuICByZW5kZXIoKTogYW55IHtcbiAgICAvLyBpZGsgeVxuICAgIGlmICh0aGlzLnN0YXRlLmhhc0Vycm9yKSB7XG4gICAgICByZXR1cm4gPHNwYW4+Li4uPC9zcGFuPlxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuIHx8IDxzcGFuIC8+XG4gIH1cbn1cblxuY29uc3QgTGVhZiA9ICh7IGF0dHJpYnV0ZXMsIGNoaWxkcmVuLCBsZWFmIH06IFJlbmRlckxlYWZQcm9wcykgPT4ge1xuICByZXR1cm4gKFxuICAgIDxzcGFuIGNsYXNzTmFtZT17YHRva2VuICR7bGVhZi50b2tlblR5cGUgfHwgJyd9YH0gey4uLmF0dHJpYnV0ZXN9PlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvc3Bhbj5cbiAgKVxufVxuXG5leHBvcnQgY29uc3QgU2FuZGJveCA9ICh7XG4gIGNoaWxkcmVuLFxuICBlY29zeXN0ZW1JZCxcbiAgZXh0cmFTY29wZSxcbiAgcmVzdWx0VmFyID0gJ1Jlc3VsdCcsXG59OiB7XG4gIGNoaWxkcmVuOiBzdHJpbmdcbiAgZWNvc3lzdGVtSWQ/OiBzdHJpbmdcbiAgZXh0cmFTY29wZT86IHN0cmluZyB8IFJlY29yZDxzdHJpbmcsIGFueT5cbiAgcmVzdWx0VmFyPzogc3RyaW5nXG59KSA9PiB7XG4gIGNvbnN0IHsgYmFzZVVybCB9ID0gdXNlRG9jdXNhdXJ1c0NvbnRleHQoKS5zaXRlQ29uZmlnXG4gIGNvbnN0IGVkaXRvciA9IHVzZU1lbW8oKCkgPT4gd2l0aEhpc3Rvcnkod2l0aFJlYWN0KGNyZWF0ZUVkaXRvcigpKSksIFtdKVxuICBjb25zdCBpbml0aWFsVmFsdWUgPSB1c2VNZW1vKCgpID0+IHBhcnNlKGNoaWxkcmVuKSwgW10pXG4gIGNvbnN0IFt2YWx1ZSwgc2V0VmFsdWVdID0gdXNlU3RhdGUoaW5pdGlhbFZhbHVlKVxuICBjb25zdCBbcmVzdWx0LCBzZXRSZXN1bHRdID0gdXNlU3RhdGUoJycpXG4gIGNvbnN0IHRoZW1lID0gdXNlUHJpc21UaGVtZSgpXG4gIGNvbnN0IGVjb3N5c3RlbUlkUmVmID0gdXNlUmVmKGVjb3N5c3RlbUlkKVxuICBjb25zdCBsYXN0TG9nZ2VkRXJyb3JUaW1lUmVmID0gdXNlUmVmPG51bWJlciB8IHVuZGVmaW5lZD4oKVxuICBjb25zdCBpc01vdW50ZWRSZWYgPSB1c2VSZWYodHJ1ZSlcblxuICBjb25zdCBydW5Db2RlID0gdXNlQ2FsbGJhY2soXG4gICAgKHJhd1ZhbDogRGVzY2VuZGFudFtdKSA9PiB7XG4gICAgICBjb25zdCB2YWwgPSBzZXJpYWxpemUocmF3VmFsKVxuXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBleHRyYVNjb3BlU3RyID0gdHlwZW9mIGV4dHJhU2NvcGUgPT09ICdzdHJpbmcnID8gZXh0cmFTY29wZSA6ICcnXG4gICAgICAgIGNvbnN0IGpzQ29kZSA9ICh3aW5kb3cgYXMgYW55KT8udHMudHJhbnNwaWxlKFxuICAgICAgICAgIGAke2V4dHJhU2NvcGVTdHJ9OyAke3ZhbH1gLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGpzeDogJ3JlYWN0JyxcbiAgICAgICAgICB9XG4gICAgICAgIClcblxuICAgICAgICBpZiAoIWpzQ29kZSkgcmV0dXJuXG5cbiAgICAgICAgY29uc3QgZWNvc3lzdGVtID0gWmVkdXguZ2V0RWNvc3lzdGVtKGVjb3N5c3RlbUlkUmVmLmN1cnJlbnQpXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhlY29zeXN0ZW0/Ll9pbnN0YW5jZXMgfHwge30pLmxlbmd0aCkge1xuICAgICAgICAgIGVjb3N5c3RlbT8ud2lwZSgpXG4gICAgICAgICAgZWNvc3lzdGVtPy5zZXRPdmVycmlkZXMoW10pXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBldmFsUmVzdWx0ID0gZXZhbENvZGUoXG4gICAgICAgICAganNDb2RlLFxuICAgICAgICAgIHJlc3VsdFZhcixcbiAgICAgICAgICBlY29zeXN0ZW1JZFJlZixcbiAgICAgICAgICB0eXBlb2YgZXh0cmFTY29wZSA9PT0gJ3N0cmluZycgPyB1bmRlZmluZWQgOiBleHRyYVNjb3BlXG4gICAgICAgIClcblxuICAgICAgICBsYXN0TG9nZ2VkRXJyb3JUaW1lUmVmLmN1cnJlbnQgPSB1bmRlZmluZWRcblxuICAgICAgICBpZiAoaXNNb3VudGVkUmVmLmN1cnJlbnQpIHNldFJlc3VsdChldmFsUmVzdWx0KVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmIChpc01vdW50ZWRSZWYuY3VycmVudCkgc2V0UmVzdWx0KGVyci5tZXNzYWdlKVxuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBsYXN0TG9nZ2VkRXJyb3JUaW1lUmVmLmN1cnJlbnQgJiZcbiAgICAgICAgICBEYXRlLm5vdygpIC0gbGFzdExvZ2dlZEVycm9yVGltZVJlZi5jdXJyZW50IDwgNTAwMCAvLyBvbmx5IGxvZyBlcnJvcnMgb25jZSBldmVyeSA1IHNlY29uZHNcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmVycm9yKCdMaXZlIFNhbmRib3ggZXJyb3I6JywgZXJyKVxuICAgICAgICBsYXN0TG9nZ2VkRXJyb3JUaW1lUmVmLmN1cnJlbnQgPSBEYXRlLm5vdygpXG4gICAgICB9XG4gICAgfSxcbiAgICBbZWNvc3lzdGVtSWQsIGV4dHJhU2NvcGUsIHJlc3VsdFZhcl1cbiAgKVxuXG4gIC8vIHJ1biBpbml0aWFsIGNvZGUgb24gbW91bnQgKG9yIGlmIHJ1bkNvZGUgY2hhbmdlcyAtIHNob3VsZG4ndCBoYXBwZW4pXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgcnVuQ29kZSh2YWx1ZSlcbiAgfSwgW3J1bkNvZGVdKVxuXG4gIGNvbnN0IHNsYXRlID0gKFxuICAgIDxTbGF0ZVxuICAgICAgZWRpdG9yPXtlZGl0b3J9XG4gICAgICBvbkNoYW5nZT17bmV3VmFsdWUgPT4ge1xuICAgICAgICBpZiAobmV3VmFsdWUgPT09IHZhbHVlKSByZXR1cm5cblxuICAgICAgICBzZXRWYWx1ZShuZXdWYWx1ZSlcbiAgICAgICAgcnVuQ29kZShuZXdWYWx1ZSlcbiAgICAgIH19XG4gICAgICB2YWx1ZT17dmFsdWV9XG4gICAgPlxuICAgICAgPFdyYXBwZXI+XG4gICAgICAgIDxIZWFkZXI+XG4gICAgICAgICAgPGltZyBzcmM9e2Ake2Jhc2VVcmx9aW1nL3plZHV4LWljb24tNzV4NzUucG5nYH0gLz5cbiAgICAgICAgICA8SGVhZGVyVGV4dD5MaXZlIFNhbmRib3g8L0hlYWRlclRleHQ+XG4gICAgICAgICAgPEhlYWRlckFjdGlvbnM+XG4gICAgICAgICAgICA8TG9nQWN0aW9ucyBlY29zeXN0ZW1JZFJlZj17ZWNvc3lzdGVtSWRSZWZ9IFplZHV4PXtaZWR1eH0gLz5cbiAgICAgICAgICAgIDxSZXNldEJ1dHRvblxuICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VmFsdWUoaW5pdGlhbFZhbHVlKVxuICAgICAgICAgICAgICAgIHJ1bkNvZGUoaW5pdGlhbFZhbHVlKVxuICAgICAgICAgICAgICAgIGVkaXRvci5jaGlsZHJlbiA9IGluaXRpYWxWYWx1ZVxuICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICBSZXNldFxuICAgICAgICAgICAgPC9SZXNldEJ1dHRvbj5cbiAgICAgICAgICA8L0hlYWRlckFjdGlvbnM+XG4gICAgICAgIDwvSGVhZGVyPlxuICAgICAgICA8RWRpdG9yV3JhcHBlcj5cbiAgICAgICAgICA8R3V0dGVyPlxuICAgICAgICAgICAge3ZhbHVlLm1hcCgoXywgaSkgPT4gKFxuICAgICAgICAgICAgICA8c3BhbiBrZXk9e2l9PntpICsgMX08L3NwYW4+XG4gICAgICAgICAgICApKX1cbiAgICAgICAgICA8L0d1dHRlcj5cbiAgICAgICAgICA8U3R5bGVkRWRpdGFibGVcbiAgICAgICAgICAgIGRlY29yYXRlPXtkZWNvcmF0ZX1cbiAgICAgICAgICAgIG9uS2V5RG93bj17ZXZlbnQgPT4gb25LZXlEb3duKGVkaXRvciwgZXZlbnQpfVxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJXcml0ZSBzb21lIGNvZGUuLi5cIlxuICAgICAgICAgICAgcmVuZGVyTGVhZj17TGVhZn1cbiAgICAgICAgICAgIHNjcm9sbFNlbGVjdGlvbkludG9WaWV3PXtzY3JvbGxTZWxlY3Rpb25JbnRvVmlld31cbiAgICAgICAgICAgICRzc2NQcm9wcz17dGhlbWV9XG4gICAgICAgICAgLz5cbiAgICAgICAgPC9FZGl0b3JXcmFwcGVyPlxuICAgICAgICA8UmVzdWx0PlxuICAgICAgICAgIDxFcnJvckJvdW5kYXJ5PntyZXN1bHR9PC9FcnJvckJvdW5kYXJ5PlxuICAgICAgICA8L1Jlc3VsdD5cbiAgICAgIDwvV3JhcHBlcj5cbiAgICA8L1NsYXRlPlxuICApXG5cbiAgcmV0dXJuIGVjb3N5c3RlbUlkUmVmLmN1cnJlbnQgPyAoXG4gICAgPFplZHV4LkVjb3N5c3RlbVByb3ZpZGVyIGlkPXtlY29zeXN0ZW1JZH0+e3NsYXRlfTwvWmVkdXguRWNvc3lzdGVtUHJvdmlkZXI+XG4gICkgOiAoXG4gICAgc2xhdGVcbiAgKVxufVxuIl0sIm5hbWVzIjpbIlN0b3JlIiwicHJvZHVjZSIsIkltbWVyU3RvcmUiLCJpbml0aWFsU3RhdGUiLCJyZWNpcGUiLCJzZXRTdGF0ZSIsImdldFN0YXRlIiwiZHJhZnQiLCJjcmVhdGVJbW1lclN0b3JlIiwiY3JlYXRlSW5qZWN0b3IiLCJpbnRlcm5hbFR5cGVzIiwib3BlcmF0aW9uIiwiZG9TdWJzY3JpYmUiLCJpbnN0YW5jZSIsInN0b3JlIiwic3Vic2NyaWJlIiwiZWZmZWN0cyIsImFjdGlvbiIsIm5ld1N0YXRlIiwib2xkU3RhdGUiLCJlY29zeXN0ZW0iLCJfZXZhbHVhdGlvblN0YWNrIiwiaXNFdmFsdWF0aW5nIiwia2V5SGFzaCIsIm1ldGEiLCJpZ25vcmUiLCJfc2NoZWR1bGVFdmFsdWF0aW9uIiwicmVhc29ucyIsInNvdXJjZVR5cGUiLCJ0eXBlIiwiX3NjaGVkdWxlciIsImZsdXNoIiwiaW5qZWN0SW1tZXJTdG9yZSIsInN0YXRlIiwiY29uZmlnIiwiaHlkcmF0aW9uIiwiX2NvbnN1bWVIeWRyYXRpb24iLCJzdWJzY3JpcHRpb24iLCJjbGVhbnVwIiwidW5zdWJzY3JpYmUiLCJ1bmRlZmluZWQiLCJyZXN1bHQiLCJwcmV2RGVzY3JpcHRvciIsInByZXZzdWJzY3JpYmUiLCJleHRyYWN0QWN0aW9uVHlwZSIsInJlYWN0YWJsZSIsIm1ldGhvZCIsIkRFViIsIlR5cGVFcnJvciIsImV4dHJhY3RBY3Rpb25UeXBlcyIsInJlYWN0YWJsZXMiLCJtYXAiLCJjcmVhdGVSZWR1Y2VyIiwiYWN0aW9uVG9SZWR1Y2Vyc01hcCIsInJlZHVjZXIiLCJyZWR1Y2VycyIsInJ1blJlZHVjZXJzIiwicmVkdWNlIiwic3ViUmVkdWNlciIsImFjdGlvblR5cGVzIiwiQXJyYXkiLCJpc0FycmF5IiwibWFwQWN0aW9uVHlwZXNUb1JlZHVjZXIiLCJjb25zdW1lciIsImZvckVhY2giLCJhY3Rpb25UeXBlIiwicHVzaCIsImFjY3VtdWxhdGVkU3RhdGUiLCJwYXlsb2FkIiwiTWFjaGluZVN0b3JlIiwic3RhdGVzIiwiaW5pdGlhbENvbnRleHQiLCJndWFyZCIsImNvbnRleHQiLCJ2YWx1ZSIsImdldENvbnRleHQiLCJnZXRWYWx1ZSIsImlzIiwic3RhdGVOYW1lIiwic2VuZCIsImV2ZW50TmFtZSIsImN1cnJlbnRTdGF0ZSIsIm5leHRWYWx1ZSIsIm5hbWUiLCJzZXRDb250ZXh0Iiwic2V0Q29udGV4dERlZXAiLCJwYXJ0aWFsQ29udGV4dCIsInNldFN0YXRlRGVlcCIsIklvbiIsImlvbiIsImtleSIsImdldCIsInJlYWRJbnN0YW5jZSIsImluamVjdEF0b21HZXR0ZXJzIiwiYXRvbUdldHRlcnMiLCJBdG9tSW5zdGFuY2UiLCJBdG9tQmFzZSIsInN0YXRlRmFjdG9yeSIsIl9jb25maWciLCJwYXJhbXMiLCJfZ2V0IiwiX2NyZWF0ZUluc3RhbmNlIiwiZ2V0S2V5SGFzaCIsImJhc2UiLCJsZW5ndGgiLCJfaWRHZW5lcmF0b3IiLCJoYXNoUGFyYW1zIiwiY29tcGxleFBhcmFtcyIsIm92ZXJyaWRlIiwibmV3R2V0IiwiY3JlYXRlU3RvcmUiLCJwbHVnaW5BY3Rpb25zIiwiWmVkdXhQbHVnaW4iLCJpbml0aWFsTW9kcyIsInJlZ2lzdGVyRWNvc3lzdGVtIiwibW9kU3RvcmUiLCJhY3Rpb25zIiwiUmVhY3QiLCJ1c2VFY29zeXN0ZW0iLCJBdG9tSW5zdGFuY2VQcm92aWRlciIsImNoaWxkcmVuIiwiaW5zdGFuY2VzIiwiRXJyb3IiLCJhbGxJbnN0YW5jZXMiLCJfZ2V0UmVhY3RDb250ZXh0IiwiYXRvbSIsInBhcmVudEluc3RhbmNlIiwiY2hpbGRJbnN0YW5jZXMiLCJ1c2VNZW1vIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJjcmVhdGVFY29zeXN0ZW0iLCJlY29zeXN0ZW1Db250ZXh0IiwiRWNvc3lzdGVtUHJvdmlkZXIiLCJwYXNzZWRFY29zeXN0ZW0iLCJlY29zeXN0ZW1Db25maWciLCJyZXNvbHZlZEVjb3N5c3RlbSIsImRlc3Ryb3lPblVubW91bnQiLCJfaW5jcmVtZW50UmVmQ291bnQiLCJfZGVjcmVtZW50UmVmQ291bnQiLCJpZCIsImdldFNuYXBzaG90IiwidXNlQ29udGV4dCIsIkF0b21JbnN0YW5jZUJhc2UiLCJ1c2VBdG9tQ29uc3VtZXIiLCJkZWZhdWx0UGFyYW1zIiwiYWN0aXZlU3RhdGUiLCJSZWZlcmVuY2VFcnJvciIsImdldEluc3RhbmNlIiwidXNlUmVmIiwiZGVzdHJveWVkIiwiRXh0ZXJuYWwiLCJoYXZlRGVwc0NoYW5nZWQiLCJ1c2VSZWFjdENvbXBvbmVudElkIiwiZ2xvYiIsImdsb2JhbFRoaXMiLCJJTlZBTElEQVRFX1JFQUNUIiwiTWF0aCIsInJhbmRvbSIsIk9QRVJBVElPTiIsImlzUmVmRGlmZmVyZW50IiwibmV3U2VsZWN0b3IiLCJjYWNoZVJlZiIsImN1cnJlbnQiLCJvbGRTZWxlY3RvciIsInNlbGVjdG9yUmVmIiwiZGVwZW5kZW50cyIsIl9ncmFwaCIsIm5vZGVzIiwiY2FjaGVLZXkiLCJPYmplY3QiLCJrZXlzIiwibmV3SXNGdW5jdGlvbiIsIm9sZElzRnVuY3Rpb24iLCJuZXdLZXkiLCJzZWxlY3RvckNhY2hlIiwiX2dldElkZWFsQ2FjaGVLZXkiLCJvbGRLZXkiLCJyZXN1bHRzQ29tcGFyYXRvciIsIm5ld1Jlc3VsdHNDb21wYXJhdG9yU3RyIiwidG9TdHJpbmciLCJvbGRSZXN1bHRzQ29tcGFyYXRvclN0ciIsInNlbGVjdG9yIiwibmV3UmVmU3RyIiwib2xkUmVmU3RyIiwidXNlQXRvbVNlbGVjdG9yIiwic2VsZWN0b3JPckNvbmZpZyIsImRlcGVuZGVudEtleSIsInNraXBTdGF0ZSIsImlzQ29uZmlnIiwiYXJncyIsImFyZ3NDaGFuZ2VkIiwiYXJnc0NvbXBhcmF0b3IiLCJyZXNvbHZlZEFyZ3MiLCJoYXNSZWZDaGFuZ2VkIiwiaXNEaWZmZXJlbnQiLCJnZXRDYWNoZSIsImNhY2hlIiwiaXNJbnZhbGlkYXRlZCIsIm9uU3RvcmVDaGFuZ2UiLCJJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQiLCJpc0Rlc3Ryb3llZCIsImFkZEVkZ2UiLCJzaWduYWwiLCJyZW1vdmVFZGdlIiwiX3N3YXBSZWZzIiwidXNlQXRvbUluc3RhbmNlIiwidXNlQXRvbVN0YXRlIiwiX2luZnVzZWRTZXR0ZXIiLCJ1c2VBdG9tVmFsdWUiLCJwcmVmaXgiLCJTdGF0aWMiLCJkZWZhdWx0T3BlcmF0aW9uIiwiaW5qZWN0QXRvbUluc3RhbmNlIiwiaW5qZWN0ZWRJbnN0YW5jZSIsImluamVjdEF0b21TZWxlY3RvciIsInNlbGVjdGFibGUiLCJzZWxlY3QiLCJpbmplY3RBdG9tU3RhdGUiLCJzZXR0YWJsZSIsImFzc2lnbiIsImV4cG9ydHMiLCJpbmplY3RBdG9tVmFsdWUiLCJpbmplY3RNZW1vIiwidmFsdWVGYWN0b3J5IiwiZGVwcyIsImRlcHNIYXZlQ2hhbmdlZCIsImluamVjdENhbGxiYWNrIiwiY2FsbGJhY2siLCJpbmplY3RJbnZhbGlkYXRlIiwiaW52YWxpZGF0ZSIsImluamVjdE1hY2hpbmVTdG9yZSIsInN0YXRlc0ZhY3RvcnkiLCJlbnRlckhvb2tzIiwibGVhdmVIb29rcyIsImNyZWF0ZVN0YXRlIiwib24iLCJuZXh0U3RhdGUiLCJvbkVudGVyIiwib25MZWF2ZSIsImh5ZHJhdGUiLCJzdG9yZUVmZmVjdCIsIm9uVHJhbnNpdGlvbiIsInVwZGF0ZXJTdWIiLCJkZXNjcmlwdG9yIiwiY2xlYW51cFVwZGF0ZXIiLCJkZXRhaWxlZFR5cGVvZiIsImFwaSIsImdldEVycm9yUHJvbWlzZVN0YXRlIiwiZ2V0SW5pdGlhbFByb21pc2VTdGF0ZSIsImdldFN1Y2Nlc3NQcm9taXNlU3RhdGUiLCJpbmplY3RFZmZlY3QiLCJpbmplY3RTdG9yZSIsImluamVjdFJlZiIsImluamVjdFByb21pc2UiLCJwcm9taXNlRmFjdG9yeSIsImRhdGFPbmx5Iiwic3RvcmVDb25maWciLCJyZWZzIiwicHJvbWlzZSIsInByZXZDb250cm9sbGVyIiwiY29udHJvbGxlciIsIm5leHRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwidGhlbiIsImFib3J0IiwiZGF0YSIsImFib3J0ZWQiLCJjYXRjaCIsImVycm9yIiwic2V0UHJvbWlzZSIsImluamVjdFdoeSIsIl9uZXh0RXZhbHVhdGlvblJlYXNvbnMiLCJ1c2VTdGF0ZSIsInN0eWxlZCIsIm9wdGlvbnMiLCJBdG9tU3RhdGUiLCJTZWxlY3RvckNhY2hlIiwiRWNvc3lzdGVtIiwiR3JhcGgiLCJTY29wZSIsIkJhY2tkcm9wIiwiZGl2IiwiQnV0dG9uIiwiYnV0dG9uIiwiRHJvcGRvd24iLCJPcHRpb24iLCJzcGFuIiwiT3B0aW9ucyIsIldyYXBwZXIiLCJDYXJldERvd25JY29uIiwiTG9nQWN0aW9ucyIsImVjb3N5c3RlbUlkUmVmIiwiWmVkdXgiLCJpc09wZW4iLCJzZXRJc09wZW4iLCJsYXN0U2VsZWN0aW9uIiwic2V0TGFzdFNlbGVjdGlvbiIsImNvbnNvbGUiLCJncm91cCIsImxvZyIsImdldEVjb3N5c3RlbSIsImRlaHlkcmF0ZSIsInRyYW5zZm9ybSIsImdyb3VwRW5kIiwidmlld0dyYXBoIiwiaW5zcGVjdEl0ZW1WYWx1ZXMiLCJvcHRpb24iLCJSZWFjdEVkaXRvciIsIlRyYW5zZm9ybXMiLCJvcGVuaW5nQ2hhcnMiLCJjbG9zaW5nQ2hhcnMiLCJvbktleURvd24iLCJlZGl0b3IiLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwiaW5zZXJ0VGV4dCIsIm1vdmUiLCJkaXN0YW5jZSIsInJldmVyc2UiLCJ1bml0IiwiZG9tUmFuZ2UiLCJzZWxlY3Rpb24iLCJ0b0RPTVJhbmdlIiwibGluZSIsInN0YXJ0Q29udGFpbmVyIiwicGFyZW50RWxlbWVudCIsImRhdGFzZXQiLCJzbGF0ZU5vZGUiLCJsaW5lVGV4dCIsImlubmVyVGV4dCIsInNwYWNlcyIsIm1hdGNoIiwiaGFzU2VsZWN0aW9uIiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJmb2N1cyIsIm9mZnNldCIsInByZXZDaGFyIiwibmV4dENoYXIiLCJpbnNlcnRCcmVhayIsImluY2x1ZGVzIiwic2Nyb2xsU2VsZWN0aW9uSW50b1ZpZXciLCJlbCIsImVkaXRvckVsIiwic2xhdGVFZGl0b3IiLCJjaGFyV2lkdGgiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsInByZXZQb3MiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsSW50b1ZpZXciLCJibG9jayIsImNsaWVudFdpZHRoIiwiY2hhck51bSIsIkJVRkZFUiIsIkVkaXRhYmxlIiwiY3NzIiwiRWRpdG9yV3JhcHBlciIsIkd1dHRlciIsIkhlYWRlciIsIkhlYWRlckFjdGlvbnMiLCJIZWFkZXJUZXh0IiwiUmVzZXRCdXR0b24iLCJSZXN1bHQiLCJTdHlsZWRFZGl0YWJsZSIsIiRzc2NQcm9wcyIsInN0eWxlcyIsInN0eWxlIiwidHlwZXMiLCJqb2luIiwic2VjdGlvbiIsInVzZVByaXNtVGhlbWUiLCJ1c2VEb2N1c2F1cnVzQ29udGV4dCIsIlByaXNtIiwidXNlQ2FsbGJhY2siLCJ1c2VFZmZlY3QiLCJUZXh0IiwiY3JlYXRlRWRpdG9yIiwid2l0aEhpc3RvcnkiLCJTbGF0ZSIsIndpdGhSZWFjdCIsIlJlYWN0SW1tZXIiLCJSZWFjdFplZHV4Iiwic2NvcGUiLCJzY29wZUtleXMiLCJzY29wZVZhbHVlcyIsImRlY29yYXRlVG9rZW5zIiwicGF0aCIsInRva2VucyIsInBhcmVudFR5cGUiLCJ0b2tlbiIsImVuZCIsInN0YXJ0IiwicmFuZ2VzIiwiYW5jaG9yIiwidG9rZW5UeXBlIiwiY29udGVudCIsImRlY29yYXRlIiwibm9kZSIsImlzVGV4dCIsInRva2VuaXplIiwidGV4dCIsImxhbmd1YWdlcyIsInRzeCIsImV2YWxDb2RlIiwiY29kZSIsInJlc3VsdFZhck5hbWUiLCJleHRyYVNjb3BlIiwicmVzdWx0U3RyIiwid3JhcHBlZCIsImV4dHJhU2NvcGVLZXlzIiwidmFscyIsImZuIiwiRnVuY3Rpb24iLCJlY29zeXN0ZW1zQmVmb3JlIiwiaW50ZXJuYWxTdG9yZSIsImNhbGwiLCJlY29zeXN0ZW1zQWZ0ZXIiLCJwYXJzZSIsInNwbGl0Iiwic2xpY2UiLCJzZXJpYWxpemUiLCJjaGlsZCIsIkVycm9yQm91bmRhcnkiLCJwcm9wcyIsImhhc0Vycm9yIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJyZW5kZXIiLCJDb21wb25lbnQiLCJMZWFmIiwiYXR0cmlidXRlcyIsImxlYWYiLCJTYW5kYm94IiwiZWNvc3lzdGVtSWQiLCJyZXN1bHRWYXIiLCJiYXNlVXJsIiwic2l0ZUNvbmZpZyIsImluaXRpYWxWYWx1ZSIsInNldFZhbHVlIiwic2V0UmVzdWx0IiwidGhlbWUiLCJsYXN0TG9nZ2VkRXJyb3JUaW1lUmVmIiwiaXNNb3VudGVkUmVmIiwicnVuQ29kZSIsInJhd1ZhbCIsInZhbCIsImV4dHJhU2NvcGVTdHIiLCJqc0NvZGUiLCJ3aW5kb3ciLCJ0cyIsInRyYW5zcGlsZSIsImpzeCIsIl9pbnN0YW5jZXMiLCJ3aXBlIiwic2V0T3ZlcnJpZGVzIiwiZXZhbFJlc3VsdCIsImVyciIsIm1lc3NhZ2UiLCJEYXRlIiwibm93Iiwic2xhdGUiLCJuZXdWYWx1ZSIsIl8iLCJpIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6630\n")},9094:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  "Z": function() { return /* binding */ theme_CodeBlock; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteralLoose.js\nvar taggedTemplateLiteralLoose = __webpack_require__(1880);\n// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/hooks/usePrismTheme.js\nvar usePrismTheme = __webpack_require__(6412);\n// EXTERNAL MODULE: ./src/ssc/index.tsx\nvar ssc = __webpack_require__(8880);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js\nvar esm_extends = __webpack_require__(7462);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\nvar objectWithoutPropertiesLoose = __webpack_require__(3366);\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(7294);\n// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/useIsBrowser.js\nvar useIsBrowser = __webpack_require__(2389);\n// EXTERNAL MODULE: ./node_modules/clsx/dist/clsx.m.js\nvar clsx_m = __webpack_require__(6010);\n// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/ThemeClassNames.js\nvar ThemeClassNames = __webpack_require__(5281);\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/wrapRegExp.js + 1 modules\nvar wrapRegExp = __webpack_require__(7099);\n// EXTERNAL MODULE: ./node_modules/parse-numeric-range/index.js\nvar parse_numeric_range = __webpack_require__(7594);\nvar parse_numeric_range_default = /*#__PURE__*/__webpack_require__.n(parse_numeric_range);\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/codeBlockUtils.js\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */var codeBlockTitleRegex=/*#__PURE__*/(0,wrapRegExp/* default */.Z)(/title=(["\'])(.*?)\\1/,{quote:1,title:2});var metastringLinesRangeRegex=/*#__PURE__*/(0,wrapRegExp/* default */.Z)(/\\{([\\d,-]+)\\}/,{range:1});// Supported types of highlight comments\nvar commentPatterns={js:{start:\'\\\\/\\\\/\',end:\'\'},jsBlock:{start:\'\\\\/\\\\*\',end:\'\\\\*\\\\/\'},jsx:{start:\'\\\\{\\\\s*\\\\/\\\\*\',end:\'\\\\*\\\\/\\\\s*\\\\}\'},bash:{start:\'#\',end:\'\'},html:{start:\'\x3c!--\',end:\'--\x3e\'}};function getCommentPattern(languages,magicCommentDirectives){// To be more reliable, the opening and closing comment must match\nvar commentPattern=languages.map(function(lang){var _commentPatterns$lang=commentPatterns[lang],start=_commentPatterns$lang.start,end=_commentPatterns$lang.end;return"(?:"+start+"\\\\s*("+magicCommentDirectives.flatMap(function(d){var _d$block,_d$block2;return[d.line,(_d$block=d.block)==null?void 0:_d$block.start,(_d$block2=d.block)==null?void 0:_d$block2.end].filter(Boolean);}).join(\'|\')+")\\\\s*"+end+")";}).join(\'|\');// White space is allowed, but otherwise it should be on it\'s own line\nreturn new RegExp("^\\\\s*(?:"+commentPattern+")\\\\s*$");}/**\n * Select comment styles based on language\n */function getAllMagicCommentDirectiveStyles(lang,magicCommentDirectives){switch(lang){case\'js\':case\'javascript\':case\'ts\':case\'typescript\':return getCommentPattern([\'js\',\'jsBlock\'],magicCommentDirectives);case\'jsx\':case\'tsx\':return getCommentPattern([\'js\',\'jsBlock\',\'jsx\'],magicCommentDirectives);case\'html\':return getCommentPattern([\'js\',\'jsBlock\',\'html\'],magicCommentDirectives);case\'python\':case\'py\':case\'bash\':return getCommentPattern([\'bash\'],magicCommentDirectives);case\'markdown\':case\'md\':// Text uses HTML, front matter uses bash\nreturn getCommentPattern([\'html\',\'jsx\',\'bash\'],magicCommentDirectives);default:// All comment types\nreturn getCommentPattern(Object.keys(commentPatterns),magicCommentDirectives);}}function parseCodeBlockTitle(metastring){var _metastring$match$gro,_metastring$match;return(_metastring$match$gro=metastring==null?void 0:(_metastring$match=metastring.match(codeBlockTitleRegex))==null?void 0:_metastring$match.groups.title)!=null?_metastring$match$gro:\'\';}function containsLineNumbers(metastring){return Boolean(metastring==null?void 0:metastring.includes(\'showLineNumbers\'));}/**\n * Gets the language name from the class name (set by MDX).\n * e.g. `"language-javascript"` => `"javascript"`.\n * Returns undefined if there is no language class name.\n */function parseLanguage(className){var languageClassName=className.split(\' \').find(function(str){return str.startsWith(\'language-\');});return languageClassName==null?void 0:languageClassName.replace(/language-/,\'\');}/**\n * Parses the code content, strips away any magic comments, and returns the\n * clean content and the highlighted lines marked by the comments or metastring.\n *\n * If the metastring contains a range, the `content` will be returned as-is\n * without any parsing. The returned `lineClassNames` will be a map from that\n * number range to the first magic comment config entry (which _should_ be for\n * line highlight directives.)\n *\n * @param content The raw code with magic comments. Trailing newline will be\n * trimmed upfront.\n * @param options Options for parsing behavior.\n */function parseLines(content,options){var code=content.replace(/\\n$/,\'\');var language=options.language,magicComments=options.magicComments,metastring=options.metastring;// Highlighted lines specified in props: don\'t parse the content\nif(metastring&&metastringLinesRangeRegex.test(metastring)){var linesRange=metastring.match(metastringLinesRangeRegex).groups.range;if(magicComments.length===0){throw new Error("A highlight range has been given in code block\'s metastring (``` "+metastring+"), but no magic comment config is available. Docusaurus applies the first magic comment entry\'s className for metastring ranges.");}var metastringRangeClassName=magicComments[0].className;var _lines=parse_numeric_range_default()(linesRange).filter(function(n){return n>0;}).map(function(n){return[n-1,[metastringRangeClassName]];});return{lineClassNames:Object.fromEntries(_lines),code:code};}if(language===undefined){return{lineClassNames:{},code:code};}var directiveRegex=getAllMagicCommentDirectiveStyles(language,magicComments);// Go through line by line\nvar lines=code.split(\'\\n\');var blocks=Object.fromEntries(magicComments.map(function(d){return[d.className,{start:0,range:\'\'}];}));var lineToClassName=Object.fromEntries(magicComments.filter(function(d){return d.line;}).map(function(_ref){var className=_ref.className,line=_ref.line;return[line,className];}));var blockStartToClassName=Object.fromEntries(magicComments.filter(function(d){return d.block;}).map(function(_ref2){var className=_ref2.className,block=_ref2.block;return[block.start,className];}));var blockEndToClassName=Object.fromEntries(magicComments.filter(function(d){return d.block;}).map(function(_ref3){var className=_ref3.className,block=_ref3.block;return[block.end,className];}));for(var lineNumber=0;lineNumber<lines.length;){var line=lines[lineNumber];var match=line.match(directiveRegex);if(!match){// Lines without directives are unchanged\nlineNumber+=1;continue;}var directive=match.slice(1).find(function(item){return item!==undefined;});if(lineToClassName[directive]){blocks[lineToClassName[directive]].range+=lineNumber+",";}else if(blockStartToClassName[directive]){blocks[blockStartToClassName[directive]].start=lineNumber;}else if(blockEndToClassName[directive]){blocks[blockEndToClassName[directive]].range+=blocks[blockEndToClassName[directive]].start+"-"+(lineNumber-1)+",";}lines.splice(lineNumber,1);}code=lines.join(\'\\n\');var lineClassNames={};Object.entries(blocks).forEach(function(_ref4){var className=_ref4[0],range=_ref4[1].range;parse_numeric_range_default()(range).forEach(function(l){var _lineClassNames$l;(_lineClassNames$l=lineClassNames[l])!=null?_lineClassNames$l:lineClassNames[l]=[];lineClassNames[l].push(className);});});return{lineClassNames:lineClassNames,code:code};}function getPrismCssVariables(prismTheme){var mapping={color:\'--prism-color\',backgroundColor:\'--prism-background-color\'};var properties={};Object.entries(prismTheme.plain).forEach(function(_ref5){var key=_ref5[0],value=_ref5[1];var varName=mapping[key];if(varName&&typeof value===\'string\'){properties[varName]=value;}});return properties;}\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/CodeBlock/Container/styles.module.css\n// extracted by mini-css-extract-plugin\n/* harmony default export */ var styles_module = ({"codeBlockContainer":"codeBlockContainer_Ckt0"});\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/CodeBlock/Container/index.js\nvar _excluded=["as"];/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */function CodeBlockContainer(_ref){var As=_ref.as,props=(0,objectWithoutPropertiesLoose/* default */.Z)(_ref,_excluded);var prismTheme=(0,usePrismTheme/* usePrismTheme */.p)();var prismCssVariables=getPrismCssVariables(prismTheme);return/*#__PURE__*/react.createElement(As// Polymorphic components are hard to type, without `oneOf` generics\n,(0,esm_extends/* default */.Z)({},props,{style:prismCssVariables,className:(0,clsx_m/* default */.Z)(props.className,styles_module.codeBlockContainer,ThemeClassNames/* ThemeClassNames.common.codeBlock */.k.common.codeBlock)}));}\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/CodeBlock/Content/styles.module.css\n// extracted by mini-css-extract-plugin\n/* harmony default export */ var Content_styles_module = ({"codeBlockContent":"codeBlockContent_biex","codeBlockTitle":"codeBlockTitle_Ktv7","codeBlock":"codeBlock_bY9V","codeBlockStandalone":"codeBlockStandalone_MEMb","codeBlockLines":"codeBlockLines_e6Vv","codeBlockLinesWithNumbering":"codeBlockLinesWithNumbering_o6Pm","buttonGroup":"buttonGroup__atx"});\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/CodeBlock/Content/Element.js\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */// <pre> tags in markdown map to CodeBlocks. They may contain JSX children. When\n// the children is not a simple string, we just return a styled block without\n// actually highlighting.\nfunction CodeBlockJSX(_ref){var children=_ref.children,className=_ref.className;return/*#__PURE__*/react.createElement(CodeBlockContainer,{as:"pre",tabIndex:0,className:(0,clsx_m/* default */.Z)(Content_styles_module.codeBlockStandalone,\'thin-scrollbar\',className)},/*#__PURE__*/react.createElement("code",{className:Content_styles_module.codeBlockLines},children));}\n// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/useThemeConfig.js\nvar useThemeConfig = __webpack_require__(6668);\n// EXTERNAL MODULE: ./node_modules/@docusaurus/theme-common/lib/utils/reactUtils.js + 3 modules\nvar reactUtils = __webpack_require__(7326);\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/hooks/useMutationObserver.js\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */var DefaultOptions={attributes:true,characterData:true,childList:true,subtree:true};function useMutationObserver(target,callback,options){if(options===void 0){options=DefaultOptions;}var stableCallback=(0,reactUtils/* useEvent */.zX)(callback);// MutationObserver options are not nested much\n// so this should be to memo options in 99%\n// TODO handle options.attributeFilter array\nvar stableOptions=(0,reactUtils/* useShallowMemoObject */.Ql)(options);(0,react.useEffect)(function(){var observer=new MutationObserver(stableCallback);if(target){observer.observe(target,stableOptions);}return function(){return observer.disconnect();};},[target,stableCallback,stableOptions]);}\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-common/lib/hooks/useCodeWordWrap.js\n// Callback fires when the "hidden" attribute of a tabpanel changes\n// See https://github.com/facebook/docusaurus/pull/7485\nfunction useTabBecameVisibleCallback(codeBlockRef,callback){var _useState=(0,react.useState)(),hiddenTabElement=_useState[0],setHiddenTabElement=_useState[1];var updateHiddenTabElement=(0,react.useCallback)(function(){var _codeBlockRef$current;// No need to observe non-hidden tabs\n// + we want to force a re-render when a tab becomes visible\nsetHiddenTabElement((_codeBlockRef$current=codeBlockRef.current)==null?void 0:_codeBlockRef$current.closest(\'[role=tabpanel][hidden]\'));},[codeBlockRef,setHiddenTabElement]);(0,react.useEffect)(function(){updateHiddenTabElement();},[updateHiddenTabElement]);useMutationObserver(hiddenTabElement,function(mutations){mutations.forEach(function(mutation){if(mutation.type===\'attributes\'&&mutation.attributeName===\'hidden\'){callback();updateHiddenTabElement();}});},{attributes:true,characterData:false,childList:false,subtree:false});}function useCodeWordWrap(){var _useState2=(0,react.useState)(false),isEnabled=_useState2[0],setIsEnabled=_useState2[1];var _useState3=(0,react.useState)(false),isCodeScrollable=_useState3[0],setIsCodeScrollable=_useState3[1];var codeBlockRef=(0,react.useRef)(null);var toggle=(0,react.useCallback)(function(){var codeElement=codeBlockRef.current.querySelector(\'code\');if(isEnabled){codeElement.removeAttribute(\'style\');}else{codeElement.style.whiteSpace=\'pre-wrap\';// When code wrap is enabled, we want to avoid a scrollbar in any case\n// Ensure that very very long words/strings/tokens still wrap\ncodeElement.style.overflowWrap=\'anywhere\';}setIsEnabled(function(value){return!value;});},[codeBlockRef,isEnabled]);var updateCodeIsScrollable=(0,react.useCallback)(function(){var _codeBlockRef$current2=codeBlockRef.current,scrollWidth=_codeBlockRef$current2.scrollWidth,clientWidth=_codeBlockRef$current2.clientWidth;var isScrollable=scrollWidth>clientWidth||codeBlockRef.current.querySelector(\'code\').hasAttribute(\'style\');setIsCodeScrollable(isScrollable);},[codeBlockRef]);useTabBecameVisibleCallback(codeBlockRef,updateCodeIsScrollable);(0,react.useEffect)(function(){updateCodeIsScrollable();},[isEnabled,updateCodeIsScrollable]);(0,react.useEffect)(function(){window.addEventListener(\'resize\',updateCodeIsScrollable,{passive:true});return function(){window.removeEventListener(\'resize\',updateCodeIsScrollable);};},[updateCodeIsScrollable]);return{codeBlockRef:codeBlockRef,isEnabled:isEnabled,isCodeScrollable:isCodeScrollable,toggle:toggle};}\n// EXTERNAL MODULE: ./node_modules/prism-react-renderer/prism/index.js\nvar prism = __webpack_require__(7410);\n;// CONCATENATED MODULE: ./node_modules/prism-react-renderer/themes/duotoneDark/index.js\n// Duotone Dark\n// Author: Simurai, adapted from DuoTone themes for Atom (http://simurai.com/projects/2016/01/01/duotone-themes)\n// Conversion: Bram de Haan (http://atelierbram.github.io/Base2Tone-prism/output/prism/prism-base2tone-evening-dark.css)\n// Generated with Base16 Builder (https://github.com/base16-builder/base16-builder)\nvar theme = {\n  plain: {\n    backgroundColor: "#2a2734",\n    color: "#9a86fd"\n  },\n  styles: [{\n    types: ["comment", "prolog", "doctype", "cdata", "punctuation"],\n    style: {\n      color: "#6c6783"\n    }\n  }, {\n    types: ["namespace"],\n    style: {\n      opacity: 0.7\n    }\n  }, {\n    types: ["tag", "operator", "number"],\n    style: {\n      color: "#e09142"\n    }\n  }, {\n    types: ["property", "function"],\n    style: {\n      color: "#9a86fd"\n    }\n  }, {\n    types: ["tag-id", "selector", "atrule-id"],\n    style: {\n      color: "#eeebff"\n    }\n  }, {\n    types: ["attr-name"],\n    style: {\n      color: "#c4b9fe"\n    }\n  }, {\n    types: ["boolean", "string", "entity", "url", "attr-value", "keyword", "control", "directive", "unit", "statement", "regex", "atrule", "placeholder", "variable"],\n    style: {\n      color: "#ffcc99"\n    }\n  }, {\n    types: ["deleted"],\n    style: {\n      textDecorationLine: "line-through"\n    }\n  }, {\n    types: ["inserted"],\n    style: {\n      textDecorationLine: "underline"\n    }\n  }, {\n    types: ["italic"],\n    style: {\n      fontStyle: "italic"\n    }\n  }, {\n    types: ["important", "bold"],\n    style: {\n      fontWeight: "bold"\n    }\n  }, {\n    types: ["important"],\n    style: {\n      color: "#c4b9fe"\n    }\n  }]\n};\n\n/* harmony default export */ var duotoneDark = (theme);\n\n;// CONCATENATED MODULE: ./node_modules/prism-react-renderer/dist/index.js\n\n\n\n\n\nvar defaultProps = {\n  // $FlowFixMe\n  Prism: prism/* default */.Z,\n  theme: duotoneDark\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar newlineRe = /\\r\\n|\\r|\\n/; // Empty lines need to contain a single empty token, denoted with { empty: true }\n\nvar normalizeEmptyLines = function (line) {\n  if (line.length === 0) {\n    line.push({\n      types: ["plain"],\n      content: "\\n",\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === "") {\n    line[0].content = "\\n";\n    line[0].empty = true;\n  }\n};\n\nvar appendTypes = function (types, add) {\n  var typesSize = types.length;\n\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n\n  return types.concat(add);\n}; // Takes an array of Prism\'s tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type "plain".\n// This is not recursive to avoid exceeding the call-stack limit, since it\'s unclear\n// how nested Prism\'s tokens can become\n\n\nvar normalizeTokens = function (tokens) {\n  var typeArrStack = [[]];\n  var tokenArrStack = [tokens];\n  var tokenArrIndexStack = [0];\n  var tokenArrSizeStack = [tokens.length];\n  var i = 0;\n  var stackIndex = 0;\n  var currentLine = [];\n  var acc = [currentLine];\n\n  while (stackIndex > -1) {\n    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      var content = void 0;\n      var types = typeArrStack[stackIndex];\n      var tokenArr = tokenArrStack[stackIndex];\n      var token = tokenArr[i]; // Determine content and append type to types if necessary\n\n      if (typeof token === "string") {\n        types = stackIndex > 0 ? types : ["plain"];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n\n        content = token.content;\n      } // If token.content is an array, increase the stack depth and repeat this while-loop\n\n\n      if (typeof content !== "string") {\n        stackIndex++;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        continue;\n      } // Split by newlines\n\n\n      var splitByNewlines = content.split(newlineRe);\n      var newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types: types,\n        content: splitByNewlines[0]\n      }); // Create a new line for each string on a new line\n\n      for (var i$1 = 1; i$1 < newlineCount; i$1++) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types: types,\n          content: splitByNewlines[i$1]\n        });\n      }\n    } // Decreate the stack depth\n\n\n    stackIndex--;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\n\nvar themeToDict = function (theme, language) {\n  var plain = theme.plain; // $FlowFixMe\n\n  var base = Object.create(null);\n  var themeDict = theme.styles.reduce(function (acc, themeEntry) {\n    var languages = themeEntry.languages;\n    var style = themeEntry.style;\n\n    if (languages && !languages.includes(language)) {\n      return acc;\n    }\n\n    themeEntry.types.forEach(function (type) {\n      // $FlowFixMe\n      var accStyle = _extends({}, acc[type], style);\n\n      acc[type] = accStyle;\n    });\n    return acc;\n  }, base); // $FlowFixMe\n\n  themeDict.root = plain; // $FlowFixMe\n\n  themeDict.plain = _extends({}, plain, {\n    backgroundColor: null\n  });\n  return themeDict;\n};\n\nfunction objectWithoutProperties(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n\n  return target;\n}\n\nvar Highlight = /*@__PURE__*/function (Component) {\n  function Highlight() {\n    var this$1 = this;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    Component.apply(this, args);\n\n    _defineProperty(this, "getThemeDict", function (props) {\n      if (this$1.themeDict !== undefined && props.theme === this$1.prevTheme && props.language === this$1.prevLanguage) {\n        return this$1.themeDict;\n      }\n\n      this$1.prevTheme = props.theme;\n      this$1.prevLanguage = props.language;\n      var themeDict = props.theme ? themeToDict(props.theme, props.language) : undefined;\n      return this$1.themeDict = themeDict;\n    });\n\n    _defineProperty(this, "getLineProps", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var rest$1 = objectWithoutProperties(ref, ["key", "className", "style", "line"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: "token-line",\n        style: undefined,\n        key: undefined\n      });\n\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict !== undefined) {\n        output.style = themeDict.plain;\n      }\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += " " + className;\n      }\n\n      return output;\n    });\n\n    _defineProperty(this, "getStyleForToken", function (ref) {\n      var types = ref.types;\n      var empty = ref.empty;\n      var typesSize = types.length;\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict === undefined) {\n        return undefined;\n      } else if (typesSize === 1 && types[0] === "plain") {\n        return empty ? {\n          display: "inline-block"\n        } : undefined;\n      } else if (typesSize === 1 && !empty) {\n        return themeDict[types[0]];\n      }\n\n      var baseStyle = empty ? {\n        display: "inline-block"\n      } : {}; // $FlowFixMe\n\n      var typeStyles = types.map(function (type) {\n        return themeDict[type];\n      });\n      return Object.assign.apply(Object, [baseStyle].concat(typeStyles));\n    });\n\n    _defineProperty(this, "getTokenProps", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var token = ref.token;\n      var rest$1 = objectWithoutProperties(ref, ["key", "className", "style", "token"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: "token " + token.types.join(" "),\n        children: token.content,\n        style: this$1.getStyleForToken(token),\n        key: undefined\n      });\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += " " + className;\n      }\n\n      return output;\n    });\n\n    _defineProperty(this, "tokenize", function (Prism, code, grammar, language) {\n      var env = {\n        code: code,\n        grammar: grammar,\n        language: language,\n        tokens: []\n      };\n      Prism.hooks.run("before-tokenize", env);\n      var tokens = env.tokens = Prism.tokenize(env.code, env.grammar, env.language);\n      Prism.hooks.run("after-tokenize", env);\n      return tokens;\n    });\n  }\n\n  if (Component) Highlight.__proto__ = Component;\n  Highlight.prototype = Object.create(Component && Component.prototype);\n  Highlight.prototype.constructor = Highlight;\n\n  Highlight.prototype.render = function render() {\n    var ref = this.props;\n    var Prism = ref.Prism;\n    var language = ref.language;\n    var code = ref.code;\n    var children = ref.children;\n    var themeDict = this.getThemeDict(this.props);\n    var grammar = Prism.languages[language];\n    var mixedTokens = grammar !== undefined ? this.tokenize(Prism, code, grammar, language) : [code];\n    var tokens = normalizeTokens(mixedTokens);\n    return children({\n      tokens: tokens,\n      className: "prism-code language-" + language,\n      style: themeDict !== undefined ? themeDict.root : {},\n      getLineProps: this.getLineProps,\n      getTokenProps: this.getTokenProps\n    });\n  };\n\n  return Highlight;\n}(react.Component);\n\n/* harmony default export */ var dist = (Highlight);\n\n\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/CodeBlock/Line/styles.module.css\n// extracted by mini-css-extract-plugin\n/* harmony default export */ var Line_styles_module = ({"codeLine":"codeLine_lJS_","codeLineNumber":"codeLineNumber_Tfdd","codeLineContent":"codeLineContent_feaV"});\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/CodeBlock/Line/index.js\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */function CodeBlockLine(_ref){var line=_ref.line,classNames=_ref.classNames,showLineNumbers=_ref.showLineNumbers,getLineProps=_ref.getLineProps,getTokenProps=_ref.getTokenProps;if(line.length===1&&line[0].content===\'\\n\'){line[0].content=\'\';}var lineProps=getLineProps({line:line,className:(0,clsx_m/* default */.Z)(classNames,showLineNumbers&&Line_styles_module.codeLine)});var lineTokens=line.map(function(token,key){return/*#__PURE__*/react.createElement("span",(0,esm_extends/* default */.Z)({key:key},getTokenProps({token:token,key:key})));});return/*#__PURE__*/react.createElement("span",lineProps,showLineNumbers?/*#__PURE__*/react.createElement(react.Fragment,null,/*#__PURE__*/react.createElement("span",{className:Line_styles_module.codeLineNumber}),/*#__PURE__*/react.createElement("span",{className:Line_styles_module.codeLineContent},lineTokens)):lineTokens,/*#__PURE__*/react.createElement("br",null));}\n;// CONCATENATED MODULE: ./node_modules/copy-text-to-clipboard/index.js\nfunction copyTextToClipboard(input,_temp){var _ref=_temp===void 0?{}:_temp,_ref$target=_ref.target,target=_ref$target===void 0?document.body:_ref$target;var element=document.createElement(\'textarea\');var previouslyFocusedElement=document.activeElement;element.value=input;// Prevent keyboard from showing on mobile\nelement.setAttribute(\'readonly\',\'\');element.style.contain=\'strict\';element.style.position=\'absolute\';element.style.left=\'-9999px\';element.style.fontSize=\'12pt\';// Prevent zooming on iOS\nvar selection=document.getSelection();var originalRange=false;if(selection.rangeCount>0){originalRange=selection.getRangeAt(0);}target.append(element);element.select();// Explicit selection workaround for iOS\nelement.selectionStart=0;element.selectionEnd=input.length;var isSuccess=false;try{isSuccess=document.execCommand(\'copy\');}catch(_unused){}element.remove();if(originalRange){selection.removeAllRanges();selection.addRange(originalRange);}// Get the focus back on the previously focused element, if any\nif(previouslyFocusedElement){previouslyFocusedElement.focus();}return isSuccess;}\n// EXTERNAL MODULE: ./node_modules/@docusaurus/core/lib/client/exports/Translate.js + 1 modules\nvar Translate = __webpack_require__(5999);\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/CodeBlock/CopyButton/styles.module.css\n// extracted by mini-css-extract-plugin\n/* harmony default export */ var CopyButton_styles_module = ({"copyButtonCopied":"copyButtonCopied_obH4","copyButtonIcons":"copyButtonIcons_eSgA","copyButtonIcon":"copyButtonIcon_y97N","copyButtonSuccessIcon":"copyButtonSuccessIcon_LjdS"});\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/CodeBlock/CopyButton/index.js\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */// @ts-expect-error: TODO, we need to make theme-classic have type: module\nfunction CopyButton(_ref){var code=_ref.code,className=_ref.className;var _useState=(0,react.useState)(false),isCopied=_useState[0],setIsCopied=_useState[1];var copyTimeout=(0,react.useRef)(undefined);var handleCopyCode=(0,react.useCallback)(function(){copyTextToClipboard(code);setIsCopied(true);copyTimeout.current=window.setTimeout(function(){setIsCopied(false);},1000);},[code]);(0,react.useEffect)(function(){return function(){return window.clearTimeout(copyTimeout.current);};},[]);return/*#__PURE__*/react.createElement("button",{type:"button","aria-label":isCopied?(0,Translate/* translate */.I)({id:\'theme.CodeBlock.copied\',message:\'Copied\',description:\'The copied button label on code blocks\'}):(0,Translate/* translate */.I)({id:\'theme.CodeBlock.copyButtonAriaLabel\',message:\'Copy code to clipboard\',description:\'The ARIA label for copy code blocks button\'}),title:(0,Translate/* translate */.I)({id:\'theme.CodeBlock.copy\',message:\'Copy\',description:\'The copy button label on code blocks\'}),className:(0,clsx_m/* default */.Z)(\'clean-btn\',className,CopyButton_styles_module.copyButton,isCopied&&CopyButton_styles_module.copyButtonCopied),onClick:handleCopyCode},/*#__PURE__*/react.createElement("span",{className:CopyButton_styles_module.copyButtonIcons,"aria-hidden":"true"},/*#__PURE__*/react.createElement("svg",{className:CopyButton_styles_module.copyButtonIcon,viewBox:"0 0 24 24"},/*#__PURE__*/react.createElement("path",{d:"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"})),/*#__PURE__*/react.createElement("svg",{className:CopyButton_styles_module.copyButtonSuccessIcon,viewBox:"0 0 24 24"},/*#__PURE__*/react.createElement("path",{d:"M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"}))));}\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/CodeBlock/WordWrapButton/styles.module.css\n// extracted by mini-css-extract-plugin\n/* harmony default export */ var WordWrapButton_styles_module = ({"wordWrapButtonIcon":"wordWrapButtonIcon_Bwma","wordWrapButtonEnabled":"wordWrapButtonEnabled_EoeP"});\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/CodeBlock/WordWrapButton/index.js\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */function WordWrapButton(_ref){var className=_ref.className,onClick=_ref.onClick,isEnabled=_ref.isEnabled;var title=(0,Translate/* translate */.I)({id:\'theme.CodeBlock.wordWrapToggle\',message:\'Toggle word wrap\',description:\'The title attribute for toggle word wrapping button of code block lines\'});return/*#__PURE__*/react.createElement("button",{type:"button",onClick:onClick,className:(0,clsx_m/* default */.Z)(\'clean-btn\',className,isEnabled&&WordWrapButton_styles_module.wordWrapButtonEnabled),"aria-label":title,title:title},/*#__PURE__*/react.createElement("svg",{className:WordWrapButton_styles_module.wordWrapButtonIcon,viewBox:"0 0 24 24","aria-hidden":"true"},/*#__PURE__*/react.createElement("path",{fill:"currentColor",d:"M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3l3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z"})));}\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/CodeBlock/Content/String.js\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */function CodeBlockString(_ref){var _ref2;var children=_ref.children,_ref$className=_ref.className,blockClassName=_ref$className===void 0?\'\':_ref$className,metastring=_ref.metastring,titleProp=_ref.title,showLineNumbersProp=_ref.showLineNumbers,languageProp=_ref.language;var _useThemeConfig=(0,useThemeConfig/* useThemeConfig */.L)(),_useThemeConfig$prism=_useThemeConfig.prism,defaultLanguage=_useThemeConfig$prism.defaultLanguage,magicComments=_useThemeConfig$prism.magicComments;var language=(_ref2=languageProp!=null?languageProp:parseLanguage(blockClassName))!=null?_ref2:defaultLanguage;var prismTheme=(0,usePrismTheme/* usePrismTheme */.p)();var wordWrap=useCodeWordWrap();// We still parse the metastring in case we want to support more syntax in the\n// future. Note that MDX doesn\'t strip quotes when parsing metastring:\n// "title=\\"xyz\\"" => title: "\\"xyz\\""\nvar title=parseCodeBlockTitle(metastring)||titleProp;var _parseLines=parseLines(children,{metastring:metastring,language:language,magicComments:magicComments}),lineClassNames=_parseLines.lineClassNames,code=_parseLines.code;var showLineNumbers=showLineNumbersProp!=null?showLineNumbersProp:containsLineNumbers(metastring);return/*#__PURE__*/react.createElement(CodeBlockContainer,{as:"div",className:(0,clsx_m/* default */.Z)(blockClassName,language&&!blockClassName.includes("language-"+language)&&"language-"+language)},title&&/*#__PURE__*/react.createElement("div",{className:Content_styles_module.codeBlockTitle},title),/*#__PURE__*/react.createElement("div",{className:Content_styles_module.codeBlockContent},/*#__PURE__*/react.createElement(dist,(0,esm_extends/* default */.Z)({},defaultProps,{theme:prismTheme,code:code,language:language!=null?language:\'text\'}),function(_ref3){var className=_ref3.className,tokens=_ref3.tokens,getLineProps=_ref3.getLineProps,getTokenProps=_ref3.getTokenProps;return/*#__PURE__*/react.createElement("pre",{/* eslint-disable-next-line jsx-a11y/no-noninteractive-tabindex */tabIndex:0,ref:wordWrap.codeBlockRef,className:(0,clsx_m/* default */.Z)(className,Content_styles_module.codeBlock,\'thin-scrollbar\')},/*#__PURE__*/react.createElement("code",{className:(0,clsx_m/* default */.Z)(Content_styles_module.codeBlockLines,showLineNumbers&&Content_styles_module.codeBlockLinesWithNumbering)},tokens.map(function(line,i){return/*#__PURE__*/react.createElement(CodeBlockLine,{key:i,line:line,getLineProps:getLineProps,getTokenProps:getTokenProps,classNames:lineClassNames[i],showLineNumbers:showLineNumbers});})));}),/*#__PURE__*/react.createElement("div",{className:Content_styles_module.buttonGroup},(wordWrap.isEnabled||wordWrap.isCodeScrollable)&&/*#__PURE__*/react.createElement(WordWrapButton,{className:Content_styles_module.codeButton,onClick:function onClick(){return wordWrap.toggle();},isEnabled:wordWrap.isEnabled}),/*#__PURE__*/react.createElement(CopyButton,{className:Content_styles_module.codeButton,code:code}))));}\n;// CONCATENATED MODULE: ./node_modules/@docusaurus/theme-classic/lib/theme/CodeBlock/index.js\nvar CodeBlock_excluded=["children"];/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *//**\n * Best attempt to make the children a plain string so it is copyable. If there\n * are react elements, we will not be able to copy the content, and it will\n * return `children` as-is; otherwise, it concatenates the string children\n * together.\n */function maybeStringifyChildren(children){if(react.Children.toArray(children).some(function(el){return/*#__PURE__*/(0,react.isValidElement)(el);})){return children;}// The children is now guaranteed to be one/more plain strings\nreturn Array.isArray(children)?children.join(\'\'):children;}function CodeBlock(_ref){var rawChildren=_ref.children,props=(0,objectWithoutPropertiesLoose/* default */.Z)(_ref,CodeBlock_excluded);// The Prism theme on SSR is always the default theme but the site theme can\n// be in a different mode. React hydration doesn\'t update DOM styles that come\n// from SSR. Hence force a re-render after mounting to apply the current\n// relevant styles.\nvar isBrowser=(0,useIsBrowser/* default */.Z)();var children=maybeStringifyChildren(rawChildren);var CodeBlockComp=typeof children===\'string\'?CodeBlockString:CodeBlockJSX;return/*#__PURE__*/react.createElement(CodeBlockComp,(0,esm_extends/* default */.Z)({key:String(isBrowser)},props),children);}\n// EXTERNAL MODULE: ./node_modules/prismjs/prism.js\nvar prismjs_prism = __webpack_require__(5660);\nvar prism_default = /*#__PURE__*/__webpack_require__.n(prismjs_prism);\n// EXTERNAL MODULE: ./node_modules/prismjs/components/prism-jsx.js\nvar prism_jsx = __webpack_require__(2356);\n// EXTERNAL MODULE: ./node_modules/prismjs/components/prism-typescript.js\nvar prism_typescript = __webpack_require__(6836);\n// EXTERNAL MODULE: ./node_modules/prismjs/components/prism-tsx.js\nvar prism_tsx = __webpack_require__(1029);\n// EXTERNAL MODULE: ./node_modules/prismjs/components/prism-bash.js\nvar prism_bash = __webpack_require__(7874);\n// EXTERNAL MODULE: ./src/theme/CodeBlock/Sandbox.tsx + 45 modules\nvar Sandbox = __webpack_require__(6630);\n;// CONCATENATED MODULE: ./src/theme/CodeBlock/index.tsx\nvar _templateObject;/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */var Code=ssc/* default.code */.ZP.code(_templateObject||(_templateObject=(0,taggedTemplateLiteralLoose/* default */.Z)(["\\n  display: block;\\n\\n  .token {\\n    color: #d7dfec;\\n\\n    ","\\n\\n    &.comment {\\n      font-style: italic;\\n    }\\n\\n    &.keyword {\\n      color: #e08a57;\\n    }\\n  }\\n"])),function(_ref){var $sscProps=_ref.$sscProps;return $sscProps.styles.map(function(_ref2){var style=_ref2.style,types=_ref2.types;return types.map(function(type){return"&."+type+" { "+(0,ssc/* css */.iv)(style/* Prism font-weight type is wrong */)+" }";}).join(\'\\n\');}).join(\'\\n\');});var renderTokens=function renderTokens(tokens){return tokens.map(function(token,i){return/*#__PURE__*/react.createElement("span",{className:"token "+(typeof token===\'string\'?\'\':token.type),key:i},typeof token===\'string\'?token:typeof token.content===\'string\'?token.content:renderTokens(Array.isArray(token.content)?token.content:[token.content]));});};var withLiveEditor=function withLiveEditor(Component){function WrappedComponent(props){var _props$className;var theme=(0,usePrismTheme/* usePrismTheme */.p)();if(props.live){return/*#__PURE__*/react.createElement(Sandbox/* Sandbox */.p,props);}return/*#__PURE__*/react.createElement(Component,props);var tokens=prism_default().tokenize(props.children,(prism_default()).languages[props.language||((_props$className=props.className)==null?void 0:_props$className.split(\'-\')[1])||\'tsx\']);return/*#__PURE__*/react.createElement(react.Fragment,null,/*#__PURE__*/react.createElement("div",{className:"codeBlockContainer_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Container-styles-module theme-code-block",style:{\'--prism-color\':\'#bfc7d5\',\'--prism-background-color\':\'#292d3e\'}},/*#__PURE__*/react.createElement("div",{className:"codeBlockContent_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module"},/*#__PURE__*/react.createElement("pre",{tabIndex:0,className:"prism-code codeBlock_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module thin-scrollbar"},/*#__PURE__*/react.createElement(Code,{className:props.className+" codeBlockLines_node_modules-@docusaurus-theme-classic-lib-theme-CodeBlock-Content-styles-module",$sscProps:theme},renderTokens(tokens))))));}return WrappedComponent;};/* harmony default export */ var theme_CodeBlock = (withLiveEditor(CodeBlock));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFmLGlCQUFpQkUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFJLEtBQUssQ0FBQyxDQUMzRSxDQUVELG1CQUNFLHFEQUNFLDJCQUNFLFNBQVMsQ0FBQyx3SEFBd0gsQ0FDbEksS0FBSyxDQUNILENBQ0UsZUFBZSxDQUFFLFNBQVMsQ0FDMUIsMEJBQTBCLENBQUUsU0FDOUIsQ0FDRCxlQUVELDJCQUFLLFNBQVMsQ0FBQyxtR0FBbUcsZUFDaEgsMkJBQ0UsUUFBUSxDQUFFLENBQUUsQ0FDWixTQUFTLENBQUMsc0hBQXNILGVBRWhJLG9CQUFDLElBQUksRUFDSCxTQUFTLENBQUtzRCxLQUFLLENBQUN4RCxTQUFTLG1HQUFtRyxDQUNoSSxTQUFTLENBQUVnTyxLQUFNLEVBRWhCSixZQUFZLENBQUM1QixNQUFNLENBQUMsQ0FDaEIsQ0FDSCxDQTRDRixDQUNGLENBQ0wsQ0FFUCxDQUVBLE1BQU8rQixpQkFBZ0IsQ0FDekIsQ0FBQyxDQUVELG9EQUFlRixjQUFjLENBQUNiLFNBQVMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi4vLi4vc3JjL3V0aWxzL2NvZGVCbG9ja1V0aWxzLnRzP2RiOTAiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uL25vZGVfbW9kdWxlcy9AZG9jdXNhdXJ1cy90aGVtZS1jbGFzc2ljL2xpYi90aGVtZS9Db2RlQmxvY2svQ29udGFpbmVyL3N0eWxlcy5tb2R1bGUuY3NzPzE3ODEiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uL25vZGVfbW9kdWxlcy9AZG9jdXNhdXJ1cy90aGVtZS1jbGFzc2ljL2xpYi90aGVtZS9Db2RlQmxvY2svQ29udGFpbmVyL2luZGV4LmpzPzZkZWMiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uL25vZGVfbW9kdWxlcy9AZG9jdXNhdXJ1cy90aGVtZS1jbGFzc2ljL2xpYi90aGVtZS9Db2RlQmxvY2svQ29udGVudC9zdHlsZXMubW9kdWxlLmNzcz9lYTUwIiwid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvQGRvY3VzYXVydXMvdGhlbWUtY2xhc3NpYy9saWIvdGhlbWUvQ29kZUJsb2NrL0NvbnRlbnQvRWxlbWVudC5qcz85MDI3Iiwid2VicGFjazovL3plZHV4LWRvY3MvLi4vLi4vc3JjL2hvb2tzL3VzZU11dGF0aW9uT2JzZXJ2ZXIudHM/NTg5ZSIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uLy4uL3NyYy9ob29rcy91c2VDb2RlV29yZFdyYXAudHM/YmY1YiIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL3ByaXNtLXJlYWN0LXJlbmRlcmVyL3RoZW1lcy9kdW90b25lRGFyay9pbmRleC5qcz9hMzcyIiwid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvcHJpc20tcmVhY3QtcmVuZGVyZXIvZGlzdC9pbmRleC5qcz8zYWQ5Iiwid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvQGRvY3VzYXVydXMvdGhlbWUtY2xhc3NpYy9saWIvdGhlbWUvQ29kZUJsb2NrL0xpbmUvc3R5bGVzLm1vZHVsZS5jc3M/Nzc0ZCIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL0Bkb2N1c2F1cnVzL3RoZW1lLWNsYXNzaWMvbGliL3RoZW1lL0NvZGVCbG9jay9MaW5lL2luZGV4LmpzPzNjYjgiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uL25vZGVfbW9kdWxlcy9jb3B5LXRleHQtdG8tY2xpcGJvYXJkL2luZGV4LmpzP2RkZmUiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uL25vZGVfbW9kdWxlcy9AZG9jdXNhdXJ1cy90aGVtZS1jbGFzc2ljL2xpYi90aGVtZS9Db2RlQmxvY2svQ29weUJ1dHRvbi9zdHlsZXMubW9kdWxlLmNzcz8yZWM5Iiwid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvQGRvY3VzYXVydXMvdGhlbWUtY2xhc3NpYy9saWIvdGhlbWUvQ29kZUJsb2NrL0NvcHlCdXR0b24vaW5kZXguanM/NDc3NSIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL0Bkb2N1c2F1cnVzL3RoZW1lLWNsYXNzaWMvbGliL3RoZW1lL0NvZGVCbG9jay9Xb3JkV3JhcEJ1dHRvbi9zdHlsZXMubW9kdWxlLmNzcz9mMWI1Iiwid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvQGRvY3VzYXVydXMvdGhlbWUtY2xhc3NpYy9saWIvdGhlbWUvQ29kZUJsb2NrL1dvcmRXcmFwQnV0dG9uL2luZGV4LmpzPzE4NmMiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uL25vZGVfbW9kdWxlcy9AZG9jdXNhdXJ1cy90aGVtZS1jbGFzc2ljL2xpYi90aGVtZS9Db2RlQmxvY2svQ29udGVudC9TdHJpbmcuanM/NzFjZSIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL0Bkb2N1c2F1cnVzL3RoZW1lLWNsYXNzaWMvbGliL3RoZW1lL0NvZGVCbG9jay9pbmRleC5qcz84ZTQ5Iiwid2VicGFjazovL3plZHV4LWRvY3MvLi9zcmMvdGhlbWUvQ29kZUJsb2NrL2luZGV4LnRzeD9kMDA5Il0sInNvdXJjZXNDb250ZW50IjpbbnVsbCwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgZGVmYXVsdCB7XCJjb2RlQmxvY2tDb250YWluZXJcIjpcImNvZGVCbG9ja0NvbnRhaW5lcl9Da3QwXCJ9OyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7VGhlbWVDbGFzc05hbWVzLCB1c2VQcmlzbVRoZW1lfSBmcm9tICdAZG9jdXNhdXJ1cy90aGVtZS1jb21tb24nO1xuaW1wb3J0IHtnZXRQcmlzbUNzc1ZhcmlhYmxlc30gZnJvbSAnQGRvY3VzYXVydXMvdGhlbWUtY29tbW9uL2ludGVybmFsJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9zdHlsZXMubW9kdWxlLmNzcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb2RlQmxvY2tDb250YWluZXIoe2FzOiBBcywgLi4ucHJvcHN9KSB7XG4gIGNvbnN0IHByaXNtVGhlbWUgPSB1c2VQcmlzbVRoZW1lKCk7XG4gIGNvbnN0IHByaXNtQ3NzVmFyaWFibGVzID0gZ2V0UHJpc21Dc3NWYXJpYWJsZXMocHJpc21UaGVtZSk7XG4gIHJldHVybiAoXG4gICAgPEFzXG4gICAgICAvLyBQb2x5bW9ycGhpYyBjb21wb25lbnRzIGFyZSBoYXJkIHRvIHR5cGUsIHdpdGhvdXQgYG9uZU9mYCBnZW5lcmljc1xuICAgICAgey4uLnByb3BzfVxuICAgICAgc3R5bGU9e3ByaXNtQ3NzVmFyaWFibGVzfVxuICAgICAgY2xhc3NOYW1lPXtjbHN4KFxuICAgICAgICBwcm9wcy5jbGFzc05hbWUsXG4gICAgICAgIHN0eWxlcy5jb2RlQmxvY2tDb250YWluZXIsXG4gICAgICAgIFRoZW1lQ2xhc3NOYW1lcy5jb21tb24uY29kZUJsb2NrLFxuICAgICAgKX1cbiAgICAvPlxuICApO1xufVxuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgZGVmYXVsdCB7XCJjb2RlQmxvY2tDb250ZW50XCI6XCJjb2RlQmxvY2tDb250ZW50X2JpZXhcIixcImNvZGVCbG9ja1RpdGxlXCI6XCJjb2RlQmxvY2tUaXRsZV9LdHY3XCIsXCJjb2RlQmxvY2tcIjpcImNvZGVCbG9ja19iWTlWXCIsXCJjb2RlQmxvY2tTdGFuZGFsb25lXCI6XCJjb2RlQmxvY2tTdGFuZGFsb25lX01FTWJcIixcImNvZGVCbG9ja0xpbmVzXCI6XCJjb2RlQmxvY2tMaW5lc19lNlZ2XCIsXCJjb2RlQmxvY2tMaW5lc1dpdGhOdW1iZXJpbmdcIjpcImNvZGVCbG9ja0xpbmVzV2l0aE51bWJlcmluZ19vNlBtXCIsXCJidXR0b25Hcm91cFwiOlwiYnV0dG9uR3JvdXBfX2F0eFwifTsiLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJ0B0aGVtZS9Db2RlQmxvY2svQ29udGFpbmVyJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9zdHlsZXMubW9kdWxlLmNzcyc7XG4vLyA8cHJlPiB0YWdzIGluIG1hcmtkb3duIG1hcCB0byBDb2RlQmxvY2tzLiBUaGV5IG1heSBjb250YWluIEpTWCBjaGlsZHJlbi4gV2hlblxuLy8gdGhlIGNoaWxkcmVuIGlzIG5vdCBhIHNpbXBsZSBzdHJpbmcsIHdlIGp1c3QgcmV0dXJuIGEgc3R5bGVkIGJsb2NrIHdpdGhvdXRcbi8vIGFjdHVhbGx5IGhpZ2hsaWdodGluZy5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvZGVCbG9ja0pTWCh7Y2hpbGRyZW4sIGNsYXNzTmFtZX0pIHtcbiAgcmV0dXJuIChcbiAgICA8Q29udGFpbmVyXG4gICAgICBhcz1cInByZVwiXG4gICAgICB0YWJJbmRleD17MH1cbiAgICAgIGNsYXNzTmFtZT17Y2xzeChzdHlsZXMuY29kZUJsb2NrU3RhbmRhbG9uZSwgJ3RoaW4tc2Nyb2xsYmFyJywgY2xhc3NOYW1lKX0+XG4gICAgICA8Y29kZSBjbGFzc05hbWU9e3N0eWxlcy5jb2RlQmxvY2tMaW5lc30+e2NoaWxkcmVufTwvY29kZT5cbiAgICA8L0NvbnRhaW5lcj5cbiAgKTtcbn1cbiIsbnVsbCxudWxsLCIvLyBEdW90b25lIERhcmtcbi8vIEF1dGhvcjogU2ltdXJhaSwgYWRhcHRlZCBmcm9tIER1b1RvbmUgdGhlbWVzIGZvciBBdG9tIChodHRwOi8vc2ltdXJhaS5jb20vcHJvamVjdHMvMjAxNi8wMS8wMS9kdW90b25lLXRoZW1lcylcbi8vIENvbnZlcnNpb246IEJyYW0gZGUgSGFhbiAoaHR0cDovL2F0ZWxpZXJicmFtLmdpdGh1Yi5pby9CYXNlMlRvbmUtcHJpc20vb3V0cHV0L3ByaXNtL3ByaXNtLWJhc2UydG9uZS1ldmVuaW5nLWRhcmsuY3NzKVxuLy8gR2VuZXJhdGVkIHdpdGggQmFzZTE2IEJ1aWxkZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS9iYXNlMTYtYnVpbGRlci9iYXNlMTYtYnVpbGRlcilcbnZhciB0aGVtZSA9IHtcbiAgcGxhaW46IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzJhMjczNFwiLFxuICAgIGNvbG9yOiBcIiM5YTg2ZmRcIlxuICB9LFxuICBzdHlsZXM6IFt7XG4gICAgdHlwZXM6IFtcImNvbW1lbnRcIiwgXCJwcm9sb2dcIiwgXCJkb2N0eXBlXCIsIFwiY2RhdGFcIiwgXCJwdW5jdHVhdGlvblwiXSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IFwiIzZjNjc4M1wiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcIm5hbWVzcGFjZVwiXSxcbiAgICBzdHlsZToge1xuICAgICAgb3BhY2l0eTogMC43XG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcInRhZ1wiLCBcIm9wZXJhdG9yXCIsIFwibnVtYmVyXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogXCIjZTA5MTQyXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wicHJvcGVydHlcIiwgXCJmdW5jdGlvblwiXSxcbiAgICBzdHlsZToge1xuICAgICAgY29sb3I6IFwiIzlhODZmZFwiXG4gICAgfVxuICB9LCB7XG4gICAgdHlwZXM6IFtcInRhZy1pZFwiLCBcInNlbGVjdG9yXCIsIFwiYXRydWxlLWlkXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogXCIjZWVlYmZmXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wiYXR0ci1uYW1lXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogXCIjYzRiOWZlXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wiYm9vbGVhblwiLCBcInN0cmluZ1wiLCBcImVudGl0eVwiLCBcInVybFwiLCBcImF0dHItdmFsdWVcIiwgXCJrZXl3b3JkXCIsIFwiY29udHJvbFwiLCBcImRpcmVjdGl2ZVwiLCBcInVuaXRcIiwgXCJzdGF0ZW1lbnRcIiwgXCJyZWdleFwiLCBcImF0cnVsZVwiLCBcInBsYWNlaG9sZGVyXCIsIFwidmFyaWFibGVcIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGNvbG9yOiBcIiNmZmNjOTlcIlxuICAgIH1cbiAgfSwge1xuICAgIHR5cGVzOiBbXCJkZWxldGVkXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICB0ZXh0RGVjb3JhdGlvbkxpbmU6IFwibGluZS10aHJvdWdoXCJcbiAgICB9XG4gIH0sIHtcbiAgICB0eXBlczogW1wiaW5zZXJ0ZWRcIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIHRleHREZWNvcmF0aW9uTGluZTogXCJ1bmRlcmxpbmVcIlxuICAgIH1cbiAgfSwge1xuICAgIHR5cGVzOiBbXCJpdGFsaWNcIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIlxuICAgIH1cbiAgfSwge1xuICAgIHR5cGVzOiBbXCJpbXBvcnRhbnRcIiwgXCJib2xkXCJdLFxuICAgIHN0eWxlOiB7XG4gICAgICBmb250V2VpZ2h0OiBcImJvbGRcIlxuICAgIH1cbiAgfSwge1xuICAgIHR5cGVzOiBbXCJpbXBvcnRhbnRcIl0sXG4gICAgc3R5bGU6IHtcbiAgICAgIGNvbG9yOiBcIiNjNGI5ZmVcIlxuICAgIH1cbiAgfV1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IHRoZW1lO1xuIiwiaW1wb3J0IHByaXNtIGZyb20gJy4uL3ByaXNtL2luZGV4LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHJpc20gfSBmcm9tICcuLi9wcmlzbS9pbmRleC5qcyc7XG5pbXBvcnQgdGhlbWUgZnJvbSAnLi4vdGhlbWVzL2R1b3RvbmVEYXJrJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcblxudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgLy8gJEZsb3dGaXhNZVxuICBQcmlzbTogcHJpc20sXG4gIHRoZW1lOiB0aGVtZVxufTtcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBuZXdsaW5lUmUgPSAvXFxyXFxufFxccnxcXG4vOyAvLyBFbXB0eSBsaW5lcyBuZWVkIHRvIGNvbnRhaW4gYSBzaW5nbGUgZW1wdHkgdG9rZW4sIGRlbm90ZWQgd2l0aCB7IGVtcHR5OiB0cnVlIH1cblxudmFyIG5vcm1hbGl6ZUVtcHR5TGluZXMgPSBmdW5jdGlvbiAobGluZSkge1xuICBpZiAobGluZS5sZW5ndGggPT09IDApIHtcbiAgICBsaW5lLnB1c2goe1xuICAgICAgdHlwZXM6IFtcInBsYWluXCJdLFxuICAgICAgY29udGVudDogXCJcXG5cIixcbiAgICAgIGVtcHR5OiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAobGluZS5sZW5ndGggPT09IDEgJiYgbGluZVswXS5jb250ZW50ID09PSBcIlwiKSB7XG4gICAgbGluZVswXS5jb250ZW50ID0gXCJcXG5cIjtcbiAgICBsaW5lWzBdLmVtcHR5ID0gdHJ1ZTtcbiAgfVxufTtcblxudmFyIGFwcGVuZFR5cGVzID0gZnVuY3Rpb24gKHR5cGVzLCBhZGQpIHtcbiAgdmFyIHR5cGVzU2l6ZSA9IHR5cGVzLmxlbmd0aDtcblxuICBpZiAodHlwZXNTaXplID4gMCAmJiB0eXBlc1t0eXBlc1NpemUgLSAxXSA9PT0gYWRkKSB7XG4gICAgcmV0dXJuIHR5cGVzO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVzLmNvbmNhdChhZGQpO1xufTsgLy8gVGFrZXMgYW4gYXJyYXkgb2YgUHJpc20ncyB0b2tlbnMgYW5kIGdyb3VwcyB0aGVtIGJ5IGxpbmUsIHR1cm5pbmcgcGxhaW5cbi8vIHN0cmluZ3MgaW50byB0b2tlbnMgYXMgd2VsbC4gVG9rZW5zIGNhbiBiZWNvbWUgcmVjdXJzaXZlIGluIHNvbWUgY2FzZXMsXG4vLyB3aGljaCBtZWFucyB0aGF0IHRoZWlyIHR5cGVzIGFyZSBjb25jYXRlbmF0ZWQuIFBsYWluLXN0cmluZyB0b2tlbnMgaG93ZXZlclxuLy8gYXJlIGFsd2F5cyBvZiB0eXBlIFwicGxhaW5cIi5cbi8vIFRoaXMgaXMgbm90IHJlY3Vyc2l2ZSB0byBhdm9pZCBleGNlZWRpbmcgdGhlIGNhbGwtc3RhY2sgbGltaXQsIHNpbmNlIGl0J3MgdW5jbGVhclxuLy8gaG93IG5lc3RlZCBQcmlzbSdzIHRva2VucyBjYW4gYmVjb21lXG5cblxudmFyIG5vcm1hbGl6ZVRva2VucyA9IGZ1bmN0aW9uICh0b2tlbnMpIHtcbiAgdmFyIHR5cGVBcnJTdGFjayA9IFtbXV07XG4gIHZhciB0b2tlbkFyclN0YWNrID0gW3Rva2Vuc107XG4gIHZhciB0b2tlbkFyckluZGV4U3RhY2sgPSBbMF07XG4gIHZhciB0b2tlbkFyclNpemVTdGFjayA9IFt0b2tlbnMubGVuZ3RoXTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgc3RhY2tJbmRleCA9IDA7XG4gIHZhciBjdXJyZW50TGluZSA9IFtdO1xuICB2YXIgYWNjID0gW2N1cnJlbnRMaW5lXTtcblxuICB3aGlsZSAoc3RhY2tJbmRleCA+IC0xKSB7XG4gICAgd2hpbGUgKChpID0gdG9rZW5BcnJJbmRleFN0YWNrW3N0YWNrSW5kZXhdKyspIDwgdG9rZW5BcnJTaXplU3RhY2tbc3RhY2tJbmRleF0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gdm9pZCAwO1xuICAgICAgdmFyIHR5cGVzID0gdHlwZUFyclN0YWNrW3N0YWNrSW5kZXhdO1xuICAgICAgdmFyIHRva2VuQXJyID0gdG9rZW5BcnJTdGFja1tzdGFja0luZGV4XTtcbiAgICAgIHZhciB0b2tlbiA9IHRva2VuQXJyW2ldOyAvLyBEZXRlcm1pbmUgY29udGVudCBhbmQgYXBwZW5kIHR5cGUgdG8gdHlwZXMgaWYgbmVjZXNzYXJ5XG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdHlwZXMgPSBzdGFja0luZGV4ID4gMCA/IHR5cGVzIDogW1wicGxhaW5cIl07XG4gICAgICAgIGNvbnRlbnQgPSB0b2tlbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVzID0gYXBwZW5kVHlwZXModHlwZXMsIHRva2VuLnR5cGUpO1xuXG4gICAgICAgIGlmICh0b2tlbi5hbGlhcykge1xuICAgICAgICAgIHR5cGVzID0gYXBwZW5kVHlwZXModHlwZXMsIHRva2VuLmFsaWFzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRlbnQgPSB0b2tlbi5jb250ZW50O1xuICAgICAgfSAvLyBJZiB0b2tlbi5jb250ZW50IGlzIGFuIGFycmF5LCBpbmNyZWFzZSB0aGUgc3RhY2sgZGVwdGggYW5kIHJlcGVhdCB0aGlzIHdoaWxlLWxvb3BcblxuXG4gICAgICBpZiAodHlwZW9mIGNvbnRlbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3RhY2tJbmRleCsrO1xuICAgICAgICB0eXBlQXJyU3RhY2sucHVzaCh0eXBlcyk7XG4gICAgICAgIHRva2VuQXJyU3RhY2sucHVzaChjb250ZW50KTtcbiAgICAgICAgdG9rZW5BcnJJbmRleFN0YWNrLnB1c2goMCk7XG4gICAgICAgIHRva2VuQXJyU2l6ZVN0YWNrLnB1c2goY29udGVudC5sZW5ndGgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gU3BsaXQgYnkgbmV3bGluZXNcblxuXG4gICAgICB2YXIgc3BsaXRCeU5ld2xpbmVzID0gY29udGVudC5zcGxpdChuZXdsaW5lUmUpO1xuICAgICAgdmFyIG5ld2xpbmVDb3VudCA9IHNwbGl0QnlOZXdsaW5lcy5sZW5ndGg7XG4gICAgICBjdXJyZW50TGluZS5wdXNoKHtcbiAgICAgICAgdHlwZXM6IHR5cGVzLFxuICAgICAgICBjb250ZW50OiBzcGxpdEJ5TmV3bGluZXNbMF1cbiAgICAgIH0pOyAvLyBDcmVhdGUgYSBuZXcgbGluZSBmb3IgZWFjaCBzdHJpbmcgb24gYSBuZXcgbGluZVxuXG4gICAgICBmb3IgKHZhciBpJDEgPSAxOyBpJDEgPCBuZXdsaW5lQ291bnQ7IGkkMSsrKSB7XG4gICAgICAgIG5vcm1hbGl6ZUVtcHR5TGluZXMoY3VycmVudExpbmUpO1xuICAgICAgICBhY2MucHVzaChjdXJyZW50TGluZSA9IFtdKTtcbiAgICAgICAgY3VycmVudExpbmUucHVzaCh7XG4gICAgICAgICAgdHlwZXM6IHR5cGVzLFxuICAgICAgICAgIGNvbnRlbnQ6IHNwbGl0QnlOZXdsaW5lc1tpJDFdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gLy8gRGVjcmVhdGUgdGhlIHN0YWNrIGRlcHRoXG5cblxuICAgIHN0YWNrSW5kZXgtLTtcbiAgICB0eXBlQXJyU3RhY2sucG9wKCk7XG4gICAgdG9rZW5BcnJTdGFjay5wb3AoKTtcbiAgICB0b2tlbkFyckluZGV4U3RhY2sucG9wKCk7XG4gICAgdG9rZW5BcnJTaXplU3RhY2sucG9wKCk7XG4gIH1cblxuICBub3JtYWxpemVFbXB0eUxpbmVzKGN1cnJlbnRMaW5lKTtcbiAgcmV0dXJuIGFjYztcbn07XG5cbnZhciB0aGVtZVRvRGljdCA9IGZ1bmN0aW9uICh0aGVtZSwgbGFuZ3VhZ2UpIHtcbiAgdmFyIHBsYWluID0gdGhlbWUucGxhaW47IC8vICRGbG93Rml4TWVcblxuICB2YXIgYmFzZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciB0aGVtZURpY3QgPSB0aGVtZS5zdHlsZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHRoZW1lRW50cnkpIHtcbiAgICB2YXIgbGFuZ3VhZ2VzID0gdGhlbWVFbnRyeS5sYW5ndWFnZXM7XG4gICAgdmFyIHN0eWxlID0gdGhlbWVFbnRyeS5zdHlsZTtcblxuICAgIGlmIChsYW5ndWFnZXMgJiYgIWxhbmd1YWdlcy5pbmNsdWRlcyhsYW5ndWFnZSkpIHtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuXG4gICAgdGhlbWVFbnRyeS50eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICB2YXIgYWNjU3R5bGUgPSBfZXh0ZW5kcyh7fSwgYWNjW3R5cGVdLCBzdHlsZSk7XG5cbiAgICAgIGFjY1t0eXBlXSA9IGFjY1N0eWxlO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG4gIH0sIGJhc2UpOyAvLyAkRmxvd0ZpeE1lXG5cbiAgdGhlbWVEaWN0LnJvb3QgPSBwbGFpbjsgLy8gJEZsb3dGaXhNZVxuXG4gIHRoZW1lRGljdC5wbGFpbiA9IF9leHRlbmRzKHt9LCBwbGFpbiwge1xuICAgIGJhY2tncm91bmRDb2xvcjogbnVsbFxuICB9KTtcbiAgcmV0dXJuIHRoZW1lRGljdDtcbn07XG5cbmZ1bmN0aW9uIG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwgZXhjbHVkZSkge1xuICB2YXIgdGFyZ2V0ID0ge307XG5cbiAgZm9yICh2YXIgayBpbiBvYmopIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrKSAmJiBleGNsdWRlLmluZGV4T2YoaykgPT09IC0xKSB0YXJnZXRba10gPSBvYmpba107XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxudmFyIEhpZ2hsaWdodCA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoQ29tcG9uZW50KSB7XG4gIGZ1bmN0aW9uIEhpZ2hsaWdodCgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcbiAgICB2YXIgYXJncyA9IFtdLFxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbi0tKSBhcmdzW2xlbl0gPSBhcmd1bWVudHNbbGVuXTtcblxuICAgIENvbXBvbmVudC5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFRoZW1lRGljdFwiLCBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgIGlmICh0aGlzJDEudGhlbWVEaWN0ICE9PSB1bmRlZmluZWQgJiYgcHJvcHMudGhlbWUgPT09IHRoaXMkMS5wcmV2VGhlbWUgJiYgcHJvcHMubGFuZ3VhZ2UgPT09IHRoaXMkMS5wcmV2TGFuZ3VhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMkMS50aGVtZURpY3Q7XG4gICAgICB9XG5cbiAgICAgIHRoaXMkMS5wcmV2VGhlbWUgPSBwcm9wcy50aGVtZTtcbiAgICAgIHRoaXMkMS5wcmV2TGFuZ3VhZ2UgPSBwcm9wcy5sYW5ndWFnZTtcbiAgICAgIHZhciB0aGVtZURpY3QgPSBwcm9wcy50aGVtZSA/IHRoZW1lVG9EaWN0KHByb3BzLnRoZW1lLCBwcm9wcy5sYW5ndWFnZSkgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gdGhpcyQxLnRoZW1lRGljdCA9IHRoZW1lRGljdDtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldExpbmVQcm9wc1wiLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIga2V5ID0gcmVmLmtleTtcbiAgICAgIHZhciBjbGFzc05hbWUgPSByZWYuY2xhc3NOYW1lO1xuICAgICAgdmFyIHN0eWxlID0gcmVmLnN0eWxlO1xuICAgICAgdmFyIHJlc3QkMSA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHJlZiwgW1wia2V5XCIsIFwiY2xhc3NOYW1lXCIsIFwic3R5bGVcIiwgXCJsaW5lXCJdKTtcbiAgICAgIHZhciByZXN0ID0gcmVzdCQxO1xuXG4gICAgICB2YXIgb3V0cHV0ID0gX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICAgICAgY2xhc3NOYW1lOiBcInRva2VuLWxpbmVcIixcbiAgICAgICAgc3R5bGU6IHVuZGVmaW5lZCxcbiAgICAgICAga2V5OiB1bmRlZmluZWRcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgdGhlbWVEaWN0ID0gdGhpcyQxLmdldFRoZW1lRGljdCh0aGlzJDEucHJvcHMpO1xuXG4gICAgICBpZiAodGhlbWVEaWN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0cHV0LnN0eWxlID0gdGhlbWVEaWN0LnBsYWluO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRwdXQuc3R5bGUgPSBvdXRwdXQuc3R5bGUgIT09IHVuZGVmaW5lZCA/IF9leHRlbmRzKHt9LCBvdXRwdXQuc3R5bGUsIHN0eWxlKSA6IHN0eWxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0cHV0LmtleSA9IGtleTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICBvdXRwdXQuY2xhc3NOYW1lICs9IFwiIFwiICsgY2xhc3NOYW1lO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0U3R5bGVGb3JUb2tlblwiLCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIgdHlwZXMgPSByZWYudHlwZXM7XG4gICAgICB2YXIgZW1wdHkgPSByZWYuZW1wdHk7XG4gICAgICB2YXIgdHlwZXNTaXplID0gdHlwZXMubGVuZ3RoO1xuICAgICAgdmFyIHRoZW1lRGljdCA9IHRoaXMkMS5nZXRUaGVtZURpY3QodGhpcyQxLnByb3BzKTtcblxuICAgICAgaWYgKHRoZW1lRGljdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVzU2l6ZSA9PT0gMSAmJiB0eXBlc1swXSA9PT0gXCJwbGFpblwiKSB7XG4gICAgICAgIHJldHVybiBlbXB0eSA/IHtcbiAgICAgICAgICBkaXNwbGF5OiBcImlubGluZS1ibG9ja1wiXG4gICAgICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVzU2l6ZSA9PT0gMSAmJiAhZW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIHRoZW1lRGljdFt0eXBlc1swXV07XG4gICAgICB9XG5cbiAgICAgIHZhciBiYXNlU3R5bGUgPSBlbXB0eSA/IHtcbiAgICAgICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIlxuICAgICAgfSA6IHt9OyAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgIHZhciB0eXBlU3R5bGVzID0gdHlwZXMubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGVtZURpY3RbdHlwZV07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCwgW2Jhc2VTdHlsZV0uY29uY2F0KHR5cGVTdHlsZXMpKTtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldFRva2VuUHJvcHNcIiwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIGtleSA9IHJlZi5rZXk7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gcmVmLmNsYXNzTmFtZTtcbiAgICAgIHZhciBzdHlsZSA9IHJlZi5zdHlsZTtcbiAgICAgIHZhciB0b2tlbiA9IHJlZi50b2tlbjtcbiAgICAgIHZhciByZXN0JDEgPSBvYmplY3RXaXRob3V0UHJvcGVydGllcyhyZWYsIFtcImtleVwiLCBcImNsYXNzTmFtZVwiLCBcInN0eWxlXCIsIFwidG9rZW5cIl0pO1xuICAgICAgdmFyIHJlc3QgPSByZXN0JDE7XG5cbiAgICAgIHZhciBvdXRwdXQgPSBfZXh0ZW5kcyh7fSwgcmVzdCwge1xuICAgICAgICBjbGFzc05hbWU6IFwidG9rZW4gXCIgKyB0b2tlbi50eXBlcy5qb2luKFwiIFwiKSxcbiAgICAgICAgY2hpbGRyZW46IHRva2VuLmNvbnRlbnQsXG4gICAgICAgIHN0eWxlOiB0aGlzJDEuZ2V0U3R5bGVGb3JUb2tlbih0b2tlbiksXG4gICAgICAgIGtleTogdW5kZWZpbmVkXG4gICAgICB9KTtcblxuICAgICAgaWYgKHN0eWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3V0cHV0LnN0eWxlID0gb3V0cHV0LnN0eWxlICE9PSB1bmRlZmluZWQgPyBfZXh0ZW5kcyh7fSwgb3V0cHV0LnN0eWxlLCBzdHlsZSkgOiBzdHlsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dHB1dC5rZXkgPSBrZXk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgb3V0cHV0LmNsYXNzTmFtZSArPSBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInRva2VuaXplXCIsIGZ1bmN0aW9uIChQcmlzbSwgY29kZSwgZ3JhbW1hciwgbGFuZ3VhZ2UpIHtcbiAgICAgIHZhciBlbnYgPSB7XG4gICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgIGdyYW1tYXI6IGdyYW1tYXIsXG4gICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZSxcbiAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgfTtcbiAgICAgIFByaXNtLmhvb2tzLnJ1bihcImJlZm9yZS10b2tlbml6ZVwiLCBlbnYpO1xuICAgICAgdmFyIHRva2VucyA9IGVudi50b2tlbnMgPSBQcmlzbS50b2tlbml6ZShlbnYuY29kZSwgZW52LmdyYW1tYXIsIGVudi5sYW5ndWFnZSk7XG4gICAgICBQcmlzbS5ob29rcy5ydW4oXCJhZnRlci10b2tlbml6ZVwiLCBlbnYpO1xuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChDb21wb25lbnQpIEhpZ2hsaWdodC5fX3Byb3RvX18gPSBDb21wb25lbnQ7XG4gIEhpZ2hsaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENvbXBvbmVudCAmJiBDb21wb25lbnQucHJvdG90eXBlKTtcbiAgSGlnaGxpZ2h0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhpZ2hsaWdodDtcblxuICBIaWdobGlnaHQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgcmVmID0gdGhpcy5wcm9wcztcbiAgICB2YXIgUHJpc20gPSByZWYuUHJpc207XG4gICAgdmFyIGxhbmd1YWdlID0gcmVmLmxhbmd1YWdlO1xuICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG4gICAgdmFyIGNoaWxkcmVuID0gcmVmLmNoaWxkcmVuO1xuICAgIHZhciB0aGVtZURpY3QgPSB0aGlzLmdldFRoZW1lRGljdCh0aGlzLnByb3BzKTtcbiAgICB2YXIgZ3JhbW1hciA9IFByaXNtLmxhbmd1YWdlc1tsYW5ndWFnZV07XG4gICAgdmFyIG1peGVkVG9rZW5zID0gZ3JhbW1hciAhPT0gdW5kZWZpbmVkID8gdGhpcy50b2tlbml6ZShQcmlzbSwgY29kZSwgZ3JhbW1hciwgbGFuZ3VhZ2UpIDogW2NvZGVdO1xuICAgIHZhciB0b2tlbnMgPSBub3JtYWxpemVUb2tlbnMobWl4ZWRUb2tlbnMpO1xuICAgIHJldHVybiBjaGlsZHJlbih7XG4gICAgICB0b2tlbnM6IHRva2VucyxcbiAgICAgIGNsYXNzTmFtZTogXCJwcmlzbS1jb2RlIGxhbmd1YWdlLVwiICsgbGFuZ3VhZ2UsXG4gICAgICBzdHlsZTogdGhlbWVEaWN0ICE9PSB1bmRlZmluZWQgPyB0aGVtZURpY3Qucm9vdCA6IHt9LFxuICAgICAgZ2V0TGluZVByb3BzOiB0aGlzLmdldExpbmVQcm9wcyxcbiAgICAgIGdldFRva2VuUHJvcHM6IHRoaXMuZ2V0VG9rZW5Qcm9wc1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBIaWdobGlnaHQ7XG59KENvbXBvbmVudCk7XG5cbmV4cG9ydCBkZWZhdWx0IEhpZ2hsaWdodDtcbmV4cG9ydCB7IGRlZmF1bHRQcm9wcyB9O1xuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgZGVmYXVsdCB7XCJjb2RlTGluZVwiOlwiY29kZUxpbmVfbEpTX1wiLFwiY29kZUxpbmVOdW1iZXJcIjpcImNvZGVMaW5lTnVtYmVyX1RmZGRcIixcImNvZGVMaW5lQ29udGVudFwiOlwiY29kZUxpbmVDb250ZW50X2ZlYVZcIn07IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlcy5tb2R1bGUuY3NzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvZGVCbG9ja0xpbmUoe1xuICBsaW5lLFxuICBjbGFzc05hbWVzLFxuICBzaG93TGluZU51bWJlcnMsXG4gIGdldExpbmVQcm9wcyxcbiAgZ2V0VG9rZW5Qcm9wcyxcbn0pIHtcbiAgaWYgKGxpbmUubGVuZ3RoID09PSAxICYmIGxpbmVbMF0uY29udGVudCA9PT0gJ1xcbicpIHtcbiAgICBsaW5lWzBdLmNvbnRlbnQgPSAnJztcbiAgfVxuICBjb25zdCBsaW5lUHJvcHMgPSBnZXRMaW5lUHJvcHMoe1xuICAgIGxpbmUsXG4gICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzTmFtZXMsIHNob3dMaW5lTnVtYmVycyAmJiBzdHlsZXMuY29kZUxpbmUpLFxuICB9KTtcbiAgY29uc3QgbGluZVRva2VucyA9IGxpbmUubWFwKCh0b2tlbiwga2V5KSA9PiAoXG4gICAgPHNwYW4ga2V5PXtrZXl9IHsuLi5nZXRUb2tlblByb3BzKHt0b2tlbiwga2V5fSl9IC8+XG4gICkpO1xuICByZXR1cm4gKFxuICAgIDxzcGFuIHsuLi5saW5lUHJvcHN9PlxuICAgICAge3Nob3dMaW5lTnVtYmVycyA/IChcbiAgICAgICAgPD5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5jb2RlTGluZU51bWJlcn0gLz5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9e3N0eWxlcy5jb2RlTGluZUNvbnRlbnR9PntsaW5lVG9rZW5zfTwvc3Bhbj5cbiAgICAgICAgPC8+XG4gICAgICApIDogKFxuICAgICAgICBsaW5lVG9rZW5zXG4gICAgICApfVxuICAgICAgPGJyIC8+XG4gICAgPC9zcGFuPlxuICApO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29weVRleHRUb0NsaXBib2FyZChpbnB1dCwge3RhcmdldCA9IGRvY3VtZW50LmJvZHl9ID0ge30pIHtcblx0Y29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG5cdGNvbnN0IHByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cblx0ZWxlbWVudC52YWx1ZSA9IGlucHV0O1xuXG5cdC8vIFByZXZlbnQga2V5Ym9hcmQgZnJvbSBzaG93aW5nIG9uIG1vYmlsZVxuXHRlbGVtZW50LnNldEF0dHJpYnV0ZSgncmVhZG9ubHknLCAnJyk7XG5cblx0ZWxlbWVudC5zdHlsZS5jb250YWluID0gJ3N0cmljdCc7XG5cdGVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRlbGVtZW50LnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG5cdGVsZW1lbnQuc3R5bGUuZm9udFNpemUgPSAnMTJwdCc7IC8vIFByZXZlbnQgem9vbWluZyBvbiBpT1NcblxuXHRjb25zdCBzZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRTZWxlY3Rpb24oKTtcblx0bGV0IG9yaWdpbmFsUmFuZ2UgPSBmYWxzZTtcblx0aWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuXHRcdG9yaWdpbmFsUmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcblx0fVxuXG5cdHRhcmdldC5hcHBlbmQoZWxlbWVudCk7XG5cdGVsZW1lbnQuc2VsZWN0KCk7XG5cblx0Ly8gRXhwbGljaXQgc2VsZWN0aW9uIHdvcmthcm91bmQgZm9yIGlPU1xuXHRlbGVtZW50LnNlbGVjdGlvblN0YXJ0ID0gMDtcblx0ZWxlbWVudC5zZWxlY3Rpb25FbmQgPSBpbnB1dC5sZW5ndGg7XG5cblx0bGV0IGlzU3VjY2VzcyA9IGZhbHNlO1xuXHR0cnkge1xuXHRcdGlzU3VjY2VzcyA9IGRvY3VtZW50LmV4ZWNDb21tYW5kKCdjb3B5Jyk7XG5cdH0gY2F0Y2gge31cblxuXHRlbGVtZW50LnJlbW92ZSgpO1xuXG5cdGlmIChvcmlnaW5hbFJhbmdlKSB7XG5cdFx0c2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXHRcdHNlbGVjdGlvbi5hZGRSYW5nZShvcmlnaW5hbFJhbmdlKTtcblx0fVxuXG5cdC8vIEdldCB0aGUgZm9jdXMgYmFjayBvbiB0aGUgcHJldmlvdXNseSBmb2N1c2VkIGVsZW1lbnQsIGlmIGFueVxuXHRpZiAocHJldmlvdXNseUZvY3VzZWRFbGVtZW50KSB7XG5cdFx0cHJldmlvdXNseUZvY3VzZWRFbGVtZW50LmZvY3VzKCk7XG5cdH1cblxuXHRyZXR1cm4gaXNTdWNjZXNzO1xufVxuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgZGVmYXVsdCB7XCJjb3B5QnV0dG9uQ29waWVkXCI6XCJjb3B5QnV0dG9uQ29waWVkX29iSDRcIixcImNvcHlCdXR0b25JY29uc1wiOlwiY29weUJ1dHRvbkljb25zX2VTZ0FcIixcImNvcHlCdXR0b25JY29uXCI6XCJjb3B5QnV0dG9uSWNvbl95OTdOXCIsXCJjb3B5QnV0dG9uU3VjY2Vzc0ljb25cIjpcImNvcHlCdXR0b25TdWNjZXNzSWNvbl9MamRTXCJ9OyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmltcG9ydCBSZWFjdCwge3VzZUNhbGxiYWNrLCB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VFZmZlY3R9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuLy8gQHRzLWV4cGVjdC1lcnJvcjogVE9ETywgd2UgbmVlZCB0byBtYWtlIHRoZW1lLWNsYXNzaWMgaGF2ZSB0eXBlOiBtb2R1bGVcbmltcG9ydCBjb3B5IGZyb20gJ2NvcHktdGV4dC10by1jbGlwYm9hcmQnO1xuaW1wb3J0IHt0cmFuc2xhdGV9IGZyb20gJ0Bkb2N1c2F1cnVzL1RyYW5zbGF0ZSc7XG5pbXBvcnQgc3R5bGVzIGZyb20gJy4vc3R5bGVzLm1vZHVsZS5jc3MnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ29weUJ1dHRvbih7Y29kZSwgY2xhc3NOYW1lfSkge1xuICBjb25zdCBbaXNDb3BpZWQsIHNldElzQ29waWVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgY29weVRpbWVvdXQgPSB1c2VSZWYodW5kZWZpbmVkKTtcbiAgY29uc3QgaGFuZGxlQ29weUNvZGUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgY29weShjb2RlKTtcbiAgICBzZXRJc0NvcGllZCh0cnVlKTtcbiAgICBjb3B5VGltZW91dC5jdXJyZW50ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc2V0SXNDb3BpZWQoZmFsc2UpO1xuICAgIH0sIDEwMDApO1xuICB9LCBbY29kZV0pO1xuICB1c2VFZmZlY3QoKCkgPT4gKCkgPT4gd2luZG93LmNsZWFyVGltZW91dChjb3B5VGltZW91dC5jdXJyZW50KSwgW10pO1xuICByZXR1cm4gKFxuICAgIDxidXR0b25cbiAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgYXJpYS1sYWJlbD17XG4gICAgICAgIGlzQ29waWVkXG4gICAgICAgICAgPyB0cmFuc2xhdGUoe1xuICAgICAgICAgICAgICBpZDogJ3RoZW1lLkNvZGVCbG9jay5jb3BpZWQnLFxuICAgICAgICAgICAgICBtZXNzYWdlOiAnQ29waWVkJyxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgY29waWVkIGJ1dHRvbiBsYWJlbCBvbiBjb2RlIGJsb2NrcycsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIDogdHJhbnNsYXRlKHtcbiAgICAgICAgICAgICAgaWQ6ICd0aGVtZS5Db2RlQmxvY2suY29weUJ1dHRvbkFyaWFMYWJlbCcsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6ICdDb3B5IGNvZGUgdG8gY2xpcGJvYXJkJyxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgQVJJQSBsYWJlbCBmb3IgY29weSBjb2RlIGJsb2NrcyBidXR0b24nLFxuICAgICAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIHRpdGxlPXt0cmFuc2xhdGUoe1xuICAgICAgICBpZDogJ3RoZW1lLkNvZGVCbG9jay5jb3B5JyxcbiAgICAgICAgbWVzc2FnZTogJ0NvcHknLFxuICAgICAgICBkZXNjcmlwdGlvbjogJ1RoZSBjb3B5IGJ1dHRvbiBsYWJlbCBvbiBjb2RlIGJsb2NrcycsXG4gICAgICB9KX1cbiAgICAgIGNsYXNzTmFtZT17Y2xzeChcbiAgICAgICAgJ2NsZWFuLWJ0bicsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgc3R5bGVzLmNvcHlCdXR0b24sXG4gICAgICAgIGlzQ29waWVkICYmIHN0eWxlcy5jb3B5QnV0dG9uQ29waWVkLFxuICAgICAgKX1cbiAgICAgIG9uQ2xpY2s9e2hhbmRsZUNvcHlDb2RlfT5cbiAgICAgIDxzcGFuIGNsYXNzTmFtZT17c3R5bGVzLmNvcHlCdXR0b25JY29uc30gYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICAgIDxzdmcgY2xhc3NOYW1lPXtzdHlsZXMuY29weUJ1dHRvbkljb259IHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgICA8cGF0aCBkPVwiTTE5LDIxSDhWN0gxOU0xOSw1SDhBMiwyIDAgMCwwIDYsN1YyMUEyLDIgMCAwLDAgOCwyM0gxOUEyLDIgMCAwLDAgMjEsMjFWN0EyLDIgMCAwLDAgMTksNU0xNiwxSDRBMiwyIDAgMCwwIDIsM1YxN0g0VjNIMTZWMVpcIiAvPlxuICAgICAgICA8L3N2Zz5cbiAgICAgICAgPHN2ZyBjbGFzc05hbWU9e3N0eWxlcy5jb3B5QnV0dG9uU3VjY2Vzc0ljb259IHZpZXdCb3g9XCIwIDAgMjQgMjRcIj5cbiAgICAgICAgICA8cGF0aCBkPVwiTTIxLDdMOSwxOUwzLjUsMTMuNUw0LjkxLDEyLjA5TDksMTYuMTdMMTkuNTksNS41OUwyMSw3WlwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9zcGFuPlxuICAgIDwvYnV0dG9uPlxuICApO1xufVxuIiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQgZGVmYXVsdCB7XCJ3b3JkV3JhcEJ1dHRvbkljb25cIjpcIndvcmRXcmFwQnV0dG9uSWNvbl9Cd21hXCIsXCJ3b3JkV3JhcEJ1dHRvbkVuYWJsZWRcIjpcIndvcmRXcmFwQnV0dG9uRW5hYmxlZF9Fb2VQXCJ9OyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCB7dHJhbnNsYXRlfSBmcm9tICdAZG9jdXNhdXJ1cy9UcmFuc2xhdGUnO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlcy5tb2R1bGUuY3NzJztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFdvcmRXcmFwQnV0dG9uKHtjbGFzc05hbWUsIG9uQ2xpY2ssIGlzRW5hYmxlZH0pIHtcbiAgY29uc3QgdGl0bGUgPSB0cmFuc2xhdGUoe1xuICAgIGlkOiAndGhlbWUuQ29kZUJsb2NrLndvcmRXcmFwVG9nZ2xlJyxcbiAgICBtZXNzYWdlOiAnVG9nZ2xlIHdvcmQgd3JhcCcsXG4gICAgZGVzY3JpcHRpb246XG4gICAgICAnVGhlIHRpdGxlIGF0dHJpYnV0ZSBmb3IgdG9nZ2xlIHdvcmQgd3JhcHBpbmcgYnV0dG9uIG9mIGNvZGUgYmxvY2sgbGluZXMnLFxuICB9KTtcbiAgcmV0dXJuIChcbiAgICA8YnV0dG9uXG4gICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgIG9uQ2xpY2s9e29uQ2xpY2t9XG4gICAgICBjbGFzc05hbWU9e2Nsc3goXG4gICAgICAgICdjbGVhbi1idG4nLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIGlzRW5hYmxlZCAmJiBzdHlsZXMud29yZFdyYXBCdXR0b25FbmFibGVkLFxuICAgICAgKX1cbiAgICAgIGFyaWEtbGFiZWw9e3RpdGxlfVxuICAgICAgdGl0bGU9e3RpdGxlfT5cbiAgICAgIDxzdmdcbiAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMud29yZFdyYXBCdXR0b25JY29ufVxuICAgICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCJcbiAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgZmlsbD1cImN1cnJlbnRDb2xvclwiXG4gICAgICAgICAgZD1cIk00IDE5aDZ2LTJINHYyek0yMCA1SDR2MmgxNlY1em0tMyA2SDR2MmgxMy4yNWMxLjEgMCAyIC45IDIgMnMtLjkgMi0yIDJIMTV2LTJsLTMgM2wzIDN2LTJoMmMyLjIxIDAgNC0xLjc5IDQtNHMtMS43OS00LTQtNHpcIlxuICAgICAgICAvPlxuICAgICAgPC9zdmc+XG4gICAgPC9idXR0b24+XG4gICk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQge3VzZVRoZW1lQ29uZmlnLCB1c2VQcmlzbVRoZW1lfSBmcm9tICdAZG9jdXNhdXJ1cy90aGVtZS1jb21tb24nO1xuaW1wb3J0IHtcbiAgcGFyc2VDb2RlQmxvY2tUaXRsZSxcbiAgcGFyc2VMYW5ndWFnZSxcbiAgcGFyc2VMaW5lcyxcbiAgY29udGFpbnNMaW5lTnVtYmVycyxcbiAgdXNlQ29kZVdvcmRXcmFwLFxufSBmcm9tICdAZG9jdXNhdXJ1cy90aGVtZS1jb21tb24vaW50ZXJuYWwnO1xuaW1wb3J0IEhpZ2hsaWdodCwge2RlZmF1bHRQcm9wc30gZnJvbSAncHJpc20tcmVhY3QtcmVuZGVyZXInO1xuaW1wb3J0IExpbmUgZnJvbSAnQHRoZW1lL0NvZGVCbG9jay9MaW5lJztcbmltcG9ydCBDb3B5QnV0dG9uIGZyb20gJ0B0aGVtZS9Db2RlQmxvY2svQ29weUJ1dHRvbic7XG5pbXBvcnQgV29yZFdyYXBCdXR0b24gZnJvbSAnQHRoZW1lL0NvZGVCbG9jay9Xb3JkV3JhcEJ1dHRvbic7XG5pbXBvcnQgQ29udGFpbmVyIGZyb20gJ0B0aGVtZS9Db2RlQmxvY2svQ29udGFpbmVyJztcbmltcG9ydCBzdHlsZXMgZnJvbSAnLi9zdHlsZXMubW9kdWxlLmNzcyc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb2RlQmxvY2tTdHJpbmcoe1xuICBjaGlsZHJlbixcbiAgY2xhc3NOYW1lOiBibG9ja0NsYXNzTmFtZSA9ICcnLFxuICBtZXRhc3RyaW5nLFxuICB0aXRsZTogdGl0bGVQcm9wLFxuICBzaG93TGluZU51bWJlcnM6IHNob3dMaW5lTnVtYmVyc1Byb3AsXG4gIGxhbmd1YWdlOiBsYW5ndWFnZVByb3AsXG59KSB7XG4gIGNvbnN0IHtcbiAgICBwcmlzbToge2RlZmF1bHRMYW5ndWFnZSwgbWFnaWNDb21tZW50c30sXG4gIH0gPSB1c2VUaGVtZUNvbmZpZygpO1xuICBjb25zdCBsYW5ndWFnZSA9XG4gICAgbGFuZ3VhZ2VQcm9wID8/IHBhcnNlTGFuZ3VhZ2UoYmxvY2tDbGFzc05hbWUpID8/IGRlZmF1bHRMYW5ndWFnZTtcbiAgY29uc3QgcHJpc21UaGVtZSA9IHVzZVByaXNtVGhlbWUoKTtcbiAgY29uc3Qgd29yZFdyYXAgPSB1c2VDb2RlV29yZFdyYXAoKTtcbiAgLy8gV2Ugc3RpbGwgcGFyc2UgdGhlIG1ldGFzdHJpbmcgaW4gY2FzZSB3ZSB3YW50IHRvIHN1cHBvcnQgbW9yZSBzeW50YXggaW4gdGhlXG4gIC8vIGZ1dHVyZS4gTm90ZSB0aGF0IE1EWCBkb2Vzbid0IHN0cmlwIHF1b3RlcyB3aGVuIHBhcnNpbmcgbWV0YXN0cmluZzpcbiAgLy8gXCJ0aXRsZT1cXFwieHl6XFxcIlwiID0+IHRpdGxlOiBcIlxcXCJ4eXpcXFwiXCJcbiAgY29uc3QgdGl0bGUgPSBwYXJzZUNvZGVCbG9ja1RpdGxlKG1ldGFzdHJpbmcpIHx8IHRpdGxlUHJvcDtcbiAgY29uc3Qge2xpbmVDbGFzc05hbWVzLCBjb2RlfSA9IHBhcnNlTGluZXMoY2hpbGRyZW4sIHtcbiAgICBtZXRhc3RyaW5nLFxuICAgIGxhbmd1YWdlLFxuICAgIG1hZ2ljQ29tbWVudHMsXG4gIH0pO1xuICBjb25zdCBzaG93TGluZU51bWJlcnMgPVxuICAgIHNob3dMaW5lTnVtYmVyc1Byb3AgPz8gY29udGFpbnNMaW5lTnVtYmVycyhtZXRhc3RyaW5nKTtcbiAgcmV0dXJuIChcbiAgICA8Q29udGFpbmVyXG4gICAgICBhcz1cImRpdlwiXG4gICAgICBjbGFzc05hbWU9e2Nsc3goXG4gICAgICAgIGJsb2NrQ2xhc3NOYW1lLFxuICAgICAgICBsYW5ndWFnZSAmJlxuICAgICAgICAgICFibG9ja0NsYXNzTmFtZS5pbmNsdWRlcyhgbGFuZ3VhZ2UtJHtsYW5ndWFnZX1gKSAmJlxuICAgICAgICAgIGBsYW5ndWFnZS0ke2xhbmd1YWdlfWAsXG4gICAgICApfT5cbiAgICAgIHt0aXRsZSAmJiA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmNvZGVCbG9ja1RpdGxlfT57dGl0bGV9PC9kaXY+fVxuICAgICAgPGRpdiBjbGFzc05hbWU9e3N0eWxlcy5jb2RlQmxvY2tDb250ZW50fT5cbiAgICAgICAgPEhpZ2hsaWdodFxuICAgICAgICAgIHsuLi5kZWZhdWx0UHJvcHN9XG4gICAgICAgICAgdGhlbWU9e3ByaXNtVGhlbWV9XG4gICAgICAgICAgY29kZT17Y29kZX1cbiAgICAgICAgICBsYW5ndWFnZT17bGFuZ3VhZ2UgPz8gJ3RleHQnfT5cbiAgICAgICAgICB7KHtjbGFzc05hbWUsIHRva2VucywgZ2V0TGluZVByb3BzLCBnZXRUb2tlblByb3BzfSkgPT4gKFxuICAgICAgICAgICAgPHByZVxuICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUganN4LWExMXkvbm8tbm9uaW50ZXJhY3RpdmUtdGFiaW5kZXggKi9cbiAgICAgICAgICAgICAgdGFiSW5kZXg9ezB9XG4gICAgICAgICAgICAgIHJlZj17d29yZFdyYXAuY29kZUJsb2NrUmVmfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9e2Nsc3goY2xhc3NOYW1lLCBzdHlsZXMuY29kZUJsb2NrLCAndGhpbi1zY3JvbGxiYXInKX0+XG4gICAgICAgICAgICAgIDxjb2RlXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPXtjbHN4KFxuICAgICAgICAgICAgICAgICAgc3R5bGVzLmNvZGVCbG9ja0xpbmVzLFxuICAgICAgICAgICAgICAgICAgc2hvd0xpbmVOdW1iZXJzICYmIHN0eWxlcy5jb2RlQmxvY2tMaW5lc1dpdGhOdW1iZXJpbmcsXG4gICAgICAgICAgICAgICAgKX0+XG4gICAgICAgICAgICAgICAge3Rva2Vucy5tYXAoKGxpbmUsIGkpID0+IChcbiAgICAgICAgICAgICAgICAgIDxMaW5lXG4gICAgICAgICAgICAgICAgICAgIGtleT17aX1cbiAgICAgICAgICAgICAgICAgICAgbGluZT17bGluZX1cbiAgICAgICAgICAgICAgICAgICAgZ2V0TGluZVByb3BzPXtnZXRMaW5lUHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIGdldFRva2VuUHJvcHM9e2dldFRva2VuUHJvcHN9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZXM9e2xpbmVDbGFzc05hbWVzW2ldfVxuICAgICAgICAgICAgICAgICAgICBzaG93TGluZU51bWJlcnM9e3Nob3dMaW5lTnVtYmVyc31cbiAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgIDwvY29kZT5cbiAgICAgICAgICAgIDwvcHJlPlxuICAgICAgICAgICl9XG4gICAgICAgIDwvSGlnaGxpZ2h0PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmJ1dHRvbkdyb3VwfT5cbiAgICAgICAgICB7KHdvcmRXcmFwLmlzRW5hYmxlZCB8fCB3b3JkV3JhcC5pc0NvZGVTY3JvbGxhYmxlKSAmJiAoXG4gICAgICAgICAgICA8V29yZFdyYXBCdXR0b25cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMuY29kZUJ1dHRvbn1cbiAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gd29yZFdyYXAudG9nZ2xlKCl9XG4gICAgICAgICAgICAgIGlzRW5hYmxlZD17d29yZFdyYXAuaXNFbmFibGVkfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApfVxuICAgICAgICAgIDxDb3B5QnV0dG9uIGNsYXNzTmFtZT17c3R5bGVzLmNvZGVCdXR0b259IGNvZGU9e2NvZGV9IC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9Db250YWluZXI+XG4gICk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5pbXBvcnQgUmVhY3QsIHtpc1ZhbGlkRWxlbWVudH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVzZUlzQnJvd3NlciBmcm9tICdAZG9jdXNhdXJ1cy91c2VJc0Jyb3dzZXInO1xuaW1wb3J0IEVsZW1lbnRDb250ZW50IGZyb20gJ0B0aGVtZS9Db2RlQmxvY2svQ29udGVudC9FbGVtZW50JztcbmltcG9ydCBTdHJpbmdDb250ZW50IGZyb20gJ0B0aGVtZS9Db2RlQmxvY2svQ29udGVudC9TdHJpbmcnO1xuLyoqXG4gKiBCZXN0IGF0dGVtcHQgdG8gbWFrZSB0aGUgY2hpbGRyZW4gYSBwbGFpbiBzdHJpbmcgc28gaXQgaXMgY29weWFibGUuIElmIHRoZXJlXG4gKiBhcmUgcmVhY3QgZWxlbWVudHMsIHdlIHdpbGwgbm90IGJlIGFibGUgdG8gY29weSB0aGUgY29udGVudCwgYW5kIGl0IHdpbGxcbiAqIHJldHVybiBgY2hpbGRyZW5gIGFzLWlzOyBvdGhlcndpc2UsIGl0IGNvbmNhdGVuYXRlcyB0aGUgc3RyaW5nIGNoaWxkcmVuXG4gKiB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWF5YmVTdHJpbmdpZnlDaGlsZHJlbihjaGlsZHJlbikge1xuICBpZiAoUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbikuc29tZSgoZWwpID0+IGlzVmFsaWRFbGVtZW50KGVsKSkpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgLy8gVGhlIGNoaWxkcmVuIGlzIG5vdyBndWFyYW50ZWVkIHRvIGJlIG9uZS9tb3JlIHBsYWluIHN0cmluZ3NcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW4uam9pbignJykgOiBjaGlsZHJlbjtcbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvZGVCbG9jayh7Y2hpbGRyZW46IHJhd0NoaWxkcmVuLCAuLi5wcm9wc30pIHtcbiAgLy8gVGhlIFByaXNtIHRoZW1lIG9uIFNTUiBpcyBhbHdheXMgdGhlIGRlZmF1bHQgdGhlbWUgYnV0IHRoZSBzaXRlIHRoZW1lIGNhblxuICAvLyBiZSBpbiBhIGRpZmZlcmVudCBtb2RlLiBSZWFjdCBoeWRyYXRpb24gZG9lc24ndCB1cGRhdGUgRE9NIHN0eWxlcyB0aGF0IGNvbWVcbiAgLy8gZnJvbSBTU1IuIEhlbmNlIGZvcmNlIGEgcmUtcmVuZGVyIGFmdGVyIG1vdW50aW5nIHRvIGFwcGx5IHRoZSBjdXJyZW50XG4gIC8vIHJlbGV2YW50IHN0eWxlcy5cbiAgY29uc3QgaXNCcm93c2VyID0gdXNlSXNCcm93c2VyKCk7XG4gIGNvbnN0IGNoaWxkcmVuID0gbWF5YmVTdHJpbmdpZnlDaGlsZHJlbihyYXdDaGlsZHJlbik7XG4gIGNvbnN0IENvZGVCbG9ja0NvbXAgPVxuICAgIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycgPyBTdHJpbmdDb250ZW50IDogRWxlbWVudENvbnRlbnQ7XG4gIHJldHVybiAoXG4gICAgPENvZGVCbG9ja0NvbXAga2V5PXtTdHJpbmcoaXNCcm93c2VyKX0gey4uLnByb3BzfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0NvZGVCbG9ja0NvbXA+XG4gICk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmltcG9ydCB7IHVzZVByaXNtVGhlbWUgfSBmcm9tICdAZG9jdXNhdXJ1cy90aGVtZS1jb21tb24nXG5pbXBvcnQgc3R5bGVkLCB7IGNzcyB9IGZyb20gJ0BzaXRlL3NyYy9zc2MnXG5pbXBvcnQgQ29kZUJsb2NrIGZyb20gJ0B0aGVtZS1pbml0L0NvZGVCbG9jaydcbmltcG9ydCBQcmlzbSBmcm9tICdwcmlzbWpzJ1xuaW1wb3J0ICdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tanN4J1xuaW1wb3J0ICdwcmlzbWpzL2NvbXBvbmVudHMvcHJpc20tdHlwZXNjcmlwdCdcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLXRzeCdcbmltcG9ydCAncHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWJhc2gnXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBTYW5kYm94IH0gZnJvbSAnLi9TYW5kYm94J1xuXG5jb25zdCBDb2RlID0gc3R5bGVkLmNvZGU8eyAkc3NjUHJvcHM6IFJldHVyblR5cGU8dHlwZW9mIHVzZVByaXNtVGhlbWU+IH0+YFxuICBkaXNwbGF5OiBibG9jaztcblxuICAudG9rZW4ge1xuICAgIGNvbG9yOiAjZDdkZmVjO1xuXG4gICAgJHsoeyAkc3NjUHJvcHMgfSkgPT5cbiAgICAgICRzc2NQcm9wcy5zdHlsZXNcbiAgICAgICAgLm1hcCgoeyBzdHlsZSwgdHlwZXMgfSkgPT5cbiAgICAgICAgICB0eXBlc1xuICAgICAgICAgICAgLm1hcChcbiAgICAgICAgICAgICAgdHlwZSA9PlxuICAgICAgICAgICAgICAgIGAmLiR7dHlwZX0geyAke2NzcyhcbiAgICAgICAgICAgICAgICAgIHN0eWxlIGFzIGFueSAvKiBQcmlzbSBmb250LXdlaWdodCB0eXBlIGlzIHdyb25nICovXG4gICAgICAgICAgICAgICAgKX0gfWBcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIC5qb2luKCdcXG4nKVxuICAgICAgICApXG4gICAgICAgIC5qb2luKCdcXG4nKX1cblxuICAgICYuY29tbWVudCB7XG4gICAgICBmb250LXN0eWxlOiBpdGFsaWM7XG4gICAgfVxuXG4gICAgJi5rZXl3b3JkIHtcbiAgICAgIGNvbG9yOiAjZTA4YTU3O1xuICAgIH1cbiAgfVxuYFxuXG5jb25zdCByZW5kZXJUb2tlbnMgPSAodG9rZW5zOiAoc3RyaW5nIHwgUHJpc20uVG9rZW4pW10pID0+XG4gIHRva2Vucy5tYXAoKHRva2VuLCBpKSA9PiAoXG4gICAgPHNwYW5cbiAgICAgIGNsYXNzTmFtZT17YHRva2VuICR7dHlwZW9mIHRva2VuID09PSAnc3RyaW5nJyA/ICcnIDogdG9rZW4udHlwZX1gfVxuICAgICAga2V5PXtpfVxuICAgID5cbiAgICAgIHt0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnXG4gICAgICAgID8gdG9rZW5cbiAgICAgICAgOiB0eXBlb2YgdG9rZW4uY29udGVudCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyB0b2tlbi5jb250ZW50XG4gICAgICAgIDogcmVuZGVyVG9rZW5zKFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh0b2tlbi5jb250ZW50KSA/IHRva2VuLmNvbnRlbnQgOiBbdG9rZW4uY29udGVudF1cbiAgICAgICAgICApfVxuICAgIDwvc3Bhbj5cbiAgKSlcblxuY29uc3Qgd2l0aExpdmVFZGl0b3IgPSAoQ29tcG9uZW50OiB0eXBlb2YgQ29kZUJsb2NrKSA9PiB7XG4gIGZ1bmN0aW9uIFdyYXBwZWRDb21wb25lbnQocHJvcHM6IGFueSkge1xuICAgIGNvbnN0IHRoZW1lID0gdXNlUHJpc21UaGVtZSgpXG5cbiAgICBpZiAocHJvcHMubGl2ZSkge1xuICAgICAgcmV0dXJuIDxTYW5kYm94IHsuLi5wcm9wc30gLz5cbiAgICB9XG5cbiAgICByZXR1cm4gPENvbXBvbmVudCB7Li4ucHJvcHN9IC8+XG5cbiAgICBjb25zdCB0b2tlbnMgPSBQcmlzbS50b2tlbml6ZShcbiAgICAgIHByb3BzLmNoaWxkcmVuLFxuICAgICAgUHJpc20ubGFuZ3VhZ2VzW3Byb3BzLmxhbmd1YWdlIHx8IHByb3BzLmNsYXNzTmFtZT8uc3BsaXQoJy0nKVsxXSB8fCAndHN4J11cbiAgICApXG5cbiAgICByZXR1cm4gKFxuICAgICAgPD5cbiAgICAgICAgPGRpdlxuICAgICAgICAgIGNsYXNzTmFtZT1cImNvZGVCbG9ja0NvbnRhaW5lcl9ub2RlX21vZHVsZXMtQGRvY3VzYXVydXMtdGhlbWUtY2xhc3NpYy1saWItdGhlbWUtQ29kZUJsb2NrLUNvbnRhaW5lci1zdHlsZXMtbW9kdWxlIHRoZW1lLWNvZGUtYmxvY2tcIlxuICAgICAgICAgIHN0eWxlPXtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgJy0tcHJpc20tY29sb3InOiAnI2JmYzdkNScsXG4gICAgICAgICAgICAgICctLXByaXNtLWJhY2tncm91bmQtY29sb3InOiAnIzI5MmQzZScsXG4gICAgICAgICAgICB9IGFzIGFueVxuICAgICAgICAgIH1cbiAgICAgICAgPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29kZUJsb2NrQ29udGVudF9ub2RlX21vZHVsZXMtQGRvY3VzYXVydXMtdGhlbWUtY2xhc3NpYy1saWItdGhlbWUtQ29kZUJsb2NrLUNvbnRlbnQtc3R5bGVzLW1vZHVsZVwiPlxuICAgICAgICAgICAgPHByZVxuICAgICAgICAgICAgICB0YWJJbmRleD17MH1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHJpc20tY29kZSBjb2RlQmxvY2tfbm9kZV9tb2R1bGVzLUBkb2N1c2F1cnVzLXRoZW1lLWNsYXNzaWMtbGliLXRoZW1lLUNvZGVCbG9jay1Db250ZW50LXN0eWxlcy1tb2R1bGUgdGhpbi1zY3JvbGxiYXJcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8Q29kZVxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT17YCR7cHJvcHMuY2xhc3NOYW1lfSBjb2RlQmxvY2tMaW5lc19ub2RlX21vZHVsZXMtQGRvY3VzYXVydXMtdGhlbWUtY2xhc3NpYy1saWItdGhlbWUtQ29kZUJsb2NrLUNvbnRlbnQtc3R5bGVzLW1vZHVsZWB9XG4gICAgICAgICAgICAgICAgJHNzY1Byb3BzPXt0aGVtZX1cbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIHtyZW5kZXJUb2tlbnModG9rZW5zKX1cbiAgICAgICAgICAgICAgPC9Db2RlPlxuICAgICAgICAgICAgPC9wcmU+XG4gICAgICAgICAgICB7LyogPGRpdiBjbGFzc05hbWU9XCJidXR0b25Hcm91cF9ub2RlX21vZHVsZXMtQGRvY3VzYXVydXMtdGhlbWUtY2xhc3NpYy1saWItdGhlbWUtQ29kZUJsb2NrLUNvbnRlbnQtc3R5bGVzLW1vZHVsZVwiPlxuICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY2xlYW4tYnRuXCJcbiAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiVG9nZ2xlIHdvcmQgd3JhcFwiXG4gICAgICAgICAgICAgICAgdGl0bGU9XCJUb2dnbGUgd29yZCB3cmFwXCJcbiAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIndvcmRXcmFwQnV0dG9uSWNvbl9ub2RlX21vZHVsZXMtQGRvY3VzYXVydXMtdGhlbWUtY2xhc3NpYy1saWItdGhlbWUtQ29kZUJsb2NrLVdvcmRXcmFwQnV0dG9uLXN0eWxlcy1tb2R1bGVcIlxuICAgICAgICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICAgICAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgICAgICAgIGZpbGw9XCJjdXJyZW50Q29sb3JcIlxuICAgICAgICAgICAgICAgICAgICBkPVwiTTQgMTloNnYtMkg0djJ6TTIwIDVINHYyaDE2VjV6bS0zIDZINHYyaDEzLjI1YzEuMSAwIDIgLjkgMiAycy0uOSAyLTIgMkgxNXYtMmwtMyAzbDMgM3YtMmgyYzIuMjEgMCA0LTEuNzkgNC00cy0xLjc5LTQtNC00elwiXG4gICAgICAgICAgICAgICAgICA+PC9wYXRoPlxuICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgICAgIGFyaWEtbGFiZWw9XCJDb3B5IGNvZGUgdG8gY2xpcGJvYXJkXCJcbiAgICAgICAgICAgICAgICB0aXRsZT1cIkNvcHlcIlxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImNsZWFuLWJ0blwiXG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8c3BhblxuICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29weUJ1dHRvbkljb25zX25vZGVfbW9kdWxlcy1AZG9jdXNhdXJ1cy10aGVtZS1jbGFzc2ljLWxpYi10aGVtZS1Db2RlQmxvY2stQ29weUJ1dHRvbi1zdHlsZXMtbW9kdWxlXCJcbiAgICAgICAgICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgPHN2Z1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJjb3B5QnV0dG9uSWNvbl9ub2RlX21vZHVsZXMtQGRvY3VzYXVydXMtdGhlbWUtY2xhc3NpYy1saWItdGhlbWUtQ29kZUJsb2NrLUNvcHlCdXR0b24tc3R5bGVzLW1vZHVsZVwiXG4gICAgICAgICAgICAgICAgICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxuICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICA8cGF0aCBkPVwiTTE5LDIxSDhWN0gxOU0xOSw1SDhBMiwyIDAgMCwwIDYsN1YyMUEyLDIgMCAwLDAgOCwyM0gxOUEyLDIgMCAwLDAgMjEsMjFWN0EyLDIgMCAwLDAgMTksNU0xNiwxSDRBMiwyIDAgMCwwIDIsM1YxN0g0VjNIMTZWMVpcIj48L3BhdGg+XG4gICAgICAgICAgICAgICAgICA8L3N2Zz5cbiAgICAgICAgICAgICAgICAgIDxzdmdcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiY29weUJ1dHRvblN1Y2Nlc3NJY29uX25vZGVfbW9kdWxlcy1AZG9jdXNhdXJ1cy10aGVtZS1jbGFzc2ljLWxpYi10aGVtZS1Db2RlQmxvY2stQ29weUJ1dHRvbi1zdHlsZXMtbW9kdWxlXCJcbiAgICAgICAgICAgICAgICAgICAgdmlld0JveD1cIjAgMCAyNCAyNFwiXG4gICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XCJNMjEsN0w5LDE5TDMuNSwxMy41TDQuOTEsMTIuMDlMOSwxNi4xN0wxOS41OSw1LjU5TDIxLDdaXCI+PC9wYXRoPlxuICAgICAgICAgICAgICAgICAgPC9zdmc+XG4gICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PiAqL31cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8Lz5cbiAgICApXG4gIH1cblxuICByZXR1cm4gV3JhcHBlZENvbXBvbmVudFxufVxuXG5leHBvcnQgZGVmYXVsdCB3aXRoTGl2ZUVkaXRvcihDb2RlQmxvY2spXG4iXSwibmFtZXMiOlsicmFuZ2VQYXJzZXIiLCJjb2RlQmxvY2tUaXRsZVJlZ2V4IiwibWV0YXN0cmluZ0xpbmVzUmFuZ2VSZWdleCIsImNvbW1lbnRQYXR0ZXJucyIsImpzIiwic3RhcnQiLCJlbmQiLCJqc0Jsb2NrIiwianN4IiwiYmFzaCIsImh0bWwiLCJnZXRDb21tZW50UGF0dGVybiIsImxhbmd1YWdlcyIsIm1hZ2ljQ29tbWVudERpcmVjdGl2ZXMiLCJjb21tZW50UGF0dGVybiIsIm1hcCIsImxhbmciLCJmbGF0TWFwIiwiZCIsImxpbmUiLCJibG9jayIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwiUmVnRXhwIiwiZ2V0QWxsTWFnaWNDb21tZW50RGlyZWN0aXZlU3R5bGVzIiwiT2JqZWN0Iiwia2V5cyIsInBhcnNlQ29kZUJsb2NrVGl0bGUiLCJtZXRhc3RyaW5nIiwibWF0Y2giLCJncm91cHMiLCJ0aXRsZSIsImNvbnRhaW5zTGluZU51bWJlcnMiLCJpbmNsdWRlcyIsInBhcnNlTGFuZ3VhZ2UiLCJjbGFzc05hbWUiLCJsYW5ndWFnZUNsYXNzTmFtZSIsInNwbGl0IiwiZmluZCIsInN0ciIsInN0YXJ0c1dpdGgiLCJyZXBsYWNlIiwicGFyc2VMaW5lcyIsImNvbnRlbnQiLCJvcHRpb25zIiwiY29kZSIsImxhbmd1YWdlIiwibWFnaWNDb21tZW50cyIsInRlc3QiLCJsaW5lc1JhbmdlIiwicmFuZ2UiLCJsZW5ndGgiLCJFcnJvciIsIm1ldGFzdHJpbmdSYW5nZUNsYXNzTmFtZSIsImxpbmVzIiwibiIsImxpbmVDbGFzc05hbWVzIiwiZnJvbUVudHJpZXMiLCJ1bmRlZmluZWQiLCJkaXJlY3RpdmVSZWdleCIsImJsb2NrcyIsImxpbmVUb0NsYXNzTmFtZSIsImJsb2NrU3RhcnRUb0NsYXNzTmFtZSIsImJsb2NrRW5kVG9DbGFzc05hbWUiLCJsaW5lTnVtYmVyIiwiZGlyZWN0aXZlIiwic2xpY2UiLCJpdGVtIiwic3BsaWNlIiwiZW50cmllcyIsImZvckVhY2giLCJsIiwicHVzaCIsImdldFByaXNtQ3NzVmFyaWFibGVzIiwicHJpc21UaGVtZSIsIm1hcHBpbmciLCJjb2xvciIsImJhY2tncm91bmRDb2xvciIsInByb3BlcnRpZXMiLCJwbGFpbiIsImtleSIsInZhbHVlIiwidmFyTmFtZSIsIlJlYWN0IiwiY2xzeCIsIlRoZW1lQ2xhc3NOYW1lcyIsInVzZVByaXNtVGhlbWUiLCJzdHlsZXMiLCJDb2RlQmxvY2tDb250YWluZXIiLCJBcyIsImFzIiwicHJvcHMiLCJwcmlzbUNzc1ZhcmlhYmxlcyIsImNvZGVCbG9ja0NvbnRhaW5lciIsImNvbW1vbiIsImNvZGVCbG9jayIsIkNvbnRhaW5lciIsIkNvZGVCbG9ja0pTWCIsImNoaWxkcmVuIiwiY29kZUJsb2NrU3RhbmRhbG9uZSIsImNvZGVCbG9ja0xpbmVzIiwidXNlRWZmZWN0IiwidXNlRXZlbnQiLCJ1c2VTaGFsbG93TWVtb09iamVjdCIsIkRlZmF1bHRPcHRpb25zIiwiYXR0cmlidXRlcyIsImNoYXJhY3RlckRhdGEiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwidXNlTXV0YXRpb25PYnNlcnZlciIsInRhcmdldCIsImNhbGxiYWNrIiwic3RhYmxlQ2FsbGJhY2siLCJzdGFibGVPcHRpb25zIiwib2JzZXJ2ZXIiLCJNdXRhdGlvbk9ic2VydmVyIiwib2JzZXJ2ZSIsImRpc2Nvbm5lY3QiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlUmVmIiwidXNlVGFiQmVjYW1lVmlzaWJsZUNhbGxiYWNrIiwiY29kZUJsb2NrUmVmIiwiaGlkZGVuVGFiRWxlbWVudCIsInNldEhpZGRlblRhYkVsZW1lbnQiLCJ1cGRhdGVIaWRkZW5UYWJFbGVtZW50IiwiY3VycmVudCIsImNsb3Nlc3QiLCJtdXRhdGlvbnMiLCJtdXRhdGlvbiIsInR5cGUiLCJhdHRyaWJ1dGVOYW1lIiwidXNlQ29kZVdvcmRXcmFwIiwiaXNFbmFibGVkIiwic2V0SXNFbmFibGVkIiwiaXNDb2RlU2Nyb2xsYWJsZSIsInNldElzQ29kZVNjcm9sbGFibGUiLCJ0b2dnbGUiLCJjb2RlRWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzdHlsZSIsIndoaXRlU3BhY2UiLCJvdmVyZmxvd1dyYXAiLCJ1cGRhdGVDb2RlSXNTY3JvbGxhYmxlIiwic2Nyb2xsV2lkdGgiLCJjbGllbnRXaWR0aCIsImlzU2Nyb2xsYWJsZSIsImhhc0F0dHJpYnV0ZSIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkNvZGVCbG9ja0xpbmUiLCJjbGFzc05hbWVzIiwic2hvd0xpbmVOdW1iZXJzIiwiZ2V0TGluZVByb3BzIiwiZ2V0VG9rZW5Qcm9wcyIsImxpbmVQcm9wcyIsImNvZGVMaW5lIiwibGluZVRva2VucyIsInRva2VuIiwiY29kZUxpbmVOdW1iZXIiLCJjb2RlTGluZUNvbnRlbnQiLCJjb3B5VGV4dFRvQ2xpcGJvYXJkIiwiaW5wdXQiLCJkb2N1bWVudCIsImJvZHkiLCJlbGVtZW50IiwiY3JlYXRlRWxlbWVudCIsInByZXZpb3VzbHlGb2N1c2VkRWxlbWVudCIsImFjdGl2ZUVsZW1lbnQiLCJzZXRBdHRyaWJ1dGUiLCJjb250YWluIiwicG9zaXRpb24iLCJsZWZ0IiwiZm9udFNpemUiLCJzZWxlY3Rpb24iLCJnZXRTZWxlY3Rpb24iLCJvcmlnaW5hbFJhbmdlIiwicmFuZ2VDb3VudCIsImdldFJhbmdlQXQiLCJhcHBlbmQiLCJzZWxlY3QiLCJzZWxlY3Rpb25TdGFydCIsInNlbGVjdGlvbkVuZCIsImlzU3VjY2VzcyIsImV4ZWNDb21tYW5kIiwicmVtb3ZlIiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJmb2N1cyIsImNvcHkiLCJ0cmFuc2xhdGUiLCJDb3B5QnV0dG9uIiwiaXNDb3BpZWQiLCJzZXRJc0NvcGllZCIsImNvcHlUaW1lb3V0IiwiaGFuZGxlQ29weUNvZGUiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwiaWQiLCJtZXNzYWdlIiwiZGVzY3JpcHRpb24iLCJjb3B5QnV0dG9uIiwiY29weUJ1dHRvbkNvcGllZCIsImNvcHlCdXR0b25JY29ucyIsImNvcHlCdXR0b25JY29uIiwiY29weUJ1dHRvblN1Y2Nlc3NJY29uIiwiV29yZFdyYXBCdXR0b24iLCJvbkNsaWNrIiwid29yZFdyYXBCdXR0b25FbmFibGVkIiwid29yZFdyYXBCdXR0b25JY29uIiwidXNlVGhlbWVDb25maWciLCJIaWdobGlnaHQiLCJkZWZhdWx0UHJvcHMiLCJMaW5lIiwiQ29kZUJsb2NrU3RyaW5nIiwiYmxvY2tDbGFzc05hbWUiLCJ0aXRsZVByb3AiLCJzaG93TGluZU51bWJlcnNQcm9wIiwibGFuZ3VhZ2VQcm9wIiwicHJpc20iLCJkZWZhdWx0TGFuZ3VhZ2UiLCJ3b3JkV3JhcCIsImNvZGVCbG9ja1RpdGxlIiwiY29kZUJsb2NrQ29udGVudCIsInRva2VucyIsImNvZGVCbG9ja0xpbmVzV2l0aE51bWJlcmluZyIsImkiLCJidXR0b25Hcm91cCIsImNvZGVCdXR0b24iLCJpc1ZhbGlkRWxlbWVudCIsInVzZUlzQnJvd3NlciIsIkVsZW1lbnRDb250ZW50IiwiU3RyaW5nQ29udGVudCIsIm1heWJlU3RyaW5naWZ5Q2hpbGRyZW4iLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJzb21lIiwiZWwiLCJBcnJheSIsImlzQXJyYXkiLCJDb2RlQmxvY2siLCJyYXdDaGlsZHJlbiIsImlzQnJvd3NlciIsIkNvZGVCbG9ja0NvbXAiLCJTdHJpbmciLCJzdHlsZWQiLCJjc3MiLCJQcmlzbSIsIlNhbmRib3giLCJDb2RlIiwiJHNzY1Byb3BzIiwidHlwZXMiLCJyZW5kZXJUb2tlbnMiLCJ3aXRoTGl2ZUVkaXRvciIsIkNvbXBvbmVudCIsIldyYXBwZWRDb21wb25lbnQiLCJ0aGVtZSIsImxpdmUiLCJ0b2tlbml6ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9094\n')},2808:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"B\": function() { return /* binding */ actionFactory; }\n/* harmony export */ });\n/* harmony import */ var _utils_general__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8487);\n/**\n  Factory for creating ActionFactory objects.\n\n  ActionFactories are just action creators with an extra `.type` property set to\n  the string passed to `actionFactory()`.\n\n  ActionFactories can be passed directly to a ReducerBuilder's `reduce()`\n  method, thus removing the necessity of string constants.\n*/var actionFactory=function actionFactory(actionType){if( true&&typeof actionType!=='string'){throw new TypeError(\"Zedux: actionFactory() - actionType must be a string. Received \"+(0,_utils_general__WEBPACK_IMPORTED_MODULE_0__/* .detailedTypeof */ .px)(actionType));}// The factory itself just returns a normal action object with the `type` and\n// optional `payload` set.\nvar factory=function factory(payload){var action={type:factory.type};if(typeof payload!=='undefined')action.payload=payload;return action;};// Expose the action `type` for this factory. Read only! There should never be\n// any reason to modify this.\nfactory.type=actionType;return factory;};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjgwOC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQ08sR0FBTUMsY0FJbUIsQ0FBRyxRQUp0QkEsY0FJbUIsQ0FDOUJDLFVBQWdCLENBQ2IsQ0FDSCxHQUFJQyxLQUFHLEVBQUksTUFBT0QsV0FBVSxHQUFLLFFBQVEsQ0FBRSxDQUN6QyxLQUFNLElBQUlFLFVBQVMsbUVBQ2lESix3RUFBYyxDQUM5RUUsVUFBVSxDQUNYLENBQ0YsQ0FDSCxDQUVBO0FBQ0E7QUFDQSxHQUFNRyxRQUFPLENBQUksUUFBWEEsUUFBTyxDQUFLQyxPQUFpQixDQUFLLENBQ3RDLEdBQU1DLE9BQTZCLENBQUcsQ0FDcENDLElBQUksQ0FBRUgsT0FBTyxDQUFDRyxJQUNoQixDQUFDLENBRUQsR0FBSSxNQUFPRixRQUFPLEdBQUssV0FBVyxDQUFFQyxNQUFNLENBQUNELE9BQU8sQ0FBR0EsT0FBTyxDQUU1RCxNQUFPQyxPQUFNLENBQ2YsQ0FBa0MsQ0FFbEM7QUFDQTtBQUNBRixPQUFPLENBQUNHLElBQUksQ0FBR04sVUFBVSxDQUV6QixNQUFPRyxRQUFPLENBQ2hCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL2NvcmUvc3JjL2FwaS9hY3Rpb25GYWN0b3J5LnRzPzNjNDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWN0aW9uLCBBY3Rpb25GYWN0b3J5IH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBkZXRhaWxlZFR5cGVvZiB9IGZyb20gJy4uL3V0aWxzL2dlbmVyYWwnXG5cbi8qKlxuICBGYWN0b3J5IGZvciBjcmVhdGluZyBBY3Rpb25GYWN0b3J5IG9iamVjdHMuXG5cbiAgQWN0aW9uRmFjdG9yaWVzIGFyZSBqdXN0IGFjdGlvbiBjcmVhdG9ycyB3aXRoIGFuIGV4dHJhIGAudHlwZWAgcHJvcGVydHkgc2V0IHRvXG4gIHRoZSBzdHJpbmcgcGFzc2VkIHRvIGBhY3Rpb25GYWN0b3J5KClgLlxuXG4gIEFjdGlvbkZhY3RvcmllcyBjYW4gYmUgcGFzc2VkIGRpcmVjdGx5IHRvIGEgUmVkdWNlckJ1aWxkZXIncyBgcmVkdWNlKClgXG4gIG1ldGhvZCwgdGh1cyByZW1vdmluZyB0aGUgbmVjZXNzaXR5IG9mIHN0cmluZyBjb25zdGFudHMuXG4qL1xuZXhwb3J0IGNvbnN0IGFjdGlvbkZhY3Rvcnk6IDxQYXlsb2FkID0gdW5kZWZpbmVkLCBUeXBlIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihcbiAgYWN0aW9uVHlwZTogVHlwZVxuKSA9PiBQYXlsb2FkIGV4dGVuZHMgdW5kZWZpbmVkXG4gID8gQWN0aW9uRmFjdG9yeTx1bmRlZmluZWQsIFR5cGU+XG4gIDogQWN0aW9uRmFjdG9yeTxQYXlsb2FkLCBUeXBlPiA9IDxQYXlsb2FkLCBUeXBlIGV4dGVuZHMgc3RyaW5nPihcbiAgYWN0aW9uVHlwZTogVHlwZVxuKSA9PiB7XG4gIGlmIChERVYgJiYgdHlwZW9mIGFjdGlvblR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBaZWR1eDogYWN0aW9uRmFjdG9yeSgpIC0gYWN0aW9uVHlwZSBtdXN0IGJlIGEgc3RyaW5nLiBSZWNlaXZlZCAke2RldGFpbGVkVHlwZW9mKFxuICAgICAgICBhY3Rpb25UeXBlXG4gICAgICApfWBcbiAgICApXG4gIH1cblxuICAvLyBUaGUgZmFjdG9yeSBpdHNlbGYganVzdCByZXR1cm5zIGEgbm9ybWFsIGFjdGlvbiBvYmplY3Qgd2l0aCB0aGUgYHR5cGVgIGFuZFxuICAvLyBvcHRpb25hbCBgcGF5bG9hZGAgc2V0LlxuICBjb25zdCBmYWN0b3J5ID0gKChwYXlsb2FkPzogUGF5bG9hZCkgPT4ge1xuICAgIGNvbnN0IGFjdGlvbjogQWN0aW9uPFBheWxvYWQsIFR5cGU+ID0ge1xuICAgICAgdHlwZTogZmFjdG9yeS50eXBlLFxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgcGF5bG9hZCAhPT0gJ3VuZGVmaW5lZCcpIGFjdGlvbi5wYXlsb2FkID0gcGF5bG9hZFxuXG4gICAgcmV0dXJuIGFjdGlvblxuICB9KSBhcyBBY3Rpb25GYWN0b3J5PFBheWxvYWQsIFR5cGU+XG5cbiAgLy8gRXhwb3NlIHRoZSBhY3Rpb24gYHR5cGVgIGZvciB0aGlzIGZhY3RvcnkuIFJlYWQgb25seSEgVGhlcmUgc2hvdWxkIG5ldmVyIGJlXG4gIC8vIGFueSByZWFzb24gdG8gbW9kaWZ5IHRoaXMuXG4gIGZhY3RvcnkudHlwZSA9IGFjdGlvblR5cGVcblxuICByZXR1cm4gZmFjdG9yeSBhcyBhbnlcbn1cbiJdLCJuYW1lcyI6WyJkZXRhaWxlZFR5cGVvZiIsImFjdGlvbkZhY3RvcnkiLCJhY3Rpb25UeXBlIiwiREVWIiwiVHlwZUVycm9yIiwiZmFjdG9yeSIsInBheWxvYWQiLCJhY3Rpb24iLCJ0eXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2808\n")},3064:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "P": function() { return /* binding */ internalTypes; }\n/* harmony export */ });\nvar PREFIX=\'@@zedux/\';var internalTypes={delegate:PREFIX+"delegate",hydrate:PREFIX+"hydrate",// for use with atoms in the @zedux/react package:\nignore:PREFIX+"ignore",inherit:PREFIX+"inherit",merge:PREFIX+"merge",prime:PREFIX+"prime"};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA2NC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQSxHQUFNQSxPQUFNLENBQUcsVUFBVSxDQUVsQixHQUFNQyxjQUFhLENBQUcsQ0FDM0JDLFFBQVEsQ0FBS0YsTUFBTSxXQUFVLENBQzdCRyxPQUFPLENBQUtILE1BQU0sVUFBUyxDQUMzQjtBQUNBSSxNQUFNLENBQUtKLE1BQU0sU0FBUSxDQUN6QkssT0FBTyxDQUFLTCxNQUFNLFVBQVMsQ0FDM0JNLEtBQUssQ0FBS04sTUFBTSxRQUFPLENBQ3ZCTyxLQUFLLENBQUtQLE1BQU0sUUFDbEIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvY29yZS9zcmMvYXBpL2NvbnN0YW50cy50cz9kZTAyIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFBSRUZJWCA9ICdAQHplZHV4LydcblxuZXhwb3J0IGNvbnN0IGludGVybmFsVHlwZXMgPSB7XG4gIGRlbGVnYXRlOiBgJHtQUkVGSVh9ZGVsZWdhdGVgLFxuICBoeWRyYXRlOiBgJHtQUkVGSVh9aHlkcmF0ZWAsXG4gIC8vIGZvciB1c2Ugd2l0aCBhdG9tcyBpbiB0aGUgQHplZHV4L3JlYWN0IHBhY2thZ2U6XG4gIGlnbm9yZTogYCR7UFJFRklYfWlnbm9yZWAsXG4gIGluaGVyaXQ6IGAke1BSRUZJWH1pbmhlcml0YCxcbiAgbWVyZ2U6IGAke1BSRUZJWH1tZXJnZWAsXG4gIHByaW1lOiBgJHtQUkVGSVh9cHJpbWVgLFxufVxuIl0sIm5hbWVzIjpbIlBSRUZJWCIsImludGVybmFsVHlwZXMiLCJkZWxlZ2F0ZSIsImh5ZHJhdGUiLCJpZ25vcmUiLCJpbmhlcml0IiwibWVyZ2UiLCJwcmltZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3064\n')},1694:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"y\": function() { return /* binding */ Store; },\n  \"M\": function() { return /* binding */ createStore; }\n});\n\n// NAMESPACE OBJECT: ../packages/core/src/utils/hierarchyConfig.ts\nvar hierarchyConfig_namespaceObject = {};\n__webpack_require__.r(hierarchyConfig_namespaceObject);\n__webpack_require__.d(hierarchyConfig_namespaceObject, {\n  \"clone\": function() { return clone; },\n  \"create\": function() { return create; },\n  \"get\": function() { return get; },\n  \"isNode\": function() { return isNode; },\n  \"iterate\": function() { return iterate; },\n  \"set\": function() { return set; },\n  \"size\": function() { return size; }\n});\n\n// EXTERNAL MODULE: ../packages/core/src/api/constants.ts\nvar constants = __webpack_require__(3064);\n// EXTERNAL MODULE: ../packages/core/src/api/is.ts\nvar is = __webpack_require__(9283);\n// EXTERNAL MODULE: ../packages/core/src/api/meta.ts\nvar meta = __webpack_require__(7159);\n// EXTERNAL MODULE: ../packages/core/src/utils/general.ts\nvar general = __webpack_require__(8487);\n;// CONCATENATED MODULE: ../packages/core/src/hierarchy/create.ts\n/**\n  Converts a Branch hierarchy descriptor to a diff node's children\n\n  Really should only be used from `hierarchyDescriptorToDiffTree()`\n*/function branchToDiffNodeChildren(branch,registerSubStore,currentPath){var children={};Object.entries(branch).forEach(function(_ref){var key=_ref[0],val=_ref[1];var newPath=[].concat(currentPath,[key]);children[key]=hierarchyDescriptorToDiffTree(val,registerSubStore,newPath);});return children;}/**\n  Turns a non-branch node from a user-supplied hierarchy descriptor into a\n  DiffNode object\n*/function nonBranchToDiffNode(type,hierarchy,registerSubStore,currentPath){if(type===general/* HierarchyType.Null */._T.Null){return{type:type};}if(type===general/* HierarchyType.Reducer */._T.Reducer){return{type:type,reducer:hierarchy};}// It's a Store hierarchy descriptor\nreturn{type:type,destroy:registerSubStore(currentPath,hierarchy),reducer:wrapStoreInReducer(hierarchy),store:hierarchy};}/**\n  Determines the type of the given hierarchy descriptor.\n\n  Throws a TypeError if the descriptor is invalid.\n*/function getHierarchyType(descriptor){if(typeof descriptor==='function')return general/* HierarchyType.Reducer */._T.Reducer;if(descriptor&&(0,is.is)(descriptor,Store))return general/* HierarchyType.Store */._T.Store;if((0,general/* isPlainObject */.PO)(descriptor))return general/* HierarchyType.Branch */._T.Branch;if( true&&descriptor!=null){throw new TypeError(\"Zedux: store.use() - Hierarchy descriptor nodes must be reducers, stores, or plain objects. Received \"+(0,general/* detailedTypeof */.px)(descriptor));}return general/* HierarchyType.Null */._T.Null;}/**\n  Turns a normal, user-supplied hierarchy descriptor into a diff tree for easy\n  reducer hierarchy creating, diffing, merging, and destroying.\n\n  Also figures out the reducer for non-branch nodes.\n*/function hierarchyDescriptorToDiffTree(hierarchy,registerSubStore,currentPath){if(currentPath===void 0){currentPath=[];}var type=getHierarchyType(hierarchy);if(type!==general/* HierarchyType.Branch */._T.Branch){return nonBranchToDiffNode(type,hierarchy,registerSubStore,currentPath);}// It's a Branch; recursively convert the whole tree. We don't need to supply\n// a reducer for this branch 'cause the merge process does that for us\nreturn{type:type,children:branchToDiffNodeChildren(hierarchy,registerSubStore,currentPath)};}/**\n  Creates a reducer that wraps the entry points of the given store.\n\n  This reducer will propagate actions down the child store's reducers.\n\n  Wraps all actions in the special `inherit` meta node to inform the child\n  store's effects subscribers that this action was received from its parent\n  store.\n\n  Since the parent store also registers an effects subscriber on this child\n  store, it will know not to propagate the inherited action from the child\n  store. UPDATE: Actually, it doesn't even need to check - the parent store\n  knows that it _isDispatching and can ignore child store actions while it is.\n*/function wrapStoreInReducer(store){var reducer=function reducer(state,action){// If this is the special hydrate or partial hydrate action, re-create the\n// action's payload using the current state slice\nif(action.type===constants/* internalTypes.hydrate */.P.hydrate||action.type===constants/* internalTypes.merge */.P.merge){action={type:constants/* internalTypes.hydrate */.P.hydrate,payload:state};}// Tell the child store's effect subscribers that this action is inherited\nvar inheritedAction=(0,meta/* addMeta */.k)(action,constants/* internalTypes.inherit */.P.inherit);return store.dispatch(inheritedAction);};return reducer;}\n;// CONCATENATED MODULE: ../packages/core/src/hierarchy/merge.ts\n/**\n  Turns a diff tree into a single reducer.\n\n  All child diff nodes must have `reducer` props themselves.\n\n  Accepts configuration to create the state representation of this node,\n  to get and set properties on that data type, to determine if the old\n  state is a node, and to find the size of the node.\n*/var createBranchReducer=function createBranchReducer(children,_ref){var create=_ref.create,get=_ref.get,isNode=_ref.isNode,set=_ref.set,size=_ref.size;return function(oldState,action){if(oldState===void 0){oldState=create();}// Make a new node to keep track of the values returned by\n// the child reducers.\nvar newState=create();var hasChanges=false;// Iterate over the child reducers, passing them their state slice\n// and the action and recording their results.\nObject.keys(children).forEach(function(key){var _ref2=children[key],reducer=_ref2.reducer;// we've ensured reducer exists at this point\n// Grab the old state slice\nvar oldStatePiece=isNode(oldState)?get(oldState,key):undefined;// yes, explicitly set it to undefined\n// Calculate the new value\nvar newStatePiece=reducer(oldStatePiece,action);// Record the result\nnewState=set(newState,key,newStatePiece);// Check for changes\nhasChanges||(hasChanges=newStatePiece!==oldStatePiece);});// Handle the case where `children` did not used to be an empty node. This\n// means there were changes, but our change detection failed since we didn't\n// actually iterate over anything.\nhasChanges||(hasChanges=!isNode(oldState)||!Object.keys(children).length&&!!size(oldState));// If nothing changed, discard the accumulated newState\nreturn hasChanges?newState:oldState;};};/**\n  Recursively destroys a tree, preventing memory leaks.\n\n  Currently STORE is the only node type affected by this; stores need to\n  unsubscribe() from their child stores.\n*/function destroyTree(tree){if(!tree)return;var _ref3=tree,children=_ref3.children,destroy=_ref3.destroy;if(destroy)destroy();if(!children)return;// base case; this branch is now destroyed\nObject.values(children).forEach(destroyTree);}/**\n  Merges two diff tree BRANCH nodes together.\n\n  Really should only be used from `mergeDiffTrees()`\n*/function mergeBranches(oldTree,newTree,hierarchyConfig){var mergedChildren=Object.assign({},oldTree.children);// Iterate over the new tree's children\nObject.keys(newTree.children).forEach(function(key){var _children;var newChild=newTree.children[key];var oldChild=(_children=oldTree.children)==null?void 0:_children[key];// Attempt to recursively merge the two children\n// Let `mergeDiffTrees()` handle any destroying\nvar mergedChild=mergeDiffTrees(oldChild,newChild,hierarchyConfig);// If the new node is NULL, kill it.\nif(mergedChild.type===general/* HierarchyType.Null */._T.Null){delete mergedChildren[key];return;}mergedChildren[key]=mergedChild;});return{children:mergedChildren,reducer:createBranchReducer(mergedChildren,hierarchyConfig),type:general/* HierarchyType.Branch */._T.Branch};}/**\n  Merges two diff trees together.\n\n  Uses head recursion to merge the leaf nodes first. This allows this step to\n  also find each node's reducer. (A node's children reducers need to exist\n  before its own reducer can)\n\n  Destroys any no-longer-used resources in the oldTree.\n\n  The resulting tree will always have the type of the newTree.\n\n  Dynamically injects reducers and stores into the hierarchy or replaces the\n  hierarchy altogether.\n\n  There are 4 types of nodes in this hierarchy:\n    - BRANCH - indicates a branch (non-leaf) node\n    - REDUCER - indicates a leaf node handled by this store\n    - STORE - indicates a leaf node handled by another store\n    - NULL - indicates a non-existent node, or node to be deleted\n\n  BRANCH nodes will be deeply merged (recursively).\n\n  All other nodes will be overwritten.\n*/function mergeDiffTrees(oldTree,newTree,hierarchyConfig){if(newTree.type!==general/* HierarchyType.Branch */._T.Branch){destroyTree(oldTree);return newTree;}if(!oldTree||oldTree.type!==general/* HierarchyType.Branch */._T.Branch){destroyTree(oldTree);return mergeBranches({type:general/* HierarchyType.Null */._T.Null},newTree,hierarchyConfig);}// They're both BRANCH nodes; recursively merge them\nreturn mergeBranches(oldTree,newTree,hierarchyConfig);}/**\n  Deeply merges the new state tree into the old one.\n\n  If this hydration contains new state for a child store, this parent store will\n  create the child store's state for it :O\n\n  This means that mixing hierarchyConfigs is not supported, since only the\n  parent's hierarchyConfig will be respected during this merge. The child's\n  state will be full-hydrated with its new state after this merge.\n*/function mergeStateTrees(oldStateTree,newStateTree,hierarchyConfig){if(!hierarchyConfig.isNode(oldStateTree)||!hierarchyConfig.isNode(newStateTree)){return[newStateTree,newStateTree!==oldStateTree];}var hasChanges=false;var mergedTree=hierarchyConfig.clone(oldStateTree);hierarchyConfig.iterate(newStateTree,function(key,newVal){var oldVal=hierarchyConfig.get(mergedTree,key);var _ref4=hierarchyConfig.isNode(newVal)?// Recursively merge the nested nodes.\nmergeStateTrees(oldVal,newVal,hierarchyConfig):// Not a nested node (anymore, at least)\n[newVal,newVal!==oldVal],clonedVal=_ref4[0],childHasChanges=_ref4[1];if(!childHasChanges)return;if(!hasChanges)hasChanges=childHasChanges;hierarchyConfig.set(mergedTree,key,clonedVal);});return[hasChanges?mergedTree:oldStateTree,hasChanges];}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelperLoose.js + 2 modules\nvar createForOfIteratorHelperLoose = __webpack_require__(7855);\n;// CONCATENATED MODULE: ../packages/core/src/hierarchy/traverse.ts\nvar getErrorMessage= true?function(subStorePath){return\"Zedux: store.dispatch() - Invalid Delegation - Current store hierarchy does not contain a sub-store at path: \"+subStorePath.join(' -> ');}:0;/**\n  Finds a node in a diffTree given a node path (array of nodes).\n*/var findChild=function findChild(diffTree,nodePath){for(var _iterator=(0,createForOfIteratorHelperLoose/* default */.Z)(nodePath),_step;!(_step=_iterator()).done;){var node=_step.value;if(diffTree.type!==general/* HierarchyType.Branch */._T.Branch){throw new ReferenceError(getErrorMessage(nodePath));}diffTree=diffTree.children[node];if(!diffTree){throw new ReferenceError(getErrorMessage(nodePath));}}return diffTree;};/**\n  Delegates an action to a child store.\n\n  Does nothing if the special `delegate` meta node is not present in the action\n  action chain.\n\n  This expects the `metaData` of the `delegate` meta node to be an array\n  containing a path of nodes describing the child store's location in the parent\n  store's current hierarchy descriptor.\n\n  Delegated actions will not be handled by the parent store at all.\n*/var delegate=function delegate(diffTree,action){var subStorePath=(0,meta/* getMetaData */.g2)(action,constants/* internalTypes.delegate */.P.delegate);if(!subStorePath||!diffTree)return false;var child=findChild(diffTree,subStorePath);if(child.type!==general/* HierarchyType.Store */._T.Store){throw new TypeError(getErrorMessage(subStorePath));};child.store.dispatch((0,meta/* removeMeta */.hM)(action,constants/* internalTypes.delegate */.P.delegate));};/**\n  Propagates a state change from a child store to a parent.\n\n  Recursively finds the child store's node in the parent store's\n  state tree and re-creates all the nodes down that path.\n\n  #immutability\n*/var propagateChange=function propagateChange(currentState,subStorePath,newSubStoreState,hierarchyConfig){if(!subStorePath.length)return newSubStoreState;// at this point we can assume that currentState is a hierarhical structure\n// these \"currentState as any\" casts should be fine\nvar newNode=hierarchyConfig.clone(currentState);var nextNodeKey=subStorePath[0];return hierarchyConfig.set(newNode,nextNodeKey,propagateChange(hierarchyConfig.get(currentState,nextNodeKey),subStorePath.slice(1),newSubStoreState,hierarchyConfig));};\n;// CONCATENATED MODULE: ../packages/core/src/utils/hierarchyConfig.ts\n/**\n  The default method for cloning state tree nodes\n\n  This does not have to create a deep copy.\n  In fact, it probably shouldn't.\n*/var clone=function clone(node){return Object.assign({},node);};/**\n  The default method for creating state tree nodes\n\n  Should return an empty node.\n*/var create=function create(){return{};};/**\n  The default method for retrieving the value of a property on\n  the state tree.\n*/var get=function get(node,key){return node[key];};/**\n  The default method for determining if something is a state tree node\n*/var isNode=general/* isPlainObject */.PO;/**\n  The default method for iterating over the properties of a state tree\n  node.\n\n  Should call `callback` with each key-value pair.\n*/var iterate=function iterate(node,callback){Object.entries(node).forEach(function(_ref){var key=_ref[0],val=_ref[1];return callback(key,val);});};/**\n  The default method for setting the value of a property on the\n  state tree.\n\n  This can be mutating.\n  Zedux promises to never abuse this power.\n*/var set=function set(node,key,val){node[key]=val;return node;};/**\n  The default method for finding the size of a state tree node.\n*/var size=function size(node){return Object.keys(node).length;};\n;// CONCATENATED MODULE: ../packages/core/src/api/createStore.ts\nvar _Symbol$observable;// When an action is dispatched to a parent store and delegated to a child\n// store, the child store needs to wait until the update propagates everywhere\n// and the parent store finishes its dispatch before notifying its subscribers.\n// A proper scheduler will allow all child stores of the currently-dispatching\n// parent store to wait to notify their subscribers until all stores in the\n// hierarchy are done dispatching.\nvar defaultScheduler={scheduleNow:function scheduleNow(job){return job.task();}};var primeAction={type:constants/* internalTypes.prime */.P.prime};/**\n  Creates a new Zedux store.\n*/var createStore=function createStore(initialHierarchy,initialState){return new Store(initialHierarchy,initialState);};_Symbol$observable=Symbol.observable;var Store=/*#__PURE__*/function(){/**\n    Used by the store's branch reducers in the generated reducer hierarchy to\n    interact with the hierarchical data type returned by the store's reducers.\n\n    This \"hierarchical data type\" is a plain object by default. But these\n    hierarchy config options can teach Zedux how to use an Immutable `Map` or\n    any recursive, map-like data structure.\n  */function Store(initialHierarchy,initialState){var _this=this;this._subscribers=[];this.dispatch=function(action){_this._scheduler.scheduleNow({task:function task(){return _this._dispatch(action);},type:0// UpdateStore (0)\n});return _this._currentState;};this.setState=function(settable,meta){_this._scheduler.scheduleNow({task:function task(){return _this._setState(settable,meta);},type:0// UpdateStore (0)\n});return _this._currentState;};this._currentState=initialState;this._scheduler=Store._scheduler||defaultScheduler;if(initialHierarchy)this.use(initialHierarchy);}var _proto=Store.prototype;_proto.actionStream=function actionStream(){var _this2=this,_ref2;return _ref2={},_ref2[Symbol.observable]=function(){return this;},_ref2['@@observable']=function observable(){return this;},_ref2.subscribe=function subscribe(subscriber){return _this2.subscribe({effects:function effects(_ref){var action=_ref.action,error=_ref.error;if(error&&typeof subscriber!=='function'){subscriber.error==null?void 0:subscriber.error(error);}else if(action){typeof subscriber==='function'?subscriber(action):subscriber.next==null?void 0:subscriber.next(action);}}});},_ref2;}/**\n    Dispatches an action to the store.\n\n    The action will be sent through this store's reducer hierarchy (if any) and\n    passed on to any child stores after being wrapped in `inherit` meta nodes\n\n    The resulting state will be returned synchronously from this call.\n\n    This is a bound function property. Every store recreates this small\n    function. But it's always bound and can be passed around easily.\n  */;/**\n    Returns the current state of the store.\n\n    Do not mutate the returned value.\n  */_proto.getState=function getState(){if( true&&this._isDispatching){throw new Error('Zedux: store.getState() cannot be called in a reducer');}return this._currentState;}/**\n    Applies a full hydration to the store.\n\n    Accepts either the new state or a function that accepts the current state\n    and returns the new state.\n\n    Dispatches the special `hydrate` action to the store's reducers. Effects\n    subscribers can inspect and record this action to implement time travel.\n\n    The `hydrate` action's `payload` property will be set to the new state. The\n    action's `meta` property will be set to the passed meta, if any.\n\n    Throws an error if called from the reducer layer.\n\n    Returns the new state.\n\n    Unlike setStateDeep, setState is a bound function property. Every store\n    recreates this small function. But it's always bound and can be passed\n    around easily.\n  */;/**\n    Applies a partial state update to the store.\n\n    Accepts either a deep partial state object or a function that accepts the\n    current state and returns a deep partial state object.\n\n    Dispatches the special `merge` action to the store's reducers.\n    Effects subscribers can inspect and record this action to implement time\n    travel.\n\n    The `merge` action's `payload` property will be set to the partial\n    state update.\n\n    Note that deep setting cannot remove properties from the state tree. If that\n    functionality is needed, use store.setState() or create a new reducer\n    hierarchy and pass it to store.use().\n\n    Throws an error if called from the reducer layer.\n\n    Returns the new state.\n\n    Unlike setState, setStateDeep is not bound. You must call it with context -\n    e.g. by using dot-notation: `store.setStateDeep(...)`\n  */_proto.setStateDeep=function setStateDeep(settable,meta){var _this3=this;this._scheduler.scheduleNow({task:function task(){return _this3._setState(settable,meta,true);},type:0// UpdateStore (0)\n});return this._currentState;}/**\n    Registers a subscriber with the store.\n\n    The subscriber will be notified every time the store's state\n    changes.\n\n    Returns a subscription object. Calling `subscription.unsubscribe()`\n    unregisters the subscriber.\n  */;_proto.subscribe=function subscribe(subscriber){var _this4=this;var subscriberObj=typeof subscriber==='function'?{next:subscriber}:subscriber;if(true){if(subscriberObj.next&&typeof subscriberObj.next!=='function'){throw new TypeError(\"Zedux: store.subscribe() expects either a function or an object with a \\\"next\\\" property whose value is a function. Received: \"+(0,general/* detailedTypeof */.px)(subscriberObj.next));}if(subscriberObj.error&&typeof subscriberObj.error!=='function'){throw new TypeError(\"Zedux: store.subscribe() - subscriber.error must be a function. Received: \"+(0,general/* detailedTypeof */.px)(subscriberObj.error));}if(subscriberObj.effects&&typeof subscriberObj.effects!=='function'){throw new TypeError(\"Zedux: store.subscribe() - subscriber.effects must be a function. Received: \"+(0,general/* detailedTypeof */.px)(subscriberObj.effects));}}this._subscribers.push(subscriberObj);return{unsubscribe:function unsubscribe(){var index=_this4._subscribers.indexOf(subscriberObj);if(index>-1)_this4._subscribers.splice(index,1);}};}/**\n    Merges a hierarchy descriptor into the existing hierarchy descriptor.\n\n    Intelligently diffs the two hierarchies and only creates/recreates the\n    necessary reducers.\n\n    Dispatches the special `prime` action to the store.\n  */;_proto.use=function use(newHierarchy){var newDiffTree=hierarchyDescriptorToDiffTree(newHierarchy,this._registerChildStore.bind(this));this._currentDiffTree=mergeDiffTrees(this._currentDiffTree,newDiffTree,this.constructor.hierarchyConfig);this._rootReducer=this._currentDiffTree.reducer;if(this._rootReducer){this._dispatchAction(primeAction,primeAction,this._currentState);}return this;// for chaining\n}/**\n   * Only for internal use.\n   */;_proto._register=function _register(effects){var parents=this._parents||(this._parents=[]);parents.push(effects);return function(){var index=parents.indexOf(effects);if(index>-1)parents.splice(index,1);};};_proto[_Symbol$observable]=function(){return this;};_proto['@@observable']=function observable(){return this;};_proto._dispatch=function _dispatch(action){if( true&&typeof action==='function'){throw new TypeError('Zedux: store.dispatch() - Thunks are not currently supported. Only normal action objects can be passed to store.dispatch(). For zero-config stores, you can pass a function to store.setState()');}if( true&&!(0,general/* isPlainObject */.PO)(action)){throw new TypeError(\"Zedux: store.dispatch() - Action must be a plain object. Received \"+(0,general/* detailedTypeof */.px)(action));}var delegateResult=delegate(this._currentDiffTree,action);if(delegateResult!==false){// No need to inform subscribers - this store's effects subscriber\n// on the child store will have already done that by this point\nreturn this._currentState;}return this._routeAction(action);};_proto._dispatchAction=function _dispatchAction(action,unwrappedAction,rootState){if( true&&this._isDispatching){throw new Error('Zedux: dispatch(), setState(), and setStateDeep() cannot be called in a reducer');}this._isDispatching=true;var error;var newState=rootState;try{if(this._rootReducer){newState=this._rootReducer(rootState,unwrappedAction);}}catch(err){error=err;throw err;}finally{this._isDispatching=false;this._informSubscribers(newState,action,error);}return newState;}/**\n    \"Hydrates\" the store with the given state.\n\n    Dispatches the special `hydrate` action to the store's inspectors\n    and reducers. The `hydrate` action's `payload` property will be\n    set to the new store state, allowing inspectors to pick up on\n    the changes and implement time travel and whatnot.\n\n    Throws an Error if called from the reducer layer.\n  */;_proto._dispatchHydration=function _dispatchHydration(state,actionType,meta){var newState=actionType===constants/* internalTypes.hydrate */.P.hydrate?state:mergeStateTrees(this._currentState,state,this.constructor.hierarchyConfig)[0];if(newState===this._currentState){// Nothing to do. TODO: Should this inform effects subscribers?\nreturn this._currentState;}var action={payload:newState,type:actionType};if(meta!=null)action.meta=meta;// Maybe we can provide a utility for setting a description for the\n// hydration. Then wrap the action in an ActionMeta with that description\n// as the metaData.\n// Propagate the change to child stores and allow for effects.\nreturn this._dispatchAction(action,action,newState);};_proto._dispatchStateSetter=function _dispatchStateSetter(getState,meta,deep){var newState;try{newState=getState(this._currentState);}catch(error){this._informSubscribers(this._currentState,{type:constants/* internalTypes.merge */.P.merge},error);throw error;}return this._dispatchHydration(newState,deep?constants/* internalTypes.merge */.P.merge:constants/* internalTypes.hydrate */.P.hydrate,meta);};_proto._finishInforming=function _finishInforming(effect){// Clone the subscribers in case of mutation mid-iteration\nvar subscribers=[].concat(this._subscribers);for(var i=0;i<subscribers.length;i++){var subscriber=subscribers[i];if(effect.error&&subscriber.error)subscriber.error(effect.error);if(effect.newState!==effect.oldState&&subscriber.next){subscriber.next(effect.newState,effect.oldState,effect.action);}if(subscriber.effects)subscriber.effects(effect);}};_proto._informSubscribers=function _informSubscribers(newState,action,error){var _this5=this,_this$_parents;var effect={action:action,error:error,newState:newState,oldState:this._currentState,store:this};// Update the stored state\nthis._currentState=newState;// defer informing if a parent store is currently dispatching\nthis._scheduler.scheduleNow({task:function task(){// skip informing subscribers if the state has already been changed\n// by a parent store's subscriber (which state change is already\n// propagated to this store's subscribers by this point):\nif(_this5._currentState!==newState)return;_this5._finishInforming(effect);},type:1// InformSubscribers (1)\n},false);(_this$_parents=this._parents)==null?void 0:_this$_parents.forEach(function(parent){return parent(effect);});};_proto._registerChildStore=function _registerChildStore(childStorePath,childStore){var _this6=this;var effectsSubscriber=function effectsSubscriber(_ref3){var action=_ref3.action,error=_ref3.error,newState=_ref3.newState,oldState=_ref3.oldState;// If this store's reducer layer dispatched this action to this\n// substore in the first place, ignore the propagation; this store\n// will receive it anyway.\n// const isInherited = hasMeta(action, internalTypes.inherit)\nif(_this6._isDispatching)return;var newOwnState=newState===oldState?_this6._currentState:propagateChange(_this6._currentState,childStorePath,newState,_this6.constructor.hierarchyConfig);// Tell the subscribers what child store this action came from.\n// This store (the parent) can use this info to determine how to\n// recreate this state update.\nvar wrappedAction=action&&(0,meta/* addMeta */.k)(action,constants/* internalTypes.delegate */.P.delegate,childStorePath);_this6._informSubscribers(newOwnState,wrappedAction,error);};return childStore._register(effectsSubscriber);};_proto._routeAction=function _routeAction(action){var unwrappedAction=(0,meta/* removeAllMeta */.vU)(action);if( true&&typeof unwrappedAction.type!=='string'){throw new TypeError(\"Zedux: store.dispatch() - Action must have a string \\\"type\\\" property. Received \"+(0,general/* detailedTypeof */.px)(unwrappedAction.type));}if(unwrappedAction.type===constants/* internalTypes.hydrate */.P.hydrate||unwrappedAction.type===constants/* internalTypes.merge */.P.merge){return this._dispatchHydration(unwrappedAction.payload,unwrappedAction.type,unwrappedAction.meta);}return this._dispatchAction(action,unwrappedAction,this._currentState);};_proto._setState=function _setState(settable,meta,deep){if(deep===void 0){deep=false;}if(typeof settable==='function'){return this._dispatchStateSetter(settable,meta,deep);}return this._dispatchHydration(settable,deep?constants/* internalTypes.merge */.P.merge:constants/* internalTypes.hydrate */.P.hydrate,meta);};return Store;}();Store.hierarchyConfig=hierarchyConfig_namespaceObject;Store.$$typeof=general/* STORE_IDENTIFIER */.IE;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFBSSxHQUFLcEIsMENBQW1CLENBQzVDLENBQ0EsTUFBTyxLQUFJLENBQUN3SixrQkFBa0IsQ0FDNUJKLGVBQWUsQ0FBQy9HLE9BQU8sQ0FDdkIrRyxlQUFlLENBQUNoSSxJQUFJLENBQ3BCZ0ksZUFBZSxDQUFDaEMsSUFBSSxDQUNyQixDQUNILENBRUEsTUFBTyxLQUFJLENBQUMwQixlQUFlLENBQUM1RyxNQUFNLENBQUVrSCxlQUFlLENBQUUsSUFBSSxDQUFDbkMsYUFBYSxDQUFDLENBQzFFLENBQUMsUUFFT0ksU0FBUyxDQUFqQixtQkFDRUYsUUFBa0QsQ0FDbERDLElBQVUsQ0FDVnVDLElBQUksQ0FDSixJQURBQSxJQUFJLFdBQUpBLElBQUksQ0FBRyxLQUFLLEVBRVosR0FBSSxNQUFPeEMsU0FBUSxHQUFLLFVBQVUsQ0FBRSxDQUNsQyxNQUFPLEtBQUksQ0FBQ3VDLG9CQUFvQixDQUFDdkMsUUFBUSxDQUFxQkMsSUFBSSxDQUFFdUMsSUFBSSxDQUFDLENBQzNFLENBRUEsTUFBTyxLQUFJLENBQUNILGtCQUFrQixDQUM1QnJDLFFBQVEsQ0FDUndDLElBQUksQ0FBRzNKLDBDQUFtQixDQUFHQSw4Q0FBcUIsQ0FDbERvSCxJQUFJLENBQ0wsQ0FDSCxDQUFDLGtCQTdoQlVuSCxLQUFLLENBU0E0RCxlQUFlLENBQW9Cb0MsK0JBQXNCLENBVDlEaEcsS0FBSyxDQVVBcUssUUFBUSxDQUFHdEUsZ0NBQWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9jb3JlL3NyYy9oaWVyYXJjaHkvY3JlYXRlLnRzP2E3NTciLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9jb3JlL3NyYy9oaWVyYXJjaHkvbWVyZ2UudHM/Y2Y0NiIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL2NvcmUvc3JjL2hpZXJhcmNoeS90cmF2ZXJzZS50cz84NWI2Iiwid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvY29yZS9zcmMvdXRpbHMvaGllcmFyY2h5Q29uZmlnLnRzP2E0M2QiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9jb3JlL3NyYy9hcGkvY3JlYXRlU3RvcmUudHM/Y2FhNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbnRlcm5hbFR5cGVzIH0gZnJvbSAnLi4vYXBpL2NvbnN0YW50cydcbmltcG9ydCB7IFN0b3JlIH0gZnJvbSAnLi4vYXBpL2NyZWF0ZVN0b3JlJ1xuaW1wb3J0IHsgaXMgfSBmcm9tICcuLi9hcGkvaXMnXG5pbXBvcnQgeyBhZGRNZXRhIH0gZnJvbSAnLi4vYXBpL21ldGEnXG5pbXBvcnQgeyBBY3Rpb24sIEJyYW5jaCwgSGllcmFyY2h5RGVzY3JpcHRvciwgUmVkdWNlciB9IGZyb20gJy4uL3R5cGVzJ1xuaW1wb3J0IHsgZGV0YWlsZWRUeXBlb2YsIEhpZXJhcmNoeVR5cGUsIGlzUGxhaW5PYmplY3QgfSBmcm9tICcuLi91dGlscy9nZW5lcmFsJ1xuaW1wb3J0IHsgRGlmZk5vZGUsIERpZmZUcmVlLCBSZWdpc3RlclN1YlN0b3JlIH0gZnJvbSAnLi4vdXRpbHMvdHlwZXMnXG5cbi8qKlxuICBDb252ZXJ0cyBhIEJyYW5jaCBoaWVyYXJjaHkgZGVzY3JpcHRvciB0byBhIGRpZmYgbm9kZSdzIGNoaWxkcmVuXG5cbiAgUmVhbGx5IHNob3VsZCBvbmx5IGJlIHVzZWQgZnJvbSBgaGllcmFyY2h5RGVzY3JpcHRvclRvRGlmZlRyZWUoKWBcbiovXG5mdW5jdGlvbiBicmFuY2hUb0RpZmZOb2RlQ2hpbGRyZW4oXG4gIGJyYW5jaDogQnJhbmNoLFxuICByZWdpc3RlclN1YlN0b3JlOiBSZWdpc3RlclN1YlN0b3JlLFxuICBjdXJyZW50UGF0aDogc3RyaW5nW11cbikge1xuICBjb25zdCBjaGlsZHJlbjogRGlmZlRyZWUgPSB7fVxuXG4gIE9iamVjdC5lbnRyaWVzKGJyYW5jaCkuZm9yRWFjaCgoW2tleSwgdmFsXSkgPT4ge1xuICAgIGNvbnN0IG5ld1BhdGggPSBbLi4uY3VycmVudFBhdGgsIGtleV1cblxuICAgIGNoaWxkcmVuW2tleV0gPSBoaWVyYXJjaHlEZXNjcmlwdG9yVG9EaWZmVHJlZShcbiAgICAgIHZhbCxcbiAgICAgIHJlZ2lzdGVyU3ViU3RvcmUsXG4gICAgICBuZXdQYXRoXG4gICAgKVxuICB9KVxuXG4gIHJldHVybiBjaGlsZHJlblxufVxuXG4vKipcbiAgVHVybnMgYSBub24tYnJhbmNoIG5vZGUgZnJvbSBhIHVzZXItc3VwcGxpZWQgaGllcmFyY2h5IGRlc2NyaXB0b3IgaW50byBhXG4gIERpZmZOb2RlIG9iamVjdFxuKi9cbmZ1bmN0aW9uIG5vbkJyYW5jaFRvRGlmZk5vZGUoXG4gIHR5cGU6IEhpZXJhcmNoeVR5cGUsXG4gIGhpZXJhcmNoeTogUmVkdWNlciB8IFN0b3JlLFxuICByZWdpc3RlclN1YlN0b3JlOiBSZWdpc3RlclN1YlN0b3JlLFxuICBjdXJyZW50UGF0aDogc3RyaW5nW11cbik6IERpZmZOb2RlIHtcbiAgaWYgKHR5cGUgPT09IEhpZXJhcmNoeVR5cGUuTnVsbCkge1xuICAgIHJldHVybiB7IHR5cGUgfVxuICB9XG5cbiAgaWYgKHR5cGUgPT09IEhpZXJhcmNoeVR5cGUuUmVkdWNlcikge1xuICAgIHJldHVybiB7IHR5cGUsIHJlZHVjZXI6IGhpZXJhcmNoeSBhcyBSZWR1Y2VyIH1cbiAgfVxuXG4gIC8vIEl0J3MgYSBTdG9yZSBoaWVyYXJjaHkgZGVzY3JpcHRvclxuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUgYXMgSGllcmFyY2h5VHlwZS5TdG9yZSxcbiAgICBkZXN0cm95OiByZWdpc3RlclN1YlN0b3JlKGN1cnJlbnRQYXRoLCBoaWVyYXJjaHkgYXMgU3RvcmUpLFxuICAgIHJlZHVjZXI6IHdyYXBTdG9yZUluUmVkdWNlcihoaWVyYXJjaHkgYXMgU3RvcmUpLFxuICAgIHN0b3JlOiBoaWVyYXJjaHkgYXMgU3RvcmUsXG4gIH1cbn1cblxuLyoqXG4gIERldGVybWluZXMgdGhlIHR5cGUgb2YgdGhlIGdpdmVuIGhpZXJhcmNoeSBkZXNjcmlwdG9yLlxuXG4gIFRocm93cyBhIFR5cGVFcnJvciBpZiB0aGUgZGVzY3JpcHRvciBpcyBpbnZhbGlkLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRIaWVyYXJjaHlUeXBlKGRlc2NyaXB0b3I6IEhpZXJhcmNoeURlc2NyaXB0b3IpIHtcbiAgaWYgKHR5cGVvZiBkZXNjcmlwdG9yID09PSAnZnVuY3Rpb24nKSByZXR1cm4gSGllcmFyY2h5VHlwZS5SZWR1Y2VyXG5cbiAgaWYgKGRlc2NyaXB0b3IgJiYgaXMoZGVzY3JpcHRvciwgU3RvcmUpKSByZXR1cm4gSGllcmFyY2h5VHlwZS5TdG9yZVxuXG4gIGlmIChpc1BsYWluT2JqZWN0KGRlc2NyaXB0b3IpKSByZXR1cm4gSGllcmFyY2h5VHlwZS5CcmFuY2hcblxuICBpZiAoREVWICYmIGRlc2NyaXB0b3IgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBgWmVkdXg6IHN0b3JlLnVzZSgpIC0gSGllcmFyY2h5IGRlc2NyaXB0b3Igbm9kZXMgbXVzdCBiZSByZWR1Y2Vycywgc3RvcmVzLCBvciBwbGFpbiBvYmplY3RzLiBSZWNlaXZlZCAke2RldGFpbGVkVHlwZW9mKFxuICAgICAgICBkZXNjcmlwdG9yXG4gICAgICApfWBcbiAgICApXG4gIH1cblxuICByZXR1cm4gSGllcmFyY2h5VHlwZS5OdWxsXG59XG5cbi8qKlxuICBUdXJucyBhIG5vcm1hbCwgdXNlci1zdXBwbGllZCBoaWVyYXJjaHkgZGVzY3JpcHRvciBpbnRvIGEgZGlmZiB0cmVlIGZvciBlYXN5XG4gIHJlZHVjZXIgaGllcmFyY2h5IGNyZWF0aW5nLCBkaWZmaW5nLCBtZXJnaW5nLCBhbmQgZGVzdHJveWluZy5cblxuICBBbHNvIGZpZ3VyZXMgb3V0IHRoZSByZWR1Y2VyIGZvciBub24tYnJhbmNoIG5vZGVzLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBoaWVyYXJjaHlEZXNjcmlwdG9yVG9EaWZmVHJlZShcbiAgaGllcmFyY2h5OiBIaWVyYXJjaHlEZXNjcmlwdG9yLFxuICByZWdpc3RlclN1YlN0b3JlOiBSZWdpc3RlclN1YlN0b3JlLFxuICBjdXJyZW50UGF0aDogc3RyaW5nW10gPSBbXVxuKTogRGlmZk5vZGUge1xuICBjb25zdCB0eXBlID0gZ2V0SGllcmFyY2h5VHlwZShoaWVyYXJjaHkpXG5cbiAgaWYgKHR5cGUgIT09IEhpZXJhcmNoeVR5cGUuQnJhbmNoKSB7XG4gICAgcmV0dXJuIG5vbkJyYW5jaFRvRGlmZk5vZGUoXG4gICAgICB0eXBlLFxuICAgICAgaGllcmFyY2h5IGFzIFJlZHVjZXIgfCBTdG9yZSxcbiAgICAgIHJlZ2lzdGVyU3ViU3RvcmUsXG4gICAgICBjdXJyZW50UGF0aFxuICAgIClcbiAgfVxuXG4gIC8vIEl0J3MgYSBCcmFuY2g7IHJlY3Vyc2l2ZWx5IGNvbnZlcnQgdGhlIHdob2xlIHRyZWUuIFdlIGRvbid0IG5lZWQgdG8gc3VwcGx5XG4gIC8vIGEgcmVkdWNlciBmb3IgdGhpcyBicmFuY2ggJ2NhdXNlIHRoZSBtZXJnZSBwcm9jZXNzIGRvZXMgdGhhdCBmb3IgdXNcbiAgcmV0dXJuIHtcbiAgICB0eXBlLFxuICAgIGNoaWxkcmVuOiBicmFuY2hUb0RpZmZOb2RlQ2hpbGRyZW4oXG4gICAgICBoaWVyYXJjaHkgYXMgQnJhbmNoLFxuICAgICAgcmVnaXN0ZXJTdWJTdG9yZSxcbiAgICAgIGN1cnJlbnRQYXRoXG4gICAgKSxcbiAgfVxufVxuXG4vKipcbiAgQ3JlYXRlcyBhIHJlZHVjZXIgdGhhdCB3cmFwcyB0aGUgZW50cnkgcG9pbnRzIG9mIHRoZSBnaXZlbiBzdG9yZS5cblxuICBUaGlzIHJlZHVjZXIgd2lsbCBwcm9wYWdhdGUgYWN0aW9ucyBkb3duIHRoZSBjaGlsZCBzdG9yZSdzIHJlZHVjZXJzLlxuXG4gIFdyYXBzIGFsbCBhY3Rpb25zIGluIHRoZSBzcGVjaWFsIGBpbmhlcml0YCBtZXRhIG5vZGUgdG8gaW5mb3JtIHRoZSBjaGlsZFxuICBzdG9yZSdzIGVmZmVjdHMgc3Vic2NyaWJlcnMgdGhhdCB0aGlzIGFjdGlvbiB3YXMgcmVjZWl2ZWQgZnJvbSBpdHMgcGFyZW50XG4gIHN0b3JlLlxuXG4gIFNpbmNlIHRoZSBwYXJlbnQgc3RvcmUgYWxzbyByZWdpc3RlcnMgYW4gZWZmZWN0cyBzdWJzY3JpYmVyIG9uIHRoaXMgY2hpbGRcbiAgc3RvcmUsIGl0IHdpbGwga25vdyBub3QgdG8gcHJvcGFnYXRlIHRoZSBpbmhlcml0ZWQgYWN0aW9uIGZyb20gdGhlIGNoaWxkXG4gIHN0b3JlLiBVUERBVEU6IEFjdHVhbGx5LCBpdCBkb2Vzbid0IGV2ZW4gbmVlZCB0byBjaGVjayAtIHRoZSBwYXJlbnQgc3RvcmVcbiAga25vd3MgdGhhdCBpdCBfaXNEaXNwYXRjaGluZyBhbmQgY2FuIGlnbm9yZSBjaGlsZCBzdG9yZSBhY3Rpb25zIHdoaWxlIGl0IGlzLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiB3cmFwU3RvcmVJblJlZHVjZXI8U3RhdGU+KHN0b3JlOiBTdG9yZTxTdGF0ZT4pIHtcbiAgY29uc3QgcmVkdWNlcjogUmVkdWNlciA9IChzdGF0ZTogU3RhdGUsIGFjdGlvbjogQWN0aW9uKSA9PiB7XG4gICAgLy8gSWYgdGhpcyBpcyB0aGUgc3BlY2lhbCBoeWRyYXRlIG9yIHBhcnRpYWwgaHlkcmF0ZSBhY3Rpb24sIHJlLWNyZWF0ZSB0aGVcbiAgICAvLyBhY3Rpb24ncyBwYXlsb2FkIHVzaW5nIHRoZSBjdXJyZW50IHN0YXRlIHNsaWNlXG4gICAgaWYgKFxuICAgICAgYWN0aW9uLnR5cGUgPT09IGludGVybmFsVHlwZXMuaHlkcmF0ZSB8fFxuICAgICAgYWN0aW9uLnR5cGUgPT09IGludGVybmFsVHlwZXMubWVyZ2VcbiAgICApIHtcbiAgICAgIGFjdGlvbiA9IHtcbiAgICAgICAgdHlwZTogaW50ZXJuYWxUeXBlcy5oeWRyYXRlLFxuICAgICAgICBwYXlsb2FkOiBzdGF0ZSxcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUZWxsIHRoZSBjaGlsZCBzdG9yZSdzIGVmZmVjdCBzdWJzY3JpYmVycyB0aGF0IHRoaXMgYWN0aW9uIGlzIGluaGVyaXRlZFxuICAgIGNvbnN0IGluaGVyaXRlZEFjdGlvbiA9IGFkZE1ldGEoYWN0aW9uLCBpbnRlcm5hbFR5cGVzLmluaGVyaXQpXG5cbiAgICByZXR1cm4gc3RvcmUuZGlzcGF0Y2goaW5oZXJpdGVkQWN0aW9uKVxuICB9XG5cbiAgcmV0dXJuIHJlZHVjZXJcbn1cbiIsImltcG9ydCB7IEFjdGlvbiwgSGllcmFyY2h5Q29uZmlnLCBSZWR1Y2VyIH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBIaWVyYXJjaHlUeXBlIH0gZnJvbSAnLi4vdXRpbHMvZ2VuZXJhbCdcbmltcG9ydCB7IEJyYW5jaE5vZGUsIERpZmZOb2RlLCBEaWZmVHJlZSB9IGZyb20gJy4uL3V0aWxzL3R5cGVzJ1xuXG4vKipcbiAgVHVybnMgYSBkaWZmIHRyZWUgaW50byBhIHNpbmdsZSByZWR1Y2VyLlxuXG4gIEFsbCBjaGlsZCBkaWZmIG5vZGVzIG11c3QgaGF2ZSBgcmVkdWNlcmAgcHJvcHMgdGhlbXNlbHZlcy5cblxuICBBY2NlcHRzIGNvbmZpZ3VyYXRpb24gdG8gY3JlYXRlIHRoZSBzdGF0ZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUsXG4gIHRvIGdldCBhbmQgc2V0IHByb3BlcnRpZXMgb24gdGhhdCBkYXRhIHR5cGUsIHRvIGRldGVybWluZSBpZiB0aGUgb2xkXG4gIHN0YXRlIGlzIGEgbm9kZSwgYW5kIHRvIGZpbmQgdGhlIHNpemUgb2YgdGhlIG5vZGUuXG4qL1xuY29uc3QgY3JlYXRlQnJhbmNoUmVkdWNlciA9IChcbiAgY2hpbGRyZW46IERpZmZUcmVlLFxuICB7IGNyZWF0ZSwgZ2V0LCBpc05vZGUsIHNldCwgc2l6ZSB9OiBIaWVyYXJjaHlDb25maWdcbik6IFJlZHVjZXIgPT4gKG9sZFN0YXRlID0gY3JlYXRlKCksIGFjdGlvbjogQWN0aW9uKSA9PiB7XG4gIC8vIE1ha2UgYSBuZXcgbm9kZSB0byBrZWVwIHRyYWNrIG9mIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnlcbiAgLy8gdGhlIGNoaWxkIHJlZHVjZXJzLlxuICBsZXQgbmV3U3RhdGUgPSBjcmVhdGUoKVxuICBsZXQgaGFzQ2hhbmdlcyA9IGZhbHNlXG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBjaGlsZCByZWR1Y2VycywgcGFzc2luZyB0aGVtIHRoZWlyIHN0YXRlIHNsaWNlXG4gIC8vIGFuZCB0aGUgYWN0aW9uIGFuZCByZWNvcmRpbmcgdGhlaXIgcmVzdWx0cy5cbiAgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCB7IHJlZHVjZXIgfSA9IGNoaWxkcmVuW2tleV0gYXMgeyByZWR1Y2VyOiBSZWR1Y2VyIH0gLy8gd2UndmUgZW5zdXJlZCByZWR1Y2VyIGV4aXN0cyBhdCB0aGlzIHBvaW50XG5cbiAgICAvLyBHcmFiIHRoZSBvbGQgc3RhdGUgc2xpY2VcbiAgICBjb25zdCBvbGRTdGF0ZVBpZWNlID0gaXNOb2RlKG9sZFN0YXRlKSA/IGdldChvbGRTdGF0ZSwga2V5KSA6IHVuZGVmaW5lZCAvLyB5ZXMsIGV4cGxpY2l0bHkgc2V0IGl0IHRvIHVuZGVmaW5lZFxuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBuZXcgdmFsdWVcbiAgICBjb25zdCBuZXdTdGF0ZVBpZWNlID0gcmVkdWNlcihvbGRTdGF0ZVBpZWNlLCBhY3Rpb24pXG5cbiAgICAvLyBSZWNvcmQgdGhlIHJlc3VsdFxuICAgIG5ld1N0YXRlID0gc2V0KG5ld1N0YXRlLCBrZXksIG5ld1N0YXRlUGllY2UpXG5cbiAgICAvLyBDaGVjayBmb3IgY2hhbmdlc1xuICAgIGhhc0NoYW5nZXMgfHwgKGhhc0NoYW5nZXMgPSBuZXdTdGF0ZVBpZWNlICE9PSBvbGRTdGF0ZVBpZWNlKVxuICB9KVxuXG4gIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBgY2hpbGRyZW5gIGRpZCBub3QgdXNlZCB0byBiZSBhbiBlbXB0eSBub2RlLiBUaGlzXG4gIC8vIG1lYW5zIHRoZXJlIHdlcmUgY2hhbmdlcywgYnV0IG91ciBjaGFuZ2UgZGV0ZWN0aW9uIGZhaWxlZCBzaW5jZSB3ZSBkaWRuJ3RcbiAgLy8gYWN0dWFsbHkgaXRlcmF0ZSBvdmVyIGFueXRoaW5nLlxuICBoYXNDaGFuZ2VzIHx8XG4gICAgKGhhc0NoYW5nZXMgPVxuICAgICAgIWlzTm9kZShvbGRTdGF0ZSkgfHwgKCFPYmplY3Qua2V5cyhjaGlsZHJlbikubGVuZ3RoICYmICEhc2l6ZShvbGRTdGF0ZSkpKVxuXG4gIC8vIElmIG5vdGhpbmcgY2hhbmdlZCwgZGlzY2FyZCB0aGUgYWNjdW11bGF0ZWQgbmV3U3RhdGVcbiAgcmV0dXJuIGhhc0NoYW5nZXMgPyBuZXdTdGF0ZSA6IG9sZFN0YXRlXG59XG5cbi8qKlxuICBSZWN1cnNpdmVseSBkZXN0cm95cyBhIHRyZWUsIHByZXZlbnRpbmcgbWVtb3J5IGxlYWtzLlxuXG4gIEN1cnJlbnRseSBTVE9SRSBpcyB0aGUgb25seSBub2RlIHR5cGUgYWZmZWN0ZWQgYnkgdGhpczsgc3RvcmVzIG5lZWQgdG9cbiAgdW5zdWJzY3JpYmUoKSBmcm9tIHRoZWlyIGNoaWxkIHN0b3Jlcy5cbiovXG5leHBvcnQgZnVuY3Rpb24gZGVzdHJveVRyZWUodHJlZT86IERpZmZOb2RlKSB7XG4gIGlmICghdHJlZSkgcmV0dXJuXG5cbiAgY29uc3QgeyBjaGlsZHJlbiwgZGVzdHJveSB9ID0gdHJlZSBhcyBCcmFuY2hOb2RlXG5cbiAgaWYgKGRlc3Ryb3kpIGRlc3Ryb3koKVxuXG4gIGlmICghY2hpbGRyZW4pIHJldHVybiAvLyBiYXNlIGNhc2U7IHRoaXMgYnJhbmNoIGlzIG5vdyBkZXN0cm95ZWRcblxuICBPYmplY3QudmFsdWVzKGNoaWxkcmVuKS5mb3JFYWNoKGRlc3Ryb3lUcmVlKVxufVxuXG4vKipcbiAgTWVyZ2VzIHR3byBkaWZmIHRyZWUgQlJBTkNIIG5vZGVzIHRvZ2V0aGVyLlxuXG4gIFJlYWxseSBzaG91bGQgb25seSBiZSB1c2VkIGZyb20gYG1lcmdlRGlmZlRyZWVzKClgXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQnJhbmNoZXMoXG4gIG9sZFRyZWU6IERpZmZOb2RlLFxuICBuZXdUcmVlOiBCcmFuY2hOb2RlLFxuICBoaWVyYXJjaHlDb25maWc6IEhpZXJhcmNoeUNvbmZpZ1xuKTogQnJhbmNoTm9kZSB7XG4gIGNvbnN0IG1lcmdlZENoaWxkcmVuID0geyAuLi4ob2xkVHJlZSBhcyBCcmFuY2hOb2RlKS5jaGlsZHJlbiB9XG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBuZXcgdHJlZSdzIGNoaWxkcmVuXG4gIE9iamVjdC5rZXlzKG5ld1RyZWUuY2hpbGRyZW4pLmZvckVhY2goa2V5ID0+IHtcbiAgICBjb25zdCBuZXdDaGlsZCA9IG5ld1RyZWUuY2hpbGRyZW5ba2V5XVxuICAgIGNvbnN0IG9sZENoaWxkID0gKG9sZFRyZWUgYXMgQnJhbmNoTm9kZSkuY2hpbGRyZW4/LltrZXldXG5cbiAgICAvLyBBdHRlbXB0IHRvIHJlY3Vyc2l2ZWx5IG1lcmdlIHRoZSB0d28gY2hpbGRyZW5cbiAgICAvLyBMZXQgYG1lcmdlRGlmZlRyZWVzKClgIGhhbmRsZSBhbnkgZGVzdHJveWluZ1xuICAgIGNvbnN0IG1lcmdlZENoaWxkID0gbWVyZ2VEaWZmVHJlZXMob2xkQ2hpbGQsIG5ld0NoaWxkLCBoaWVyYXJjaHlDb25maWcpXG5cbiAgICAvLyBJZiB0aGUgbmV3IG5vZGUgaXMgTlVMTCwga2lsbCBpdC5cbiAgICBpZiAobWVyZ2VkQ2hpbGQudHlwZSA9PT0gSGllcmFyY2h5VHlwZS5OdWxsKSB7XG4gICAgICBkZWxldGUgbWVyZ2VkQ2hpbGRyZW5ba2V5XVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBtZXJnZWRDaGlsZHJlbltrZXldID0gbWVyZ2VkQ2hpbGRcbiAgfSlcblxuICByZXR1cm4ge1xuICAgIGNoaWxkcmVuOiBtZXJnZWRDaGlsZHJlbixcbiAgICByZWR1Y2VyOiBjcmVhdGVCcmFuY2hSZWR1Y2VyKG1lcmdlZENoaWxkcmVuLCBoaWVyYXJjaHlDb25maWcpLFxuICAgIHR5cGU6IEhpZXJhcmNoeVR5cGUuQnJhbmNoLFxuICB9XG59XG5cbi8qKlxuICBNZXJnZXMgdHdvIGRpZmYgdHJlZXMgdG9nZXRoZXIuXG5cbiAgVXNlcyBoZWFkIHJlY3Vyc2lvbiB0byBtZXJnZSB0aGUgbGVhZiBub2RlcyBmaXJzdC4gVGhpcyBhbGxvd3MgdGhpcyBzdGVwIHRvXG4gIGFsc28gZmluZCBlYWNoIG5vZGUncyByZWR1Y2VyLiAoQSBub2RlJ3MgY2hpbGRyZW4gcmVkdWNlcnMgbmVlZCB0byBleGlzdFxuICBiZWZvcmUgaXRzIG93biByZWR1Y2VyIGNhbilcblxuICBEZXN0cm95cyBhbnkgbm8tbG9uZ2VyLXVzZWQgcmVzb3VyY2VzIGluIHRoZSBvbGRUcmVlLlxuXG4gIFRoZSByZXN1bHRpbmcgdHJlZSB3aWxsIGFsd2F5cyBoYXZlIHRoZSB0eXBlIG9mIHRoZSBuZXdUcmVlLlxuXG4gIER5bmFtaWNhbGx5IGluamVjdHMgcmVkdWNlcnMgYW5kIHN0b3JlcyBpbnRvIHRoZSBoaWVyYXJjaHkgb3IgcmVwbGFjZXMgdGhlXG4gIGhpZXJhcmNoeSBhbHRvZ2V0aGVyLlxuXG4gIFRoZXJlIGFyZSA0IHR5cGVzIG9mIG5vZGVzIGluIHRoaXMgaGllcmFyY2h5OlxuICAgIC0gQlJBTkNIIC0gaW5kaWNhdGVzIGEgYnJhbmNoIChub24tbGVhZikgbm9kZVxuICAgIC0gUkVEVUNFUiAtIGluZGljYXRlcyBhIGxlYWYgbm9kZSBoYW5kbGVkIGJ5IHRoaXMgc3RvcmVcbiAgICAtIFNUT1JFIC0gaW5kaWNhdGVzIGEgbGVhZiBub2RlIGhhbmRsZWQgYnkgYW5vdGhlciBzdG9yZVxuICAgIC0gTlVMTCAtIGluZGljYXRlcyBhIG5vbi1leGlzdGVudCBub2RlLCBvciBub2RlIHRvIGJlIGRlbGV0ZWRcblxuICBCUkFOQ0ggbm9kZXMgd2lsbCBiZSBkZWVwbHkgbWVyZ2VkIChyZWN1cnNpdmVseSkuXG5cbiAgQWxsIG90aGVyIG5vZGVzIHdpbGwgYmUgb3ZlcndyaXR0ZW4uXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGlmZlRyZWVzKFxuICBvbGRUcmVlOiBEaWZmTm9kZSB8IHVuZGVmaW5lZCxcbiAgbmV3VHJlZTogRGlmZk5vZGUsXG4gIGhpZXJhcmNoeUNvbmZpZzogSGllcmFyY2h5Q29uZmlnXG4pIHtcbiAgaWYgKG5ld1RyZWUudHlwZSAhPT0gSGllcmFyY2h5VHlwZS5CcmFuY2gpIHtcbiAgICBkZXN0cm95VHJlZShvbGRUcmVlKVxuXG4gICAgcmV0dXJuIG5ld1RyZWVcbiAgfVxuXG4gIGlmICghb2xkVHJlZSB8fCBvbGRUcmVlLnR5cGUgIT09IEhpZXJhcmNoeVR5cGUuQnJhbmNoKSB7XG4gICAgZGVzdHJveVRyZWUob2xkVHJlZSlcblxuICAgIHJldHVybiBtZXJnZUJyYW5jaGVzKHsgdHlwZTogSGllcmFyY2h5VHlwZS5OdWxsIH0sIG5ld1RyZWUsIGhpZXJhcmNoeUNvbmZpZylcbiAgfVxuXG4gIC8vIFRoZXkncmUgYm90aCBCUkFOQ0ggbm9kZXM7IHJlY3Vyc2l2ZWx5IG1lcmdlIHRoZW1cbiAgcmV0dXJuIG1lcmdlQnJhbmNoZXMob2xkVHJlZSwgbmV3VHJlZSwgaGllcmFyY2h5Q29uZmlnKVxufVxuXG4vKipcbiAgRGVlcGx5IG1lcmdlcyB0aGUgbmV3IHN0YXRlIHRyZWUgaW50byB0aGUgb2xkIG9uZS5cblxuICBJZiB0aGlzIGh5ZHJhdGlvbiBjb250YWlucyBuZXcgc3RhdGUgZm9yIGEgY2hpbGQgc3RvcmUsIHRoaXMgcGFyZW50IHN0b3JlIHdpbGxcbiAgY3JlYXRlIHRoZSBjaGlsZCBzdG9yZSdzIHN0YXRlIGZvciBpdCA6T1xuXG4gIFRoaXMgbWVhbnMgdGhhdCBtaXhpbmcgaGllcmFyY2h5Q29uZmlncyBpcyBub3Qgc3VwcG9ydGVkLCBzaW5jZSBvbmx5IHRoZVxuICBwYXJlbnQncyBoaWVyYXJjaHlDb25maWcgd2lsbCBiZSByZXNwZWN0ZWQgZHVyaW5nIHRoaXMgbWVyZ2UuIFRoZSBjaGlsZCdzXG4gIHN0YXRlIHdpbGwgYmUgZnVsbC1oeWRyYXRlZCB3aXRoIGl0cyBuZXcgc3RhdGUgYWZ0ZXIgdGhpcyBtZXJnZS5cbiovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VTdGF0ZVRyZWVzKFxuICBvbGRTdGF0ZVRyZWU6IGFueSxcbiAgbmV3U3RhdGVUcmVlOiBhbnksXG4gIGhpZXJhcmNoeUNvbmZpZzogSGllcmFyY2h5Q29uZmlnXG4pIHtcbiAgaWYgKFxuICAgICFoaWVyYXJjaHlDb25maWcuaXNOb2RlKG9sZFN0YXRlVHJlZSkgfHxcbiAgICAhaGllcmFyY2h5Q29uZmlnLmlzTm9kZShuZXdTdGF0ZVRyZWUpXG4gICkge1xuICAgIHJldHVybiBbbmV3U3RhdGVUcmVlLCBuZXdTdGF0ZVRyZWUgIT09IG9sZFN0YXRlVHJlZV0gYXMgY29uc3RcbiAgfVxuXG4gIGxldCBoYXNDaGFuZ2VzID0gZmFsc2VcbiAgY29uc3QgbWVyZ2VkVHJlZSA9IGhpZXJhcmNoeUNvbmZpZy5jbG9uZShvbGRTdGF0ZVRyZWUpXG5cbiAgaGllcmFyY2h5Q29uZmlnLml0ZXJhdGUobmV3U3RhdGVUcmVlLCAoa2V5LCBuZXdWYWwpID0+IHtcbiAgICBjb25zdCBvbGRWYWwgPSBoaWVyYXJjaHlDb25maWcuZ2V0KG1lcmdlZFRyZWUsIGtleSlcbiAgICBjb25zdCBbY2xvbmVkVmFsLCBjaGlsZEhhc0NoYW5nZXNdID0gaGllcmFyY2h5Q29uZmlnLmlzTm9kZShuZXdWYWwpXG4gICAgICA/IC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIHRoZSBuZXN0ZWQgbm9kZXMuXG4gICAgICAgIG1lcmdlU3RhdGVUcmVlcyhvbGRWYWwsIG5ld1ZhbCwgaGllcmFyY2h5Q29uZmlnKVxuICAgICAgOiAvLyBOb3QgYSBuZXN0ZWQgbm9kZSAoYW55bW9yZSwgYXQgbGVhc3QpXG4gICAgICAgIFtuZXdWYWwsIG5ld1ZhbCAhPT0gb2xkVmFsXVxuXG4gICAgaWYgKCFjaGlsZEhhc0NoYW5nZXMpIHJldHVyblxuXG4gICAgaWYgKCFoYXNDaGFuZ2VzKSBoYXNDaGFuZ2VzID0gY2hpbGRIYXNDaGFuZ2VzXG4gICAgaGllcmFyY2h5Q29uZmlnLnNldChtZXJnZWRUcmVlLCBrZXksIGNsb25lZFZhbClcbiAgfSlcblxuICByZXR1cm4gW2hhc0NoYW5nZXMgPyBtZXJnZWRUcmVlIDogb2xkU3RhdGVUcmVlLCBoYXNDaGFuZ2VzXSBhcyBjb25zdFxufVxuIiwiaW1wb3J0IHsgaW50ZXJuYWxUeXBlcyB9IGZyb20gJy4uL2FwaS9jb25zdGFudHMnXG5pbXBvcnQgeyBBY3Rpb25DaGFpbiwgSGllcmFyY2h5Q29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBIaWVyYXJjaHlUeXBlIH0gZnJvbSAnLi4vdXRpbHMvZ2VuZXJhbCdcbmltcG9ydCB7IGdldE1ldGFEYXRhLCByZW1vdmVNZXRhIH0gZnJvbSAnLi4vYXBpL21ldGEnXG5pbXBvcnQgeyBEaWZmTm9kZSwgU3RvcmVOb2RlIH0gZnJvbSAnLi4vdXRpbHMvdHlwZXMnXG5cbmV4cG9ydCBjb25zdCBnZXRFcnJvck1lc3NhZ2UgPSBERVZcbiAgPyAoc3ViU3RvcmVQYXRoOiBzdHJpbmdbXSkgPT5cbiAgICAgIGBaZWR1eDogc3RvcmUuZGlzcGF0Y2goKSAtIEludmFsaWQgRGVsZWdhdGlvbiAtIEN1cnJlbnQgc3RvcmUgaGllcmFyY2h5IGRvZXMgbm90IGNvbnRhaW4gYSBzdWItc3RvcmUgYXQgcGF0aDogJHtzdWJTdG9yZVBhdGguam9pbihcbiAgICAgICAgJyAtPiAnXG4gICAgICApfWBcbiAgOiAoKSA9PiAnJ1xuXG4vKipcbiAgRmluZHMgYSBub2RlIGluIGEgZGlmZlRyZWUgZ2l2ZW4gYSBub2RlIHBhdGggKGFycmF5IG9mIG5vZGVzKS5cbiovXG5jb25zdCBmaW5kQ2hpbGQgPSAoZGlmZlRyZWU6IERpZmZOb2RlLCBub2RlUGF0aDogc3RyaW5nW10pID0+IHtcbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVQYXRoKSB7XG4gICAgaWYgKGRpZmZUcmVlLnR5cGUgIT09IEhpZXJhcmNoeVR5cGUuQnJhbmNoKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoZ2V0RXJyb3JNZXNzYWdlKG5vZGVQYXRoKSlcbiAgICB9XG5cbiAgICBkaWZmVHJlZSA9IGRpZmZUcmVlLmNoaWxkcmVuW25vZGVdXG5cbiAgICBpZiAoIWRpZmZUcmVlKSB7XG4gICAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoZ2V0RXJyb3JNZXNzYWdlKG5vZGVQYXRoKSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlmZlRyZWVcbn1cblxuLyoqXG4gIERlbGVnYXRlcyBhbiBhY3Rpb24gdG8gYSBjaGlsZCBzdG9yZS5cblxuICBEb2VzIG5vdGhpbmcgaWYgdGhlIHNwZWNpYWwgYGRlbGVnYXRlYCBtZXRhIG5vZGUgaXMgbm90IHByZXNlbnQgaW4gdGhlIGFjdGlvblxuICBhY3Rpb24gY2hhaW4uXG5cbiAgVGhpcyBleHBlY3RzIHRoZSBgbWV0YURhdGFgIG9mIHRoZSBgZGVsZWdhdGVgIG1ldGEgbm9kZSB0byBiZSBhbiBhcnJheVxuICBjb250YWluaW5nIGEgcGF0aCBvZiBub2RlcyBkZXNjcmliaW5nIHRoZSBjaGlsZCBzdG9yZSdzIGxvY2F0aW9uIGluIHRoZSBwYXJlbnRcbiAgc3RvcmUncyBjdXJyZW50IGhpZXJhcmNoeSBkZXNjcmlwdG9yLlxuXG4gIERlbGVnYXRlZCBhY3Rpb25zIHdpbGwgbm90IGJlIGhhbmRsZWQgYnkgdGhlIHBhcmVudCBzdG9yZSBhdCBhbGwuXG4qL1xuZXhwb3J0IGNvbnN0IGRlbGVnYXRlID0gKFxuICBkaWZmVHJlZTogRGlmZk5vZGUgfCB1bmRlZmluZWQsXG4gIGFjdGlvbjogQWN0aW9uQ2hhaW5cbikgPT4ge1xuICBjb25zdCBzdWJTdG9yZVBhdGggPSBnZXRNZXRhRGF0YShhY3Rpb24sIGludGVybmFsVHlwZXMuZGVsZWdhdGUpXG5cbiAgaWYgKCFzdWJTdG9yZVBhdGggfHwgIWRpZmZUcmVlKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCBjaGlsZCA9IGZpbmRDaGlsZChkaWZmVHJlZSwgc3ViU3RvcmVQYXRoKVxuXG4gIGlmIChjaGlsZC50eXBlICE9PSBIaWVyYXJjaHlUeXBlLlN0b3JlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihnZXRFcnJvck1lc3NhZ2Uoc3ViU3RvcmVQYXRoKSlcbiAgfVxuXG4gIDsoY2hpbGQgYXMgU3RvcmVOb2RlKS5zdG9yZS5kaXNwYXRjaChcbiAgICByZW1vdmVNZXRhKGFjdGlvbiwgaW50ZXJuYWxUeXBlcy5kZWxlZ2F0ZSlcbiAgKVxufVxuXG4vKipcbiAgUHJvcGFnYXRlcyBhIHN0YXRlIGNoYW5nZSBmcm9tIGEgY2hpbGQgc3RvcmUgdG8gYSBwYXJlbnQuXG5cbiAgUmVjdXJzaXZlbHkgZmluZHMgdGhlIGNoaWxkIHN0b3JlJ3Mgbm9kZSBpbiB0aGUgcGFyZW50IHN0b3JlJ3NcbiAgc3RhdGUgdHJlZSBhbmQgcmUtY3JlYXRlcyBhbGwgdGhlIG5vZGVzIGRvd24gdGhhdCBwYXRoLlxuXG4gICNpbW11dGFiaWxpdHlcbiovXG5leHBvcnQgY29uc3QgcHJvcGFnYXRlQ2hhbmdlID0gPFN0YXRlID0gYW55PihcbiAgY3VycmVudFN0YXRlOiBTdGF0ZSxcbiAgc3ViU3RvcmVQYXRoOiBzdHJpbmdbXSxcbiAgbmV3U3ViU3RvcmVTdGF0ZTogYW55LFxuICBoaWVyYXJjaHlDb25maWc6IEhpZXJhcmNoeUNvbmZpZ1xuKTogU3RhdGUgPT4ge1xuICBpZiAoIXN1YlN0b3JlUGF0aC5sZW5ndGgpIHJldHVybiBuZXdTdWJTdG9yZVN0YXRlXG5cbiAgLy8gYXQgdGhpcyBwb2ludCB3ZSBjYW4gYXNzdW1lIHRoYXQgY3VycmVudFN0YXRlIGlzIGEgaGllcmFyaGljYWwgc3RydWN0dXJlXG4gIC8vIHRoZXNlIFwiY3VycmVudFN0YXRlIGFzIGFueVwiIGNhc3RzIHNob3VsZCBiZSBmaW5lXG4gIGNvbnN0IG5ld05vZGUgPSBoaWVyYXJjaHlDb25maWcuY2xvbmUoY3VycmVudFN0YXRlIGFzIGFueSlcbiAgY29uc3QgbmV4dE5vZGVLZXkgPSBzdWJTdG9yZVBhdGhbMF1cblxuICByZXR1cm4gaGllcmFyY2h5Q29uZmlnLnNldChcbiAgICBuZXdOb2RlLFxuICAgIG5leHROb2RlS2V5LFxuICAgIHByb3BhZ2F0ZUNoYW5nZShcbiAgICAgIGhpZXJhcmNoeUNvbmZpZy5nZXQoY3VycmVudFN0YXRlIGFzIGFueSwgbmV4dE5vZGVLZXkpLFxuICAgICAgc3ViU3RvcmVQYXRoLnNsaWNlKDEpLFxuICAgICAgbmV3U3ViU3RvcmVTdGF0ZSxcbiAgICAgIGhpZXJhcmNoeUNvbmZpZ1xuICAgIClcbiAgKSBhcyBhbnlcbn1cbiIsImltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICcuL2dlbmVyYWwnXG5cbmludGVyZmFjZSBUIHtcbiAgW2tleTogc3RyaW5nXTogYW55XG59XG5cbi8qKlxuICBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGNsb25pbmcgc3RhdGUgdHJlZSBub2Rlc1xuXG4gIFRoaXMgZG9lcyBub3QgaGF2ZSB0byBjcmVhdGUgYSBkZWVwIGNvcHkuXG4gIEluIGZhY3QsIGl0IHByb2JhYmx5IHNob3VsZG4ndC5cbiovXG5leHBvcnQgY29uc3QgY2xvbmUgPSAobm9kZTogVCkgPT4gKHsgLi4ubm9kZSB9KVxuXG4vKipcbiAgVGhlIGRlZmF1bHQgbWV0aG9kIGZvciBjcmVhdGluZyBzdGF0ZSB0cmVlIG5vZGVzXG5cbiAgU2hvdWxkIHJldHVybiBhbiBlbXB0eSBub2RlLlxuKi9cbmV4cG9ydCBjb25zdCBjcmVhdGUgPSAoKSA9PiAoe30pXG5cbi8qKlxuICBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIHJldHJpZXZpbmcgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgb25cbiAgdGhlIHN0YXRlIHRyZWUuXG4qL1xuZXhwb3J0IGNvbnN0IGdldCA9IChub2RlOiBULCBrZXk6IHN0cmluZykgPT4gbm9kZVtrZXldXG5cbi8qKlxuICBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGRldGVybWluaW5nIGlmIHNvbWV0aGluZyBpcyBhIHN0YXRlIHRyZWUgbm9kZVxuKi9cbmV4cG9ydCBjb25zdCBpc05vZGUgPSBpc1BsYWluT2JqZWN0XG5cbi8qKlxuICBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIGl0ZXJhdGluZyBvdmVyIHRoZSBwcm9wZXJ0aWVzIG9mIGEgc3RhdGUgdHJlZVxuICBub2RlLlxuXG4gIFNob3VsZCBjYWxsIGBjYWxsYmFja2Agd2l0aCBlYWNoIGtleS12YWx1ZSBwYWlyLlxuKi9cbmV4cG9ydCBjb25zdCBpdGVyYXRlID0gKFxuICBub2RlOiBULFxuICBjYWxsYmFjazogKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSA9PiBhbnlcbikgPT4ge1xuICBPYmplY3QuZW50cmllcyhub2RlKS5mb3JFYWNoKChba2V5LCB2YWxdKSA9PiBjYWxsYmFjayhrZXksIHZhbCkpXG59XG5cbi8qKlxuICBUaGUgZGVmYXVsdCBtZXRob2QgZm9yIHNldHRpbmcgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgb24gdGhlXG4gIHN0YXRlIHRyZWUuXG5cbiAgVGhpcyBjYW4gYmUgbXV0YXRpbmcuXG4gIFplZHV4IHByb21pc2VzIHRvIG5ldmVyIGFidXNlIHRoaXMgcG93ZXIuXG4qL1xuZXhwb3J0IGNvbnN0IHNldCA9IChub2RlOiBULCBrZXk6IHN0cmluZywgdmFsOiBhbnkpID0+IHtcbiAgbm9kZVtrZXldID0gdmFsXG5cbiAgcmV0dXJuIG5vZGVcbn1cblxuLyoqXG4gIFRoZSBkZWZhdWx0IG1ldGhvZCBmb3IgZmluZGluZyB0aGUgc2l6ZSBvZiBhIHN0YXRlIHRyZWUgbm9kZS5cbiovXG5leHBvcnQgY29uc3Qgc2l6ZSA9IChub2RlOiBUKSA9PiBPYmplY3Qua2V5cyhub2RlKS5sZW5ndGhcbiIsImltcG9ydCB7IGhpZXJhcmNoeURlc2NyaXB0b3JUb0RpZmZUcmVlIH0gZnJvbSAnLi4vaGllcmFyY2h5L2NyZWF0ZSdcbmltcG9ydCB7IG1lcmdlRGlmZlRyZWVzLCBtZXJnZVN0YXRlVHJlZXMgfSBmcm9tICcuLi9oaWVyYXJjaHkvbWVyZ2UnXG5pbXBvcnQgeyBkZWxlZ2F0ZSwgcHJvcGFnYXRlQ2hhbmdlIH0gZnJvbSAnLi4vaGllcmFyY2h5L3RyYXZlcnNlJ1xuaW1wb3J0IHtcbiAgQWN0aW9uLFxuICBBY3Rpb25DaGFpbixcbiAgRGlzcGF0Y2hhYmxlLFxuICBTdG9yZUVmZmVjdCxcbiAgRWZmZWN0c1N1YnNjcmliZXIsXG4gIEhpZXJhcmNoeUNvbmZpZyxcbiAgSGllcmFyY2h5RGVzY3JpcHRvcixcbiAgU2V0U3RhdGUsXG4gIFJlY3Vyc2l2ZVBhcnRpYWwsXG4gIFJlZHVjZXIsXG4gIFNldHRhYmxlLFxuICBTdWJzY3JpYmVyLFxuICBTdWJzY3JpYmVyT2JqZWN0LFxuICBTY2hlZHVsZXIsXG4gIEpvYixcbn0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQge1xuICBkZXRhaWxlZFR5cGVvZixcbiAgaXNQbGFpbk9iamVjdCxcbiAgU1RPUkVfSURFTlRJRklFUixcbn0gZnJvbSAnLi4vdXRpbHMvZ2VuZXJhbCdcbmltcG9ydCAqIGFzIGRlZmF1bHRIaWVyYXJjaHlDb25maWcgZnJvbSAnLi4vdXRpbHMvaGllcmFyY2h5Q29uZmlnJ1xuaW1wb3J0IHsgRGlmZk5vZGUgfSBmcm9tICcuLi91dGlscy90eXBlcydcbmltcG9ydCB7IGludGVybmFsVHlwZXMgfSBmcm9tICcuL2NvbnN0YW50cydcbmltcG9ydCB7IGFkZE1ldGEsIHJlbW92ZUFsbE1ldGEgfSBmcm9tICcuL21ldGEnXG5cbi8vIFdoZW4gYW4gYWN0aW9uIGlzIGRpc3BhdGNoZWQgdG8gYSBwYXJlbnQgc3RvcmUgYW5kIGRlbGVnYXRlZCB0byBhIGNoaWxkXG4vLyBzdG9yZSwgdGhlIGNoaWxkIHN0b3JlIG5lZWRzIHRvIHdhaXQgdW50aWwgdGhlIHVwZGF0ZSBwcm9wYWdhdGVzIGV2ZXJ5d2hlcmVcbi8vIGFuZCB0aGUgcGFyZW50IHN0b3JlIGZpbmlzaGVzIGl0cyBkaXNwYXRjaCBiZWZvcmUgbm90aWZ5aW5nIGl0cyBzdWJzY3JpYmVycy5cbi8vIEEgcHJvcGVyIHNjaGVkdWxlciB3aWxsIGFsbG93IGFsbCBjaGlsZCBzdG9yZXMgb2YgdGhlIGN1cnJlbnRseS1kaXNwYXRjaGluZ1xuLy8gcGFyZW50IHN0b3JlIHRvIHdhaXQgdG8gbm90aWZ5IHRoZWlyIHN1YnNjcmliZXJzIHVudGlsIGFsbCBzdG9yZXMgaW4gdGhlXG4vLyBoaWVyYXJjaHkgYXJlIGRvbmUgZGlzcGF0Y2hpbmcuXG5jb25zdCBkZWZhdWx0U2NoZWR1bGVyOiBTY2hlZHVsZXIgPSB7XG4gIHNjaGVkdWxlTm93OiAoam9iOiBKb2IpID0+IGpvYi50YXNrKCksXG59XG5cbmNvbnN0IHByaW1lQWN0aW9uID0geyB0eXBlOiBpbnRlcm5hbFR5cGVzLnByaW1lIH1cblxuLyoqXG4gIENyZWF0ZXMgYSBuZXcgWmVkdXggc3RvcmUuXG4qL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVN0b3JlOiB7XG4gIDxTdGF0ZSA9IGFueT4oXG4gICAgaW5pdGlhbEhpZXJhcmNoeT86IEhpZXJhcmNoeURlc2NyaXB0b3I8U3RhdGU+LFxuICAgIGluaXRpYWxTdGF0ZT86IFN0YXRlXG4gICk6IFN0b3JlPFN0YXRlPlxuXG4gIDxTdGF0ZSA9IGFueT4oXG4gICAgaW5pdGlhbEhpZXJhcmNoeTogbnVsbCB8IHVuZGVmaW5lZCxcbiAgICBpbml0aWFsU3RhdGU6IFN0YXRlXG4gICk6IFN0b3JlPFN0YXRlPlxufSA9IDxTdGF0ZSA9IGFueT4oXG4gIGluaXRpYWxIaWVyYXJjaHk/OiBIaWVyYXJjaHlEZXNjcmlwdG9yPFN0YXRlPixcbiAgaW5pdGlhbFN0YXRlPzogU3RhdGVcbikgPT4ge1xuICByZXR1cm4gbmV3IFN0b3JlPFN0YXRlPihpbml0aWFsSGllcmFyY2h5LCBpbml0aWFsU3RhdGUpXG59XG5cbmV4cG9ydCBjbGFzcyBTdG9yZTxTdGF0ZSA9IGFueT4ge1xuICAvKipcbiAgICBVc2VkIGJ5IHRoZSBzdG9yZSdzIGJyYW5jaCByZWR1Y2VycyBpbiB0aGUgZ2VuZXJhdGVkIHJlZHVjZXIgaGllcmFyY2h5IHRvXG4gICAgaW50ZXJhY3Qgd2l0aCB0aGUgaGllcmFyY2hpY2FsIGRhdGEgdHlwZSByZXR1cm5lZCBieSB0aGUgc3RvcmUncyByZWR1Y2Vycy5cblxuICAgIFRoaXMgXCJoaWVyYXJjaGljYWwgZGF0YSB0eXBlXCIgaXMgYSBwbGFpbiBvYmplY3QgYnkgZGVmYXVsdC4gQnV0IHRoZXNlXG4gICAgaGllcmFyY2h5IGNvbmZpZyBvcHRpb25zIGNhbiB0ZWFjaCBaZWR1eCBob3cgdG8gdXNlIGFuIEltbXV0YWJsZSBgTWFwYCBvclxuICAgIGFueSByZWN1cnNpdmUsIG1hcC1saWtlIGRhdGEgc3RydWN0dXJlLlxuICAqL1xuICBzdGF0aWMgcmVhZG9ubHkgaGllcmFyY2h5Q29uZmlnOiBIaWVyYXJjaHlDb25maWcgPSBkZWZhdWx0SGllcmFyY2h5Q29uZmlnXG4gIHN0YXRpYyByZWFkb25seSAkJHR5cGVvZiA9IFNUT1JFX0lERU5USUZJRVJcblxuICAvKipcbiAgICogVGhpcyBpcyBzZXQgYnkgYXRvbSBlY29zeXN0ZW1zIHRvIGF1dG9tYXRpY2FsbGx5IHRpZSBzdG9yZXMgY3JlYXRlZCBkdXJpbmdcbiAgICogYXRvbSBldmFsdWF0aW9uIHRvIHRoZSBlY29zeXN0ZW0uXG4gICAqL1xuICBzdGF0aWMgX3NjaGVkdWxlcj86IFNjaGVkdWxlclxuICBwcml2YXRlIF9jdXJyZW50RGlmZlRyZWU/OiBEaWZmTm9kZVxuICBwcml2YXRlIF9jdXJyZW50U3RhdGU6IFN0YXRlXG4gIHByaXZhdGUgX2lzRGlzcGF0Y2hpbmc/OiBib29sZWFuXG4gIHByaXZhdGUgX3BhcmVudHM/OiBFZmZlY3RzU3Vic2NyaWJlcltdXG4gIHByaXZhdGUgX3Jvb3RSZWR1Y2VyPzogUmVkdWNlcjxTdGF0ZT5cbiAgcHJpdmF0ZSBfc2NoZWR1bGVyOiBTY2hlZHVsZXJcbiAgcHJpdmF0ZSBfc3Vic2NyaWJlcnM6IFN1YnNjcmliZXJPYmplY3RbXSA9IFtdXG5cbiAgY29uc3RydWN0b3IoXG4gICAgaW5pdGlhbEhpZXJhcmNoeT86IEhpZXJhcmNoeURlc2NyaXB0b3I8U3RhdGU+LFxuICAgIGluaXRpYWxTdGF0ZT86IFN0YXRlXG4gICkge1xuICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IGluaXRpYWxTdGF0ZSBhcyBTdGF0ZVxuICAgIHRoaXMuX3NjaGVkdWxlciA9IFN0b3JlLl9zY2hlZHVsZXIgfHwgZGVmYXVsdFNjaGVkdWxlclxuXG4gICAgaWYgKGluaXRpYWxIaWVyYXJjaHkpIHRoaXMudXNlKGluaXRpYWxIaWVyYXJjaHkpXG4gIH1cblxuICBwdWJsaWMgYWN0aW9uU3RyZWFtKCkge1xuICAgIHJldHVybiB7XG4gICAgICBbU3ltYm9sLm9ic2VydmFibGVdKCkge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSxcbiAgICAgICdAQG9ic2VydmFibGUnKCkge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSxcbiAgICAgIHN1YnNjcmliZTogKFxuICAgICAgICBzdWJzY3JpYmVyOlxuICAgICAgICAgIHwge1xuICAgICAgICAgICAgICBjb21wbGV0ZT86ICgpID0+IHZvaWRcbiAgICAgICAgICAgICAgZXJyb3I/OiAoZXJyb3I6IHVua25vd24pID0+IHZvaWRcbiAgICAgICAgICAgICAgbmV4dD86IChhY3Rpb246IEFjdGlvbkNoYWluKSA9PiB2b2lkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfCAoKGFjdGlvbjogQWN0aW9uQ2hhaW4pID0+IHZvaWQpXG4gICAgICApID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlKHtcbiAgICAgICAgICBlZmZlY3RzOiAoeyBhY3Rpb24sIGVycm9yIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvciAmJiB0eXBlb2Ygc3Vic2NyaWJlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBzdWJzY3JpYmVyLmVycm9yPy4oZXJyb3IpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgICB0eXBlb2Ygc3Vic2NyaWJlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgID8gc3Vic2NyaWJlcihhY3Rpb24pXG4gICAgICAgICAgICAgICAgOiBzdWJzY3JpYmVyLm5leHQ/LihhY3Rpb24pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAgRGlzcGF0Y2hlcyBhbiBhY3Rpb24gdG8gdGhlIHN0b3JlLlxuXG4gICAgVGhlIGFjdGlvbiB3aWxsIGJlIHNlbnQgdGhyb3VnaCB0aGlzIHN0b3JlJ3MgcmVkdWNlciBoaWVyYXJjaHkgKGlmIGFueSkgYW5kXG4gICAgcGFzc2VkIG9uIHRvIGFueSBjaGlsZCBzdG9yZXMgYWZ0ZXIgYmVpbmcgd3JhcHBlZCBpbiBgaW5oZXJpdGAgbWV0YSBub2Rlc1xuXG4gICAgVGhlIHJlc3VsdGluZyBzdGF0ZSB3aWxsIGJlIHJldHVybmVkIHN5bmNocm9ub3VzbHkgZnJvbSB0aGlzIGNhbGwuXG5cbiAgICBUaGlzIGlzIGEgYm91bmQgZnVuY3Rpb24gcHJvcGVydHkuIEV2ZXJ5IHN0b3JlIHJlY3JlYXRlcyB0aGlzIHNtYWxsXG4gICAgZnVuY3Rpb24uIEJ1dCBpdCdzIGFsd2F5cyBib3VuZCBhbmQgY2FuIGJlIHBhc3NlZCBhcm91bmQgZWFzaWx5LlxuICAqL1xuICBwdWJsaWMgZGlzcGF0Y2ggPSAoYWN0aW9uOiBEaXNwYXRjaGFibGUpID0+IHtcbiAgICB0aGlzLl9zY2hlZHVsZXIuc2NoZWR1bGVOb3coe1xuICAgICAgdGFzazogKCkgPT4gdGhpcy5fZGlzcGF0Y2goYWN0aW9uKSxcbiAgICAgIHR5cGU6IDAsIC8vIFVwZGF0ZVN0b3JlICgwKVxuICAgIH0pXG5cbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlXG4gIH1cblxuICAvKipcbiAgICBSZXR1cm5zIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBzdG9yZS5cblxuICAgIERvIG5vdCBtdXRhdGUgdGhlIHJldHVybmVkIHZhbHVlLlxuICAqL1xuICBwdWJsaWMgZ2V0U3RhdGUoKSB7XG4gICAgaWYgKERFViAmJiB0aGlzLl9pc0Rpc3BhdGNoaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1plZHV4OiBzdG9yZS5nZXRTdGF0ZSgpIGNhbm5vdCBiZSBjYWxsZWQgaW4gYSByZWR1Y2VyJylcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlXG4gIH1cblxuICAvKipcbiAgICBBcHBsaWVzIGEgZnVsbCBoeWRyYXRpb24gdG8gdGhlIHN0b3JlLlxuXG4gICAgQWNjZXB0cyBlaXRoZXIgdGhlIG5ldyBzdGF0ZSBvciBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgY3VycmVudCBzdGF0ZVxuICAgIGFuZCByZXR1cm5zIHRoZSBuZXcgc3RhdGUuXG5cbiAgICBEaXNwYXRjaGVzIHRoZSBzcGVjaWFsIGBoeWRyYXRlYCBhY3Rpb24gdG8gdGhlIHN0b3JlJ3MgcmVkdWNlcnMuIEVmZmVjdHNcbiAgICBzdWJzY3JpYmVycyBjYW4gaW5zcGVjdCBhbmQgcmVjb3JkIHRoaXMgYWN0aW9uIHRvIGltcGxlbWVudCB0aW1lIHRyYXZlbC5cblxuICAgIFRoZSBgaHlkcmF0ZWAgYWN0aW9uJ3MgYHBheWxvYWRgIHByb3BlcnR5IHdpbGwgYmUgc2V0IHRvIHRoZSBuZXcgc3RhdGUuIFRoZVxuICAgIGFjdGlvbidzIGBtZXRhYCBwcm9wZXJ0eSB3aWxsIGJlIHNldCB0byB0aGUgcGFzc2VkIG1ldGEsIGlmIGFueS5cblxuICAgIFRocm93cyBhbiBlcnJvciBpZiBjYWxsZWQgZnJvbSB0aGUgcmVkdWNlciBsYXllci5cblxuICAgIFJldHVybnMgdGhlIG5ldyBzdGF0ZS5cblxuICAgIFVubGlrZSBzZXRTdGF0ZURlZXAsIHNldFN0YXRlIGlzIGEgYm91bmQgZnVuY3Rpb24gcHJvcGVydHkuIEV2ZXJ5IHN0b3JlXG4gICAgcmVjcmVhdGVzIHRoaXMgc21hbGwgZnVuY3Rpb24uIEJ1dCBpdCdzIGFsd2F5cyBib3VuZCBhbmQgY2FuIGJlIHBhc3NlZFxuICAgIGFyb3VuZCBlYXNpbHkuXG4gICovXG4gIHB1YmxpYyBzZXRTdGF0ZSA9IChzZXR0YWJsZTogU2V0dGFibGU8U3RhdGU+LCBtZXRhPzogYW55KSA9PiB7XG4gICAgdGhpcy5fc2NoZWR1bGVyLnNjaGVkdWxlTm93KHtcbiAgICAgIHRhc2s6ICgpID0+XG4gICAgICAgIHRoaXMuX3NldFN0YXRlKFxuICAgICAgICAgIHNldHRhYmxlIGFzIFNldHRhYmxlPFJlY3Vyc2l2ZVBhcnRpYWw8U3RhdGU+LCBTdGF0ZT4sXG4gICAgICAgICAgbWV0YVxuICAgICAgICApLFxuICAgICAgdHlwZTogMCwgLy8gVXBkYXRlU3RvcmUgKDApXG4gICAgfSlcblxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGVcbiAgfVxuXG4gIC8qKlxuICAgIEFwcGxpZXMgYSBwYXJ0aWFsIHN0YXRlIHVwZGF0ZSB0byB0aGUgc3RvcmUuXG5cbiAgICBBY2NlcHRzIGVpdGhlciBhIGRlZXAgcGFydGlhbCBzdGF0ZSBvYmplY3Qgb3IgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlXG4gICAgY3VycmVudCBzdGF0ZSBhbmQgcmV0dXJucyBhIGRlZXAgcGFydGlhbCBzdGF0ZSBvYmplY3QuXG5cbiAgICBEaXNwYXRjaGVzIHRoZSBzcGVjaWFsIGBtZXJnZWAgYWN0aW9uIHRvIHRoZSBzdG9yZSdzIHJlZHVjZXJzLlxuICAgIEVmZmVjdHMgc3Vic2NyaWJlcnMgY2FuIGluc3BlY3QgYW5kIHJlY29yZCB0aGlzIGFjdGlvbiB0byBpbXBsZW1lbnQgdGltZVxuICAgIHRyYXZlbC5cblxuICAgIFRoZSBgbWVyZ2VgIGFjdGlvbidzIGBwYXlsb2FkYCBwcm9wZXJ0eSB3aWxsIGJlIHNldCB0byB0aGUgcGFydGlhbFxuICAgIHN0YXRlIHVwZGF0ZS5cblxuICAgIE5vdGUgdGhhdCBkZWVwIHNldHRpbmcgY2Fubm90IHJlbW92ZSBwcm9wZXJ0aWVzIGZyb20gdGhlIHN0YXRlIHRyZWUuIElmIHRoYXRcbiAgICBmdW5jdGlvbmFsaXR5IGlzIG5lZWRlZCwgdXNlIHN0b3JlLnNldFN0YXRlKCkgb3IgY3JlYXRlIGEgbmV3IHJlZHVjZXJcbiAgICBoaWVyYXJjaHkgYW5kIHBhc3MgaXQgdG8gc3RvcmUudXNlKCkuXG5cbiAgICBUaHJvd3MgYW4gZXJyb3IgaWYgY2FsbGVkIGZyb20gdGhlIHJlZHVjZXIgbGF5ZXIuXG5cbiAgICBSZXR1cm5zIHRoZSBuZXcgc3RhdGUuXG5cbiAgICBVbmxpa2Ugc2V0U3RhdGUsIHNldFN0YXRlRGVlcCBpcyBub3QgYm91bmQuIFlvdSBtdXN0IGNhbGwgaXQgd2l0aCBjb250ZXh0IC1cbiAgICBlLmcuIGJ5IHVzaW5nIGRvdC1ub3RhdGlvbjogYHN0b3JlLnNldFN0YXRlRGVlcCguLi4pYFxuICAqL1xuICBwdWJsaWMgc2V0U3RhdGVEZWVwKFxuICAgIHNldHRhYmxlOiBTZXR0YWJsZTxSZWN1cnNpdmVQYXJ0aWFsPFN0YXRlPiwgU3RhdGU+LFxuICAgIG1ldGE/OiBhbnlcbiAgKSB7XG4gICAgdGhpcy5fc2NoZWR1bGVyLnNjaGVkdWxlTm93KHtcbiAgICAgIHRhc2s6ICgpID0+XG4gICAgICAgIHRoaXMuX3NldFN0YXRlKFxuICAgICAgICAgIHNldHRhYmxlIGFzIFNldHRhYmxlPFJlY3Vyc2l2ZVBhcnRpYWw8U3RhdGU+LCBTdGF0ZT4sXG4gICAgICAgICAgbWV0YSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICksXG4gICAgICB0eXBlOiAwLCAvLyBVcGRhdGVTdG9yZSAoMClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAgUmVnaXN0ZXJzIGEgc3Vic2NyaWJlciB3aXRoIHRoZSBzdG9yZS5cblxuICAgIFRoZSBzdWJzY3JpYmVyIHdpbGwgYmUgbm90aWZpZWQgZXZlcnkgdGltZSB0aGUgc3RvcmUncyBzdGF0ZVxuICAgIGNoYW5nZXMuXG5cbiAgICBSZXR1cm5zIGEgc3Vic2NyaXB0aW9uIG9iamVjdC4gQ2FsbGluZyBgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKClgXG4gICAgdW5yZWdpc3RlcnMgdGhlIHN1YnNjcmliZXIuXG4gICovXG4gIHB1YmxpYyBzdWJzY3JpYmUoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxTdGF0ZSwgdGhpcz4pIHtcbiAgICBjb25zdCBzdWJzY3JpYmVyT2JqID1cbiAgICAgIHR5cGVvZiBzdWJzY3JpYmVyID09PSAnZnVuY3Rpb24nID8geyBuZXh0OiBzdWJzY3JpYmVyIH0gOiBzdWJzY3JpYmVyXG5cbiAgICBpZiAoREVWKSB7XG4gICAgICBpZiAoc3Vic2NyaWJlck9iai5uZXh0ICYmIHR5cGVvZiBzdWJzY3JpYmVyT2JqLm5leHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBgWmVkdXg6IHN0b3JlLnN1YnNjcmliZSgpIGV4cGVjdHMgZWl0aGVyIGEgZnVuY3Rpb24gb3IgYW4gb2JqZWN0IHdpdGggYSBcIm5leHRcIiBwcm9wZXJ0eSB3aG9zZSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLiBSZWNlaXZlZDogJHtkZXRhaWxlZFR5cGVvZihcbiAgICAgICAgICAgIHN1YnNjcmliZXJPYmoubmV4dFxuICAgICAgICAgICl9YFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChzdWJzY3JpYmVyT2JqLmVycm9yICYmIHR5cGVvZiBzdWJzY3JpYmVyT2JqLmVycm9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgYFplZHV4OiBzdG9yZS5zdWJzY3JpYmUoKSAtIHN1YnNjcmliZXIuZXJyb3IgbXVzdCBiZSBhIGZ1bmN0aW9uLiBSZWNlaXZlZDogJHtkZXRhaWxlZFR5cGVvZihcbiAgICAgICAgICAgIHN1YnNjcmliZXJPYmouZXJyb3JcbiAgICAgICAgICApfWBcbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHN1YnNjcmliZXJPYmouZWZmZWN0cyAmJlxuICAgICAgICB0eXBlb2Ygc3Vic2NyaWJlck9iai5lZmZlY3RzICE9PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBgWmVkdXg6IHN0b3JlLnN1YnNjcmliZSgpIC0gc3Vic2NyaWJlci5lZmZlY3RzIG11c3QgYmUgYSBmdW5jdGlvbi4gUmVjZWl2ZWQ6ICR7ZGV0YWlsZWRUeXBlb2YoXG4gICAgICAgICAgICBzdWJzY3JpYmVyT2JqLmVmZmVjdHNcbiAgICAgICAgICApfWBcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N1YnNjcmliZXJzLnB1c2goc3Vic2NyaWJlck9iaiBhcyBTdWJzY3JpYmVyT2JqZWN0KVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHVuc3Vic2NyaWJlOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fc3Vic2NyaWJlcnMuaW5kZXhPZihcbiAgICAgICAgICBzdWJzY3JpYmVyT2JqIGFzIFN1YnNjcmliZXJPYmplY3RcbiAgICAgICAgKVxuXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB0aGlzLl9zdWJzY3JpYmVycy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICB9LFxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgIE1lcmdlcyBhIGhpZXJhcmNoeSBkZXNjcmlwdG9yIGludG8gdGhlIGV4aXN0aW5nIGhpZXJhcmNoeSBkZXNjcmlwdG9yLlxuXG4gICAgSW50ZWxsaWdlbnRseSBkaWZmcyB0aGUgdHdvIGhpZXJhcmNoaWVzIGFuZCBvbmx5IGNyZWF0ZXMvcmVjcmVhdGVzIHRoZVxuICAgIG5lY2Vzc2FyeSByZWR1Y2Vycy5cblxuICAgIERpc3BhdGNoZXMgdGhlIHNwZWNpYWwgYHByaW1lYCBhY3Rpb24gdG8gdGhlIHN0b3JlLlxuICAqL1xuICBwdWJsaWMgdXNlKG5ld0hpZXJhcmNoeTogSGllcmFyY2h5RGVzY3JpcHRvcjxTdGF0ZT4pIHtcbiAgICBjb25zdCBuZXdEaWZmVHJlZSA9IGhpZXJhcmNoeURlc2NyaXB0b3JUb0RpZmZUcmVlKFxuICAgICAgbmV3SGllcmFyY2h5LFxuICAgICAgdGhpcy5fcmVnaXN0ZXJDaGlsZFN0b3JlLmJpbmQodGhpcylcbiAgICApXG5cbiAgICB0aGlzLl9jdXJyZW50RGlmZlRyZWUgPSBtZXJnZURpZmZUcmVlcyhcbiAgICAgIHRoaXMuX2N1cnJlbnREaWZmVHJlZSxcbiAgICAgIG5ld0RpZmZUcmVlLFxuICAgICAgKHRoaXMuY29uc3RydWN0b3IgYXMgdHlwZW9mIFN0b3JlKS5oaWVyYXJjaHlDb25maWdcbiAgICApXG4gICAgdGhpcy5fcm9vdFJlZHVjZXIgPSB0aGlzLl9jdXJyZW50RGlmZlRyZWUucmVkdWNlclxuXG4gICAgaWYgKHRoaXMuX3Jvb3RSZWR1Y2VyKSB7XG4gICAgICB0aGlzLl9kaXNwYXRjaEFjdGlvbihwcmltZUFjdGlvbiwgcHJpbWVBY3Rpb24sIHRoaXMuX2N1cnJlbnRTdGF0ZSlcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcyAvLyBmb3IgY2hhaW5pbmdcbiAgfVxuXG4gIC8qKlxuICAgKiBPbmx5IGZvciBpbnRlcm5hbCB1c2UuXG4gICAqL1xuICBwdWJsaWMgX3JlZ2lzdGVyKGVmZmVjdHM6IEVmZmVjdHNTdWJzY3JpYmVyKSB7XG4gICAgY29uc3QgcGFyZW50cyA9IHRoaXMuX3BhcmVudHMgfHwgKHRoaXMuX3BhcmVudHMgPSBbXSlcbiAgICBwYXJlbnRzLnB1c2goZWZmZWN0cylcblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHBhcmVudHMuaW5kZXhPZihlZmZlY3RzKVxuXG4gICAgICBpZiAoaW5kZXggPiAtMSkgcGFyZW50cy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgfVxuICB9XG5cbiAgcHVibGljIFtTeW1ib2wub2JzZXJ2YWJsZV0oKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHB1YmxpYyAnQEBvYnNlcnZhYmxlJygpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBfZGlzcGF0Y2goYWN0aW9uOiBEaXNwYXRjaGFibGUpIHtcbiAgICBpZiAoREVWICYmIHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdaZWR1eDogc3RvcmUuZGlzcGF0Y2goKSAtIFRodW5rcyBhcmUgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQuIE9ubHkgbm9ybWFsIGFjdGlvbiBvYmplY3RzIGNhbiBiZSBwYXNzZWQgdG8gc3RvcmUuZGlzcGF0Y2goKS4gRm9yIHplcm8tY29uZmlnIHN0b3JlcywgeW91IGNhbiBwYXNzIGEgZnVuY3Rpb24gdG8gc3RvcmUuc2V0U3RhdGUoKSdcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoREVWICYmICFpc1BsYWluT2JqZWN0KGFjdGlvbikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGBaZWR1eDogc3RvcmUuZGlzcGF0Y2goKSAtIEFjdGlvbiBtdXN0IGJlIGEgcGxhaW4gb2JqZWN0LiBSZWNlaXZlZCAke2RldGFpbGVkVHlwZW9mKFxuICAgICAgICAgIGFjdGlvblxuICAgICAgICApfWBcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBkZWxlZ2F0ZVJlc3VsdCA9IGRlbGVnYXRlKHRoaXMuX2N1cnJlbnREaWZmVHJlZSwgYWN0aW9uKVxuXG4gICAgaWYgKGRlbGVnYXRlUmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgLy8gTm8gbmVlZCB0byBpbmZvcm0gc3Vic2NyaWJlcnMgLSB0aGlzIHN0b3JlJ3MgZWZmZWN0cyBzdWJzY3JpYmVyXG4gICAgICAvLyBvbiB0aGUgY2hpbGQgc3RvcmUgd2lsbCBoYXZlIGFscmVhZHkgZG9uZSB0aGF0IGJ5IHRoaXMgcG9pbnRcbiAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGVcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcm91dGVBY3Rpb24oYWN0aW9uKVxuICB9XG5cbiAgcHJpdmF0ZSBfZGlzcGF0Y2hBY3Rpb24oXG4gICAgYWN0aW9uOiBBY3Rpb25DaGFpbixcbiAgICB1bndyYXBwZWRBY3Rpb246IEFjdGlvbixcbiAgICByb290U3RhdGU6IFN0YXRlXG4gICkge1xuICAgIGlmIChERVYgJiYgdGhpcy5faXNEaXNwYXRjaGluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnWmVkdXg6IGRpc3BhdGNoKCksIHNldFN0YXRlKCksIGFuZCBzZXRTdGF0ZURlZXAoKSBjYW5ub3QgYmUgY2FsbGVkIGluIGEgcmVkdWNlcidcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLl9pc0Rpc3BhdGNoaW5nID0gdHJ1ZVxuXG4gICAgbGV0IGVycm9yOiB1bmtub3duXG4gICAgbGV0IG5ld1N0YXRlID0gcm9vdFN0YXRlXG5cbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuX3Jvb3RSZWR1Y2VyKSB7XG4gICAgICAgIG5ld1N0YXRlID0gdGhpcy5fcm9vdFJlZHVjZXIocm9vdFN0YXRlLCB1bndyYXBwZWRBY3Rpb24pXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBlcnJvciA9IGVyclxuXG4gICAgICB0aHJvdyBlcnJcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5faXNEaXNwYXRjaGluZyA9IGZhbHNlXG5cbiAgICAgIHRoaXMuX2luZm9ybVN1YnNjcmliZXJzKG5ld1N0YXRlLCBhY3Rpb24sIGVycm9yKVxuICAgIH1cblxuICAgIHJldHVybiBuZXdTdGF0ZVxuICB9XG5cbiAgLyoqXG4gICAgXCJIeWRyYXRlc1wiIHRoZSBzdG9yZSB3aXRoIHRoZSBnaXZlbiBzdGF0ZS5cblxuICAgIERpc3BhdGNoZXMgdGhlIHNwZWNpYWwgYGh5ZHJhdGVgIGFjdGlvbiB0byB0aGUgc3RvcmUncyBpbnNwZWN0b3JzXG4gICAgYW5kIHJlZHVjZXJzLiBUaGUgYGh5ZHJhdGVgIGFjdGlvbidzIGBwYXlsb2FkYCBwcm9wZXJ0eSB3aWxsIGJlXG4gICAgc2V0IHRvIHRoZSBuZXcgc3RvcmUgc3RhdGUsIGFsbG93aW5nIGluc3BlY3RvcnMgdG8gcGljayB1cCBvblxuICAgIHRoZSBjaGFuZ2VzIGFuZCBpbXBsZW1lbnQgdGltZSB0cmF2ZWwgYW5kIHdoYXRub3QuXG5cbiAgICBUaHJvd3MgYW4gRXJyb3IgaWYgY2FsbGVkIGZyb20gdGhlIHJlZHVjZXIgbGF5ZXIuXG4gICovXG4gIHByaXZhdGUgX2Rpc3BhdGNoSHlkcmF0aW9uPFN0YXRlID0gYW55PihcbiAgICBzdGF0ZTogUmVjdXJzaXZlUGFydGlhbDxTdGF0ZT4sXG4gICAgYWN0aW9uVHlwZTogc3RyaW5nLFxuICAgIG1ldGE/OiBhbnlcbiAgKSB7XG4gICAgY29uc3QgbmV3U3RhdGUgPVxuICAgICAgYWN0aW9uVHlwZSA9PT0gaW50ZXJuYWxUeXBlcy5oeWRyYXRlXG4gICAgICAgID8gc3RhdGVcbiAgICAgICAgOiBtZXJnZVN0YXRlVHJlZXMoXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICh0aGlzLmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBTdG9yZSkuaGllcmFyY2h5Q29uZmlnXG4gICAgICAgICAgKVswXVxuXG4gICAgaWYgKG5ld1N0YXRlID09PSB0aGlzLl9jdXJyZW50U3RhdGUpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8uIFRPRE86IFNob3VsZCB0aGlzIGluZm9ybSBlZmZlY3RzIHN1YnNjcmliZXJzP1xuICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZVxuICAgIH1cblxuICAgIGNvbnN0IGFjdGlvbjogQWN0aW9uID0ge1xuICAgICAgcGF5bG9hZDogbmV3U3RhdGUsXG4gICAgICB0eXBlOiBhY3Rpb25UeXBlLFxuICAgIH1cblxuICAgIGlmIChtZXRhICE9IG51bGwpIGFjdGlvbi5tZXRhID0gbWV0YVxuXG4gICAgLy8gTWF5YmUgd2UgY2FuIHByb3ZpZGUgYSB1dGlsaXR5IGZvciBzZXR0aW5nIGEgZGVzY3JpcHRpb24gZm9yIHRoZVxuICAgIC8vIGh5ZHJhdGlvbi4gVGhlbiB3cmFwIHRoZSBhY3Rpb24gaW4gYW4gQWN0aW9uTWV0YSB3aXRoIHRoYXQgZGVzY3JpcHRpb25cbiAgICAvLyBhcyB0aGUgbWV0YURhdGEuXG5cbiAgICAvLyBQcm9wYWdhdGUgdGhlIGNoYW5nZSB0byBjaGlsZCBzdG9yZXMgYW5kIGFsbG93IGZvciBlZmZlY3RzLlxuICAgIHJldHVybiB0aGlzLl9kaXNwYXRjaEFjdGlvbihhY3Rpb24sIGFjdGlvbiwgbmV3U3RhdGUpXG4gIH1cblxuICBwcml2YXRlIF9kaXNwYXRjaFN0YXRlU2V0dGVyKFxuICAgIGdldFN0YXRlOiBTZXRTdGF0ZTxTdGF0ZT4sXG4gICAgbWV0YT86IGFueSxcbiAgICBkZWVwPzogYm9vbGVhblxuICApIHtcbiAgICBsZXQgbmV3U3RhdGVcblxuICAgIHRyeSB7XG4gICAgICBuZXdTdGF0ZSA9IGdldFN0YXRlKHRoaXMuX2N1cnJlbnRTdGF0ZSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5faW5mb3JtU3Vic2NyaWJlcnMoXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSxcbiAgICAgICAgeyB0eXBlOiBpbnRlcm5hbFR5cGVzLm1lcmdlIH0sXG4gICAgICAgIGVycm9yXG4gICAgICApXG5cbiAgICAgIHRocm93IGVycm9yXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoSHlkcmF0aW9uKFxuICAgICAgbmV3U3RhdGUsXG4gICAgICBkZWVwID8gaW50ZXJuYWxUeXBlcy5tZXJnZSA6IGludGVybmFsVHlwZXMuaHlkcmF0ZSxcbiAgICAgIG1ldGFcbiAgICApXG4gIH1cblxuICBwcml2YXRlIF9maW5pc2hJbmZvcm1pbmcoZWZmZWN0OiBTdG9yZUVmZmVjdDxTdGF0ZSwgdGhpcz4pIHtcbiAgICAvLyBDbG9uZSB0aGUgc3Vic2NyaWJlcnMgaW4gY2FzZSBvZiBtdXRhdGlvbiBtaWQtaXRlcmF0aW9uXG4gICAgY29uc3Qgc3Vic2NyaWJlcnMgPSBbLi4udGhpcy5fc3Vic2NyaWJlcnNdXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdWJzY3JpYmVyID0gc3Vic2NyaWJlcnNbaV1cblxuICAgICAgaWYgKGVmZmVjdC5lcnJvciAmJiBzdWJzY3JpYmVyLmVycm9yKSBzdWJzY3JpYmVyLmVycm9yKGVmZmVjdC5lcnJvcilcblxuICAgICAgaWYgKGVmZmVjdC5uZXdTdGF0ZSAhPT0gZWZmZWN0Lm9sZFN0YXRlICYmIHN1YnNjcmliZXIubmV4dCkge1xuICAgICAgICBzdWJzY3JpYmVyLm5leHQoXG4gICAgICAgICAgZWZmZWN0Lm5ld1N0YXRlLFxuICAgICAgICAgIGVmZmVjdC5vbGRTdGF0ZSxcbiAgICAgICAgICBlZmZlY3QuYWN0aW9uIGFzIEFjdGlvbkNoYWluXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKHN1YnNjcmliZXIuZWZmZWN0cykgc3Vic2NyaWJlci5lZmZlY3RzKGVmZmVjdClcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9pbmZvcm1TdWJzY3JpYmVycyhcbiAgICBuZXdTdGF0ZTogU3RhdGUsXG4gICAgYWN0aW9uPzogQWN0aW9uQ2hhaW4sXG4gICAgZXJyb3I/OiB1bmtub3duXG4gICkge1xuICAgIGNvbnN0IGVmZmVjdDogU3RvcmVFZmZlY3Q8U3RhdGUsIHRoaXM+ID0ge1xuICAgICAgYWN0aW9uLFxuICAgICAgZXJyb3IsXG4gICAgICBuZXdTdGF0ZSxcbiAgICAgIG9sZFN0YXRlOiB0aGlzLl9jdXJyZW50U3RhdGUsXG4gICAgICBzdG9yZTogdGhpcyxcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIHN0b3JlZCBzdGF0ZVxuICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlXG5cbiAgICAvLyBkZWZlciBpbmZvcm1pbmcgaWYgYSBwYXJlbnQgc3RvcmUgaXMgY3VycmVudGx5IGRpc3BhdGNoaW5nXG4gICAgdGhpcy5fc2NoZWR1bGVyLnNjaGVkdWxlTm93KFxuICAgICAge1xuICAgICAgICB0YXNrOiAoKSA9PiB7XG4gICAgICAgICAgLy8gc2tpcCBpbmZvcm1pbmcgc3Vic2NyaWJlcnMgaWYgdGhlIHN0YXRlIGhhcyBhbHJlYWR5IGJlZW4gY2hhbmdlZFxuICAgICAgICAgIC8vIGJ5IGEgcGFyZW50IHN0b3JlJ3Mgc3Vic2NyaWJlciAod2hpY2ggc3RhdGUgY2hhbmdlIGlzIGFscmVhZHlcbiAgICAgICAgICAvLyBwcm9wYWdhdGVkIHRvIHRoaXMgc3RvcmUncyBzdWJzY3JpYmVycyBieSB0aGlzIHBvaW50KTpcbiAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlICE9PSBuZXdTdGF0ZSkgcmV0dXJuXG5cbiAgICAgICAgICB0aGlzLl9maW5pc2hJbmZvcm1pbmcoZWZmZWN0KVxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiAxLCAvLyBJbmZvcm1TdWJzY3JpYmVycyAoMSlcbiAgICAgIH0sXG4gICAgICBmYWxzZVxuICAgIClcblxuICAgIHRoaXMuX3BhcmVudHM/LmZvckVhY2gocGFyZW50ID0+IHBhcmVudChlZmZlY3QpKVxuICB9XG5cbiAgcHJpdmF0ZSBfcmVnaXN0ZXJDaGlsZFN0b3JlPFN0YXRlID0gYW55PihcbiAgICBjaGlsZFN0b3JlUGF0aDogc3RyaW5nW10sXG4gICAgY2hpbGRTdG9yZTogU3RvcmVcbiAgKSB7XG4gICAgY29uc3QgZWZmZWN0c1N1YnNjcmliZXI6IEVmZmVjdHNTdWJzY3JpYmVyPFN0YXRlPiA9ICh7XG4gICAgICBhY3Rpb24sXG4gICAgICBlcnJvcixcbiAgICAgIG5ld1N0YXRlLFxuICAgICAgb2xkU3RhdGUsXG4gICAgfSkgPT4ge1xuICAgICAgLy8gSWYgdGhpcyBzdG9yZSdzIHJlZHVjZXIgbGF5ZXIgZGlzcGF0Y2hlZCB0aGlzIGFjdGlvbiB0byB0aGlzXG4gICAgICAvLyBzdWJzdG9yZSBpbiB0aGUgZmlyc3QgcGxhY2UsIGlnbm9yZSB0aGUgcHJvcGFnYXRpb247IHRoaXMgc3RvcmVcbiAgICAgIC8vIHdpbGwgcmVjZWl2ZSBpdCBhbnl3YXkuXG4gICAgICAvLyBjb25zdCBpc0luaGVyaXRlZCA9IGhhc01ldGEoYWN0aW9uLCBpbnRlcm5hbFR5cGVzLmluaGVyaXQpXG4gICAgICBpZiAodGhpcy5faXNEaXNwYXRjaGluZykgcmV0dXJuXG5cbiAgICAgIGNvbnN0IG5ld093blN0YXRlID1cbiAgICAgICAgbmV3U3RhdGUgPT09IG9sZFN0YXRlXG4gICAgICAgICAgPyB0aGlzLl9jdXJyZW50U3RhdGVcbiAgICAgICAgICA6IHByb3BhZ2F0ZUNoYW5nZShcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlLFxuICAgICAgICAgICAgICBjaGlsZFN0b3JlUGF0aCxcbiAgICAgICAgICAgICAgbmV3U3RhdGUsXG4gICAgICAgICAgICAgICh0aGlzLmNvbnN0cnVjdG9yIGFzIHR5cGVvZiBTdG9yZSkuaGllcmFyY2h5Q29uZmlnXG4gICAgICAgICAgICApXG5cbiAgICAgIC8vIFRlbGwgdGhlIHN1YnNjcmliZXJzIHdoYXQgY2hpbGQgc3RvcmUgdGhpcyBhY3Rpb24gY2FtZSBmcm9tLlxuICAgICAgLy8gVGhpcyBzdG9yZSAodGhlIHBhcmVudCkgY2FuIHVzZSB0aGlzIGluZm8gdG8gZGV0ZXJtaW5lIGhvdyB0b1xuICAgICAgLy8gcmVjcmVhdGUgdGhpcyBzdGF0ZSB1cGRhdGUuXG4gICAgICBjb25zdCB3cmFwcGVkQWN0aW9uID1cbiAgICAgICAgYWN0aW9uICYmIGFkZE1ldGEoYWN0aW9uLCBpbnRlcm5hbFR5cGVzLmRlbGVnYXRlLCBjaGlsZFN0b3JlUGF0aClcblxuICAgICAgdGhpcy5faW5mb3JtU3Vic2NyaWJlcnMobmV3T3duU3RhdGUsIHdyYXBwZWRBY3Rpb24sIGVycm9yKVxuICAgIH1cblxuICAgIHJldHVybiBjaGlsZFN0b3JlLl9yZWdpc3RlcihlZmZlY3RzU3Vic2NyaWJlcilcbiAgfVxuXG4gIHByaXZhdGUgX3JvdXRlQWN0aW9uKGFjdGlvbjogQWN0aW9uQ2hhaW4pIHtcbiAgICBjb25zdCB1bndyYXBwZWRBY3Rpb24gPSByZW1vdmVBbGxNZXRhKGFjdGlvbilcblxuICAgIGlmIChERVYgJiYgdHlwZW9mIHVud3JhcHBlZEFjdGlvbi50eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYFplZHV4OiBzdG9yZS5kaXNwYXRjaCgpIC0gQWN0aW9uIG11c3QgaGF2ZSBhIHN0cmluZyBcInR5cGVcIiBwcm9wZXJ0eS4gUmVjZWl2ZWQgJHtkZXRhaWxlZFR5cGVvZihcbiAgICAgICAgICB1bndyYXBwZWRBY3Rpb24udHlwZVxuICAgICAgICApfWBcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB1bndyYXBwZWRBY3Rpb24udHlwZSA9PT0gaW50ZXJuYWxUeXBlcy5oeWRyYXRlIHx8XG4gICAgICB1bndyYXBwZWRBY3Rpb24udHlwZSA9PT0gaW50ZXJuYWxUeXBlcy5tZXJnZVxuICAgICkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoSHlkcmF0aW9uKFxuICAgICAgICB1bndyYXBwZWRBY3Rpb24ucGF5bG9hZCxcbiAgICAgICAgdW53cmFwcGVkQWN0aW9uLnR5cGUsXG4gICAgICAgIHVud3JhcHBlZEFjdGlvbi5tZXRhXG4gICAgICApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoQWN0aW9uKGFjdGlvbiwgdW53cmFwcGVkQWN0aW9uLCB0aGlzLl9jdXJyZW50U3RhdGUpXG4gIH1cblxuICBwcml2YXRlIF9zZXRTdGF0ZShcbiAgICBzZXR0YWJsZTogU2V0dGFibGU8UmVjdXJzaXZlUGFydGlhbDxTdGF0ZT4sIFN0YXRlPixcbiAgICBtZXRhPzogYW55LFxuICAgIGRlZXAgPSBmYWxzZVxuICApIHtcbiAgICBpZiAodHlwZW9mIHNldHRhYmxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlzcGF0Y2hTdGF0ZVNldHRlcihzZXR0YWJsZSBhcyBTZXRTdGF0ZTxTdGF0ZT4sIG1ldGEsIGRlZXApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2Rpc3BhdGNoSHlkcmF0aW9uKFxuICAgICAgc2V0dGFibGUsXG4gICAgICBkZWVwID8gaW50ZXJuYWxUeXBlcy5tZXJnZSA6IGludGVybmFsVHlwZXMuaHlkcmF0ZSxcbiAgICAgIG1ldGFcbiAgICApXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJpbnRlcm5hbFR5cGVzIiwiU3RvcmUiLCJpcyIsImFkZE1ldGEiLCJkZXRhaWxlZFR5cGVvZiIsIkhpZXJhcmNoeVR5cGUiLCJpc1BsYWluT2JqZWN0IiwiYnJhbmNoVG9EaWZmTm9kZUNoaWxkcmVuIiwiYnJhbmNoIiwicmVnaXN0ZXJTdWJTdG9yZSIsImN1cnJlbnRQYXRoIiwiY2hpbGRyZW4iLCJPYmplY3QiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImtleSIsInZhbCIsIm5ld1BhdGgiLCJoaWVyYXJjaHlEZXNjcmlwdG9yVG9EaWZmVHJlZSIsIm5vbkJyYW5jaFRvRGlmZk5vZGUiLCJ0eXBlIiwiaGllcmFyY2h5IiwiTnVsbCIsIlJlZHVjZXIiLCJyZWR1Y2VyIiwiZGVzdHJveSIsIndyYXBTdG9yZUluUmVkdWNlciIsInN0b3JlIiwiZ2V0SGllcmFyY2h5VHlwZSIsImRlc2NyaXB0b3IiLCJCcmFuY2giLCJERVYiLCJUeXBlRXJyb3IiLCJzdGF0ZSIsImFjdGlvbiIsImh5ZHJhdGUiLCJtZXJnZSIsInBheWxvYWQiLCJpbmhlcml0ZWRBY3Rpb24iLCJpbmhlcml0IiwiZGlzcGF0Y2giLCJjcmVhdGVCcmFuY2hSZWR1Y2VyIiwiY3JlYXRlIiwiZ2V0IiwiaXNOb2RlIiwic2V0Iiwic2l6ZSIsIm9sZFN0YXRlIiwibmV3U3RhdGUiLCJoYXNDaGFuZ2VzIiwia2V5cyIsIm9sZFN0YXRlUGllY2UiLCJ1bmRlZmluZWQiLCJuZXdTdGF0ZVBpZWNlIiwibGVuZ3RoIiwiZGVzdHJveVRyZWUiLCJ0cmVlIiwidmFsdWVzIiwibWVyZ2VCcmFuY2hlcyIsIm9sZFRyZWUiLCJuZXdUcmVlIiwiaGllcmFyY2h5Q29uZmlnIiwibWVyZ2VkQ2hpbGRyZW4iLCJuZXdDaGlsZCIsIm9sZENoaWxkIiwibWVyZ2VkQ2hpbGQiLCJtZXJnZURpZmZUcmVlcyIsIm1lcmdlU3RhdGVUcmVlcyIsIm9sZFN0YXRlVHJlZSIsIm5ld1N0YXRlVHJlZSIsIm1lcmdlZFRyZWUiLCJjbG9uZSIsIml0ZXJhdGUiLCJuZXdWYWwiLCJvbGRWYWwiLCJjbG9uZWRWYWwiLCJjaGlsZEhhc0NoYW5nZXMiLCJnZXRNZXRhRGF0YSIsInJlbW92ZU1ldGEiLCJnZXRFcnJvck1lc3NhZ2UiLCJzdWJTdG9yZVBhdGgiLCJqb2luIiwiZmluZENoaWxkIiwiZGlmZlRyZWUiLCJub2RlUGF0aCIsIm5vZGUiLCJSZWZlcmVuY2VFcnJvciIsImRlbGVnYXRlIiwiY2hpbGQiLCJwcm9wYWdhdGVDaGFuZ2UiLCJjdXJyZW50U3RhdGUiLCJuZXdTdWJTdG9yZVN0YXRlIiwibmV3Tm9kZSIsIm5leHROb2RlS2V5Iiwic2xpY2UiLCJjYWxsYmFjayIsIlNUT1JFX0lERU5USUZJRVIiLCJkZWZhdWx0SGllcmFyY2h5Q29uZmlnIiwicmVtb3ZlQWxsTWV0YSIsImRlZmF1bHRTY2hlZHVsZXIiLCJzY2hlZHVsZU5vdyIsImpvYiIsInRhc2siLCJwcmltZUFjdGlvbiIsInByaW1lIiwiY3JlYXRlU3RvcmUiLCJpbml0aWFsSGllcmFyY2h5IiwiaW5pdGlhbFN0YXRlIiwiU3ltYm9sIiwib2JzZXJ2YWJsZSIsIl9zdWJzY3JpYmVycyIsIl9zY2hlZHVsZXIiLCJfZGlzcGF0Y2giLCJfY3VycmVudFN0YXRlIiwic2V0U3RhdGUiLCJzZXR0YWJsZSIsIm1ldGEiLCJfc2V0U3RhdGUiLCJ1c2UiLCJhY3Rpb25TdHJlYW0iLCJzdWJzY3JpYmUiLCJzdWJzY3JpYmVyIiwiZWZmZWN0cyIsImVycm9yIiwibmV4dCIsImdldFN0YXRlIiwiX2lzRGlzcGF0Y2hpbmciLCJFcnJvciIsInNldFN0YXRlRGVlcCIsInN1YnNjcmliZXJPYmoiLCJwdXNoIiwidW5zdWJzY3JpYmUiLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJuZXdIaWVyYXJjaHkiLCJuZXdEaWZmVHJlZSIsIl9yZWdpc3RlckNoaWxkU3RvcmUiLCJiaW5kIiwiX2N1cnJlbnREaWZmVHJlZSIsImNvbnN0cnVjdG9yIiwiX3Jvb3RSZWR1Y2VyIiwiX2Rpc3BhdGNoQWN0aW9uIiwiX3JlZ2lzdGVyIiwicGFyZW50cyIsIl9wYXJlbnRzIiwiZGVsZWdhdGVSZXN1bHQiLCJfcm91dGVBY3Rpb24iLCJ1bndyYXBwZWRBY3Rpb24iLCJyb290U3RhdGUiLCJlcnIiLCJfaW5mb3JtU3Vic2NyaWJlcnMiLCJfZGlzcGF0Y2hIeWRyYXRpb24iLCJhY3Rpb25UeXBlIiwiX2Rpc3BhdGNoU3RhdGVTZXR0ZXIiLCJkZWVwIiwiX2ZpbmlzaEluZm9ybWluZyIsImVmZmVjdCIsInN1YnNjcmliZXJzIiwiaSIsInBhcmVudCIsImNoaWxkU3RvcmVQYXRoIiwiY2hpbGRTdG9yZSIsImVmZmVjdHNTdWJzY3JpYmVyIiwibmV3T3duU3RhdGUiLCJ3cmFwcGVkQWN0aW9uIiwiJCR0eXBlb2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1694\n")},9283:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"is\": function() { return /* binding */ is; }\n/* harmony export */ });\n/**\n * is() - Checks if a value is an instance of a class\n *\n * We can't use instanceof 'cause that breaks across realms - e.g. when an atom\n * instance is shared between a parent and child window, that instance's object\n * reference will be different in both windows (since each window creates its\n * own copy of Zedux).\n *\n * The classToCheck should have a static $$typeof property whose value is a\n * symbol created with Symbol.for() (sharing the symbol reference across realms)\n *\n * This works no matter how deep the inheritance tree is for either object\n * passed.\n *\n * @param val anything - the thing we're checking\n * @param classToCheck a class with a static $$typeof property\n * @returns boolean - whether val is an instanceof classToCheck\n */var is=function is(val,classToCheck){var _val$constructor;return(val==null?void 0:(_val$constructor=val.constructor)==null?void 0:_val$constructor.$$typeof)===classToCheck.$$typeof;};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTI4My5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FDTyxHQUFNQSxHQUFFLENBQUcsUUFBTEEsR0FBRSxDQUFJQyxHQUFRLENBQUVDLFlBQWtDLDZCQUM3RCxDQUFBRCxHQUFHLGdDQUFIQSxHQUFHLENBQUVFLFdBQVcsZUFBaEIsaUJBQWtCQyxRQUFRLElBQUtGLFlBQVksQ0FBQ0UsUUFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvY29yZS9zcmMvYXBpL2lzLnRzP2NiNTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBpcygpIC0gQ2hlY2tzIGlmIGEgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgYSBjbGFzc1xuICpcbiAqIFdlIGNhbid0IHVzZSBpbnN0YW5jZW9mICdjYXVzZSB0aGF0IGJyZWFrcyBhY3Jvc3MgcmVhbG1zIC0gZS5nLiB3aGVuIGFuIGF0b21cbiAqIGluc3RhbmNlIGlzIHNoYXJlZCBiZXR3ZWVuIGEgcGFyZW50IGFuZCBjaGlsZCB3aW5kb3csIHRoYXQgaW5zdGFuY2UncyBvYmplY3RcbiAqIHJlZmVyZW5jZSB3aWxsIGJlIGRpZmZlcmVudCBpbiBib3RoIHdpbmRvd3MgKHNpbmNlIGVhY2ggd2luZG93IGNyZWF0ZXMgaXRzXG4gKiBvd24gY29weSBvZiBaZWR1eCkuXG4gKlxuICogVGhlIGNsYXNzVG9DaGVjayBzaG91bGQgaGF2ZSBhIHN0YXRpYyAkJHR5cGVvZiBwcm9wZXJ0eSB3aG9zZSB2YWx1ZSBpcyBhXG4gKiBzeW1ib2wgY3JlYXRlZCB3aXRoIFN5bWJvbC5mb3IoKSAoc2hhcmluZyB0aGUgc3ltYm9sIHJlZmVyZW5jZSBhY3Jvc3MgcmVhbG1zKVxuICpcbiAqIFRoaXMgd29ya3Mgbm8gbWF0dGVyIGhvdyBkZWVwIHRoZSBpbmhlcml0YW5jZSB0cmVlIGlzIGZvciBlaXRoZXIgb2JqZWN0XG4gKiBwYXNzZWQuXG4gKlxuICogQHBhcmFtIHZhbCBhbnl0aGluZyAtIHRoZSB0aGluZyB3ZSdyZSBjaGVja2luZ1xuICogQHBhcmFtIGNsYXNzVG9DaGVjayBhIGNsYXNzIHdpdGggYSBzdGF0aWMgJCR0eXBlb2YgcHJvcGVydHlcbiAqIEByZXR1cm5zIGJvb2xlYW4gLSB3aGV0aGVyIHZhbCBpcyBhbiBpbnN0YW5jZW9mIGNsYXNzVG9DaGVja1xuICovXG5leHBvcnQgY29uc3QgaXMgPSAodmFsOiBhbnksIGNsYXNzVG9DaGVjazogeyAkJHR5cGVvZjogc3ltYm9sIH0pOiBib29sZWFuID0+XG4gIHZhbD8uY29uc3RydWN0b3I/LiQkdHlwZW9mID09PSBjbGFzc1RvQ2hlY2suJCR0eXBlb2ZcbiJdLCJuYW1lcyI6WyJpcyIsInZhbCIsImNsYXNzVG9DaGVjayIsImNvbnN0cnVjdG9yIiwiJCR0eXBlb2YiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9283\n")},7159:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "g2": function() { return /* binding */ getMetaData; },\n/* harmony export */   "hM": function() { return /* binding */ removeMeta; },\n/* harmony export */   "k": function() { return /* binding */ addMeta; },\n/* harmony export */   "vU": function() { return /* binding */ removeAllMeta; },\n/* harmony export */   "yF": function() { return /* binding */ hasMeta; }\n/* harmony export */ });\n/* harmony import */ var _utils_general__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8487);\nvar assertActionExists= true?function(action){if(action)return;throw new Error("Zedux: Invalid action chain. The last node in the chain must be either a valid action object with a non-empty \\"type\\" property or an effect with a non-empty \\"effectType\\" property. Received "+(0,_utils_general__WEBPACK_IMPORTED_MODULE_0__/* .detailedTypeof */ .px)(action));}:0;var getNewRoot=function getNewRoot(currentNode,prevNode,rootNode){// If the match is at the top layer, just return the next layer\nif(!prevNode||!rootNode)return currentNode.payload;// If the match is at least one layer deep, swap out the target layer\n// and return the new root of the action chain\nprevNode.payload=currentNode.payload;return rootNode;};/**\n * Adds a meta node of the given metaType and with the given metaData at the\n * beginning of an ActionChain\n */var addMeta=function addMeta(action,metaType,metaData){var wrappedAction={metaType:metaType,payload:action};if(metaData)wrappedAction.metaData=metaData;return wrappedAction;};/**\n * Returns the value of the metaData field of the first ActionMeta object in the\n * chain with the given metaType.\n */var getMetaData=function getMetaData(action,metaType){while(action.metaType){if(action.metaType===metaType){return action.metaData;}action=action.payload;if(true){assertActionExists(action);}}};/**\n * Returns true if the given ActionChain contains an ActionMeta node with the\n * given metaType.\n */var hasMeta=function hasMeta(action,metaType){while(action.metaType){if(action.metaType===metaType)return true;action=action.payload;if(true){assertActionExists(action);}}return false;};/**\n * Strips all ActionMeta nodes off an ActionChain and returns the wrapped Action\n */var removeAllMeta=function removeAllMeta(action){while(action.metaType){action=action.payload;if(true){assertActionExists(action);}}return action;};/**\n * Removes the first found meta node with the given metaType in the given action\n * chain.\n *\n * The metaType does not have to exist in the action chain (though this\'ll be\n * pretty inefficient and wasteful if it doesn\'t).\n */var removeMeta=function removeMeta(action,metaType){var currentNode=action;var prevNode=null;var rootNode=null;while(currentNode.metaType){if(currentNode.metaType===metaType){return getNewRoot(currentNode,prevNode,rootNode);}// Move down the chain\nvar clonedNode=Object.assign({},currentNode);prevNode&&(prevNode.payload=clonedNode);prevNode=clonedNode;currentNode=currentNode.payload;// If this will be the new root, remember it\nrootNode||(rootNode=prevNode);}// No match found; return the original action chain\nreturn action;};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LENBRUE7QUFDQSxHQUFNVSxXQUFVLGtCQUFRWixXQUFXLENBQUUsQ0FFckNDLFFBQVEsR0FBS0EsUUFBUSxDQUFDRSxPQUFPLENBQUdTLFVBQVUsQ0FBQyxDQUUzQ1gsUUFBUSxDQUFHVyxVQUFVLENBQ3JCWixXQUFXLENBQUdBLFdBQVcsQ0FBQ0csT0FBTyxDQUVqQztBQUNBRCxRQUFRLEdBQUtBLFFBQVEsQ0FBR0QsUUFBUSxDQUFDLENBQ25DLENBRUE7QUFDQSxNQUFPSixPQUFNLENBQ2YsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvY29yZS9zcmMvYXBpL21ldGEudHM/NDlhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkZXRhaWxlZFR5cGVvZiwgbm9vcCB9IGZyb20gJy4uL3V0aWxzL2dlbmVyYWwnXG5pbXBvcnQgeyBBY3Rpb24sIEFjdGlvbkNoYWluLCBBY3Rpb25NZXRhIH0gZnJvbSAnLi4vdHlwZXMnXG5cbmNvbnN0IGFzc2VydEFjdGlvbkV4aXN0cyA9IERFVlxuICA/IChhY3Rpb246IEFjdGlvbkNoYWluKSA9PiB7XG4gICAgICBpZiAoYWN0aW9uKSByZXR1cm5cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWmVkdXg6IEludmFsaWQgYWN0aW9uIGNoYWluLiBUaGUgbGFzdCBub2RlIGluIHRoZSBjaGFpbiBtdXN0IGJlIGVpdGhlciBhIHZhbGlkIGFjdGlvbiBvYmplY3Qgd2l0aCBhIG5vbi1lbXB0eSBcInR5cGVcIiBwcm9wZXJ0eSBvciBhbiBlZmZlY3Qgd2l0aCBhIG5vbi1lbXB0eSBcImVmZmVjdFR5cGVcIiBwcm9wZXJ0eS4gUmVjZWl2ZWQgJHtkZXRhaWxlZFR5cGVvZihcbiAgICAgICAgICBhY3Rpb25cbiAgICAgICAgKX1gXG4gICAgICApXG4gICAgfVxuICA6IG5vb3BcblxuY29uc3QgZ2V0TmV3Um9vdCA9IDxUIGV4dGVuZHMgQWN0aW9uQ2hhaW4+KFxuICBjdXJyZW50Tm9kZTogVCxcbiAgcHJldk5vZGU6IFQgfCBudWxsLFxuICByb290Tm9kZTogVCB8IG51bGxcbik6IFQgPT4ge1xuICAvLyBJZiB0aGUgbWF0Y2ggaXMgYXQgdGhlIHRvcCBsYXllciwganVzdCByZXR1cm4gdGhlIG5leHQgbGF5ZXJcbiAgaWYgKCFwcmV2Tm9kZSB8fCAhcm9vdE5vZGUpIHJldHVybiBjdXJyZW50Tm9kZS5wYXlsb2FkXG5cbiAgLy8gSWYgdGhlIG1hdGNoIGlzIGF0IGxlYXN0IG9uZSBsYXllciBkZWVwLCBzd2FwIG91dCB0aGUgdGFyZ2V0IGxheWVyXG4gIC8vIGFuZCByZXR1cm4gdGhlIG5ldyByb290IG9mIHRoZSBhY3Rpb24gY2hhaW5cbiAgcHJldk5vZGUucGF5bG9hZCA9IGN1cnJlbnROb2RlLnBheWxvYWRcblxuICByZXR1cm4gcm9vdE5vZGVcbn1cblxuLyoqXG4gKiBBZGRzIGEgbWV0YSBub2RlIG9mIHRoZSBnaXZlbiBtZXRhVHlwZSBhbmQgd2l0aCB0aGUgZ2l2ZW4gbWV0YURhdGEgYXQgdGhlXG4gKiBiZWdpbm5pbmcgb2YgYW4gQWN0aW9uQ2hhaW5cbiAqL1xuZXhwb3J0IGNvbnN0IGFkZE1ldGEgPSAoXG4gIGFjdGlvbjogQWN0aW9uQ2hhaW4sXG4gIG1ldGFUeXBlOiBzdHJpbmcsXG4gIG1ldGFEYXRhPzogYW55XG4pID0+IHtcbiAgY29uc3Qgd3JhcHBlZEFjdGlvbjogQWN0aW9uTWV0YSA9IHtcbiAgICBtZXRhVHlwZSxcbiAgICBwYXlsb2FkOiBhY3Rpb24sXG4gIH1cblxuICBpZiAobWV0YURhdGEpIHdyYXBwZWRBY3Rpb24ubWV0YURhdGEgPSBtZXRhRGF0YVxuXG4gIHJldHVybiB3cmFwcGVkQWN0aW9uXG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIG1ldGFEYXRhIGZpZWxkIG9mIHRoZSBmaXJzdCBBY3Rpb25NZXRhIG9iamVjdCBpbiB0aGVcbiAqIGNoYWluIHdpdGggdGhlIGdpdmVuIG1ldGFUeXBlLlxuICovXG5leHBvcnQgY29uc3QgZ2V0TWV0YURhdGEgPSAoYWN0aW9uOiBBY3Rpb25DaGFpbiwgbWV0YVR5cGU6IHN0cmluZykgPT4ge1xuICB3aGlsZSAoKGFjdGlvbiBhcyBBY3Rpb25NZXRhKS5tZXRhVHlwZSkge1xuICAgIGlmICgoYWN0aW9uIGFzIEFjdGlvbk1ldGEpLm1ldGFUeXBlID09PSBtZXRhVHlwZSkge1xuICAgICAgcmV0dXJuIChhY3Rpb24gYXMgQWN0aW9uTWV0YSkubWV0YURhdGFcbiAgICB9XG5cbiAgICBhY3Rpb24gPSBhY3Rpb24ucGF5bG9hZFxuXG4gICAgaWYgKERFVikge1xuICAgICAgYXNzZXJ0QWN0aW9uRXhpc3RzKGFjdGlvbilcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIEFjdGlvbkNoYWluIGNvbnRhaW5zIGFuIEFjdGlvbk1ldGEgbm9kZSB3aXRoIHRoZVxuICogZ2l2ZW4gbWV0YVR5cGUuXG4gKi9cbmV4cG9ydCBjb25zdCBoYXNNZXRhID0gKGFjdGlvbjogQWN0aW9uQ2hhaW4sIG1ldGFUeXBlOiBzdHJpbmcpID0+IHtcbiAgd2hpbGUgKChhY3Rpb24gYXMgQWN0aW9uTWV0YSkubWV0YVR5cGUpIHtcbiAgICBpZiAoKGFjdGlvbiBhcyBBY3Rpb25NZXRhKS5tZXRhVHlwZSA9PT0gbWV0YVR5cGUpIHJldHVybiB0cnVlXG5cbiAgICBhY3Rpb24gPSBhY3Rpb24ucGF5bG9hZFxuXG4gICAgaWYgKERFVikge1xuICAgICAgYXNzZXJ0QWN0aW9uRXhpc3RzKGFjdGlvbilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBTdHJpcHMgYWxsIEFjdGlvbk1ldGEgbm9kZXMgb2ZmIGFuIEFjdGlvbkNoYWluIGFuZCByZXR1cm5zIHRoZSB3cmFwcGVkIEFjdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlQWxsTWV0YSA9IChhY3Rpb246IEFjdGlvbkNoYWluKSA9PiB7XG4gIHdoaWxlICgoYWN0aW9uIGFzIEFjdGlvbk1ldGEpLm1ldGFUeXBlKSB7XG4gICAgYWN0aW9uID0gYWN0aW9uLnBheWxvYWRcblxuICAgIGlmIChERVYpIHtcbiAgICAgIGFzc2VydEFjdGlvbkV4aXN0cyhhY3Rpb24pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGFjdGlvbiBhcyBBY3Rpb25cbn1cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBmaXJzdCBmb3VuZCBtZXRhIG5vZGUgd2l0aCB0aGUgZ2l2ZW4gbWV0YVR5cGUgaW4gdGhlIGdpdmVuIGFjdGlvblxuICogY2hhaW4uXG4gKlxuICogVGhlIG1ldGFUeXBlIGRvZXMgbm90IGhhdmUgdG8gZXhpc3QgaW4gdGhlIGFjdGlvbiBjaGFpbiAodGhvdWdoIHRoaXMnbGwgYmVcbiAqIHByZXR0eSBpbmVmZmljaWVudCBhbmQgd2FzdGVmdWwgaWYgaXQgZG9lc24ndCkuXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVNZXRhID0gKGFjdGlvbjogQWN0aW9uQ2hhaW4sIG1ldGFUeXBlOiBzdHJpbmcpID0+IHtcbiAgbGV0IGN1cnJlbnROb2RlID0gYWN0aW9uXG4gIGxldCBwcmV2Tm9kZSA9IG51bGxcbiAgbGV0IHJvb3ROb2RlID0gbnVsbFxuXG4gIHdoaWxlICgoY3VycmVudE5vZGUgYXMgQWN0aW9uTWV0YSkubWV0YVR5cGUpIHtcbiAgICBpZiAoKGN1cnJlbnROb2RlIGFzIEFjdGlvbk1ldGEpLm1ldGFUeXBlID09PSBtZXRhVHlwZSkge1xuICAgICAgcmV0dXJuIGdldE5ld1Jvb3QoY3VycmVudE5vZGUsIHByZXZOb2RlLCByb290Tm9kZSlcbiAgICB9XG5cbiAgICAvLyBNb3ZlIGRvd24gdGhlIGNoYWluXG4gICAgY29uc3QgY2xvbmVkTm9kZSA9IHsgLi4uY3VycmVudE5vZGUgfVxuXG4gICAgcHJldk5vZGUgJiYgKHByZXZOb2RlLnBheWxvYWQgPSBjbG9uZWROb2RlKVxuXG4gICAgcHJldk5vZGUgPSBjbG9uZWROb2RlXG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXlsb2FkXG5cbiAgICAvLyBJZiB0aGlzIHdpbGwgYmUgdGhlIG5ldyByb290LCByZW1lbWJlciBpdFxuICAgIHJvb3ROb2RlIHx8IChyb290Tm9kZSA9IHByZXZOb2RlKVxuICB9XG5cbiAgLy8gTm8gbWF0Y2ggZm91bmQ7IHJldHVybiB0aGUgb3JpZ2luYWwgYWN0aW9uIGNoYWluXG4gIHJldHVybiBhY3Rpb25cbn1cbiJdLCJuYW1lcyI6WyJkZXRhaWxlZFR5cGVvZiIsIm5vb3AiLCJhc3NlcnRBY3Rpb25FeGlzdHMiLCJERVYiLCJhY3Rpb24iLCJFcnJvciIsImdldE5ld1Jvb3QiLCJjdXJyZW50Tm9kZSIsInByZXZOb2RlIiwicm9vdE5vZGUiLCJwYXlsb2FkIiwiYWRkTWV0YSIsIm1ldGFUeXBlIiwibWV0YURhdGEiLCJ3cmFwcGVkQWN0aW9uIiwiZ2V0TWV0YURhdGEiLCJoYXNNZXRhIiwicmVtb3ZlQWxsTWV0YSIsInJlbW92ZU1ldGEiLCJjbG9uZWROb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7159\n')},8487:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "IE": function() { return /* binding */ STORE_IDENTIFIER; },\n/* harmony export */   "PO": function() { return /* binding */ isPlainObject; },\n/* harmony export */   "_T": function() { return /* binding */ HierarchyType; },\n/* harmony export */   "px": function() { return /* binding */ detailedTypeof; }\n/* harmony export */ });\n/* unused harmony exports ARRAY, COMPLEX_OBJECT, NO_PROTOTYPE, NULL, PLAIN_OBJECT, observableSymbol, noop */\nvar ARRAY=\'array\';var COMPLEX_OBJECT=\'complex object\';var NO_PROTOTYPE=\'prototype-less object\';var NULL=\'null\';var PLAIN_OBJECT=\'object\';/**\n  Determines which kind of object an "object" is.\n\n  Objects can be prototype-less, complex, or plain.\n*/function getDetailedObjectType(value){var prototype=Object.getPrototypeOf(value);if(!prototype)return NO_PROTOTYPE;return Object.getPrototypeOf(prototype)?COMPLEX_OBJECT:PLAIN_OBJECT;}var HierarchyType;(function(HierarchyType){HierarchyType[HierarchyType["Branch"]=0]="Branch";HierarchyType[HierarchyType["Null"]=1]="Null";HierarchyType[HierarchyType["Reducer"]=2]="Reducer";HierarchyType[HierarchyType["Store"]=3]="Store";})(HierarchyType||(HierarchyType={}));var observableSymbol=typeof Symbol===\'function\'&&Symbol.observable||\'@@observable\';// Used to check if something is a Zedux store\nvar STORE_IDENTIFIER=Symbol.for(\'zedux.store\');/**\n  Returns a more informative description of value\'s type.\n\n  Used to give users helpful error messages that detail exactly why\n  their input was rejected, rather than ux nightmares like:\n\n  "expected a plain object, received object"\n*/function detailedTypeof(value){var valueType=typeof value;if(valueType!==\'object\')return valueType;if(!value)return NULL;if(Array.isArray(value))return ARRAY;return getDetailedObjectType(value);}/**\n  Checks whether value is a plain old object.\n\n  The object may originate from another realm or have its prototype\n  explicitly set to Object.prototype, but it may not have a null\n  prototype or prototype chain more than 1 layer deep.\n*/function isPlainObject(value){if(typeof value!==\'object\'||!value)return false;var prototype=Object.getPrototypeOf(value);if(!prototype)return false;// it was created with Object.create(null)\n// If the prototype chain is exactly 1 layer deep, it\'s likely a normal object\nreturn Object.getPrototypeOf(prototype)===null;}var noop=function noop(){};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQ4Ny5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQU8sR0FBTUEsTUFBSyxDQUFHLE9BQU8sQ0FDckIsR0FBTUMsZUFBYyxDQUFHLGdCQUFnQixDQUN2QyxHQUFNQyxhQUFZLENBQUcsdUJBQXVCLENBQzVDLEdBQU1DLEtBQUksQ0FBRyxNQUFNLENBQ25CLEdBQU1DLGFBQVksQ0FBRyxRQUFRLENBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFDQSxRQUFTQyxzQkFBcUIsQ0FBQ0MsS0FBVSxDQUFFLENBQ3pDLEdBQU1DLFVBQVMsQ0FBR0MsTUFBTSxDQUFDQyxjQUFjLENBQUNILEtBQUssQ0FBQyxDQUU5QyxHQUFJLENBQUNDLFNBQVMsQ0FBRSxNQUFPTCxhQUFZLENBRW5DLE1BQU9NLE9BQU0sQ0FBQ0MsY0FBYyxDQUFDRixTQUFTLENBQUMsQ0FBR04sY0FBYyxDQUFHRyxZQUFZLENBQ3pFLENBRU8sR0FBS00sY0FBYSxDQUt4QixVQUxXQSxhQUFhLEVBQWJBLGFBQWEsQ0FBYkEsYUFBYSx1QkFBYkEsYUFBYSxDQUFiQSxhQUFhLG1CQUFiQSxhQUFhLENBQWJBLGFBQWEseUJBQWJBLGFBQWEsQ0FBYkEsYUFBYSx3QkFBYkEsYUFBYSxHQUFiQSxhQUFhLE1BT2xCLEdBQU1DLGlCQUFnQixDQUMxQixNQUFPQyxPQUFNLEdBQUssVUFBVSxFQUFLQSxNQUFNLENBQVNDLFVBQVUsRUFBSyxjQUFjLENBRWhGO0FBQ08sR0FBTUMsaUJBQWdCLENBQUdGLE1BQU0sQ0FBQ0csR0FBRyxDQUFDLGFBQWEsQ0FBQyxDQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQ08sUUFBU0MsZUFBYyxDQUFDVixLQUFVLENBQUUsQ0FDekMsR0FBTVcsVUFBUyxDQUFHLE1BQU9YLE1BQUssQ0FFOUIsR0FBSVcsU0FBUyxHQUFLLFFBQVEsQ0FBRSxNQUFPQSxVQUFTLENBQzVDLEdBQUksQ0FBQ1gsS0FBSyxDQUFFLE1BQU9ILEtBQUksQ0FDdkIsR0FBSWUsS0FBSyxDQUFDQyxPQUFPLENBQUNiLEtBQUssQ0FBQyxDQUFFLE1BQU9OLE1BQUssQ0FFdEMsTUFBT0ssc0JBQXFCLENBQUNDLEtBQUssQ0FBQyxDQUNyQyxDQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQ08sUUFBU2MsY0FBYSxDQUFDZCxLQUFVLENBQUUsQ0FDeEMsR0FBSSxNQUFPQSxNQUFLLEdBQUssUUFBUSxFQUFJLENBQUNBLEtBQUssQ0FBRSxNQUFPLE1BQUssQ0FFckQsR0FBTUMsVUFBUyxDQUFHQyxNQUFNLENBQUNDLGNBQWMsQ0FBQ0gsS0FBSyxDQUFDLENBQzlDLEdBQUksQ0FBQ0MsU0FBUyxDQUFFLE1BQU8sTUFBSyxDQUFDO0FBRTdCO0FBQ0EsTUFBT0MsT0FBTSxDQUFDQyxjQUFjLENBQUNGLFNBQVMsQ0FBQyxHQUFLLElBQUksQ0FDbEQsQ0FFTyxHQUFNYyxLQUFJLENBQUcsUUFBUEEsS0FBSSxFQUFTLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvY29yZS9zcmMvdXRpbHMvZ2VuZXJhbC50cz81MTM3Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBBUlJBWSA9ICdhcnJheSdcbmV4cG9ydCBjb25zdCBDT01QTEVYX09CSkVDVCA9ICdjb21wbGV4IG9iamVjdCdcbmV4cG9ydCBjb25zdCBOT19QUk9UT1RZUEUgPSAncHJvdG90eXBlLWxlc3Mgb2JqZWN0J1xuZXhwb3J0IGNvbnN0IE5VTEwgPSAnbnVsbCdcbmV4cG9ydCBjb25zdCBQTEFJTl9PQkpFQ1QgPSAnb2JqZWN0J1xuXG4vKipcbiAgRGV0ZXJtaW5lcyB3aGljaCBraW5kIG9mIG9iamVjdCBhbiBcIm9iamVjdFwiIGlzLlxuXG4gIE9iamVjdHMgY2FuIGJlIHByb3RvdHlwZS1sZXNzLCBjb21wbGV4LCBvciBwbGFpbi5cbiovXG5mdW5jdGlvbiBnZXREZXRhaWxlZE9iamVjdFR5cGUodmFsdWU6IGFueSkge1xuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpXG5cbiAgaWYgKCFwcm90b3R5cGUpIHJldHVybiBOT19QUk9UT1RZUEVcblxuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvdHlwZSkgPyBDT01QTEVYX09CSkVDVCA6IFBMQUlOX09CSkVDVFxufVxuXG5leHBvcnQgZW51bSBIaWVyYXJjaHlUeXBlIHtcbiAgQnJhbmNoLFxuICBOdWxsLFxuICBSZWR1Y2VyLFxuICBTdG9yZSxcbn1cblxuZXhwb3J0IGNvbnN0IG9ic2VydmFibGVTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiAoU3ltYm9sIGFzIGFueSkub2JzZXJ2YWJsZSkgfHwgJ0BAb2JzZXJ2YWJsZSdcblxuLy8gVXNlZCB0byBjaGVjayBpZiBzb21ldGhpbmcgaXMgYSBaZWR1eCBzdG9yZVxuZXhwb3J0IGNvbnN0IFNUT1JFX0lERU5USUZJRVIgPSBTeW1ib2wuZm9yKCd6ZWR1eC5zdG9yZScpXG5cbi8qKlxuICBSZXR1cm5zIGEgbW9yZSBpbmZvcm1hdGl2ZSBkZXNjcmlwdGlvbiBvZiB2YWx1ZSdzIHR5cGUuXG5cbiAgVXNlZCB0byBnaXZlIHVzZXJzIGhlbHBmdWwgZXJyb3IgbWVzc2FnZXMgdGhhdCBkZXRhaWwgZXhhY3RseSB3aHlcbiAgdGhlaXIgaW5wdXQgd2FzIHJlamVjdGVkLCByYXRoZXIgdGhhbiB1eCBuaWdodG1hcmVzIGxpa2U6XG5cbiAgXCJleHBlY3RlZCBhIHBsYWluIG9iamVjdCwgcmVjZWl2ZWQgb2JqZWN0XCJcbiovXG5leHBvcnQgZnVuY3Rpb24gZGV0YWlsZWRUeXBlb2YodmFsdWU6IGFueSkge1xuICBjb25zdCB2YWx1ZVR5cGUgPSB0eXBlb2YgdmFsdWVcblxuICBpZiAodmFsdWVUeXBlICE9PSAnb2JqZWN0JykgcmV0dXJuIHZhbHVlVHlwZVxuICBpZiAoIXZhbHVlKSByZXR1cm4gTlVMTFxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiBBUlJBWVxuXG4gIHJldHVybiBnZXREZXRhaWxlZE9iamVjdFR5cGUodmFsdWUpXG59XG5cbi8qKlxuICBDaGVja3Mgd2hldGhlciB2YWx1ZSBpcyBhIHBsYWluIG9sZCBvYmplY3QuXG5cbiAgVGhlIG9iamVjdCBtYXkgb3JpZ2luYXRlIGZyb20gYW5vdGhlciByZWFsbSBvciBoYXZlIGl0cyBwcm90b3R5cGVcbiAgZXhwbGljaXRseSBzZXQgdG8gT2JqZWN0LnByb3RvdHlwZSwgYnV0IGl0IG1heSBub3QgaGF2ZSBhIG51bGxcbiAgcHJvdG90eXBlIG9yIHByb3RvdHlwZSBjaGFpbiBtb3JlIHRoYW4gMSBsYXllciBkZWVwLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlOiBhbnkpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcgfHwgIXZhbHVlKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpXG4gIGlmICghcHJvdG90eXBlKSByZXR1cm4gZmFsc2UgLy8gaXQgd2FzIGNyZWF0ZWQgd2l0aCBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgLy8gSWYgdGhlIHByb3RvdHlwZSBjaGFpbiBpcyBleGFjdGx5IDEgbGF5ZXIgZGVlcCwgaXQncyBsaWtlbHkgYSBub3JtYWwgb2JqZWN0XG4gIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG90eXBlKSA9PT0gbnVsbFxufVxuXG5leHBvcnQgY29uc3Qgbm9vcCA9ICgpID0+IHt9XG4iXSwibmFtZXMiOlsiQVJSQVkiLCJDT01QTEVYX09CSkVDVCIsIk5PX1BST1RPVFlQRSIsIk5VTEwiLCJQTEFJTl9PQkpFQ1QiLCJnZXREZXRhaWxlZE9iamVjdFR5cGUiLCJ2YWx1ZSIsInByb3RvdHlwZSIsIk9iamVjdCIsImdldFByb3RvdHlwZU9mIiwiSGllcmFyY2h5VHlwZSIsIm9ic2VydmFibGVTeW1ib2wiLCJTeW1ib2wiLCJvYnNlcnZhYmxlIiwiU1RPUkVfSURFTlRJRklFUiIsImZvciIsImRldGFpbGVkVHlwZW9mIiwidmFsdWVUeXBlIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNQbGFpbk9iamVjdCIsIm5vb3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///8487\n')},2448:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "u": function() { return /* binding */ AtomApi; }\n/* harmony export */ });\n/* harmony import */ var _zedux_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9283);\n/* harmony import */ var _zedux_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1694);\n/* harmony import */ var _zedux_react_utils_general__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(395);\nvar AtomApi=/*#__PURE__*/function(){function AtomApi(value){this.promise=undefined;this.value=value;this.store=(0,_zedux_core__WEBPACK_IMPORTED_MODULE_0__.is)(value,_zedux_core__WEBPACK_IMPORTED_MODULE_1__/* .Store */ .y)?value:undefined;if((0,_zedux_core__WEBPACK_IMPORTED_MODULE_0__.is)(value,AtomApi)){Object.assign(this,value);}}var _proto=AtomApi.prototype;_proto.addExports=function addExports(exports){if(!this.exports)this.exports=exports;else this.exports=Object.assign({},this.exports,exports);return this;};_proto.setExports=function setExports(exports){;this.exports=exports;return this;// for chaining\n};_proto.setPromise=function setPromise(promise){this.promise=promise;return this;// for chaining\n};_proto.setTtl=function setTtl(ttl){this.ttl=ttl;return this;// for chaining\n};return AtomApi;}();AtomApi.$$typeof=Symbol.for(_zedux_react_utils_general__WEBPACK_IMPORTED_MODULE_2__/* .prefix */ .O4+"/AtomApi");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQ0OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFJTyxHQUFNRyxRQUFPLHlCQWNsQixpQkFDRUMsS0FBMEUsQ0FDMUUsQ0FDQSxJQUFJLENBQUNDLE9BQU8sQ0FBR0MsU0FBd0IsQ0FDdkMsSUFBSSxDQUFDRixLQUFLLENBQUdBLEtBQTBCLENBQ3ZDLElBQUksQ0FBQ0csS0FBSyxDQUFJUCwrQ0FBRSxDQUFDSSxLQUFLLENBQUVILHVEQUFLLENBQUMsQ0FBR0csS0FBSyxDQUFHRSxTQUF1QixDQUVoRSxHQUFJTiwrQ0FBRSxDQUFDSSxLQUFLLENBQUVELE9BQU8sQ0FBQyxDQUFFLENBQ3RCSyxNQUFNLENBQUNDLE1BQU0sQ0FDWCxJQUFJLENBQ0pMLEtBQUssQ0FDTixDQUNILENBQ0YsQ0FBQyxvQ0FFTU0sVUFBVSxDQUFqQixvQkFDRUMsT0FBbUIsQ0FDMkMsQ0FDOUQsR0FBSSxDQUFDLElBQUksQ0FBQ0EsT0FBTyxDQUFFLElBQUksQ0FBQ0EsT0FBTyxDQUFHQSxPQUFjLEtBQzNDLEtBQUksQ0FBQ0EsT0FBTyxrQkFBUSxJQUFJLENBQUNBLE9BQU8sQ0FBS0EsT0FBTyxDQUFFLENBRW5ELE1BQU8sS0FBSSxDQUNiLENBQUMsUUFFTUMsVUFBVSxDQUFqQixvQkFDRUQsT0FBbUIsQ0FDaUMsQ0FDcEQsQ0FBRyxJQUFJLENBS0pBLE9BQU8sQ0FBR0EsT0FBTyxDQUVwQixNQUFRLEtBQUksQ0FLVjtBQUNKLENBQUMsUUFFTUUsVUFBVSxDQUFqQixvQkFDRVIsT0FBbUIsQ0FDNkIsQ0FDaEQsSUFBSSxDQUFDQSxPQUFPLENBQUlBLE9BQWtDLENBRWxELE1BQU8sS0FBSSxDQUFtRDtBQUNoRSxDQUFDLFFBRU1TLE1BQU0sQ0FBYixnQkFBY0MsR0FBOEMsQ0FBRSxDQUM1RCxJQUFJLENBQUNBLEdBQUcsQ0FBR0EsR0FBRyxDQUVkLE1BQU8sS0FBSSxDQUFDO0FBQ2QsQ0FBQyxvQkFwRVVaLE9BQU8sQ0FNSmEsUUFBUSxDQUFHQyxNQUFNLENBQUNDLEdBQUcsQ0FBSWhCLHdFQUFNLFlBQVciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9jbGFzc2VzL0F0b21BcGkudHM/ZjJhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpcywgU3RvcmUgfSBmcm9tICdAemVkdXgvY29yZSdcbmltcG9ydCB7IEF0b21JbnN0YW5jZVR0bCwgQXRvbUFwaVByb21pc2UgfSBmcm9tICdAemVkdXgvcmVhY3QvdHlwZXMnXG5pbXBvcnQgeyBwcmVmaXggfSBmcm9tICdAemVkdXgvcmVhY3QvdXRpbHMvZ2VuZXJhbCdcblxuZXhwb3J0IGNsYXNzIEF0b21BcGk8XG4gIFN0YXRlLFxuICBFeHBvcnRzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PixcbiAgU3RvcmVUeXBlIGV4dGVuZHMgU3RvcmU8U3RhdGU+IHwgdW5kZWZpbmVkLFxuICBQcm9taXNlVHlwZSBleHRlbmRzIEF0b21BcGlQcm9taXNlXG4+IHtcbiAgcHVibGljIHN0YXRpYyAkJHR5cGVvZiA9IFN5bWJvbC5mb3IoYCR7cHJlZml4fS9BdG9tQXBpYClcblxuICBwdWJsaWMgZXhwb3J0cz86IEV4cG9ydHNcbiAgcHVibGljIHByb21pc2U6IFByb21pc2VUeXBlXG4gIHB1YmxpYyBzdG9yZTogU3RvcmVUeXBlXG4gIHB1YmxpYyB0dGw/OiBBdG9tSW5zdGFuY2VUdGwgfCAoKCkgPT4gQXRvbUluc3RhbmNlVHRsKVxuICBwdWJsaWMgdmFsdWU6IFN0YXRlIHwgU3RvcmVUeXBlXG5cbiAgY29uc3RydWN0b3IoXG4gICAgdmFsdWU6IEF0b21BcGk8U3RhdGUsIEV4cG9ydHMsIFN0b3JlVHlwZSwgUHJvbWlzZVR5cGU+IHwgU3RvcmVUeXBlIHwgU3RhdGVcbiAgKSB7XG4gICAgdGhpcy5wcm9taXNlID0gdW5kZWZpbmVkIGFzIFByb21pc2VUeXBlXG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlIGFzIFN0b3JlVHlwZSB8IFN0YXRlXG4gICAgdGhpcy5zdG9yZSA9IChpcyh2YWx1ZSwgU3RvcmUpID8gdmFsdWUgOiB1bmRlZmluZWQpIGFzIFN0b3JlVHlwZVxuXG4gICAgaWYgKGlzKHZhbHVlLCBBdG9tQXBpKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdmFsdWUgYXMgQXRvbUFwaTxTdGF0ZSwgRXhwb3J0cywgU3RvcmVUeXBlLCBQcm9taXNlVHlwZT5cbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYWRkRXhwb3J0czxOZXdFeHBvcnRzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4oXG4gICAgZXhwb3J0czogTmV3RXhwb3J0c1xuICApOiBBdG9tQXBpPFN0YXRlLCBFeHBvcnRzICYgTmV3RXhwb3J0cywgU3RvcmVUeXBlLCBQcm9taXNlVHlwZT4ge1xuICAgIGlmICghdGhpcy5leHBvcnRzKSB0aGlzLmV4cG9ydHMgPSBleHBvcnRzIGFzIGFueVxuICAgIGVsc2UgdGhpcy5leHBvcnRzID0geyAuLi50aGlzLmV4cG9ydHMsIC4uLmV4cG9ydHMgfVxuXG4gICAgcmV0dXJuIHRoaXMgYXMgQXRvbUFwaTxTdGF0ZSwgRXhwb3J0cyAmIE5ld0V4cG9ydHMsIFN0b3JlVHlwZSwgUHJvbWlzZVR5cGU+XG4gIH1cblxuICBwdWJsaWMgc2V0RXhwb3J0czxOZXdFeHBvcnRzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55Pj4oXG4gICAgZXhwb3J0czogTmV3RXhwb3J0c1xuICApOiBBdG9tQXBpPFN0YXRlLCBOZXdFeHBvcnRzLCBTdG9yZVR5cGUsIFByb21pc2VUeXBlPiB7XG4gICAgOygodGhpcyBhcyB1bmtub3duKSBhcyBBdG9tQXBpPFxuICAgICAgU3RhdGUsXG4gICAgICBOZXdFeHBvcnRzLFxuICAgICAgU3RvcmVUeXBlLFxuICAgICAgUHJvbWlzZVR5cGVcbiAgICA+KS5leHBvcnRzID0gZXhwb3J0c1xuXG4gICAgcmV0dXJuICh0aGlzIGFzIHVua25vd24pIGFzIEF0b21BcGk8XG4gICAgICBTdGF0ZSxcbiAgICAgIE5ld0V4cG9ydHMsXG4gICAgICBTdG9yZVR5cGUsXG4gICAgICBQcm9taXNlVHlwZVxuICAgID4gLy8gZm9yIGNoYWluaW5nXG4gIH1cblxuICBwdWJsaWMgc2V0UHJvbWlzZTxUPihcbiAgICBwcm9taXNlOiBQcm9taXNlPFQ+XG4gICk6IEF0b21BcGk8U3RhdGUsIEV4cG9ydHMsIFN0b3JlVHlwZSwgUHJvbWlzZTxUPj4ge1xuICAgIHRoaXMucHJvbWlzZSA9IChwcm9taXNlIGFzIHVua25vd24pIGFzIFByb21pc2VUeXBlXG5cbiAgICByZXR1cm4gdGhpcyBhcyBBdG9tQXBpPFN0YXRlLCBFeHBvcnRzLCBTdG9yZVR5cGUsIFByb21pc2U8VD4+IC8vIGZvciBjaGFpbmluZ1xuICB9XG5cbiAgcHVibGljIHNldFR0bCh0dGw6IEF0b21JbnN0YW5jZVR0bCB8ICgoKSA9PiBBdG9tSW5zdGFuY2VUdGwpKSB7XG4gICAgdGhpcy50dGwgPSB0dGxcblxuICAgIHJldHVybiB0aGlzIC8vIGZvciBjaGFpbmluZ1xuICB9XG59XG4iXSwibmFtZXMiOlsiaXMiLCJTdG9yZSIsInByZWZpeCIsIkF0b21BcGkiLCJ2YWx1ZSIsInByb21pc2UiLCJ1bmRlZmluZWQiLCJzdG9yZSIsIk9iamVjdCIsImFzc2lnbiIsImFkZEV4cG9ydHMiLCJleHBvcnRzIiwic2V0RXhwb3J0cyIsInNldFByb21pc2UiLCJzZXRUdGwiLCJ0dGwiLCIkJHR5cGVvZiIsIlN5bWJvbCIsImZvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2448\n')},5092:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"q\": function() { return /* binding */ Ecosystem; }\n});\n\n// EXTERNAL MODULE: ../packages/core/src/api/createStore.ts + 4 modules\nvar createStore = __webpack_require__(1694);\n// EXTERNAL MODULE: ../packages/core/src/api/is.ts\nvar is = __webpack_require__(9283);\n// EXTERNAL MODULE: ./node_modules/react/index.js\nvar react = __webpack_require__(7294);\n// EXTERNAL MODULE: ../packages/react/src/store/index.ts\nvar store = __webpack_require__(825);\n// EXTERNAL MODULE: ../packages/react/src/utils/general.ts\nvar general = __webpack_require__(395);\n// EXTERNAL MODULE: ../packages/react/src/utils/plugin-actions.ts\nvar plugin_actions = __webpack_require__(3299);\n// EXTERNAL MODULE: ../packages/react/src/classes/EvaluationStack.ts\nvar EvaluationStack = __webpack_require__(2633);\n;// CONCATENATED MODULE: ../packages/react/src/classes/Graph.ts\nvar Graph=/*#__PURE__*/function(){function Graph(ecosystem){this.nodes={};this.updateStack=[];this.ecosystem=ecosystem;}/**\n   * Draw a new edge between two nodes in the graph. This is how dependencies\n   * are created between atoms, selectors, and external nodes like React\n   * components.\n   */var _proto=Graph.prototype;_proto.addEdge=function addEdge(dependentKey,dependencyKey,operation,flags,callback){var newEdge={callback:callback,createdAt:Date.now(),flags:flags,operation:operation};if(!this.updateStack.length){return this.finishAddingEdge(dependentKey,dependencyKey,newEdge);}// We're buffering updates! Buffer this one\nvar _this$updateStack=this.updateStack[this.updateStack.length-1],dependencies=_this$updateStack.dependencies,key=_this$updateStack.key;if( true&&key!==dependentKey){throw new Error(\"Zedux: Tried updating dependencies of a graph node that isn't currently evaluating. This means that either you tried updating the graph manually or there is a bug in Zedux. If it's a bug, please report it!\");}var dependency=dependencies[dependencyKey];// Don't overwrite a higher-prio edge with a lower one. Also ignore same-prio\nif(!dependency||dependency.flags>flags){dependencies[dependencyKey]=newEdge;return newEdge;}// if this edge was ignored, return the existing buffered edge\nreturn dependencies[dependencyKey];}// Should only be used internally\n;_proto.addNode=function addNode(nodeKey,isAtomSelector){if(this.nodes[nodeKey])return;// already added\nthis.nodes[nodeKey]={dependencies:{},dependents:{},isAtomSelector:isAtomSelector,weight:1// this node doesn't have dependencies yet; it's weight is 1\n};}/**\n   * Prevent new graph edges from being added immediately. Instead, buffer them\n   * so we can prevent duplicates or unnecessary edges. Call `.flushUpdates()`\n   * to finish buffering.\n   *\n   * This is used during atom and AtomSelector evaluation to make the graph as\n   * efficient as possible.\n   */;_proto.bufferUpdates=function bufferUpdates(key){this.updateStack.push({key:key,dependencies:{}});}/**\n   * If an atom instance or AtomSelector errors during evaluation, we need to\n   * destroy any instances or AtomSelectors created during that evaluation that\n   * now have no dependents.\n   */;_proto.destroyBuffer=function destroyBuffer(){var _this=this;var _this$updateStack2=this.updateStack[this.updateStack.length-1],dependencies=_this$updateStack2.dependencies,key=_this$updateStack2.key;var edges=this.nodes[key].dependencies;Object.keys(dependencies).forEach(function(dependencyKey){var existingEdge=edges[dependencyKey];// the edge wasn't created during the evaluation that errored; keep it\nif(existingEdge)return;_this.scheduleNodeDestruction(dependencyKey);});this.updateStack.pop();}/**\n   * Stop buffering updates for the node passed to `.bufferUpdates()` and add\n   * the buffered edges to the graph.\n   */;_proto.flushUpdates=function flushUpdates(){var _this2=this;var _this$updateStack3=this.updateStack[this.updateStack.length-1],dependencies=_this$updateStack3.dependencies,key=_this$updateStack3.key;var edges=this.nodes[key].dependencies;// remove any edges that were not recreated while buffering. Don't remove\n// anything but implicit-internal edges (those are the only kind we\n// auto-create during evaluation - other types may have been added manually\n// by the user and we don't want to touch them here)\nObject.keys(edges).forEach(function(dependencyKey){var existingEdge=_this2.nodes[dependencyKey].dependents[key];if(existingEdge.flags&(general/* Explicit */.Jy|general/* External */.RQ))return;var edgeToAdd=dependencies[dependencyKey];// edge still exists; keep it\nif(edgeToAdd&&edgeToAdd.flags===existingEdge.flags)return;_this2.removeEdge(key,dependencyKey);});// add new edges that we tracked while buffering\nObject.keys(dependencies).forEach(function(dependencyKey){var edgeToAdd=dependencies[dependencyKey];var existingEdge=edges[dependencyKey];// edge already exists; keep it\nif(existingEdge)return;_this2.finishAddingEdge(key,dependencyKey,edgeToAdd);});this.updateStack.pop();};_proto.getRefCount=function getRefCount(dependencyKey){var _this$nodes$dependenc;return Object.keys(((_this$nodes$dependenc=this.nodes[dependencyKey])==null?void 0:_this$nodes$dependenc.dependents)||{}).length;};_proto.removeDependencies=function removeDependencies(dependentKey){var _this3=this;var node=this.nodes[dependentKey];if(!node)return;// node already destroyed\nvar edges=node.dependencies;if(!edges)return;Object.keys(edges).forEach(function(dependencyKey){_this3.removeEdge(dependentKey,dependencyKey);});}/**\n   * Should only be used internally. Remove the graph edge between two nodes.\n   * The dependent may not exist as a node in the graph if it's external, e.g. a\n   * React component\n   *\n   * For some reason in React 18+, React destroys parents before children. This\n   * means a parent EcosystemProvider may have already unmounted and wiped the\n   * whole graph; this edge may already be destroyed.\n   */;_proto.removeEdge=function removeEdge(dependentKey,dependencyKey){var dependency=this.nodes[dependencyKey];var dependent=this.nodes[dependentKey];// won't exist if external\n// erase graph edge between dependent and dependency\nif(dependent){delete dependent.dependencies[dependencyKey];}// hmm could maybe happen when a dependency was force-destroyed if a child\n// tries to destroy its edge before recreating it (I don't think we ever do\n// that though)\nif(!dependency)return;var dependentEdge=dependency.dependents[dependentKey];// happens in React 18+ (see this method's jsdoc above)\nif(!dependentEdge)return;delete dependency.dependents[dependentKey];// static dependencies don't change a node's weight\nif(!(dependentEdge.flags&general/* Static */.qG)){this.recalculateNodeWeight(dependentKey,-dependency.weight);}if(dependentEdge.task){this.ecosystem._scheduler.unschedule(dependentEdge.task);}if(this.ecosystem._mods.edgeRemoved){this.ecosystem.modBus.dispatch(plugin_actions/* pluginActions.edgeRemoved */.V.edgeRemoved({dependency:this.ecosystem._instances[dependencyKey]||this.ecosystem.selectorCache._items[dependencyKey],dependent:this.ecosystem._instances[dependentKey]||this.ecosystem.selectorCache._items[dependentKey]||dependentKey,edge:dependentEdge}));}this.scheduleNodeDestruction(dependencyKey);}// Should only be used internally\n;_proto.removeNode=function removeNode(nodeKey){var _this4=this;var node=this.nodes[nodeKey];if(!node)return;// already removed\n// We don't need to remove this dependent from its dependencies here - the\n// atom instance/AtomSelector will have removed all its deps before calling\n// this function as part of its destruction process\n// if an atom instance is force-destroyed, it could still have dependents.\n// Inform them of the destruction\nthis.scheduleDependents(nodeKey,[],undefined,undefined,true,'node destroyed','Destroyed',true);// Remove this dependency from all its dependents and recalculate all\n// weights recursively\nObject.keys(node.dependents).forEach(function(dependentKey){var dependentEdge=node.dependents[dependentKey];if(!(dependentEdge.flags&general/* Static */.qG)){_this4.recalculateNodeWeight(dependentKey,-node.weight);}var dependentNode=_this4.nodes[dependentKey];if(dependentNode)delete dependentNode.dependencies[nodeKey];});delete this.nodes[nodeKey];}/**\n   * Schedules a job to update all dependents of a node. This is called e.g.\n   * when an atom instance or AtomSelector updates, when an atom instance is\n   * force-destroyed, or when an atom instance's promise changes.\n   */;_proto.scheduleDependents=function scheduleDependents(nodeKey,reasons,newState,oldState,shouldSetTimeout,type,signal,scheduleStaticDeps){var _this5=this;if(type===void 0){type='state changed';}if(signal===void 0){signal='Updated';}if(scheduleStaticDeps===void 0){scheduleStaticDeps=false;}var instance=this.ecosystem._instances[nodeKey];var cache=this.ecosystem.selectorCache._items[nodeKey];var node=this.nodes[nodeKey];Object.keys(node.dependents).forEach(function(dependentKey){var dependentEdge=node.dependents[dependentKey];// if edge.task exists, this edge has already been scheduled\nif(dependentEdge.task){if(signal!=='Destroyed')return;// destruction jobs supersede update jobs; cancel the existing job so we\n// can create a new one for the destruction\n_this5.ecosystem._scheduler.unschedule(dependentEdge.task);}// Static deps don't update on state change. Dynamic deps don't update on\n// promise change. Both types update on instance force-destruction\nvar isStatic=dependentEdge.flags&general/* Static */.qG;if(isStatic&&!scheduleStaticDeps)return;var reason={newState:newState,oldState:oldState,operation:dependentEdge.operation,reasons:reasons,sourceKey:nodeKey,sourceType:node.isAtomSelector?'AtomSelector':'Atom',type:type};// let internal dependents (other atoms and AtomSelectors) schedule their\n// own jobs\nif(!(dependentEdge.flags&general/* External */.RQ)){if(_this5.nodes[dependentKey].isAtomSelector){return _this5.ecosystem.selectorCache._scheduleEvaluation(dependentKey,reason,shouldSetTimeout);}return _this5.ecosystem._instances[dependentKey]._scheduleEvaluation(reason,shouldSetTimeout);}// schedule external dependents\nvar task=function task(){dependentEdge.task=undefined;dependentEdge.callback==null?void 0:dependentEdge.callback(signal,instance?instance.store.getState():cache.result,// don't use the snapshotted newState above\nreason);};_this5.ecosystem._scheduler.schedule({flags:dependentEdge.flags,task:task,type:3// UpdateExternalDependent (3)\n},shouldSetTimeout);// mutate the edge; give it the scheduled task so it can be cleaned up\ndependentEdge.task=task;});}/**\n   * Actually add an edge to the graph. When we buffer graph updates, we're\n   * really just deferring the calling of this method.\n   */;_proto.finishAddingEdge=function finishAddingEdge(dependentKey,dependencyKey,newEdge){var dependency=this.nodes[dependencyKey];if(!dependency)return;// happened once for some reason\n// draw graph edge between dependent and dependency\nif(!(newEdge.flags&general/* External */.RQ)){this.nodes[dependentKey].dependencies[dependencyKey]=true;}dependency.dependents[dependentKey]=newEdge;this.unscheduleNodeDestruction(dependencyKey);// static dependencies don't change a node's weight\nif(!(newEdge.flags&general/* Static */.qG)){this.recalculateNodeWeight(dependentKey,dependency.weight);}if(this.ecosystem._mods.edgeCreated){this.ecosystem.modBus.dispatch(plugin_actions/* pluginActions.edgeCreated */.V.edgeCreated({dependency:this.ecosystem._instances[dependencyKey]||this.ecosystem.selectorCache._items[dependencyKey],dependent:this.ecosystem._instances[dependentKey]||this.ecosystem.selectorCache._items[dependentKey]||dependentKey,// unfortunate but not changing for now UPDATE: shouldn't be needed anymore. Double check\nedge:newEdge}));}return newEdge;}/**\n   * When a non-static edge is added or removed, every node below that edge (the\n   * dependent, its dependents, etc) in the graph needs to have its weight\n   * recalculated.\n   */;_proto.recalculateNodeWeight=function recalculateNodeWeight(nodeKey,weightDiff){var _this6=this;var node=this.nodes[nodeKey];if(!node)return;// happens when node is external\nnode.weight+=weightDiff;Object.keys(node.dependents).forEach(function(dependentKey){_this6.recalculateNodeWeight(dependentKey,weightDiff);});}/**\n   * When a node's refCount hits 0, schedule destruction of that node.\n   */;_proto.scheduleNodeDestruction=function scheduleNodeDestruction(nodeKey){var node=this.nodes[nodeKey];if(node&&!Object.keys(node.dependents).length){if(node.isAtomSelector){this.ecosystem.selectorCache._destroySelector(nodeKey);}else{this.ecosystem._instances[nodeKey]._scheduleDestruction();}}}/**\n   * When a node's refCount hits 0, we schedule destruction of that node. If\n   * that destruction is still pending and the refCount goes back up to 1,\n   * cancel the scheduled destruction.\n   */;_proto.unscheduleNodeDestruction=function unscheduleNodeDestruction(nodeKey){var dependency=this.nodes[nodeKey];if(!dependency.isAtomSelector&&Object.keys(dependency.dependents).length===1){var instance=this.ecosystem._instances[nodeKey];instance._cancelDestruction==null?void 0:instance._cancelDestruction();}};return Graph;}();\n// EXTERNAL MODULE: ../packages/core/src/utils/general.ts\nvar utils_general = __webpack_require__(8487);\n// EXTERNAL MODULE: ../packages/react/src/classes/instances/AtomInstanceBase.ts\nvar AtomInstanceBase = __webpack_require__(4987);\n;// CONCATENATED MODULE: ../packages/react/src/classes/IdGenerator.ts\n/**\n * When using SSR, only `generateNodeId` should be allowed to run. It is okay\n * for `generateAtomSelectorId` to run, but auto-id'd selectors won't be\n * hydratable on the client (usually fine for inline selectors). Ecosystem ids\n * must be set manually\n *\n * To prevent Zedux from auto-id'ing AtomSelectors, use a shared function\n * reference. When using AtomSelectorConfig objects, make sure the object\n * reference itself is shared. In both cases, the function must have a unique\n * name.\n *\n * ```ts\n * // examples that will be auto-id'd:\n * useAtomSelector(({ get }) => get(myAtom)) // inline function ref can't be shared and has no name\n * const mySelector = { // this object reference can be shared...\n *   selector: ({ get }) => get(myAtom) // ...but the function has a generic name\n * }\n *\n * // examples where ids will be generated predictably based on params:\n * const mySelector = ({ get }) => get(myAtom) // function has a name and ref can be shared\n * const mySelector = { // this ref can be shared...\n *   selector: function mySelector({ get }) { // ...and the function has a name\n *     return get(myAtom)\n *   }\n * }\n * const mySelector = { // this ref can be shared...\n *   name: 'mySelector', // ...and we set the `name` config option\n *   selector: ({ get }) => get(myAtom)\n * }\n * ```\n */var IdGenerator=/*#__PURE__*/function(){function IdGenerator(){var _this=this;this.idCounter=0;this.weakCache=new WeakMap();this.generateId=function(prefix){return prefix+\"-\"+ ++_this.idCounter+Math.random().toString(16).slice(2,14);};}var _proto=IdGenerator.prototype;_proto.generateAtomSelectorId=function generateAtomSelectorId(name){if(name===void 0){name='';}if(!name){name= true?'unknownSelector':0;}return this.generateId(\"@@selector-\"+name);};_proto.generateEcosystemId=function generateEcosystemId(){return this.generateId('es');};_proto.generateNodeId=function generateNodeId(){return this.generateId('no');}/**\n   * Generate a graph node key for a React component\n   */;_proto.generateReactComponentId=function generateReactComponentId(){var _lines$find;if(false){}var _Error=new Error(),stack=_Error.stack;if(!stack)return'';var lines=stack.split('\\n').slice(2).map(function(line){return line.trim().replace('at ','').replace(/ \\(.*\\)/,'');});var componentName=(_lines$find=lines.find(function(line){if(!/\\w/.test(line[0]))return false;var identifiers=line.split('.');var fn=identifiers[identifiers.length-1];return fn[0].toUpperCase()===fn[0];}))==null?void 0:_lines$find.split(' ')[0];return this.generateId(componentName||'UnknownComponent');}/**\n   * Turn an array of anything into a predictable string. If any item is an atom\n   * instance, it will be serialized as the instance's keyHash. If\n   * acceptComplexParams is true, map class instances and functions to a\n   * consistent id for the reference.\n   *\n   * Note that recursive objects are not supported - they would add way too much\n   * overhead here and are really just unnecessary.\n   */;_proto.hashParams=function hashParams(params,acceptComplexParams){var _this2=this;return JSON.stringify(params,function(_,param){if((0,is.is)(param,AtomInstanceBase/* AtomInstanceBase */.T))return param.keyHash;if(!param)return param;if(!(0,utils_general/* isPlainObject */.PO)(param)){if(!acceptComplexParams||Array.isArray(param))return param;if(typeof param==='function')return _this2.cacheFn(param);if(typeof(param==null?void 0:param.constructor)==='function'){return _this2.cacheClass(param);}return param;// let engine try resolve it or throw the error\n}return Object.keys(param).sort().reduce(function(result,key){result[key]=param[key];return result;},{});});};_proto.cacheClass=function cacheClass(instance){var id=this.weakCache.get(instance);if(id)return id;id=this.generateId(instance.constructor.name||'UnknownClass');this.weakCache.set(instance,id);return id;};_proto.cacheFn=function cacheFn(fn){var id=this.weakCache.get(fn);if(id)return id;id=this.generateId(fn.name||'anonFn');this.weakCache.set(fn,id);return id;};return IdGenerator;}();\n;// CONCATENATED MODULE: ../packages/react/src/classes/Scheduler.ts\nvar Scheduler=/*#__PURE__*/function(){// private _runStartTime?: number\nfunction Scheduler(ecosystem){this.jobs=[];this.ecosystem=ecosystem;}/**\n   * Kill any current timeout and run all jobs immediately.\n   *\n   * IMPORTANT: Setting and clearing timeouts is expensive. We need to always\n   * pass `shouldSetTimeout: false` to scheduler.schedule() when we're going\n   * to immediately flush\n   */var _proto=Scheduler.prototype;_proto.flush=function flush(){if(this._isRunning)return;// already flushing\nif(this._jobTimeoutId)clearTimeout(this._jobTimeoutId);this.runJobs();}/**\n   * Insert a job into the queue. Insertion point depends on job's type and\n   * weight.\n   *\n   * IMPORTANT: Setting and clearing timeouts is expensive. We need to always\n   * pass `shouldSetTimeout: false` when we're going to immediately flush\n   */;_proto.schedule=function schedule(newJob,shouldSetTimeout){if(shouldSetTimeout===void 0){shouldSetTimeout=true;}if(newJob.type===4){// RunEffect (4) jobs run in any order, after everything else\nthis.jobs.push(newJob);}else{var _newJob$flags;var nodes=this.ecosystem._graph.nodes;var flags=(_newJob$flags=newJob.flags)!=null?_newJob$flags:0;var weight=newJob.keyHash?nodes[newJob.keyHash].weight:0;var index=this.findIndex(function(job){if(job.type!==newJob.type)return+(newJob.type-job.type>0)||-1;// 1 or -1\n// a job type can use either weight or flags comparison or neither\nif(job.keyHash){var jobWeight=nodes[job.keyHash].weight;return weight<jobWeight?-1:+(weight>jobWeight);// + = 0 or 1\n}else if(job.flags!=null){return flags<job.flags?-1:+(flags>job.flags);}return 0;});if(index===-1){this.jobs.push(newJob);}else{this.jobs.splice(index,0,newJob);}}// we just pushed the first job onto the queue\nif(shouldSetTimeout&&this.jobs.length===1){this.setTimeout();}}/**\n   * Some jobs (update store jobs) must run immediately but also need the\n   * scheduler to be running.\n   *\n   * Other jobs (inform subscriber jobs) must run immediately after the current\n   * task. This is done by passing `false` for the 2nd param.\n   */;_proto.scheduleNow=function scheduleNow(newJob,runIfRunning){if(runIfRunning===void 0){runIfRunning=true;}if(this._isRunning===runIfRunning)return newJob.task();this.jobs.unshift(newJob);this.flush();};_proto.unschedule=function unschedule(task){var index=this.jobs.findIndex(function(job){return job.task===task;});if(index!==-1)this.jobs.splice(index,1);};_proto.wipe=function wipe(){// allow external jobs to proceed. TODO: should we flush here?\nthis.jobs=this.jobs.filter(function(job){return job.type===3;}// UpdateExternalDependent (3)\n);}// An O(log n) replacement for this.jobs.findIndex()\n;_proto.findIndex=function findIndex(cb,index,iteration){if(index===void 0){index=Math.ceil(this.jobs.length/2)-1;}if(iteration===void 0){iteration=1;}var job=this.jobs[index];if(job==null)return index;var direction=cb(job);if(!direction)return index;var divisor=Math.pow(2,iteration);var isDone=divisor>this.jobs.length;if(isDone){return index+(direction===1?1:0);}var effectualSize=Math.round(this.jobs.length/divisor);var newIndex=Math.min(this.jobs.length-1,Math.max(0,index+Math.ceil(effectualSize/2)*direction));return this.findIndex(cb,newIndex,iteration+1);};_proto.runJobs=function runJobs(){this._jobTimeoutId=undefined;// this._runStartTime = performance.now()\n// let counter = 0\nthis._isRunning=true;while(this.jobs.length){var job=this.jobs.shift();job.task();// this \"break\" idea would need to only break if the next job is\n// interruptible (store updates - the highest-prio tasks - are not\n// interruptible)\n// if (!(++counter % 20) && performance.now() - this._runStartTime >= 100) {\n//   setTimeout(() => this.runJobs())\n//   break\n// }\n}this._isRunning=false;};_proto.setTimeout=function(_setTimeout){function setTimeout(){return _setTimeout.apply(this,arguments);}setTimeout.toString=function(){return _setTimeout.toString();};return setTimeout;}(function(){var _this=this;if(this._isRunning)return;this._jobTimeoutId=setTimeout(function(){_this.runJobs();});});return Scheduler;}();\n;// CONCATENATED MODULE: ../packages/react/src/classes/SelectorCache.ts\nvar defaultResultsComparator=function defaultResultsComparator(a,b){return a===b;};var SelectorCacheItem=function SelectorCacheItem(cacheKey,selectorRef,args){this.nextEvaluationReasons=[];this.cacheKey=cacheKey;this.selectorRef=selectorRef;this.args=args;};/**\n * Since AtomSelectors are meant to feel lightweight, they don't have to be\n * instances of a class - they'll often be standalone or even inline\n * functions. This class handles all the logic that AtomSelectors would handle\n * themselves if they were classes - creation, cache management, and\n * destruction.\n */SelectorCacheItem.$$typeof=Symbol.for(general/* prefix */.O4+\"/SelectorCache\");var SelectorCache=/*#__PURE__*/function(){/**\n   * Map selectorKey+params keyHash strings to the cached params and result for\n   * the selector\n   */ /**\n   * Map selectors (or selector config objects) to a base selectorKey that can\n   * be used to predictably create selectorKey+params keyHashes to look up the\n   * cache in `this._items`\n   */function SelectorCache(ecosystem){this._items={};this._refBaseKeys=new WeakMap();this.ecosystem=ecosystem;}var _proto=SelectorCache.prototype;_proto.addDependent=function addDependent(cacheItem,_temp){var _this=this;var _ref=_temp===void 0?{}:_temp,callback=_ref.callback,_ref$operation=_ref.operation,operation=_ref$operation===void 0?'addDependent':_ref$operation;var id=this.ecosystem._idGenerator.generateNodeId();this.ecosystem._graph.addEdge(id,cacheItem.cacheKey,operation,general/* Explicit */.Jy|general/* External */.RQ,callback);return function(){return _this.ecosystem._graph.removeEdge(id,cacheItem.cacheKey);};};/**\n   * Destroys the cache for the given selector + args combo (if it exists).\n   *\n   * Destruction bails out by default if the selector's ref count is > 0. Pass\n   * `true` as the 3rd param to force destruction.\n   */_proto.destroyCache=function destroyCache(selectable,args,force){var cacheKey=(0,is.is)(selectable,SelectorCacheItem)?selectable.cacheKey:this.getCacheKey(selectable,args);var cache=(0,is.is)(selectable,SelectorCacheItem)?selectable:this._items[cacheKey];if(!cache)return;var node=this.ecosystem._graph.nodes[cacheKey];if(!force&&Object.keys((node==null?void 0:node.dependents)||{}).length)return;this._destroySelector(cacheKey);};/**\n   * Get the cached args and result for the given AtomSelector (or\n   * AtomSelectorConfig). Runs the selector, sets up the graph, and caches the\n   * initial value if this selector hasn't been cached before.\n   */_proto.getCache=function getCache(selectable,args){if(args===void 0){args=[];}if((0,is.is)(selectable,SelectorCacheItem)){return selectable;}var selectorOrConfig=selectable;var cacheKey=this.getCacheKey(selectorOrConfig,args);var cache=this._items[cacheKey];if(cache)return cache;// create the cache; it doesn't exist yet\ncache=new SelectorCacheItem(cacheKey,selectorOrConfig,args);this._items[cacheKey]=cache;this.ecosystem._graph.addNode(cacheKey,true);this.runSelector(cacheKey,args,true);return cache;};/**\n   * Get the fully qualified key hash for the given selector+params combo\n   */_proto.getCacheKey=function getCacheKey(selectorOrConfig,args,weak){var baseKey=this.getBaseKey(selectorOrConfig,weak);return args!=null&&args.length?baseKey+\"-\"+this.ecosystem._idGenerator.hashParams(args,this.ecosystem.complexParams):baseKey;}/**\n   * Get an object of all currently-cached AtomSelectors.\n   *\n   * Pass a selector reference or string to filter by caches whose cacheKey\n   * weakly matches the passed selector name.\n   */;_proto.inspectItems=function inspectItems(selectableOrName){var hash={};var filterKey=!selectableOrName||typeof selectableOrName==='string'?selectableOrName:(0,is.is)(selectableOrName,SelectorCacheItem)?selectableOrName.cacheKey:this.getBaseKey(selectableOrName,true)||this._getIdealCacheKey(selectableOrName);Object.values(this._items).sort(function(a,b){return a.cacheKey.localeCompare(b.cacheKey);}).forEach(function(instance){if(filterKey&&!instance.cacheKey.includes(filterKey)){return;}hash[instance.cacheKey]=instance;});return hash;}/**\n   * Get an object mapping all cacheKeys in this selectorCache to their current\n   * values.\n   *\n   * Pass an atom or atom key string to only return instances whose keyHash\n   * weakly matches the passed key.\n   */;_proto.inspectItemValues=function inspectItemValues(selectableOrName){var hash=this.inspectItems(selectableOrName);// We just created the object. Just mutate it.\nObject.keys(hash).forEach(function(cacheKey){hash[cacheKey]=hash[cacheKey].result;});return hash;}/**\n   * Get the cache for the given selector. Don't create it if it doesn't exist,\n   * just return undefined.\n   */;_proto.weakGetCache=function weakGetCache(selectable,args){if((0,is.is)(selectable,SelectorCacheItem)){return selectable;}var cacheKey=this.getCacheKey(selectable,args,true);if(!cacheKey)return;return this._items[cacheKey];}/**\n   * Should only be used internally. Removes the selector from the cache and\n   * the graph\n   */;_proto._destroySelector=function _destroySelector(cacheKey){var cache=this._items[cacheKey];if(!cache)return;// shouldn't happen\nif(cache.nextEvaluationReasons.length&&cache.task){this.ecosystem._scheduler.unschedule(cache.task);}this.ecosystem._graph.removeDependencies(cacheKey);this.ecosystem._graph.removeNode(cacheKey);delete this._items[cacheKey];cache.isDestroyed=true;this._refBaseKeys.delete(cache.selectorRef);}/**\n   * Get the string key we would ideally use as the cacheKey of the given\n   * AtomSelector function or AtomSelectorConfig object - doesn't necessarily\n   * mean we end up caching using this key.\n   */;_proto._getIdealCacheKey=function _getIdealCacheKey(selectorOrConfig){var _selector;var idealKey=selectorOrConfig.name||((_selector=selectorOrConfig.selector)==null?void 0:_selector.name);// 'selector' is too generic (it's the key in AtomSelectorConfig objects)\nreturn idealKey!=='selector'&&idealKey||undefined;}/**\n   * Should only be used internally\n   */;_proto._scheduleEvaluation=function _scheduleEvaluation(cacheKey,reason,shouldSetTimeout){var _this2=this;var cache=this._items[cacheKey];// TODO: Any calls in this case probably indicate a memory leak on the\n// user's part. Notify them.\nif(!cache)return;cache.nextEvaluationReasons.push(reason);if(cache.nextEvaluationReasons.length>1)return;// job already scheduled\nvar task=function task(){cache.task=undefined;_this2.runSelector(cacheKey,cache.args);};cache.task=task;this.ecosystem._scheduler.schedule({keyHash:cacheKey,task:task,type:2// EvaluateGraphNode (2)\n},shouldSetTimeout);}/**\n   * Should only be used internally\n   */;_proto._swapRefs=function _swapRefs(oldRef,newRef,args){var existingCache=this.weakGetCache(oldRef,args);var baseKey=this._refBaseKeys.get(oldRef);if(!existingCache||!baseKey)return;this._refBaseKeys.set(newRef,baseKey);existingCache.selectorRef=newRef;this.runSelector(existingCache.cacheKey,args);}/**\n   * Destroy all cached selectors. Should probably only be used internally.\n   * Prefer `ecosystem.reset()`.\n   */;_proto._wipe=function _wipe(){var _this3=this;Object.keys(this._items).forEach(function(cacheKey){_this3._destroySelector(cacheKey);});this._refBaseKeys=new WeakMap();}/**\n   * Get a base key that can be used to generate consistent cacheKeys for the\n   * given selector\n   */;_proto.getBaseKey=function getBaseKey(selectorOrConfig,weak){var existingId=this._refBaseKeys.get(selectorOrConfig);if(existingId||weak)return existingId;var idealKey=this._getIdealCacheKey(selectorOrConfig);var prefixedKey=\"@@selector-\"+idealKey;var keyExists=this._items[prefixedKey];// if the ideal key is taken, generate a new hash prefixed with the ideal key\nvar key=!idealKey||keyExists?this.ecosystem._idGenerator.generateAtomSelectorId(idealKey):prefixedKey;this._refBaseKeys.set(selectorOrConfig,key);return key;}/**\n   * Run an AtomSelector and, depending on the selector's resultsComparator,\n   * update its cached result. Updates the graph efficiently (using\n   * `.bufferUpdates()`)\n   */;_proto.runSelector=function runSelector(cacheKey,args,isInitializing){this.ecosystem._graph.bufferUpdates(cacheKey);var cache=this._items[cacheKey];this.ecosystem._evaluationStack.start(cache);var selector=typeof cache.selectorRef==='function'?cache.selectorRef:cache.selectorRef.selector;var resultsComparator=typeof cache.selectorRef!=='function'&&cache.selectorRef.resultsComparator||defaultResultsComparator;try{var result=selector.apply(void 0,[this.ecosystem._evaluationStack.atomGetters].concat(args));if(!isInitializing&&!resultsComparator(result,cache.result)){this.ecosystem._graph.scheduleDependents(cacheKey,cache.nextEvaluationReasons,result,cache.result);if(this.ecosystem._mods.stateChanged){this.ecosystem.modBus.dispatch(plugin_actions/* pluginActions.stateChanged */.V.stateChanged({cache:cache,newState:result,oldState:cache.result,reasons:cache.nextEvaluationReasons}));}cache.result=result;}else if(isInitializing){cache.result=result;}}catch(err){this.ecosystem._graph.destroyBuffer();console.error(\"Zedux encountered an error while running AtomSelector with key \\\"\"+cacheKey+\"\\\":\",err);throw err;}finally{this.ecosystem._evaluationStack.finish();cache.prevEvaluationReasons=cache.nextEvaluationReasons;cache.nextEvaluationReasons=[];}this.ecosystem._graph.flushUpdates();};return SelectorCache;}();\n;// CONCATENATED MODULE: ../packages/react/src/classes/Ecosystem.ts\nvar defaultMods=Object.keys(plugin_actions/* pluginActions */.V).reduce(function(map,mod){map[mod]=0;return map;},{});var mapOverrides=function mapOverrides(overrides){return overrides.reduce(function(map,atom){map[atom.key]=atom;return map;},{});};var Ecosystem=/*#__PURE__*/function(){// use an empty store as a message bus\nfunction Ecosystem(_ref){var complexParams=_ref.complexParams,context=_ref.context,defaultTtl=_ref.defaultTtl,destroyOnUnmount=_ref.destroyOnUnmount,flags=_ref.flags,id=_ref.id,onReady=_ref.onReady,overrides=_ref.overrides,ssr=_ref.ssr;this._destroyOnUnmount=false;this._graph=new Graph(this);this._evaluationStack=new EvaluationStack/* EvaluationStack */.O(this);this._idGenerator=new IdGenerator();this._instances={};this._mods=Object.assign({},defaultMods);this._reactContexts={};this._refCount=0;this._scheduler=new Scheduler(this);this.selectorCache=new SelectorCache(this);this.modBus=(0,createStore/* createStore */.M)();this.overrides={};this.isInitialized=false;this.plugins=[];if( true&&flags&&!Array.isArray(flags)){throw new TypeError(\"Zedux: The Ecosystem's `flags` property must be an array of strings\");}if( true&&overrides&&!Array.isArray(overrides)){throw new TypeError(\"Zedux: The Ecosystem's `overrides` property must be an array of Atom objects\");}this.id=id||this._idGenerator.generateEcosystemId();if(overrides){this.setOverrides(overrides);}this.flags=flags;this.complexParams=!!complexParams;this.context=context;this.defaultTtl=defaultTtl!=null?defaultTtl:-1;this.ssr=ssr;this._destroyOnUnmount=!!destroyOnUnmount;this._onReady=onReady;this.isInitialized=true;this.cleanup=onReady==null?void 0:onReady(this);}/**\n   * Merge the passed atom overrides into the ecosystem's current list of\n   * overrides. Force-destroys all atom instances currently in the ecosystem\n   * that should now be overridden.\n   *\n   * This can't be used to remove overrides. Use `.setOverrides()` or\n   * `.removeOverrides()` for that.\n   */var _proto=Ecosystem.prototype;_proto.addOverrides=function addOverrides(overrides){var _this=this;this.overrides=Object.assign({},this.overrides,mapOverrides(overrides));overrides.forEach(function(override){var instances=_this.inspectInstances(override);Object.values(instances).forEach(function(instance){return instance.destroy(true);});});}/**\n   * Retrieve an object mapping atom instance keyHashes to their current values.\n   *\n   * Calls the `dehydrate` atom config option (on atoms that have one) to\n   * transform state to a serializable form. Pass `transform: false` to prevent\n   * this.\n   *\n   * Atoms can be excluded from dehydration by passing `exclude` and/or\n   * `excludeFlags` options:\n   *\n   * ```ts\n   * myEcosystem.dehydrate({\n   *   exclude: [myAtom, 'my-fuzzy-search-string'],\n   *   excludeFlags: ['no-ssr']\n   * })\n   * ```\n   *\n   * An atom passed to `exclude` will exclude all instances of that atom. A\n   * string passed to `exclude` will exclude all instances whose keyHash\n   * contains the string (case-insensitive)\n   *\n   * You can dehydrate only a subset of all atoms by passing `include` and/or\n   * `includeFlags` options:\n   *\n   * ```ts\n   * myEcosystem.dehydrate({\n   *   include: [myAtom, 'my-fuzzy-search-string'],\n   *   includeFlags: ['ssr']\n   * })\n   * ```\n   *\n   * An atom passed to `include` will include all instances of that atom. A\n   * string passed to `include` will include all instances whose keyHash\n   * contains the string (case-insensitive)\n   *\n   * Excludes takes precedence over includes.\n   *\n   * By default, dehydration will call any configured `dehydrate` atom config\n   * options to transform atom instance state. Pass `{ transform: false }` to\n   * prevent this.\n   */;_proto.dehydrate=function dehydrate(_temp){var _ref2=_temp===void 0?{}:_temp,exclude=_ref2.exclude,excludeFlags=_ref2.excludeFlags,include=_ref2.include,includeFlags=_ref2.includeFlags,_ref2$transform=_ref2.transform,transform=_ref2$transform===void 0?true:_ref2$transform;var instances=Object.values(this._instances).filter(function(instance){if(exclude&&exclude.some(function(atomOrKey){return typeof atomOrKey==='string'?instance.keyHash.toLowerCase().includes(atomOrKey.toLowerCase()):instance.atom.key===atomOrKey.key;})){return false;}if(excludeFlags&&excludeFlags.some(function(flag){var _instance$atom$flags;return(_instance$atom$flags=instance.atom.flags)==null?void 0:_instance$atom$flags.includes(flag);})){return false;}if(!include&&!includeFlags)return true;if(include&&include.some(function(atomOrKey){return typeof atomOrKey==='string'?instance.keyHash.toLowerCase().includes(atomOrKey.toLowerCase()):instance.atom.key===atomOrKey.key;})){return true;}if(includeFlags&&includeFlags.some(function(flag){var _instance$atom$flags2;return(_instance$atom$flags2=instance.atom.flags)==null?void 0:_instance$atom$flags2.includes(flag);})){return true;}return false;});return Object.fromEntries(instances.map(function(instance){var state=instance.store.getState();return[instance.keyHash,transform&&instance.atom.dehydrate?instance.atom.dehydrate(state):state];}));}/**\n   * Destroy this ecosystem - destroy all this ecosystem's atom instances,\n   * remove and clean up all plugins, and remove this ecosystem from the\n   * internalStore.\n   *\n   * Destruction will bail out by default if this ecosystem is still being\n   * provided via an <EcosystemProvider>. Pass `true` as the first parameter to\n   * force destruction anyway.\n   */;_proto.destroy=function destroy(force){var _this2=this;if(!force&&this._refCount>0)return;this.wipe();// Check if this ecosystem has been destroyed already\nvar ecosystem=store/* internalStore.getState */.Do.getState()[this.id];if(!ecosystem)return;this.plugins.forEach(function(_ref3){var cleanup=_ref3.cleanup;return cleanup();});this.plugins=[];store/* internalStore.setState */.Do.setState(function(state){var newState=Object.assign({},state);delete newState[_this2.id];return newState;});};/**\n   * Returns an atom instance's value. Creates the atom instance if it doesn't\n   * exist yet. Doesn't register any graph dependencies.\n   */_proto.get=function get(atom,params){if((0,is.is)(atom,AtomInstanceBase/* AtomInstanceBase */.T)){return atom.store.getState();}var instance=this.getInstance(atom,params);return instance.store.getState();};/**\n   * Returns an atom instance. Creates the atom instance if it doesn't exist\n   * yet. Doesn't register any graph dependencies.\n   */_proto.getInstance=function getInstance(atom,params){if((0,is.is)(atom,AtomInstanceBase/* AtomInstanceBase */.T))return atom;var keyHash=atom.getKeyHash(this,params);// try to find an existing instance\nvar existingInstance=this._instances[keyHash];if(existingInstance)return existingInstance;// create a new instance\nvar resolvedAtom=this.resolveAtom(atom);this._graph.addNode(keyHash);var newInstance=resolvedAtom._createInstance(this,keyHash,params||[]);this._instances[keyHash]=newInstance;newInstance._init();return newInstance;}/**\n   * Hydrate the state of atoms in this ecosystem with an object mapping atom\n   * instance keyHashes to their hydrated state. This object will usually be the\n   * result of a call to `ecosystem.dehydrate()`.\n   *\n   * This is the key to SSR. The ecosystem's initial state can be dehydrated on\n   * the server, sent to the client in serialized form, deserialized, and passed\n   * to `ecosystem.hydrate()`. Every atom instance that evaluates after this\n   * hydration can use the `hydrate` injectStore config option to retrieve its\n   * hydrated state.\n   *\n   * Pass `retroactive: false` to prevent this call from updating the state of\n   * all atom instances that have already been initialized with this new\n   * hydration. Hydration is retroactive by default.\n   *\n   * ```ts\n   * ecosystem.hydrate(dehydratedState, { retroactive: false })\n   * ```\n   */;_proto.hydrate=function hydrate(dehydratedState,config){var _this3=this;this.hydration=Object.assign({},this.hydration,dehydratedState);if((config==null?void 0:config.retroactive)===false)return;Object.entries(dehydratedState).forEach(function(_ref4){var _this3$hydration;var key=_ref4[0],val=_ref4[1];var instance=_this3._instances[key];if(!instance)return;instance.setState(instance.atom.hydrate?instance.atom.hydrate(val):val);(_this3$hydration=_this3.hydration)==null?true:delete _this3$hydration[key];});}/**\n   * Get an object of all atom instances in this ecosystem.\n   *\n   * Pass an atom or atom key string to only return instances whose keyHash\n   * weakly matches the passed key.\n   */;_proto.inspectInstances=function inspectInstances(atom){var isAtom=atom==null?void 0:atom.key;var filterKey=isAtom?atom==null?void 0:atom.key:atom;var hash={};Object.values(this._instances).sort(function(a,b){return a.keyHash.localeCompare(b.keyHash);}).forEach(function(instance){if(filterKey&&(isAtom?instance.atom.key!==filterKey:!instance.keyHash.toLowerCase().includes(filterKey))){return;}hash[instance.keyHash]=instance;});return hash;}/**\n   * Add a ZeduxPlugin to this ecosystem. This ecosystem will subscribe to the\n   * plugin's modStore, whose state can be changed to reactively update the mods\n   * of this ecosystem.\n   *\n   * This method will also call the passed plugin's `.registerEcosystem` method,\n   * allowing the plugin to subscribe to this ecosystem's modBus\n   *\n   * The plugin will remain part of this ecosystem until it is unregistered or\n   * this ecosystem is destroyed. `.wipe()` and `.reset()` don't remove plugins.\n   * However, a plugin _can_ set the `ecosystemWiped` mod and react to those\n   * events.\n   */;_proto.registerPlugin=function registerPlugin(plugin){var _this4=this;if(this.plugins.some(function(descriptor){return descriptor.plugin===plugin;}))return;var subscription=plugin.modStore.subscribe(function(newState,oldState){_this4.recalculateMods(newState,oldState);});var cleanupRegistration=plugin.registerEcosystem(this);var cleanup=function cleanup(){subscription.unsubscribe();if(cleanupRegistration)cleanupRegistration();};this.plugins.push({cleanup:cleanup,plugin:plugin});this.recalculateMods(plugin.modStore.getState());}/**\n   * Remove all passed atoms from this ecosystem's list of atom overrides. Does\n   * nothing for passed atoms that aren't currently in the overrides list.\n   *\n   * Force destroys all instances of all removed atoms. This forced destruction\n   * will cause dependents of those instances to recreate their dependency atom\n   * instance without using an override.\n   */;_proto.removeOverrides=function removeOverrides(overrides){var _this5=this;this.overrides=mapOverrides(Object.values(this.overrides).filter(function(atom){return overrides.every(function(override){var key=typeof override==='string'?override:override.key;return key!==atom.key;});}));overrides.forEach(function(override){var instances=_this5.inspectInstances(override);Object.values(instances).forEach(function(instance){return instance.destroy(true);});});}/**\n   * Destroys all atom instances in this ecosystem, runs the cleanup function\n   * returned from `onReady` (if any), and calls `onReady` again to reinitialize\n   * the ecosystem.\n   */;_proto.reset=function reset(newContext){var _this$_onReady;this.wipe();var prevContext=this.context;if(typeof newContext!=='undefined')this.context=newContext;this.cleanup=(_this$_onReady=this._onReady)==null?void 0:_this$_onReady.call(this,this,prevContext);}/**\n   * Runs an AtomSelector statically - without registering any dependencies or\n   * updating any caches. If we've already cached this exact selector + args\n   * combo, returns the cached value without running the selector again\n   */;_proto.select=function select(selectable){if((0,is.is)(selectable,SelectorCacheItem)){return selectable.result;}var atomSelector=selectable;for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}var cache=this.selectorCache.weakGetCache(atomSelector,args);if(cache)return cache.result;var resolvedSelector=typeof atomSelector==='function'?atomSelector:atomSelector.selector;return resolvedSelector.apply(void 0,[{ecosystem:this,get:this.get.bind(this),getInstance:this.getInstance.bind(this),select:this.select.bind(this)}].concat(args));}/**\n   * Completely replace this ecosystem's current list of atom overrides with a\n   * new list.\n   *\n   * Force destroys all instances of all previously- and newly-overridden atoms.\n   * This forced destruction will cause dependents of those instances to\n   * recreate their dependency atom instance.\n   */;_proto.setOverrides=function setOverrides(newOverrides){var _this6=this;var oldOverrides=this.overrides;this.overrides=mapOverrides(newOverrides);if(!this.isInitialized)return;newOverrides.forEach(function(atom){var instances=_this6.inspectInstances(atom);Object.values(instances).forEach(function(instance){instance.destroy(true);});});if(!oldOverrides)return;Object.values(oldOverrides).forEach(function(atom){var instances=_this6.inspectInstances(atom);Object.values(instances).forEach(function(instance){instance.destroy(true);});});}/**\n   * Unregister a plugin registered in this ecosystem via `.registerPlugin()`\n   */;_proto.unregisterPlugin=function unregisterPlugin(plugin){var index=this.plugins.findIndex(function(descriptor){return descriptor.plugin===plugin;});if(index===-1)return;this.plugins[index].cleanup();this.plugins.splice(index,1);this.recalculateMods(undefined,plugin.modStore.getState());};/**\n   * Get the current graph of this ecosystem. There are 3 views:\n   *\n   * Flat (default). Returns an object with all graph nodes on the top layer,\n   * each node pointing to its dependencies and dependents. No nesting.\n   *\n   * Bottom-Up. Returns an object containing all the leaf nodes of the graph\n   * (nodes that have no internal dependents), each node containing an object of\n   * its parent nodes, recursively.\n   *\n   * Top-Down. Returns an object containing all the root nodes of the graph\n   * (nodes that have no dependencies), each node containing an object of its\n   * child nodes, recursively.\n   */_proto.viewGraph=function viewGraph(view){var _this7=this;if(view!=='top-down'&&view!=='bottom-up'){var _hash={};Object.keys(this._graph.nodes).forEach(function(cacheKey){var node=_this7._graph.nodes[cacheKey];_hash[cacheKey]={dependencies:Object.keys(node.dependencies).map(function(key){return{key:key,operation:_this7._graph.nodes[key].dependents[cacheKey].operation};}),dependents:Object.keys(node.dependents).map(function(key){return{key:key,operation:node.dependents[key].operation};}),weight:node.weight};});return _hash;}var hash={};Object.keys(this._graph.nodes).forEach(function(key){var node=_this7._graph.nodes[key];var isTopLevel=view==='bottom-up'?Object.keys(node.dependents).every(function(key){var dependent=node.dependents[key];return dependent.flags&general/* External */.RQ;}):!Object.keys(node.dependencies).length;if(isTopLevel){hash[key]={};}});var recurse=function recurse(node){if(!node)return;var keys=Object.keys(view==='bottom-up'?node.dependencies:node.dependents);var children={};keys.forEach(function(key){var child=recurse(_this7._graph.nodes[key]);if(child)children[key]=child;});return children;};Object.keys(hash).forEach(function(key){var node=_this7._graph.nodes[key];var children=recurse(node);if(children)hash[key]=children;});return hash;}/**\n   * Get an atom instance value. Don't create the atom instance if it doesn't\n   * exist. Don't register any graph dependencies.\n   */;_proto.weakGet=function weakGet(atom,params){var instance=this.weakGetInstance(atom,params);return instance==null?void 0:instance.store.getState();}/**\n   * Get an atom instance. Don't create the atom instance if it doesn't exist.\n   * Don't register any graph dependencies.\n   */;_proto.weakGetInstance=function weakGetInstance(atom,params){if(typeof atom!=='string'){var keyHash=atom.getKeyHash(this,params);// try to find an existing instance\nreturn this._instances[keyHash];}return Object.values(this.inspectInstances(atom))[0];}/**\n   * Returns the list of reasons detailing why the current atom instance or\n   * selector is evaluating.\n   *\n   * Returns undefined if nothing is currently evaluating. Returns an empty\n   * array if this is the first evaluation of the instance or selector.\n   */;_proto.why=function why(){var item=this._evaluationStack.read();if(!item)return;if(item.cache){return item.cache.nextEvaluationReasons;}return item.instance._nextEvaluationReasons;}/**\n   * Destroy all atom instances in this ecosystem. Also run the cleanup function\n   * returned from the onReady callback (if any). Don't remove plugins or re-run\n   * the onReady callback.\n   *\n   * Important! This method is mostly for internal use. You won't typically want\n   * to call this method. Prefer `.reset()` which re-runs the onReady callback\n   * after wiping the ecosystem, allowing onReady to re-initialize the ecosystem\n   * - preloading atoms, registering plugins, configuring context, etc\n   */;_proto.wipe=function wipe(){// call cleanup function first so it can configure the ecosystem for cleanup\nif(this.cleanup)this.cleanup();// TODO: Delete nodes in an optimal order, starting with nodes with no\n// internal dependents. This is different from highest-weighted nodes since\n// static dependents don't affect weight. This should make sure no internal\n// nodes schedule unnecessary reevaaluations to recreate force-destroyed\n// instances\nObject.values(this._instances).forEach(function(instance){instance.destroy(true);});this.hydration=undefined;this.selectorCache._wipe();this._scheduler.wipe();this._scheduler.flush();if(this._mods.ecosystemWiped){this.modBus.dispatch(plugin_actions/* pluginActions.ecosystemWiped */.V.ecosystemWiped({ecosystem:this}));}}/**\n   * Should only be used internally\n   */;_proto._consumeHydration=function _consumeHydration(instance){var _this$hydration,_this$hydration2;var hydratedValue=(_this$hydration=this.hydration)==null?void 0:_this$hydration[instance.keyHash];if(typeof hydratedValue==='undefined')return;(_this$hydration2=this.hydration)==null?true:delete _this$hydration2[instance.keyHash];return instance.atom.hydrate?instance.atom.hydrate(hydratedValue):hydratedValue;}/**\n   * Should only be used internally\n   */;_proto._decrementRefCount=function _decrementRefCount(){this._refCount--;if(!this._destroyOnUnmount)return;this.destroy();// only destroys if _refCount === 0\n}/**\n   * Should only be used internally\n   */;_proto._destroyAtomInstance=function _destroyAtomInstance(keyHash){// try to destroy instance (if not destroyed - this fn is called as part of\n// that destruction process too)\nthis._graph.removeNode(keyHash);delete this._instances[keyHash];// TODO: dispatch an action over internalStore for this mutation\n}/**\n   * Should only be used internally\n   */;_proto._getReactContext=function _getReactContext(atom){var existingContext=this._reactContexts[atom.key];if(existingContext)return existingContext;var newContext=/*#__PURE__*/(0,react.createContext)(undefined);this._reactContexts[atom.key]=newContext;return newContext;}/**\n   * Should only be used internally\n   */;_proto._incrementRefCount=function _incrementRefCount(){this._refCount++;};_proto.recalculateMods=function recalculateMods(newState,oldState){var _this8=this;if(oldState){oldState.forEach(function(key){_this8._mods[key]--;// fun fact, undefined-- is fine\n});}if(newState){newState.forEach(function(key){_this8._mods[key]++;});}};_proto.resolveAtom=function resolveAtom(atom){var _this$overrides,_this9=this;var override=(_this$overrides=this.overrides)==null?void 0:_this$overrides[atom.key];var maybeOverriddenAtom=override||atom;// to turn off flag checking, just don't pass a `flags` prop\nif(this.flags){var _maybeOverriddenAtom$;var badFlag=(_maybeOverriddenAtom$=maybeOverriddenAtom.flags)==null?void 0:_maybeOverriddenAtom$.find(function(flag){var _this9$flags;return!((_this9$flags=_this9.flags)!=null&&_this9$flags.includes(flag));});if( true&&badFlag){console.error(\"Zedux: encountered unsafe atom \\\"\"+atom.key+\"\\\" with flag \\\"\"+badFlag+\"\\\". This atom should be overridden in the current environment.\");}}return maybeOverriddenAtom;};return Ecosystem;}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QytCLEtBQUssQ0FBQy9CLEdBQUcsQ0FBUSxFQUFFLENBQUM7QUFDM0IsQ0FBQyxDQUFDLENBQ0osQ0FFQSxHQUFJNEMsUUFBUSxDQUFFLENBQ1pBLFFBQVEsQ0FBQzdCLE9BQU8sQ0FBQyxTQUFBZixHQUFHLENBQUksQ0FDdEIsTUFBSSxDQUFDK0IsS0FBSyxDQUFDL0IsR0FBRyxDQUFRLEVBQUUsQ0FDMUIsQ0FBQyxDQUFDLENBQ0osQ0FDRixDQUFDLFFBRU84UCxXQUFXLENBQW5CLHFCQUE4Q3RDLElBQWMsQ0FBRSxpQ0FDNUQsR0FBTWlCLFNBQVEsa0JBQUcsSUFBSSxDQUFDbEIsU0FBUyxlQUFkLGdCQUFpQkMsSUFBSSxDQUFDeE4sR0FBRyxDQUFDLENBQzNDLEdBQU1vVCxvQkFBbUIsQ0FBSTNFLFFBQVEsRUFBSWpCLElBQWlCLENBRTFEO0FBQ0EsR0FBSSxJQUFJLENBQUNqTyxLQUFLLENBQUUsMkJBQ2QsR0FBTThULFFBQU8sd0JBQUdELG1CQUFtQixDQUFDN1QsS0FBSyxlQUF6QixzQkFBMkJzRyxJQUFJLENBQzdDLFNBQUF5SixJQUFJLHlCQUFJLGdCQUFDLE1BQUksQ0FBQy9QLEtBQUssU0FBVixhQUFZK0wsUUFBUSxDQUFDZ0UsSUFBSSxDQUFDLElBQ3BDLENBRUQsR0FBSXJQLEtBQUcsRUFBSW9ULE9BQU8sQ0FBRSxDQUNsQnpHLE9BQU8sQ0FBQ0MsS0FBSyxxQ0FDd0JXLElBQUksQ0FBQ3hOLEdBQUcsbUJBQWdCcVQsT0FBTyxrRUFDbkUsQ0FDSCxDQUNGLENBRUEsTUFBT0Qsb0JBQW1CLENBQzVCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9jbGFzc2VzL0dyYXBoLnRzPzY5NGIiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9yZWFjdC9zcmMvY2xhc3Nlcy9JZEdlbmVyYXRvci50cz9iMDFhIiwid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL2NsYXNzZXMvU2NoZWR1bGVyLnRzPzlmNzQiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9yZWFjdC9zcmMvY2xhc3Nlcy9TZWxlY3RvckNhY2hlLnRzPzhkMTMiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9yZWFjdC9zcmMvY2xhc3Nlcy9FY29zeXN0ZW0udHM/OWNkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBbnlBdG9tSW5zdGFuY2UsXG4gIERlcGVuZGVudENhbGxiYWNrLFxuICBEZXBlbmRlbnRFZGdlLFxuICBFY29zeXN0ZW1HcmFwaE5vZGUsXG4gIEV2YWx1YXRpb25SZWFzb24sXG4gIEV2YWx1YXRpb25UeXBlLFxuICBHcmFwaEVkZ2VTaWduYWwsXG59IGZyb20gJy4uL3R5cGVzJ1xuaW1wb3J0IHsgRXhwbGljaXQsIEV4dGVybmFsLCBTdGF0aWMgfSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IHBsdWdpbkFjdGlvbnMgfSBmcm9tICcuLi91dGlscy9wbHVnaW4tYWN0aW9ucydcbmltcG9ydCB7IEVjb3N5c3RlbSB9IGZyb20gJy4vRWNvc3lzdGVtJ1xuXG5leHBvcnQgY2xhc3MgR3JhcGgge1xuICBwdWJsaWMgbm9kZXM6IFJlY29yZDxzdHJpbmcsIEVjb3N5c3RlbUdyYXBoTm9kZT4gPSB7fVxuICBwcml2YXRlIHVwZGF0ZVN0YWNrOiB7XG4gICAgZGVwZW5kZW5jaWVzOiBSZWNvcmQ8c3RyaW5nLCBEZXBlbmRlbnRFZGdlPlxuICAgIGtleTogc3RyaW5nXG4gIH1bXSA9IFtdXG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgZWNvc3lzdGVtOiBFY29zeXN0ZW0pIHt9XG5cbiAgLyoqXG4gICAqIERyYXcgYSBuZXcgZWRnZSBiZXR3ZWVuIHR3byBub2RlcyBpbiB0aGUgZ3JhcGguIFRoaXMgaXMgaG93IGRlcGVuZGVuY2llc1xuICAgKiBhcmUgY3JlYXRlZCBiZXR3ZWVuIGF0b21zLCBzZWxlY3RvcnMsIGFuZCBleHRlcm5hbCBub2RlcyBsaWtlIFJlYWN0XG4gICAqIGNvbXBvbmVudHMuXG4gICAqL1xuICBwdWJsaWMgYWRkRWRnZShcbiAgICBkZXBlbmRlbnRLZXk6IHN0cmluZyxcbiAgICBkZXBlbmRlbmN5S2V5OiBzdHJpbmcsXG4gICAgb3BlcmF0aW9uOiBzdHJpbmcsXG4gICAgZmxhZ3M6IG51bWJlcixcbiAgICBjYWxsYmFjaz86IERlcGVuZGVudENhbGxiYWNrXG4gICkge1xuICAgIGNvbnN0IG5ld0VkZ2U6IERlcGVuZGVudEVkZ2UgPSB7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIGNyZWF0ZWRBdDogRGF0ZS5ub3coKSxcbiAgICAgIGZsYWdzLFxuICAgICAgb3BlcmF0aW9uLFxuICAgIH1cblxuICAgIGlmICghdGhpcy51cGRhdGVTdGFjay5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbmlzaEFkZGluZ0VkZ2UoZGVwZW5kZW50S2V5LCBkZXBlbmRlbmN5S2V5LCBuZXdFZGdlKVxuICAgIH1cblxuICAgIC8vIFdlJ3JlIGJ1ZmZlcmluZyB1cGRhdGVzISBCdWZmZXIgdGhpcyBvbmVcbiAgICBjb25zdCB7IGRlcGVuZGVuY2llcywga2V5IH0gPSB0aGlzLnVwZGF0ZVN0YWNrW3RoaXMudXBkYXRlU3RhY2subGVuZ3RoIC0gMV1cblxuICAgIGlmIChERVYgJiYga2V5ICE9PSBkZXBlbmRlbnRLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJaZWR1eDogVHJpZWQgdXBkYXRpbmcgZGVwZW5kZW5jaWVzIG9mIGEgZ3JhcGggbm9kZSB0aGF0IGlzbid0IGN1cnJlbnRseSBldmFsdWF0aW5nLiBUaGlzIG1lYW5zIHRoYXQgZWl0aGVyIHlvdSB0cmllZCB1cGRhdGluZyB0aGUgZ3JhcGggbWFudWFsbHkgb3IgdGhlcmUgaXMgYSBidWcgaW4gWmVkdXguIElmIGl0J3MgYSBidWcsIHBsZWFzZSByZXBvcnQgaXQhXCJcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2RlcGVuZGVuY3lLZXldXG5cbiAgICAvLyBEb24ndCBvdmVyd3JpdGUgYSBoaWdoZXItcHJpbyBlZGdlIHdpdGggYSBsb3dlciBvbmUuIEFsc28gaWdub3JlIHNhbWUtcHJpb1xuICAgIGlmICghZGVwZW5kZW5jeSB8fCBkZXBlbmRlbmN5LmZsYWdzID4gZmxhZ3MpIHtcbiAgICAgIGRlcGVuZGVuY2llc1tkZXBlbmRlbmN5S2V5XSA9IG5ld0VkZ2VcbiAgICAgIHJldHVybiBuZXdFZGdlXG4gICAgfVxuXG4gICAgLy8gaWYgdGhpcyBlZGdlIHdhcyBpZ25vcmVkLCByZXR1cm4gdGhlIGV4aXN0aW5nIGJ1ZmZlcmVkIGVkZ2VcbiAgICByZXR1cm4gZGVwZW5kZW5jaWVzW2RlcGVuZGVuY3lLZXldXG4gIH1cblxuICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGludGVybmFsbHlcbiAgcHVibGljIGFkZE5vZGUobm9kZUtleTogc3RyaW5nLCBpc0F0b21TZWxlY3Rvcj86IGJvb2xlYW4pIHtcbiAgICBpZiAodGhpcy5ub2Rlc1tub2RlS2V5XSkgcmV0dXJuIC8vIGFscmVhZHkgYWRkZWRcblxuICAgIHRoaXMubm9kZXNbbm9kZUtleV0gPSB7XG4gICAgICBkZXBlbmRlbmNpZXM6IHt9LFxuICAgICAgZGVwZW5kZW50czoge30sXG4gICAgICBpc0F0b21TZWxlY3RvcixcbiAgICAgIHdlaWdodDogMSwgLy8gdGhpcyBub2RlIGRvZXNuJ3QgaGF2ZSBkZXBlbmRlbmNpZXMgeWV0OyBpdCdzIHdlaWdodCBpcyAxXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByZXZlbnQgbmV3IGdyYXBoIGVkZ2VzIGZyb20gYmVpbmcgYWRkZWQgaW1tZWRpYXRlbHkuIEluc3RlYWQsIGJ1ZmZlciB0aGVtXG4gICAqIHNvIHdlIGNhbiBwcmV2ZW50IGR1cGxpY2F0ZXMgb3IgdW5uZWNlc3NhcnkgZWRnZXMuIENhbGwgYC5mbHVzaFVwZGF0ZXMoKWBcbiAgICogdG8gZmluaXNoIGJ1ZmZlcmluZy5cbiAgICpcbiAgICogVGhpcyBpcyB1c2VkIGR1cmluZyBhdG9tIGFuZCBBdG9tU2VsZWN0b3IgZXZhbHVhdGlvbiB0byBtYWtlIHRoZSBncmFwaCBhc1xuICAgKiBlZmZpY2llbnQgYXMgcG9zc2libGUuXG4gICAqL1xuICBwdWJsaWMgYnVmZmVyVXBkYXRlcyhrZXk6IHN0cmluZykge1xuICAgIHRoaXMudXBkYXRlU3RhY2sucHVzaCh7IGtleSwgZGVwZW5kZW5jaWVzOiB7fSB9KVxuICB9XG5cbiAgLyoqXG4gICAqIElmIGFuIGF0b20gaW5zdGFuY2Ugb3IgQXRvbVNlbGVjdG9yIGVycm9ycyBkdXJpbmcgZXZhbHVhdGlvbiwgd2UgbmVlZCB0b1xuICAgKiBkZXN0cm95IGFueSBpbnN0YW5jZXMgb3IgQXRvbVNlbGVjdG9ycyBjcmVhdGVkIGR1cmluZyB0aGF0IGV2YWx1YXRpb24gdGhhdFxuICAgKiBub3cgaGF2ZSBubyBkZXBlbmRlbnRzLlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3lCdWZmZXIoKSB7XG4gICAgY29uc3QgeyBkZXBlbmRlbmNpZXMsIGtleSB9ID0gdGhpcy51cGRhdGVTdGFja1t0aGlzLnVwZGF0ZVN0YWNrLmxlbmd0aCAtIDFdXG4gICAgY29uc3QgZWRnZXMgPSB0aGlzLm5vZGVzW2tleV0uZGVwZW5kZW5jaWVzXG5cbiAgICBPYmplY3Qua2V5cyhkZXBlbmRlbmNpZXMpLmZvckVhY2goZGVwZW5kZW5jeUtleSA9PiB7XG4gICAgICBjb25zdCBleGlzdGluZ0VkZ2UgPSBlZGdlc1tkZXBlbmRlbmN5S2V5XVxuXG4gICAgICAvLyB0aGUgZWRnZSB3YXNuJ3QgY3JlYXRlZCBkdXJpbmcgdGhlIGV2YWx1YXRpb24gdGhhdCBlcnJvcmVkOyBrZWVwIGl0XG4gICAgICBpZiAoZXhpc3RpbmdFZGdlKSByZXR1cm5cblxuICAgICAgdGhpcy5zY2hlZHVsZU5vZGVEZXN0cnVjdGlvbihkZXBlbmRlbmN5S2V5KVxuICAgIH0pXG5cbiAgICB0aGlzLnVwZGF0ZVN0YWNrLnBvcCgpXG4gIH1cblxuICAvKipcbiAgICogU3RvcCBidWZmZXJpbmcgdXBkYXRlcyBmb3IgdGhlIG5vZGUgcGFzc2VkIHRvIGAuYnVmZmVyVXBkYXRlcygpYCBhbmQgYWRkXG4gICAqIHRoZSBidWZmZXJlZCBlZGdlcyB0byB0aGUgZ3JhcGguXG4gICAqL1xuICBwdWJsaWMgZmx1c2hVcGRhdGVzKCkge1xuICAgIGNvbnN0IHsgZGVwZW5kZW5jaWVzLCBrZXkgfSA9IHRoaXMudXBkYXRlU3RhY2tbdGhpcy51cGRhdGVTdGFjay5sZW5ndGggLSAxXVxuICAgIGNvbnN0IGVkZ2VzID0gdGhpcy5ub2Rlc1trZXldLmRlcGVuZGVuY2llc1xuXG4gICAgLy8gcmVtb3ZlIGFueSBlZGdlcyB0aGF0IHdlcmUgbm90IHJlY3JlYXRlZCB3aGlsZSBidWZmZXJpbmcuIERvbid0IHJlbW92ZVxuICAgIC8vIGFueXRoaW5nIGJ1dCBpbXBsaWNpdC1pbnRlcm5hbCBlZGdlcyAodGhvc2UgYXJlIHRoZSBvbmx5IGtpbmQgd2VcbiAgICAvLyBhdXRvLWNyZWF0ZSBkdXJpbmcgZXZhbHVhdGlvbiAtIG90aGVyIHR5cGVzIG1heSBoYXZlIGJlZW4gYWRkZWQgbWFudWFsbHlcbiAgICAvLyBieSB0aGUgdXNlciBhbmQgd2UgZG9uJ3Qgd2FudCB0byB0b3VjaCB0aGVtIGhlcmUpXG4gICAgT2JqZWN0LmtleXMoZWRnZXMpLmZvckVhY2goZGVwZW5kZW5jeUtleSA9PiB7XG4gICAgICBjb25zdCBleGlzdGluZ0VkZ2UgPSB0aGlzLm5vZGVzW2RlcGVuZGVuY3lLZXldLmRlcGVuZGVudHNba2V5XVxuXG4gICAgICBpZiAoZXhpc3RpbmdFZGdlLmZsYWdzICYgKEV4cGxpY2l0IHwgRXh0ZXJuYWwpKSByZXR1cm5cblxuICAgICAgY29uc3QgZWRnZVRvQWRkID0gZGVwZW5kZW5jaWVzW2RlcGVuZGVuY3lLZXldXG5cbiAgICAgIC8vIGVkZ2Ugc3RpbGwgZXhpc3RzOyBrZWVwIGl0XG4gICAgICBpZiAoZWRnZVRvQWRkICYmIGVkZ2VUb0FkZC5mbGFncyA9PT0gZXhpc3RpbmdFZGdlLmZsYWdzKSByZXR1cm5cblxuICAgICAgdGhpcy5yZW1vdmVFZGdlKGtleSwgZGVwZW5kZW5jeUtleSlcbiAgICB9KVxuXG4gICAgLy8gYWRkIG5ldyBlZGdlcyB0aGF0IHdlIHRyYWNrZWQgd2hpbGUgYnVmZmVyaW5nXG4gICAgT2JqZWN0LmtleXMoZGVwZW5kZW5jaWVzKS5mb3JFYWNoKGRlcGVuZGVuY3lLZXkgPT4ge1xuICAgICAgY29uc3QgZWRnZVRvQWRkID0gZGVwZW5kZW5jaWVzW2RlcGVuZGVuY3lLZXldXG4gICAgICBjb25zdCBleGlzdGluZ0VkZ2UgPSBlZGdlc1tkZXBlbmRlbmN5S2V5XVxuXG4gICAgICAvLyBlZGdlIGFscmVhZHkgZXhpc3RzOyBrZWVwIGl0XG4gICAgICBpZiAoZXhpc3RpbmdFZGdlKSByZXR1cm5cblxuICAgICAgdGhpcy5maW5pc2hBZGRpbmdFZGdlKGtleSwgZGVwZW5kZW5jeUtleSwgZWRnZVRvQWRkKVxuICAgIH0pXG5cbiAgICB0aGlzLnVwZGF0ZVN0YWNrLnBvcCgpXG4gIH1cblxuICBwdWJsaWMgZ2V0UmVmQ291bnQoZGVwZW5kZW5jeUtleTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubm9kZXNbZGVwZW5kZW5jeUtleV0/LmRlcGVuZGVudHMgfHwge30pLmxlbmd0aFxuICB9XG5cbiAgcHVibGljIHJlbW92ZURlcGVuZGVuY2llcyhkZXBlbmRlbnRLZXk6IHN0cmluZykge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVzW2RlcGVuZGVudEtleV1cblxuICAgIGlmICghbm9kZSkgcmV0dXJuIC8vIG5vZGUgYWxyZWFkeSBkZXN0cm95ZWRcblxuICAgIGNvbnN0IGVkZ2VzID0gbm9kZS5kZXBlbmRlbmNpZXNcblxuICAgIGlmICghZWRnZXMpIHJldHVyblxuXG4gICAgT2JqZWN0LmtleXMoZWRnZXMpLmZvckVhY2goZGVwZW5kZW5jeUtleSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZUVkZ2UoZGVwZW5kZW50S2V5LCBkZXBlbmRlbmN5S2V5KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogU2hvdWxkIG9ubHkgYmUgdXNlZCBpbnRlcm5hbGx5LiBSZW1vdmUgdGhlIGdyYXBoIGVkZ2UgYmV0d2VlbiB0d28gbm9kZXMuXG4gICAqIFRoZSBkZXBlbmRlbnQgbWF5IG5vdCBleGlzdCBhcyBhIG5vZGUgaW4gdGhlIGdyYXBoIGlmIGl0J3MgZXh0ZXJuYWwsIGUuZy4gYVxuICAgKiBSZWFjdCBjb21wb25lbnRcbiAgICpcbiAgICogRm9yIHNvbWUgcmVhc29uIGluIFJlYWN0IDE4KywgUmVhY3QgZGVzdHJveXMgcGFyZW50cyBiZWZvcmUgY2hpbGRyZW4uIFRoaXNcbiAgICogbWVhbnMgYSBwYXJlbnQgRWNvc3lzdGVtUHJvdmlkZXIgbWF5IGhhdmUgYWxyZWFkeSB1bm1vdW50ZWQgYW5kIHdpcGVkIHRoZVxuICAgKiB3aG9sZSBncmFwaDsgdGhpcyBlZGdlIG1heSBhbHJlYWR5IGJlIGRlc3Ryb3llZC5cbiAgICovXG4gIHB1YmxpYyByZW1vdmVFZGdlKGRlcGVuZGVudEtleTogc3RyaW5nLCBkZXBlbmRlbmN5S2V5OiBzdHJpbmcpIHtcbiAgICBjb25zdCBkZXBlbmRlbmN5ID0gdGhpcy5ub2Rlc1tkZXBlbmRlbmN5S2V5XVxuICAgIGNvbnN0IGRlcGVuZGVudCA9IHRoaXMubm9kZXNbZGVwZW5kZW50S2V5XSAvLyB3b24ndCBleGlzdCBpZiBleHRlcm5hbFxuXG4gICAgLy8gZXJhc2UgZ3JhcGggZWRnZSBiZXR3ZWVuIGRlcGVuZGVudCBhbmQgZGVwZW5kZW5jeVxuICAgIGlmIChkZXBlbmRlbnQpIHtcbiAgICAgIGRlbGV0ZSBkZXBlbmRlbnQuZGVwZW5kZW5jaWVzW2RlcGVuZGVuY3lLZXldXG4gICAgfVxuXG4gICAgLy8gaG1tIGNvdWxkIG1heWJlIGhhcHBlbiB3aGVuIGEgZGVwZW5kZW5jeSB3YXMgZm9yY2UtZGVzdHJveWVkIGlmIGEgY2hpbGRcbiAgICAvLyB0cmllcyB0byBkZXN0cm95IGl0cyBlZGdlIGJlZm9yZSByZWNyZWF0aW5nIGl0IChJIGRvbid0IHRoaW5rIHdlIGV2ZXIgZG9cbiAgICAvLyB0aGF0IHRob3VnaClcbiAgICBpZiAoIWRlcGVuZGVuY3kpIHJldHVyblxuXG4gICAgY29uc3QgZGVwZW5kZW50RWRnZSA9IGRlcGVuZGVuY3kuZGVwZW5kZW50c1tkZXBlbmRlbnRLZXldXG5cbiAgICAvLyBoYXBwZW5zIGluIFJlYWN0IDE4KyAoc2VlIHRoaXMgbWV0aG9kJ3MganNkb2MgYWJvdmUpXG4gICAgaWYgKCFkZXBlbmRlbnRFZGdlKSByZXR1cm5cbiAgICBkZWxldGUgZGVwZW5kZW5jeS5kZXBlbmRlbnRzW2RlcGVuZGVudEtleV1cblxuICAgIC8vIHN0YXRpYyBkZXBlbmRlbmNpZXMgZG9uJ3QgY2hhbmdlIGEgbm9kZSdzIHdlaWdodFxuICAgIGlmICghKGRlcGVuZGVudEVkZ2UuZmxhZ3MgJiBTdGF0aWMpKSB7XG4gICAgICB0aGlzLnJlY2FsY3VsYXRlTm9kZVdlaWdodChkZXBlbmRlbnRLZXksIC1kZXBlbmRlbmN5LndlaWdodClcbiAgICB9XG5cbiAgICBpZiAoZGVwZW5kZW50RWRnZS50YXNrKSB7XG4gICAgICB0aGlzLmVjb3N5c3RlbS5fc2NoZWR1bGVyLnVuc2NoZWR1bGUoZGVwZW5kZW50RWRnZS50YXNrKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmVjb3N5c3RlbS5fbW9kcy5lZGdlUmVtb3ZlZCkge1xuICAgICAgdGhpcy5lY29zeXN0ZW0ubW9kQnVzLmRpc3BhdGNoKFxuICAgICAgICBwbHVnaW5BY3Rpb25zLmVkZ2VSZW1vdmVkKHtcbiAgICAgICAgICBkZXBlbmRlbmN5OlxuICAgICAgICAgICAgdGhpcy5lY29zeXN0ZW0uX2luc3RhbmNlc1tkZXBlbmRlbmN5S2V5XSB8fFxuICAgICAgICAgICAgdGhpcy5lY29zeXN0ZW0uc2VsZWN0b3JDYWNoZS5faXRlbXNbZGVwZW5kZW5jeUtleV0sXG4gICAgICAgICAgZGVwZW5kZW50OlxuICAgICAgICAgICAgdGhpcy5lY29zeXN0ZW0uX2luc3RhbmNlc1tkZXBlbmRlbnRLZXldIHx8XG4gICAgICAgICAgICB0aGlzLmVjb3N5c3RlbS5zZWxlY3RvckNhY2hlLl9pdGVtc1tkZXBlbmRlbnRLZXldIHx8XG4gICAgICAgICAgICBkZXBlbmRlbnRLZXksXG4gICAgICAgICAgZWRnZTogZGVwZW5kZW50RWRnZSxcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLnNjaGVkdWxlTm9kZURlc3RydWN0aW9uKGRlcGVuZGVuY3lLZXkpXG4gIH1cblxuICAvLyBTaG91bGQgb25seSBiZSB1c2VkIGludGVybmFsbHlcbiAgcHVibGljIHJlbW92ZU5vZGUobm9kZUtleTogc3RyaW5nKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZXNbbm9kZUtleV1cblxuICAgIGlmICghbm9kZSkgcmV0dXJuIC8vIGFscmVhZHkgcmVtb3ZlZFxuXG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byByZW1vdmUgdGhpcyBkZXBlbmRlbnQgZnJvbSBpdHMgZGVwZW5kZW5jaWVzIGhlcmUgLSB0aGVcbiAgICAvLyBhdG9tIGluc3RhbmNlL0F0b21TZWxlY3RvciB3aWxsIGhhdmUgcmVtb3ZlZCBhbGwgaXRzIGRlcHMgYmVmb3JlIGNhbGxpbmdcbiAgICAvLyB0aGlzIGZ1bmN0aW9uIGFzIHBhcnQgb2YgaXRzIGRlc3RydWN0aW9uIHByb2Nlc3NcblxuICAgIC8vIGlmIGFuIGF0b20gaW5zdGFuY2UgaXMgZm9yY2UtZGVzdHJveWVkLCBpdCBjb3VsZCBzdGlsbCBoYXZlIGRlcGVuZGVudHMuXG4gICAgLy8gSW5mb3JtIHRoZW0gb2YgdGhlIGRlc3RydWN0aW9uXG4gICAgdGhpcy5zY2hlZHVsZURlcGVuZGVudHMoXG4gICAgICBub2RlS2V5LFxuICAgICAgW10sXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB1bmRlZmluZWQsXG4gICAgICB0cnVlLFxuICAgICAgJ25vZGUgZGVzdHJveWVkJyxcbiAgICAgICdEZXN0cm95ZWQnLFxuICAgICAgdHJ1ZVxuICAgIClcblxuICAgIC8vIFJlbW92ZSB0aGlzIGRlcGVuZGVuY3kgZnJvbSBhbGwgaXRzIGRlcGVuZGVudHMgYW5kIHJlY2FsY3VsYXRlIGFsbFxuICAgIC8vIHdlaWdodHMgcmVjdXJzaXZlbHlcbiAgICBPYmplY3Qua2V5cyhub2RlLmRlcGVuZGVudHMpLmZvckVhY2goZGVwZW5kZW50S2V5ID0+IHtcbiAgICAgIGNvbnN0IGRlcGVuZGVudEVkZ2UgPSBub2RlLmRlcGVuZGVudHNbZGVwZW5kZW50S2V5XVxuXG4gICAgICBpZiAoIShkZXBlbmRlbnRFZGdlLmZsYWdzICYgU3RhdGljKSkge1xuICAgICAgICB0aGlzLnJlY2FsY3VsYXRlTm9kZVdlaWdodChkZXBlbmRlbnRLZXksIC1ub2RlLndlaWdodClcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVwZW5kZW50Tm9kZSA9IHRoaXMubm9kZXNbZGVwZW5kZW50S2V5XVxuXG4gICAgICBpZiAoZGVwZW5kZW50Tm9kZSkgZGVsZXRlIGRlcGVuZGVudE5vZGUuZGVwZW5kZW5jaWVzW25vZGVLZXldXG4gICAgfSlcblxuICAgIGRlbGV0ZSB0aGlzLm5vZGVzW25vZGVLZXldXG4gIH1cblxuICAvKipcbiAgICogU2NoZWR1bGVzIGEgam9iIHRvIHVwZGF0ZSBhbGwgZGVwZW5kZW50cyBvZiBhIG5vZGUuIFRoaXMgaXMgY2FsbGVkIGUuZy5cbiAgICogd2hlbiBhbiBhdG9tIGluc3RhbmNlIG9yIEF0b21TZWxlY3RvciB1cGRhdGVzLCB3aGVuIGFuIGF0b20gaW5zdGFuY2UgaXNcbiAgICogZm9yY2UtZGVzdHJveWVkLCBvciB3aGVuIGFuIGF0b20gaW5zdGFuY2UncyBwcm9taXNlIGNoYW5nZXMuXG4gICAqL1xuICBwdWJsaWMgc2NoZWR1bGVEZXBlbmRlbnRzKFxuICAgIG5vZGVLZXk6IHN0cmluZyxcbiAgICByZWFzb25zOiBFdmFsdWF0aW9uUmVhc29uW10sXG4gICAgbmV3U3RhdGU6IGFueSxcbiAgICBvbGRTdGF0ZTogYW55LFxuICAgIHNob3VsZFNldFRpbWVvdXQ/OiBib29sZWFuLFxuICAgIHR5cGU6IEV2YWx1YXRpb25UeXBlID0gJ3N0YXRlIGNoYW5nZWQnLFxuICAgIHNpZ25hbDogR3JhcGhFZGdlU2lnbmFsID0gJ1VwZGF0ZWQnLFxuICAgIHNjaGVkdWxlU3RhdGljRGVwcyA9IGZhbHNlXG4gICkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5lY29zeXN0ZW0uX2luc3RhbmNlc1tub2RlS2V5XVxuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5lY29zeXN0ZW0uc2VsZWN0b3JDYWNoZS5faXRlbXNbbm9kZUtleV1cbiAgICBjb25zdCBub2RlID0gdGhpcy5ub2Rlc1tub2RlS2V5XVxuXG4gICAgT2JqZWN0LmtleXMobm9kZS5kZXBlbmRlbnRzKS5mb3JFYWNoKGRlcGVuZGVudEtleSA9PiB7XG4gICAgICBjb25zdCBkZXBlbmRlbnRFZGdlID0gbm9kZS5kZXBlbmRlbnRzW2RlcGVuZGVudEtleV1cblxuICAgICAgLy8gaWYgZWRnZS50YXNrIGV4aXN0cywgdGhpcyBlZGdlIGhhcyBhbHJlYWR5IGJlZW4gc2NoZWR1bGVkXG4gICAgICBpZiAoZGVwZW5kZW50RWRnZS50YXNrKSB7XG4gICAgICAgIGlmIChzaWduYWwgIT09ICdEZXN0cm95ZWQnKSByZXR1cm5cblxuICAgICAgICAvLyBkZXN0cnVjdGlvbiBqb2JzIHN1cGVyc2VkZSB1cGRhdGUgam9iczsgY2FuY2VsIHRoZSBleGlzdGluZyBqb2Igc28gd2VcbiAgICAgICAgLy8gY2FuIGNyZWF0ZSBhIG5ldyBvbmUgZm9yIHRoZSBkZXN0cnVjdGlvblxuICAgICAgICB0aGlzLmVjb3N5c3RlbS5fc2NoZWR1bGVyLnVuc2NoZWR1bGUoZGVwZW5kZW50RWRnZS50YXNrKVxuICAgICAgfVxuXG4gICAgICAvLyBTdGF0aWMgZGVwcyBkb24ndCB1cGRhdGUgb24gc3RhdGUgY2hhbmdlLiBEeW5hbWljIGRlcHMgZG9uJ3QgdXBkYXRlIG9uXG4gICAgICAvLyBwcm9taXNlIGNoYW5nZS4gQm90aCB0eXBlcyB1cGRhdGUgb24gaW5zdGFuY2UgZm9yY2UtZGVzdHJ1Y3Rpb25cbiAgICAgIGNvbnN0IGlzU3RhdGljID0gZGVwZW5kZW50RWRnZS5mbGFncyAmIFN0YXRpY1xuICAgICAgaWYgKGlzU3RhdGljICYmICFzY2hlZHVsZVN0YXRpY0RlcHMpIHJldHVyblxuXG4gICAgICBjb25zdCByZWFzb246IEV2YWx1YXRpb25SZWFzb24gPSB7XG4gICAgICAgIG5ld1N0YXRlLFxuICAgICAgICBvbGRTdGF0ZSxcbiAgICAgICAgb3BlcmF0aW9uOiBkZXBlbmRlbnRFZGdlLm9wZXJhdGlvbixcbiAgICAgICAgcmVhc29ucyxcbiAgICAgICAgc291cmNlS2V5OiBub2RlS2V5LFxuICAgICAgICBzb3VyY2VUeXBlOiBub2RlLmlzQXRvbVNlbGVjdG9yID8gJ0F0b21TZWxlY3RvcicgOiAnQXRvbScsXG4gICAgICAgIHR5cGUsXG4gICAgICB9XG5cbiAgICAgIC8vIGxldCBpbnRlcm5hbCBkZXBlbmRlbnRzIChvdGhlciBhdG9tcyBhbmQgQXRvbVNlbGVjdG9ycykgc2NoZWR1bGUgdGhlaXJcbiAgICAgIC8vIG93biBqb2JzXG4gICAgICBpZiAoIShkZXBlbmRlbnRFZGdlLmZsYWdzICYgRXh0ZXJuYWwpKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVzW2RlcGVuZGVudEtleV0uaXNBdG9tU2VsZWN0b3IpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lY29zeXN0ZW0uc2VsZWN0b3JDYWNoZS5fc2NoZWR1bGVFdmFsdWF0aW9uKFxuICAgICAgICAgICAgZGVwZW5kZW50S2V5LFxuICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgc2hvdWxkU2V0VGltZW91dFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmVjb3N5c3RlbS5faW5zdGFuY2VzW2RlcGVuZGVudEtleV0uX3NjaGVkdWxlRXZhbHVhdGlvbihcbiAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgc2hvdWxkU2V0VGltZW91dFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIC8vIHNjaGVkdWxlIGV4dGVybmFsIGRlcGVuZGVudHNcbiAgICAgIGNvbnN0IHRhc2sgPSAoKSA9PiB7XG4gICAgICAgIGRlcGVuZGVudEVkZ2UudGFzayA9IHVuZGVmaW5lZFxuICAgICAgICBkZXBlbmRlbnRFZGdlLmNhbGxiYWNrPy4oXG4gICAgICAgICAgc2lnbmFsLFxuICAgICAgICAgIGluc3RhbmNlID8gaW5zdGFuY2Uuc3RvcmUuZ2V0U3RhdGUoKSA6IGNhY2hlLnJlc3VsdCwgLy8gZG9uJ3QgdXNlIHRoZSBzbmFwc2hvdHRlZCBuZXdTdGF0ZSBhYm92ZVxuICAgICAgICAgIHJlYXNvblxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZWNvc3lzdGVtLl9zY2hlZHVsZXIuc2NoZWR1bGUoXG4gICAgICAgIHtcbiAgICAgICAgICBmbGFnczogZGVwZW5kZW50RWRnZS5mbGFncyxcbiAgICAgICAgICB0YXNrLFxuICAgICAgICAgIHR5cGU6IDMsIC8vIFVwZGF0ZUV4dGVybmFsRGVwZW5kZW50ICgzKVxuICAgICAgICB9LFxuICAgICAgICBzaG91bGRTZXRUaW1lb3V0XG4gICAgICApXG5cbiAgICAgIC8vIG11dGF0ZSB0aGUgZWRnZTsgZ2l2ZSBpdCB0aGUgc2NoZWR1bGVkIHRhc2sgc28gaXQgY2FuIGJlIGNsZWFuZWQgdXBcbiAgICAgIGRlcGVuZGVudEVkZ2UudGFzayA9IHRhc2tcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEFjdHVhbGx5IGFkZCBhbiBlZGdlIHRvIHRoZSBncmFwaC4gV2hlbiB3ZSBidWZmZXIgZ3JhcGggdXBkYXRlcywgd2UncmVcbiAgICogcmVhbGx5IGp1c3QgZGVmZXJyaW5nIHRoZSBjYWxsaW5nIG9mIHRoaXMgbWV0aG9kLlxuICAgKi9cbiAgcHJpdmF0ZSBmaW5pc2hBZGRpbmdFZGdlKFxuICAgIGRlcGVuZGVudEtleTogc3RyaW5nLFxuICAgIGRlcGVuZGVuY3lLZXk6IHN0cmluZyxcbiAgICBuZXdFZGdlOiBEZXBlbmRlbnRFZGdlXG4gICkge1xuICAgIGNvbnN0IGRlcGVuZGVuY3kgPSB0aGlzLm5vZGVzW2RlcGVuZGVuY3lLZXldXG5cbiAgICBpZiAoIWRlcGVuZGVuY3kpIHJldHVybiAvLyBoYXBwZW5lZCBvbmNlIGZvciBzb21lIHJlYXNvblxuXG4gICAgLy8gZHJhdyBncmFwaCBlZGdlIGJldHdlZW4gZGVwZW5kZW50IGFuZCBkZXBlbmRlbmN5XG4gICAgaWYgKCEobmV3RWRnZS5mbGFncyAmIEV4dGVybmFsKSkge1xuICAgICAgdGhpcy5ub2Rlc1tkZXBlbmRlbnRLZXldLmRlcGVuZGVuY2llc1tkZXBlbmRlbmN5S2V5XSA9IHRydWVcbiAgICB9XG4gICAgZGVwZW5kZW5jeS5kZXBlbmRlbnRzW2RlcGVuZGVudEtleV0gPSBuZXdFZGdlXG5cbiAgICB0aGlzLnVuc2NoZWR1bGVOb2RlRGVzdHJ1Y3Rpb24oZGVwZW5kZW5jeUtleSlcblxuICAgIC8vIHN0YXRpYyBkZXBlbmRlbmNpZXMgZG9uJ3QgY2hhbmdlIGEgbm9kZSdzIHdlaWdodFxuICAgIGlmICghKG5ld0VkZ2UuZmxhZ3MgJiBTdGF0aWMpKSB7XG4gICAgICB0aGlzLnJlY2FsY3VsYXRlTm9kZVdlaWdodChkZXBlbmRlbnRLZXksIGRlcGVuZGVuY3kud2VpZ2h0KVxuICAgIH1cblxuICAgIGlmICh0aGlzLmVjb3N5c3RlbS5fbW9kcy5lZGdlQ3JlYXRlZCkge1xuICAgICAgdGhpcy5lY29zeXN0ZW0ubW9kQnVzLmRpc3BhdGNoKFxuICAgICAgICBwbHVnaW5BY3Rpb25zLmVkZ2VDcmVhdGVkKHtcbiAgICAgICAgICBkZXBlbmRlbmN5OlxuICAgICAgICAgICAgdGhpcy5lY29zeXN0ZW0uX2luc3RhbmNlc1tkZXBlbmRlbmN5S2V5XSB8fFxuICAgICAgICAgICAgdGhpcy5lY29zeXN0ZW0uc2VsZWN0b3JDYWNoZS5faXRlbXNbZGVwZW5kZW5jeUtleV0sXG4gICAgICAgICAgZGVwZW5kZW50OlxuICAgICAgICAgICAgdGhpcy5lY29zeXN0ZW0uX2luc3RhbmNlc1tkZXBlbmRlbnRLZXldIHx8XG4gICAgICAgICAgICB0aGlzLmVjb3N5c3RlbS5zZWxlY3RvckNhY2hlLl9pdGVtc1tkZXBlbmRlbnRLZXldIHx8XG4gICAgICAgICAgICBkZXBlbmRlbnRLZXksIC8vIHVuZm9ydHVuYXRlIGJ1dCBub3QgY2hhbmdpbmcgZm9yIG5vdyBVUERBVEU6IHNob3VsZG4ndCBiZSBuZWVkZWQgYW55bW9yZS4gRG91YmxlIGNoZWNrXG4gICAgICAgICAgZWRnZTogbmV3RWRnZSxcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RWRnZVxuICB9XG5cbiAgLyoqXG4gICAqIFdoZW4gYSBub24tc3RhdGljIGVkZ2UgaXMgYWRkZWQgb3IgcmVtb3ZlZCwgZXZlcnkgbm9kZSBiZWxvdyB0aGF0IGVkZ2UgKHRoZVxuICAgKiBkZXBlbmRlbnQsIGl0cyBkZXBlbmRlbnRzLCBldGMpIGluIHRoZSBncmFwaCBuZWVkcyB0byBoYXZlIGl0cyB3ZWlnaHRcbiAgICogcmVjYWxjdWxhdGVkLlxuICAgKi9cbiAgcHJpdmF0ZSByZWNhbGN1bGF0ZU5vZGVXZWlnaHQobm9kZUtleTogc3RyaW5nLCB3ZWlnaHREaWZmOiBudW1iZXIpIHtcbiAgICBjb25zdCBub2RlID0gdGhpcy5ub2Rlc1tub2RlS2V5XVxuXG4gICAgaWYgKCFub2RlKSByZXR1cm4gLy8gaGFwcGVucyB3aGVuIG5vZGUgaXMgZXh0ZXJuYWxcblxuICAgIG5vZGUud2VpZ2h0ICs9IHdlaWdodERpZmZcblxuICAgIE9iamVjdC5rZXlzKG5vZGUuZGVwZW5kZW50cykuZm9yRWFjaChkZXBlbmRlbnRLZXkgPT4ge1xuICAgICAgdGhpcy5yZWNhbGN1bGF0ZU5vZGVXZWlnaHQoZGVwZW5kZW50S2V5LCB3ZWlnaHREaWZmKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogV2hlbiBhIG5vZGUncyByZWZDb3VudCBoaXRzIDAsIHNjaGVkdWxlIGRlc3RydWN0aW9uIG9mIHRoYXQgbm9kZS5cbiAgICovXG4gIHByaXZhdGUgc2NoZWR1bGVOb2RlRGVzdHJ1Y3Rpb24obm9kZUtleTogc3RyaW5nKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZXNbbm9kZUtleV1cblxuICAgIGlmIChub2RlICYmICFPYmplY3Qua2V5cyhub2RlLmRlcGVuZGVudHMpLmxlbmd0aCkge1xuICAgICAgaWYgKG5vZGUuaXNBdG9tU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5lY29zeXN0ZW0uc2VsZWN0b3JDYWNoZS5fZGVzdHJveVNlbGVjdG9yKG5vZGVLZXkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVjb3N5c3RlbS5faW5zdGFuY2VzW25vZGVLZXldLl9zY2hlZHVsZURlc3RydWN0aW9uKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogV2hlbiBhIG5vZGUncyByZWZDb3VudCBoaXRzIDAsIHdlIHNjaGVkdWxlIGRlc3RydWN0aW9uIG9mIHRoYXQgbm9kZS4gSWZcbiAgICogdGhhdCBkZXN0cnVjdGlvbiBpcyBzdGlsbCBwZW5kaW5nIGFuZCB0aGUgcmVmQ291bnQgZ29lcyBiYWNrIHVwIHRvIDEsXG4gICAqIGNhbmNlbCB0aGUgc2NoZWR1bGVkIGRlc3RydWN0aW9uLlxuICAgKi9cbiAgcHJpdmF0ZSB1bnNjaGVkdWxlTm9kZURlc3RydWN0aW9uKG5vZGVLZXk6IHN0cmluZykge1xuICAgIGNvbnN0IGRlcGVuZGVuY3kgPSB0aGlzLm5vZGVzW25vZGVLZXldXG5cbiAgICBpZiAoXG4gICAgICAhZGVwZW5kZW5jeS5pc0F0b21TZWxlY3RvciAmJlxuICAgICAgT2JqZWN0LmtleXMoZGVwZW5kZW5jeS5kZXBlbmRlbnRzKS5sZW5ndGggPT09IDFcbiAgICApIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5lY29zeXN0ZW0uX2luc3RhbmNlc1tub2RlS2V5XSBhcyBBbnlBdG9tSW5zdGFuY2VcblxuICAgICAgaW5zdGFuY2UuX2NhbmNlbERlc3RydWN0aW9uPy4oKVxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgaXMgfSBmcm9tICdAemVkdXgvY29yZSdcbmltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICdAemVkdXgvY29yZS91dGlscy9nZW5lcmFsJ1xuaW1wb3J0IHsgQXRvbUluc3RhbmNlQmFzZSB9IGZyb20gJy4vaW5zdGFuY2VzL0F0b21JbnN0YW5jZUJhc2UnXG5cbi8qKlxuICogV2hlbiB1c2luZyBTU1IsIG9ubHkgYGdlbmVyYXRlTm9kZUlkYCBzaG91bGQgYmUgYWxsb3dlZCB0byBydW4uIEl0IGlzIG9rYXlcbiAqIGZvciBgZ2VuZXJhdGVBdG9tU2VsZWN0b3JJZGAgdG8gcnVuLCBidXQgYXV0by1pZCdkIHNlbGVjdG9ycyB3b24ndCBiZVxuICogaHlkcmF0YWJsZSBvbiB0aGUgY2xpZW50ICh1c3VhbGx5IGZpbmUgZm9yIGlubGluZSBzZWxlY3RvcnMpLiBFY29zeXN0ZW0gaWRzXG4gKiBtdXN0IGJlIHNldCBtYW51YWxseVxuICpcbiAqIFRvIHByZXZlbnQgWmVkdXggZnJvbSBhdXRvLWlkJ2luZyBBdG9tU2VsZWN0b3JzLCB1c2UgYSBzaGFyZWQgZnVuY3Rpb25cbiAqIHJlZmVyZW5jZS4gV2hlbiB1c2luZyBBdG9tU2VsZWN0b3JDb25maWcgb2JqZWN0cywgbWFrZSBzdXJlIHRoZSBvYmplY3RcbiAqIHJlZmVyZW5jZSBpdHNlbGYgaXMgc2hhcmVkLiBJbiBib3RoIGNhc2VzLCB0aGUgZnVuY3Rpb24gbXVzdCBoYXZlIGEgdW5pcXVlXG4gKiBuYW1lLlxuICpcbiAqIGBgYHRzXG4gKiAvLyBleGFtcGxlcyB0aGF0IHdpbGwgYmUgYXV0by1pZCdkOlxuICogdXNlQXRvbVNlbGVjdG9yKCh7IGdldCB9KSA9PiBnZXQobXlBdG9tKSkgLy8gaW5saW5lIGZ1bmN0aW9uIHJlZiBjYW4ndCBiZSBzaGFyZWQgYW5kIGhhcyBubyBuYW1lXG4gKiBjb25zdCBteVNlbGVjdG9yID0geyAvLyB0aGlzIG9iamVjdCByZWZlcmVuY2UgY2FuIGJlIHNoYXJlZC4uLlxuICogICBzZWxlY3RvcjogKHsgZ2V0IH0pID0+IGdldChteUF0b20pIC8vIC4uLmJ1dCB0aGUgZnVuY3Rpb24gaGFzIGEgZ2VuZXJpYyBuYW1lXG4gKiB9XG4gKlxuICogLy8gZXhhbXBsZXMgd2hlcmUgaWRzIHdpbGwgYmUgZ2VuZXJhdGVkIHByZWRpY3RhYmx5IGJhc2VkIG9uIHBhcmFtczpcbiAqIGNvbnN0IG15U2VsZWN0b3IgPSAoeyBnZXQgfSkgPT4gZ2V0KG15QXRvbSkgLy8gZnVuY3Rpb24gaGFzIGEgbmFtZSBhbmQgcmVmIGNhbiBiZSBzaGFyZWRcbiAqIGNvbnN0IG15U2VsZWN0b3IgPSB7IC8vIHRoaXMgcmVmIGNhbiBiZSBzaGFyZWQuLi5cbiAqICAgc2VsZWN0b3I6IGZ1bmN0aW9uIG15U2VsZWN0b3IoeyBnZXQgfSkgeyAvLyAuLi5hbmQgdGhlIGZ1bmN0aW9uIGhhcyBhIG5hbWVcbiAqICAgICByZXR1cm4gZ2V0KG15QXRvbSlcbiAqICAgfVxuICogfVxuICogY29uc3QgbXlTZWxlY3RvciA9IHsgLy8gdGhpcyByZWYgY2FuIGJlIHNoYXJlZC4uLlxuICogICBuYW1lOiAnbXlTZWxlY3RvcicsIC8vIC4uLmFuZCB3ZSBzZXQgdGhlIGBuYW1lYCBjb25maWcgb3B0aW9uXG4gKiAgIHNlbGVjdG9yOiAoeyBnZXQgfSkgPT4gZ2V0KG15QXRvbSlcbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSWRHZW5lcmF0b3Ige1xuICBwdWJsaWMgaWRDb3VudGVyID0gMFxuXG4gIC8qKlxuICAgKiBDYWNoZSBmdW5jdGlvbiBhbmQgY2xhc3MgaW5zdGFuY2UgcmVmZXJlbmNlcyB0aGF0IGdldCBwYXNzZWQgYXMgcGFyYW1zIHRvXG4gICAqIGF0b21zIG9yIEF0b21TZWxlY3RvcnMuIE1hcCB0aGVtIHRvIGEgdW5pcXVlLCBzZXJpYWxpemFibGUgaWQuIFVzZSBhXG4gICAqIFdlYWtNYXAgc28gd2UgZG9uJ3QgaG9sZCBvbiB0byBhbnl0aGluZyBoZXJlXG4gICAqL1xuICBwdWJsaWMgd2Vha0NhY2hlID0gbmV3IFdlYWtNYXA8YW55LCBzdHJpbmc+KClcblxuICBwdWJsaWMgZ2VuZXJhdGVBdG9tU2VsZWN0b3JJZChuYW1lID0gJycpIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgIG5hbWUgPSBERVYgPyAndW5rbm93blNlbGVjdG9yJyA6ICdhcydcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUlkKGBAQHNlbGVjdG9yLSR7bmFtZX1gKVxuICB9XG5cbiAgcHVibGljIGdlbmVyYXRlRWNvc3lzdGVtSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVJZCgnZXMnKVxuICB9XG5cbiAgcHVibGljIGdlbmVyYXRlSWQgPSAocHJlZml4OiBzdHJpbmcpID0+XG4gICAgYCR7cHJlZml4fS0keysrdGhpcy5pZENvdW50ZXJ9JHtNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDE2KS5zbGljZSgyLCAxNCl9YFxuXG4gIHB1YmxpYyBnZW5lcmF0ZU5vZGVJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZW5lcmF0ZUlkKCdubycpXG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBncmFwaCBub2RlIGtleSBmb3IgYSBSZWFjdCBjb21wb25lbnRcbiAgICovXG4gIHB1YmxpYyBnZW5lcmF0ZVJlYWN0Q29tcG9uZW50SWQoKSB7XG4gICAgaWYgKCFERVYpIHJldHVybiB0aGlzLmdlbmVyYXRlSWQoJ3JjJylcblxuICAgIGNvbnN0IHsgc3RhY2sgfSA9IG5ldyBFcnJvcigpXG5cbiAgICBpZiAoIXN0YWNrKSByZXR1cm4gJydcblxuICAgIGNvbnN0IGxpbmVzID0gc3RhY2tcbiAgICAgIC5zcGxpdCgnXFxuJylcbiAgICAgIC5zbGljZSgyKVxuICAgICAgLm1hcChsaW5lID0+XG4gICAgICAgIGxpbmVcbiAgICAgICAgICAudHJpbSgpXG4gICAgICAgICAgLnJlcGxhY2UoJ2F0ICcsICcnKVxuICAgICAgICAgIC5yZXBsYWNlKC8gXFwoLipcXCkvLCAnJylcbiAgICAgIClcblxuICAgIGNvbnN0IGNvbXBvbmVudE5hbWUgPSBsaW5lc1xuICAgICAgLmZpbmQobGluZSA9PiB7XG4gICAgICAgIGlmICghL1xcdy8udGVzdChsaW5lWzBdKSkgcmV0dXJuIGZhbHNlXG5cbiAgICAgICAgY29uc3QgaWRlbnRpZmllcnMgPSBsaW5lLnNwbGl0KCcuJylcbiAgICAgICAgY29uc3QgZm4gPSBpZGVudGlmaWVyc1tpZGVudGlmaWVycy5sZW5ndGggLSAxXVxuICAgICAgICByZXR1cm4gZm5bMF0udG9VcHBlckNhc2UoKSA9PT0gZm5bMF1cbiAgICAgIH0pXG4gICAgICA/LnNwbGl0KCcgJylbMF1cblxuICAgIHJldHVybiB0aGlzLmdlbmVyYXRlSWQoY29tcG9uZW50TmFtZSB8fCAnVW5rbm93bkNvbXBvbmVudCcpXG4gIH1cblxuICAvKipcbiAgICogVHVybiBhbiBhcnJheSBvZiBhbnl0aGluZyBpbnRvIGEgcHJlZGljdGFibGUgc3RyaW5nLiBJZiBhbnkgaXRlbSBpcyBhbiBhdG9tXG4gICAqIGluc3RhbmNlLCBpdCB3aWxsIGJlIHNlcmlhbGl6ZWQgYXMgdGhlIGluc3RhbmNlJ3Mga2V5SGFzaC4gSWZcbiAgICogYWNjZXB0Q29tcGxleFBhcmFtcyBpcyB0cnVlLCBtYXAgY2xhc3MgaW5zdGFuY2VzIGFuZCBmdW5jdGlvbnMgdG8gYVxuICAgKiBjb25zaXN0ZW50IGlkIGZvciB0aGUgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgcmVjdXJzaXZlIG9iamVjdHMgYXJlIG5vdCBzdXBwb3J0ZWQgLSB0aGV5IHdvdWxkIGFkZCB3YXkgdG9vIG11Y2hcbiAgICogb3ZlcmhlYWQgaGVyZSBhbmQgYXJlIHJlYWxseSBqdXN0IHVubmVjZXNzYXJ5LlxuICAgKi9cbiAgcHVibGljIGhhc2hQYXJhbXMocGFyYW1zOiBhbnlbXSwgYWNjZXB0Q29tcGxleFBhcmFtcz86IGJvb2xlYW4pOiBzdHJpbmcge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJhbXMsIChfLCBwYXJhbSkgPT4ge1xuICAgICAgaWYgKGlzKHBhcmFtLCBBdG9tSW5zdGFuY2VCYXNlKSkgcmV0dXJuIHBhcmFtLmtleUhhc2hcbiAgICAgIGlmICghcGFyYW0pIHJldHVybiBwYXJhbVxuICAgICAgaWYgKCFpc1BsYWluT2JqZWN0KHBhcmFtKSkge1xuICAgICAgICBpZiAoIWFjY2VwdENvbXBsZXhQYXJhbXMgfHwgQXJyYXkuaXNBcnJheShwYXJhbSkpIHJldHVybiBwYXJhbVxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtID09PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5jYWNoZUZuKHBhcmFtKVxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtPy5jb25zdHJ1Y3RvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmNhY2hlQ2xhc3MocGFyYW0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyYW0gLy8gbGV0IGVuZ2luZSB0cnkgcmVzb2x2ZSBpdCBvciB0aHJvdyB0aGUgZXJyb3JcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtKVxuICAgICAgICAuc29ydCgpXG4gICAgICAgIC5yZWR1Y2UoKHJlc3VsdCwga2V5KSA9PiB7XG4gICAgICAgICAgcmVzdWx0W2tleV0gPSBwYXJhbVtrZXldXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9LCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBhbnk+KVxuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIGNhY2hlQ2xhc3MoaW5zdGFuY2U6IHsgbmV3ICgpOiBhbnkgfSkge1xuICAgIGxldCBpZCA9IHRoaXMud2Vha0NhY2hlLmdldChpbnN0YW5jZSlcbiAgICBpZiAoaWQpIHJldHVybiBpZFxuXG4gICAgaWQgPSB0aGlzLmdlbmVyYXRlSWQoaW5zdGFuY2UuY29uc3RydWN0b3IubmFtZSB8fCAnVW5rbm93bkNsYXNzJylcbiAgICB0aGlzLndlYWtDYWNoZS5zZXQoaW5zdGFuY2UsIGlkKVxuXG4gICAgcmV0dXJuIGlkXG4gIH1cblxuICBwcml2YXRlIGNhY2hlRm4oZm46ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55KSB7XG4gICAgbGV0IGlkID0gdGhpcy53ZWFrQ2FjaGUuZ2V0KGZuKVxuICAgIGlmIChpZCkgcmV0dXJuIGlkXG5cbiAgICBpZCA9IHRoaXMuZ2VuZXJhdGVJZChmbi5uYW1lIHx8ICdhbm9uRm4nKVxuICAgIHRoaXMud2Vha0NhY2hlLnNldChmbiwgaWQpXG5cbiAgICByZXR1cm4gaWRcbiAgfVxufVxuIiwiaW1wb3J0IHsgSm9iLCBTY2hlZHVsZXIgYXMgU2NoZWR1bGVySW50ZXJmYWNlIH0gZnJvbSAnQHplZHV4L2NvcmUnXG5pbXBvcnQgeyBFY29zeXN0ZW0gfSBmcm9tICcuL0Vjb3N5c3RlbSdcblxuZXhwb3J0IGNsYXNzIFNjaGVkdWxlciBpbXBsZW1lbnRzIFNjaGVkdWxlckludGVyZmFjZSB7XG4gIC8vIHByaXZhdGUgX3J1blN0YXJ0VGltZT86IG51bWJlclxuICBwcml2YXRlIGpvYnM6IEpvYltdID0gW11cbiAgcHJpdmF0ZSBfam9iVGltZW91dElkPzogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD5cbiAgcHJpdmF0ZSBfaXNSdW5uaW5nPzogYm9vbGVhblxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgZWNvc3lzdGVtOiBFY29zeXN0ZW0pIHt9XG5cbiAgLyoqXG4gICAqIEtpbGwgYW55IGN1cnJlbnQgdGltZW91dCBhbmQgcnVuIGFsbCBqb2JzIGltbWVkaWF0ZWx5LlxuICAgKlxuICAgKiBJTVBPUlRBTlQ6IFNldHRpbmcgYW5kIGNsZWFyaW5nIHRpbWVvdXRzIGlzIGV4cGVuc2l2ZS4gV2UgbmVlZCB0byBhbHdheXNcbiAgICogcGFzcyBgc2hvdWxkU2V0VGltZW91dDogZmFsc2VgIHRvIHNjaGVkdWxlci5zY2hlZHVsZSgpIHdoZW4gd2UncmUgZ29pbmdcbiAgICogdG8gaW1tZWRpYXRlbHkgZmx1c2hcbiAgICovXG4gIHB1YmxpYyBmbHVzaCgpIHtcbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSByZXR1cm4gLy8gYWxyZWFkeSBmbHVzaGluZ1xuICAgIGlmICh0aGlzLl9qb2JUaW1lb3V0SWQpIGNsZWFyVGltZW91dCh0aGlzLl9qb2JUaW1lb3V0SWQpXG5cbiAgICB0aGlzLnJ1bkpvYnMoKVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCBhIGpvYiBpbnRvIHRoZSBxdWV1ZS4gSW5zZXJ0aW9uIHBvaW50IGRlcGVuZHMgb24gam9iJ3MgdHlwZSBhbmRcbiAgICogd2VpZ2h0LlxuICAgKlxuICAgKiBJTVBPUlRBTlQ6IFNldHRpbmcgYW5kIGNsZWFyaW5nIHRpbWVvdXRzIGlzIGV4cGVuc2l2ZS4gV2UgbmVlZCB0byBhbHdheXNcbiAgICogcGFzcyBgc2hvdWxkU2V0VGltZW91dDogZmFsc2VgIHdoZW4gd2UncmUgZ29pbmcgdG8gaW1tZWRpYXRlbHkgZmx1c2hcbiAgICovXG4gIHB1YmxpYyBzY2hlZHVsZShuZXdKb2I6IEpvYiwgc2hvdWxkU2V0VGltZW91dCA9IHRydWUpIHtcbiAgICBpZiAobmV3Sm9iLnR5cGUgPT09IDQpIHtcbiAgICAgIC8vIFJ1bkVmZmVjdCAoNCkgam9icyBydW4gaW4gYW55IG9yZGVyLCBhZnRlciBldmVyeXRoaW5nIGVsc2VcbiAgICAgIHRoaXMuam9icy5wdXNoKG5ld0pvYilcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcy5lY29zeXN0ZW0uX2dyYXBoXG4gICAgICBjb25zdCBmbGFncyA9IG5ld0pvYi5mbGFncyA/PyAwXG4gICAgICBjb25zdCB3ZWlnaHQgPSBuZXdKb2Iua2V5SGFzaCA/IG5vZGVzW25ld0pvYi5rZXlIYXNoXS53ZWlnaHQgOiAwXG5cbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5maW5kSW5kZXgoam9iID0+IHtcbiAgICAgICAgaWYgKGpvYi50eXBlICE9PSBuZXdKb2IudHlwZSkgcmV0dXJuICsobmV3Sm9iLnR5cGUgLSBqb2IudHlwZSA+IDApIHx8IC0xIC8vIDEgb3IgLTFcblxuICAgICAgICAvLyBhIGpvYiB0eXBlIGNhbiB1c2UgZWl0aGVyIHdlaWdodCBvciBmbGFncyBjb21wYXJpc29uIG9yIG5laXRoZXJcbiAgICAgICAgaWYgKGpvYi5rZXlIYXNoKSB7XG4gICAgICAgICAgY29uc3Qgam9iV2VpZ2h0ID0gbm9kZXNbam9iLmtleUhhc2hdLndlaWdodFxuXG4gICAgICAgICAgcmV0dXJuIHdlaWdodCA8IGpvYldlaWdodCA/IC0xIDogKyh3ZWlnaHQgPiBqb2JXZWlnaHQpIC8vICsgPSAwIG9yIDFcbiAgICAgICAgfSBlbHNlIGlmIChqb2IuZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmbGFncyA8IGpvYi5mbGFncyA/IC0xIDogKyhmbGFncyA+IGpvYi5mbGFncylcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwXG4gICAgICB9KVxuXG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRoaXMuam9icy5wdXNoKG5ld0pvYilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuam9icy5zcGxpY2UoaW5kZXgsIDAsIG5ld0pvYilcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSBqdXN0IHB1c2hlZCB0aGUgZmlyc3Qgam9iIG9udG8gdGhlIHF1ZXVlXG4gICAgaWYgKHNob3VsZFNldFRpbWVvdXQgJiYgdGhpcy5qb2JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdGhpcy5zZXRUaW1lb3V0KClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU29tZSBqb2JzICh1cGRhdGUgc3RvcmUgam9icykgbXVzdCBydW4gaW1tZWRpYXRlbHkgYnV0IGFsc28gbmVlZCB0aGVcbiAgICogc2NoZWR1bGVyIHRvIGJlIHJ1bm5pbmcuXG4gICAqXG4gICAqIE90aGVyIGpvYnMgKGluZm9ybSBzdWJzY3JpYmVyIGpvYnMpIG11c3QgcnVuIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjdXJyZW50XG4gICAqIHRhc2suIFRoaXMgaXMgZG9uZSBieSBwYXNzaW5nIGBmYWxzZWAgZm9yIHRoZSAybmQgcGFyYW0uXG4gICAqL1xuICBwdWJsaWMgc2NoZWR1bGVOb3cobmV3Sm9iOiBKb2IsIHJ1bklmUnVubmluZyA9IHRydWUpIHtcbiAgICBpZiAodGhpcy5faXNSdW5uaW5nID09PSBydW5JZlJ1bm5pbmcpIHJldHVybiBuZXdKb2IudGFzaygpXG4gICAgdGhpcy5qb2JzLnVuc2hpZnQobmV3Sm9iKVxuICAgIHRoaXMuZmx1c2goKVxuICB9XG5cbiAgcHVibGljIHVuc2NoZWR1bGUodGFzazogKCkgPT4gdm9pZCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5qb2JzLmZpbmRJbmRleChqb2IgPT4gam9iLnRhc2sgPT09IHRhc2spXG5cbiAgICBpZiAoaW5kZXggIT09IC0xKSB0aGlzLmpvYnMuc3BsaWNlKGluZGV4LCAxKVxuICB9XG5cbiAgcHVibGljIHdpcGUoKSB7XG4gICAgLy8gYWxsb3cgZXh0ZXJuYWwgam9icyB0byBwcm9jZWVkLiBUT0RPOiBzaG91bGQgd2UgZmx1c2ggaGVyZT9cbiAgICB0aGlzLmpvYnMgPSB0aGlzLmpvYnMuZmlsdGVyKFxuICAgICAgam9iID0+IGpvYi50eXBlID09PSAzIC8vIFVwZGF0ZUV4dGVybmFsRGVwZW5kZW50ICgzKVxuICAgIClcbiAgfVxuXG4gIC8vIEFuIE8obG9nIG4pIHJlcGxhY2VtZW50IGZvciB0aGlzLmpvYnMuZmluZEluZGV4KClcbiAgcHJpdmF0ZSBmaW5kSW5kZXgoXG4gICAgY2I6IChqb2I6IEpvYikgPT4gbnVtYmVyLFxuICAgIGluZGV4ID0gTWF0aC5jZWlsKHRoaXMuam9icy5sZW5ndGggLyAyKSAtIDEsXG4gICAgaXRlcmF0aW9uID0gMVxuICApOiBudW1iZXIge1xuICAgIGNvbnN0IGpvYiA9IHRoaXMuam9ic1tpbmRleF1cbiAgICBpZiAoam9iID09IG51bGwpIHJldHVybiBpbmRleFxuXG4gICAgY29uc3QgZGlyZWN0aW9uID0gY2Ioam9iKVxuICAgIGlmICghZGlyZWN0aW9uKSByZXR1cm4gaW5kZXhcblxuICAgIGNvbnN0IGRpdmlzb3IgPSAyICoqIGl0ZXJhdGlvblxuICAgIGNvbnN0IGlzRG9uZSA9IGRpdmlzb3IgPiB0aGlzLmpvYnMubGVuZ3RoXG5cbiAgICBpZiAoaXNEb25lKSB7XG4gICAgICByZXR1cm4gaW5kZXggKyAoZGlyZWN0aW9uID09PSAxID8gMSA6IDApXG4gICAgfVxuXG4gICAgY29uc3QgZWZmZWN0dWFsU2l6ZSA9IE1hdGgucm91bmQodGhpcy5qb2JzLmxlbmd0aCAvIGRpdmlzb3IpXG4gICAgY29uc3QgbmV3SW5kZXggPSBNYXRoLm1pbihcbiAgICAgIHRoaXMuam9icy5sZW5ndGggLSAxLFxuICAgICAgTWF0aC5tYXgoMCwgaW5kZXggKyBNYXRoLmNlaWwoZWZmZWN0dWFsU2l6ZSAvIDIpICogZGlyZWN0aW9uKVxuICAgIClcblxuICAgIHJldHVybiB0aGlzLmZpbmRJbmRleChjYiwgbmV3SW5kZXgsIGl0ZXJhdGlvbiArIDEpXG4gIH1cblxuICBwcml2YXRlIHJ1bkpvYnMoKSB7XG4gICAgdGhpcy5fam9iVGltZW91dElkID0gdW5kZWZpbmVkXG4gICAgLy8gdGhpcy5fcnVuU3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAvLyBsZXQgY291bnRlciA9IDBcblxuICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWVcbiAgICB3aGlsZSAodGhpcy5qb2JzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgam9iID0gdGhpcy5qb2JzLnNoaWZ0KCkgYXMgSm9iXG4gICAgICBqb2IudGFzaygpXG5cbiAgICAgIC8vIHRoaXMgXCJicmVha1wiIGlkZWEgd291bGQgbmVlZCB0byBvbmx5IGJyZWFrIGlmIHRoZSBuZXh0IGpvYiBpc1xuICAgICAgLy8gaW50ZXJydXB0aWJsZSAoc3RvcmUgdXBkYXRlcyAtIHRoZSBoaWdoZXN0LXByaW8gdGFza3MgLSBhcmUgbm90XG4gICAgICAvLyBpbnRlcnJ1cHRpYmxlKVxuICAgICAgLy8gaWYgKCEoKytjb3VudGVyICUgMjApICYmIHBlcmZvcm1hbmNlLm5vdygpIC0gdGhpcy5fcnVuU3RhcnRUaW1lID49IDEwMCkge1xuICAgICAgLy8gICBzZXRUaW1lb3V0KCgpID0+IHRoaXMucnVuSm9icygpKVxuICAgICAgLy8gICBicmVha1xuICAgICAgLy8gfVxuICAgIH1cbiAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZVxuICB9XG5cbiAgcHJpdmF0ZSBzZXRUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHJldHVyblxuXG4gICAgdGhpcy5fam9iVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnJ1bkpvYnMoKVxuICAgIH0pXG4gIH1cbn1cbiIsImltcG9ydCB7IGlzIH0gZnJvbSAnQHplZHV4L2NvcmUnXG5pbXBvcnQge1xuICBBdG9tU2VsZWN0b3JDb25maWcsXG4gIEF0b21TZWxlY3Rvck9yQ29uZmlnLFxuICBDbGVhbnVwLFxuICBEZXBlbmRlbnRDYWxsYmFjayxcbiAgRXZhbHVhdGlvblJlYXNvbixcbiAgU2VsZWN0YWJsZSxcbn0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBFeHBsaWNpdCwgRXh0ZXJuYWwsIHByZWZpeCB9IGZyb20gJy4uL3V0aWxzJ1xuaW1wb3J0IHsgcGx1Z2luQWN0aW9ucyB9IGZyb20gJy4uL3V0aWxzL3BsdWdpbi1hY3Rpb25zJ1xuaW1wb3J0IHsgRWNvc3lzdGVtIH0gZnJvbSAnLi9FY29zeXN0ZW0nXG5cbmNvbnN0IGRlZmF1bHRSZXN1bHRzQ29tcGFyYXRvciA9IChhOiBhbnksIGI6IGFueSkgPT4gYSA9PT0gYlxuXG5leHBvcnQgY2xhc3MgU2VsZWN0b3JDYWNoZUl0ZW08VCA9IGFueSwgQXJncyBleHRlbmRzIGFueVtdID0gYW55W10+IHtcbiAgcHVibGljIHN0YXRpYyAkJHR5cGVvZiA9IFN5bWJvbC5mb3IoYCR7cHJlZml4fS9TZWxlY3RvckNhY2hlYClcbiAgcHVibGljIGlzRGVzdHJveWVkPzogYm9vbGVhblxuICBwdWJsaWMgbmV4dEV2YWx1YXRpb25SZWFzb25zOiBFdmFsdWF0aW9uUmVhc29uW10gPSBbXVxuICBwdWJsaWMgcHJldkV2YWx1YXRpb25SZWFzb25zPzogRXZhbHVhdGlvblJlYXNvbltdXG4gIHB1YmxpYyByZXN1bHQ/OiBUXG4gIHB1YmxpYyB0YXNrPzogKCkgPT4gdm9pZFxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjYWNoZUtleTogc3RyaW5nLFxuICAgIHB1YmxpYyBzZWxlY3RvclJlZjogQXRvbVNlbGVjdG9yT3JDb25maWc8VCwgQXJncz4sXG4gICAgcHVibGljIGFyZ3M/OiBBcmdzXG4gICkge31cbn1cblxuLyoqXG4gKiBTaW5jZSBBdG9tU2VsZWN0b3JzIGFyZSBtZWFudCB0byBmZWVsIGxpZ2h0d2VpZ2h0LCB0aGV5IGRvbid0IGhhdmUgdG8gYmVcbiAqIGluc3RhbmNlcyBvZiBhIGNsYXNzIC0gdGhleSdsbCBvZnRlbiBiZSBzdGFuZGFsb25lIG9yIGV2ZW4gaW5saW5lXG4gKiBmdW5jdGlvbnMuIFRoaXMgY2xhc3MgaGFuZGxlcyBhbGwgdGhlIGxvZ2ljIHRoYXQgQXRvbVNlbGVjdG9ycyB3b3VsZCBoYW5kbGVcbiAqIHRoZW1zZWx2ZXMgaWYgdGhleSB3ZXJlIGNsYXNzZXMgLSBjcmVhdGlvbiwgY2FjaGUgbWFuYWdlbWVudCwgYW5kXG4gKiBkZXN0cnVjdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFNlbGVjdG9yQ2FjaGUge1xuICAvKipcbiAgICogTWFwIHNlbGVjdG9yS2V5K3BhcmFtcyBrZXlIYXNoIHN0cmluZ3MgdG8gdGhlIGNhY2hlZCBwYXJhbXMgYW5kIHJlc3VsdCBmb3JcbiAgICogdGhlIHNlbGVjdG9yXG4gICAqL1xuICBwdWJsaWMgX2l0ZW1zOiBSZWNvcmQ8c3RyaW5nLCBTZWxlY3RvckNhY2hlSXRlbTxhbnksIGFueT4+ID0ge31cblxuICAvKipcbiAgICogTWFwIHNlbGVjdG9ycyAob3Igc2VsZWN0b3IgY29uZmlnIG9iamVjdHMpIHRvIGEgYmFzZSBzZWxlY3RvcktleSB0aGF0IGNhblxuICAgKiBiZSB1c2VkIHRvIHByZWRpY3RhYmx5IGNyZWF0ZSBzZWxlY3RvcktleStwYXJhbXMga2V5SGFzaGVzIHRvIGxvb2sgdXAgdGhlXG4gICAqIGNhY2hlIGluIGB0aGlzLl9pdGVtc2BcbiAgICovXG4gIHB1YmxpYyBfcmVmQmFzZUtleXMgPSBuZXcgV2Vha01hcDxBdG9tU2VsZWN0b3JPckNvbmZpZzxhbnksIGFueT4sIHN0cmluZz4oKVxuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgZWNvc3lzdGVtOiBFY29zeXN0ZW0pIHt9XG5cbiAgcHVibGljIGFkZERlcGVuZGVudChcbiAgICBjYWNoZUl0ZW06IFNlbGVjdG9yQ2FjaGVJdGVtPGFueSwgYW55PixcbiAgICB7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG9wZXJhdGlvbiA9ICdhZGREZXBlbmRlbnQnLFxuICAgIH06IHtcbiAgICAgIGNhbGxiYWNrPzogRGVwZW5kZW50Q2FsbGJhY2tcbiAgICAgIG9wZXJhdGlvbj86IHN0cmluZ1xuICAgIH0gPSB7fVxuICApOiBDbGVhbnVwIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuZWNvc3lzdGVtLl9pZEdlbmVyYXRvci5nZW5lcmF0ZU5vZGVJZCgpXG4gICAgdGhpcy5lY29zeXN0ZW0uX2dyYXBoLmFkZEVkZ2UoXG4gICAgICBpZCxcbiAgICAgIGNhY2hlSXRlbS5jYWNoZUtleSxcbiAgICAgIG9wZXJhdGlvbixcbiAgICAgIEV4cGxpY2l0IHwgRXh0ZXJuYWwsXG4gICAgICBjYWxsYmFja1xuICAgIClcblxuICAgIHJldHVybiAoKSA9PiB0aGlzLmVjb3N5c3RlbS5fZ3JhcGgucmVtb3ZlRWRnZShpZCwgY2FjaGVJdGVtLmNhY2hlS2V5KVxuICB9XG5cbiAgcHVibGljIGRlc3Ryb3lDYWNoZTxUID0gYW55LCBBcmdzIGV4dGVuZHMgW10gPSBbXT4oXG4gICAgc2VsZWN0YWJsZTogU2VsZWN0YWJsZTxULCBBcmdzPlxuICApOiB2b2lkXG5cbiAgcHVibGljIGRlc3Ryb3lDYWNoZTxUID0gYW55LCBBcmdzIGV4dGVuZHMgYW55W10gPSBbXT4oXG4gICAgc2VsZWN0YWJsZTogU2VsZWN0YWJsZTxULCBBcmdzPixcbiAgICBhcmdzOiBBcmdzLFxuICAgIGZvcmNlPzogYm9vbGVhblxuICApOiB2b2lkXG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoZSBjYWNoZSBmb3IgdGhlIGdpdmVuIHNlbGVjdG9yICsgYXJncyBjb21ibyAoaWYgaXQgZXhpc3RzKS5cbiAgICpcbiAgICogRGVzdHJ1Y3Rpb24gYmFpbHMgb3V0IGJ5IGRlZmF1bHQgaWYgdGhlIHNlbGVjdG9yJ3MgcmVmIGNvdW50IGlzID4gMC4gUGFzc1xuICAgKiBgdHJ1ZWAgYXMgdGhlIDNyZCBwYXJhbSB0byBmb3JjZSBkZXN0cnVjdGlvbi5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95Q2FjaGU8VCA9IGFueSwgQXJncyBleHRlbmRzIGFueVtdID0gW10+KFxuICAgIHNlbGVjdGFibGU6IFNlbGVjdGFibGU8VCwgQXJncz4sXG4gICAgYXJncz86IEFyZ3MsXG4gICAgZm9yY2U/OiBib29sZWFuXG4gICkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gaXMoc2VsZWN0YWJsZSwgU2VsZWN0b3JDYWNoZUl0ZW0pXG4gICAgICA/IChzZWxlY3RhYmxlIGFzIFNlbGVjdG9yQ2FjaGVJdGVtKS5jYWNoZUtleVxuICAgICAgOiB0aGlzLmdldENhY2hlS2V5KFxuICAgICAgICAgIHNlbGVjdGFibGUgYXMgQXRvbVNlbGVjdG9yT3JDb25maWc8VCwgQXJncz4sXG4gICAgICAgICAgYXJncyBhcyBBcmdzXG4gICAgICAgIClcblxuICAgIGNvbnN0IGNhY2hlID0gaXMoc2VsZWN0YWJsZSwgU2VsZWN0b3JDYWNoZUl0ZW0pXG4gICAgICA/IChzZWxlY3RhYmxlIGFzIFNlbGVjdG9yQ2FjaGVJdGVtPFQsIEFyZ3M+KVxuICAgICAgOiB0aGlzLl9pdGVtc1tjYWNoZUtleV1cblxuICAgIGlmICghY2FjaGUpIHJldHVyblxuXG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZWNvc3lzdGVtLl9ncmFwaC5ub2Rlc1tjYWNoZUtleV1cblxuICAgIGlmICghZm9yY2UgJiYgT2JqZWN0LmtleXMobm9kZT8uZGVwZW5kZW50cyB8fCB7fSkubGVuZ3RoKSByZXR1cm5cblxuICAgIHRoaXMuX2Rlc3Ryb3lTZWxlY3RvcihjYWNoZUtleSlcbiAgfVxuXG4gIHB1YmxpYyBnZXRDYWNoZTxUID0gYW55LCBBcmdzIGV4dGVuZHMgW10gPSBbXT4oXG4gICAgc2VsZWN0YWJsZTogU2VsZWN0YWJsZTxULCBBcmdzPlxuICApOiBTZWxlY3RvckNhY2hlSXRlbTxULCBBcmdzPlxuXG4gIHB1YmxpYyBnZXRDYWNoZTxUID0gYW55LCBBcmdzIGV4dGVuZHMgYW55W10gPSBbXT4oXG4gICAgc2VsZWN0YWJsZTogU2VsZWN0YWJsZTxULCBBcmdzPixcbiAgICBhcmdzOiBBcmdzXG4gICk6IFNlbGVjdG9yQ2FjaGVJdGVtPFQsIEFyZ3M+XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgY2FjaGVkIGFyZ3MgYW5kIHJlc3VsdCBmb3IgdGhlIGdpdmVuIEF0b21TZWxlY3RvciAob3JcbiAgICogQXRvbVNlbGVjdG9yQ29uZmlnKS4gUnVucyB0aGUgc2VsZWN0b3IsIHNldHMgdXAgdGhlIGdyYXBoLCBhbmQgY2FjaGVzIHRoZVxuICAgKiBpbml0aWFsIHZhbHVlIGlmIHRoaXMgc2VsZWN0b3IgaGFzbid0IGJlZW4gY2FjaGVkIGJlZm9yZS5cbiAgICovXG4gIHB1YmxpYyBnZXRDYWNoZTxUID0gYW55LCBBcmdzIGV4dGVuZHMgYW55W10gPSBbXT4oXG4gICAgc2VsZWN0YWJsZTogU2VsZWN0YWJsZTxULCBBcmdzPiB8IFNlbGVjdG9yQ2FjaGVJdGVtPFQsIEFyZ3M+LFxuICAgIGFyZ3M6IEFyZ3MgPSAoW10gYXMgdW5rbm93bikgYXMgQXJnc1xuICApIHtcbiAgICBpZiAoaXMoc2VsZWN0YWJsZSwgU2VsZWN0b3JDYWNoZUl0ZW0pKSB7XG4gICAgICByZXR1cm4gc2VsZWN0YWJsZVxuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdG9yT3JDb25maWcgPSBzZWxlY3RhYmxlIGFzIEF0b21TZWxlY3Rvck9yQ29uZmlnPFQsIEFyZ3M+XG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmdldENhY2hlS2V5KHNlbGVjdG9yT3JDb25maWcsIGFyZ3MgYXMgQXJncylcbiAgICBsZXQgY2FjaGUgPSB0aGlzLl9pdGVtc1tjYWNoZUtleV0gYXMgU2VsZWN0b3JDYWNoZUl0ZW08VCwgQXJncz5cblxuICAgIGlmIChjYWNoZSkgcmV0dXJuIGNhY2hlXG5cbiAgICAvLyBjcmVhdGUgdGhlIGNhY2hlOyBpdCBkb2Vzbid0IGV4aXN0IHlldFxuICAgIGNhY2hlID0gbmV3IFNlbGVjdG9yQ2FjaGVJdGVtKGNhY2hlS2V5LCBzZWxlY3Rvck9yQ29uZmlnLCBhcmdzKVxuICAgIHRoaXMuX2l0ZW1zW2NhY2hlS2V5XSA9IGNhY2hlIGFzIFNlbGVjdG9yQ2FjaGVJdGVtPGFueSwgYW55W10+XG4gICAgdGhpcy5lY29zeXN0ZW0uX2dyYXBoLmFkZE5vZGUoY2FjaGVLZXksIHRydWUpXG5cbiAgICB0aGlzLnJ1blNlbGVjdG9yKGNhY2hlS2V5LCBhcmdzIGFzIEFyZ3MsIHRydWUpXG5cbiAgICByZXR1cm4gY2FjaGVcbiAgfVxuXG4gIHB1YmxpYyBnZXRDYWNoZUtleTxUID0gYW55LCBBcmdzIGV4dGVuZHMgW10gPSBbXT4oXG4gICAgc2VsZWN0b3JPckNvbmZpZzogQXRvbVNlbGVjdG9yT3JDb25maWc8VCwgQXJncz5cbiAgKTogc3RyaW5nXG5cbiAgcHVibGljIGdldENhY2hlS2V5PFQgPSBhbnksIEFyZ3MgZXh0ZW5kcyBhbnlbXSA9IFtdPihcbiAgICBzZWxlY3Rvck9yQ29uZmlnOiBBdG9tU2VsZWN0b3JPckNvbmZpZzxULCBBcmdzPixcbiAgICBhcmdzOiBBcmdzXG4gICk6IHN0cmluZ1xuXG4gIHB1YmxpYyBnZXRDYWNoZUtleTxUID0gYW55LCBBcmdzIGV4dGVuZHMgYW55W10gPSBbXT4oXG4gICAgc2VsZWN0b3JPckNvbmZpZzogQXRvbVNlbGVjdG9yT3JDb25maWc8VCwgQXJncz4sXG4gICAgYXJnczogQXJncyxcbiAgICB3ZWFrOiB0cnVlXG4gICk6IHN0cmluZyB8IHVuZGVmaW5lZFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZ1bGx5IHF1YWxpZmllZCBrZXkgaGFzaCBmb3IgdGhlIGdpdmVuIHNlbGVjdG9yK3BhcmFtcyBjb21ib1xuICAgKi9cbiAgcHVibGljIGdldENhY2hlS2V5KFxuICAgIHNlbGVjdG9yT3JDb25maWc6IEF0b21TZWxlY3Rvck9yQ29uZmlnPGFueSwgYW55W10+LFxuICAgIGFyZ3M/OiBhbnlbXSxcbiAgICB3ZWFrPzogYm9vbGVhblxuICApIHtcbiAgICBjb25zdCBiYXNlS2V5ID0gdGhpcy5nZXRCYXNlS2V5KHNlbGVjdG9yT3JDb25maWcsIHdlYWspXG5cbiAgICByZXR1cm4gYXJncz8ubGVuZ3RoXG4gICAgICA/IGAke2Jhc2VLZXl9LSR7dGhpcy5lY29zeXN0ZW0uX2lkR2VuZXJhdG9yLmhhc2hQYXJhbXMoXG4gICAgICAgICAgYXJncyxcbiAgICAgICAgICB0aGlzLmVjb3N5c3RlbS5jb21wbGV4UGFyYW1zXG4gICAgICAgICl9YFxuICAgICAgOiBiYXNlS2V5XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIG9iamVjdCBvZiBhbGwgY3VycmVudGx5LWNhY2hlZCBBdG9tU2VsZWN0b3JzLlxuICAgKlxuICAgKiBQYXNzIGEgc2VsZWN0b3IgcmVmZXJlbmNlIG9yIHN0cmluZyB0byBmaWx0ZXIgYnkgY2FjaGVzIHdob3NlIGNhY2hlS2V5XG4gICAqIHdlYWtseSBtYXRjaGVzIHRoZSBwYXNzZWQgc2VsZWN0b3IgbmFtZS5cbiAgICovXG4gIHB1YmxpYyBpbnNwZWN0SXRlbXMoc2VsZWN0YWJsZU9yTmFtZT86IFNlbGVjdGFibGU8YW55LCBhbnk+IHwgc3RyaW5nKSB7XG4gICAgY29uc3QgaGFzaDogUmVjb3JkPHN0cmluZywgU2VsZWN0b3JDYWNoZUl0ZW0+ID0ge31cbiAgICBjb25zdCBmaWx0ZXJLZXkgPVxuICAgICAgIXNlbGVjdGFibGVPck5hbWUgfHwgdHlwZW9mIHNlbGVjdGFibGVPck5hbWUgPT09ICdzdHJpbmcnXG4gICAgICAgID8gc2VsZWN0YWJsZU9yTmFtZVxuICAgICAgICA6IGlzKHNlbGVjdGFibGVPck5hbWUsIFNlbGVjdG9yQ2FjaGVJdGVtKVxuICAgICAgICA/IChzZWxlY3RhYmxlT3JOYW1lIGFzIFNlbGVjdG9yQ2FjaGVJdGVtKS5jYWNoZUtleVxuICAgICAgICA6IHRoaXMuZ2V0QmFzZUtleShcbiAgICAgICAgICAgIHNlbGVjdGFibGVPck5hbWUgYXMgQXRvbVNlbGVjdG9yT3JDb25maWc8YW55LCBhbnk+LFxuICAgICAgICAgICAgdHJ1ZVxuICAgICAgICAgICkgfHwgdGhpcy5fZ2V0SWRlYWxDYWNoZUtleShzZWxlY3RhYmxlT3JOYW1lIGFzIEF0b21TZWxlY3Rvck9yQ29uZmlnKVxuXG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLl9pdGVtcylcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmNhY2hlS2V5LmxvY2FsZUNvbXBhcmUoYi5jYWNoZUtleSkpXG4gICAgICAuZm9yRWFjaChpbnN0YW5jZSA9PiB7XG4gICAgICAgIGlmIChmaWx0ZXJLZXkgJiYgIWluc3RhbmNlLmNhY2hlS2V5LmluY2x1ZGVzKGZpbHRlcktleSkpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGhhc2hbaW5zdGFuY2UuY2FjaGVLZXldID0gaW5zdGFuY2VcbiAgICAgIH0pXG5cbiAgICByZXR1cm4gaGFzaFxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBvYmplY3QgbWFwcGluZyBhbGwgY2FjaGVLZXlzIGluIHRoaXMgc2VsZWN0b3JDYWNoZSB0byB0aGVpciBjdXJyZW50XG4gICAqIHZhbHVlcy5cbiAgICpcbiAgICogUGFzcyBhbiBhdG9tIG9yIGF0b20ga2V5IHN0cmluZyB0byBvbmx5IHJldHVybiBpbnN0YW5jZXMgd2hvc2Uga2V5SGFzaFxuICAgKiB3ZWFrbHkgbWF0Y2hlcyB0aGUgcGFzc2VkIGtleS5cbiAgICovXG4gIHB1YmxpYyBpbnNwZWN0SXRlbVZhbHVlcyhzZWxlY3RhYmxlT3JOYW1lPzogU2VsZWN0YWJsZTxhbnksIGFueT4gfCBzdHJpbmcpIHtcbiAgICBjb25zdCBoYXNoID0gdGhpcy5pbnNwZWN0SXRlbXMoc2VsZWN0YWJsZU9yTmFtZSlcblxuICAgIC8vIFdlIGp1c3QgY3JlYXRlZCB0aGUgb2JqZWN0LiBKdXN0IG11dGF0ZSBpdC5cbiAgICBPYmplY3Qua2V5cyhoYXNoKS5mb3JFYWNoKGNhY2hlS2V5ID0+IHtcbiAgICAgIGhhc2hbY2FjaGVLZXldID0gaGFzaFtjYWNoZUtleV0ucmVzdWx0XG4gICAgfSlcblxuICAgIHJldHVybiBoYXNoXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjYWNoZSBmb3IgdGhlIGdpdmVuIHNlbGVjdG9yLiBEb24ndCBjcmVhdGUgaXQgaWYgaXQgZG9lc24ndCBleGlzdCxcbiAgICoganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuICAgKi9cbiAgcHVibGljIHdlYWtHZXRDYWNoZTxUID0gYW55LCBBcmdzIGV4dGVuZHMgW10gPSBbXT4oXG4gICAgc2VsZWN0YWJsZTogU2VsZWN0YWJsZTxULCBBcmdzPlxuICApOiBTZWxlY3RvckNhY2hlSXRlbTxULCBBcmdzPiB8IHVuZGVmaW5lZFxuXG4gIHB1YmxpYyB3ZWFrR2V0Q2FjaGU8VCA9IGFueSwgQXJncyBleHRlbmRzIGFueVtdID0gW10+KFxuICAgIHNlbGVjdGFibGU6IFNlbGVjdGFibGU8VCwgQXJncz4sXG4gICAgYXJnczogQXJnc1xuICApOiBTZWxlY3RvckNhY2hlSXRlbTxULCBBcmdzPiB8IHVuZGVmaW5lZFxuXG4gIHB1YmxpYyB3ZWFrR2V0Q2FjaGU8VCA9IGFueSwgQXJncyBleHRlbmRzIGFueVtdID0gW10+KFxuICAgIHNlbGVjdGFibGU6IFNlbGVjdGFibGU8VCwgQXJncz4sXG4gICAgYXJncz86IEFyZ3NcbiAgKSB7XG4gICAgaWYgKGlzKHNlbGVjdGFibGUsIFNlbGVjdG9yQ2FjaGVJdGVtKSkge1xuICAgICAgcmV0dXJuIHNlbGVjdGFibGUgYXMgU2VsZWN0b3JDYWNoZUl0ZW1cbiAgICB9XG5cbiAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuZ2V0Q2FjaGVLZXkoXG4gICAgICBzZWxlY3RhYmxlIGFzIEF0b21TZWxlY3Rvck9yQ29uZmlnPFQsIEFyZ3M+LFxuICAgICAgYXJncyBhcyBBcmdzLFxuICAgICAgdHJ1ZVxuICAgIClcbiAgICBpZiAoIWNhY2hlS2V5KSByZXR1cm5cblxuICAgIHJldHVybiB0aGlzLl9pdGVtc1tjYWNoZUtleV1cbiAgfVxuXG4gIC8qKlxuICAgKiBTaG91bGQgb25seSBiZSB1c2VkIGludGVybmFsbHkuIFJlbW92ZXMgdGhlIHNlbGVjdG9yIGZyb20gdGhlIGNhY2hlIGFuZFxuICAgKiB0aGUgZ3JhcGhcbiAgICovXG4gIHB1YmxpYyBfZGVzdHJveVNlbGVjdG9yKGNhY2hlS2V5OiBzdHJpbmcpIHtcbiAgICBjb25zdCBjYWNoZSA9IHRoaXMuX2l0ZW1zW2NhY2hlS2V5XVxuXG4gICAgaWYgKCFjYWNoZSkgcmV0dXJuIC8vIHNob3VsZG4ndCBoYXBwZW5cblxuICAgIGlmIChjYWNoZS5uZXh0RXZhbHVhdGlvblJlYXNvbnMubGVuZ3RoICYmIGNhY2hlLnRhc2spIHtcbiAgICAgIHRoaXMuZWNvc3lzdGVtLl9zY2hlZHVsZXIudW5zY2hlZHVsZShjYWNoZS50YXNrKVxuICAgIH1cblxuICAgIHRoaXMuZWNvc3lzdGVtLl9ncmFwaC5yZW1vdmVEZXBlbmRlbmNpZXMoY2FjaGVLZXkpXG4gICAgdGhpcy5lY29zeXN0ZW0uX2dyYXBoLnJlbW92ZU5vZGUoY2FjaGVLZXkpXG4gICAgZGVsZXRlIHRoaXMuX2l0ZW1zW2NhY2hlS2V5XVxuICAgIGNhY2hlLmlzRGVzdHJveWVkID0gdHJ1ZVxuICAgIHRoaXMuX3JlZkJhc2VLZXlzLmRlbGV0ZShjYWNoZS5zZWxlY3RvclJlZilcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0cmluZyBrZXkgd2Ugd291bGQgaWRlYWxseSB1c2UgYXMgdGhlIGNhY2hlS2V5IG9mIHRoZSBnaXZlblxuICAgKiBBdG9tU2VsZWN0b3IgZnVuY3Rpb24gb3IgQXRvbVNlbGVjdG9yQ29uZmlnIG9iamVjdCAtIGRvZXNuJ3QgbmVjZXNzYXJpbHlcbiAgICogbWVhbiB3ZSBlbmQgdXAgY2FjaGluZyB1c2luZyB0aGlzIGtleS5cbiAgICovXG4gIHB1YmxpYyBfZ2V0SWRlYWxDYWNoZUtleShcbiAgICBzZWxlY3Rvck9yQ29uZmlnOiBBdG9tU2VsZWN0b3JPckNvbmZpZzxhbnksIGFueT5cbiAgKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCBpZGVhbEtleSA9XG4gICAgICBzZWxlY3Rvck9yQ29uZmlnLm5hbWUgfHxcbiAgICAgIChzZWxlY3Rvck9yQ29uZmlnIGFzIEF0b21TZWxlY3RvckNvbmZpZykuc2VsZWN0b3I/Lm5hbWVcblxuICAgIC8vICdzZWxlY3RvcicgaXMgdG9vIGdlbmVyaWMgKGl0J3MgdGhlIGtleSBpbiBBdG9tU2VsZWN0b3JDb25maWcgb2JqZWN0cylcbiAgICByZXR1cm4gKGlkZWFsS2V5ICE9PSAnc2VsZWN0b3InICYmIGlkZWFsS2V5KSB8fCB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBTaG91bGQgb25seSBiZSB1c2VkIGludGVybmFsbHlcbiAgICovXG4gIHB1YmxpYyBfc2NoZWR1bGVFdmFsdWF0aW9uKFxuICAgIGNhY2hlS2V5OiBzdHJpbmcsXG4gICAgcmVhc29uOiBFdmFsdWF0aW9uUmVhc29uLFxuICAgIHNob3VsZFNldFRpbWVvdXQ/OiBib29sZWFuXG4gICkge1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5faXRlbXNbY2FjaGVLZXldXG5cbiAgICAvLyBUT0RPOiBBbnkgY2FsbHMgaW4gdGhpcyBjYXNlIHByb2JhYmx5IGluZGljYXRlIGEgbWVtb3J5IGxlYWsgb24gdGhlXG4gICAgLy8gdXNlcidzIHBhcnQuIE5vdGlmeSB0aGVtLlxuICAgIGlmICghY2FjaGUpIHJldHVyblxuXG4gICAgY2FjaGUubmV4dEV2YWx1YXRpb25SZWFzb25zLnB1c2gocmVhc29uKVxuXG4gICAgaWYgKGNhY2hlLm5leHRFdmFsdWF0aW9uUmVhc29ucy5sZW5ndGggPiAxKSByZXR1cm4gLy8gam9iIGFscmVhZHkgc2NoZWR1bGVkXG5cbiAgICBjb25zdCB0YXNrID0gKCkgPT4ge1xuICAgICAgY2FjaGUudGFzayA9IHVuZGVmaW5lZFxuICAgICAgdGhpcy5ydW5TZWxlY3RvcihjYWNoZUtleSwgY2FjaGUuYXJncyBhcyBhbnlbXSlcbiAgICB9XG4gICAgY2FjaGUudGFzayA9IHRhc2tcblxuICAgIHRoaXMuZWNvc3lzdGVtLl9zY2hlZHVsZXIuc2NoZWR1bGUoXG4gICAgICB7XG4gICAgICAgIGtleUhhc2g6IGNhY2hlS2V5LFxuICAgICAgICB0YXNrLFxuICAgICAgICB0eXBlOiAyLCAvLyBFdmFsdWF0ZUdyYXBoTm9kZSAoMilcbiAgICAgIH0sXG4gICAgICBzaG91bGRTZXRUaW1lb3V0XG4gICAgKVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3VsZCBvbmx5IGJlIHVzZWQgaW50ZXJuYWxseVxuICAgKi9cbiAgcHVibGljIF9zd2FwUmVmcyhcbiAgICBvbGRSZWY6IEF0b21TZWxlY3Rvck9yQ29uZmlnPGFueSwgYW55W10+LFxuICAgIG5ld1JlZjogQXRvbVNlbGVjdG9yT3JDb25maWc8YW55LCBhbnlbXT4sXG4gICAgYXJnczogYW55W11cbiAgKSB7XG4gICAgY29uc3QgZXhpc3RpbmdDYWNoZSA9IHRoaXMud2Vha0dldENhY2hlKG9sZFJlZiwgYXJncylcbiAgICBjb25zdCBiYXNlS2V5ID0gdGhpcy5fcmVmQmFzZUtleXMuZ2V0KG9sZFJlZilcblxuICAgIGlmICghZXhpc3RpbmdDYWNoZSB8fCAhYmFzZUtleSkgcmV0dXJuXG5cbiAgICB0aGlzLl9yZWZCYXNlS2V5cy5zZXQobmV3UmVmLCBiYXNlS2V5KVxuICAgIGV4aXN0aW5nQ2FjaGUuc2VsZWN0b3JSZWYgPSBuZXdSZWZcbiAgICB0aGlzLnJ1blNlbGVjdG9yKGV4aXN0aW5nQ2FjaGUuY2FjaGVLZXksIGFyZ3MpXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSBhbGwgY2FjaGVkIHNlbGVjdG9ycy4gU2hvdWxkIHByb2JhYmx5IG9ubHkgYmUgdXNlZCBpbnRlcm5hbGx5LlxuICAgKiBQcmVmZXIgYGVjb3N5c3RlbS5yZXNldCgpYC5cbiAgICovXG4gIHB1YmxpYyBfd2lwZSgpIHtcbiAgICBPYmplY3Qua2V5cyh0aGlzLl9pdGVtcykuZm9yRWFjaChjYWNoZUtleSA9PiB7XG4gICAgICB0aGlzLl9kZXN0cm95U2VsZWN0b3IoY2FjaGVLZXkpXG4gICAgfSlcblxuICAgIHRoaXMuX3JlZkJhc2VLZXlzID0gbmV3IFdlYWtNYXAoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGJhc2Uga2V5IHRoYXQgY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgY29uc2lzdGVudCBjYWNoZUtleXMgZm9yIHRoZVxuICAgKiBnaXZlbiBzZWxlY3RvclxuICAgKi9cbiAgcHJpdmF0ZSBnZXRCYXNlS2V5KFxuICAgIHNlbGVjdG9yT3JDb25maWc6IEF0b21TZWxlY3Rvck9yQ29uZmlnPGFueSwgYW55W10+LFxuICAgIHdlYWs/OiBib29sZWFuXG4gICkge1xuICAgIGNvbnN0IGV4aXN0aW5nSWQgPSB0aGlzLl9yZWZCYXNlS2V5cy5nZXQoc2VsZWN0b3JPckNvbmZpZylcblxuICAgIGlmIChleGlzdGluZ0lkIHx8IHdlYWspIHJldHVybiBleGlzdGluZ0lkXG5cbiAgICBjb25zdCBpZGVhbEtleSA9IHRoaXMuX2dldElkZWFsQ2FjaGVLZXkoc2VsZWN0b3JPckNvbmZpZylcbiAgICBjb25zdCBwcmVmaXhlZEtleSA9IGBAQHNlbGVjdG9yLSR7aWRlYWxLZXl9YFxuICAgIGNvbnN0IGtleUV4aXN0cyA9IHRoaXMuX2l0ZW1zW3ByZWZpeGVkS2V5XVxuXG4gICAgLy8gaWYgdGhlIGlkZWFsIGtleSBpcyB0YWtlbiwgZ2VuZXJhdGUgYSBuZXcgaGFzaCBwcmVmaXhlZCB3aXRoIHRoZSBpZGVhbCBrZXlcbiAgICBjb25zdCBrZXkgPVxuICAgICAgIWlkZWFsS2V5IHx8IGtleUV4aXN0c1xuICAgICAgICA/IHRoaXMuZWNvc3lzdGVtLl9pZEdlbmVyYXRvci5nZW5lcmF0ZUF0b21TZWxlY3RvcklkKGlkZWFsS2V5KVxuICAgICAgICA6IHByZWZpeGVkS2V5XG5cbiAgICB0aGlzLl9yZWZCYXNlS2V5cy5zZXQoc2VsZWN0b3JPckNvbmZpZywga2V5KVxuXG4gICAgcmV0dXJuIGtleVxuICB9XG5cbiAgLyoqXG4gICAqIFJ1biBhbiBBdG9tU2VsZWN0b3IgYW5kLCBkZXBlbmRpbmcgb24gdGhlIHNlbGVjdG9yJ3MgcmVzdWx0c0NvbXBhcmF0b3IsXG4gICAqIHVwZGF0ZSBpdHMgY2FjaGVkIHJlc3VsdC4gVXBkYXRlcyB0aGUgZ3JhcGggZWZmaWNpZW50bHkgKHVzaW5nXG4gICAqIGAuYnVmZmVyVXBkYXRlcygpYClcbiAgICovXG4gIHByaXZhdGUgcnVuU2VsZWN0b3I8VCA9IGFueSwgQXJncyBleHRlbmRzIGFueVtdID0gW10+KFxuICAgIGNhY2hlS2V5OiBzdHJpbmcsXG4gICAgYXJnczogQXJncyxcbiAgICBpc0luaXRpYWxpemluZz86IGJvb2xlYW5cbiAgKSB7XG4gICAgdGhpcy5lY29zeXN0ZW0uX2dyYXBoLmJ1ZmZlclVwZGF0ZXMoY2FjaGVLZXkpXG4gICAgY29uc3QgY2FjaGUgPSB0aGlzLl9pdGVtc1tjYWNoZUtleV0gYXMgU2VsZWN0b3JDYWNoZUl0ZW08VCwgQXJncz5cbiAgICB0aGlzLmVjb3N5c3RlbS5fZXZhbHVhdGlvblN0YWNrLnN0YXJ0KGNhY2hlKVxuICAgIGNvbnN0IHNlbGVjdG9yID1cbiAgICAgIHR5cGVvZiBjYWNoZS5zZWxlY3RvclJlZiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNhY2hlLnNlbGVjdG9yUmVmXG4gICAgICAgIDogY2FjaGUuc2VsZWN0b3JSZWYuc2VsZWN0b3JcblxuICAgIGNvbnN0IHJlc3VsdHNDb21wYXJhdG9yID1cbiAgICAgICh0eXBlb2YgY2FjaGUuc2VsZWN0b3JSZWYgIT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgY2FjaGUuc2VsZWN0b3JSZWYucmVzdWx0c0NvbXBhcmF0b3IpIHx8XG4gICAgICBkZWZhdWx0UmVzdWx0c0NvbXBhcmF0b3JcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBzZWxlY3RvcihcbiAgICAgICAgdGhpcy5lY29zeXN0ZW0uX2V2YWx1YXRpb25TdGFjay5hdG9tR2V0dGVycyxcbiAgICAgICAgLi4uYXJnc1xuICAgICAgKVxuXG4gICAgICBpZiAoIWlzSW5pdGlhbGl6aW5nICYmICFyZXN1bHRzQ29tcGFyYXRvcihyZXN1bHQsIGNhY2hlLnJlc3VsdCBhcyBUKSkge1xuICAgICAgICB0aGlzLmVjb3N5c3RlbS5fZ3JhcGguc2NoZWR1bGVEZXBlbmRlbnRzKFxuICAgICAgICAgIGNhY2hlS2V5LFxuICAgICAgICAgIGNhY2hlLm5leHRFdmFsdWF0aW9uUmVhc29ucyxcbiAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgY2FjaGUucmVzdWx0XG4gICAgICAgIClcblxuICAgICAgICBpZiAodGhpcy5lY29zeXN0ZW0uX21vZHMuc3RhdGVDaGFuZ2VkKSB7XG4gICAgICAgICAgdGhpcy5lY29zeXN0ZW0ubW9kQnVzLmRpc3BhdGNoKFxuICAgICAgICAgICAgcGx1Z2luQWN0aW9ucy5zdGF0ZUNoYW5nZWQoe1xuICAgICAgICAgICAgICBjYWNoZTogY2FjaGUgYXMgU2VsZWN0b3JDYWNoZUl0ZW08YW55LCBhbnlbXT4sXG4gICAgICAgICAgICAgIG5ld1N0YXRlOiByZXN1bHQsXG4gICAgICAgICAgICAgIG9sZFN0YXRlOiBjYWNoZS5yZXN1bHQsXG4gICAgICAgICAgICAgIHJlYXNvbnM6IGNhY2hlLm5leHRFdmFsdWF0aW9uUmVhc29ucyxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgY2FjaGUucmVzdWx0ID0gcmVzdWx0XG4gICAgICB9IGVsc2UgaWYgKGlzSW5pdGlhbGl6aW5nKSB7XG4gICAgICAgIGNhY2hlLnJlc3VsdCA9IHJlc3VsdFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5lY29zeXN0ZW0uX2dyYXBoLmRlc3Ryb3lCdWZmZXIoKVxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgYFplZHV4IGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIHJ1bm5pbmcgQXRvbVNlbGVjdG9yIHdpdGgga2V5IFwiJHtjYWNoZUtleX1cIjpgLFxuICAgICAgICBlcnJcbiAgICAgIClcblxuICAgICAgdGhyb3cgZXJyXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZWNvc3lzdGVtLl9ldmFsdWF0aW9uU3RhY2suZmluaXNoKClcbiAgICAgIGNhY2hlLnByZXZFdmFsdWF0aW9uUmVhc29ucyA9IGNhY2hlLm5leHRFdmFsdWF0aW9uUmVhc29uc1xuICAgICAgY2FjaGUubmV4dEV2YWx1YXRpb25SZWFzb25zID0gW11cbiAgICB9XG5cbiAgICB0aGlzLmVjb3N5c3RlbS5fZ3JhcGguZmx1c2hVcGRhdGVzKClcbiAgfVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlU3RvcmUsIGlzIH0gZnJvbSAnQHplZHV4L2NvcmUnXG5pbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgaW50ZXJuYWxTdG9yZSB9IGZyb20gJy4uL3N0b3JlJ1xuaW1wb3J0IHtcbiAgQW55QXRvbSxcbiAgQW55QXRvbUluc3RhbmNlLFxuICBBbnlBdG9tSW5zdGFuY2VCYXNlLFxuICBBdG9tR2V0dGVyc0Jhc2UsXG4gIEF0b21JbnN0YW5jZVN0YXRlVHlwZSxcbiAgQXRvbUluc3RhbmNlVHlwZSxcbiAgQXRvbVBhcmFtc1R5cGUsXG4gIEF0b21TZWxlY3Rvck9yQ29uZmlnLFxuICBBdG9tU3RhdGVUeXBlLFxuICBDbGVhbnVwLFxuICBFY29zeXN0ZW1Db25maWcsXG4gIEVjb3N5c3RlbUdyYXBoTm9kZSxcbiAgR3JhcGhFZGdlSW5mbyxcbiAgR3JhcGhWaWV3UmVjdXJzaXZlLFxuICBNYXliZUNsZWFudXAsXG4gIFBhcnRpYWxBdG9tSW5zdGFuY2UsXG4gIFNlbGVjdGFibGUsXG59IGZyb20gJy4uL3R5cGVzJ1xuaW1wb3J0IHsgRXh0ZXJuYWwsIEluc3RhbmNlU3RhY2tJdGVtLCBTZWxlY3RvclN0YWNrSXRlbSB9IGZyb20gJy4uL3V0aWxzJ1xuaW1wb3J0IHsgcGx1Z2luQWN0aW9ucyB9IGZyb20gJy4uL3V0aWxzL3BsdWdpbi1hY3Rpb25zJ1xuaW1wb3J0IHsgQXRvbUJhc2UgfSBmcm9tICcuL2F0b21zL0F0b21CYXNlJ1xuaW1wb3J0IHsgRXZhbHVhdGlvblN0YWNrIH0gZnJvbSAnLi9FdmFsdWF0aW9uU3RhY2snXG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJy4vR3JhcGgnXG5pbXBvcnQgeyBJZEdlbmVyYXRvciB9IGZyb20gJy4vSWRHZW5lcmF0b3InXG5pbXBvcnQgeyBBdG9tSW5zdGFuY2VCYXNlIH0gZnJvbSAnLi9pbnN0YW5jZXMvQXRvbUluc3RhbmNlQmFzZSdcbmltcG9ydCB7IFNjaGVkdWxlciB9IGZyb20gJy4vU2NoZWR1bGVyJ1xuaW1wb3J0IHsgU2VsZWN0b3JDYWNoZUl0ZW0sIFNlbGVjdG9yQ2FjaGUgfSBmcm9tICcuL1NlbGVjdG9yQ2FjaGUnXG5pbXBvcnQgeyBNb2QsIFplZHV4UGx1Z2luIH0gZnJvbSAnLi9aZWR1eFBsdWdpbidcblxuY29uc3QgZGVmYXVsdE1vZHMgPSBPYmplY3Qua2V5cyhwbHVnaW5BY3Rpb25zKS5yZWR1Y2UoKG1hcCwgbW9kKSA9PiB7XG4gIG1hcFttb2QgYXMgTW9kXSA9IDBcbiAgcmV0dXJuIG1hcFxufSwge30gYXMgUmVjb3JkPE1vZCwgbnVtYmVyPilcblxuY29uc3QgbWFwT3ZlcnJpZGVzID0gKG92ZXJyaWRlczogQW55QXRvbVtdKSA9PlxuICBvdmVycmlkZXMucmVkdWNlKChtYXAsIGF0b20pID0+IHtcbiAgICBtYXBbYXRvbS5rZXldID0gYXRvbVxuICAgIHJldHVybiBtYXBcbiAgfSwge30gYXMgUmVjb3JkPHN0cmluZywgQW55QXRvbT4pXG5cbmV4cG9ydCBjbGFzcyBFY29zeXN0ZW08Q29udGV4dCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQgPSBhbnk+XG4gIGltcGxlbWVudHMgQXRvbUdldHRlcnNCYXNlIHtcbiAgcHVibGljIF9kZXN0cm95T25Vbm1vdW50ID0gZmFsc2VcbiAgcHVibGljIF9ncmFwaDogR3JhcGggPSBuZXcgR3JhcGgodGhpcylcbiAgcHVibGljIF9ldmFsdWF0aW9uU3RhY2s6IEV2YWx1YXRpb25TdGFjayA9IG5ldyBFdmFsdWF0aW9uU3RhY2sodGhpcylcbiAgcHVibGljIF9pZEdlbmVyYXRvciA9IG5ldyBJZEdlbmVyYXRvcigpXG4gIHB1YmxpYyBfaW5zdGFuY2VzOiBSZWNvcmQ8c3RyaW5nLCBBbnlBdG9tSW5zdGFuY2U+ID0ge31cbiAgcHVibGljIF9vblJlYWR5OiBFY29zeXN0ZW1Db25maWc8Q29udGV4dD5bJ29uUmVhZHknXVxuICBwdWJsaWMgX21vZHM6IFJlY29yZDxNb2QsIG51bWJlcj4gPSB7IC4uLmRlZmF1bHRNb2RzIH1cbiAgcHVibGljIF9yZWFjdENvbnRleHRzOiBSZWNvcmQ8c3RyaW5nLCBSZWFjdC5Db250ZXh0PGFueT4+ID0ge31cbiAgcHVibGljIF9yZWZDb3VudCA9IDBcbiAgcHVibGljIF9zY2hlZHVsZXI6IFNjaGVkdWxlciA9IG5ldyBTY2hlZHVsZXIodGhpcylcbiAgcHVibGljIHNlbGVjdG9yQ2FjaGU6IFNlbGVjdG9yQ2FjaGUgPSBuZXcgU2VsZWN0b3JDYWNoZSh0aGlzKVxuICBwdWJsaWMgY29tcGxleFBhcmFtczogYm9vbGVhblxuICBwdWJsaWMgY29udGV4dDogQ29udGV4dFxuICBwdWJsaWMgZGVmYXVsdFR0bD86IG51bWJlclxuICBwdWJsaWMgaWQ6IHN0cmluZ1xuICBwdWJsaWMgZmxhZ3M/OiBzdHJpbmdbXVxuICBwdWJsaWMgaHlkcmF0aW9uPzogUmVjb3JkPHN0cmluZywgYW55PlxuICBwdWJsaWMgbW9kQnVzID0gY3JlYXRlU3RvcmUoKSAvLyB1c2UgYW4gZW1wdHkgc3RvcmUgYXMgYSBtZXNzYWdlIGJ1c1xuICBwdWJsaWMgb3ZlcnJpZGVzOiBSZWNvcmQ8c3RyaW5nLCBBbnlBdG9tPiA9IHt9XG4gIHB1YmxpYyBzc3I/OiBib29sZWFuXG4gIHByaXZhdGUgY2xlYW51cD86IE1heWJlQ2xlYW51cFxuICBwcml2YXRlIGlzSW5pdGlhbGl6ZWQgPSBmYWxzZVxuICBwcml2YXRlIHBsdWdpbnM6IHsgcGx1Z2luOiBaZWR1eFBsdWdpbjsgY2xlYW51cDogQ2xlYW51cCB9W10gPSBbXVxuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjb21wbGV4UGFyYW1zLFxuICAgIGNvbnRleHQsXG4gICAgZGVmYXVsdFR0bCxcbiAgICBkZXN0cm95T25Vbm1vdW50LFxuICAgIGZsYWdzLFxuICAgIGlkLFxuICAgIG9uUmVhZHksXG4gICAgb3ZlcnJpZGVzLFxuICAgIHNzcixcbiAgfTogRWNvc3lzdGVtQ29uZmlnPENvbnRleHQ+KSB7XG4gICAgaWYgKERFViAmJiBmbGFncyAmJiAhQXJyYXkuaXNBcnJheShmbGFncykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiWmVkdXg6IFRoZSBFY29zeXN0ZW0ncyBgZmxhZ3NgIHByb3BlcnR5IG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nc1wiXG4gICAgICApXG4gICAgfVxuICAgIGlmIChERVYgJiYgb3ZlcnJpZGVzICYmICFBcnJheS5pc0FycmF5KG92ZXJyaWRlcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIFwiWmVkdXg6IFRoZSBFY29zeXN0ZW0ncyBgb3ZlcnJpZGVzYCBwcm9wZXJ0eSBtdXN0IGJlIGFuIGFycmF5IG9mIEF0b20gb2JqZWN0c1wiXG4gICAgICApXG4gICAgfVxuXG4gICAgdGhpcy5pZCA9IGlkIHx8IHRoaXMuX2lkR2VuZXJhdG9yLmdlbmVyYXRlRWNvc3lzdGVtSWQoKVxuXG4gICAgaWYgKG92ZXJyaWRlcykge1xuICAgICAgdGhpcy5zZXRPdmVycmlkZXMob3ZlcnJpZGVzKVxuICAgIH1cblxuICAgIHRoaXMuZmxhZ3MgPSBmbGFnc1xuICAgIHRoaXMuY29tcGxleFBhcmFtcyA9ICEhY29tcGxleFBhcmFtc1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQgYXMgQ29udGV4dFxuICAgIHRoaXMuZGVmYXVsdFR0bCA9IGRlZmF1bHRUdGwgPz8gLTFcbiAgICB0aGlzLnNzciA9IHNzclxuICAgIHRoaXMuX2Rlc3Ryb3lPblVubW91bnQgPSAhIWRlc3Ryb3lPblVubW91bnRcbiAgICB0aGlzLl9vblJlYWR5ID0gb25SZWFkeVxuICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWVcbiAgICB0aGlzLmNsZWFudXAgPSBvblJlYWR5Py4odGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXJnZSB0aGUgcGFzc2VkIGF0b20gb3ZlcnJpZGVzIGludG8gdGhlIGVjb3N5c3RlbSdzIGN1cnJlbnQgbGlzdCBvZlxuICAgKiBvdmVycmlkZXMuIEZvcmNlLWRlc3Ryb3lzIGFsbCBhdG9tIGluc3RhbmNlcyBjdXJyZW50bHkgaW4gdGhlIGVjb3N5c3RlbVxuICAgKiB0aGF0IHNob3VsZCBub3cgYmUgb3ZlcnJpZGRlbi5cbiAgICpcbiAgICogVGhpcyBjYW4ndCBiZSB1c2VkIHRvIHJlbW92ZSBvdmVycmlkZXMuIFVzZSBgLnNldE92ZXJyaWRlcygpYCBvclxuICAgKiBgLnJlbW92ZU92ZXJyaWRlcygpYCBmb3IgdGhhdC5cbiAgICovXG4gIHB1YmxpYyBhZGRPdmVycmlkZXMob3ZlcnJpZGVzOiBBbnlBdG9tW10pIHtcbiAgICB0aGlzLm92ZXJyaWRlcyA9IHtcbiAgICAgIC4uLnRoaXMub3ZlcnJpZGVzLFxuICAgICAgLi4ubWFwT3ZlcnJpZGVzKG92ZXJyaWRlcyksXG4gICAgfVxuXG4gICAgb3ZlcnJpZGVzLmZvckVhY2gob3ZlcnJpZGUgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2VzID0gdGhpcy5pbnNwZWN0SW5zdGFuY2VzKG92ZXJyaWRlKVxuXG4gICAgICBPYmplY3QudmFsdWVzKGluc3RhbmNlcykuZm9yRWFjaChpbnN0YW5jZSA9PiBpbnN0YW5jZS5kZXN0cm95KHRydWUpKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgYW4gb2JqZWN0IG1hcHBpbmcgYXRvbSBpbnN0YW5jZSBrZXlIYXNoZXMgdG8gdGhlaXIgY3VycmVudCB2YWx1ZXMuXG4gICAqXG4gICAqIENhbGxzIHRoZSBgZGVoeWRyYXRlYCBhdG9tIGNvbmZpZyBvcHRpb24gKG9uIGF0b21zIHRoYXQgaGF2ZSBvbmUpIHRvXG4gICAqIHRyYW5zZm9ybSBzdGF0ZSB0byBhIHNlcmlhbGl6YWJsZSBmb3JtLiBQYXNzIGB0cmFuc2Zvcm06IGZhbHNlYCB0byBwcmV2ZW50XG4gICAqIHRoaXMuXG4gICAqXG4gICAqIEF0b21zIGNhbiBiZSBleGNsdWRlZCBmcm9tIGRlaHlkcmF0aW9uIGJ5IHBhc3NpbmcgYGV4Y2x1ZGVgIGFuZC9vclxuICAgKiBgZXhjbHVkZUZsYWdzYCBvcHRpb25zOlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBteUVjb3N5c3RlbS5kZWh5ZHJhdGUoe1xuICAgKiAgIGV4Y2x1ZGU6IFtteUF0b20sICdteS1mdXp6eS1zZWFyY2gtc3RyaW5nJ10sXG4gICAqICAgZXhjbHVkZUZsYWdzOiBbJ25vLXNzciddXG4gICAqIH0pXG4gICAqIGBgYFxuICAgKlxuICAgKiBBbiBhdG9tIHBhc3NlZCB0byBgZXhjbHVkZWAgd2lsbCBleGNsdWRlIGFsbCBpbnN0YW5jZXMgb2YgdGhhdCBhdG9tLiBBXG4gICAqIHN0cmluZyBwYXNzZWQgdG8gYGV4Y2x1ZGVgIHdpbGwgZXhjbHVkZSBhbGwgaW5zdGFuY2VzIHdob3NlIGtleUhhc2hcbiAgICogY29udGFpbnMgdGhlIHN0cmluZyAoY2FzZS1pbnNlbnNpdGl2ZSlcbiAgICpcbiAgICogWW91IGNhbiBkZWh5ZHJhdGUgb25seSBhIHN1YnNldCBvZiBhbGwgYXRvbXMgYnkgcGFzc2luZyBgaW5jbHVkZWAgYW5kL29yXG4gICAqIGBpbmNsdWRlRmxhZ3NgIG9wdGlvbnM6XG4gICAqXG4gICAqIGBgYHRzXG4gICAqIG15RWNvc3lzdGVtLmRlaHlkcmF0ZSh7XG4gICAqICAgaW5jbHVkZTogW215QXRvbSwgJ215LWZ1enp5LXNlYXJjaC1zdHJpbmcnXSxcbiAgICogICBpbmNsdWRlRmxhZ3M6IFsnc3NyJ11cbiAgICogfSlcbiAgICogYGBgXG4gICAqXG4gICAqIEFuIGF0b20gcGFzc2VkIHRvIGBpbmNsdWRlYCB3aWxsIGluY2x1ZGUgYWxsIGluc3RhbmNlcyBvZiB0aGF0IGF0b20uIEFcbiAgICogc3RyaW5nIHBhc3NlZCB0byBgaW5jbHVkZWAgd2lsbCBpbmNsdWRlIGFsbCBpbnN0YW5jZXMgd2hvc2Uga2V5SGFzaFxuICAgKiBjb250YWlucyB0aGUgc3RyaW5nIChjYXNlLWluc2Vuc2l0aXZlKVxuICAgKlxuICAgKiBFeGNsdWRlcyB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgaW5jbHVkZXMuXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIGRlaHlkcmF0aW9uIHdpbGwgY2FsbCBhbnkgY29uZmlndXJlZCBgZGVoeWRyYXRlYCBhdG9tIGNvbmZpZ1xuICAgKiBvcHRpb25zIHRvIHRyYW5zZm9ybSBhdG9tIGluc3RhbmNlIHN0YXRlLiBQYXNzIGB7IHRyYW5zZm9ybTogZmFsc2UgfWAgdG9cbiAgICogcHJldmVudCB0aGlzLlxuICAgKi9cbiAgcHVibGljIGRlaHlkcmF0ZSh7XG4gICAgZXhjbHVkZSxcbiAgICBleGNsdWRlRmxhZ3MsXG4gICAgaW5jbHVkZSxcbiAgICBpbmNsdWRlRmxhZ3MsXG4gICAgdHJhbnNmb3JtID0gdHJ1ZSxcbiAgfToge1xuICAgIGV4Y2x1ZGU/OiAoQW55QXRvbSB8IHN0cmluZylbXVxuICAgIGV4Y2x1ZGVGbGFncz86IHN0cmluZ1tdXG4gICAgaW5jbHVkZT86IChBbnlBdG9tIHwgc3RyaW5nKVtdXG4gICAgaW5jbHVkZUZsYWdzPzogc3RyaW5nW11cbiAgICB0cmFuc2Zvcm0/OiBib29sZWFuXG4gIH0gPSB7fSkge1xuICAgIGNvbnN0IGluc3RhbmNlcyA9IE9iamVjdC52YWx1ZXModGhpcy5faW5zdGFuY2VzKS5maWx0ZXIoaW5zdGFuY2UgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBleGNsdWRlICYmXG4gICAgICAgIGV4Y2x1ZGUuc29tZShhdG9tT3JLZXkgPT5cbiAgICAgICAgICB0eXBlb2YgYXRvbU9yS2V5ID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBpbnN0YW5jZS5rZXlIYXNoLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoYXRvbU9yS2V5LnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICA6IGluc3RhbmNlLmF0b20ua2V5ID09PSBhdG9tT3JLZXkua2V5XG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBleGNsdWRlRmxhZ3MgJiZcbiAgICAgICAgZXhjbHVkZUZsYWdzLnNvbWUoZmxhZyA9PiBpbnN0YW5jZS5hdG9tLmZsYWdzPy5pbmNsdWRlcyhmbGFnKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKCFpbmNsdWRlICYmICFpbmNsdWRlRmxhZ3MpIHJldHVybiB0cnVlXG5cbiAgICAgIGlmIChcbiAgICAgICAgaW5jbHVkZSAmJlxuICAgICAgICBpbmNsdWRlLnNvbWUoYXRvbU9yS2V5ID0+XG4gICAgICAgICAgdHlwZW9mIGF0b21PcktleSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gaW5zdGFuY2Uua2V5SGFzaC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKGF0b21PcktleS50b0xvd2VyQ2FzZSgpKVxuICAgICAgICAgICAgOiBpbnN0YW5jZS5hdG9tLmtleSA9PT0gYXRvbU9yS2V5LmtleVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBpbmNsdWRlRmxhZ3MgJiZcbiAgICAgICAgaW5jbHVkZUZsYWdzLnNvbWUoZmxhZyA9PiBpbnN0YW5jZS5hdG9tLmZsYWdzPy5pbmNsdWRlcyhmbGFnKSlcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9KVxuXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIGluc3RhbmNlcy5tYXAoaW5zdGFuY2UgPT4ge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGluc3RhbmNlLnN0b3JlLmdldFN0YXRlKClcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGluc3RhbmNlLmtleUhhc2gsXG4gICAgICAgICAgdHJhbnNmb3JtICYmIGluc3RhbmNlLmF0b20uZGVoeWRyYXRlXG4gICAgICAgICAgICA/IGluc3RhbmNlLmF0b20uZGVoeWRyYXRlKHN0YXRlKVxuICAgICAgICAgICAgOiBzdGF0ZSxcbiAgICAgICAgXVxuICAgICAgfSlcbiAgICApXG4gIH1cblxuICAvKipcbiAgICogRGVzdHJveSB0aGlzIGVjb3N5c3RlbSAtIGRlc3Ryb3kgYWxsIHRoaXMgZWNvc3lzdGVtJ3MgYXRvbSBpbnN0YW5jZXMsXG4gICAqIHJlbW92ZSBhbmQgY2xlYW4gdXAgYWxsIHBsdWdpbnMsIGFuZCByZW1vdmUgdGhpcyBlY29zeXN0ZW0gZnJvbSB0aGVcbiAgICogaW50ZXJuYWxTdG9yZS5cbiAgICpcbiAgICogRGVzdHJ1Y3Rpb24gd2lsbCBiYWlsIG91dCBieSBkZWZhdWx0IGlmIHRoaXMgZWNvc3lzdGVtIGlzIHN0aWxsIGJlaW5nXG4gICAqIHByb3ZpZGVkIHZpYSBhbiA8RWNvc3lzdGVtUHJvdmlkZXI+LiBQYXNzIGB0cnVlYCBhcyB0aGUgZmlyc3QgcGFyYW1ldGVyIHRvXG4gICAqIGZvcmNlIGRlc3RydWN0aW9uIGFueXdheS5cbiAgICovXG4gIHB1YmxpYyBkZXN0cm95KGZvcmNlPzogYm9vbGVhbikge1xuICAgIGlmICghZm9yY2UgJiYgdGhpcy5fcmVmQ291bnQgPiAwKSByZXR1cm5cblxuICAgIHRoaXMud2lwZSgpXG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGVjb3N5c3RlbSBoYXMgYmVlbiBkZXN0cm95ZWQgYWxyZWFkeVxuICAgIGNvbnN0IGVjb3N5c3RlbSA9IGludGVybmFsU3RvcmUuZ2V0U3RhdGUoKVt0aGlzLmlkXVxuICAgIGlmICghZWNvc3lzdGVtKSByZXR1cm5cblxuICAgIHRoaXMucGx1Z2lucy5mb3JFYWNoKCh7IGNsZWFudXAgfSkgPT4gY2xlYW51cCgpKVxuICAgIHRoaXMucGx1Z2lucyA9IFtdXG5cbiAgICBpbnRlcm5hbFN0b3JlLnNldFN0YXRlKHN0YXRlID0+IHtcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0geyAuLi5zdGF0ZSB9XG4gICAgICBkZWxldGUgbmV3U3RhdGVbdGhpcy5pZF1cblxuICAgICAgcmV0dXJuIG5ld1N0YXRlXG4gICAgfSlcbiAgfVxuXG4gIHB1YmxpYyBnZXQ8QSBleHRlbmRzIEF0b21CYXNlPGFueSwgW10sIGFueSwgYW55LCBhbnksIGFueT4+KFxuICAgIGF0b206IEFcbiAgKTogQXRvbVN0YXRlVHlwZTxBPlxuXG4gIHB1YmxpYyBnZXQ8QSBleHRlbmRzIEF0b21CYXNlPGFueSwgWy4uLmFueV0sIGFueSwgYW55LCBhbnksIGFueT4+KFxuICAgIGF0b206IEEsXG4gICAgcGFyYW1zOiBBdG9tUGFyYW1zVHlwZTxBPlxuICApOiBBdG9tU3RhdGVUeXBlPEE+XG5cbiAgcHVibGljIGdldDxBSSBleHRlbmRzIEF0b21JbnN0YW5jZUJhc2U8YW55LCBbLi4uYW55XSwgYW55Pj4oXG4gICAgaW5zdGFuY2U6IEFJXG4gICk6IEF0b21JbnN0YW5jZVN0YXRlVHlwZTxBST5cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhdG9tIGluc3RhbmNlJ3MgdmFsdWUuIENyZWF0ZXMgdGhlIGF0b20gaW5zdGFuY2UgaWYgaXQgZG9lc24ndFxuICAgKiBleGlzdCB5ZXQuIERvZXNuJ3QgcmVnaXN0ZXIgYW55IGdyYXBoIGRlcGVuZGVuY2llcy5cbiAgICovXG4gIHB1YmxpYyBnZXQ8QSBleHRlbmRzIEF0b21CYXNlPGFueSwgWy4uLmFueV0sIGFueSwgYW55LCBhbnksIGFueT4+KFxuICAgIGF0b206IEEgfCBBdG9tSW5zdGFuY2VCYXNlPGFueSwgWy4uLmFueV0sIGFueT4sXG4gICAgcGFyYW1zPzogQXRvbVBhcmFtc1R5cGU8QT5cbiAgKSB7XG4gICAgaWYgKGlzKGF0b20sIEF0b21JbnN0YW5jZUJhc2UpKSB7XG4gICAgICByZXR1cm4gKGF0b20gYXMgQW55QXRvbUluc3RhbmNlQmFzZSkuc3RvcmUuZ2V0U3RhdGUoKVxuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy5nZXRJbnN0YW5jZShcbiAgICAgIGF0b20gYXMgQSxcbiAgICAgIHBhcmFtcyBhcyBBdG9tUGFyYW1zVHlwZTxBPlxuICAgICkgYXMgQXRvbUluc3RhbmNlQmFzZTxhbnksIGFueSwgYW55PlxuXG4gICAgcmV0dXJuIGluc3RhbmNlLnN0b3JlLmdldFN0YXRlKClcbiAgfVxuXG4gIHB1YmxpYyBnZXRJbnN0YW5jZTxBIGV4dGVuZHMgQXRvbUJhc2U8YW55LCBbXSwgYW55LCBhbnksIGFueSwgYW55Pj4oXG4gICAgYXRvbTogQVxuICApOiBBdG9tSW5zdGFuY2VUeXBlPEE+XG5cbiAgcHVibGljIGdldEluc3RhbmNlPEEgZXh0ZW5kcyBBdG9tQmFzZTxhbnksIFsuLi5hbnldLCBhbnksIGFueSwgYW55LCBhbnk+PihcbiAgICBhdG9tOiBBLFxuICAgIHBhcmFtczogQXRvbVBhcmFtc1R5cGU8QT4sXG4gICAgZWRnZUluZm8/OiBHcmFwaEVkZ2VJbmZvXG4gICk6IEF0b21JbnN0YW5jZVR5cGU8QT5cblxuICBwdWJsaWMgZ2V0SW5zdGFuY2U8QUkgZXh0ZW5kcyBBdG9tSW5zdGFuY2VCYXNlPGFueSwgYW55LCBhbnk+PihcbiAgICBpbnN0YW5jZTogQUksXG4gICAgcGFyYW1zPzogW10sXG4gICAgZWRnZUluZm8/OiBHcmFwaEVkZ2VJbmZvXG4gICk6IEFJXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXRvbSBpbnN0YW5jZS4gQ3JlYXRlcyB0aGUgYXRvbSBpbnN0YW5jZSBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gICAqIHlldC4gRG9lc24ndCByZWdpc3RlciBhbnkgZ3JhcGggZGVwZW5kZW5jaWVzLlxuICAgKi9cbiAgcHVibGljIGdldEluc3RhbmNlPEEgZXh0ZW5kcyBBdG9tQmFzZTxhbnksIFsuLi5hbnldLCBhbnksIGFueSwgYW55LCBhbnk+PihcbiAgICBhdG9tOiBBIHwgQXRvbUluc3RhbmNlQmFzZTxhbnksIFsuLi5hbnldLCBhbnk+LFxuICAgIHBhcmFtcz86IEF0b21QYXJhbXNUeXBlPEE+XG4gICkge1xuICAgIGlmIChpcyhhdG9tLCBBdG9tSW5zdGFuY2VCYXNlKSkgcmV0dXJuIGF0b21cblxuICAgIGNvbnN0IGtleUhhc2ggPSAoYXRvbSBhcyBBKS5nZXRLZXlIYXNoKHRoaXMsIHBhcmFtcylcblxuICAgIC8vIHRyeSB0byBmaW5kIGFuIGV4aXN0aW5nIGluc3RhbmNlXG4gICAgY29uc3QgZXhpc3RpbmdJbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlc1trZXlIYXNoXVxuICAgIGlmIChleGlzdGluZ0luc3RhbmNlKSByZXR1cm4gZXhpc3RpbmdJbnN0YW5jZVxuXG4gICAgLy8gY3JlYXRlIGEgbmV3IGluc3RhbmNlXG4gICAgY29uc3QgcmVzb2x2ZWRBdG9tID0gdGhpcy5yZXNvbHZlQXRvbShhdG9tIGFzIEEpXG4gICAgdGhpcy5fZ3JhcGguYWRkTm9kZShrZXlIYXNoKVxuXG4gICAgY29uc3QgbmV3SW5zdGFuY2UgPSByZXNvbHZlZEF0b20uX2NyZWF0ZUluc3RhbmNlKFxuICAgICAgdGhpcyxcbiAgICAgIGtleUhhc2gsXG4gICAgICAocGFyYW1zIHx8IFtdKSBhcyBBdG9tUGFyYW1zVHlwZTxBPlxuICAgIClcbiAgICB0aGlzLl9pbnN0YW5jZXNba2V5SGFzaF0gPSBuZXdJbnN0YW5jZVxuICAgIG5ld0luc3RhbmNlLl9pbml0KClcblxuICAgIHJldHVybiBuZXdJbnN0YW5jZVxuICB9XG5cbiAgLyoqXG4gICAqIEh5ZHJhdGUgdGhlIHN0YXRlIG9mIGF0b21zIGluIHRoaXMgZWNvc3lzdGVtIHdpdGggYW4gb2JqZWN0IG1hcHBpbmcgYXRvbVxuICAgKiBpbnN0YW5jZSBrZXlIYXNoZXMgdG8gdGhlaXIgaHlkcmF0ZWQgc3RhdGUuIFRoaXMgb2JqZWN0IHdpbGwgdXN1YWxseSBiZSB0aGVcbiAgICogcmVzdWx0IG9mIGEgY2FsbCB0byBgZWNvc3lzdGVtLmRlaHlkcmF0ZSgpYC5cbiAgICpcbiAgICogVGhpcyBpcyB0aGUga2V5IHRvIFNTUi4gVGhlIGVjb3N5c3RlbSdzIGluaXRpYWwgc3RhdGUgY2FuIGJlIGRlaHlkcmF0ZWQgb25cbiAgICogdGhlIHNlcnZlciwgc2VudCB0byB0aGUgY2xpZW50IGluIHNlcmlhbGl6ZWQgZm9ybSwgZGVzZXJpYWxpemVkLCBhbmQgcGFzc2VkXG4gICAqIHRvIGBlY29zeXN0ZW0uaHlkcmF0ZSgpYC4gRXZlcnkgYXRvbSBpbnN0YW5jZSB0aGF0IGV2YWx1YXRlcyBhZnRlciB0aGlzXG4gICAqIGh5ZHJhdGlvbiBjYW4gdXNlIHRoZSBgaHlkcmF0ZWAgaW5qZWN0U3RvcmUgY29uZmlnIG9wdGlvbiB0byByZXRyaWV2ZSBpdHNcbiAgICogaHlkcmF0ZWQgc3RhdGUuXG4gICAqXG4gICAqIFBhc3MgYHJldHJvYWN0aXZlOiBmYWxzZWAgdG8gcHJldmVudCB0aGlzIGNhbGwgZnJvbSB1cGRhdGluZyB0aGUgc3RhdGUgb2ZcbiAgICogYWxsIGF0b20gaW5zdGFuY2VzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gaW5pdGlhbGl6ZWQgd2l0aCB0aGlzIG5ld1xuICAgKiBoeWRyYXRpb24uIEh5ZHJhdGlvbiBpcyByZXRyb2FjdGl2ZSBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBlY29zeXN0ZW0uaHlkcmF0ZShkZWh5ZHJhdGVkU3RhdGUsIHsgcmV0cm9hY3RpdmU6IGZhbHNlIH0pXG4gICAqIGBgYFxuICAgKi9cbiAgcHVibGljIGh5ZHJhdGUoXG4gICAgZGVoeWRyYXRlZFN0YXRlOiBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgIGNvbmZpZz86IHsgcmV0cm9hY3RpdmU/OiBib29sZWFuIH1cbiAgKSB7XG4gICAgdGhpcy5oeWRyYXRpb24gPSB7IC4uLnRoaXMuaHlkcmF0aW9uLCAuLi5kZWh5ZHJhdGVkU3RhdGUgfVxuXG4gICAgaWYgKGNvbmZpZz8ucmV0cm9hY3RpdmUgPT09IGZhbHNlKSByZXR1cm5cblxuICAgIE9iamVjdC5lbnRyaWVzKGRlaHlkcmF0ZWRTdGF0ZSkuZm9yRWFjaCgoW2tleSwgdmFsXSkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZXNba2V5XVxuXG4gICAgICBpZiAoIWluc3RhbmNlKSByZXR1cm5cblxuICAgICAgaW5zdGFuY2Uuc2V0U3RhdGUoXG4gICAgICAgIGluc3RhbmNlLmF0b20uaHlkcmF0ZSA/IGluc3RhbmNlLmF0b20uaHlkcmF0ZSh2YWwpIDogdmFsXG4gICAgICApXG5cbiAgICAgIGRlbGV0ZSB0aGlzLmh5ZHJhdGlvbj8uW2tleV1cbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBvYmplY3Qgb2YgYWxsIGF0b20gaW5zdGFuY2VzIGluIHRoaXMgZWNvc3lzdGVtLlxuICAgKlxuICAgKiBQYXNzIGFuIGF0b20gb3IgYXRvbSBrZXkgc3RyaW5nIHRvIG9ubHkgcmV0dXJuIGluc3RhbmNlcyB3aG9zZSBrZXlIYXNoXG4gICAqIHdlYWtseSBtYXRjaGVzIHRoZSBwYXNzZWQga2V5LlxuICAgKi9cbiAgcHVibGljIGluc3BlY3RJbnN0YW5jZXMoYXRvbT86IEFueUF0b20gfCBzdHJpbmcpIHtcbiAgICBjb25zdCBpc0F0b20gPSAoYXRvbSBhcyBBbnlBdG9tKT8ua2V5XG4gICAgY29uc3QgZmlsdGVyS2V5ID0gaXNBdG9tID8gKGF0b20gYXMgQW55QXRvbSk/LmtleSA6IChhdG9tIGFzIHN0cmluZylcbiAgICBjb25zdCBoYXNoOiBSZWNvcmQ8c3RyaW5nLCBBdG9tSW5zdGFuY2VCYXNlPGFueSwgYW55LCBhbnk+PiA9IHt9XG5cbiAgICBPYmplY3QudmFsdWVzKHRoaXMuX2luc3RhbmNlcylcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmtleUhhc2gubG9jYWxlQ29tcGFyZShiLmtleUhhc2gpKVxuICAgICAgLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgZmlsdGVyS2V5ICYmXG4gICAgICAgICAgKGlzQXRvbVxuICAgICAgICAgICAgPyBpbnN0YW5jZS5hdG9tLmtleSAhPT0gZmlsdGVyS2V5XG4gICAgICAgICAgICA6ICFpbnN0YW5jZS5rZXlIYXNoLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoZmlsdGVyS2V5KSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBoYXNoW2luc3RhbmNlLmtleUhhc2hdID0gaW5zdGFuY2VcbiAgICAgIH0pXG5cbiAgICByZXR1cm4gaGFzaFxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIFplZHV4UGx1Z2luIHRvIHRoaXMgZWNvc3lzdGVtLiBUaGlzIGVjb3N5c3RlbSB3aWxsIHN1YnNjcmliZSB0byB0aGVcbiAgICogcGx1Z2luJ3MgbW9kU3RvcmUsIHdob3NlIHN0YXRlIGNhbiBiZSBjaGFuZ2VkIHRvIHJlYWN0aXZlbHkgdXBkYXRlIHRoZSBtb2RzXG4gICAqIG9mIHRoaXMgZWNvc3lzdGVtLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFsc28gY2FsbCB0aGUgcGFzc2VkIHBsdWdpbidzIGAucmVnaXN0ZXJFY29zeXN0ZW1gIG1ldGhvZCxcbiAgICogYWxsb3dpbmcgdGhlIHBsdWdpbiB0byBzdWJzY3JpYmUgdG8gdGhpcyBlY29zeXN0ZW0ncyBtb2RCdXNcbiAgICpcbiAgICogVGhlIHBsdWdpbiB3aWxsIHJlbWFpbiBwYXJ0IG9mIHRoaXMgZWNvc3lzdGVtIHVudGlsIGl0IGlzIHVucmVnaXN0ZXJlZCBvclxuICAgKiB0aGlzIGVjb3N5c3RlbSBpcyBkZXN0cm95ZWQuIGAud2lwZSgpYCBhbmQgYC5yZXNldCgpYCBkb24ndCByZW1vdmUgcGx1Z2lucy5cbiAgICogSG93ZXZlciwgYSBwbHVnaW4gX2Nhbl8gc2V0IHRoZSBgZWNvc3lzdGVtV2lwZWRgIG1vZCBhbmQgcmVhY3QgdG8gdGhvc2VcbiAgICogZXZlbnRzLlxuICAgKi9cbiAgcHVibGljIHJlZ2lzdGVyUGx1Z2luKHBsdWdpbjogWmVkdXhQbHVnaW4pIHtcbiAgICBpZiAodGhpcy5wbHVnaW5zLnNvbWUoZGVzY3JpcHRvciA9PiBkZXNjcmlwdG9yLnBsdWdpbiA9PT0gcGx1Z2luKSkgcmV0dXJuXG5cbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBwbHVnaW4ubW9kU3RvcmUuc3Vic2NyaWJlKChuZXdTdGF0ZSwgb2xkU3RhdGUpID0+IHtcbiAgICAgIHRoaXMucmVjYWxjdWxhdGVNb2RzKG5ld1N0YXRlLCBvbGRTdGF0ZSlcbiAgICB9KVxuXG4gICAgY29uc3QgY2xlYW51cFJlZ2lzdHJhdGlvbiA9IHBsdWdpbi5yZWdpc3RlckVjb3N5c3RlbSh0aGlzKVxuICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKVxuICAgICAgaWYgKGNsZWFudXBSZWdpc3RyYXRpb24pIGNsZWFudXBSZWdpc3RyYXRpb24oKVxuICAgIH1cblxuICAgIHRoaXMucGx1Z2lucy5wdXNoKHsgY2xlYW51cCwgcGx1Z2luIH0pXG4gICAgdGhpcy5yZWNhbGN1bGF0ZU1vZHMocGx1Z2luLm1vZFN0b3JlLmdldFN0YXRlKCkpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGFsbCBwYXNzZWQgYXRvbXMgZnJvbSB0aGlzIGVjb3N5c3RlbSdzIGxpc3Qgb2YgYXRvbSBvdmVycmlkZXMuIERvZXNcbiAgICogbm90aGluZyBmb3IgcGFzc2VkIGF0b21zIHRoYXQgYXJlbid0IGN1cnJlbnRseSBpbiB0aGUgb3ZlcnJpZGVzIGxpc3QuXG4gICAqXG4gICAqIEZvcmNlIGRlc3Ryb3lzIGFsbCBpbnN0YW5jZXMgb2YgYWxsIHJlbW92ZWQgYXRvbXMuIFRoaXMgZm9yY2VkIGRlc3RydWN0aW9uXG4gICAqIHdpbGwgY2F1c2UgZGVwZW5kZW50cyBvZiB0aG9zZSBpbnN0YW5jZXMgdG8gcmVjcmVhdGUgdGhlaXIgZGVwZW5kZW5jeSBhdG9tXG4gICAqIGluc3RhbmNlIHdpdGhvdXQgdXNpbmcgYW4gb3ZlcnJpZGUuXG4gICAqL1xuICBwdWJsaWMgcmVtb3ZlT3ZlcnJpZGVzKG92ZXJyaWRlczogKEFueUF0b20gfCBzdHJpbmcpW10pIHtcbiAgICB0aGlzLm92ZXJyaWRlcyA9IG1hcE92ZXJyaWRlcyhcbiAgICAgIE9iamVjdC52YWx1ZXModGhpcy5vdmVycmlkZXMpLmZpbHRlcihhdG9tID0+XG4gICAgICAgIG92ZXJyaWRlcy5ldmVyeShvdmVycmlkZSA9PiB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gdHlwZW9mIG92ZXJyaWRlID09PSAnc3RyaW5nJyA/IG92ZXJyaWRlIDogb3ZlcnJpZGUua2V5XG5cbiAgICAgICAgICByZXR1cm4ga2V5ICE9PSBhdG9tLmtleVxuICAgICAgICB9KVxuICAgICAgKVxuICAgIClcblxuICAgIG92ZXJyaWRlcy5mb3JFYWNoKG92ZXJyaWRlID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlcyA9IHRoaXMuaW5zcGVjdEluc3RhbmNlcyhvdmVycmlkZSlcblxuICAgICAgT2JqZWN0LnZhbHVlcyhpbnN0YW5jZXMpLmZvckVhY2goaW5zdGFuY2UgPT4gaW5zdGFuY2UuZGVzdHJveSh0cnVlKSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIGFsbCBhdG9tIGluc3RhbmNlcyBpbiB0aGlzIGVjb3N5c3RlbSwgcnVucyB0aGUgY2xlYW51cCBmdW5jdGlvblxuICAgKiByZXR1cm5lZCBmcm9tIGBvblJlYWR5YCAoaWYgYW55KSwgYW5kIGNhbGxzIGBvblJlYWR5YCBhZ2FpbiB0byByZWluaXRpYWxpemVcbiAgICogdGhlIGVjb3N5c3RlbS5cbiAgICovXG4gIHB1YmxpYyByZXNldChuZXdDb250ZXh0PzogQ29udGV4dCkge1xuICAgIHRoaXMud2lwZSgpXG5cbiAgICBjb25zdCBwcmV2Q29udGV4dCA9IHRoaXMuY29udGV4dFxuICAgIGlmICh0eXBlb2YgbmV3Q29udGV4dCAhPT0gJ3VuZGVmaW5lZCcpIHRoaXMuY29udGV4dCA9IG5ld0NvbnRleHRcblxuICAgIHRoaXMuY2xlYW51cCA9IHRoaXMuX29uUmVhZHk/Lih0aGlzLCBwcmV2Q29udGV4dClcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIGFuIEF0b21TZWxlY3RvciBzdGF0aWNhbGx5IC0gd2l0aG91dCByZWdpc3RlcmluZyBhbnkgZGVwZW5kZW5jaWVzIG9yXG4gICAqIHVwZGF0aW5nIGFueSBjYWNoZXMuIElmIHdlJ3ZlIGFscmVhZHkgY2FjaGVkIHRoaXMgZXhhY3Qgc2VsZWN0b3IgKyBhcmdzXG4gICAqIGNvbWJvLCByZXR1cm5zIHRoZSBjYWNoZWQgdmFsdWUgd2l0aG91dCBydW5uaW5nIHRoZSBzZWxlY3RvciBhZ2FpblxuICAgKi9cbiAgcHVibGljIHNlbGVjdDxULCBBcmdzIGV4dGVuZHMgYW55W10+KFxuICAgIHNlbGVjdGFibGU6IFNlbGVjdGFibGU8VCwgQXJncz4sXG4gICAgLi4uYXJnczogQXJnc1xuICApOiBUIHtcbiAgICBpZiAoaXMoc2VsZWN0YWJsZSwgU2VsZWN0b3JDYWNoZUl0ZW0pKSB7XG4gICAgICByZXR1cm4gKHNlbGVjdGFibGUgYXMgU2VsZWN0b3JDYWNoZUl0ZW08VCwgQXJncz4pLnJlc3VsdCBhcyBUXG4gICAgfVxuXG4gICAgY29uc3QgYXRvbVNlbGVjdG9yID0gc2VsZWN0YWJsZSBhcyBBdG9tU2VsZWN0b3JPckNvbmZpZzxULCBBcmdzPlxuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5zZWxlY3RvckNhY2hlLndlYWtHZXRDYWNoZShhdG9tU2VsZWN0b3IsIGFyZ3MpXG4gICAgaWYgKGNhY2hlKSByZXR1cm4gY2FjaGUucmVzdWx0IGFzIFRcblxuICAgIGNvbnN0IHJlc29sdmVkU2VsZWN0b3IgPVxuICAgICAgdHlwZW9mIGF0b21TZWxlY3RvciA9PT0gJ2Z1bmN0aW9uJyA/IGF0b21TZWxlY3RvciA6IGF0b21TZWxlY3Rvci5zZWxlY3RvclxuXG4gICAgcmV0dXJuIHJlc29sdmVkU2VsZWN0b3IoXG4gICAgICB7XG4gICAgICAgIGVjb3N5c3RlbTogdGhpcyxcbiAgICAgICAgZ2V0OiB0aGlzLmdldC5iaW5kKHRoaXMpLFxuICAgICAgICBnZXRJbnN0YW5jZTogdGhpcy5nZXRJbnN0YW5jZS5iaW5kKHRoaXMpLFxuICAgICAgICBzZWxlY3Q6IHRoaXMuc2VsZWN0LmJpbmQodGhpcyksXG4gICAgICB9LFxuICAgICAgLi4uYXJnc1xuICAgIClcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wbGV0ZWx5IHJlcGxhY2UgdGhpcyBlY29zeXN0ZW0ncyBjdXJyZW50IGxpc3Qgb2YgYXRvbSBvdmVycmlkZXMgd2l0aCBhXG4gICAqIG5ldyBsaXN0LlxuICAgKlxuICAgKiBGb3JjZSBkZXN0cm95cyBhbGwgaW5zdGFuY2VzIG9mIGFsbCBwcmV2aW91c2x5LSBhbmQgbmV3bHktb3ZlcnJpZGRlbiBhdG9tcy5cbiAgICogVGhpcyBmb3JjZWQgZGVzdHJ1Y3Rpb24gd2lsbCBjYXVzZSBkZXBlbmRlbnRzIG9mIHRob3NlIGluc3RhbmNlcyB0b1xuICAgKiByZWNyZWF0ZSB0aGVpciBkZXBlbmRlbmN5IGF0b20gaW5zdGFuY2UuXG4gICAqL1xuICBwdWJsaWMgc2V0T3ZlcnJpZGVzKG5ld092ZXJyaWRlczogQW55QXRvbVtdKSB7XG4gICAgY29uc3Qgb2xkT3ZlcnJpZGVzID0gdGhpcy5vdmVycmlkZXNcblxuICAgIHRoaXMub3ZlcnJpZGVzID0gbWFwT3ZlcnJpZGVzKG5ld092ZXJyaWRlcylcblxuICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSByZXR1cm5cblxuICAgIG5ld092ZXJyaWRlcy5mb3JFYWNoKGF0b20gPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2VzID0gdGhpcy5pbnNwZWN0SW5zdGFuY2VzKGF0b20pXG5cbiAgICAgIE9iamVjdC52YWx1ZXMoaW5zdGFuY2VzKS5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgICAgaW5zdGFuY2UuZGVzdHJveSh0cnVlKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaWYgKCFvbGRPdmVycmlkZXMpIHJldHVyblxuXG4gICAgT2JqZWN0LnZhbHVlcyhvbGRPdmVycmlkZXMpLmZvckVhY2goYXRvbSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZXMgPSB0aGlzLmluc3BlY3RJbnN0YW5jZXMoYXRvbSlcblxuICAgICAgT2JqZWN0LnZhbHVlcyhpbnN0YW5jZXMpLmZvckVhY2goaW5zdGFuY2UgPT4ge1xuICAgICAgICBpbnN0YW5jZS5kZXN0cm95KHRydWUpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlciBhIHBsdWdpbiByZWdpc3RlcmVkIGluIHRoaXMgZWNvc3lzdGVtIHZpYSBgLnJlZ2lzdGVyUGx1Z2luKClgXG4gICAqL1xuICBwdWJsaWMgdW5yZWdpc3RlclBsdWdpbihwbHVnaW46IFplZHV4UGx1Z2luKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnBsdWdpbnMuZmluZEluZGV4KFxuICAgICAgZGVzY3JpcHRvciA9PiBkZXNjcmlwdG9yLnBsdWdpbiA9PT0gcGx1Z2luXG4gICAgKVxuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVyblxuXG4gICAgdGhpcy5wbHVnaW5zW2luZGV4XS5jbGVhbnVwKClcbiAgICB0aGlzLnBsdWdpbnMuc3BsaWNlKGluZGV4LCAxKVxuICAgIHRoaXMucmVjYWxjdWxhdGVNb2RzKHVuZGVmaW5lZCwgcGx1Z2luLm1vZFN0b3JlLmdldFN0YXRlKCkpXG4gIH1cblxuICBwdWJsaWMgdmlld0dyYXBoKHZpZXc6ICdib3R0b20tdXAnKTogR3JhcGhWaWV3UmVjdXJzaXZlXG4gIHB1YmxpYyB2aWV3R3JhcGgoXG4gICAgdmlldz86ICdmbGF0J1xuICApOiBSZWNvcmQ8XG4gICAgc3RyaW5nLFxuICAgIHtcbiAgICAgIGRlcGVuZGVuY2llczogeyBrZXk6IHN0cmluZzsgb3BlcmF0aW9uOiBzdHJpbmcgfVtdXG4gICAgICBkZXBlbmRlbnRzOiB7IGtleTogc3RyaW5nOyBvcGVyYXRpb246IHN0cmluZyB9W11cbiAgICAgIHdlaWdodDogbnVtYmVyXG4gICAgfVxuICA+XG4gIHB1YmxpYyB2aWV3R3JhcGgodmlldzogJ3RvcC1kb3duJyk6IEdyYXBoVmlld1JlY3Vyc2l2ZVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgZ3JhcGggb2YgdGhpcyBlY29zeXN0ZW0uIFRoZXJlIGFyZSAzIHZpZXdzOlxuICAgKlxuICAgKiBGbGF0IChkZWZhdWx0KS4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBhbGwgZ3JhcGggbm9kZXMgb24gdGhlIHRvcCBsYXllcixcbiAgICogZWFjaCBub2RlIHBvaW50aW5nIHRvIGl0cyBkZXBlbmRlbmNpZXMgYW5kIGRlcGVuZGVudHMuIE5vIG5lc3RpbmcuXG4gICAqXG4gICAqIEJvdHRvbS1VcC4gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGxlYWYgbm9kZXMgb2YgdGhlIGdyYXBoXG4gICAqIChub2RlcyB0aGF0IGhhdmUgbm8gaW50ZXJuYWwgZGVwZW5kZW50cyksIGVhY2ggbm9kZSBjb250YWluaW5nIGFuIG9iamVjdCBvZlxuICAgKiBpdHMgcGFyZW50IG5vZGVzLCByZWN1cnNpdmVseS5cbiAgICpcbiAgICogVG9wLURvd24uIFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSByb290IG5vZGVzIG9mIHRoZSBncmFwaFxuICAgKiAobm9kZXMgdGhhdCBoYXZlIG5vIGRlcGVuZGVuY2llcyksIGVhY2ggbm9kZSBjb250YWluaW5nIGFuIG9iamVjdCBvZiBpdHNcbiAgICogY2hpbGQgbm9kZXMsIHJlY3Vyc2l2ZWx5LlxuICAgKi9cbiAgcHVibGljIHZpZXdHcmFwaCh2aWV3Pzogc3RyaW5nKSB7XG4gICAgaWYgKHZpZXcgIT09ICd0b3AtZG93bicgJiYgdmlldyAhPT0gJ2JvdHRvbS11cCcpIHtcbiAgICAgIGNvbnN0IGhhc2g6IFJlY29yZDxcbiAgICAgICAgc3RyaW5nLFxuICAgICAgICB7XG4gICAgICAgICAgZGVwZW5kZW5jaWVzOiB7IGtleTogc3RyaW5nOyBvcGVyYXRpb246IHN0cmluZyB9W11cbiAgICAgICAgICBkZXBlbmRlbnRzOiB7IGtleTogc3RyaW5nOyBvcGVyYXRpb246IHN0cmluZyB9W11cbiAgICAgICAgICB3ZWlnaHQ6IG51bWJlclxuICAgICAgICB9XG4gICAgICA+ID0ge31cblxuICAgICAgT2JqZWN0LmtleXModGhpcy5fZ3JhcGgubm9kZXMpLmZvckVhY2goY2FjaGVLZXkgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5fZ3JhcGgubm9kZXNbY2FjaGVLZXldXG5cbiAgICAgICAgaGFzaFtjYWNoZUtleV0gPSB7XG4gICAgICAgICAgZGVwZW5kZW5jaWVzOiBPYmplY3Qua2V5cyhub2RlLmRlcGVuZGVuY2llcykubWFwKGtleSA9PiAoe1xuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgb3BlcmF0aW9uOiB0aGlzLl9ncmFwaC5ub2Rlc1trZXldLmRlcGVuZGVudHNbY2FjaGVLZXldLm9wZXJhdGlvbixcbiAgICAgICAgICB9KSksXG4gICAgICAgICAgZGVwZW5kZW50czogT2JqZWN0LmtleXMobm9kZS5kZXBlbmRlbnRzKS5tYXAoa2V5ID0+ICh7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBvcGVyYXRpb246IG5vZGUuZGVwZW5kZW50c1trZXldLm9wZXJhdGlvbixcbiAgICAgICAgICB9KSksXG4gICAgICAgICAgd2VpZ2h0OiBub2RlLndlaWdodCxcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIGhhc2hcbiAgICB9XG5cbiAgICBjb25zdCBoYXNoOiBHcmFwaFZpZXdSZWN1cnNpdmUgPSB7fVxuXG4gICAgT2JqZWN0LmtleXModGhpcy5fZ3JhcGgubm9kZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLl9ncmFwaC5ub2Rlc1trZXldXG4gICAgICBjb25zdCBpc1RvcExldmVsID1cbiAgICAgICAgdmlldyA9PT0gJ2JvdHRvbS11cCdcbiAgICAgICAgICA/IE9iamVjdC5rZXlzKG5vZGUuZGVwZW5kZW50cykuZXZlcnkoa2V5ID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZGVwZW5kZW50ID0gbm9kZS5kZXBlbmRlbnRzW2tleV1cblxuICAgICAgICAgICAgICByZXR1cm4gZGVwZW5kZW50LmZsYWdzICYgRXh0ZXJuYWxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgOiAhT2JqZWN0LmtleXMobm9kZS5kZXBlbmRlbmNpZXMpLmxlbmd0aFxuXG4gICAgICBpZiAoaXNUb3BMZXZlbCkge1xuICAgICAgICBoYXNoW2tleV0gPSB7fVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCByZWN1cnNlID0gKG5vZGU/OiBFY29zeXN0ZW1HcmFwaE5vZGUpID0+IHtcbiAgICAgIGlmICghbm9kZSkgcmV0dXJuXG5cbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhcbiAgICAgICAgdmlldyA9PT0gJ2JvdHRvbS11cCcgPyBub2RlLmRlcGVuZGVuY2llcyA6IG5vZGUuZGVwZW5kZW50c1xuICAgICAgKVxuICAgICAgY29uc3QgY2hpbGRyZW46IEdyYXBoVmlld1JlY3Vyc2l2ZSA9IHt9XG5cbiAgICAgIGtleXMuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHJlY3Vyc2UodGhpcy5fZ3JhcGgubm9kZXNba2V5XSlcblxuICAgICAgICBpZiAoY2hpbGQpIGNoaWxkcmVuW2tleV0gPSBjaGlsZFxuICAgICAgfSlcblxuICAgICAgcmV0dXJuIGNoaWxkcmVuXG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoaGFzaCkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX2dyYXBoLm5vZGVzW2tleV1cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gcmVjdXJzZShub2RlKVxuXG4gICAgICBpZiAoY2hpbGRyZW4pIGhhc2hba2V5XSA9IGNoaWxkcmVuXG4gICAgfSlcblxuICAgIHJldHVybiBoYXNoXG4gIH1cblxuICAvKipcbiAgICogR2V0IGFuIGF0b20gaW5zdGFuY2UgdmFsdWUuIERvbid0IGNyZWF0ZSB0aGUgYXRvbSBpbnN0YW5jZSBpZiBpdCBkb2Vzbid0XG4gICAqIGV4aXN0LiBEb24ndCByZWdpc3RlciBhbnkgZ3JhcGggZGVwZW5kZW5jaWVzLlxuICAgKi9cbiAgcHVibGljIHdlYWtHZXQ8QSBleHRlbmRzIEF0b21CYXNlPGFueSwgW10sIGFueSwgYW55LCBhbnksIGFueT4+KFxuICAgIGF0b206IEFcbiAgKTogQXRvbVN0YXRlVHlwZTxBPiB8IHVuZGVmaW5lZFxuXG4gIHB1YmxpYyB3ZWFrR2V0PEEgZXh0ZW5kcyBBdG9tQmFzZTxhbnksIFsuLi5hbnldLCBhbnksIGFueSwgYW55LCBhbnk+PihcbiAgICBhdG9tOiBBLFxuICAgIHBhcmFtczogQXRvbVBhcmFtc1R5cGU8QT5cbiAgKTogQXRvbVN0YXRlVHlwZTxBPiB8IHVuZGVmaW5lZFxuXG4gIHB1YmxpYyB3ZWFrR2V0PEEgZXh0ZW5kcyBBdG9tQmFzZTxhbnksIFsuLi5hbnldLCBhbnksIGFueSwgYW55LCBhbnk+PihcbiAgICBhdG9tOiBBLFxuICAgIHBhcmFtcz86IEF0b21QYXJhbXNUeXBlPEE+XG4gICkge1xuICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy53ZWFrR2V0SW5zdGFuY2UoXG4gICAgICBhdG9tIGFzIEEsXG4gICAgICBwYXJhbXMgYXMgQXRvbVBhcmFtc1R5cGU8QT5cbiAgICApIGFzIEF0b21JbnN0YW5jZUJhc2U8YW55LCBhbnksIGFueT5cblxuICAgIHJldHVybiBpbnN0YW5jZT8uc3RvcmUuZ2V0U3RhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbiBhdG9tIGluc3RhbmNlLiBEb24ndCBjcmVhdGUgdGhlIGF0b20gaW5zdGFuY2UgaWYgaXQgZG9lc24ndCBleGlzdC5cbiAgICogRG9uJ3QgcmVnaXN0ZXIgYW55IGdyYXBoIGRlcGVuZGVuY2llcy5cbiAgICovXG4gIHB1YmxpYyB3ZWFrR2V0SW5zdGFuY2U8QSBleHRlbmRzIEF0b21CYXNlPGFueSwgW10sIGFueSwgYW55LCBhbnksIGFueT4+KFxuICAgIGF0b206IEFcbiAgKTogQXRvbUluc3RhbmNlVHlwZTxBPiB8IHVuZGVmaW5lZFxuXG4gIHB1YmxpYyB3ZWFrR2V0SW5zdGFuY2U8QSBleHRlbmRzIEF0b21CYXNlPGFueSwgWy4uLmFueV0sIGFueSwgYW55LCBhbnksIGFueT4+KFxuICAgIGF0b206IEEsXG4gICAgcGFyYW1zOiBBdG9tUGFyYW1zVHlwZTxBPlxuICApOiBBdG9tSW5zdGFuY2VUeXBlPEE+IHwgdW5kZWZpbmVkXG5cbiAgcHVibGljIHdlYWtHZXRJbnN0YW5jZTxBIGV4dGVuZHMgQW55QXRvbSA9IGFueT4oXG4gICAga2V5OiBzdHJpbmdcbiAgKTogQXRvbUluc3RhbmNlVHlwZTxBPiB8IHVuZGVmaW5lZFxuXG4gIHB1YmxpYyB3ZWFrR2V0SW5zdGFuY2U8QSBleHRlbmRzIEF0b21CYXNlPGFueSwgWy4uLmFueV0sIGFueSwgYW55LCBhbnksIGFueT4+KFxuICAgIGF0b206IEEgfCBzdHJpbmcsXG4gICAgcGFyYW1zPzogQXRvbVBhcmFtc1R5cGU8QT5cbiAgKSB7XG4gICAgaWYgKHR5cGVvZiBhdG9tICE9PSAnc3RyaW5nJykge1xuICAgICAgY29uc3Qga2V5SGFzaCA9IChhdG9tIGFzIEEpLmdldEtleUhhc2godGhpcywgcGFyYW1zKVxuXG4gICAgICAvLyB0cnkgdG8gZmluZCBhbiBleGlzdGluZyBpbnN0YW5jZVxuICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlc1trZXlIYXNoXVxuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuaW5zcGVjdEluc3RhbmNlcyhhdG9tKSlbMF0gYXNcbiAgICAgIHwgQXRvbUluc3RhbmNlVHlwZTxBPlxuICAgICAgfCB1bmRlZmluZWRcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHJlYXNvbnMgZGV0YWlsaW5nIHdoeSB0aGUgY3VycmVudCBhdG9tIGluc3RhbmNlIG9yXG4gICAqIHNlbGVjdG9yIGlzIGV2YWx1YXRpbmcuXG4gICAqXG4gICAqIFJldHVybnMgdW5kZWZpbmVkIGlmIG5vdGhpbmcgaXMgY3VycmVudGx5IGV2YWx1YXRpbmcuIFJldHVybnMgYW4gZW1wdHlcbiAgICogYXJyYXkgaWYgdGhpcyBpcyB0aGUgZmlyc3QgZXZhbHVhdGlvbiBvZiB0aGUgaW5zdGFuY2Ugb3Igc2VsZWN0b3IuXG4gICAqL1xuICBwdWJsaWMgd2h5KCkge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9ldmFsdWF0aW9uU3RhY2sucmVhZCgpXG5cbiAgICBpZiAoIWl0ZW0pIHJldHVyblxuXG4gICAgaWYgKChpdGVtIGFzIFNlbGVjdG9yU3RhY2tJdGVtKS5jYWNoZSkge1xuICAgICAgcmV0dXJuIChpdGVtIGFzIFNlbGVjdG9yU3RhY2tJdGVtKS5jYWNoZS5uZXh0RXZhbHVhdGlvblJlYXNvbnNcbiAgICB9XG5cbiAgICByZXR1cm4gKGl0ZW0gYXMgSW5zdGFuY2VTdGFja0l0ZW0pLmluc3RhbmNlLl9uZXh0RXZhbHVhdGlvblJlYXNvbnNcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IGFsbCBhdG9tIGluc3RhbmNlcyBpbiB0aGlzIGVjb3N5c3RlbS4gQWxzbyBydW4gdGhlIGNsZWFudXAgZnVuY3Rpb25cbiAgICogcmV0dXJuZWQgZnJvbSB0aGUgb25SZWFkeSBjYWxsYmFjayAoaWYgYW55KS4gRG9uJ3QgcmVtb3ZlIHBsdWdpbnMgb3IgcmUtcnVuXG4gICAqIHRoZSBvblJlYWR5IGNhbGxiYWNrLlxuICAgKlxuICAgKiBJbXBvcnRhbnQhIFRoaXMgbWV0aG9kIGlzIG1vc3RseSBmb3IgaW50ZXJuYWwgdXNlLiBZb3Ugd29uJ3QgdHlwaWNhbGx5IHdhbnRcbiAgICogdG8gY2FsbCB0aGlzIG1ldGhvZC4gUHJlZmVyIGAucmVzZXQoKWAgd2hpY2ggcmUtcnVucyB0aGUgb25SZWFkeSBjYWxsYmFja1xuICAgKiBhZnRlciB3aXBpbmcgdGhlIGVjb3N5c3RlbSwgYWxsb3dpbmcgb25SZWFkeSB0byByZS1pbml0aWFsaXplIHRoZSBlY29zeXN0ZW1cbiAgICogLSBwcmVsb2FkaW5nIGF0b21zLCByZWdpc3RlcmluZyBwbHVnaW5zLCBjb25maWd1cmluZyBjb250ZXh0LCBldGNcbiAgICovXG4gIHB1YmxpYyB3aXBlKCkge1xuICAgIC8vIGNhbGwgY2xlYW51cCBmdW5jdGlvbiBmaXJzdCBzbyBpdCBjYW4gY29uZmlndXJlIHRoZSBlY29zeXN0ZW0gZm9yIGNsZWFudXBcbiAgICBpZiAodGhpcy5jbGVhbnVwKSB0aGlzLmNsZWFudXAoKVxuXG4gICAgLy8gVE9ETzogRGVsZXRlIG5vZGVzIGluIGFuIG9wdGltYWwgb3JkZXIsIHN0YXJ0aW5nIHdpdGggbm9kZXMgd2l0aCBub1xuICAgIC8vIGludGVybmFsIGRlcGVuZGVudHMuIFRoaXMgaXMgZGlmZmVyZW50IGZyb20gaGlnaGVzdC13ZWlnaHRlZCBub2RlcyBzaW5jZVxuICAgIC8vIHN0YXRpYyBkZXBlbmRlbnRzIGRvbid0IGFmZmVjdCB3ZWlnaHQuIFRoaXMgc2hvdWxkIG1ha2Ugc3VyZSBubyBpbnRlcm5hbFxuICAgIC8vIG5vZGVzIHNjaGVkdWxlIHVubmVjZXNzYXJ5IHJlZXZhYWx1YXRpb25zIHRvIHJlY3JlYXRlIGZvcmNlLWRlc3Ryb3llZFxuICAgIC8vIGluc3RhbmNlc1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5faW5zdGFuY2VzKS5mb3JFYWNoKGluc3RhbmNlID0+IHtcbiAgICAgIGluc3RhbmNlLmRlc3Ryb3kodHJ1ZSlcbiAgICB9KVxuXG4gICAgdGhpcy5oeWRyYXRpb24gPSB1bmRlZmluZWRcbiAgICB0aGlzLnNlbGVjdG9yQ2FjaGUuX3dpcGUoKVxuXG4gICAgdGhpcy5fc2NoZWR1bGVyLndpcGUoKVxuICAgIHRoaXMuX3NjaGVkdWxlci5mbHVzaCgpXG5cbiAgICBpZiAodGhpcy5fbW9kcy5lY29zeXN0ZW1XaXBlZCkge1xuICAgICAgdGhpcy5tb2RCdXMuZGlzcGF0Y2gocGx1Z2luQWN0aW9ucy5lY29zeXN0ZW1XaXBlZCh7IGVjb3N5c3RlbTogdGhpcyB9KSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2hvdWxkIG9ubHkgYmUgdXNlZCBpbnRlcm5hbGx5XG4gICAqL1xuICBwdWJsaWMgX2NvbnN1bWVIeWRyYXRpb24oaW5zdGFuY2U6IFBhcnRpYWxBdG9tSW5zdGFuY2UpIHtcbiAgICBjb25zdCBoeWRyYXRlZFZhbHVlID0gdGhpcy5oeWRyYXRpb24/LltpbnN0YW5jZS5rZXlIYXNoXVxuXG4gICAgaWYgKHR5cGVvZiBoeWRyYXRlZFZhbHVlID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG5cbiAgICBkZWxldGUgdGhpcy5oeWRyYXRpb24/LltpbnN0YW5jZS5rZXlIYXNoXVxuXG4gICAgcmV0dXJuIGluc3RhbmNlLmF0b20uaHlkcmF0ZVxuICAgICAgPyBpbnN0YW5jZS5hdG9tLmh5ZHJhdGUoaHlkcmF0ZWRWYWx1ZSlcbiAgICAgIDogaHlkcmF0ZWRWYWx1ZVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3VsZCBvbmx5IGJlIHVzZWQgaW50ZXJuYWxseVxuICAgKi9cbiAgcHVibGljIF9kZWNyZW1lbnRSZWZDb3VudCgpIHtcbiAgICB0aGlzLl9yZWZDb3VudC0tXG4gICAgaWYgKCF0aGlzLl9kZXN0cm95T25Vbm1vdW50KSByZXR1cm5cblxuICAgIHRoaXMuZGVzdHJveSgpIC8vIG9ubHkgZGVzdHJveXMgaWYgX3JlZkNvdW50ID09PSAwXG4gIH1cblxuICAvKipcbiAgICogU2hvdWxkIG9ubHkgYmUgdXNlZCBpbnRlcm5hbGx5XG4gICAqL1xuICBwdWJsaWMgX2Rlc3Ryb3lBdG9tSW5zdGFuY2Uoa2V5SGFzaDogc3RyaW5nKSB7XG4gICAgLy8gdHJ5IHRvIGRlc3Ryb3kgaW5zdGFuY2UgKGlmIG5vdCBkZXN0cm95ZWQgLSB0aGlzIGZuIGlzIGNhbGxlZCBhcyBwYXJ0IG9mXG4gICAgLy8gdGhhdCBkZXN0cnVjdGlvbiBwcm9jZXNzIHRvbylcbiAgICB0aGlzLl9ncmFwaC5yZW1vdmVOb2RlKGtleUhhc2gpXG5cbiAgICBkZWxldGUgdGhpcy5faW5zdGFuY2VzW2tleUhhc2hdIC8vIFRPRE86IGRpc3BhdGNoIGFuIGFjdGlvbiBvdmVyIGludGVybmFsU3RvcmUgZm9yIHRoaXMgbXV0YXRpb25cbiAgfVxuXG4gIC8qKlxuICAgKiBTaG91bGQgb25seSBiZSB1c2VkIGludGVybmFsbHlcbiAgICovXG4gIHB1YmxpYyBfZ2V0UmVhY3RDb250ZXh0KGF0b206IEFueUF0b20pIHtcbiAgICBjb25zdCBleGlzdGluZ0NvbnRleHQgPSB0aGlzLl9yZWFjdENvbnRleHRzW2F0b20ua2V5XVxuXG4gICAgaWYgKGV4aXN0aW5nQ29udGV4dCkgcmV0dXJuIGV4aXN0aW5nQ29udGV4dFxuXG4gICAgY29uc3QgbmV3Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKVxuICAgIHRoaXMuX3JlYWN0Q29udGV4dHNbYXRvbS5rZXldID0gbmV3Q29udGV4dFxuXG4gICAgcmV0dXJuIG5ld0NvbnRleHQgYXMgUmVhY3QuQ29udGV4dDxhbnk+XG4gIH1cblxuICAvKipcbiAgICogU2hvdWxkIG9ubHkgYmUgdXNlZCBpbnRlcm5hbGx5XG4gICAqL1xuICBwdWJsaWMgX2luY3JlbWVudFJlZkNvdW50KCkge1xuICAgIHRoaXMuX3JlZkNvdW50KytcbiAgfVxuXG4gIHByaXZhdGUgcmVjYWxjdWxhdGVNb2RzKG5ld1N0YXRlPzogTW9kW10sIG9sZFN0YXRlPzogTW9kW10pIHtcbiAgICBpZiAob2xkU3RhdGUpIHtcbiAgICAgIG9sZFN0YXRlLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgdGhpcy5fbW9kc1trZXkgYXMgTW9kXS0tIC8vIGZ1biBmYWN0LCB1bmRlZmluZWQtLSBpcyBmaW5lXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChuZXdTdGF0ZSkge1xuICAgICAgbmV3U3RhdGUuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICB0aGlzLl9tb2RzW2tleSBhcyBNb2RdKytcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSByZXNvbHZlQXRvbTxBdG9tVHlwZSBleHRlbmRzIEFueUF0b20+KGF0b206IEF0b21UeXBlKSB7XG4gICAgY29uc3Qgb3ZlcnJpZGUgPSB0aGlzLm92ZXJyaWRlcz8uW2F0b20ua2V5XVxuICAgIGNvbnN0IG1heWJlT3ZlcnJpZGRlbkF0b20gPSAob3ZlcnJpZGUgfHwgYXRvbSkgYXMgQXRvbVR5cGVcblxuICAgIC8vIHRvIHR1cm4gb2ZmIGZsYWcgY2hlY2tpbmcsIGp1c3QgZG9uJ3QgcGFzcyBhIGBmbGFnc2AgcHJvcFxuICAgIGlmICh0aGlzLmZsYWdzKSB7XG4gICAgICBjb25zdCBiYWRGbGFnID0gbWF5YmVPdmVycmlkZGVuQXRvbS5mbGFncz8uZmluZChcbiAgICAgICAgZmxhZyA9PiAhdGhpcy5mbGFncz8uaW5jbHVkZXMoZmxhZylcbiAgICAgIClcblxuICAgICAgaWYgKERFViAmJiBiYWRGbGFnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgYFplZHV4OiBlbmNvdW50ZXJlZCB1bnNhZmUgYXRvbSBcIiR7YXRvbS5rZXl9XCIgd2l0aCBmbGFnIFwiJHtiYWRGbGFnfVwiLiBUaGlzIGF0b20gc2hvdWxkIGJlIG92ZXJyaWRkZW4gaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuYFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlT3ZlcnJpZGRlbkF0b21cbiAgfVxufVxuIl0sIm5hbWVzIjpbIkV4cGxpY2l0IiwiRXh0ZXJuYWwiLCJTdGF0aWMiLCJwbHVnaW5BY3Rpb25zIiwiR3JhcGgiLCJlY29zeXN0ZW0iLCJub2RlcyIsInVwZGF0ZVN0YWNrIiwiYWRkRWRnZSIsImRlcGVuZGVudEtleSIsImRlcGVuZGVuY3lLZXkiLCJvcGVyYXRpb24iLCJmbGFncyIsImNhbGxiYWNrIiwibmV3RWRnZSIsImNyZWF0ZWRBdCIsIkRhdGUiLCJub3ciLCJsZW5ndGgiLCJmaW5pc2hBZGRpbmdFZGdlIiwiZGVwZW5kZW5jaWVzIiwia2V5IiwiREVWIiwiRXJyb3IiLCJkZXBlbmRlbmN5IiwiYWRkTm9kZSIsIm5vZGVLZXkiLCJpc0F0b21TZWxlY3RvciIsImRlcGVuZGVudHMiLCJ3ZWlnaHQiLCJidWZmZXJVcGRhdGVzIiwicHVzaCIsImRlc3Ryb3lCdWZmZXIiLCJlZGdlcyIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiZXhpc3RpbmdFZGdlIiwic2NoZWR1bGVOb2RlRGVzdHJ1Y3Rpb24iLCJwb3AiLCJmbHVzaFVwZGF0ZXMiLCJlZGdlVG9BZGQiLCJyZW1vdmVFZGdlIiwiZ2V0UmVmQ291bnQiLCJyZW1vdmVEZXBlbmRlbmNpZXMiLCJub2RlIiwiZGVwZW5kZW50IiwiZGVwZW5kZW50RWRnZSIsInJlY2FsY3VsYXRlTm9kZVdlaWdodCIsInRhc2siLCJfc2NoZWR1bGVyIiwidW5zY2hlZHVsZSIsIl9tb2RzIiwiZWRnZVJlbW92ZWQiLCJtb2RCdXMiLCJkaXNwYXRjaCIsIl9pbnN0YW5jZXMiLCJzZWxlY3RvckNhY2hlIiwiX2l0ZW1zIiwiZWRnZSIsInJlbW92ZU5vZGUiLCJzY2hlZHVsZURlcGVuZGVudHMiLCJ1bmRlZmluZWQiLCJkZXBlbmRlbnROb2RlIiwicmVhc29ucyIsIm5ld1N0YXRlIiwib2xkU3RhdGUiLCJzaG91bGRTZXRUaW1lb3V0IiwidHlwZSIsInNpZ25hbCIsInNjaGVkdWxlU3RhdGljRGVwcyIsImluc3RhbmNlIiwiY2FjaGUiLCJpc1N0YXRpYyIsInJlYXNvbiIsInNvdXJjZUtleSIsInNvdXJjZVR5cGUiLCJfc2NoZWR1bGVFdmFsdWF0aW9uIiwic3RvcmUiLCJnZXRTdGF0ZSIsInJlc3VsdCIsInNjaGVkdWxlIiwidW5zY2hlZHVsZU5vZGVEZXN0cnVjdGlvbiIsImVkZ2VDcmVhdGVkIiwid2VpZ2h0RGlmZiIsIl9kZXN0cm95U2VsZWN0b3IiLCJfc2NoZWR1bGVEZXN0cnVjdGlvbiIsIl9jYW5jZWxEZXN0cnVjdGlvbiIsImlzIiwiaXNQbGFpbk9iamVjdCIsIkF0b21JbnN0YW5jZUJhc2UiLCJJZEdlbmVyYXRvciIsImlkQ291bnRlciIsIndlYWtDYWNoZSIsIldlYWtNYXAiLCJnZW5lcmF0ZUlkIiwicHJlZml4IiwiTWF0aCIsInJhbmRvbSIsInRvU3RyaW5nIiwic2xpY2UiLCJnZW5lcmF0ZUF0b21TZWxlY3RvcklkIiwibmFtZSIsImdlbmVyYXRlRWNvc3lzdGVtSWQiLCJnZW5lcmF0ZU5vZGVJZCIsImdlbmVyYXRlUmVhY3RDb21wb25lbnRJZCIsInN0YWNrIiwibGluZXMiLCJzcGxpdCIsIm1hcCIsImxpbmUiLCJ0cmltIiwicmVwbGFjZSIsImNvbXBvbmVudE5hbWUiLCJmaW5kIiwidGVzdCIsImlkZW50aWZpZXJzIiwiZm4iLCJ0b1VwcGVyQ2FzZSIsImhhc2hQYXJhbXMiLCJwYXJhbXMiLCJhY2NlcHRDb21wbGV4UGFyYW1zIiwiSlNPTiIsInN0cmluZ2lmeSIsIl8iLCJwYXJhbSIsImtleUhhc2giLCJBcnJheSIsImlzQXJyYXkiLCJjYWNoZUZuIiwiY29uc3RydWN0b3IiLCJjYWNoZUNsYXNzIiwic29ydCIsInJlZHVjZSIsImlkIiwiZ2V0Iiwic2V0IiwiU2NoZWR1bGVyIiwiam9icyIsImZsdXNoIiwiX2lzUnVubmluZyIsIl9qb2JUaW1lb3V0SWQiLCJjbGVhclRpbWVvdXQiLCJydW5Kb2JzIiwibmV3Sm9iIiwiX2dyYXBoIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJqb2IiLCJqb2JXZWlnaHQiLCJzcGxpY2UiLCJzZXRUaW1lb3V0Iiwic2NoZWR1bGVOb3ciLCJydW5JZlJ1bm5pbmciLCJ1bnNoaWZ0Iiwid2lwZSIsImZpbHRlciIsImNiIiwiaXRlcmF0aW9uIiwiY2VpbCIsImRpcmVjdGlvbiIsImRpdmlzb3IiLCJpc0RvbmUiLCJlZmZlY3R1YWxTaXplIiwicm91bmQiLCJuZXdJbmRleCIsIm1pbiIsIm1heCIsInNoaWZ0IiwiZGVmYXVsdFJlc3VsdHNDb21wYXJhdG9yIiwiYSIsImIiLCJTZWxlY3RvckNhY2hlSXRlbSIsImNhY2hlS2V5Iiwic2VsZWN0b3JSZWYiLCJhcmdzIiwibmV4dEV2YWx1YXRpb25SZWFzb25zIiwiJCR0eXBlb2YiLCJTeW1ib2wiLCJmb3IiLCJTZWxlY3RvckNhY2hlIiwiX3JlZkJhc2VLZXlzIiwiYWRkRGVwZW5kZW50IiwiY2FjaGVJdGVtIiwiX2lkR2VuZXJhdG9yIiwiZGVzdHJveUNhY2hlIiwic2VsZWN0YWJsZSIsImZvcmNlIiwiZ2V0Q2FjaGVLZXkiLCJnZXRDYWNoZSIsInNlbGVjdG9yT3JDb25maWciLCJydW5TZWxlY3RvciIsIndlYWsiLCJiYXNlS2V5IiwiZ2V0QmFzZUtleSIsImNvbXBsZXhQYXJhbXMiLCJpbnNwZWN0SXRlbXMiLCJzZWxlY3RhYmxlT3JOYW1lIiwiaGFzaCIsImZpbHRlcktleSIsIl9nZXRJZGVhbENhY2hlS2V5IiwidmFsdWVzIiwibG9jYWxlQ29tcGFyZSIsImluY2x1ZGVzIiwiaW5zcGVjdEl0ZW1WYWx1ZXMiLCJ3ZWFrR2V0Q2FjaGUiLCJpc0Rlc3Ryb3llZCIsImRlbGV0ZSIsImlkZWFsS2V5Iiwic2VsZWN0b3IiLCJfc3dhcFJlZnMiLCJvbGRSZWYiLCJuZXdSZWYiLCJleGlzdGluZ0NhY2hlIiwiX3dpcGUiLCJleGlzdGluZ0lkIiwicHJlZml4ZWRLZXkiLCJrZXlFeGlzdHMiLCJpc0luaXRpYWxpemluZyIsIl9ldmFsdWF0aW9uU3RhY2siLCJzdGFydCIsInJlc3VsdHNDb21wYXJhdG9yIiwiYXRvbUdldHRlcnMiLCJzdGF0ZUNoYW5nZWQiLCJlcnIiLCJjb25zb2xlIiwiZXJyb3IiLCJmaW5pc2giLCJwcmV2RXZhbHVhdGlvblJlYXNvbnMiLCJjcmVhdGVTdG9yZSIsImNyZWF0ZUNvbnRleHQiLCJpbnRlcm5hbFN0b3JlIiwiRXZhbHVhdGlvblN0YWNrIiwiZGVmYXVsdE1vZHMiLCJtb2QiLCJtYXBPdmVycmlkZXMiLCJvdmVycmlkZXMiLCJhdG9tIiwiRWNvc3lzdGVtIiwiY29udGV4dCIsImRlZmF1bHRUdGwiLCJkZXN0cm95T25Vbm1vdW50Iiwib25SZWFkeSIsInNzciIsIl9kZXN0cm95T25Vbm1vdW50IiwiX3JlYWN0Q29udGV4dHMiLCJfcmVmQ291bnQiLCJpc0luaXRpYWxpemVkIiwicGx1Z2lucyIsIlR5cGVFcnJvciIsInNldE92ZXJyaWRlcyIsIl9vblJlYWR5IiwiY2xlYW51cCIsImFkZE92ZXJyaWRlcyIsIm92ZXJyaWRlIiwiaW5zdGFuY2VzIiwiaW5zcGVjdEluc3RhbmNlcyIsImRlc3Ryb3kiLCJkZWh5ZHJhdGUiLCJleGNsdWRlIiwiZXhjbHVkZUZsYWdzIiwiaW5jbHVkZSIsImluY2x1ZGVGbGFncyIsInRyYW5zZm9ybSIsInNvbWUiLCJhdG9tT3JLZXkiLCJ0b0xvd2VyQ2FzZSIsImZsYWciLCJmcm9tRW50cmllcyIsInN0YXRlIiwic2V0U3RhdGUiLCJnZXRJbnN0YW5jZSIsImdldEtleUhhc2giLCJleGlzdGluZ0luc3RhbmNlIiwicmVzb2x2ZWRBdG9tIiwicmVzb2x2ZUF0b20iLCJuZXdJbnN0YW5jZSIsIl9jcmVhdGVJbnN0YW5jZSIsIl9pbml0IiwiaHlkcmF0ZSIsImRlaHlkcmF0ZWRTdGF0ZSIsImNvbmZpZyIsImh5ZHJhdGlvbiIsInJldHJvYWN0aXZlIiwiZW50cmllcyIsInZhbCIsImlzQXRvbSIsInJlZ2lzdGVyUGx1Z2luIiwicGx1Z2luIiwiZGVzY3JpcHRvciIsInN1YnNjcmlwdGlvbiIsIm1vZFN0b3JlIiwic3Vic2NyaWJlIiwicmVjYWxjdWxhdGVNb2RzIiwiY2xlYW51cFJlZ2lzdHJhdGlvbiIsInJlZ2lzdGVyRWNvc3lzdGVtIiwidW5zdWJzY3JpYmUiLCJyZW1vdmVPdmVycmlkZXMiLCJldmVyeSIsInJlc2V0IiwibmV3Q29udGV4dCIsInByZXZDb250ZXh0Iiwic2VsZWN0IiwiYXRvbVNlbGVjdG9yIiwicmVzb2x2ZWRTZWxlY3RvciIsImJpbmQiLCJuZXdPdmVycmlkZXMiLCJvbGRPdmVycmlkZXMiLCJ1bnJlZ2lzdGVyUGx1Z2luIiwidmlld0dyYXBoIiwidmlldyIsImlzVG9wTGV2ZWwiLCJyZWN1cnNlIiwiY2hpbGRyZW4iLCJjaGlsZCIsIndlYWtHZXQiLCJ3ZWFrR2V0SW5zdGFuY2UiLCJ3aHkiLCJpdGVtIiwicmVhZCIsIl9uZXh0RXZhbHVhdGlvblJlYXNvbnMiLCJlY29zeXN0ZW1XaXBlZCIsIl9jb25zdW1lSHlkcmF0aW9uIiwiaHlkcmF0ZWRWYWx1ZSIsIl9kZWNyZW1lbnRSZWZDb3VudCIsIl9kZXN0cm95QXRvbUluc3RhbmNlIiwiX2dldFJlYWN0Q29udGV4dCIsImV4aXN0aW5nQ29udGV4dCIsIl9pbmNyZW1lbnRSZWZDb3VudCIsIm1heWJlT3ZlcnJpZGRlbkF0b20iLCJiYWRGbGFnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5092\n")},2633:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"O\": function() { return /* binding */ EvaluationStack; },\n/* harmony export */   \"i\": function() { return /* binding */ readInstance; }\n/* harmony export */ });\n/* harmony import */ var _zedux_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1694);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(395);\n/* harmony import */ var _utils_plugin_actions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3299);\nvar perf=typeof performance!=='undefined'?performance:{now:function now(){return Date.now();}};/**\n * A stack of AtomInstances and AtomSelectors that are currently evaluating -\n * innermost instance/selector (the one that's actually currently evaluating) at\n * the end of the array.\n *\n * This has to live in the module scope so `readInstance` can access it without\n * any ecosystem context. That's how injectors work.\n */var stack=[];var readInstance=function readInstance(){var item=stack[stack.length-1];if( true&&!(item!=null&&item.instance)){throw new Error('Zedux: Injectors can only be used in atom state factories');}return item.instance;};var EvaluationStack=/*#__PURE__*/function(){function EvaluationStack(ecosystem){var _this=this;this.ecosystem=ecosystem;var get=function get(atomOrInstance,params){var instance=ecosystem.getInstance(atomOrInstance,params);// when called outside AtomSelector evaluation, get() is just an alias for\n// ecosystem.get()\nif(!stack.length)return instance.store.getState();// if get is called during evaluation, track the required atom instances so\n// we can add graph edges for them\necosystem._graph.addEdge(stack[stack.length-1].key,instance.keyHash,'get',0);return instance.store.getState();};var getInstance=function getInstance(atomOrInstance,params,edgeInfo){var _edgeInfo$;var instance=ecosystem.getInstance(atomOrInstance,params);// when called outside AtomSelector evaluation, getInstance() is just an alias\n// for ecosystem.getInstance()\nif(!stack.length)return instance;// if getInstance is called during evaluation, track the required atom\n// instances so we can add graph edges for them\necosystem._graph.addEdge(stack[stack.length-1].key,instance.keyHash,(edgeInfo==null?void 0:edgeInfo[1])||'getInstance',(_edgeInfo$=edgeInfo==null?void 0:edgeInfo[0])!=null?_edgeInfo$:_utils__WEBPACK_IMPORTED_MODULE_0__/* .Static */ .qG);return instance;};var select=function select(selectable){for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}// when called outside AtomSelector evaluation, select() is just an alias for ecosystem.select()\nif(!stack.length){return ecosystem.select.apply(ecosystem,[selectable].concat(args));}var cache=_this.ecosystem.selectorCache.getCache(selectable,args);ecosystem._graph.addEdge(stack[stack.length-1].key,cache.cacheKey,'select',0);return cache.result;};this.atomGetters={ecosystem:ecosystem,get:get,getInstance:getInstance,select:select};}var _proto=EvaluationStack.prototype;_proto.isEvaluating=function isEvaluating(key){return stack.some(function(item){return item.key===key;});};_proto.finish=function finish(){var item=stack.pop();if(!item||!this.ecosystem._mods.evaluationFinished)return;var time=item.start?perf.now()-item.start:0;var action={time:time};if(item.instance){;action.instance=item.instance;}else if(item.cache){;action.cache=item.cache;}this.ecosystem.modBus.dispatch(_utils_plugin_actions__WEBPACK_IMPORTED_MODULE_1__/* .pluginActions.evaluationFinished */ .V.evaluationFinished(action));_zedux_core__WEBPACK_IMPORTED_MODULE_2__/* .Store._scheduler */ .y._scheduler=undefined;};_proto.read=function read(){return stack[stack.length-1];};_proto.start=function start(item){var newItem={};if(item.keyHash){newItem.key=item.keyHash;newItem.instance=item;}else{newItem.key=item.cacheKey;newItem.cache=item;}if(this.ecosystem._mods.evaluationFinished){newItem.start=perf.now();}stack.push(newItem);// all stores created during evaluation automatically belong to the ecosystem\n_zedux_core__WEBPACK_IMPORTED_MODULE_2__/* .Store._scheduler */ .y._scheduler=this.ecosystem._scheduler;};return EvaluationStack;}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFRLENBQzVCNUMsK0dBQWdDLENBQUMwQyxNQUFNLENBQVEsQ0FDaEQsQ0FFRDVDLDZFQUFnQixDQUFHZ0QsU0FBUyxDQUM5QixDQUFDLFFBRU1DLElBQUksQ0FBWCxlQUFjLENBQ1osTUFBTzFDLE1BQUssQ0FBQ0EsS0FBSyxDQUFDRyxNQUFNLENBQUcsQ0FBQyxDQUFDLENBQ2hDLENBQUMsUUFFTWlDLEtBQUssQ0FBWixlQUFhbEMsSUFBbUQsQ0FBRSxDQUNoRSxHQUFNeUMsUUFBTyxDQUFHLENBQUMsQ0FBYyxDQUUvQixHQUFLekMsSUFBSSxDQUFxQmdCLE9BQU8sQ0FBRSxDQUNyQ3lCLE9BQU8sQ0FBQzFCLEdBQUcsQ0FBSWYsSUFBSSxDQUFxQmdCLE9BQU8sQ0FDN0N5QixPQUFPLENBQXVCdEMsUUFBUSxDQUFHSCxJQUF1QixDQUNwRSxDQUFDLElBQU0sQ0FDTHlDLE9BQU8sQ0FBQzFCLEdBQUcsQ0FBSWYsSUFBSSxDQUF1QndCLFFBQVEsQ0FDaERpQixPQUFPLENBQXVCcEIsS0FBSyxDQUFHckIsSUFBeUIsQ0FDbkUsQ0FFQSxHQUFJLElBQUksQ0FBQ00sU0FBUyxDQUFDeUIsS0FBSyxDQUFDQyxrQkFBa0IsQ0FBRSxDQUMzQ1MsT0FBTyxDQUFDUCxLQUFLLENBQUd4QyxJQUFJLENBQUNFLEdBQUcsRUFBRSxDQUM1QixDQUVBRSxLQUFLLENBQUM0QyxJQUFJLENBQUNELE9BQU8sQ0FBQyxDQUVuQjtBQUNBbEQsNkVBQWdCLENBQUcsSUFBSSxDQUFDZSxTQUFTLENBQUNnQyxVQUFVLENBQzlDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9jbGFzc2VzL0V2YWx1YXRpb25TdGFjay50cz9lYTM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFjdGlvbkZhY3RvcnlQYXlsb2FkVHlwZSwgU3RvcmUgfSBmcm9tICdAemVkdXgvY29yZSdcbmltcG9ydCB7XG4gIEFueUF0b21JbnN0YW5jZSxcbiAgQXRvbUdldHRlcnMsXG4gIEF0b21QYXJhbXNUeXBlLFxuICBHcmFwaEVkZ2VJbmZvLFxuICBTZWxlY3RhYmxlLFxufSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7XG4gIEluc3RhbmNlU3RhY2tJdGVtLFxuICBTZWxlY3RvclN0YWNrSXRlbSxcbiAgU3RhY2tJdGVtLFxuICBTdGF0aWMsXG59IGZyb20gJy4uL3V0aWxzJ1xuaW1wb3J0IHsgcGx1Z2luQWN0aW9ucyB9IGZyb20gJy4uL3V0aWxzL3BsdWdpbi1hY3Rpb25zJ1xuaW1wb3J0IHsgQXRvbUJhc2UgfSBmcm9tICcuL2F0b21zL0F0b21CYXNlJ1xuaW1wb3J0IHsgRWNvc3lzdGVtIH0gZnJvbSAnLi9FY29zeXN0ZW0nXG5pbXBvcnQgeyBTZWxlY3RvckNhY2hlSXRlbSB9IGZyb20gJy4vU2VsZWN0b3JDYWNoZSdcblxuY29uc3QgcGVyZiA9XG4gIHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgPyBwZXJmb3JtYW5jZSA6IHsgbm93OiAoKSA9PiBEYXRlLm5vdygpIH1cblxuLyoqXG4gKiBBIHN0YWNrIG9mIEF0b21JbnN0YW5jZXMgYW5kIEF0b21TZWxlY3RvcnMgdGhhdCBhcmUgY3VycmVudGx5IGV2YWx1YXRpbmcgLVxuICogaW5uZXJtb3N0IGluc3RhbmNlL3NlbGVjdG9yICh0aGUgb25lIHRoYXQncyBhY3R1YWxseSBjdXJyZW50bHkgZXZhbHVhdGluZykgYXRcbiAqIHRoZSBlbmQgb2YgdGhlIGFycmF5LlxuICpcbiAqIFRoaXMgaGFzIHRvIGxpdmUgaW4gdGhlIG1vZHVsZSBzY29wZSBzbyBgcmVhZEluc3RhbmNlYCBjYW4gYWNjZXNzIGl0IHdpdGhvdXRcbiAqIGFueSBlY29zeXN0ZW0gY29udGV4dC4gVGhhdCdzIGhvdyBpbmplY3RvcnMgd29yay5cbiAqL1xuY29uc3Qgc3RhY2s6IFN0YWNrSXRlbVtdID0gW11cblxuZXhwb3J0IGNvbnN0IHJlYWRJbnN0YW5jZSA9ICgpID0+IHtcbiAgY29uc3QgaXRlbSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXG5cbiAgaWYgKERFViAmJiAhKGl0ZW0gYXMgSW5zdGFuY2VTdGFja0l0ZW0gfCB1bmRlZmluZWQpPy5pbnN0YW5jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignWmVkdXg6IEluamVjdG9ycyBjYW4gb25seSBiZSB1c2VkIGluIGF0b20gc3RhdGUgZmFjdG9yaWVzJylcbiAgfVxuXG4gIHJldHVybiAoaXRlbSBhcyBJbnN0YW5jZVN0YWNrSXRlbSkuaW5zdGFuY2Vcbn1cblxuZXhwb3J0IGNsYXNzIEV2YWx1YXRpb25TdGFjayB7XG4gIHB1YmxpYyBhdG9tR2V0dGVyczogQXRvbUdldHRlcnNcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGVjb3N5c3RlbTogRWNvc3lzdGVtKSB7XG4gICAgY29uc3QgZ2V0OiBBdG9tR2V0dGVyc1snZ2V0J10gPSAoKGF0b21Pckluc3RhbmNlLCBwYXJhbXMpID0+IHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gZWNvc3lzdGVtLmdldEluc3RhbmNlKGF0b21Pckluc3RhbmNlLCBwYXJhbXMpXG5cbiAgICAgIC8vIHdoZW4gY2FsbGVkIG91dHNpZGUgQXRvbVNlbGVjdG9yIGV2YWx1YXRpb24sIGdldCgpIGlzIGp1c3QgYW4gYWxpYXMgZm9yXG4gICAgICAvLyBlY29zeXN0ZW0uZ2V0KClcbiAgICAgIGlmICghc3RhY2subGVuZ3RoKSByZXR1cm4gaW5zdGFuY2Uuc3RvcmUuZ2V0U3RhdGUoKVxuXG4gICAgICAvLyBpZiBnZXQgaXMgY2FsbGVkIGR1cmluZyBldmFsdWF0aW9uLCB0cmFjayB0aGUgcmVxdWlyZWQgYXRvbSBpbnN0YW5jZXMgc29cbiAgICAgIC8vIHdlIGNhbiBhZGQgZ3JhcGggZWRnZXMgZm9yIHRoZW1cbiAgICAgIGVjb3N5c3RlbS5fZ3JhcGguYWRkRWRnZShcbiAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0ua2V5LFxuICAgICAgICBpbnN0YW5jZS5rZXlIYXNoLFxuICAgICAgICAnZ2V0JyxcbiAgICAgICAgMFxuICAgICAgKVxuXG4gICAgICByZXR1cm4gaW5zdGFuY2Uuc3RvcmUuZ2V0U3RhdGUoKVxuICAgIH0pIGFzIEF0b21HZXR0ZXJzWydnZXQnXVxuXG4gICAgY29uc3QgZ2V0SW5zdGFuY2U6IEF0b21HZXR0ZXJzWydnZXRJbnN0YW5jZSddID0gPFxuICAgICAgQSBleHRlbmRzIEF0b21CYXNlPGFueSwgWy4uLmFueV0sIGFueSwgYW55LCBhbnksIGFueT5cbiAgICA+KFxuICAgICAgYXRvbU9ySW5zdGFuY2U6IEEsXG4gICAgICBwYXJhbXM/OiBBdG9tUGFyYW1zVHlwZTxBPixcbiAgICAgIGVkZ2VJbmZvPzogR3JhcGhFZGdlSW5mb1xuICAgICkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBlY29zeXN0ZW0uZ2V0SW5zdGFuY2UoXG4gICAgICAgIGF0b21Pckluc3RhbmNlLFxuICAgICAgICBwYXJhbXMgYXMgQXRvbVBhcmFtc1R5cGU8QT5cbiAgICAgIClcblxuICAgICAgLy8gd2hlbiBjYWxsZWQgb3V0c2lkZSBBdG9tU2VsZWN0b3IgZXZhbHVhdGlvbiwgZ2V0SW5zdGFuY2UoKSBpcyBqdXN0IGFuIGFsaWFzXG4gICAgICAvLyBmb3IgZWNvc3lzdGVtLmdldEluc3RhbmNlKClcbiAgICAgIGlmICghc3RhY2subGVuZ3RoKSByZXR1cm4gaW5zdGFuY2VcblxuICAgICAgLy8gaWYgZ2V0SW5zdGFuY2UgaXMgY2FsbGVkIGR1cmluZyBldmFsdWF0aW9uLCB0cmFjayB0aGUgcmVxdWlyZWQgYXRvbVxuICAgICAgLy8gaW5zdGFuY2VzIHNvIHdlIGNhbiBhZGQgZ3JhcGggZWRnZXMgZm9yIHRoZW1cbiAgICAgIGVjb3N5c3RlbS5fZ3JhcGguYWRkRWRnZShcbiAgICAgICAgc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0ua2V5LFxuICAgICAgICBpbnN0YW5jZS5rZXlIYXNoLFxuICAgICAgICBlZGdlSW5mbz8uWzFdIHx8ICdnZXRJbnN0YW5jZScsXG4gICAgICAgIGVkZ2VJbmZvPy5bMF0gPz8gU3RhdGljXG4gICAgICApXG5cbiAgICAgIHJldHVybiBpbnN0YW5jZVxuICAgIH1cblxuICAgIGNvbnN0IHNlbGVjdDogQXRvbUdldHRlcnNbJ3NlbGVjdCddID0gPFQgPSBhbnksIEFyZ3MgZXh0ZW5kcyBhbnlbXSA9IFtdPihcbiAgICAgIHNlbGVjdGFibGU6IFNlbGVjdGFibGU8VCwgQXJncz4sXG4gICAgICAuLi5hcmdzOiBBcmdzXG4gICAgKSA9PiB7XG4gICAgICAvLyB3aGVuIGNhbGxlZCBvdXRzaWRlIEF0b21TZWxlY3RvciBldmFsdWF0aW9uLCBzZWxlY3QoKSBpcyBqdXN0IGFuIGFsaWFzIGZvciBlY29zeXN0ZW0uc2VsZWN0KClcbiAgICAgIGlmICghc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBlY29zeXN0ZW0uc2VsZWN0KHNlbGVjdGFibGUsIC4uLmFyZ3MpXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhY2hlID0gdGhpcy5lY29zeXN0ZW0uc2VsZWN0b3JDYWNoZS5nZXRDYWNoZShzZWxlY3RhYmxlLCBhcmdzKVxuXG4gICAgICBlY29zeXN0ZW0uX2dyYXBoLmFkZEVkZ2UoXG4gICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLmtleSxcbiAgICAgICAgY2FjaGUuY2FjaGVLZXksXG4gICAgICAgICdzZWxlY3QnLFxuICAgICAgICAwXG4gICAgICApXG5cbiAgICAgIHJldHVybiBjYWNoZS5yZXN1bHQgYXMgVFxuICAgIH1cblxuICAgIHRoaXMuYXRvbUdldHRlcnMgPSB7XG4gICAgICBlY29zeXN0ZW0sXG4gICAgICBnZXQsXG4gICAgICBnZXRJbnN0YW5jZSxcbiAgICAgIHNlbGVjdCxcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgaXNFdmFsdWF0aW5nKGtleTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0YWNrLnNvbWUoaXRlbSA9PiBpdGVtLmtleSA9PT0ga2V5KVxuICB9XG5cbiAgcHVibGljIGZpbmlzaCgpIHtcbiAgICBjb25zdCBpdGVtID0gc3RhY2sucG9wKClcbiAgICBpZiAoIWl0ZW0gfHwgIXRoaXMuZWNvc3lzdGVtLl9tb2RzLmV2YWx1YXRpb25GaW5pc2hlZCkgcmV0dXJuXG5cbiAgICBjb25zdCB0aW1lID0gaXRlbS5zdGFydCA/IHBlcmYubm93KCkgLSBpdGVtLnN0YXJ0IDogMFxuICAgIGNvbnN0IGFjdGlvbiA9IHsgdGltZSB9IGFzIEFjdGlvbkZhY3RvcnlQYXlsb2FkVHlwZTxcbiAgICAgIHR5cGVvZiBwbHVnaW5BY3Rpb25zLmV2YWx1YXRpb25GaW5pc2hlZFxuICAgID5cblxuICAgIGlmICgoaXRlbSBhcyBJbnN0YW5jZVN0YWNrSXRlbSkuaW5zdGFuY2UpIHtcbiAgICAgIDsoYWN0aW9uIGFzIHtcbiAgICAgICAgaW5zdGFuY2U6IEFueUF0b21JbnN0YW5jZVxuICAgICAgfSkuaW5zdGFuY2UgPSAoaXRlbSBhcyBJbnN0YW5jZVN0YWNrSXRlbSkuaW5zdGFuY2VcbiAgICB9IGVsc2UgaWYgKChpdGVtIGFzIFNlbGVjdG9yU3RhY2tJdGVtKS5jYWNoZSkge1xuICAgICAgOyhhY3Rpb24gYXMge1xuICAgICAgICBjYWNoZTogU2VsZWN0b3JDYWNoZUl0ZW1cbiAgICAgIH0pLmNhY2hlID0gKGl0ZW0gYXMgU2VsZWN0b3JTdGFja0l0ZW0pLmNhY2hlXG4gICAgfVxuXG4gICAgdGhpcy5lY29zeXN0ZW0ubW9kQnVzLmRpc3BhdGNoKFxuICAgICAgcGx1Z2luQWN0aW9ucy5ldmFsdWF0aW9uRmluaXNoZWQoYWN0aW9uIGFzIGFueSlcbiAgICApXG5cbiAgICBTdG9yZS5fc2NoZWR1bGVyID0gdW5kZWZpbmVkXG4gIH1cblxuICBwdWJsaWMgcmVhZCgpIHtcbiAgICByZXR1cm4gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1cbiAgfVxuXG4gIHB1YmxpYyBzdGFydChpdGVtOiBBbnlBdG9tSW5zdGFuY2UgfCBTZWxlY3RvckNhY2hlSXRlbTxhbnksIGFueT4pIHtcbiAgICBjb25zdCBuZXdJdGVtID0ge30gYXMgU3RhY2tJdGVtXG5cbiAgICBpZiAoKGl0ZW0gYXMgQW55QXRvbUluc3RhbmNlKS5rZXlIYXNoKSB7XG4gICAgICBuZXdJdGVtLmtleSA9IChpdGVtIGFzIEFueUF0b21JbnN0YW5jZSkua2V5SGFzaFxuICAgICAgOyhuZXdJdGVtIGFzIEluc3RhbmNlU3RhY2tJdGVtKS5pbnN0YW5jZSA9IGl0ZW0gYXMgQW55QXRvbUluc3RhbmNlXG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld0l0ZW0ua2V5ID0gKGl0ZW0gYXMgU2VsZWN0b3JDYWNoZUl0ZW0pLmNhY2hlS2V5XG4gICAgICA7KG5ld0l0ZW0gYXMgU2VsZWN0b3JTdGFja0l0ZW0pLmNhY2hlID0gaXRlbSBhcyBTZWxlY3RvckNhY2hlSXRlbVxuICAgIH1cblxuICAgIGlmICh0aGlzLmVjb3N5c3RlbS5fbW9kcy5ldmFsdWF0aW9uRmluaXNoZWQpIHtcbiAgICAgIG5ld0l0ZW0uc3RhcnQgPSBwZXJmLm5vdygpXG4gICAgfVxuXG4gICAgc3RhY2sucHVzaChuZXdJdGVtKVxuXG4gICAgLy8gYWxsIHN0b3JlcyBjcmVhdGVkIGR1cmluZyBldmFsdWF0aW9uIGF1dG9tYXRpY2FsbHkgYmVsb25nIHRvIHRoZSBlY29zeXN0ZW1cbiAgICBTdG9yZS5fc2NoZWR1bGVyID0gdGhpcy5lY29zeXN0ZW0uX3NjaGVkdWxlclxuICB9XG59XG4iXSwibmFtZXMiOlsiU3RvcmUiLCJTdGF0aWMiLCJwbHVnaW5BY3Rpb25zIiwicGVyZiIsInBlcmZvcm1hbmNlIiwibm93IiwiRGF0ZSIsInN0YWNrIiwicmVhZEluc3RhbmNlIiwiaXRlbSIsImxlbmd0aCIsIkRFViIsImluc3RhbmNlIiwiRXJyb3IiLCJFdmFsdWF0aW9uU3RhY2siLCJlY29zeXN0ZW0iLCJnZXQiLCJhdG9tT3JJbnN0YW5jZSIsInBhcmFtcyIsImdldEluc3RhbmNlIiwic3RvcmUiLCJnZXRTdGF0ZSIsIl9ncmFwaCIsImFkZEVkZ2UiLCJrZXkiLCJrZXlIYXNoIiwiZWRnZUluZm8iLCJzZWxlY3QiLCJzZWxlY3RhYmxlIiwiYXJncyIsImNhY2hlIiwic2VsZWN0b3JDYWNoZSIsImdldENhY2hlIiwiY2FjaGVLZXkiLCJyZXN1bHQiLCJhdG9tR2V0dGVycyIsImlzRXZhbHVhdGluZyIsInNvbWUiLCJmaW5pc2giLCJwb3AiLCJfbW9kcyIsImV2YWx1YXRpb25GaW5pc2hlZCIsInRpbWUiLCJzdGFydCIsImFjdGlvbiIsIm1vZEJ1cyIsImRpc3BhdGNoIiwiX3NjaGVkdWxlciIsInVuZGVmaW5lZCIsInJlYWQiLCJuZXdJdGVtIiwicHVzaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2633\n")},1968:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "h": function() { return /* binding */ Atom; }\n/* harmony export */ });\n/* harmony import */ var _Users_joshuaclaunch_code_oss_zedux_docs_node_modules_babel_runtime_helpers_esm_inheritsLoose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4578);\n/* harmony import */ var _zedux_react_factories_atom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5965);\n/* harmony import */ var _instances_AtomInstance__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4985);\n/* harmony import */ var _AtomBase__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3789);\nvar Atom=/*#__PURE__*/function(_AtomBase){(0,_Users_joshuaclaunch_code_oss_zedux_docs_node_modules_babel_runtime_helpers_esm_inheritsLoose_js__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .Z)(Atom,_AtomBase);function Atom(){return _AtomBase.apply(this,arguments)||this;}var _proto=Atom.prototype;/**\n   * This method should be overridden when creating custom atom classes that\n   * create a custom atom instance class. Return a new instance of your atom\n   * instance class.\n   */_proto._createInstance=function _createInstance(ecosystem,keyHash,params){return new _instances_AtomInstance__WEBPACK_IMPORTED_MODULE_1__/* .AtomInstance */ .p(ecosystem,this,keyHash,params);};_proto.getKeyHash=function getKeyHash(ecosystem,params){var base=this.key;if(!(params!=null&&params.length))return base;return base+"-"+ecosystem._idGenerator.hashParams(params,ecosystem.complexParams);};_proto.override=function override(newValue){return (0,_zedux_react_factories_atom__WEBPACK_IMPORTED_MODULE_2__/* .atom */ .c)(this.key,newValue,this._config);};return Atom;}(_AtomBase__WEBPACK_IMPORTED_MODULE_3__/* .AtomBase */ .H);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk2OC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBT08sR0FBTUcsS0FBSSxnU0FjZjtBQUNGO0FBQ0E7QUFDQTtBQUNBLEtBSkUsT0FLT0MsZUFBZSxDQUF0Qix5QkFDRUMsU0FBb0IsQ0FDcEJDLE9BQWUsQ0FDZkMsTUFBYyxDQUNnRCxDQUM5RCxNQUFPLElBQUlOLENBQUFBLDBFQUFZLENBQ3JCSSxTQUFTLENBQ1QsSUFBSSxDQUNKQyxPQUFPLENBQ1BDLE1BQU0sQ0FDUCxDQUNILENBQUMsUUFFTUMsVUFBVSxDQUFqQixvQkFBa0JILFNBQW9CLENBQUVFLE1BQWUsQ0FBRSxDQUN2RCxHQUFNRSxLQUFJLENBQUcsSUFBSSxDQUFDQyxHQUFHLENBRXJCLEdBQUksRUFBQ0gsTUFBTSxRQUFOQSxNQUFNLENBQUVJLE1BQU0sRUFBRSxNQUFPRixLQUFJLENBRWhDLE1BQVVBLEtBQUksS0FBSUosU0FBUyxDQUFDTyxZQUFZLENBQUNDLFVBQVUsQ0FDakROLE1BQU0sQ0FDTkYsU0FBUyxDQUFDUyxhQUFhLENBQ3hCLENBQ0gsQ0FBQyxRQUVNQyxRQUFRLENBQWYsa0JBQ0VDLFFBQTRFLENBQzVFLENBQ0EsTUFBT2hCLENBQUFBLDBFQUFJLENBQUMsSUFBSSxDQUFDVSxHQUFHLENBQUVNLFFBQVEsQ0FBRSxJQUFJLENBQUNDLE9BQU8sQ0FBQyxDQUMvQyxDQUFDLGVBekNPZix3REFBUSIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL2NsYXNzZXMvYXRvbXMvQXRvbS50cz9hYzI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFN0b3JlIH0gZnJvbSAnQHplZHV4L2NvcmUnXG5pbXBvcnQgeyBhdG9tIH0gZnJvbSAnQHplZHV4L3JlYWN0L2ZhY3Rvcmllcy9hdG9tJ1xuaW1wb3J0IHsgQXRvbUFwaVByb21pc2UsIEF0b21WYWx1ZU9yRmFjdG9yeSB9IGZyb20gJ0B6ZWR1eC9yZWFjdC90eXBlcydcbmltcG9ydCB7IEF0b21JbnN0YW5jZSB9IGZyb20gJy4uL2luc3RhbmNlcy9BdG9tSW5zdGFuY2UnXG5pbXBvcnQgeyBFY29zeXN0ZW0gfSBmcm9tICcuLi9FY29zeXN0ZW0nXG5pbXBvcnQgeyBBdG9tQmFzZSB9IGZyb20gJy4vQXRvbUJhc2UnXG5cbmV4cG9ydCBjbGFzcyBBdG9tPFxuICBTdGF0ZSxcbiAgUGFyYW1zIGV4dGVuZHMgYW55W10sXG4gIEV4cG9ydHMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBTdG9yZVR5cGUgZXh0ZW5kcyBTdG9yZTxTdGF0ZT4sXG4gIFByb21pc2VUeXBlIGV4dGVuZHMgQXRvbUFwaVByb21pc2Vcbj4gZXh0ZW5kcyBBdG9tQmFzZTxcbiAgU3RhdGUsXG4gIFBhcmFtcyxcbiAgRXhwb3J0cyxcbiAgU3RvcmVUeXBlLFxuICBQcm9taXNlVHlwZSxcbiAgQXRvbUluc3RhbmNlPFN0YXRlLCBQYXJhbXMsIEV4cG9ydHMsIFN0b3JlVHlwZSwgUHJvbWlzZVR5cGU+XG4+IHtcbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuIHdoZW4gY3JlYXRpbmcgY3VzdG9tIGF0b20gY2xhc3NlcyB0aGF0XG4gICAqIGNyZWF0ZSBhIGN1c3RvbSBhdG9tIGluc3RhbmNlIGNsYXNzLiBSZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgeW91ciBhdG9tXG4gICAqIGluc3RhbmNlIGNsYXNzLlxuICAgKi9cbiAgcHVibGljIF9jcmVhdGVJbnN0YW5jZShcbiAgICBlY29zeXN0ZW06IEVjb3N5c3RlbSxcbiAgICBrZXlIYXNoOiBzdHJpbmcsXG4gICAgcGFyYW1zOiBQYXJhbXNcbiAgKTogQXRvbUluc3RhbmNlPFN0YXRlLCBQYXJhbXMsIEV4cG9ydHMsIFN0b3JlVHlwZSwgUHJvbWlzZVR5cGU+IHtcbiAgICByZXR1cm4gbmV3IEF0b21JbnN0YW5jZTxTdGF0ZSwgUGFyYW1zLCBFeHBvcnRzLCBTdG9yZVR5cGUsIFByb21pc2VUeXBlPihcbiAgICAgIGVjb3N5c3RlbSxcbiAgICAgIHRoaXMsXG4gICAgICBrZXlIYXNoLFxuICAgICAgcGFyYW1zXG4gICAgKVxuICB9XG5cbiAgcHVibGljIGdldEtleUhhc2goZWNvc3lzdGVtOiBFY29zeXN0ZW0sIHBhcmFtcz86IFBhcmFtcykge1xuICAgIGNvbnN0IGJhc2UgPSB0aGlzLmtleVxuXG4gICAgaWYgKCFwYXJhbXM/Lmxlbmd0aCkgcmV0dXJuIGJhc2VcblxuICAgIHJldHVybiBgJHtiYXNlfS0ke2Vjb3N5c3RlbS5faWRHZW5lcmF0b3IuaGFzaFBhcmFtcyhcbiAgICAgIHBhcmFtcyxcbiAgICAgIGVjb3N5c3RlbS5jb21wbGV4UGFyYW1zXG4gICAgKX1gXG4gIH1cblxuICBwdWJsaWMgb3ZlcnJpZGUoXG4gICAgbmV3VmFsdWU6IEF0b21WYWx1ZU9yRmFjdG9yeTxTdGF0ZSwgUGFyYW1zLCBFeHBvcnRzLCBTdG9yZVR5cGUsIFByb21pc2VUeXBlPlxuICApIHtcbiAgICByZXR1cm4gYXRvbSh0aGlzLmtleSwgbmV3VmFsdWUsIHRoaXMuX2NvbmZpZylcbiAgfVxufVxuIl0sIm5hbWVzIjpbImF0b20iLCJBdG9tSW5zdGFuY2UiLCJBdG9tQmFzZSIsIkF0b20iLCJfY3JlYXRlSW5zdGFuY2UiLCJlY29zeXN0ZW0iLCJrZXlIYXNoIiwicGFyYW1zIiwiZ2V0S2V5SGFzaCIsImJhc2UiLCJrZXkiLCJsZW5ndGgiLCJfaWRHZW5lcmF0b3IiLCJoYXNoUGFyYW1zIiwiY29tcGxleFBhcmFtcyIsIm92ZXJyaWRlIiwibmV3VmFsdWUiLCJfY29uZmlnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1968\n')},3789:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "H": function() { return /* binding */ AtomBase; }\n/* harmony export */ });\nvar AtomBase=function AtomBase(key,_value,_config){this.key=key;this._value=_value;this._config=_config;this.dehydrate=_config==null?void 0:_config.dehydrate;this.flags=_config==null?void 0:_config.flags;this.hydrate=_config==null?void 0:_config.hydrate;this.manualHydration=_config==null?void 0:_config.manualHydration;this.ttl=_config==null?void 0:_config.ttl;// const map = new WeakMap();\n// map.set(newAtomInstance, true);\n// map.set({ control: true }, true);\n// console.log({ key: atom.key, map });\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzc4OS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFRTyxHQUFlQSxTQUFRLENBb0I1QixrQkFDa0JDLEdBQVcsQ0FDWEMsTUFNZixDQUNrQkMsT0FBMkIsQ0FDOUMsTUFUZ0JGLEdBQVcsQ0FBWEEsR0FBVyxNQUNYQyxNQU1mLENBTmVBLE1BTWYsTUFDa0JDLE9BQTJCLENBQTNCQSxPQUEyQixDQUU5QyxJQUFJLENBQUNDLFNBQVMsQ0FBR0QsT0FBTyxjQUFQQSxPQUFPLENBQUVDLFNBQVMsQ0FDbkMsSUFBSSxDQUFDQyxLQUFLLENBQUdGLE9BQU8sY0FBUEEsT0FBTyxDQUFFRSxLQUFLLENBQzNCLElBQUksQ0FBQ0MsT0FBTyxDQUFHSCxPQUFPLGNBQVBBLE9BQU8sQ0FBRUcsT0FBTyxDQUMvQixJQUFJLENBQUNDLGVBQWUsQ0FBR0osT0FBTyxjQUFQQSxPQUFPLENBQUVJLGVBQWUsQ0FDL0MsSUFBSSxDQUFDQyxHQUFHLENBQUdMLE9BQU8sY0FBUEEsT0FBTyxDQUFFSyxHQUFHLENBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0YsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL2NsYXNzZXMvYXRvbXMvQXRvbUJhc2UudHM/NTYyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdG9yZSB9IGZyb20gJ0B6ZWR1eC9jb3JlJ1xuaW1wb3J0IHtcbiAgQXRvbUNvbmZpZyxcbiAgQXRvbUFwaVByb21pc2UsXG4gIEF0b21WYWx1ZU9yRmFjdG9yeSxcbn0gZnJvbSAnQHplZHV4L3JlYWN0L3R5cGVzJ1xuaW1wb3J0IHsgRWNvc3lzdGVtIH0gZnJvbSAnLi4vRWNvc3lzdGVtJ1xuaW1wb3J0IHsgQXRvbUluc3RhbmNlIH0gZnJvbSAnLi4vaW5zdGFuY2VzL0F0b21JbnN0YW5jZSdcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBdG9tQmFzZTxcbiAgU3RhdGUsXG4gIFBhcmFtcyBleHRlbmRzIGFueVtdLFxuICBFeHBvcnRzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PixcbiAgU3RvcmVUeXBlIGV4dGVuZHMgU3RvcmU8U3RhdGU+LFxuICBQcm9taXNlVHlwZSBleHRlbmRzIEF0b21BcGlQcm9taXNlLFxuICBJbnN0YW5jZVR5cGUgZXh0ZW5kcyBBdG9tSW5zdGFuY2U8XG4gICAgU3RhdGUsXG4gICAgUGFyYW1zLFxuICAgIEV4cG9ydHMsXG4gICAgU3RvcmVUeXBlLFxuICAgIFByb21pc2VUeXBlXG4gID5cbj4ge1xuICBwdWJsaWMgcmVhZG9ubHkgZGVoeWRyYXRlPzogQXRvbUNvbmZpZzxTdGF0ZT5bJ2RlaHlkcmF0ZSddXG4gIHB1YmxpYyByZWFkb25seSBmbGFncz86IHN0cmluZ1tdXG4gIHB1YmxpYyByZWFkb25seSBoeWRyYXRlPzogQXRvbUNvbmZpZzxTdGF0ZT5bJ2h5ZHJhdGUnXVxuICBwdWJsaWMgcmVhZG9ubHkgbWFudWFsSHlkcmF0aW9uPzogYm9vbGVhblxuICBwdWJsaWMgcmVhZG9ubHkgdHRsPzogbnVtYmVyXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIHJlYWRvbmx5IGtleTogc3RyaW5nLFxuICAgIHB1YmxpYyByZWFkb25seSBfdmFsdWU6IEF0b21WYWx1ZU9yRmFjdG9yeTxcbiAgICAgIFN0YXRlLFxuICAgICAgUGFyYW1zLFxuICAgICAgRXhwb3J0cyxcbiAgICAgIFN0b3JlVHlwZSxcbiAgICAgIFByb21pc2VUeXBlXG4gICAgPixcbiAgICBwcm90ZWN0ZWQgcmVhZG9ubHkgX2NvbmZpZz86IEF0b21Db25maWc8U3RhdGU+XG4gICkge1xuICAgIHRoaXMuZGVoeWRyYXRlID0gX2NvbmZpZz8uZGVoeWRyYXRlXG4gICAgdGhpcy5mbGFncyA9IF9jb25maWc/LmZsYWdzXG4gICAgdGhpcy5oeWRyYXRlID0gX2NvbmZpZz8uaHlkcmF0ZVxuICAgIHRoaXMubWFudWFsSHlkcmF0aW9uID0gX2NvbmZpZz8ubWFudWFsSHlkcmF0aW9uXG4gICAgdGhpcy50dGwgPSBfY29uZmlnPy50dGxcblxuICAgIC8vIGNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgLy8gbWFwLnNldChuZXdBdG9tSW5zdGFuY2UsIHRydWUpO1xuICAgIC8vIG1hcC5zZXQoeyBjb250cm9sOiB0cnVlIH0sIHRydWUpO1xuICAgIC8vIGNvbnNvbGUubG9nKHsga2V5OiBhdG9tLmtleSwgbWFwIH0pO1xuICB9XG5cbiAgcHVibGljIGFic3RyYWN0IF9jcmVhdGVJbnN0YW5jZShcbiAgICBlY29zeXN0ZW06IEVjb3N5c3RlbSxcbiAgICBrZXlIYXNoOiBzdHJpbmcsXG4gICAgcGFyYW1zOiBQYXJhbXNcbiAgKTogSW5zdGFuY2VUeXBlXG5cbiAgcHVibGljIGFic3RyYWN0IGdldEtleUhhc2goZWNvc3lzdGVtOiBFY29zeXN0ZW0sIHBhcmFtcz86IFBhcmFtcyk6IHN0cmluZ1xufVxuIl0sIm5hbWVzIjpbIkF0b21CYXNlIiwia2V5IiwiX3ZhbHVlIiwiX2NvbmZpZyIsImRlaHlkcmF0ZSIsImZsYWdzIiwiaHlkcmF0ZSIsIm1hbnVhbEh5ZHJhdGlvbiIsInR0bCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3789\n')},4985:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  \"p\": function() { return /* binding */ AtomInstance; }\n});\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js\nvar esm_typeof = __webpack_require__(1002);\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\n\nfunction _toPrimitive(input, hint) {\n  if ((0,esm_typeof/* default */.Z)(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if ((0,esm_typeof/* default */.Z)(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\n\n\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return (0,esm_typeof/* default */.Z)(key) === \"symbol\" ? key : String(key);\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js\nvar inheritsLoose = __webpack_require__(4578);\n// EXTERNAL MODULE: ../packages/core/src/api/is.ts\nvar is = __webpack_require__(9283);\n// EXTERNAL MODULE: ../packages/core/src/api/createStore.ts + 4 modules\nvar createStore = __webpack_require__(1694);\n// EXTERNAL MODULE: ../packages/react/src/utils/promiseUtils.ts\nvar promiseUtils = __webpack_require__(1881);\n// EXTERNAL MODULE: ../packages/react/src/classes/AtomApi.ts\nvar AtomApi = __webpack_require__(2448);\n// EXTERNAL MODULE: ../packages/react/src/classes/instances/AtomInstanceBase.ts\nvar AtomInstanceBase = __webpack_require__(4987);\n// EXTERNAL MODULE: ../packages/react/src/utils/plugin-actions.ts\nvar plugin_actions = __webpack_require__(3299);\n;// CONCATENATED MODULE: ../packages/react/src/classes/instances/AtomInstance.ts\nvar StateType;(function(StateType){StateType[StateType[\"Store\"]=0]=\"Store\";StateType[StateType[\"Value\"]=1]=\"Value\";})(StateType||(StateType={}));var getStateType=function getStateType(val){if((0,is.is)(val,createStore/* Store */.y))return StateType.Store;return StateType.Value;};var getStateStore=function getStateStore(factoryResult){var stateType=getStateType(factoryResult);var stateStore=stateType===StateType.Store?factoryResult:(0,createStore/* createStore */.M)();// define how we populate our store (doesn't apply to user-supplied stores)\nif(stateType===StateType.Value){stateStore.setState(typeof factoryResult==='function'?function(){return factoryResult;}:factoryResult);}return[stateType,stateStore];};var AtomInstance=/*#__PURE__*/function(_AtomInstanceBase){(0,inheritsLoose/* default */.Z)(AtomInstance,_AtomInstanceBase);function AtomInstance(ecosystem,atom,keyHash,params){var _this;_this=_AtomInstanceBase.call(this)||this;// lol\n_this.activeState='Initializing';_this._createdAt=Date.now();_this._nextEvaluationReasons=[];_this.dispatch=function(action){return _this.store.dispatch(action);};_this.invalidate=function(operation,sourceType){return _this._invalidate(operation,sourceType);};_this.setState=function(settable,meta){return _this.store.setState(settable,meta);};_this.setStateDeep=function(settable,meta){return _this.store.setStateDeep(settable,meta);};_this._scheduleEvaluation=function(reason,shouldSetTimeout){// TODO: Any calls in this case probably indicate a memory leak on the\n// user's part. Notify them. TODO: Can we pause evaluations while\n// activeState is Stale (and should we just always evaluate once when\n// waking up a stale atom)?\nif(_this.activeState==='Destroyed')return;_this._nextEvaluationReasons.push(reason);if(_this._nextEvaluationReasons.length>1)return;// job already scheduled\n_this.ecosystem._scheduler.schedule({keyHash:_this.keyHash,task:_this.evaluationTask,type:2// EvaluateGraphNode (2)\n},shouldSetTimeout);};_this.evaluationTask=function(){return _this._evaluationTask();};_this.ecosystem=ecosystem;_this.atom=atom;_this.keyHash=keyHash;_this.params=params;_this.exports=_assertThisInitialized(_this).exports;_this.promise=_assertThisInitialized(_this).promise;_this.store=_assertThisInitialized(_this).store;_this._promiseStatus=_assertThisInitialized(_this)._promiseStatus;return _this;}/**\n   * Detach this atom instance from the ecosystem and clean up all graph edges\n   * and other subscriptions/effects created by this atom instance.\n   *\n   * Destruction will bail out if this atom instance still has dependents. Pass\n   * `true` to force-destroy the atom instance anyway.\n   */var _proto=AtomInstance.prototype;_proto.destroy=function destroy(force){var _this$ecosystem$_grap,_this$_cancelDestruct,_this$_injectors,_this$_subscription;if(this.activeState==='Destroyed')return;// If we're not force-destroying, don't destroy if there are dependents\nif(!force&&Object.keys(((_this$ecosystem$_grap=this.ecosystem._graph.nodes[this.keyHash])==null?void 0:_this$ecosystem$_grap.dependents)||{}).length){return;}(_this$_cancelDestruct=this._cancelDestruction)==null?void 0:_this$_cancelDestruct.call(this);this._cancelDestruction=undefined;this._setActiveState('Destroyed');if(this._nextEvaluationReasons.length){this.ecosystem._scheduler.unschedule(this.evaluationTask);}// Clean up effect injectors first, then everything else\nvar nonEffectInjectors=[];(_this$_injectors=this._injectors)==null?void 0:_this$_injectors.forEach(function(injector){if(injector.type!=='@@zedux/effect'){nonEffectInjectors.push(injector);return;}injector.cleanup==null?void 0:injector.cleanup();});nonEffectInjectors.forEach(function(injector){injector.cleanup==null?void 0:injector.cleanup();});this.ecosystem._graph.removeDependencies(this.keyHash);(_this$_subscription=this._subscription)==null?void 0:_this$_subscription.unsubscribe();this.ecosystem._destroyAtomInstance(this.keyHash);}/**\n   * An alias for `.store.dispatch()`\n   */;/**\n   * An alias for `instance.store.getState()`. Returns the current state of this\n   * atom instance's store.\n   */_proto.getState=function getState(){return this.store.getState();}// a small, memory-efficient bound function property we can pass around\n;_proto._init=function _init(){var _this2=this;var factoryResult=this._doEvaluate();var _getStateStore=getStateStore(factoryResult);this._stateType=_getStateStore[0];this.store=_getStateStore[1];this._subscription=this.store.subscribe(function(newState,oldState,action){// buffer updates (with cache size of 1) if this instance is currently\n// evaluating\nif(_this2.ecosystem._evaluationStack.isEvaluating(_this2.keyHash)){_this2._bufferedUpdate={newState:newState,oldState:oldState,action:action};return;}_this2._handleStateChange(newState,oldState,action);});this._setActiveState('Active');// hydrate if possible\nif(!this.ecosystem.hydration||this.atom.manualHydration)return;var hydration=this.ecosystem._consumeHydration(this);if(typeof hydration==='undefined')return;this.store.setState(hydration);}/**\n   * When a standard atom instance's refCount hits 0 and a ttl is set, we set a\n   * timeout to destroy this atom instance.\n   */;_proto._scheduleDestruction=function _scheduleDestruction(){var _this3=this;// the atom is already scheduled for destruction or destroyed\nif(this.activeState!=='Active')return;this._setActiveState('Stale');var ttl=this._getTtl();if(ttl==null||ttl===-1)return;if(ttl===0)return this.destroy();if(typeof ttl==='number'){// ttl is > 0; schedule destruction\nvar timeoutId=setTimeout(function(){_this3._cancelDestruction=undefined;_this3.destroy();},ttl);// TODO: dispatch an action over stateStore for these mutations\nthis._cancelDestruction=function(){_this3._cancelDestruction=undefined;clearTimeout(timeoutId);};return;}if(typeof ttl.then==='function'){var isCanceled=false;ttl.then(function(){_this3._cancelDestruction=undefined;if(!isCanceled)_this3.destroy();});this._cancelDestruction=function(){_this3._cancelDestruction=undefined;isCanceled=true;};return;}// ttl is an observable; destroy as soon as it emits\nvar subscription=ttl.subscribe(function(){_this3._cancelDestruction=undefined;_this3.destroy();});this._cancelDestruction=function(){_this3._cancelDestruction=undefined;subscription.unsubscribe();};};_proto._doEvaluate=function _doEvaluate(){this._nextInjectors=[];var newFactoryResult;this.ecosystem._evaluationStack.start(this);this.ecosystem._graph.bufferUpdates(this.keyHash);try{newFactoryResult=this._evaluate();}catch(err){this._nextInjectors.forEach(function(injector){injector.cleanup==null?void 0:injector.cleanup();});this._nextInjectors=undefined;this.ecosystem._graph.destroyBuffer();throw err;}finally{this.ecosystem._evaluationStack.finish();// even if evaluation errored, we need to update dependents if the store's\n// state changed\nif(this._bufferedUpdate){this._handleStateChange(this._bufferedUpdate.newState,this._bufferedUpdate.oldState,this._bufferedUpdate.action);this._bufferedUpdate=undefined;}this._prevEvaluationReasons=this._nextEvaluationReasons;this._nextEvaluationReasons=[];}this._injectors=this._nextInjectors;this._nextInjectors=undefined;this.ecosystem._graph.flushUpdates();return newFactoryResult;}/**\n   * A standard atom's value can be one of:\n   *\n   * - A raw value\n   * - A Zedux store\n   * - A function that returns a raw value\n   * - A function that returns a Zedux store\n   * - A function that returns an AtomApi\n   */;_proto._evaluate=function _evaluate(){var _value=this.atom._value;if(typeof _value!=='function'){return _value;}try{var _this$api$value;var val=_value.apply(void 0,this.params);if(!(0,is.is)(val,AtomApi/* AtomApi */.u))return val;this.api=val;// Exports can only be set on initial evaluation\nif(this.activeState==='Initializing'){this.exports=this.api.exports;}// if api.value is a promise, we ignore api.promise\nif(typeof((_this$api$value=this.api.value)==null?void 0:_this$api$value.then)==='function'){return this._setPromise(this.api.value,true);}else if(this.api.promise){this._setPromise(this.api.promise);}return this.api.value;}catch(err){console.error(\"Zedux: Error while evaluating atom \\\"\"+this.atom.key+\"\\\" with params:\",this.params,err);throw err;}};_proto._evaluationTask=function _evaluationTask(){var newFactoryResult=this._doEvaluate();var newStateType=getStateType(newFactoryResult);if( true&&newStateType!==this._stateType){throw new Error(\"Zedux: atom factory for atom \\\"\"+this.atom.key+\"\\\" returned a different type than the previous evaluation. This can happen if the atom returned a store initially but then returned a non-store value on a later evaluation or vice versa\");}if( true&&newStateType===StateType.Store&&newFactoryResult!==this.store){throw new Error(\"Zedux: atom factory for atom \\\"\"+this.atom.key+\"\\\" returned a different store. Did you mean to use `injectStore()`, or `injectMemo()`?\");}// there is no way to cause an evaluation loop when the StateType is Value\nif(newStateType===StateType.Value){this.store.setState(typeof newFactoryResult==='function'?function(){return newFactoryResult;}:newFactoryResult);}};_proto._getTtl=function _getTtl(){var _this$api;if(((_this$api=this.api)==null?void 0:_this$api.ttl)==null){var _this$atom$ttl;return(_this$atom$ttl=this.atom.ttl)!=null?_this$atom$ttl:this.ecosystem.defaultTtl;}// this atom instance set its own ttl\nvar ttl=this.api.ttl;return typeof ttl==='function'?ttl():ttl;};_proto._handleStateChange=function _handleStateChange(newState,oldState,action){this.ecosystem._graph.scheduleDependents(this.keyHash,this._nextEvaluationReasons,newState,oldState,false);if(this.ecosystem._mods.stateChanged){this.ecosystem.modBus.dispatch(plugin_actions/* pluginActions.stateChanged */.V.stateChanged({action:action,instance:this,newState:newState,oldState:oldState,reasons:this._nextEvaluationReasons}));}// run the scheduler synchronously after any atom instance state update\nthis.ecosystem._scheduler.flush();};_proto._invalidate=function _invalidate(operation,sourceType){if(operation===void 0){operation='invalidate';}if(sourceType===void 0){sourceType='External';}this._scheduleEvaluation({operation:operation,sourceType:sourceType,type:'cache invalidated'},false);// run the scheduler synchronously after invalidation\nthis.ecosystem._scheduler.flush();};_proto._setActiveState=function _setActiveState(newActiveState){var oldActiveState=this.activeState;this.activeState=newActiveState;if(this.ecosystem._mods.activeStateChanged){this.ecosystem.modBus.dispatch(plugin_actions/* pluginActions.activeStateChanged */.V.activeStateChanged({instance:this,newActiveState:newActiveState,oldActiveState:oldActiveState}));}};_proto._setPromise=function _setPromise(promise,isStateUpdater){var _this4=this;if(promise===this.promise)return this.store.getState();this.promise=promise;// since we're the first to chain off the returned promise, we don't need to\n// track the chained promise - it will run first, before React suspense's\n// `.then` on the thrown promise, for example\npromise.then(function(data){if(_this4.promise!==promise)return;_this4._promiseStatus='success';if(!isStateUpdater)return;_this4.store.setState((0,promiseUtils/* getSuccessPromiseState */.W2)(data));}).catch(function(error){if(_this4.promise!==promise)return;_this4._promiseStatus='error';_this4._promiseError=error;if(!isStateUpdater)return;_this4.store.setState((0,promiseUtils/* getErrorPromiseState */.bG)(error));});var state=(0,promiseUtils/* getInitialPromiseState */.KF)();this._promiseStatus=state.status;this.ecosystem._graph.scheduleDependents(this.keyHash,this._nextEvaluationReasons,undefined,undefined,true,'promise changed','Updated',true);return state;};_createClass(AtomInstance,[{key:\"_infusedSetter\",get:function get(){var _this5=this;if(this._set)return this._set;var setState=function setState(settable,meta){return _this5.setState(settable,meta);};return this._set=Object.assign(setState,this.exports);}}]);return AtomInstance;}(AtomInstanceBase/* AtomInstanceBase */.T);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LEdBQUksTUFBSSxDQUFDNUQsT0FBTyxHQUFLQSxPQUFPLENBQUUsT0FFOUIsTUFBSSxDQUFDQyxjQUFjLENBQUcsT0FBTyxDQUM3QixNQUFJLENBQUM4RSxhQUFhLENBQUduQixLQUFLLENBQzFCLEdBQUksQ0FBQ2dCLGNBQWMsQ0FBRSxPQUVyQixNQUFJLENBQUNoRyxLQUFLLENBQUNiLFFBQVEsQ0FBRWQsNkNBQW9CLENBQUMyRyxLQUFLLENBQUMsQ0FBc0IsQ0FDeEUsQ0FBQyxDQUFDLENBRUosR0FBTW9CLE1BQXdCLENBQUc5SCwrQ0FBc0IsRUFBRSxDQUN6RCxJQUFJLENBQUMrQyxjQUFjLENBQUcrRSxLQUFLLENBQUNDLE1BQU0sQ0FFbEMsSUFBSSxDQUFDaEgsU0FBUyxDQUFDcUMsTUFBTSxDQUFDNEQsa0JBQWtCLENBQ3RDLElBQUksQ0FBQy9GLE9BQU8sQ0FDWixJQUFJLENBQUNNLHNCQUFzQixDQUMzQmlDLFNBQVMsQ0FDVEEsU0FBUyxDQUNULElBQUksQ0FDSixpQkFBaUIsQ0FDakIsU0FBUyxDQUNULElBQUksQ0FDTCxDQUVELE1BQVFzRSxNQUFLLENBQ2YsQ0FBQyxzREEzV0QsY0FBNEIsaUJBQzFCLEdBQUksSUFBSSxDQUFDRSxJQUFJLENBQUUsTUFBTyxLQUFJLENBQUNBLElBQUksQ0FDL0IsR0FBTW5ILFNBQWEsQ0FBRyxRQUFoQkEsU0FBYSxDQUFJa0IsUUFBYSxDQUFFQyxJQUFVLFFBQzlDLE9BQUksQ0FBQ25CLFFBQVEsQ0FBQ2tCLFFBQVEsQ0FBRUMsSUFBSSxDQUFDLEdBRS9CLE1BQVEsS0FBSSxDQUFDZ0csSUFBSSxDQUFHOUUsTUFBTSxDQUFDK0UsTUFBTSxDQUFDcEgsUUFBUSxDQUFFLElBQUksQ0FBQ2dDLE9BQU8sQ0FBQyxDQUMzRCxDQUFDLDBCQTdJTzFDLHdDQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9QcmltaXRpdmUuanM/N2FkMyIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvUHJvcGVydHlLZXkuanM/YTA2MCIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzP2VjYjkiLCJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/MmVlMSIsIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9jbGFzc2VzL2luc3RhbmNlcy9BdG9tSW5zdGFuY2UudHM/NmMzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX3R5cGVvZiBmcm9tIFwiLi90eXBlb2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAoX3R5cGVvZihpbnB1dCkgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcbiAgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKF90eXBlb2YocmVzKSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChoaW50ID09PSBcInN0cmluZ1wiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XG59IiwiaW1wb3J0IF90eXBlb2YgZnJvbSBcIi4vdHlwZW9mLmpzXCI7XG5pbXBvcnQgdG9QcmltaXRpdmUgZnJvbSBcIi4vdG9QcmltaXRpdmUuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIF90eXBlb2Yoa2V5KSA9PT0gXCJzeW1ib2xcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xufSIsImltcG9ydCB0b1Byb3BlcnR5S2V5IGZyb20gXCIuL3RvUHJvcGVydHlLZXkuanNcIjtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHRvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn0iLCJpbXBvcnQge1xuICBBY3Rpb25DaGFpbixcbiAgY3JlYXRlU3RvcmUsXG4gIERpc3BhdGNoYWJsZSxcbiAgaXMsXG4gIE9ic2VydmFibGUsXG4gIFJlY3Vyc2l2ZVBhcnRpYWwsXG4gIFNldHRhYmxlLFxuICBTdG9yZSxcbiAgU3Vic2NyaXB0aW9uLFxufSBmcm9tICdAemVkdXgvY29yZSdcbmltcG9ydCB7XG4gIEFjdGl2ZVN0YXRlLFxuICBBdG9tQXBpUHJvbWlzZSxcbiAgQ2xlYW51cCxcbiAgRXZhbHVhdGlvblJlYXNvbixcbiAgRXZhbHVhdGlvblNvdXJjZVR5cGUsXG4gIEV4cG9ydHNJbmZ1c2VkU2V0dGVyLFxuICBQcm9taXNlU3RhdGUsXG4gIFByb21pc2VTdGF0dXMsXG59IGZyb20gJ0B6ZWR1eC9yZWFjdC90eXBlcydcbmltcG9ydCB7IEluamVjdG9yRGVzY3JpcHRvciB9IGZyb20gJ0B6ZWR1eC9yZWFjdC91dGlscydcbmltcG9ydCB7XG4gIGdldEVycm9yUHJvbWlzZVN0YXRlLFxuICBnZXRJbml0aWFsUHJvbWlzZVN0YXRlLFxuICBnZXRTdWNjZXNzUHJvbWlzZVN0YXRlLFxufSBmcm9tICdAemVkdXgvcmVhY3QvdXRpbHMvcHJvbWlzZVV0aWxzJ1xuaW1wb3J0IHsgRWNvc3lzdGVtIH0gZnJvbSAnLi4vRWNvc3lzdGVtJ1xuaW1wb3J0IHsgQXRvbUFwaSB9IGZyb20gJy4uL0F0b21BcGknXG5pbXBvcnQgeyBBdG9tSW5zdGFuY2VCYXNlIH0gZnJvbSAnLi9BdG9tSW5zdGFuY2VCYXNlJ1xuaW1wb3J0IHsgcGx1Z2luQWN0aW9ucyB9IGZyb20gJ0B6ZWR1eC9yZWFjdC91dGlscy9wbHVnaW4tYWN0aW9ucydcbmltcG9ydCB7IEF0b21CYXNlIH0gZnJvbSAnLi4vYXRvbXMvQXRvbUJhc2UnXG5cbmVudW0gU3RhdGVUeXBlIHtcbiAgU3RvcmUsXG4gIFZhbHVlLFxufVxuXG5jb25zdCBnZXRTdGF0ZVR5cGUgPSAodmFsOiBhbnkpID0+IHtcbiAgaWYgKGlzKHZhbCwgU3RvcmUpKSByZXR1cm4gU3RhdGVUeXBlLlN0b3JlXG5cbiAgcmV0dXJuIFN0YXRlVHlwZS5WYWx1ZVxufVxuXG5jb25zdCBnZXRTdGF0ZVN0b3JlID0gPFxuICBTdGF0ZSA9IGFueSxcbiAgU3RvcmVUeXBlIGV4dGVuZHMgU3RvcmU8U3RhdGU+ID0gU3RvcmU8U3RhdGU+LFxuICBQIGV4dGVuZHMgU3RhdGUgfCBTdG9yZVR5cGUgPSBTdGF0ZSB8IFN0b3JlVHlwZVxuPihcbiAgZmFjdG9yeVJlc3VsdDogUFxuKSA9PiB7XG4gIGNvbnN0IHN0YXRlVHlwZSA9IGdldFN0YXRlVHlwZShmYWN0b3J5UmVzdWx0KVxuXG4gIGNvbnN0IHN0YXRlU3RvcmUgPVxuICAgIHN0YXRlVHlwZSA9PT0gU3RhdGVUeXBlLlN0b3JlXG4gICAgICA/IChmYWN0b3J5UmVzdWx0IGFzIFN0b3JlVHlwZSlcbiAgICAgIDogKGNyZWF0ZVN0b3JlPFN0YXRlPigpIGFzIFN0b3JlVHlwZSlcblxuICAvLyBkZWZpbmUgaG93IHdlIHBvcHVsYXRlIG91ciBzdG9yZSAoZG9lc24ndCBhcHBseSB0byB1c2VyLXN1cHBsaWVkIHN0b3JlcylcbiAgaWYgKHN0YXRlVHlwZSA9PT0gU3RhdGVUeXBlLlZhbHVlKSB7XG4gICAgc3RhdGVTdG9yZS5zZXRTdGF0ZShcbiAgICAgIHR5cGVvZiBmYWN0b3J5UmVzdWx0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gKCkgPT4gZmFjdG9yeVJlc3VsdCBhcyBTdGF0ZVxuICAgICAgICA6IChmYWN0b3J5UmVzdWx0IGFzIFN0YXRlKVxuICAgIClcbiAgfVxuXG4gIHJldHVybiBbc3RhdGVUeXBlLCBzdGF0ZVN0b3JlXSBhcyBjb25zdFxufVxuXG5leHBvcnQgY2xhc3MgQXRvbUluc3RhbmNlPFxuICBTdGF0ZSxcbiAgUGFyYW1zIGV4dGVuZHMgYW55W10sXG4gIEV4cG9ydHMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICBTdG9yZVR5cGUgZXh0ZW5kcyBTdG9yZTxTdGF0ZT4sXG4gIFByb21pc2VUeXBlIGV4dGVuZHMgQXRvbUFwaVByb21pc2Vcbj4gZXh0ZW5kcyBBdG9tSW5zdGFuY2VCYXNlPFxuICBTdGF0ZSxcbiAgUGFyYW1zLFxuICBBdG9tQmFzZTxcbiAgICBTdGF0ZSxcbiAgICBQYXJhbXMsXG4gICAgRXhwb3J0cyxcbiAgICBTdG9yZVR5cGUsXG4gICAgUHJvbWlzZVR5cGUsXG4gICAgQXRvbUluc3RhbmNlPFN0YXRlLCBQYXJhbXMsIEV4cG9ydHMsIFN0b3JlVHlwZSwgUHJvbWlzZVR5cGU+XG4gID5cbj4ge1xuICBwdWJsaWMgYWN0aXZlU3RhdGU6IEFjdGl2ZVN0YXRlID0gJ0luaXRpYWxpemluZydcbiAgcHVibGljIGFwaT86IEF0b21BcGk8U3RhdGUsIEV4cG9ydHMsIFN0b3JlVHlwZSwgUHJvbWlzZVR5cGU+XG4gIHB1YmxpYyBleHBvcnRzOiBFeHBvcnRzXG4gIHB1YmxpYyBwcm9taXNlOiBQcm9taXNlVHlwZVxuICBwdWJsaWMgc3RvcmU6IFN0b3JlVHlwZVxuXG4gIHB1YmxpYyBfY2FuY2VsRGVzdHJ1Y3Rpb24/OiBDbGVhbnVwXG4gIHB1YmxpYyBfY3JlYXRlZEF0ID0gRGF0ZS5ub3coKVxuICBwdWJsaWMgX2luamVjdG9ycz86IEluamVjdG9yRGVzY3JpcHRvcltdXG4gIHB1YmxpYyBfbmV4dEV2YWx1YXRpb25SZWFzb25zOiBFdmFsdWF0aW9uUmVhc29uW10gPSBbXVxuICBwdWJsaWMgX25leHRJbmplY3RvcnM/OiBJbmplY3RvckRlc2NyaXB0b3JbXVxuICBwdWJsaWMgX3ByZXZFdmFsdWF0aW9uUmVhc29ucz86IEV2YWx1YXRpb25SZWFzb25bXVxuICBwdWJsaWMgX3Byb21pc2VFcnJvcj86IEVycm9yXG4gIHB1YmxpYyBfcHJvbWlzZVN0YXR1cz86IFByb21pc2VTdGF0dXNcbiAgcHVibGljIF9zdGF0ZVR5cGU/OiBTdGF0ZVR5cGVcblxuICBwcml2YXRlIF9idWZmZXJlZFVwZGF0ZT86IHtcbiAgICBuZXdTdGF0ZTogU3RhdGVcbiAgICBvbGRTdGF0ZT86IFN0YXRlXG4gICAgYWN0aW9uOiBBY3Rpb25DaGFpblxuICB9XG4gIHByaXZhdGUgX3N1YnNjcmlwdGlvbj86IFN1YnNjcmlwdGlvblxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSBlY29zeXN0ZW06IEVjb3N5c3RlbSxcbiAgICBwdWJsaWMgcmVhZG9ubHkgYXRvbTogQXRvbUJhc2U8XG4gICAgICBTdGF0ZSxcbiAgICAgIFBhcmFtcyxcbiAgICAgIEV4cG9ydHMsXG4gICAgICBTdG9yZVR5cGUsXG4gICAgICBQcm9taXNlVHlwZSxcbiAgICAgIEF0b21JbnN0YW5jZTxTdGF0ZSwgUGFyYW1zLCBFeHBvcnRzLCBTdG9yZVR5cGUsIFByb21pc2VUeXBlPlxuICAgID4sXG4gICAgcHVibGljIHJlYWRvbmx5IGtleUhhc2g6IHN0cmluZyxcbiAgICBwdWJsaWMgcmVhZG9ubHkgcGFyYW1zOiBQYXJhbXNcbiAgKSB7XG4gICAgc3VwZXIoKVxuXG4gICAgLy8gbG9sXG4gICAgdGhpcy5leHBvcnRzID0gKHRoaXMgYXMgYW55KS5leHBvcnRzXG4gICAgdGhpcy5wcm9taXNlID0gKHRoaXMgYXMgYW55KS5wcm9taXNlXG4gICAgdGhpcy5zdG9yZSA9ICh0aGlzIGFzIGFueSkuc3RvcmVcbiAgICB0aGlzLl9wcm9taXNlU3RhdHVzID0gKHRoaXMgYXMgYW55KS5fcHJvbWlzZVN0YXR1c1xuICB9XG5cbiAgLyoqXG4gICAqIERldGFjaCB0aGlzIGF0b20gaW5zdGFuY2UgZnJvbSB0aGUgZWNvc3lzdGVtIGFuZCBjbGVhbiB1cCBhbGwgZ3JhcGggZWRnZXNcbiAgICogYW5kIG90aGVyIHN1YnNjcmlwdGlvbnMvZWZmZWN0cyBjcmVhdGVkIGJ5IHRoaXMgYXRvbSBpbnN0YW5jZS5cbiAgICpcbiAgICogRGVzdHJ1Y3Rpb24gd2lsbCBiYWlsIG91dCBpZiB0aGlzIGF0b20gaW5zdGFuY2Ugc3RpbGwgaGFzIGRlcGVuZGVudHMuIFBhc3NcbiAgICogYHRydWVgIHRvIGZvcmNlLWRlc3Ryb3kgdGhlIGF0b20gaW5zdGFuY2UgYW55d2F5LlxuICAgKi9cbiAgcHVibGljIGRlc3Ryb3koZm9yY2U/OiBib29sZWFuKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlU3RhdGUgPT09ICdEZXN0cm95ZWQnKSByZXR1cm5cblxuICAgIC8vIElmIHdlJ3JlIG5vdCBmb3JjZS1kZXN0cm95aW5nLCBkb24ndCBkZXN0cm95IGlmIHRoZXJlIGFyZSBkZXBlbmRlbnRzXG4gICAgaWYgKFxuICAgICAgIWZvcmNlICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLmVjb3N5c3RlbS5fZ3JhcGgubm9kZXNbdGhpcy5rZXlIYXNoXT8uZGVwZW5kZW50cyB8fCB7fSlcbiAgICAgICAgLmxlbmd0aFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fY2FuY2VsRGVzdHJ1Y3Rpb24/LigpXG4gICAgdGhpcy5fY2FuY2VsRGVzdHJ1Y3Rpb24gPSB1bmRlZmluZWRcblxuICAgIHRoaXMuX3NldEFjdGl2ZVN0YXRlKCdEZXN0cm95ZWQnKVxuXG4gICAgaWYgKHRoaXMuX25leHRFdmFsdWF0aW9uUmVhc29ucy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZWNvc3lzdGVtLl9zY2hlZHVsZXIudW5zY2hlZHVsZSh0aGlzLmV2YWx1YXRpb25UYXNrKVxuICAgIH1cblxuICAgIC8vIENsZWFuIHVwIGVmZmVjdCBpbmplY3RvcnMgZmlyc3QsIHRoZW4gZXZlcnl0aGluZyBlbHNlXG4gICAgY29uc3Qgbm9uRWZmZWN0SW5qZWN0b3JzOiBJbmplY3RvckRlc2NyaXB0b3JbXSA9IFtdXG4gICAgdGhpcy5faW5qZWN0b3JzPy5mb3JFYWNoKGluamVjdG9yID0+IHtcbiAgICAgIGlmIChpbmplY3Rvci50eXBlICE9PSAnQEB6ZWR1eC9lZmZlY3QnKSB7XG4gICAgICAgIG5vbkVmZmVjdEluamVjdG9ycy5wdXNoKGluamVjdG9yKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGluamVjdG9yLmNsZWFudXA/LigpXG4gICAgfSlcbiAgICBub25FZmZlY3RJbmplY3RvcnMuZm9yRWFjaChpbmplY3RvciA9PiB7XG4gICAgICBpbmplY3Rvci5jbGVhbnVwPy4oKVxuICAgIH0pXG5cbiAgICB0aGlzLmVjb3N5c3RlbS5fZ3JhcGgucmVtb3ZlRGVwZW5kZW5jaWVzKHRoaXMua2V5SGFzaClcbiAgICB0aGlzLl9zdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKClcbiAgICB0aGlzLmVjb3N5c3RlbS5fZGVzdHJveUF0b21JbnN0YW5jZSh0aGlzLmtleUhhc2gpXG4gIH1cblxuICAvKipcbiAgICogQW4gYWxpYXMgZm9yIGAuc3RvcmUuZGlzcGF0Y2goKWBcbiAgICovXG4gIHB1YmxpYyBkaXNwYXRjaCA9IChhY3Rpb246IERpc3BhdGNoYWJsZSkgPT4gdGhpcy5zdG9yZS5kaXNwYXRjaChhY3Rpb24pXG5cbiAgLyoqXG4gICAqIEFuIGFsaWFzIGZvciBgaW5zdGFuY2Uuc3RvcmUuZ2V0U3RhdGUoKWAuIFJldHVybnMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpc1xuICAgKiBhdG9tIGluc3RhbmNlJ3Mgc3RvcmUuXG4gICAqL1xuICBwdWJsaWMgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RvcmUuZ2V0U3RhdGUoKVxuICB9XG5cbiAgLy8gYSBzbWFsbCwgbWVtb3J5LWVmZmljaWVudCBib3VuZCBmdW5jdGlvbiBwcm9wZXJ0eSB3ZSBjYW4gcGFzcyBhcm91bmRcbiAgcHVibGljIGludmFsaWRhdGUgPSAob3BlcmF0aW9uPzogc3RyaW5nLCBzb3VyY2VUeXBlPzogRXZhbHVhdGlvblNvdXJjZVR5cGUpID0+XG4gICAgdGhpcy5faW52YWxpZGF0ZShvcGVyYXRpb24sIHNvdXJjZVR5cGUpXG5cbiAgLyoqXG4gICAqIEFuIGFsaWFzIGZvciBgLnN0b3JlLnNldFN0YXRlKClgXG4gICAqL1xuICBwdWJsaWMgc2V0U3RhdGUgPSAoc2V0dGFibGU6IFNldHRhYmxlPFN0YXRlPiwgbWV0YT86IGFueSkgPT5cbiAgICB0aGlzLnN0b3JlLnNldFN0YXRlKHNldHRhYmxlLCBtZXRhKVxuXG4gIC8qKlxuICAgKiBBbiBhbGlhcyBmb3IgYC5zdG9yZS5zZXRTdGF0ZURlZXAoKWBcbiAgICovXG4gIHB1YmxpYyBzZXRTdGF0ZURlZXAgPSAoXG4gICAgc2V0dGFibGU6IFNldHRhYmxlPFJlY3Vyc2l2ZVBhcnRpYWw8U3RhdGU+LCBTdGF0ZT4sXG4gICAgbWV0YT86IGFueVxuICApID0+IHRoaXMuc3RvcmUuc2V0U3RhdGVEZWVwKHNldHRhYmxlLCBtZXRhKVxuXG4gIHB1YmxpYyBfc2V0PzogRXhwb3J0c0luZnVzZWRTZXR0ZXI8U3RhdGUsIEV4cG9ydHM+XG4gIHB1YmxpYyBnZXQgX2luZnVzZWRTZXR0ZXIoKSB7XG4gICAgaWYgKHRoaXMuX3NldCkgcmV0dXJuIHRoaXMuX3NldFxuICAgIGNvbnN0IHNldFN0YXRlOiBhbnkgPSAoc2V0dGFibGU6IGFueSwgbWV0YT86IGFueSkgPT5cbiAgICAgIHRoaXMuc2V0U3RhdGUoc2V0dGFibGUsIG1ldGEpXG5cbiAgICByZXR1cm4gKHRoaXMuX3NldCA9IE9iamVjdC5hc3NpZ24oc2V0U3RhdGUsIHRoaXMuZXhwb3J0cykpXG4gIH1cblxuICBwdWJsaWMgX2luaXQoKSB7XG4gICAgY29uc3QgZmFjdG9yeVJlc3VsdCA9IHRoaXMuX2RvRXZhbHVhdGUoKVxuXG4gICAgO1t0aGlzLl9zdGF0ZVR5cGUsIHRoaXMuc3RvcmVdID0gZ2V0U3RhdGVTdG9yZShmYWN0b3J5UmVzdWx0KVxuXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uID0gdGhpcy5zdG9yZS5zdWJzY3JpYmUoKG5ld1N0YXRlLCBvbGRTdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAvLyBidWZmZXIgdXBkYXRlcyAod2l0aCBjYWNoZSBzaXplIG9mIDEpIGlmIHRoaXMgaW5zdGFuY2UgaXMgY3VycmVudGx5XG4gICAgICAvLyBldmFsdWF0aW5nXG4gICAgICBpZiAodGhpcy5lY29zeXN0ZW0uX2V2YWx1YXRpb25TdGFjay5pc0V2YWx1YXRpbmcodGhpcy5rZXlIYXNoKSkge1xuICAgICAgICB0aGlzLl9idWZmZXJlZFVwZGF0ZSA9IHsgbmV3U3RhdGUsIG9sZFN0YXRlLCBhY3Rpb24gfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5faGFuZGxlU3RhdGVDaGFuZ2UobmV3U3RhdGUsIG9sZFN0YXRlLCBhY3Rpb24pXG4gICAgfSlcblxuICAgIHRoaXMuX3NldEFjdGl2ZVN0YXRlKCdBY3RpdmUnKVxuXG4gICAgLy8gaHlkcmF0ZSBpZiBwb3NzaWJsZVxuICAgIGlmICghdGhpcy5lY29zeXN0ZW0uaHlkcmF0aW9uIHx8IHRoaXMuYXRvbS5tYW51YWxIeWRyYXRpb24pIHJldHVyblxuXG4gICAgY29uc3QgaHlkcmF0aW9uID0gdGhpcy5lY29zeXN0ZW0uX2NvbnN1bWVIeWRyYXRpb24odGhpcylcblxuICAgIGlmICh0eXBlb2YgaHlkcmF0aW9uID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG5cbiAgICB0aGlzLnN0b3JlLnNldFN0YXRlKGh5ZHJhdGlvbilcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGEgc3RhbmRhcmQgYXRvbSBpbnN0YW5jZSdzIHJlZkNvdW50IGhpdHMgMCBhbmQgYSB0dGwgaXMgc2V0LCB3ZSBzZXQgYVxuICAgKiB0aW1lb3V0IHRvIGRlc3Ryb3kgdGhpcyBhdG9tIGluc3RhbmNlLlxuICAgKi9cbiAgcHVibGljIF9zY2hlZHVsZURlc3RydWN0aW9uKCkge1xuICAgIC8vIHRoZSBhdG9tIGlzIGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZXN0cnVjdGlvbiBvciBkZXN0cm95ZWRcbiAgICBpZiAodGhpcy5hY3RpdmVTdGF0ZSAhPT0gJ0FjdGl2ZScpIHJldHVyblxuXG4gICAgdGhpcy5fc2V0QWN0aXZlU3RhdGUoJ1N0YWxlJylcblxuICAgIGNvbnN0IHR0bCA9IHRoaXMuX2dldFR0bCgpXG4gICAgaWYgKHR0bCA9PSBudWxsIHx8IHR0bCA9PT0gLTEpIHJldHVyblxuICAgIGlmICh0dGwgPT09IDApIHJldHVybiB0aGlzLmRlc3Ryb3koKVxuXG4gICAgaWYgKHR5cGVvZiB0dGwgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyB0dGwgaXMgPiAwOyBzY2hlZHVsZSBkZXN0cnVjdGlvblxuICAgICAgY29uc3QgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX2NhbmNlbERlc3RydWN0aW9uID0gdW5kZWZpbmVkXG4gICAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgICB9LCB0dGwpXG5cbiAgICAgIC8vIFRPRE86IGRpc3BhdGNoIGFuIGFjdGlvbiBvdmVyIHN0YXRlU3RvcmUgZm9yIHRoZXNlIG11dGF0aW9uc1xuICAgICAgdGhpcy5fY2FuY2VsRGVzdHJ1Y3Rpb24gPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2NhbmNlbERlc3RydWN0aW9uID0gdW5kZWZpbmVkXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgICB9XG5cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgKHR0bCBhcyBQcm9taXNlPGFueT4pLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxldCBpc0NhbmNlbGVkID0gZmFsc2VcbiAgICAgIDsodHRsIGFzIFByb21pc2U8YW55PikudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuX2NhbmNlbERlc3RydWN0aW9uID0gdW5kZWZpbmVkXG4gICAgICAgIGlmICghaXNDYW5jZWxlZCkgdGhpcy5kZXN0cm95KClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuX2NhbmNlbERlc3RydWN0aW9uID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9jYW5jZWxEZXN0cnVjdGlvbiA9IHVuZGVmaW5lZFxuICAgICAgICBpc0NhbmNlbGVkID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB0dGwgaXMgYW4gb2JzZXJ2YWJsZTsgZGVzdHJveSBhcyBzb29uIGFzIGl0IGVtaXRzXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gKHR0bCBhcyBPYnNlcnZhYmxlKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5fY2FuY2VsRGVzdHJ1Y3Rpb24gPSB1bmRlZmluZWRcbiAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgfSlcblxuICAgIHRoaXMuX2NhbmNlbERlc3RydWN0aW9uID0gKCkgPT4ge1xuICAgICAgdGhpcy5fY2FuY2VsRGVzdHJ1Y3Rpb24gPSB1bmRlZmluZWRcbiAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpXG4gICAgfVxuICB9XG5cbiAgcHVibGljIF9zY2hlZHVsZUV2YWx1YXRpb24gPSAoXG4gICAgcmVhc29uOiBFdmFsdWF0aW9uUmVhc29uLFxuICAgIHNob3VsZFNldFRpbWVvdXQ/OiBib29sZWFuXG4gICkgPT4ge1xuICAgIC8vIFRPRE86IEFueSBjYWxscyBpbiB0aGlzIGNhc2UgcHJvYmFibHkgaW5kaWNhdGUgYSBtZW1vcnkgbGVhayBvbiB0aGVcbiAgICAvLyB1c2VyJ3MgcGFydC4gTm90aWZ5IHRoZW0uIFRPRE86IENhbiB3ZSBwYXVzZSBldmFsdWF0aW9ucyB3aGlsZVxuICAgIC8vIGFjdGl2ZVN0YXRlIGlzIFN0YWxlIChhbmQgc2hvdWxkIHdlIGp1c3QgYWx3YXlzIGV2YWx1YXRlIG9uY2Ugd2hlblxuICAgIC8vIHdha2luZyB1cCBhIHN0YWxlIGF0b20pP1xuICAgIGlmICh0aGlzLmFjdGl2ZVN0YXRlID09PSAnRGVzdHJveWVkJykgcmV0dXJuXG5cbiAgICB0aGlzLl9uZXh0RXZhbHVhdGlvblJlYXNvbnMucHVzaChyZWFzb24pXG5cbiAgICBpZiAodGhpcy5fbmV4dEV2YWx1YXRpb25SZWFzb25zLmxlbmd0aCA+IDEpIHJldHVybiAvLyBqb2IgYWxyZWFkeSBzY2hlZHVsZWRcblxuICAgIHRoaXMuZWNvc3lzdGVtLl9zY2hlZHVsZXIuc2NoZWR1bGUoXG4gICAgICB7XG4gICAgICAgIGtleUhhc2g6IHRoaXMua2V5SGFzaCxcbiAgICAgICAgdGFzazogdGhpcy5ldmFsdWF0aW9uVGFzayxcbiAgICAgICAgdHlwZTogMiwgLy8gRXZhbHVhdGVHcmFwaE5vZGUgKDIpXG4gICAgICB9LFxuICAgICAgc2hvdWxkU2V0VGltZW91dFxuICAgIClcbiAgfVxuXG4gIHByaXZhdGUgZXZhbHVhdGlvblRhc2sgPSAoKSA9PiB0aGlzLl9ldmFsdWF0aW9uVGFzaygpXG5cbiAgcHJpdmF0ZSBfZG9FdmFsdWF0ZSgpOiBTdG9yZVR5cGUgfCBTdGF0ZSB7XG4gICAgdGhpcy5fbmV4dEluamVjdG9ycyA9IFtdXG4gICAgbGV0IG5ld0ZhY3RvcnlSZXN1bHQ6IFN0b3JlVHlwZSB8IFN0YXRlXG4gICAgdGhpcy5lY29zeXN0ZW0uX2V2YWx1YXRpb25TdGFjay5zdGFydCh0aGlzKVxuICAgIHRoaXMuZWNvc3lzdGVtLl9ncmFwaC5idWZmZXJVcGRhdGVzKHRoaXMua2V5SGFzaClcblxuICAgIHRyeSB7XG4gICAgICBuZXdGYWN0b3J5UmVzdWx0ID0gdGhpcy5fZXZhbHVhdGUoKVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5fbmV4dEluamVjdG9ycy5mb3JFYWNoKGluamVjdG9yID0+IHtcbiAgICAgICAgaW5qZWN0b3IuY2xlYW51cD8uKClcbiAgICAgIH0pXG5cbiAgICAgIHRoaXMuX25leHRJbmplY3RvcnMgPSB1bmRlZmluZWRcbiAgICAgIHRoaXMuZWNvc3lzdGVtLl9ncmFwaC5kZXN0cm95QnVmZmVyKClcblxuICAgICAgdGhyb3cgZXJyXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuZWNvc3lzdGVtLl9ldmFsdWF0aW9uU3RhY2suZmluaXNoKClcblxuICAgICAgLy8gZXZlbiBpZiBldmFsdWF0aW9uIGVycm9yZWQsIHdlIG5lZWQgdG8gdXBkYXRlIGRlcGVuZGVudHMgaWYgdGhlIHN0b3JlJ3NcbiAgICAgIC8vIHN0YXRlIGNoYW5nZWRcbiAgICAgIGlmICh0aGlzLl9idWZmZXJlZFVwZGF0ZSkge1xuICAgICAgICB0aGlzLl9oYW5kbGVTdGF0ZUNoYW5nZShcbiAgICAgICAgICB0aGlzLl9idWZmZXJlZFVwZGF0ZS5uZXdTdGF0ZSxcbiAgICAgICAgICB0aGlzLl9idWZmZXJlZFVwZGF0ZS5vbGRTdGF0ZSxcbiAgICAgICAgICB0aGlzLl9idWZmZXJlZFVwZGF0ZS5hY3Rpb25cbiAgICAgICAgKVxuICAgICAgICB0aGlzLl9idWZmZXJlZFVwZGF0ZSA9IHVuZGVmaW5lZFxuICAgICAgfVxuXG4gICAgICB0aGlzLl9wcmV2RXZhbHVhdGlvblJlYXNvbnMgPSB0aGlzLl9uZXh0RXZhbHVhdGlvblJlYXNvbnNcbiAgICAgIHRoaXMuX25leHRFdmFsdWF0aW9uUmVhc29ucyA9IFtdXG4gICAgfVxuXG4gICAgdGhpcy5faW5qZWN0b3JzID0gdGhpcy5fbmV4dEluamVjdG9yc1xuICAgIHRoaXMuX25leHRJbmplY3RvcnMgPSB1bmRlZmluZWRcbiAgICB0aGlzLmVjb3N5c3RlbS5fZ3JhcGguZmx1c2hVcGRhdGVzKClcblxuICAgIHJldHVybiBuZXdGYWN0b3J5UmVzdWx0XG4gIH1cblxuICAvKipcbiAgICogQSBzdGFuZGFyZCBhdG9tJ3MgdmFsdWUgY2FuIGJlIG9uZSBvZjpcbiAgICpcbiAgICogLSBBIHJhdyB2YWx1ZVxuICAgKiAtIEEgWmVkdXggc3RvcmVcbiAgICogLSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHJhdyB2YWx1ZVxuICAgKiAtIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgWmVkdXggc3RvcmVcbiAgICogLSBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBBdG9tQXBpXG4gICAqL1xuICBwcml2YXRlIF9ldmFsdWF0ZSgpIHtcbiAgICBjb25zdCB7IF92YWx1ZSB9ID0gdGhpcy5hdG9tXG5cbiAgICBpZiAodHlwZW9mIF92YWx1ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIF92YWx1ZVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWwgPSAoX3ZhbHVlIGFzIChcbiAgICAgICAgLi4ucGFyYW1zOiBQYXJhbXNcbiAgICAgICkgPT4gU3RvcmVUeXBlIHwgU3RhdGUgfCBBdG9tQXBpPFN0YXRlLCBFeHBvcnRzLCBTdG9yZVR5cGUsIFByb21pc2VUeXBlPikoXG4gICAgICAgIC4uLnRoaXMucGFyYW1zXG4gICAgICApXG5cbiAgICAgIGlmICghaXModmFsLCBBdG9tQXBpKSkgcmV0dXJuIHZhbCBhcyBTdG9yZVR5cGUgfCBTdGF0ZVxuXG4gICAgICB0aGlzLmFwaSA9IHZhbCBhcyBBdG9tQXBpPFN0YXRlLCBFeHBvcnRzLCBTdG9yZVR5cGUsIFByb21pc2VUeXBlPlxuXG4gICAgICAvLyBFeHBvcnRzIGNhbiBvbmx5IGJlIHNldCBvbiBpbml0aWFsIGV2YWx1YXRpb25cbiAgICAgIGlmICh0aGlzLmFjdGl2ZVN0YXRlID09PSAnSW5pdGlhbGl6aW5nJykge1xuICAgICAgICB0aGlzLmV4cG9ydHMgPSB0aGlzLmFwaS5leHBvcnRzIGFzIEV4cG9ydHNcbiAgICAgIH1cblxuICAgICAgLy8gaWYgYXBpLnZhbHVlIGlzIGEgcHJvbWlzZSwgd2UgaWdub3JlIGFwaS5wcm9taXNlXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiAoKHRoaXMuYXBpLnZhbHVlIGFzIHVua25vd24pIGFzIFByb21pc2U8YW55Pik/LnRoZW4gPT09XG4gICAgICAgICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2V0UHJvbWlzZShcbiAgICAgICAgICAodGhpcy5hcGkudmFsdWUgYXMgdW5rbm93bikgYXMgUHJvbWlzZTxhbnk+LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmFwaS5wcm9taXNlKSB7XG4gICAgICAgIHRoaXMuX3NldFByb21pc2UodGhpcy5hcGkucHJvbWlzZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuYXBpLnZhbHVlIGFzIFN0b3JlVHlwZSB8IFN0YXRlXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICBgWmVkdXg6IEVycm9yIHdoaWxlIGV2YWx1YXRpbmcgYXRvbSBcIiR7dGhpcy5hdG9tLmtleX1cIiB3aXRoIHBhcmFtczpgLFxuICAgICAgICB0aGlzLnBhcmFtcyxcbiAgICAgICAgZXJyXG4gICAgICApXG5cbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2V2YWx1YXRpb25UYXNrKCkge1xuICAgIGNvbnN0IG5ld0ZhY3RvcnlSZXN1bHQgPSB0aGlzLl9kb0V2YWx1YXRlKClcblxuICAgIGNvbnN0IG5ld1N0YXRlVHlwZSA9IGdldFN0YXRlVHlwZShuZXdGYWN0b3J5UmVzdWx0KVxuXG4gICAgaWYgKERFViAmJiBuZXdTdGF0ZVR5cGUgIT09IHRoaXMuX3N0YXRlVHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWmVkdXg6IGF0b20gZmFjdG9yeSBmb3IgYXRvbSBcIiR7dGhpcy5hdG9tLmtleX1cIiByZXR1cm5lZCBhIGRpZmZlcmVudCB0eXBlIHRoYW4gdGhlIHByZXZpb3VzIGV2YWx1YXRpb24uIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGUgYXRvbSByZXR1cm5lZCBhIHN0b3JlIGluaXRpYWxseSBidXQgdGhlbiByZXR1cm5lZCBhIG5vbi1zdG9yZSB2YWx1ZSBvbiBhIGxhdGVyIGV2YWx1YXRpb24gb3IgdmljZSB2ZXJzYWBcbiAgICAgIClcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBERVYgJiZcbiAgICAgIG5ld1N0YXRlVHlwZSA9PT0gU3RhdGVUeXBlLlN0b3JlICYmXG4gICAgICBuZXdGYWN0b3J5UmVzdWx0ICE9PSB0aGlzLnN0b3JlXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBaZWR1eDogYXRvbSBmYWN0b3J5IGZvciBhdG9tIFwiJHt0aGlzLmF0b20ua2V5fVwiIHJldHVybmVkIGEgZGlmZmVyZW50IHN0b3JlLiBEaWQgeW91IG1lYW4gdG8gdXNlIFxcYGluamVjdFN0b3JlKClcXGAsIG9yIFxcYGluamVjdE1lbW8oKVxcYD9gXG4gICAgICApXG4gICAgfVxuXG4gICAgLy8gdGhlcmUgaXMgbm8gd2F5IHRvIGNhdXNlIGFuIGV2YWx1YXRpb24gbG9vcCB3aGVuIHRoZSBTdGF0ZVR5cGUgaXMgVmFsdWVcbiAgICBpZiAobmV3U3RhdGVUeXBlID09PSBTdGF0ZVR5cGUuVmFsdWUpIHtcbiAgICAgIHRoaXMuc3RvcmUuc2V0U3RhdGUoXG4gICAgICAgIHR5cGVvZiBuZXdGYWN0b3J5UmVzdWx0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgPyAoKSA9PiBuZXdGYWN0b3J5UmVzdWx0IGFzIFN0YXRlXG4gICAgICAgICAgOiAobmV3RmFjdG9yeVJlc3VsdCBhcyBTdGF0ZSlcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9nZXRUdGwoKSB7XG4gICAgaWYgKHRoaXMuYXBpPy50dGwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuYXRvbS50dGwgPz8gdGhpcy5lY29zeXN0ZW0uZGVmYXVsdFR0bFxuICAgIH1cblxuICAgIC8vIHRoaXMgYXRvbSBpbnN0YW5jZSBzZXQgaXRzIG93biB0dGxcbiAgICBjb25zdCB7IHR0bCB9ID0gdGhpcy5hcGlcblxuICAgIHJldHVybiB0eXBlb2YgdHRsID09PSAnZnVuY3Rpb24nID8gdHRsKCkgOiB0dGxcbiAgfVxuXG4gIHByaXZhdGUgX2hhbmRsZVN0YXRlQ2hhbmdlKFxuICAgIG5ld1N0YXRlOiBTdGF0ZSxcbiAgICBvbGRTdGF0ZTogU3RhdGUgfCB1bmRlZmluZWQsXG4gICAgYWN0aW9uOiBBY3Rpb25DaGFpblxuICApIHtcbiAgICB0aGlzLmVjb3N5c3RlbS5fZ3JhcGguc2NoZWR1bGVEZXBlbmRlbnRzKFxuICAgICAgdGhpcy5rZXlIYXNoLFxuICAgICAgdGhpcy5fbmV4dEV2YWx1YXRpb25SZWFzb25zLFxuICAgICAgbmV3U3RhdGUsXG4gICAgICBvbGRTdGF0ZSxcbiAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgaWYgKHRoaXMuZWNvc3lzdGVtLl9tb2RzLnN0YXRlQ2hhbmdlZCkge1xuICAgICAgdGhpcy5lY29zeXN0ZW0ubW9kQnVzLmRpc3BhdGNoKFxuICAgICAgICBwbHVnaW5BY3Rpb25zLnN0YXRlQ2hhbmdlZCh7XG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIGluc3RhbmNlOiB0aGlzLFxuICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgIG9sZFN0YXRlLFxuICAgICAgICAgIHJlYXNvbnM6IHRoaXMuX25leHRFdmFsdWF0aW9uUmVhc29ucyxcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9XG5cbiAgICAvLyBydW4gdGhlIHNjaGVkdWxlciBzeW5jaHJvbm91c2x5IGFmdGVyIGFueSBhdG9tIGluc3RhbmNlIHN0YXRlIHVwZGF0ZVxuICAgIHRoaXMuZWNvc3lzdGVtLl9zY2hlZHVsZXIuZmx1c2goKVxuICB9XG5cbiAgcHJpdmF0ZSBfaW52YWxpZGF0ZShcbiAgICBvcGVyYXRpb24gPSAnaW52YWxpZGF0ZScsXG4gICAgc291cmNlVHlwZTogRXZhbHVhdGlvblNvdXJjZVR5cGUgPSAnRXh0ZXJuYWwnXG4gICkge1xuICAgIHRoaXMuX3NjaGVkdWxlRXZhbHVhdGlvbihcbiAgICAgIHtcbiAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICBzb3VyY2VUeXBlLFxuICAgICAgICB0eXBlOiAnY2FjaGUgaW52YWxpZGF0ZWQnLFxuICAgICAgfSxcbiAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgLy8gcnVuIHRoZSBzY2hlZHVsZXIgc3luY2hyb25vdXNseSBhZnRlciBpbnZhbGlkYXRpb25cbiAgICB0aGlzLmVjb3N5c3RlbS5fc2NoZWR1bGVyLmZsdXNoKClcbiAgfVxuXG4gIHByaXZhdGUgX3NldEFjdGl2ZVN0YXRlKG5ld0FjdGl2ZVN0YXRlOiBBY3RpdmVTdGF0ZSkge1xuICAgIGNvbnN0IG9sZEFjdGl2ZVN0YXRlID0gdGhpcy5hY3RpdmVTdGF0ZVxuICAgIHRoaXMuYWN0aXZlU3RhdGUgPSBuZXdBY3RpdmVTdGF0ZVxuXG4gICAgaWYgKHRoaXMuZWNvc3lzdGVtLl9tb2RzLmFjdGl2ZVN0YXRlQ2hhbmdlZCkge1xuICAgICAgdGhpcy5lY29zeXN0ZW0ubW9kQnVzLmRpc3BhdGNoKFxuICAgICAgICBwbHVnaW5BY3Rpb25zLmFjdGl2ZVN0YXRlQ2hhbmdlZCh7XG4gICAgICAgICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgICAgICAgbmV3QWN0aXZlU3RhdGUsXG4gICAgICAgICAgb2xkQWN0aXZlU3RhdGUsXG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfc2V0UHJvbWlzZShwcm9taXNlOiBQcm9taXNlPGFueT4sIGlzU3RhdGVVcGRhdGVyPzogYm9vbGVhbikge1xuICAgIGlmIChwcm9taXNlID09PSB0aGlzLnByb21pc2UpIHJldHVybiB0aGlzLnN0b3JlLmdldFN0YXRlKClcblxuICAgIHRoaXMucHJvbWlzZSA9IHByb21pc2UgYXMgUHJvbWlzZVR5cGVcblxuICAgIC8vIHNpbmNlIHdlJ3JlIHRoZSBmaXJzdCB0byBjaGFpbiBvZmYgdGhlIHJldHVybmVkIHByb21pc2UsIHdlIGRvbid0IG5lZWQgdG9cbiAgICAvLyB0cmFjayB0aGUgY2hhaW5lZCBwcm9taXNlIC0gaXQgd2lsbCBydW4gZmlyc3QsIGJlZm9yZSBSZWFjdCBzdXNwZW5zZSdzXG4gICAgLy8gYC50aGVuYCBvbiB0aGUgdGhyb3duIHByb21pc2UsIGZvciBleGFtcGxlXG4gICAgcHJvbWlzZVxuICAgICAgLnRoZW4oZGF0YSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnByb21pc2UgIT09IHByb21pc2UpIHJldHVyblxuXG4gICAgICAgIHRoaXMuX3Byb21pc2VTdGF0dXMgPSAnc3VjY2VzcydcbiAgICAgICAgaWYgKCFpc1N0YXRlVXBkYXRlcikgcmV0dXJuXG5cbiAgICAgICAgdGhpcy5zdG9yZS5zZXRTdGF0ZSgoZ2V0U3VjY2Vzc1Byb21pc2VTdGF0ZShkYXRhKSBhcyB1bmtub3duKSBhcyBTdGF0ZSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICBpZiAodGhpcy5wcm9taXNlICE9PSBwcm9taXNlKSByZXR1cm5cblxuICAgICAgICB0aGlzLl9wcm9taXNlU3RhdHVzID0gJ2Vycm9yJ1xuICAgICAgICB0aGlzLl9wcm9taXNlRXJyb3IgPSBlcnJvclxuICAgICAgICBpZiAoIWlzU3RhdGVVcGRhdGVyKSByZXR1cm5cblxuICAgICAgICB0aGlzLnN0b3JlLnNldFN0YXRlKChnZXRFcnJvclByb21pc2VTdGF0ZShlcnJvcikgYXMgdW5rbm93bikgYXMgU3RhdGUpXG4gICAgICB9KVxuXG4gICAgY29uc3Qgc3RhdGU6IFByb21pc2VTdGF0ZTxhbnk+ID0gZ2V0SW5pdGlhbFByb21pc2VTdGF0ZSgpXG4gICAgdGhpcy5fcHJvbWlzZVN0YXR1cyA9IHN0YXRlLnN0YXR1c1xuXG4gICAgdGhpcy5lY29zeXN0ZW0uX2dyYXBoLnNjaGVkdWxlRGVwZW5kZW50cyhcbiAgICAgIHRoaXMua2V5SGFzaCxcbiAgICAgIHRoaXMuX25leHRFdmFsdWF0aW9uUmVhc29ucyxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHRydWUsXG4gICAgICAncHJvbWlzZSBjaGFuZ2VkJyxcbiAgICAgICdVcGRhdGVkJyxcbiAgICAgIHRydWVcbiAgICApXG5cbiAgICByZXR1cm4gKHN0YXRlIGFzIHVua25vd24pIGFzIFN0YXRlXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJjcmVhdGVTdG9yZSIsImlzIiwiU3RvcmUiLCJnZXRFcnJvclByb21pc2VTdGF0ZSIsImdldEluaXRpYWxQcm9taXNlU3RhdGUiLCJnZXRTdWNjZXNzUHJvbWlzZVN0YXRlIiwiQXRvbUFwaSIsIkF0b21JbnN0YW5jZUJhc2UiLCJwbHVnaW5BY3Rpb25zIiwiU3RhdGVUeXBlIiwiZ2V0U3RhdGVUeXBlIiwidmFsIiwiVmFsdWUiLCJnZXRTdGF0ZVN0b3JlIiwiZmFjdG9yeVJlc3VsdCIsInN0YXRlVHlwZSIsInN0YXRlU3RvcmUiLCJzZXRTdGF0ZSIsIkF0b21JbnN0YW5jZSIsImVjb3N5c3RlbSIsImF0b20iLCJrZXlIYXNoIiwicGFyYW1zIiwiYWN0aXZlU3RhdGUiLCJfY3JlYXRlZEF0IiwiRGF0ZSIsIm5vdyIsIl9uZXh0RXZhbHVhdGlvblJlYXNvbnMiLCJkaXNwYXRjaCIsImFjdGlvbiIsInN0b3JlIiwiaW52YWxpZGF0ZSIsIm9wZXJhdGlvbiIsInNvdXJjZVR5cGUiLCJfaW52YWxpZGF0ZSIsInNldHRhYmxlIiwibWV0YSIsInNldFN0YXRlRGVlcCIsIl9zY2hlZHVsZUV2YWx1YXRpb24iLCJyZWFzb24iLCJzaG91bGRTZXRUaW1lb3V0IiwicHVzaCIsImxlbmd0aCIsIl9zY2hlZHVsZXIiLCJzY2hlZHVsZSIsInRhc2siLCJldmFsdWF0aW9uVGFzayIsInR5cGUiLCJfZXZhbHVhdGlvblRhc2siLCJleHBvcnRzIiwicHJvbWlzZSIsIl9wcm9taXNlU3RhdHVzIiwiZGVzdHJveSIsImZvcmNlIiwiT2JqZWN0Iiwia2V5cyIsIl9ncmFwaCIsIm5vZGVzIiwiZGVwZW5kZW50cyIsIl9jYW5jZWxEZXN0cnVjdGlvbiIsInVuZGVmaW5lZCIsIl9zZXRBY3RpdmVTdGF0ZSIsInVuc2NoZWR1bGUiLCJub25FZmZlY3RJbmplY3RvcnMiLCJfaW5qZWN0b3JzIiwiZm9yRWFjaCIsImluamVjdG9yIiwiY2xlYW51cCIsInJlbW92ZURlcGVuZGVuY2llcyIsIl9zdWJzY3JpcHRpb24iLCJ1bnN1YnNjcmliZSIsIl9kZXN0cm95QXRvbUluc3RhbmNlIiwiZ2V0U3RhdGUiLCJfaW5pdCIsIl9kb0V2YWx1YXRlIiwiX3N0YXRlVHlwZSIsInN1YnNjcmliZSIsIm5ld1N0YXRlIiwib2xkU3RhdGUiLCJfZXZhbHVhdGlvblN0YWNrIiwiaXNFdmFsdWF0aW5nIiwiX2J1ZmZlcmVkVXBkYXRlIiwiX2hhbmRsZVN0YXRlQ2hhbmdlIiwiaHlkcmF0aW9uIiwibWFudWFsSHlkcmF0aW9uIiwiX2NvbnN1bWVIeWRyYXRpb24iLCJfc2NoZWR1bGVEZXN0cnVjdGlvbiIsInR0bCIsIl9nZXRUdGwiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwidGhlbiIsImlzQ2FuY2VsZWQiLCJzdWJzY3JpcHRpb24iLCJfbmV4dEluamVjdG9ycyIsIm5ld0ZhY3RvcnlSZXN1bHQiLCJzdGFydCIsImJ1ZmZlclVwZGF0ZXMiLCJfZXZhbHVhdGUiLCJlcnIiLCJkZXN0cm95QnVmZmVyIiwiZmluaXNoIiwiX3ByZXZFdmFsdWF0aW9uUmVhc29ucyIsImZsdXNoVXBkYXRlcyIsIl92YWx1ZSIsImFwaSIsInZhbHVlIiwiX3NldFByb21pc2UiLCJjb25zb2xlIiwiZXJyb3IiLCJrZXkiLCJuZXdTdGF0ZVR5cGUiLCJERVYiLCJFcnJvciIsImRlZmF1bHRUdGwiLCJzY2hlZHVsZURlcGVuZGVudHMiLCJfbW9kcyIsInN0YXRlQ2hhbmdlZCIsIm1vZEJ1cyIsImluc3RhbmNlIiwicmVhc29ucyIsImZsdXNoIiwibmV3QWN0aXZlU3RhdGUiLCJvbGRBY3RpdmVTdGF0ZSIsImFjdGl2ZVN0YXRlQ2hhbmdlZCIsImlzU3RhdGVVcGRhdGVyIiwiZGF0YSIsImNhdGNoIiwiX3Byb21pc2VFcnJvciIsInN0YXRlIiwic3RhdHVzIiwiX3NldCIsImFzc2lnbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4985\n")},4987:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "T": function() { return /* binding */ AtomInstanceBase; }\n/* harmony export */ });\n/* harmony import */ var _zedux_react_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(395);\nvar AtomInstanceBase=/*#__PURE__*/function(){function AtomInstanceBase(){}var _proto=AtomInstanceBase.prototype;_proto.addDependent=function addDependent(_temp){var _this=this;var _ref=_temp===void 0?{}:_temp,callback=_ref.callback,_ref$operation=_ref.operation,operation=_ref$operation===void 0?\'addDependent\':_ref$operation;var id=this.ecosystem._idGenerator.generateNodeId();this.ecosystem._graph.addEdge(id,this.keyHash,operation,_zedux_react_utils__WEBPACK_IMPORTED_MODULE_0__/* .Explicit */ .Jy|_zedux_react_utils__WEBPACK_IMPORTED_MODULE_0__/* .External */ .RQ,callback);return function(){return _this.ecosystem._graph.removeEdge(id,_this.keyHash);};};return AtomInstanceBase;}();AtomInstanceBase.$$typeof=Symbol.for(_zedux_react_utils__WEBPACK_IMPORTED_MODULE_0__/* .prefix */ .O4+"/AtomInstanceBase");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDk4Ny5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBaUJPLEdBQWVHLGlCQUFnQixtR0EwQjdCQyxZQUFZLENBQW5CLDRCQU1pQix3Q0FBYixDQUFDLENBQUMsT0FMSkMsUUFBUSxNQUFSQSxRQUFRLHFCQUNSQyxTQUFTLENBQVRBLFNBQVMseUJBQUcsY0FBYyxnQkFLMUIsR0FBTUMsR0FBRSxDQUFHLElBQUksQ0FBQ0MsU0FBUyxDQUFDQyxZQUFZLENBQUNDLGNBQWMsRUFBRSxDQUN2RCxJQUFJLENBQUNGLFNBQVMsQ0FBQ0csTUFBTSxDQUFDQyxPQUFPLENBQzNCTCxFQUFFLENBQ0YsSUFBSSxDQUFDTSxPQUFPLENBQ1pQLFNBQVMsQ0FDVE4sa0VBQVEsQ0FBR0Msa0VBQVEsQ0FDbkJJLFFBQVEsQ0FDVCxDQUVELE1BQU8sa0JBQU0sTUFBSSxDQUFDRyxTQUFTLENBQUNHLE1BQU0sQ0FBQ0csVUFBVSxDQUFDUCxFQUFFLENBQUUsS0FBSSxDQUFDTSxPQUFPLENBQUMsR0FDakUsQ0FBQyw2QkEzQ21CVixnQkFBZ0IsQ0FLdEJZLFFBQVEsQ0FBR0MsTUFBTSxDQUFDQyxHQUFHLENBQUlmLGdFQUFNLHFCQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL2NsYXNzZXMvaW5zdGFuY2VzL0F0b21JbnN0YW5jZUJhc2UudHM/YmQ3MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBY3RpdmVTdGF0ZSxcbiAgRXZhbHVhdGlvblJlYXNvbixcbiAgQ2xlYW51cCxcbiAgUHJvbWlzZVN0YXR1cyxcbiAgRGVwZW5kZW50Q2FsbGJhY2ssXG59IGZyb20gJ0B6ZWR1eC9yZWFjdC90eXBlcydcbmltcG9ydCB7XG4gIEV4cGxpY2l0LFxuICBFeHRlcm5hbCxcbiAgSW5qZWN0b3JEZXNjcmlwdG9yLFxuICBwcmVmaXgsXG59IGZyb20gJ0B6ZWR1eC9yZWFjdC91dGlscydcbmltcG9ydCB7IEF0b21CYXNlIH0gZnJvbSAnLi4vYXRvbXMvQXRvbUJhc2UnXG5pbXBvcnQgeyBFY29zeXN0ZW0gfSBmcm9tICcuLi9FY29zeXN0ZW0nXG5pbXBvcnQgeyBTdG9yZSB9IGZyb20gJ0B6ZWR1eC9jb3JlJ1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQXRvbUluc3RhbmNlQmFzZTxcbiAgU3RhdGUsXG4gIFBhcmFtcyBleHRlbmRzIGFueVtdLFxuICBBdG9tVHlwZSBleHRlbmRzIEF0b21CYXNlPFN0YXRlLCBQYXJhbXMsIGFueSwgYW55LCBhbnksIGFueT5cbj4ge1xuICBwdWJsaWMgc3RhdGljICQkdHlwZW9mID0gU3ltYm9sLmZvcihgJHtwcmVmaXh9L0F0b21JbnN0YW5jZUJhc2VgKVxuICBwdWJsaWMgYWJzdHJhY3QgYWN0aXZlU3RhdGU6IEFjdGl2ZVN0YXRlXG4gIHB1YmxpYyBhYnN0cmFjdCBhdG9tOiBBdG9tVHlwZVxuICBwdWJsaWMgYWJzdHJhY3QgZWNvc3lzdGVtOiBFY29zeXN0ZW1cbiAgcHVibGljIGFic3RyYWN0IGtleUhhc2g6IHN0cmluZ1xuICBwdWJsaWMgYWJzdHJhY3QgcHJvbWlzZT86IFByb21pc2U8YW55PlxuICBwdWJsaWMgYWJzdHJhY3Qgc3RvcmU6IFN0b3JlPFN0YXRlPlxuXG4gIHB1YmxpYyBhYnN0cmFjdCBfY3JlYXRlZEF0OiBudW1iZXJcbiAgcHVibGljIGFic3RyYWN0IF9pbmplY3RvcnM/OiBJbmplY3RvckRlc2NyaXB0b3JbXVxuICBwdWJsaWMgYWJzdHJhY3QgX3ByZXZFdmFsdWF0aW9uUmVhc29ucz86IEV2YWx1YXRpb25SZWFzb25bXVxuICBwdWJsaWMgYWJzdHJhY3QgX3Byb21pc2VFcnJvcj86IEVycm9yXG4gIHB1YmxpYyBhYnN0cmFjdCBfcHJvbWlzZVN0YXR1cz86IFByb21pc2VTdGF0dXNcblxuICBwdWJsaWMgYWJzdHJhY3QgZGVzdHJveShmb3JjZT86IGJvb2xlYW4pOiB2b2lkXG5cbiAgcHVibGljIGFic3RyYWN0IF9zY2hlZHVsZUV2YWx1YXRpb24oXG4gICAgcmVhc29uOiBFdmFsdWF0aW9uUmVhc29uLFxuICAgIHNob3VsZFNldFRpbWVvdXQ/OiBib29sZWFuXG4gICk6IHZvaWRcblxuICBwdWJsaWMgYWRkRGVwZW5kZW50KHtcbiAgICBjYWxsYmFjayxcbiAgICBvcGVyYXRpb24gPSAnYWRkRGVwZW5kZW50JyxcbiAgfToge1xuICAgIGNhbGxiYWNrPzogRGVwZW5kZW50Q2FsbGJhY2tcbiAgICBvcGVyYXRpb24/OiBzdHJpbmdcbiAgfSA9IHt9KTogQ2xlYW51cCB7XG4gICAgY29uc3QgaWQgPSB0aGlzLmVjb3N5c3RlbS5faWRHZW5lcmF0b3IuZ2VuZXJhdGVOb2RlSWQoKVxuICAgIHRoaXMuZWNvc3lzdGVtLl9ncmFwaC5hZGRFZGdlKFxuICAgICAgaWQsXG4gICAgICB0aGlzLmtleUhhc2gsXG4gICAgICBvcGVyYXRpb24sXG4gICAgICBFeHBsaWNpdCB8IEV4dGVybmFsLFxuICAgICAgY2FsbGJhY2tcbiAgICApXG5cbiAgICByZXR1cm4gKCkgPT4gdGhpcy5lY29zeXN0ZW0uX2dyYXBoLnJlbW92ZUVkZ2UoaWQsIHRoaXMua2V5SGFzaClcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkV4cGxpY2l0IiwiRXh0ZXJuYWwiLCJwcmVmaXgiLCJBdG9tSW5zdGFuY2VCYXNlIiwiYWRkRGVwZW5kZW50IiwiY2FsbGJhY2siLCJvcGVyYXRpb24iLCJpZCIsImVjb3N5c3RlbSIsIl9pZEdlbmVyYXRvciIsImdlbmVyYXRlTm9kZUlkIiwiX2dyYXBoIiwiYWRkRWRnZSIsImtleUhhc2giLCJyZW1vdmVFZGdlIiwiJCR0eXBlb2YiLCJTeW1ib2wiLCJmb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4987\n')},552:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "h": function() { return /* binding */ api; }\n/* harmony export */ });\n/* harmony import */ var _classes_AtomApi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2448);\nvar api=function api(value){return new _classes_AtomApi__WEBPACK_IMPORTED_MODULE_0__/* .AtomApi */ .u(value);};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUyLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFJTyxHQUFNQyxJQXFDWixDQUFHLFFBckNTQSxJQXFDWixDQU1DQyxLQUEyRSxRQUUzRSxJQUFJRixDQUFBQSw4REFBTyxDQUNURSxLQUFLLENBQ04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9mYWN0b3JpZXMvYXBpLnRzP2EwNGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3RvcmUsIFN0b3JlU3RhdGVUeXBlIH0gZnJvbSAnQHplZHV4L2NvcmUnXG5pbXBvcnQgeyBBdG9tQXBpIH0gZnJvbSAnLi4vY2xhc3Nlcy9BdG9tQXBpJ1xuaW1wb3J0IHsgQXRvbUFwaVByb21pc2UgfSBmcm9tICcuLi90eXBlcydcblxuZXhwb3J0IGNvbnN0IGFwaToge1xuICAvLyBDdXN0b20gU3RvcmVzXG4gIDxcbiAgICBTdG9yZVR5cGUgZXh0ZW5kcyBTdG9yZTxhbnk+ID0gU3RvcmU8YW55PixcbiAgICBFeHBvcnRzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiA9IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gICAgUHJvbWlzZVR5cGUgZXh0ZW5kcyBBdG9tQXBpUHJvbWlzZSA9IHVuZGVmaW5lZFxuICA+KFxuICAgIHZhbHVlOlxuICAgICAgfCBTdG9yZVR5cGVcbiAgICAgIHwgQXRvbUFwaTxTdG9yZVN0YXRlVHlwZTxTdG9yZVR5cGU+LCBFeHBvcnRzLCBTdG9yZVR5cGUsIFByb21pc2VUeXBlPlxuICApOiBBdG9tQXBpPFN0b3JlU3RhdGVUeXBlPFN0b3JlVHlwZT4sIEV4cG9ydHMsIFN0b3JlVHlwZSwgUHJvbWlzZVR5cGU+XG5cbiAgLy8gTm8gVmFsdWVcbiAgPFxuICAgIFN0YXRlID0gdW5kZWZpbmVkLFxuICAgIEV4cG9ydHMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gUmVjb3JkPHN0cmluZywgYW55PixcbiAgICBQcm9taXNlVHlwZSBleHRlbmRzIEF0b21BcGlQcm9taXNlID0gdW5kZWZpbmVkXG4gID4oKTogQXRvbUFwaTxTdGF0ZSwgRXhwb3J0cywgdW5kZWZpbmVkLCBQcm9taXNlVHlwZT5cblxuICAvLyBObyBTdG9yZVxuICA8XG4gICAgU3RhdGUgPSB1bmRlZmluZWQsXG4gICAgRXhwb3J0cyBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4gPSBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgIFByb21pc2VUeXBlIGV4dGVuZHMgQXRvbUFwaVByb21pc2UgPSB1bmRlZmluZWRcbiAgPihcbiAgICB2YWx1ZTogU3RhdGUgfCBBdG9tQXBpPFN0YXRlLCBFeHBvcnRzLCB1bmRlZmluZWQsIFByb21pc2VUeXBlPlxuICApOiBBdG9tQXBpPFN0YXRlLCBFeHBvcnRzLCB1bmRlZmluZWQsIFByb21pc2VUeXBlPlxuXG4gIC8vIENhdGNoLWFsbFxuICA8XG4gICAgU3RhdGUgPSB1bmRlZmluZWQsXG4gICAgRXhwb3J0cyBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4gPSBSZWNvcmQ8c3RyaW5nLCBhbnk+LFxuICAgIFN0b3JlVHlwZSBleHRlbmRzIFN0b3JlPFN0YXRlPiA9IFN0b3JlPFN0YXRlPixcbiAgICBQcm9taXNlVHlwZSBleHRlbmRzIEF0b21BcGlQcm9taXNlID0gdW5kZWZpbmVkXG4gID4oXG4gICAgdmFsdWU6IFN0YXRlIHwgU3RvcmVUeXBlIHwgQXRvbUFwaTxTdGF0ZSwgRXhwb3J0cywgU3RvcmVUeXBlLCBQcm9taXNlVHlwZT5cbiAgKTogQXRvbUFwaTxTdGF0ZSwgRXhwb3J0cywgU3RvcmVUeXBlLCBQcm9taXNlVHlwZT5cbn0gPSA8XG4gIFN0YXRlID0gdW5kZWZpbmVkLFxuICBFeHBvcnRzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiA9IFJlY29yZDxzdHJpbmcsIGFueT4sXG4gIFN0b3JlVHlwZSBleHRlbmRzIFN0b3JlPFN0YXRlPiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZCxcbiAgUHJvbWlzZVR5cGUgZXh0ZW5kcyBBdG9tQXBpUHJvbWlzZSA9IHVuZGVmaW5lZFxuPihcbiAgdmFsdWU/OiBBdG9tQXBpPFN0YXRlLCBFeHBvcnRzLCBTdG9yZVR5cGUsIFByb21pc2VUeXBlPiB8IFN0b3JlVHlwZSB8IFN0YXRlXG4pID0+XG4gIG5ldyBBdG9tQXBpKFxuICAgIHZhbHVlIGFzIEF0b21BcGk8U3RhdGUsIEV4cG9ydHMsIFN0b3JlVHlwZSwgUHJvbWlzZVR5cGU+IHwgU3RvcmVUeXBlIHwgU3RhdGVcbiAgKVxuIl0sIm5hbWVzIjpbIkF0b21BcGkiLCJhcGkiLCJ2YWx1ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///552\n')},5965:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"c\": function() { return /* binding */ atom; }\n/* harmony export */ });\n/* harmony import */ var _classes_atoms_Atom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1968);\nvar atom=function atom(key,value,config){if( true&&!key){throw new TypeError('Zedux: All atoms must have a key');}return new _classes_atoms_Atom__WEBPACK_IMPORTED_MODULE_0__/* .Atom */ .h(key,value,config);};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTk2NS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBVU8sR0FBTUMsS0FnRFosQ0FBRyxRQWhEU0EsS0FnRFosQ0FPQ0MsR0FBVyxDQUNYQyxLQUF5RSxDQUN6RUMsTUFBMEIsQ0FDdkIsQ0FDSCxHQUFJQyxLQUFHLEVBQUksQ0FBQ0gsR0FBRyxDQUFFLENBQ2YsS0FBTSxJQUFJSSxVQUFTLENBQUMsa0NBQWtDLENBQUMsQ0FDekQsQ0FFQSxNQUFPLElBQUlOLENBQUFBLDhEQUFJLENBQ2JFLEdBQUcsQ0FDSEMsS0FBSyxDQUNMQyxNQUFNLENBQ1AsQ0FDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9yZWFjdC9zcmMvZmFjdG9yaWVzL2F0b20udHM/Njc3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdG9yZSwgU3RvcmVTdGF0ZVR5cGUgfSBmcm9tICdAemVkdXgvY29yZSdcbmltcG9ydCB7XG4gIEF0b21Db25maWcsXG4gIEF0b21BcGlQcm9taXNlLFxuICBBdG9tVmFsdWVPckZhY3RvcnksXG4gIFByb21pc2VTdGF0ZSxcbn0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBBdG9tIH0gZnJvbSAnLi4vY2xhc3Nlcy9hdG9tcy9BdG9tJ1xuaW1wb3J0IHsgQXRvbUFwaSB9IGZyb20gJy4uL2NsYXNzZXMnXG5cbmV4cG9ydCBjb25zdCBhdG9tOiB7XG4gIC8vIFF1ZXJ5IEF0b21zXG4gIDxcbiAgICBTdGF0ZSA9IGFueSxcbiAgICBQYXJhbXMgZXh0ZW5kcyBhbnlbXSA9IFtdLFxuICAgIEV4cG9ydHMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gUmVjb3JkPHN0cmluZywgbmV2ZXI+XG4gID4oXG4gICAga2V5OiBzdHJpbmcsXG4gICAgdmFsdWU6IChcbiAgICAgIC4uLnBhcmFtczogUGFyYW1zXG4gICAgKSA9PiBBdG9tQXBpPFByb21pc2U8U3RhdGU+LCBFeHBvcnRzLCB1bmRlZmluZWQsIGFueT4sXG4gICAgY29uZmlnPzogQXRvbUNvbmZpZzxTdGF0ZT5cbiAgKTogQXRvbTxcbiAgICBQcm9taXNlU3RhdGU8U3RhdGU+LFxuICAgIFBhcmFtcyxcbiAgICBFeHBvcnRzLFxuICAgIFN0b3JlPFByb21pc2VTdGF0ZTxTdGF0ZT4+LFxuICAgIFByb21pc2U8U3RhdGU+XG4gID5cblxuICAvLyBDdXN0b20gU3RvcmVzXG4gIDxcbiAgICBTdG9yZVR5cGUgZXh0ZW5kcyBTdG9yZTxhbnk+ID0gU3RvcmU8YW55PixcbiAgICBQYXJhbXMgZXh0ZW5kcyBhbnlbXSA9IFtdLFxuICAgIEV4cG9ydHMgZXh0ZW5kcyBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0gUmVjb3JkPHN0cmluZywgbmV2ZXI+LFxuICAgIFByb21pc2VUeXBlIGV4dGVuZHMgQXRvbUFwaVByb21pc2UgPSB1bmRlZmluZWRcbiAgPihcbiAgICBrZXk6IHN0cmluZyxcbiAgICB2YWx1ZTogKFxuICAgICAgLi4ucGFyYW1zOiBQYXJhbXNcbiAgICApID0+XG4gICAgICB8IFN0b3JlVHlwZVxuICAgICAgfCBBdG9tQXBpPFN0b3JlU3RhdGVUeXBlPFN0b3JlPiwgRXhwb3J0cywgU3RvcmVUeXBlLCBQcm9taXNlVHlwZT4sXG4gICAgY29uZmlnPzogQXRvbUNvbmZpZzxTdG9yZVN0YXRlVHlwZTxTdG9yZVR5cGU+PlxuICApOiBBdG9tPFN0b3JlU3RhdGVUeXBlPFN0b3JlVHlwZT4sIFBhcmFtcywgRXhwb3J0cywgU3RvcmVUeXBlLCBQcm9taXNlVHlwZT5cblxuICAvLyBDYXRjaC1hbGxcbiAgPFxuICAgIFN0YXRlID0gYW55LFxuICAgIFBhcmFtcyBleHRlbmRzIGFueVtdID0gW10sXG4gICAgRXhwb3J0cyBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4gPSBSZWNvcmQ8c3RyaW5nLCBuZXZlcj4sXG4gICAgU3RvcmVUeXBlIGV4dGVuZHMgU3RvcmU8U3RhdGU+ID0gU3RvcmU8U3RhdGU+LFxuICAgIFByb21pc2VUeXBlIGV4dGVuZHMgQXRvbUFwaVByb21pc2UgPSB1bmRlZmluZWRcbiAgPihcbiAgICBrZXk6IHN0cmluZyxcbiAgICB2YWx1ZTogQXRvbVZhbHVlT3JGYWN0b3J5PFN0YXRlLCBQYXJhbXMsIEV4cG9ydHMsIFN0b3JlVHlwZSwgUHJvbWlzZVR5cGU+LFxuICAgIGNvbmZpZz86IEF0b21Db25maWc8U3RhdGU+XG4gICk6IEF0b208U3RhdGUsIFBhcmFtcywgRXhwb3J0cywgU3RvcmVUeXBlLCBQcm9taXNlVHlwZT5cbn0gPSA8XG4gIFN0YXRlID0gYW55LFxuICBQYXJhbXMgZXh0ZW5kcyBhbnlbXSA9IFtdLFxuICBFeHBvcnRzIGV4dGVuZHMgUmVjb3JkPHN0cmluZywgYW55PiA9IFJlY29yZDxzdHJpbmcsIG5ldmVyPixcbiAgU3RvcmVUeXBlIGV4dGVuZHMgU3RvcmU8U3RhdGU+ID0gU3RvcmU8U3RhdGU+LFxuICBQcm9taXNlVHlwZSBleHRlbmRzIEF0b21BcGlQcm9taXNlID0gdW5kZWZpbmVkXG4+KFxuICBrZXk6IHN0cmluZyxcbiAgdmFsdWU6IEF0b21WYWx1ZU9yRmFjdG9yeTxTdGF0ZSwgUGFyYW1zLCBFeHBvcnRzLCBTdG9yZVR5cGUsIFByb21pc2VUeXBlPixcbiAgY29uZmlnPzogQXRvbUNvbmZpZzxTdGF0ZT5cbikgPT4ge1xuICBpZiAoREVWICYmICFrZXkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdaZWR1eDogQWxsIGF0b21zIG11c3QgaGF2ZSBhIGtleScpXG4gIH1cblxuICByZXR1cm4gbmV3IEF0b208U3RhdGUsIFBhcmFtcywgRXhwb3J0cywgU3RvcmVUeXBlLCBQcm9taXNlVHlwZT4oXG4gICAga2V5LFxuICAgIHZhbHVlLFxuICAgIGNvbmZpZ1xuICApXG59XG4iXSwibmFtZXMiOlsiQXRvbSIsImF0b20iLCJrZXkiLCJ2YWx1ZSIsImNvbmZpZyIsIkRFViIsIlR5cGVFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5965\n")},2662:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "q": function() { return /* binding */ createEcosystem; }\n/* harmony export */ });\n/* harmony import */ var _classes_Ecosystem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5092);\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(825);\nvar createEcosystem=function createEcosystem(config){var _config,_internalStore$setSta;if(config===void 0){config={};}if((_config=config)!=null&&_config.id){var _ecosystem=(0,_store__WEBPACK_IMPORTED_MODULE_0__/* .getEcosystem */ .$$)(config.id);if(_ecosystem)return _ecosystem;}var ecosystem=new _classes_Ecosystem__WEBPACK_IMPORTED_MODULE_1__/* .Ecosystem */ .q(config);// yep. Set this here. We\'ll make sure no component can ever be updated\n// synchronously from this call (causing update-during-render react warnings)\n_store__WEBPACK_IMPORTED_MODULE_0__/* .internalStore.setStateDeep */ .Do.setStateDeep((_internalStore$setSta={},_internalStore$setSta[ecosystem.id]=ecosystem,_internalStore$setSta));return ecosystem;};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjY2Mi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUlPLEdBQU1HLGdCQUFlLENBQUcsUUFBbEJBLGdCQUFlLENBRzFCQyxNQUFnQyxDQUM3QixzQ0FESEEsTUFBZ0MsV0FBaENBLE1BQWdDLENBQUcsQ0FBQyxDQUFDLEVBRXJDLFlBQUlBLE1BQU0sU0FBTixRQUFRQyxFQUFFLENBQUUsQ0FDZCxHQUFNQyxXQUFTLENBQUdMLDhEQUFZLENBQUNHLE1BQU0sQ0FBQ0MsRUFBRSxDQUFDLENBRXpDLEdBQUlDLFVBQVMsQ0FBRSxNQUFPQSxXQUFTLENBQ2pDLENBRUEsR0FBTUEsVUFBUyxDQUFHLEdBQUlOLENBQUFBLGtFQUFTLENBQVVJLE1BQU0sQ0FBQyxDQUVoRDtBQUNBO0FBQ0FGLHFGQUEwQixpREFBSUksU0FBUyxDQUFDRCxFQUFFLEVBQUdDLFNBQVMsd0JBQUcsQ0FFekQsTUFBT0EsVUFBUyxDQUNsQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9yZWFjdC9zcmMvZmFjdG9yaWVzL2NyZWF0ZUVjb3N5c3RlbS50cz8wODE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVjb3N5c3RlbSB9IGZyb20gJy4uL2NsYXNzZXMvRWNvc3lzdGVtJ1xuaW1wb3J0IHsgZ2V0RWNvc3lzdGVtLCBpbnRlcm5hbFN0b3JlIH0gZnJvbSAnLi4vc3RvcmUnXG5pbXBvcnQgeyBFY29zeXN0ZW1Db25maWcgfSBmcm9tICcuLi90eXBlcydcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUVjb3N5c3RlbSA9IDxcbiAgQ29udGV4dCBleHRlbmRzIFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQgPSBhbnlcbj4oXG4gIGNvbmZpZzogRWNvc3lzdGVtQ29uZmlnPENvbnRleHQ+ID0ge31cbikgPT4ge1xuICBpZiAoY29uZmlnPy5pZCkge1xuICAgIGNvbnN0IGVjb3N5c3RlbSA9IGdldEVjb3N5c3RlbShjb25maWcuaWQpXG5cbiAgICBpZiAoZWNvc3lzdGVtKSByZXR1cm4gZWNvc3lzdGVtXG4gIH1cblxuICBjb25zdCBlY29zeXN0ZW0gPSBuZXcgRWNvc3lzdGVtPENvbnRleHQ+KGNvbmZpZylcblxuICAvLyB5ZXAuIFNldCB0aGlzIGhlcmUuIFdlJ2xsIG1ha2Ugc3VyZSBubyBjb21wb25lbnQgY2FuIGV2ZXIgYmUgdXBkYXRlZFxuICAvLyBzeW5jaHJvbm91c2x5IGZyb20gdGhpcyBjYWxsIChjYXVzaW5nIHVwZGF0ZS1kdXJpbmctcmVuZGVyIHJlYWN0IHdhcm5pbmdzKVxuICBpbnRlcm5hbFN0b3JlLnNldFN0YXRlRGVlcCh7IFtlY29zeXN0ZW0uaWRdOiBlY29zeXN0ZW0gfSlcblxuICByZXR1cm4gZWNvc3lzdGVtXG59XG4iXSwibmFtZXMiOlsiRWNvc3lzdGVtIiwiZ2V0RWNvc3lzdGVtIiwiaW50ZXJuYWxTdG9yZSIsImNyZWF0ZUVjb3N5c3RlbSIsImNvbmZpZyIsImlkIiwiZWNvc3lzdGVtIiwic2V0U3RhdGVEZWVwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2662\n')},3870:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "v": function() { return /* binding */ createInjector; }\n/* harmony export */ });\n/* harmony import */ var _classes_EvaluationStack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2633);\nvar createInjector=function createInjector(operation,first,next){var type;var injector=function injector(){var _instance$_injectors,_instance$_nextInject2,_instance$_nextInject3;var instance=(0,_classes_EvaluationStack__WEBPACK_IMPORTED_MODULE_0__/* .readInstance */ .i)();for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}if(instance.activeState===\'Initializing\'){var _instance$_nextInject;var _descriptor=first.apply(void 0,[instance].concat(args));type=_descriptor.type;(_instance$_nextInject=instance._nextInjectors)==null?void 0:_instance$_nextInject.push(_descriptor);return _descriptor.result;}var prevDescriptor=(_instance$_injectors=instance._injectors)==null?void 0:_instance$_injectors[(_instance$_nextInject2=instance._nextInjectors)==null?void 0:_instance$_nextInject2.length];if( true&&(!prevDescriptor||prevDescriptor.type!==type)){throw new Error("Zedux: "+operation+" in atom \\""+instance.atom.key+"\\" - injectors cannot be added, removed, or reordered");}var descriptor=next?next.apply(void 0,[prevDescriptor,instance].concat(args)):prevDescriptor;(_instance$_nextInject3=instance._nextInjectors)==null?void 0:_instance$_nextInject3.push(descriptor);return descriptor.result;};return injector;};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzg3MC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBSU8sR0FBTUMsZUFBYyxDQUFHLFFBQWpCQSxlQUFjLENBSXpCQyxTQUFpQixDQUNqQkMsS0FBdUQsQ0FDdkRDLElBQTBFLENBQ3ZFLENBQ0gsR0FBSUMsS0FBWSxDQUVoQixHQUFNQyxTQUFRLENBQUcsUUFBWEEsU0FBUSxFQUFtQix3RUFDL0IsR0FBTUMsU0FBUSxDQUFHUCwrRUFBWSxFQUFFLCtCQURaUSxJQUFJLDBDQUFKQSxJQUFJLHdCQUd2QixHQUFJRCxRQUFRLENBQUNFLFdBQVcsR0FBSyxjQUFjLENBQUUsMkJBQzNDLEdBQU1DLFlBQVUsQ0FBR1AsS0FBSyxlQUFDSSxRQUFRLFNBQUtDLElBQUksRUFBQyxDQUMzQ0gsSUFBSSxDQUFHSyxXQUFVLENBQUNMLElBQUksQ0FDdEIsdUJBQUFFLFFBQVEsQ0FBQ0ksY0FBYyxlQUF2QixzQkFBeUJDLElBQUksQ0FBQ0YsV0FBVSxDQUFDLENBRXpDLE1BQU9BLFlBQVUsQ0FBQ0csTUFBTSxDQUMxQixDQUVBLEdBQU1DLGVBQWMsdUJBQUdQLFFBQVEsQ0FBQ1EsVUFBVSxlQUFuQiw2Q0FDckJSLFFBQVEsQ0FBQ0ksY0FBYyxlQUF2Qix1QkFBeUJLLE1BQU0sQ0FDM0IsQ0FFTixHQUFJQyxLQUFHLEdBQUssQ0FBQ0gsY0FBYyxFQUFJQSxjQUFjLENBQUNULElBQUksR0FBS0EsSUFBSSxDQUFDLENBQUUsQ0FDNUQsS0FBTSxJQUFJYSxNQUFLLFdBQ0hoQixTQUFTLGVBQWFLLFFBQVEsQ0FBQ1ksSUFBSSxDQUFDQyxHQUFHLHlEQUNsRCxDQUNILENBRUEsR0FBTVYsV0FBVSxDQUFHTixJQUFJLENBQ25CQSxJQUFJLGVBQUNVLGNBQWMsQ0FBRVAsUUFBUSxTQUFLQyxJQUFJLEVBQUMsQ0FDdkNNLGNBQWMsQ0FFbEIsd0JBQUFQLFFBQVEsQ0FBQ0ksY0FBYyxlQUF2Qix1QkFBeUJDLElBQUksQ0FBQ0YsVUFBVSxDQUFDLENBRXpDLE1BQU9BLFdBQVUsQ0FBQ0csTUFBTSxDQUMxQixDQUFDLENBRUQsTUFBT1AsU0FBUSxDQUNqQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9yZWFjdC9zcmMvZmFjdG9yaWVzL2NyZWF0ZUluamVjdG9yLnRzP2E5YTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVhZEluc3RhbmNlIH0gZnJvbSAnLi4vY2xhc3Nlcy9FdmFsdWF0aW9uU3RhY2snXG5pbXBvcnQgeyBQYXJ0aWFsQXRvbUluc3RhbmNlIH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBJbmplY3RvckRlc2NyaXB0b3IgfSBmcm9tICcuLi91dGlscy90eXBlcydcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUluamVjdG9yID0gPFxuICBBIGV4dGVuZHMgWy4uLmFueV0sXG4gIFQgZXh0ZW5kcyBJbmplY3RvckRlc2NyaXB0b3Jcbj4oXG4gIG9wZXJhdGlvbjogc3RyaW5nLFxuICBmaXJzdDogKGluc3RhbmNlOiBQYXJ0aWFsQXRvbUluc3RhbmNlLCAuLi5hcmdzOiBBKSA9PiBULFxuICBuZXh0PzogKHByZXZEZXNjcmlwdG9yOiBULCBpbnN0YW5jZTogUGFydGlhbEF0b21JbnN0YW5jZSwgLi4uYXJnczogQSkgPT4gVFxuKSA9PiB7XG4gIGxldCB0eXBlOiBzdHJpbmdcblxuICBjb25zdCBpbmplY3RvciA9ICguLi5hcmdzOiBBKSA9PiB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSByZWFkSW5zdGFuY2UoKVxuXG4gICAgaWYgKGluc3RhbmNlLmFjdGl2ZVN0YXRlID09PSAnSW5pdGlhbGl6aW5nJykge1xuICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGZpcnN0KGluc3RhbmNlLCAuLi5hcmdzKVxuICAgICAgdHlwZSA9IGRlc2NyaXB0b3IudHlwZVxuICAgICAgaW5zdGFuY2UuX25leHRJbmplY3RvcnM/LnB1c2goZGVzY3JpcHRvcilcblxuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IucmVzdWx0XG4gICAgfVxuXG4gICAgY29uc3QgcHJldkRlc2NyaXB0b3IgPSBpbnN0YW5jZS5faW5qZWN0b3JzPy5bXG4gICAgICBpbnN0YW5jZS5fbmV4dEluamVjdG9ycz8ubGVuZ3RoIGFzIG51bWJlclxuICAgIF0gYXMgVFxuXG4gICAgaWYgKERFViAmJiAoIXByZXZEZXNjcmlwdG9yIHx8IHByZXZEZXNjcmlwdG9yLnR5cGUgIT09IHR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBaZWR1eDogJHtvcGVyYXRpb259IGluIGF0b20gXCIke2luc3RhbmNlLmF0b20ua2V5fVwiIC0gaW5qZWN0b3JzIGNhbm5vdCBiZSBhZGRlZCwgcmVtb3ZlZCwgb3IgcmVvcmRlcmVkYFxuICAgICAgKVxuICAgIH1cblxuICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBuZXh0XG4gICAgICA/IG5leHQocHJldkRlc2NyaXB0b3IsIGluc3RhbmNlLCAuLi5hcmdzKVxuICAgICAgOiBwcmV2RGVzY3JpcHRvclxuXG4gICAgaW5zdGFuY2UuX25leHRJbmplY3RvcnM/LnB1c2goZGVzY3JpcHRvcilcblxuICAgIHJldHVybiBkZXNjcmlwdG9yLnJlc3VsdFxuICB9XG5cbiAgcmV0dXJuIGluamVjdG9yXG59XG4iXSwibmFtZXMiOlsicmVhZEluc3RhbmNlIiwiY3JlYXRlSW5qZWN0b3IiLCJvcGVyYXRpb24iLCJmaXJzdCIsIm5leHQiLCJ0eXBlIiwiaW5qZWN0b3IiLCJpbnN0YW5jZSIsImFyZ3MiLCJhY3RpdmVTdGF0ZSIsImRlc2NyaXB0b3IiLCJfbmV4dEluamVjdG9ycyIsInB1c2giLCJyZXN1bHQiLCJwcmV2RGVzY3JpcHRvciIsIl9pbmplY3RvcnMiLCJsZW5ndGgiLCJERVYiLCJFcnJvciIsImF0b20iLCJrZXkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3870\n')},4538:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Q\": function() { return /* binding */ useAtomInstance; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7294);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(395);\n/* harmony import */ var _useEcosystem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6215);\n/* harmony import */ var _useReactComponentId__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6559);\nvar OPERATION='useAtomInstance';/**\n * useAtomInstance\n *\n * Creates an atom instance for the passed atom based on the passed params. If\n * an instance has already been created for the passed params, reuses the\n * existing instance.\n *\n * Registers a static graph dependency on the atom instance. This means\n * components that use this hook will not rerender when this atom instance's\n * state changes.\n *\n * If the params are large, serializing them every render can cause some\n * overhead.\n *\n * @param atom The atom to instantiate or reuse an instantiation of\n * @param params The params for generating the instance's key.\n */var useAtomInstance=function useAtomInstance(atom,params,_temp){var _ref=_temp===void 0?{operation:OPERATION}:_temp,_ref$operation=_ref.operation,operation=_ref$operation===void 0?OPERATION:_ref$operation,subscribe=_ref.subscribe,suspend=_ref.suspend;var ecosystem=(0,_useEcosystem__WEBPACK_IMPORTED_MODULE_1__/* .useEcosystem */ .l)();var dependentKey=(0,_useReactComponentId__WEBPACK_IMPORTED_MODULE_2__/* .useReactComponentId */ .$)();// it should be fine for this to run every render. It's possible to change\n// approaches if it is too heavy sometimes. But don't memoize this call:\nvar instance=ecosystem.getInstance(atom,params);var _useMemo=(0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function(){var tuple=[instance,instance.getState()];return[function(onStoreChange){var _ecosystem$_graph$nod;// this function must be idempotent\nif(!((_ecosystem$_graph$nod=ecosystem._graph.nodes[instance.keyHash])!=null&&_ecosystem$_graph$nod.dependents[dependentKey])){// React can unmount other components before calling this subscribe\n// function but after we got the instance above. Re-get the instance\n// if such unmountings destroyed it in the meantime:\nif(instance.activeState==='Destroyed'){tuple[1]=_utils__WEBPACK_IMPORTED_MODULE_3__/* .destroyed */ .lv;onStoreChange();return function(){};// let the next render register the graph edge\n}ecosystem._graph.addEdge(dependentKey,instance.keyHash,operation,_utils__WEBPACK_IMPORTED_MODULE_3__/* .External */ .RQ|(subscribe?0:_utils__WEBPACK_IMPORTED_MODULE_3__/* .Static */ .qG),function(signal){// returning a unique symbol from `getSnapshot` after we call\n// `onStoreChange` causes the component to rerender. On rerender,\n// instance will be set again, so `useSyncExternalStore` will\n// never actually return that symbol.\nif(signal==='Destroyed')tuple[1]=_utils__WEBPACK_IMPORTED_MODULE_3__/* .destroyed */ .lv;onStoreChange();});}return function(){ecosystem._graph.removeEdge(dependentKey,instance.keyHash);};},// this getSnapshot has to return a different val if either the instance\n// or the state change (since in the case of primitive values, the new\n// instance's state could be exactly the same (===) as the previous\n// instance's value)\nfunction(){// This hack should work 'cause React can't use the return value unless\n// it renders this component. And when it rerenders,\n// `tuple[1]` will get defined again before this point\nif(tuple[1]===_utils__WEBPACK_IMPORTED_MODULE_3__/* .destroyed */ .lv)return _utils__WEBPACK_IMPORTED_MODULE_3__/* .destroyed */ .lv;if(suspend!==false){if(tuple[0]._promiseStatus==='loading'){throw tuple[0].promise;}else if(tuple[0]._promiseStatus==='error'){throw tuple[0]._promiseError;}}if(!subscribe)return tuple;var state=tuple[0].getState();if(state===tuple[1])return tuple;return tuple=[tuple[0],state];}];},[instance,subscribe,suspend]),subscribeFn=_useMemo[0],getSnapshot=_useMemo[1];return (0,react__WEBPACK_IMPORTED_MODULE_0__.useSyncExternalStore)(subscribeFn,getSnapshot,getSnapshot)[0];};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxNQUFRQSxNQUFLLENBQUcsQ0FBQ0EsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFFYyxLQUFLLENBQUMsQ0FDbkMsQ0FBQyxDQUNGLENBQ0gsQ0FBQyxDQUFFLENBQUNoQixRQUFRLENBQUVKLFNBQVMsQ0FBRUMsT0FBTyxDQUFDLENBQUMsQ0FuRTNCb0IsV0FBVyxhQUFFQyxXQUFXLGFBcUUvQixNQUFPakMsQ0FBQUEsMkRBQW9CLENBQUNnQyxXQUFXLENBQUVDLFdBQVcsQ0FBRUEsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQ3ZFLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9ob29rcy91c2VBdG9tSW5zdGFuY2UudHM/NTRjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VNZW1vLCB1c2VTeW5jRXh0ZXJuYWxTdG9yZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgQXRvbUJhc2UsIEF0b21JbnN0YW5jZSwgQXRvbUluc3RhbmNlQmFzZSB9IGZyb20gJy4uL2NsYXNzZXMnXG5pbXBvcnQgeyBBdG9tSW5zdGFuY2VUeXBlLCBBdG9tUGFyYW1zVHlwZSwgWmVkdXhIb29rQ29uZmlnIH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBkZXN0cm95ZWQsIEV4dGVybmFsLCBTdGF0aWMgfSBmcm9tICcuLi91dGlscydcbmltcG9ydCB7IHVzZUVjb3N5c3RlbSB9IGZyb20gJy4vdXNlRWNvc3lzdGVtJ1xuaW1wb3J0IHsgdXNlUmVhY3RDb21wb25lbnRJZCB9IGZyb20gJy4vdXNlUmVhY3RDb21wb25lbnRJZCdcblxuY29uc3QgT1BFUkFUSU9OID0gJ3VzZUF0b21JbnN0YW5jZSdcblxuLyoqXG4gKiB1c2VBdG9tSW5zdGFuY2VcbiAqXG4gKiBDcmVhdGVzIGFuIGF0b20gaW5zdGFuY2UgZm9yIHRoZSBwYXNzZWQgYXRvbSBiYXNlZCBvbiB0aGUgcGFzc2VkIHBhcmFtcy4gSWZcbiAqIGFuIGluc3RhbmNlIGhhcyBhbHJlYWR5IGJlZW4gY3JlYXRlZCBmb3IgdGhlIHBhc3NlZCBwYXJhbXMsIHJldXNlcyB0aGVcbiAqIGV4aXN0aW5nIGluc3RhbmNlLlxuICpcbiAqIFJlZ2lzdGVycyBhIHN0YXRpYyBncmFwaCBkZXBlbmRlbmN5IG9uIHRoZSBhdG9tIGluc3RhbmNlLiBUaGlzIG1lYW5zXG4gKiBjb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9vayB3aWxsIG5vdCByZXJlbmRlciB3aGVuIHRoaXMgYXRvbSBpbnN0YW5jZSdzXG4gKiBzdGF0ZSBjaGFuZ2VzLlxuICpcbiAqIElmIHRoZSBwYXJhbXMgYXJlIGxhcmdlLCBzZXJpYWxpemluZyB0aGVtIGV2ZXJ5IHJlbmRlciBjYW4gY2F1c2Ugc29tZVxuICogb3ZlcmhlYWQuXG4gKlxuICogQHBhcmFtIGF0b20gVGhlIGF0b20gdG8gaW5zdGFudGlhdGUgb3IgcmV1c2UgYW4gaW5zdGFudGlhdGlvbiBvZlxuICogQHBhcmFtIHBhcmFtcyBUaGUgcGFyYW1zIGZvciBnZW5lcmF0aW5nIHRoZSBpbnN0YW5jZSdzIGtleS5cbiAqL1xuZXhwb3J0IGNvbnN0IHVzZUF0b21JbnN0YW5jZToge1xuICA8QSBleHRlbmRzIEF0b21CYXNlPGFueSwgW10sIGFueSwgYW55LCBhbnksIGFueT4+KFxuICAgIGF0b206IEFcbiAgKTogQXRvbUluc3RhbmNlVHlwZTxBPlxuXG4gIDxBIGV4dGVuZHMgQXRvbUJhc2U8YW55LCBbLi4uYW55XSwgYW55LCBhbnksIGFueSwgYW55Pj4oXG4gICAgYXRvbTogQSxcbiAgICBwYXJhbXM6IEF0b21QYXJhbXNUeXBlPEE+LFxuICAgIGNvbmZpZz86IFplZHV4SG9va0NvbmZpZ1xuICApOiBBdG9tSW5zdGFuY2VUeXBlPEE+XG5cbiAgPEFJIGV4dGVuZHMgQXRvbUluc3RhbmNlPGFueSwgWy4uLmFueV0sIGFueSwgYW55LCBhbnk+PihcbiAgICBpbnN0YW5jZTogQUksXG4gICAgcGFyYW1zPzogW10sXG4gICAgY29uZmlnPzogWmVkdXhIb29rQ29uZmlnXG4gICk6IEFJXG59ID0gPEEgZXh0ZW5kcyBBdG9tQmFzZTxhbnksIFsuLi5hbnldLCBhbnksIGFueSwgYW55LCBhbnk+PihcbiAgYXRvbTogQSB8IEF0b21JbnN0YW5jZUJhc2U8YW55LCBbLi4uYW55XSwgYW55PixcbiAgcGFyYW1zPzogQXRvbVBhcmFtc1R5cGU8QT4sXG4gIHsgb3BlcmF0aW9uID0gT1BFUkFUSU9OLCBzdWJzY3JpYmUsIHN1c3BlbmQgfTogWmVkdXhIb29rQ29uZmlnID0ge1xuICAgIG9wZXJhdGlvbjogT1BFUkFUSU9OLFxuICB9XG4pID0+IHtcbiAgY29uc3QgZWNvc3lzdGVtID0gdXNlRWNvc3lzdGVtKClcbiAgY29uc3QgZGVwZW5kZW50S2V5ID0gdXNlUmVhY3RDb21wb25lbnRJZCgpXG5cbiAgLy8gaXQgc2hvdWxkIGJlIGZpbmUgZm9yIHRoaXMgdG8gcnVuIGV2ZXJ5IHJlbmRlci4gSXQncyBwb3NzaWJsZSB0byBjaGFuZ2VcbiAgLy8gYXBwcm9hY2hlcyBpZiBpdCBpcyB0b28gaGVhdnkgc29tZXRpbWVzLiBCdXQgZG9uJ3QgbWVtb2l6ZSB0aGlzIGNhbGw6XG4gIGNvbnN0IGluc3RhbmNlID0gZWNvc3lzdGVtLmdldEluc3RhbmNlKGF0b20gYXMgQSwgcGFyYW1zIGFzIEF0b21QYXJhbXNUeXBlPEE+KVxuXG4gIGNvbnN0IFtzdWJzY3JpYmVGbiwgZ2V0U25hcHNob3RdID0gdXNlTWVtbygoKSA9PiB7XG4gICAgbGV0IHR1cGxlID0gW2luc3RhbmNlLCBpbnN0YW5jZS5nZXRTdGF0ZSgpXVxuXG4gICAgcmV0dXJuIFtcbiAgICAgIChvblN0b3JlQ2hhbmdlOiAoKSA9PiB2b2lkKSA9PiB7XG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBpZGVtcG90ZW50XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhZWNvc3lzdGVtLl9ncmFwaC5ub2Rlc1tpbnN0YW5jZS5rZXlIYXNoXT8uZGVwZW5kZW50c1tkZXBlbmRlbnRLZXldXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIFJlYWN0IGNhbiB1bm1vdW50IG90aGVyIGNvbXBvbmVudHMgYmVmb3JlIGNhbGxpbmcgdGhpcyBzdWJzY3JpYmVcbiAgICAgICAgICAvLyBmdW5jdGlvbiBidXQgYWZ0ZXIgd2UgZ290IHRoZSBpbnN0YW5jZSBhYm92ZS4gUmUtZ2V0IHRoZSBpbnN0YW5jZVxuICAgICAgICAgIC8vIGlmIHN1Y2ggdW5tb3VudGluZ3MgZGVzdHJveWVkIGl0IGluIHRoZSBtZWFudGltZTpcbiAgICAgICAgICBpZiAoaW5zdGFuY2UuYWN0aXZlU3RhdGUgPT09ICdEZXN0cm95ZWQnKSB7XG4gICAgICAgICAgICB0dXBsZVsxXSA9IGRlc3Ryb3llZFxuICAgICAgICAgICAgb25TdG9yZUNoYW5nZSgpXG5cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7fSAvLyBsZXQgdGhlIG5leHQgcmVuZGVyIHJlZ2lzdGVyIHRoZSBncmFwaCBlZGdlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWNvc3lzdGVtLl9ncmFwaC5hZGRFZGdlKFxuICAgICAgICAgICAgZGVwZW5kZW50S2V5LFxuICAgICAgICAgICAgaW5zdGFuY2Uua2V5SGFzaCxcbiAgICAgICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgICAgIEV4dGVybmFsIHwgKHN1YnNjcmliZSA/IDAgOiBTdGF0aWMpLFxuICAgICAgICAgICAgc2lnbmFsID0+IHtcbiAgICAgICAgICAgICAgLy8gcmV0dXJuaW5nIGEgdW5pcXVlIHN5bWJvbCBmcm9tIGBnZXRTbmFwc2hvdGAgYWZ0ZXIgd2UgY2FsbFxuICAgICAgICAgICAgICAvLyBgb25TdG9yZUNoYW5nZWAgY2F1c2VzIHRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXIuIE9uIHJlcmVuZGVyLFxuICAgICAgICAgICAgICAvLyBpbnN0YW5jZSB3aWxsIGJlIHNldCBhZ2Fpbiwgc28gYHVzZVN5bmNFeHRlcm5hbFN0b3JlYCB3aWxsXG4gICAgICAgICAgICAgIC8vIG5ldmVyIGFjdHVhbGx5IHJldHVybiB0aGF0IHN5bWJvbC5cbiAgICAgICAgICAgICAgaWYgKHNpZ25hbCA9PT0gJ0Rlc3Ryb3llZCcpIHR1cGxlWzFdID0gZGVzdHJveWVkXG5cbiAgICAgICAgICAgICAgb25TdG9yZUNoYW5nZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICBlY29zeXN0ZW0uX2dyYXBoLnJlbW92ZUVkZ2UoZGVwZW5kZW50S2V5LCBpbnN0YW5jZS5rZXlIYXNoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gdGhpcyBnZXRTbmFwc2hvdCBoYXMgdG8gcmV0dXJuIGEgZGlmZmVyZW50IHZhbCBpZiBlaXRoZXIgdGhlIGluc3RhbmNlXG4gICAgICAvLyBvciB0aGUgc3RhdGUgY2hhbmdlIChzaW5jZSBpbiB0aGUgY2FzZSBvZiBwcmltaXRpdmUgdmFsdWVzLCB0aGUgbmV3XG4gICAgICAvLyBpbnN0YW5jZSdzIHN0YXRlIGNvdWxkIGJlIGV4YWN0bHkgdGhlIHNhbWUgKD09PSkgYXMgdGhlIHByZXZpb3VzXG4gICAgICAvLyBpbnN0YW5jZSdzIHZhbHVlKVxuICAgICAgKCkgPT4ge1xuICAgICAgICAvLyBUaGlzIGhhY2sgc2hvdWxkIHdvcmsgJ2NhdXNlIFJlYWN0IGNhbid0IHVzZSB0aGUgcmV0dXJuIHZhbHVlIHVubGVzc1xuICAgICAgICAvLyBpdCByZW5kZXJzIHRoaXMgY29tcG9uZW50LiBBbmQgd2hlbiBpdCByZXJlbmRlcnMsXG4gICAgICAgIC8vIGB0dXBsZVsxXWAgd2lsbCBnZXQgZGVmaW5lZCBhZ2FpbiBiZWZvcmUgdGhpcyBwb2ludFxuICAgICAgICBpZiAodHVwbGVbMV0gPT09IGRlc3Ryb3llZCkgcmV0dXJuIGRlc3Ryb3llZCBhcyBhbnlcblxuICAgICAgICBpZiAoc3VzcGVuZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAodHVwbGVbMF0uX3Byb21pc2VTdGF0dXMgPT09ICdsb2FkaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgdHVwbGVbMF0ucHJvbWlzZVxuICAgICAgICAgIH0gZWxzZSBpZiAodHVwbGVbMF0uX3Byb21pc2VTdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IHR1cGxlWzBdLl9wcm9taXNlRXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN1YnNjcmliZSkgcmV0dXJuIHR1cGxlXG5cbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0dXBsZVswXS5nZXRTdGF0ZSgpXG5cbiAgICAgICAgaWYgKHN0YXRlID09PSB0dXBsZVsxXSkgcmV0dXJuIHR1cGxlXG5cbiAgICAgICAgcmV0dXJuICh0dXBsZSA9IFt0dXBsZVswXSwgc3RhdGVdKVxuICAgICAgfSxcbiAgICBdXG4gIH0sIFtpbnN0YW5jZSwgc3Vic2NyaWJlLCBzdXNwZW5kXSlcblxuICByZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlRm4sIGdldFNuYXBzaG90LCBnZXRTbmFwc2hvdClbMF1cbn1cbiJdLCJuYW1lcyI6WyJ1c2VNZW1vIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJkZXN0cm95ZWQiLCJFeHRlcm5hbCIsIlN0YXRpYyIsInVzZUVjb3N5c3RlbSIsInVzZVJlYWN0Q29tcG9uZW50SWQiLCJPUEVSQVRJT04iLCJ1c2VBdG9tSW5zdGFuY2UiLCJhdG9tIiwicGFyYW1zIiwib3BlcmF0aW9uIiwic3Vic2NyaWJlIiwic3VzcGVuZCIsImVjb3N5c3RlbSIsImRlcGVuZGVudEtleSIsImluc3RhbmNlIiwiZ2V0SW5zdGFuY2UiLCJ0dXBsZSIsImdldFN0YXRlIiwib25TdG9yZUNoYW5nZSIsIl9ncmFwaCIsIm5vZGVzIiwia2V5SGFzaCIsImRlcGVuZGVudHMiLCJhY3RpdmVTdGF0ZSIsImFkZEVkZ2UiLCJzaWduYWwiLCJyZW1vdmVFZGdlIiwiX3Byb21pc2VTdGF0dXMiLCJwcm9taXNlIiwiX3Byb21pc2VFcnJvciIsInN0YXRlIiwic3Vic2NyaWJlRm4iLCJnZXRTbmFwc2hvdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4538\n")},6215:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "l": function() { return /* binding */ useEcosystem; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7294);\n/* harmony import */ var _factories_createEcosystem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2662);\n/* harmony import */ var _store__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(825);\n/* harmony import */ var _utils_general__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(395);\nvar useEcosystem=function useEcosystem(){var id=(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(_utils_general__WEBPACK_IMPORTED_MODULE_1__/* .ecosystemContext */ .zs);return (0,_store__WEBPACK_IMPORTED_MODULE_2__/* .getEcosystem */ .$$)(id)||(0,_factories_createEcosystem__WEBPACK_IMPORTED_MODULE_3__/* .createEcosystem */ .q)({id:id});};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIxNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBS08sR0FBTUksYUFBWSxDQUFHLFFBQWZBLGFBQVksRUFBUyxDQUNoQyxHQUFNQyxHQUFFLENBQUdMLGlEQUFVLENBQUNHLHNFQUFnQixDQUFDLENBRXZDLE1BQU9ELENBQUFBLDhEQUFZLENBQUNHLEVBQUUsQ0FBQyxFQUFJSixvRkFBZSxDQUFDLENBQUVJLEVBQUUsQ0FBRkEsRUFBRyxDQUFDLENBQUMsQ0FDcEQsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL2hvb2tzL3VzZUVjb3N5c3RlbS50cz81YjcyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGNyZWF0ZUVjb3N5c3RlbSB9IGZyb20gJy4uL2ZhY3Rvcmllcy9jcmVhdGVFY29zeXN0ZW0nXG5pbXBvcnQgeyBnZXRFY29zeXN0ZW0gfSBmcm9tICcuLi9zdG9yZSdcbmltcG9ydCB7IGVjb3N5c3RlbUNvbnRleHQgfSBmcm9tICcuLi91dGlscy9nZW5lcmFsJ1xuXG5leHBvcnQgY29uc3QgdXNlRWNvc3lzdGVtID0gKCkgPT4ge1xuICBjb25zdCBpZCA9IHVzZUNvbnRleHQoZWNvc3lzdGVtQ29udGV4dClcblxuICByZXR1cm4gZ2V0RWNvc3lzdGVtKGlkKSB8fCBjcmVhdGVFY29zeXN0ZW0oeyBpZCB9KVxufVxuIl0sIm5hbWVzIjpbInVzZUNvbnRleHQiLCJjcmVhdGVFY29zeXN0ZW0iLCJnZXRFY29zeXN0ZW0iLCJlY29zeXN0ZW1Db250ZXh0IiwidXNlRWNvc3lzdGVtIiwiaWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6215\n')},6559:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"$\": function() { return /* binding */ useReactComponentId; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7294);\n/* harmony import */ var _useEcosystem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6215);\n/**\n * Get a unique id for a Zedux hook call. The exact string doesn't really\n * matter, but in dev try to use an error stack to grab the React component's\n * actual name for a better debugging experience\n */var useReactComponentId=function useReactComponentId(){var ecosystem=(0,_useEcosystem__WEBPACK_IMPORTED_MODULE_1__/* .useEcosystem */ .l)();// would be nice if React provided some way to know that multiple hooks are\n// from the same component. For now, every Zedux hook usage creates a new\n// graph node\nreturn (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function(){return ecosystem._idGenerator.generateReactComponentId();},[ecosystem]);};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjU1OS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FDTyxHQUFNRSxvQkFBbUIsQ0FBRyxRQUF0QkEsb0JBQW1CLEVBQVMsQ0FDdkMsR0FBTUMsVUFBUyxDQUFHRixvRUFBWSxFQUFFLENBRWhDO0FBQ0E7QUFDQTtBQUNBLE1BQU9ELENBQUFBLDhDQUFPLENBQUMsaUJBQU1HLFVBQVMsQ0FBQ0MsWUFBWSxDQUFDQyx3QkFBd0IsRUFBRSxHQUFFLENBQ3RFRixTQUFTLENBQ1YsQ0FBQyxDQUNKLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy9ob29rcy91c2VSZWFjdENvbXBvbmVudElkLnRzPzFiMjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgdXNlRWNvc3lzdGVtIH0gZnJvbSAnLi91c2VFY29zeXN0ZW0nXG5cbi8qKlxuICogR2V0IGEgdW5pcXVlIGlkIGZvciBhIFplZHV4IGhvb2sgY2FsbC4gVGhlIGV4YWN0IHN0cmluZyBkb2Vzbid0IHJlYWxseVxuICogbWF0dGVyLCBidXQgaW4gZGV2IHRyeSB0byB1c2UgYW4gZXJyb3Igc3RhY2sgdG8gZ3JhYiB0aGUgUmVhY3QgY29tcG9uZW50J3NcbiAqIGFjdHVhbCBuYW1lIGZvciBhIGJldHRlciBkZWJ1Z2dpbmcgZXhwZXJpZW5jZVxuICovXG5leHBvcnQgY29uc3QgdXNlUmVhY3RDb21wb25lbnRJZCA9ICgpID0+IHtcbiAgY29uc3QgZWNvc3lzdGVtID0gdXNlRWNvc3lzdGVtKClcblxuICAvLyB3b3VsZCBiZSBuaWNlIGlmIFJlYWN0IHByb3ZpZGVkIHNvbWUgd2F5IHRvIGtub3cgdGhhdCBtdWx0aXBsZSBob29rcyBhcmVcbiAgLy8gZnJvbSB0aGUgc2FtZSBjb21wb25lbnQuIEZvciBub3csIGV2ZXJ5IFplZHV4IGhvb2sgdXNhZ2UgY3JlYXRlcyBhIG5ld1xuICAvLyBncmFwaCBub2RlXG4gIHJldHVybiB1c2VNZW1vKCgpID0+IGVjb3N5c3RlbS5faWRHZW5lcmF0b3IuZ2VuZXJhdGVSZWFjdENvbXBvbmVudElkKCksIFtcbiAgICBlY29zeXN0ZW0sXG4gIF0pXG59XG4iXSwibmFtZXMiOlsidXNlTWVtbyIsInVzZUVjb3N5c3RlbSIsInVzZVJlYWN0Q29tcG9uZW50SWQiLCJlY29zeXN0ZW0iLCJfaWRHZW5lcmF0b3IiLCJnZW5lcmF0ZVJlYWN0Q29tcG9uZW50SWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6559\n")},8723:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"o\": function() { return /* binding */ injectEffect; }\n/* harmony export */ });\n/* harmony import */ var _factories__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3870);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(395);\nvar getTask=function getTask(effect,descriptor){var task=function task(){var cleanup=effect();// now that the task has run, there's no need for the scheduler cleanup\n// function; replace it with the cleanup logic returned from the effect\n// (if any). If a promise was returned, ignore it.\ndescriptor.cleanup=typeof cleanup==='function'?cleanup:undefined;};return task;};/**\n * Runs a deferred side effect. This is just like React's `useEffect`. When\n * `deps` change on a subsequent reevaluation, the previous effect will be\n * cleaned up and the effect will rerun.\n *\n * Return a cleanup function to clean up resources when the effect reruns or the\n * current atom instance is destroyed.\n *\n * Unlike `useEffect`, you can return a promise from `injectEffect` (e.g. by\n * passing an async function). This is only for convenience in cases where you\n * don't have anything to cleanup, as you'll be unable to clean up resources if\n * you return a promise.\n */var injectEffect=(0,_factories__WEBPACK_IMPORTED_MODULE_0__/* .createInjector */ .v)('injectEffect',function(instance,effect,deps,config){var descriptor={deps:deps,type:_utils__WEBPACK_IMPORTED_MODULE_1__/* .prefix */ .O4+\"/effect\"};if(!instance.ecosystem.ssr){var task=getTask(effect,descriptor);descriptor.cleanup=function(){instance.ecosystem._scheduler.unschedule(task);descriptor.cleanup=undefined;};if(config!=null&&config.synchronous){task();}else{instance.ecosystem._scheduler.schedule({task:task,type:4// RunEffect (4)\n});}}return descriptor;},function(prevDescriptor,instance,effect,deps,config){if(instance.ecosystem.ssr)return prevDescriptor;var depsHaveChanged=(0,_utils__WEBPACK_IMPORTED_MODULE_1__/* .haveDepsChanged */ .EM)(prevDescriptor==null?void 0:prevDescriptor.deps,deps);if(!depsHaveChanged)return prevDescriptor;prevDescriptor.cleanup==null?void 0:prevDescriptor.cleanup();var task=getTask(effect,prevDescriptor);// this cleanup should be unnecessary since effects run immediately every\n// time except init. Leave this though in case we add a way to update an\n// atom instance without flushing the scheduler\nprevDescriptor.cleanup=function(){instance.ecosystem._scheduler.unschedule(task);prevDescriptor.cleanup=undefined;};prevDescriptor.deps=deps;if(config!=null&&config.synchronous){task();}else{instance.ecosystem._scheduler.schedule({task:task,type:4// RunEffect (4)\n});}return prevDescriptor;});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ly4uL3BhY2thZ2VzL3JlYWN0L3NyYy9pbmplY3RvcnMvaW5qZWN0RWZmZWN0LnRzP2U5MTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlSW5qZWN0b3IgfSBmcm9tICcuLi9mYWN0b3JpZXMnXG5pbXBvcnQgeyBFZmZlY3RDYWxsYmFjaywgSW5qZWN0b3JEZXBzIH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBoYXZlRGVwc0NoYW5nZWQsIEluamVjdG9yRGVzY3JpcHRvciwgcHJlZml4IH0gZnJvbSAnLi4vdXRpbHMnXG5cbmludGVyZmFjZSBFZmZlY3RJbmplY3RvckRlc2NyaXB0b3IgZXh0ZW5kcyBJbmplY3RvckRlc2NyaXB0b3I8dW5kZWZpbmVkPiB7XG4gIGRlcHM6IEluamVjdG9yRGVwc1xufVxuXG5jb25zdCBnZXRUYXNrID0gKFxuICBlZmZlY3Q6IEVmZmVjdENhbGxiYWNrLFxuICBkZXNjcmlwdG9yOiBFZmZlY3RJbmplY3RvckRlc2NyaXB0b3JcbikgPT4ge1xuICBjb25zdCB0YXNrID0gKCkgPT4ge1xuICAgIGNvbnN0IGNsZWFudXAgPSBlZmZlY3QoKVxuXG4gICAgLy8gbm93IHRoYXQgdGhlIHRhc2sgaGFzIHJ1biwgdGhlcmUncyBubyBuZWVkIGZvciB0aGUgc2NoZWR1bGVyIGNsZWFudXBcbiAgICAvLyBmdW5jdGlvbjsgcmVwbGFjZSBpdCB3aXRoIHRoZSBjbGVhbnVwIGxvZ2ljIHJldHVybmVkIGZyb20gdGhlIGVmZmVjdFxuICAgIC8vIChpZiBhbnkpLiBJZiBhIHByb21pc2Ugd2FzIHJldHVybmVkLCBpZ25vcmUgaXQuXG4gICAgZGVzY3JpcHRvci5jbGVhbnVwID0gdHlwZW9mIGNsZWFudXAgPT09ICdmdW5jdGlvbicgPyBjbGVhbnVwIDogdW5kZWZpbmVkXG4gIH1cblxuICByZXR1cm4gdGFza1xufVxuXG4vKipcbiAqIFJ1bnMgYSBkZWZlcnJlZCBzaWRlIGVmZmVjdC4gVGhpcyBpcyBqdXN0IGxpa2UgUmVhY3QncyBgdXNlRWZmZWN0YC4gV2hlblxuICogYGRlcHNgIGNoYW5nZSBvbiBhIHN1YnNlcXVlbnQgcmVldmFsdWF0aW9uLCB0aGUgcHJldmlvdXMgZWZmZWN0IHdpbGwgYmVcbiAqIGNsZWFuZWQgdXAgYW5kIHRoZSBlZmZlY3Qgd2lsbCByZXJ1bi5cbiAqXG4gKiBSZXR1cm4gYSBjbGVhbnVwIGZ1bmN0aW9uIHRvIGNsZWFuIHVwIHJlc291cmNlcyB3aGVuIHRoZSBlZmZlY3QgcmVydW5zIG9yIHRoZVxuICogY3VycmVudCBhdG9tIGluc3RhbmNlIGlzIGRlc3Ryb3llZC5cbiAqXG4gKiBVbmxpa2UgYHVzZUVmZmVjdGAsIHlvdSBjYW4gcmV0dXJuIGEgcHJvbWlzZSBmcm9tIGBpbmplY3RFZmZlY3RgIChlLmcuIGJ5XG4gKiBwYXNzaW5nIGFuIGFzeW5jIGZ1bmN0aW9uKS4gVGhpcyBpcyBvbmx5IGZvciBjb252ZW5pZW5jZSBpbiBjYXNlcyB3aGVyZSB5b3VcbiAqIGRvbid0IGhhdmUgYW55dGhpbmcgdG8gY2xlYW51cCwgYXMgeW91J2xsIGJlIHVuYWJsZSB0byBjbGVhbiB1cCByZXNvdXJjZXMgaWZcbiAqIHlvdSByZXR1cm4gYSBwcm9taXNlLlxuICovXG5leHBvcnQgY29uc3QgaW5qZWN0RWZmZWN0ID0gY3JlYXRlSW5qZWN0b3IoXG4gICdpbmplY3RFZmZlY3QnLFxuICAoXG4gICAgaW5zdGFuY2UsXG4gICAgZWZmZWN0OiBFZmZlY3RDYWxsYmFjayxcbiAgICBkZXBzPzogSW5qZWN0b3JEZXBzLFxuICAgIGNvbmZpZz86IHsgc3luY2hyb25vdXM/OiBib29sZWFuIH1cbiAgKSA9PiB7XG4gICAgY29uc3QgZGVzY3JpcHRvcjogRWZmZWN0SW5qZWN0b3JEZXNjcmlwdG9yID0ge1xuICAgICAgZGVwcyxcbiAgICAgIHR5cGU6IGAke3ByZWZpeH0vZWZmZWN0YCxcbiAgICB9XG5cbiAgICBpZiAoIWluc3RhbmNlLmVjb3N5c3RlbS5zc3IpIHtcbiAgICAgIGNvbnN0IHRhc2sgPSBnZXRUYXNrKGVmZmVjdCwgZGVzY3JpcHRvcilcbiAgICAgIGRlc2NyaXB0b3IuY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgaW5zdGFuY2UuZWNvc3lzdGVtLl9zY2hlZHVsZXIudW5zY2hlZHVsZSh0YXNrKVxuICAgICAgICBkZXNjcmlwdG9yLmNsZWFudXAgPSB1bmRlZmluZWRcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZz8uc3luY2hyb25vdXMpIHtcbiAgICAgICAgdGFzaygpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0YW5jZS5lY29zeXN0ZW0uX3NjaGVkdWxlci5zY2hlZHVsZSh7XG4gICAgICAgICAgdGFzayxcbiAgICAgICAgICB0eXBlOiA0LCAvLyBSdW5FZmZlY3QgKDQpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc2NyaXB0b3JcbiAgfSxcbiAgKFxuICAgIHByZXZEZXNjcmlwdG9yLFxuICAgIGluc3RhbmNlLFxuICAgIGVmZmVjdDogRWZmZWN0Q2FsbGJhY2ssXG4gICAgZGVwcz86IEluamVjdG9yRGVwcyxcbiAgICBjb25maWc/OiB7IHN5bmNocm9ub3VzPzogYm9vbGVhbiB9XG4gICkgPT4ge1xuICAgIGlmIChpbnN0YW5jZS5lY29zeXN0ZW0uc3NyKSByZXR1cm4gcHJldkRlc2NyaXB0b3JcblxuICAgIGNvbnN0IGRlcHNIYXZlQ2hhbmdlZCA9IGhhdmVEZXBzQ2hhbmdlZChwcmV2RGVzY3JpcHRvcj8uZGVwcywgZGVwcylcblxuICAgIGlmICghZGVwc0hhdmVDaGFuZ2VkKSByZXR1cm4gcHJldkRlc2NyaXB0b3JcblxuICAgIHByZXZEZXNjcmlwdG9yLmNsZWFudXA/LigpXG5cbiAgICBjb25zdCB0YXNrID0gZ2V0VGFzayhlZmZlY3QsIHByZXZEZXNjcmlwdG9yKVxuICAgIC8vIHRoaXMgY2xlYW51cCBzaG91bGQgYmUgdW5uZWNlc3Nhcnkgc2luY2UgZWZmZWN0cyBydW4gaW1tZWRpYXRlbHkgZXZlcnlcbiAgICAvLyB0aW1lIGV4Y2VwdCBpbml0LiBMZWF2ZSB0aGlzIHRob3VnaCBpbiBjYXNlIHdlIGFkZCBhIHdheSB0byB1cGRhdGUgYW5cbiAgICAvLyBhdG9tIGluc3RhbmNlIHdpdGhvdXQgZmx1c2hpbmcgdGhlIHNjaGVkdWxlclxuICAgIHByZXZEZXNjcmlwdG9yLmNsZWFudXAgPSAoKSA9PiB7XG4gICAgICBpbnN0YW5jZS5lY29zeXN0ZW0uX3NjaGVkdWxlci51bnNjaGVkdWxlKHRhc2spXG4gICAgICBwcmV2RGVzY3JpcHRvci5jbGVhbnVwID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIHByZXZEZXNjcmlwdG9yLmRlcHMgPSBkZXBzXG5cbiAgICBpZiAoY29uZmlnPy5zeW5jaHJvbm91cykge1xuICAgICAgdGFzaygpXG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLmVjb3N5c3RlbS5fc2NoZWR1bGVyLnNjaGVkdWxlKHtcbiAgICAgICAgdGFzayxcbiAgICAgICAgdHlwZTogNCwgLy8gUnVuRWZmZWN0ICg0KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gcHJldkRlc2NyaXB0b3JcbiAgfVxuKVxuIl0sIm5hbWVzIjpbImNyZWF0ZUluamVjdG9yIiwiaGF2ZURlcHNDaGFuZ2VkIiwicHJlZml4IiwiZ2V0VGFzayIsImVmZmVjdCIsImRlc2NyaXB0b3IiLCJ0YXNrIiwiY2xlYW51cCIsInVuZGVmaW5lZCIsImluamVjdEVmZmVjdCIsImluc3RhbmNlIiwiZGVwcyIsImNvbmZpZyIsInR5cGUiLCJlY29zeXN0ZW0iLCJzc3IiLCJfc2NoZWR1bGVyIiwidW5zY2hlZHVsZSIsInN5bmNocm9ub3VzIiwic2NoZWR1bGUiLCJwcmV2RGVzY3JpcHRvciIsImRlcHNIYXZlQ2hhbmdlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8723\n")},7361:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "i": function() { return /* binding */ injectRef; }\n/* harmony export */ });\n/* harmony import */ var _factories__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3870);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(395);\nvar injectRef=(0,_factories__WEBPACK_IMPORTED_MODULE_0__/* .createInjector */ .v)(\'injectRef\',function(instance,initialVal){return{result:{current:initialVal},type:_utils__WEBPACK_IMPORTED_MODULE_1__/* .prefix */ .O4+"/ref"};});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzM2MS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQVFPLEdBQU1FLFVBSVosQ0FBR0YsbUVBQWMsQ0FDaEIsV0FBVyxDQUNYLFNBQUlHLFFBQTZCLENBQUVDLFVBQWMsUUFBTSxDQUNyREMsTUFBTSxDQUFFLENBQUVDLE9BQU8sQ0FBRUYsVUFBZ0IsQ0FBQyxDQUNwQ0csSUFBSSxDQUFLTixvREFBTSxPQUNqQixDQUFDLEVBQUMsQ0FDSCIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL2luamVjdG9ycy9pbmplY3RSZWYudHM/M2RlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBNdXRhYmxlUmVmT2JqZWN0LFxuICBQYXJ0aWFsQXRvbUluc3RhbmNlLFxuICBSZWZPYmplY3QsXG59IGZyb20gJ0B6ZWR1eC9yZWFjdC90eXBlcydcbmltcG9ydCB7IGNyZWF0ZUluamVjdG9yIH0gZnJvbSAnLi4vZmFjdG9yaWVzJ1xuaW1wb3J0IHsgcHJlZml4IH0gZnJvbSAnLi4vdXRpbHMnXG5cbmV4cG9ydCBjb25zdCBpbmplY3RSZWY6IHtcbiAgPFQ+KGluaXRpYWxWYWw6IFQpOiBNdXRhYmxlUmVmT2JqZWN0PFQ+XG4gIDxUPihpbml0aWFsVmFsOiBUIHwgbnVsbCk6IFJlZk9iamVjdDxUPlxuICA8VCA9IHVuZGVmaW5lZD4oKTogTXV0YWJsZVJlZk9iamVjdDxUIHwgdW5kZWZpbmVkPlxufSA9IGNyZWF0ZUluamVjdG9yKFxuICAnaW5qZWN0UmVmJyxcbiAgPFQ+KGluc3RhbmNlOiBQYXJ0aWFsQXRvbUluc3RhbmNlLCBpbml0aWFsVmFsPzogVCkgPT4gKHtcbiAgICByZXN1bHQ6IHsgY3VycmVudDogaW5pdGlhbFZhbCBhcyBUIH0sXG4gICAgdHlwZTogYCR7cHJlZml4fS9yZWZgLFxuICB9KVxuKVxuIl0sIm5hbWVzIjpbImNyZWF0ZUluamVjdG9yIiwicHJlZml4IiwiaW5qZWN0UmVmIiwiaW5zdGFuY2UiLCJpbml0aWFsVmFsIiwicmVzdWx0IiwiY3VycmVudCIsInR5cGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7361\n')},5684:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"F\": function() { return /* binding */ injectStore; },\n/* harmony export */   \"n\": function() { return /* binding */ doSubscribe; }\n/* harmony export */ });\n/* harmony import */ var _zedux_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3064);\n/* harmony import */ var _zedux_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1694);\n/* harmony import */ var _factories__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3870);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(395);\nvar doSubscribe=function doSubscribe(instance,store){return store.subscribe({effects:function effects(_ref){var action=_ref.action,newState=_ref.newState,oldState=_ref.oldState;// Nothing to do if the state hasn't changed. Also, ignore state updates\n// during evaluation. TODO: Create an ecosystem-level flag to turn on\n// warning logging for state-updates-during-evaluation, since this may be\n// considered an anti-pattern.\nif(newState===oldState||instance.ecosystem._evaluationStack.isEvaluating(instance.keyHash)||(action==null?void 0:action.meta)===_zedux_core__WEBPACK_IMPORTED_MODULE_0__/* .internalTypes.ignore */ .P.ignore){return;}instance._scheduleEvaluation({newState:newState,oldState:oldState,operation:'injectStore',reasons:[{action:action,newState:newState,oldState:oldState,operation:'dispatch',sourceType:'Store',type:'state changed'}],sourceType:'Injector',type:'state changed'},false);// run the scheduler synchronously after any store update\ninstance.ecosystem._scheduler.flush();}});};/**\n * injectStore()\n *\n * A convenience utility for quickly creating and optionally subscribing to\n * stores in atoms.\n *\n * The returned store is a stable reference - it will not change on subsequent\n * evaluations. It can therefore be returned from the instance factory as the\n * instance's store. It also doesn't _need_ to be added to injector deps arrays\n * (though there's no harm in doing so).\n *\n * Accepts either the initial store state or a function that returns the store.\n * Use the latter for maximum flexibility.\n *\n * Subscribes to the store by default, causing the atom to be reevaluated on\n * every state change. This can be changed by passing `false` as the\n * subscribe config option.\n *\n * In most cases you won't need to prevent subscribing. But it can be a useful\n * performance optimization.\n *\n * ```ts\n * import { atom, injectStore } from '@zedux/react'\n *\n * const inputAtom = atom('input', () => {\n *   const store = injectStore('', { subscribe: false })\n *\n *   return store\n * })\n * ```\n *\n * When `hydrate: true` is passed, the store's initial state will be set to the\n * value from the last call to `ecosystem.hydrate()` whose key matches this atom\n * instance. The hydrated value will be passed to the atom's `hydrate` config\n * option, if any, to transform the value first.\n *\n * When the function `storeFactory` overload is used and `hydrate: true` is\n * passed, the transformed hydration will be passed to the store factory\n * function and it's up to you to use it to hydrate the store you create.\n *\n * ```ts\n * const store = injectStore(\n *   hydration => createStore(null, hydration ?? defaultVal),\n *   { hydrate: true }\n * )\n * // or simply:\n * const store = injectStore(defaultVal, { hydrate: true })\n * ```\n *\n * @param storeFactory - Either a function that returns a store or the initial\n * state of the store\n * @param config - A config object. Accepts the following properties:\n *   - `hydrate` - Whether to try hydrating this store with\n *   - `subscribe` - Whether to subscribe to the store (default: `true`)\n * @returns Store\n */var injectStore=(0,_factories__WEBPACK_IMPORTED_MODULE_1__/* .createInjector */ .v)('injectStore',function(instance,storeFactory,config){var _config$subscribe;var subscribe=(_config$subscribe=config==null?void 0:config.subscribe)!=null?_config$subscribe:true;var getStore=typeof storeFactory==='function'?storeFactory:function(hydration){return (0,_zedux_core__WEBPACK_IMPORTED_MODULE_2__/* .createStore */ .M)(null,hydration||storeFactory);};var store=getStore(config!=null&&config.hydrate?instance.ecosystem._consumeHydration(instance):undefined);var subscription=subscribe&&doSubscribe(instance,store);return{cleanup:subscription?function(){return subscription.unsubscribe();}:undefined,result:store,type:_utils__WEBPACK_IMPORTED_MODULE_3__/* .prefix */ .O4+\"/store\"};},function(prevDescriptor,instance,storeFactory,config){var _config$subscribe2;var subscribe=(_config$subscribe2=config==null?void 0:config.subscribe)!=null?_config$subscribe2:true;var prevsubscribe=!!prevDescriptor.cleanup;if(prevsubscribe===subscribe)return prevDescriptor;// we were subscribed, now we're not\nif(!subscribe){prevDescriptor.cleanup==null?void 0:prevDescriptor.cleanup();prevDescriptor.cleanup=undefined;return prevDescriptor;}// we weren't subscribed, now we are\nvar subscription=doSubscribe(instance,prevDescriptor.result);prevDescriptor.cleanup=function(){return subscription.unsubscribe();};return prevDescriptor;});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R0FBTXBCLFVBQVMscUJBQUdvQixNQUFNLGNBQU5BLE1BQU0sQ0FBRXBCLFNBQVMsMkJBQUksSUFBSSxDQUMzQyxHQUFNK0IsY0FBYSxDQUFHLENBQUMsQ0FBQ0QsY0FBYyxDQUFDSCxPQUFPLENBRTlDLEdBQUlJLGFBQWEsR0FBSy9CLFNBQVMsQ0FBRSxNQUFPOEIsZUFBYyxDQUV0RDtBQUNBLEdBQUksQ0FBQzlCLFNBQVMsQ0FBRSxDQUNkOEIsY0FBYyxDQUFDSCxPQUFPLGNBQXRCRyxjQUFjLENBQUNILE9BQU8sRUFBSSxDQUMxQkcsY0FBYyxDQUFDSCxPQUFPLENBQUdGLFNBQVMsQ0FDbEMsTUFBT0ssZUFBYyxDQUN2QixDQUVBO0FBQ0EsR0FBTUosYUFBWSxDQUFHN0IsV0FBVyxDQUFDQyxRQUFRLENBQUVnQyxjQUFjLENBQUNELE1BQU0sQ0FBQyxDQUNqRUMsY0FBYyxDQUFDSCxPQUFPLENBQUcsaUJBQU1ELGFBQVksQ0FBQ0UsV0FBVyxFQUFFLEdBRXpELE1BQU9FLGVBQWMsQ0FDdkIsQ0FBQyxDQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9yZWFjdC9zcmMvaW5qZWN0b3JzL2luamVjdFN0b3JlLnRzP2ViNTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlU3RvcmUsIGludGVybmFsVHlwZXMsIFN0b3JlIH0gZnJvbSAnQHplZHV4L2NvcmUnXG5pbXBvcnQgeyBjcmVhdGVJbmplY3RvciB9IGZyb20gJy4uL2ZhY3RvcmllcydcbmltcG9ydCB7IEluamVjdFN0b3JlQ29uZmlnLCBQYXJ0aWFsQXRvbUluc3RhbmNlIH0gZnJvbSAnLi4vdHlwZXMnXG5pbXBvcnQgeyBJbmplY3RvckRlc2NyaXB0b3IsIHByZWZpeCB9IGZyb20gJy4uL3V0aWxzJ1xuXG5leHBvcnQgY29uc3QgZG9TdWJzY3JpYmUgPSA8U3RhdGU+KFxuICBpbnN0YW5jZTogUGFydGlhbEF0b21JbnN0YW5jZSxcbiAgc3RvcmU6IFN0b3JlPFN0YXRlPlxuKSA9PlxuICBzdG9yZS5zdWJzY3JpYmUoe1xuICAgIGVmZmVjdHM6ICh7IGFjdGlvbiwgbmV3U3RhdGUsIG9sZFN0YXRlIH0pID0+IHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gZG8gaWYgdGhlIHN0YXRlIGhhc24ndCBjaGFuZ2VkLiBBbHNvLCBpZ25vcmUgc3RhdGUgdXBkYXRlc1xuICAgICAgLy8gZHVyaW5nIGV2YWx1YXRpb24uIFRPRE86IENyZWF0ZSBhbiBlY29zeXN0ZW0tbGV2ZWwgZmxhZyB0byB0dXJuIG9uXG4gICAgICAvLyB3YXJuaW5nIGxvZ2dpbmcgZm9yIHN0YXRlLXVwZGF0ZXMtZHVyaW5nLWV2YWx1YXRpb24sIHNpbmNlIHRoaXMgbWF5IGJlXG4gICAgICAvLyBjb25zaWRlcmVkIGFuIGFudGktcGF0dGVybi5cbiAgICAgIGlmIChcbiAgICAgICAgbmV3U3RhdGUgPT09IG9sZFN0YXRlIHx8XG4gICAgICAgIGluc3RhbmNlLmVjb3N5c3RlbS5fZXZhbHVhdGlvblN0YWNrLmlzRXZhbHVhdGluZyhpbnN0YW5jZS5rZXlIYXNoKSB8fFxuICAgICAgICBhY3Rpb24/Lm1ldGEgPT09IGludGVybmFsVHlwZXMuaWdub3JlXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLl9zY2hlZHVsZUV2YWx1YXRpb24oXG4gICAgICAgIHtcbiAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICBvbGRTdGF0ZSxcbiAgICAgICAgICBvcGVyYXRpb246ICdpbmplY3RTdG9yZScsXG4gICAgICAgICAgcmVhc29uczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgIG5ld1N0YXRlLFxuICAgICAgICAgICAgICBvbGRTdGF0ZSxcbiAgICAgICAgICAgICAgb3BlcmF0aW9uOiAnZGlzcGF0Y2gnLFxuICAgICAgICAgICAgICBzb3VyY2VUeXBlOiAnU3RvcmUnLFxuICAgICAgICAgICAgICB0eXBlOiAnc3RhdGUgY2hhbmdlZCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgICAgc291cmNlVHlwZTogJ0luamVjdG9yJyxcbiAgICAgICAgICB0eXBlOiAnc3RhdGUgY2hhbmdlZCcsXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgICApXG5cbiAgICAgIC8vIHJ1biB0aGUgc2NoZWR1bGVyIHN5bmNocm9ub3VzbHkgYWZ0ZXIgYW55IHN0b3JlIHVwZGF0ZVxuICAgICAgaW5zdGFuY2UuZWNvc3lzdGVtLl9zY2hlZHVsZXIuZmx1c2goKVxuICAgIH0sXG4gIH0pXG5cbi8qKlxuICogaW5qZWN0U3RvcmUoKVxuICpcbiAqIEEgY29udmVuaWVuY2UgdXRpbGl0eSBmb3IgcXVpY2tseSBjcmVhdGluZyBhbmQgb3B0aW9uYWxseSBzdWJzY3JpYmluZyB0b1xuICogc3RvcmVzIGluIGF0b21zLlxuICpcbiAqIFRoZSByZXR1cm5lZCBzdG9yZSBpcyBhIHN0YWJsZSByZWZlcmVuY2UgLSBpdCB3aWxsIG5vdCBjaGFuZ2Ugb24gc3Vic2VxdWVudFxuICogZXZhbHVhdGlvbnMuIEl0IGNhbiB0aGVyZWZvcmUgYmUgcmV0dXJuZWQgZnJvbSB0aGUgaW5zdGFuY2UgZmFjdG9yeSBhcyB0aGVcbiAqIGluc3RhbmNlJ3Mgc3RvcmUuIEl0IGFsc28gZG9lc24ndCBfbmVlZF8gdG8gYmUgYWRkZWQgdG8gaW5qZWN0b3IgZGVwcyBhcnJheXNcbiAqICh0aG91Z2ggdGhlcmUncyBubyBoYXJtIGluIGRvaW5nIHNvKS5cbiAqXG4gKiBBY2NlcHRzIGVpdGhlciB0aGUgaW5pdGlhbCBzdG9yZSBzdGF0ZSBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgc3RvcmUuXG4gKiBVc2UgdGhlIGxhdHRlciBmb3IgbWF4aW11bSBmbGV4aWJpbGl0eS5cbiAqXG4gKiBTdWJzY3JpYmVzIHRvIHRoZSBzdG9yZSBieSBkZWZhdWx0LCBjYXVzaW5nIHRoZSBhdG9tIHRvIGJlIHJlZXZhbHVhdGVkIG9uXG4gKiBldmVyeSBzdGF0ZSBjaGFuZ2UuIFRoaXMgY2FuIGJlIGNoYW5nZWQgYnkgcGFzc2luZyBgZmFsc2VgIGFzIHRoZVxuICogc3Vic2NyaWJlIGNvbmZpZyBvcHRpb24uXG4gKlxuICogSW4gbW9zdCBjYXNlcyB5b3Ugd29uJ3QgbmVlZCB0byBwcmV2ZW50IHN1YnNjcmliaW5nLiBCdXQgaXQgY2FuIGJlIGEgdXNlZnVsXG4gKiBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7IGF0b20sIGluamVjdFN0b3JlIH0gZnJvbSAnQHplZHV4L3JlYWN0J1xuICpcbiAqIGNvbnN0IGlucHV0QXRvbSA9IGF0b20oJ2lucHV0JywgKCkgPT4ge1xuICogICBjb25zdCBzdG9yZSA9IGluamVjdFN0b3JlKCcnLCB7IHN1YnNjcmliZTogZmFsc2UgfSlcbiAqXG4gKiAgIHJldHVybiBzdG9yZVxuICogfSlcbiAqIGBgYFxuICpcbiAqIFdoZW4gYGh5ZHJhdGU6IHRydWVgIGlzIHBhc3NlZCwgdGhlIHN0b3JlJ3MgaW5pdGlhbCBzdGF0ZSB3aWxsIGJlIHNldCB0byB0aGVcbiAqIHZhbHVlIGZyb20gdGhlIGxhc3QgY2FsbCB0byBgZWNvc3lzdGVtLmh5ZHJhdGUoKWAgd2hvc2Uga2V5IG1hdGNoZXMgdGhpcyBhdG9tXG4gKiBpbnN0YW5jZS4gVGhlIGh5ZHJhdGVkIHZhbHVlIHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBhdG9tJ3MgYGh5ZHJhdGVgIGNvbmZpZ1xuICogb3B0aW9uLCBpZiBhbnksIHRvIHRyYW5zZm9ybSB0aGUgdmFsdWUgZmlyc3QuXG4gKlxuICogV2hlbiB0aGUgZnVuY3Rpb24gYHN0b3JlRmFjdG9yeWAgb3ZlcmxvYWQgaXMgdXNlZCBhbmQgYGh5ZHJhdGU6IHRydWVgIGlzXG4gKiBwYXNzZWQsIHRoZSB0cmFuc2Zvcm1lZCBoeWRyYXRpb24gd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHN0b3JlIGZhY3RvcnlcbiAqIGZ1bmN0aW9uIGFuZCBpdCdzIHVwIHRvIHlvdSB0byB1c2UgaXQgdG8gaHlkcmF0ZSB0aGUgc3RvcmUgeW91IGNyZWF0ZS5cbiAqXG4gKiBgYGB0c1xuICogY29uc3Qgc3RvcmUgPSBpbmplY3RTdG9yZShcbiAqICAgaHlkcmF0aW9uID0+IGNyZWF0ZVN0b3JlKG51bGwsIGh5ZHJhdGlvbiA/PyBkZWZhdWx0VmFsKSxcbiAqICAgeyBoeWRyYXRlOiB0cnVlIH1cbiAqIClcbiAqIC8vIG9yIHNpbXBseTpcbiAqIGNvbnN0IHN0b3JlID0gaW5qZWN0U3RvcmUoZGVmYXVsdFZhbCwgeyBoeWRyYXRlOiB0cnVlIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc3RvcmVGYWN0b3J5IC0gRWl0aGVyIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RvcmUgb3IgdGhlIGluaXRpYWxcbiAqIHN0YXRlIG9mIHRoZSBzdG9yZVxuICogQHBhcmFtIGNvbmZpZyAtIEEgY29uZmlnIG9iamVjdC4gQWNjZXB0cyB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKiAgIC0gYGh5ZHJhdGVgIC0gV2hldGhlciB0byB0cnkgaHlkcmF0aW5nIHRoaXMgc3RvcmUgd2l0aFxuICogICAtIGBzdWJzY3JpYmVgIC0gV2hldGhlciB0byBzdWJzY3JpYmUgdG8gdGhlIHN0b3JlIChkZWZhdWx0OiBgdHJ1ZWApXG4gKiBAcmV0dXJucyBTdG9yZVxuICovXG5leHBvcnQgY29uc3QgaW5qZWN0U3RvcmU6IHtcbiAgPFN0YXRlID0gYW55PihcbiAgICBzdG9yZUZhY3Rvcnk6IFN0YXRlIHwgKChoeWRyYXRpb24/OiBTdGF0ZSkgPT4gU3RvcmU8U3RhdGU+KSxcbiAgICBjb25maWc/OiBJbmplY3RTdG9yZUNvbmZpZ1xuICApOiBTdG9yZTxTdGF0ZT5cbiAgPFN0YXRlID0gdW5kZWZpbmVkPigpOiBTdG9yZTxTdGF0ZT5cbn0gPSBjcmVhdGVJbmplY3RvcihcbiAgJ2luamVjdFN0b3JlJyxcbiAgPFN0YXRlID0gYW55PihcbiAgICBpbnN0YW5jZTogUGFydGlhbEF0b21JbnN0YW5jZSxcbiAgICBzdG9yZUZhY3Rvcnk/OiBTdGF0ZSB8ICgoaHlkcmF0aW9uPzogU3RhdGUpID0+IFN0b3JlPFN0YXRlPiksXG4gICAgY29uZmlnPzogSW5qZWN0U3RvcmVDb25maWdcbiAgKSA9PiB7XG4gICAgY29uc3Qgc3Vic2NyaWJlID0gY29uZmlnPy5zdWJzY3JpYmUgPz8gdHJ1ZVxuICAgIGNvbnN0IGdldFN0b3JlID1cbiAgICAgIHR5cGVvZiBzdG9yZUZhY3RvcnkgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyAoc3RvcmVGYWN0b3J5IGFzICgpID0+IFN0b3JlPFN0YXRlPilcbiAgICAgICAgOiAoaHlkcmF0aW9uPzogU3RhdGUpID0+XG4gICAgICAgICAgICBjcmVhdGVTdG9yZTxTdGF0ZT4obnVsbCwgaHlkcmF0aW9uIHx8IHN0b3JlRmFjdG9yeSlcblxuICAgIGNvbnN0IHN0b3JlID0gZ2V0U3RvcmUoXG4gICAgICBjb25maWc/Lmh5ZHJhdGVcbiAgICAgICAgPyBpbnN0YW5jZS5lY29zeXN0ZW0uX2NvbnN1bWVIeWRyYXRpb24oaW5zdGFuY2UpXG4gICAgICAgIDogdW5kZWZpbmVkXG4gICAgKVxuXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlICYmIGRvU3Vic2NyaWJlKGluc3RhbmNlLCBzdG9yZSlcblxuICAgIHJldHVybiB7XG4gICAgICBjbGVhbnVwOiBzdWJzY3JpcHRpb24gPyAoKSA9PiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHJlc3VsdDogc3RvcmUsXG4gICAgICB0eXBlOiBgJHtwcmVmaXh9L3N0b3JlYCxcbiAgICB9IGFzIEluamVjdG9yRGVzY3JpcHRvcjxTdG9yZTxTdGF0ZT4+XG4gIH0sXG4gIDxTdGF0ZSA9IGFueT4oXG4gICAgcHJldkRlc2NyaXB0b3I6IEluamVjdG9yRGVzY3JpcHRvcjxTdG9yZTxTdGF0ZT4+LFxuICAgIGluc3RhbmNlOiBQYXJ0aWFsQXRvbUluc3RhbmNlLFxuICAgIHN0b3JlRmFjdG9yeT86IFN0YXRlIHwgKChoeWRyYXRpb24/OiBTdGF0ZSkgPT4gU3RvcmU8U3RhdGU+KSxcbiAgICBjb25maWc/OiBJbmplY3RTdG9yZUNvbmZpZ1xuICApID0+IHtcbiAgICBjb25zdCBzdWJzY3JpYmUgPSBjb25maWc/LnN1YnNjcmliZSA/PyB0cnVlXG4gICAgY29uc3QgcHJldnN1YnNjcmliZSA9ICEhcHJldkRlc2NyaXB0b3IuY2xlYW51cFxuXG4gICAgaWYgKHByZXZzdWJzY3JpYmUgPT09IHN1YnNjcmliZSkgcmV0dXJuIHByZXZEZXNjcmlwdG9yXG5cbiAgICAvLyB3ZSB3ZXJlIHN1YnNjcmliZWQsIG5vdyB3ZSdyZSBub3RcbiAgICBpZiAoIXN1YnNjcmliZSkge1xuICAgICAgcHJldkRlc2NyaXB0b3IuY2xlYW51cD8uKClcbiAgICAgIHByZXZEZXNjcmlwdG9yLmNsZWFudXAgPSB1bmRlZmluZWRcbiAgICAgIHJldHVybiBwcmV2RGVzY3JpcHRvclxuICAgIH1cblxuICAgIC8vIHdlIHdlcmVuJ3Qgc3Vic2NyaWJlZCwgbm93IHdlIGFyZVxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGRvU3Vic2NyaWJlKGluc3RhbmNlLCBwcmV2RGVzY3JpcHRvci5yZXN1bHQpXG4gICAgcHJldkRlc2NyaXB0b3IuY2xlYW51cCA9ICgpID0+IHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpXG5cbiAgICByZXR1cm4gcHJldkRlc2NyaXB0b3JcbiAgfVxuKVxuIl0sIm5hbWVzIjpbImNyZWF0ZVN0b3JlIiwiaW50ZXJuYWxUeXBlcyIsImNyZWF0ZUluamVjdG9yIiwicHJlZml4IiwiZG9TdWJzY3JpYmUiLCJpbnN0YW5jZSIsInN0b3JlIiwic3Vic2NyaWJlIiwiZWZmZWN0cyIsImFjdGlvbiIsIm5ld1N0YXRlIiwib2xkU3RhdGUiLCJlY29zeXN0ZW0iLCJfZXZhbHVhdGlvblN0YWNrIiwiaXNFdmFsdWF0aW5nIiwia2V5SGFzaCIsIm1ldGEiLCJpZ25vcmUiLCJfc2NoZWR1bGVFdmFsdWF0aW9uIiwib3BlcmF0aW9uIiwicmVhc29ucyIsInNvdXJjZVR5cGUiLCJ0eXBlIiwiX3NjaGVkdWxlciIsImZsdXNoIiwiaW5qZWN0U3RvcmUiLCJzdG9yZUZhY3RvcnkiLCJjb25maWciLCJnZXRTdG9yZSIsImh5ZHJhdGlvbiIsImh5ZHJhdGUiLCJfY29uc3VtZUh5ZHJhdGlvbiIsInVuZGVmaW5lZCIsInN1YnNjcmlwdGlvbiIsImNsZWFudXAiLCJ1bnN1YnNjcmliZSIsInJlc3VsdCIsInByZXZEZXNjcmlwdG9yIiwicHJldnN1YnNjcmliZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5684\n")},825:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "$$": function() { return /* binding */ getEcosystem; },\n/* harmony export */   "Do": function() { return /* binding */ internalStore; },\n/* harmony export */   "Ej": function() { return /* binding */ wipe; },\n/* harmony export */   "LW": function() { return /* binding */ setInternalStore; }\n/* harmony export */ });\n/* harmony import */ var _zedux_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1694);\nvar internalStore=(0,_zedux_core__WEBPACK_IMPORTED_MODULE_0__/* .createStore */ .M)(null,{});var getEcosystem=function getEcosystem(id){var ecosystem=internalStore.getState()[id];if(ecosystem)return ecosystem;};var setInternalStore=function setInternalStore(newStore){return internalStore=newStore;};var wipe=function wipe(){var ecosystems=Object.values(internalStore.getState().ecosystems);ecosystems.forEach(function(es){es.destroy(true);});};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODI1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFHTyxHQUFJQyxjQUFhLENBQUdELGlFQUFXLENBQUMsSUFBSSxDQUFFLENBQUMsQ0FBQyxDQUE4QixDQUV0RSxHQUFNRSxhQUFZLENBQUcsUUFBZkEsYUFBWSxDQUFJQyxFQUFVLENBQTRCLENBQ2pFLEdBQU1DLFVBQVMsQ0FBR0gsYUFBYSxDQUFDSSxRQUFRLEVBQUUsQ0FBQ0YsRUFBRSxDQUFDLENBRTlDLEdBQUlDLFNBQVMsQ0FBRSxNQUFPQSxVQUFTLENBQ2pDLENBQUMsQ0FFTSxHQUFNRSxpQkFBZ0IsQ0FBRyxRQUFuQkEsaUJBQWdCLENBQUlDLFFBQThCLFFBQzVETixjQUFhLENBQUdNLFFBQVEsRUFBQyxDQUVyQixHQUFNQyxLQUFJLENBQUcsUUFBUEEsS0FBSSxFQUFTLENBQ3hCLEdBQU1DLFdBQVUsQ0FBR0MsTUFBTSxDQUFDQyxNQUFNLENBQUNWLGFBQWEsQ0FBQ0ksUUFBUSxFQUFFLENBQUNJLFVBQVUsQ0FBQyxDQUVyRUEsVUFBVSxDQUFDRyxPQUFPLENBQUMsU0FBQUMsRUFBRSxDQUFJLENBQ3ZCQSxFQUFFLENBQUNDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FDbEIsQ0FBQyxDQUFDLENBQ0osQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi4vcGFja2FnZXMvcmVhY3Qvc3JjL3N0b3JlL2luZGV4LnRzPzExYzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlU3RvcmUgfSBmcm9tICdAemVkdXgvY29yZSdcbmltcG9ydCB7IEVjb3N5c3RlbSB9IGZyb20gJy4uL2NsYXNzZXMnXG5cbmV4cG9ydCBsZXQgaW50ZXJuYWxTdG9yZSA9IGNyZWF0ZVN0b3JlKG51bGwsIHt9IGFzIFJlY29yZDxzdHJpbmcsIEVjb3N5c3RlbT4pXG5cbmV4cG9ydCBjb25zdCBnZXRFY29zeXN0ZW0gPSAoaWQ6IHN0cmluZyk6IEVjb3N5c3RlbSB8IHVuZGVmaW5lZCA9PiB7XG4gIGNvbnN0IGVjb3N5c3RlbSA9IGludGVybmFsU3RvcmUuZ2V0U3RhdGUoKVtpZF1cblxuICBpZiAoZWNvc3lzdGVtKSByZXR1cm4gZWNvc3lzdGVtXG59XG5cbmV4cG9ydCBjb25zdCBzZXRJbnRlcm5hbFN0b3JlID0gKG5ld1N0b3JlOiB0eXBlb2YgaW50ZXJuYWxTdG9yZSkgPT5cbiAgKGludGVybmFsU3RvcmUgPSBuZXdTdG9yZSlcblxuZXhwb3J0IGNvbnN0IHdpcGUgPSAoKSA9PiB7XG4gIGNvbnN0IGVjb3N5c3RlbXMgPSBPYmplY3QudmFsdWVzKGludGVybmFsU3RvcmUuZ2V0U3RhdGUoKS5lY29zeXN0ZW1zKVxuXG4gIGVjb3N5c3RlbXMuZm9yRWFjaChlcyA9PiB7XG4gICAgZXMuZGVzdHJveSh0cnVlKVxuICB9KVxufVxuIl0sIm5hbWVzIjpbImNyZWF0ZVN0b3JlIiwiaW50ZXJuYWxTdG9yZSIsImdldEVjb3N5c3RlbSIsImlkIiwiZWNvc3lzdGVtIiwiZ2V0U3RhdGUiLCJzZXRJbnRlcm5hbFN0b3JlIiwibmV3U3RvcmUiLCJ3aXBlIiwiZWNvc3lzdGVtcyIsIk9iamVjdCIsInZhbHVlcyIsImZvckVhY2giLCJlcyIsImRlc3Ryb3kiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///825\n')},395:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "EM": function() { return /* binding */ haveDepsChanged; },\n/* harmony export */   "Jy": function() { return /* binding */ Explicit; },\n/* harmony export */   "O4": function() { return /* binding */ prefix; },\n/* harmony export */   "RQ": function() { return /* binding */ External; },\n/* harmony export */   "lv": function() { return /* binding */ destroyed; },\n/* harmony export */   "qG": function() { return /* binding */ Static; },\n/* harmony export */   "zs": function() { return /* binding */ ecosystemContext; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7294);\n/**\n * The EdgeFlags. These are used as bitwise flags.\n *\n * The flag score determines job priority in the scheduler. Scores range from\n * 0-7. Lower score = higher prio. Examples:\n *\n * 0 = implicit-internal-dynamic\n * 3 = explicit-external-dynamic\n * 7 = explicit-external-static\n */var Explicit=1;var External=2;var Static=4;// export const Deferred = 8\nvar ecosystemContext=/*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(\'@@global\');/**\n * Compare two arrays and see if any elements are different (===). Returns true\n * by default if either array is undefined\n */var haveDepsChanged=function haveDepsChanged(prevDeps,nextDeps){return!prevDeps||!nextDeps||prevDeps.length!==nextDeps.length||prevDeps.some(function(dep,i){return nextDeps[i]!==dep;});};var prefix=\'@@zedux\';var destroyed=Symbol(prefix+"/destroyed");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzk1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUNPLEdBQU1DLFNBQVEsQ0FBRyxDQUFDLENBQ2xCLEdBQU1DLFNBQVEsQ0FBRyxDQUFDLENBQ2xCLEdBQU1DLE9BQU0sQ0FBRyxDQUFDLENBQ3ZCO0FBRU8sR0FBTUMsaUJBQWdCLGNBQUdKLG9EQUFhLENBQUMsVUFBVSxDQUFDLENBRXpEO0FBQ0E7QUFDQTtBQUNBLEdBQ08sR0FBTUssZ0JBQWUsQ0FBRyxRQUFsQkEsZ0JBQWUsQ0FBSUMsUUFBZ0IsQ0FBRUMsUUFBZ0IsUUFDaEUsQ0FBQ0QsUUFBUSxFQUNULENBQUNDLFFBQVEsRUFDVEQsUUFBUSxDQUFDRSxNQUFNLEdBQUtELFFBQVEsQ0FBQ0MsTUFBTSxFQUNuQ0YsUUFBUSxDQUFDRyxJQUFJLENBQUMsU0FBQ0MsR0FBRyxDQUFFQyxDQUFDLFFBQUtKLFNBQVEsQ0FBQ0ksQ0FBQyxDQUFDLEdBQUtELEdBQUcsR0FBQyxHQUV6QyxHQUFNRSxPQUFNLENBQUcsU0FBUyxDQUV4QixHQUFNQyxVQUFTLENBQUdDLE1BQU0sQ0FBSUYsTUFBTSxjQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9yZWFjdC9zcmMvdXRpbHMvZ2VuZXJhbC50cz8xMGM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCdcblxuLyoqXG4gKiBUaGUgRWRnZUZsYWdzLiBUaGVzZSBhcmUgdXNlZCBhcyBiaXR3aXNlIGZsYWdzLlxuICpcbiAqIFRoZSBmbGFnIHNjb3JlIGRldGVybWluZXMgam9iIHByaW9yaXR5IGluIHRoZSBzY2hlZHVsZXIuIFNjb3JlcyByYW5nZSBmcm9tXG4gKiAwLTcuIExvd2VyIHNjb3JlID0gaGlnaGVyIHByaW8uIEV4YW1wbGVzOlxuICpcbiAqIDAgPSBpbXBsaWNpdC1pbnRlcm5hbC1keW5hbWljXG4gKiAzID0gZXhwbGljaXQtZXh0ZXJuYWwtZHluYW1pY1xuICogNyA9IGV4cGxpY2l0LWV4dGVybmFsLXN0YXRpY1xuICovXG5leHBvcnQgY29uc3QgRXhwbGljaXQgPSAxXG5leHBvcnQgY29uc3QgRXh0ZXJuYWwgPSAyXG5leHBvcnQgY29uc3QgU3RhdGljID0gNFxuLy8gZXhwb3J0IGNvbnN0IERlZmVycmVkID0gOFxuXG5leHBvcnQgY29uc3QgZWNvc3lzdGVtQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoJ0BAZ2xvYmFsJylcblxuLyoqXG4gKiBDb21wYXJlIHR3byBhcnJheXMgYW5kIHNlZSBpZiBhbnkgZWxlbWVudHMgYXJlIGRpZmZlcmVudCAoPT09KS4gUmV0dXJucyB0cnVlXG4gKiBieSBkZWZhdWx0IGlmIGVpdGhlciBhcnJheSBpcyB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGhhdmVEZXBzQ2hhbmdlZCA9IChwcmV2RGVwcz86IGFueVtdLCBuZXh0RGVwcz86IGFueVtdKSA9PlxuICAhcHJldkRlcHMgfHxcbiAgIW5leHREZXBzIHx8XG4gIHByZXZEZXBzLmxlbmd0aCAhPT0gbmV4dERlcHMubGVuZ3RoIHx8XG4gIHByZXZEZXBzLnNvbWUoKGRlcCwgaSkgPT4gbmV4dERlcHNbaV0gIT09IGRlcClcblxuZXhwb3J0IGNvbnN0IHByZWZpeCA9ICdAQHplZHV4J1xuXG5leHBvcnQgY29uc3QgZGVzdHJveWVkID0gU3ltYm9sKGAke3ByZWZpeH0vZGVzdHJveWVkYClcbiJdLCJuYW1lcyI6WyJjcmVhdGVDb250ZXh0IiwiRXhwbGljaXQiLCJFeHRlcm5hbCIsIlN0YXRpYyIsImVjb3N5c3RlbUNvbnRleHQiLCJoYXZlRGVwc0NoYW5nZWQiLCJwcmV2RGVwcyIsIm5leHREZXBzIiwibGVuZ3RoIiwic29tZSIsImRlcCIsImkiLCJwcmVmaXgiLCJkZXN0cm95ZWQiLCJTeW1ib2wiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///395\n')},3299:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"V\": function() { return /* binding */ pluginActions; }\n/* harmony export */ });\n/* harmony import */ var _zedux_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2808);\nvar pluginActions={activeStateChanged:(0,_zedux_core__WEBPACK_IMPORTED_MODULE_0__/* .actionFactory */ .B)('activeStateChanged'),ecosystemWiped:(0,_zedux_core__WEBPACK_IMPORTED_MODULE_0__/* .actionFactory */ .B)('ecosystemWiped'),edgeCreated:(0,_zedux_core__WEBPACK_IMPORTED_MODULE_0__/* .actionFactory */ .B)('edgeCreated'),edgeRemoved:(0,_zedux_core__WEBPACK_IMPORTED_MODULE_0__/* .actionFactory */ .B)('edgeRemoved'),evaluationFinished:(0,_zedux_core__WEBPACK_IMPORTED_MODULE_0__/* .actionFactory */ .B)('evaluationFinished'),// either cache or instance will always be defined, depending on the node type\nstateChanged:(0,_zedux_core__WEBPACK_IMPORTED_MODULE_0__/* .actionFactory */ .B)('stateChanged')};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzI5OS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBVU8sR0FBTUMsY0FBYSxDQUFHLENBQzNCQyxrQkFBa0IsQ0FBRUYsbUVBQWEsQ0FPL0Isb0JBQW9CLENBQUMsQ0FDdkJHLGNBQWMsQ0FBRUgsbUVBQWEsQ0FDM0IsZ0JBQWdCLENBQ2pCLENBQ0RJLFdBQVcsQ0FBRUosbUVBQWEsQ0FReEIsYUFBYSxDQUFDLENBQ2hCSyxXQUFXLENBQUVMLG1FQUFhLENBT3hCLGFBQWEsQ0FBQyxDQUNoQk0sa0JBQWtCLENBQUVOLG1FQUFhLENBVS9CLG9CQUFvQixDQUFDLENBQ3ZCO0FBQ0FPLFlBQVksQ0FBRVAsbUVBQWEsQ0FVekIsY0FBYyxDQUNsQixDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uLi9wYWNrYWdlcy9yZWFjdC9zcmMvdXRpbHMvcGx1Z2luLWFjdGlvbnMudHM/OTY2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBY3Rpb25DaGFpbiwgYWN0aW9uRmFjdG9yeSB9IGZyb20gJ0B6ZWR1eC9jb3JlJ1xuaW1wb3J0IHsgRWNvc3lzdGVtIH0gZnJvbSAnLi4vY2xhc3Nlcy9FY29zeXN0ZW0nXG5pbXBvcnQge1xuICBBY3RpdmVTdGF0ZSxcbiAgQW55QXRvbUluc3RhbmNlLFxuICBEZXBlbmRlbnRFZGdlLFxuICBFdmFsdWF0aW9uUmVhc29uLFxufSBmcm9tICcuLi90eXBlcydcbmltcG9ydCB7IFNlbGVjdG9yQ2FjaGVJdGVtIH0gZnJvbSAnLi4vY2xhc3Nlcy9TZWxlY3RvckNhY2hlJ1xuXG5leHBvcnQgY29uc3QgcGx1Z2luQWN0aW9ucyA9IHtcbiAgYWN0aXZlU3RhdGVDaGFuZ2VkOiBhY3Rpb25GYWN0b3J5PFxuICAgIHtcbiAgICAgIGluc3RhbmNlOiBBbnlBdG9tSW5zdGFuY2VcbiAgICAgIG5ld0FjdGl2ZVN0YXRlOiBBY3RpdmVTdGF0ZVxuICAgICAgb2xkQWN0aXZlU3RhdGU6IEFjdGl2ZVN0YXRlXG4gICAgfSxcbiAgICAnYWN0aXZlU3RhdGVDaGFuZ2VkJ1xuICA+KCdhY3RpdmVTdGF0ZUNoYW5nZWQnKSxcbiAgZWNvc3lzdGVtV2lwZWQ6IGFjdGlvbkZhY3Rvcnk8eyBlY29zeXN0ZW06IEVjb3N5c3RlbSB9LCAnZWNvc3lzdGVtV2lwZWQnPihcbiAgICAnZWNvc3lzdGVtV2lwZWQnXG4gICksXG4gIGVkZ2VDcmVhdGVkOiBhY3Rpb25GYWN0b3J5PFxuICAgIHtcbiAgICAgIGRlcGVuZGVuY3k6IEFueUF0b21JbnN0YW5jZSB8IFNlbGVjdG9yQ2FjaGVJdGVtXG4gICAgICAvLyBzdHJpbmcgaWYgYGVkZ2UuZmxhZ3MgJiBFeHRlcm5hbGA6XG4gICAgICBkZXBlbmRlbnQ6IEFueUF0b21JbnN0YW5jZSB8IFNlbGVjdG9yQ2FjaGVJdGVtIHwgc3RyaW5nXG4gICAgICBlZGdlOiBEZXBlbmRlbnRFZGdlXG4gICAgfSxcbiAgICAnZWRnZUNyZWF0ZWQnXG4gID4oJ2VkZ2VDcmVhdGVkJyksXG4gIGVkZ2VSZW1vdmVkOiBhY3Rpb25GYWN0b3J5PFxuICAgIHtcbiAgICAgIGRlcGVuZGVuY3k6IEFueUF0b21JbnN0YW5jZSB8IFNlbGVjdG9yQ2FjaGVJdGVtXG4gICAgICBkZXBlbmRlbnQ6IEFueUF0b21JbnN0YW5jZSB8IFNlbGVjdG9yQ2FjaGVJdGVtIHwgc3RyaW5nIC8vIHN0cmluZyBpZiBlZGdlIGlzIEV4dGVybmFsXG4gICAgICBlZGdlOiBEZXBlbmRlbnRFZGdlXG4gICAgfSxcbiAgICAnZWRnZVJlbW92ZWQnXG4gID4oJ2VkZ2VSZW1vdmVkJyksXG4gIGV2YWx1YXRpb25GaW5pc2hlZDogYWN0aW9uRmFjdG9yeTxcbiAgICB8IHtcbiAgICAgICAgaW5zdGFuY2U6IEFueUF0b21JbnN0YW5jZVxuICAgICAgICB0aW1lOiBudW1iZXJcbiAgICAgIH1cbiAgICB8IHtcbiAgICAgICAgY2FjaGU6IFNlbGVjdG9yQ2FjaGVJdGVtXG4gICAgICAgIHRpbWU6IG51bWJlclxuICAgICAgfSxcbiAgICAnZXZhbHVhdGlvbkZpbmlzaGVkJ1xuICA+KCdldmFsdWF0aW9uRmluaXNoZWQnKSxcbiAgLy8gZWl0aGVyIGNhY2hlIG9yIGluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIGRlZmluZWQsIGRlcGVuZGluZyBvbiB0aGUgbm9kZSB0eXBlXG4gIHN0YXRlQ2hhbmdlZDogYWN0aW9uRmFjdG9yeTxcbiAgICB7XG4gICAgICBhY3Rpb24/OiBBY3Rpb25DaGFpblxuICAgICAgY2FjaGU/OiBTZWxlY3RvckNhY2hlSXRlbVxuICAgICAgaW5zdGFuY2U/OiBBbnlBdG9tSW5zdGFuY2VcbiAgICAgIG5ld1N0YXRlOiBhbnlcbiAgICAgIG9sZFN0YXRlOiBhbnlcbiAgICAgIHJlYXNvbnM6IEV2YWx1YXRpb25SZWFzb25bXVxuICAgIH0sXG4gICAgJ3N0YXRlQ2hhbmdlZCdcbiAgPignc3RhdGVDaGFuZ2VkJyksXG59XG4iXSwibmFtZXMiOlsiYWN0aW9uRmFjdG9yeSIsInBsdWdpbkFjdGlvbnMiLCJhY3RpdmVTdGF0ZUNoYW5nZWQiLCJlY29zeXN0ZW1XaXBlZCIsImVkZ2VDcmVhdGVkIiwiZWRnZVJlbW92ZWQiLCJldmFsdWF0aW9uRmluaXNoZWQiLCJzdGF0ZUNoYW5nZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3299\n")},1881:function(__unused_webpack_module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"KF\": function() { return /* binding */ getInitialPromiseState; },\n/* harmony export */   \"W2\": function() { return /* binding */ getSuccessPromiseState; },\n/* harmony export */   \"bG\": function() { return /* binding */ getErrorPromiseState; }\n/* harmony export */ });\nvar getErrorPromiseState=function getErrorPromiseState(error){return{error:error,isError:true,isLoading:false,isSuccess:false,status:'error'};};var getInitialPromiseState=function getInitialPromiseState(data){return{data:data,isError:false,isLoading:true,isSuccess:false,status:'loading'};};var getSuccessPromiseState=function getSuccessPromiseState(data){return{data:data,isError:false,isLoading:false,isSuccess:true,status:'success'};};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg4MS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUVPLEdBQU1BLHFCQUFvQixDQUFHLFFBQXZCQSxxQkFBb0IsQ0FBT0MsS0FBWSxRQUF1QixDQUN6RUEsS0FBSyxDQUFMQSxLQUFLLENBQ0xDLE9BQU8sQ0FBRSxJQUFJLENBQ2JDLFNBQVMsQ0FBRSxLQUFLLENBQ2hCQyxTQUFTLENBQUUsS0FBSyxDQUNoQkMsTUFBTSxDQUFFLE9BQ1YsQ0FBQyxFQUFDLENBRUssR0FBTUMsdUJBQXNCLENBQUcsUUFBekJBLHVCQUFzQixDQUFPQyxJQUFRLFFBQXVCLENBQ3ZFQSxJQUFJLENBQUpBLElBQUksQ0FDSkwsT0FBTyxDQUFFLEtBQUssQ0FDZEMsU0FBUyxDQUFFLElBQUksQ0FDZkMsU0FBUyxDQUFFLEtBQUssQ0FDaEJDLE1BQU0sQ0FBRSxTQUNWLENBQUMsRUFBQyxDQUVLLEdBQU1HLHVCQUFzQixDQUFHLFFBQXpCQSx1QkFBc0IsQ0FBT0QsSUFBTyxRQUF1QixDQUN0RUEsSUFBSSxDQUFKQSxJQUFJLENBQ0pMLE9BQU8sQ0FBRSxLQUFLLENBQ2RDLFNBQVMsQ0FBRSxLQUFLLENBQ2hCQyxTQUFTLENBQUUsSUFBSSxDQUNmQyxNQUFNLENBQUUsU0FDVixDQUFDLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4uL3BhY2thZ2VzL3JlYWN0L3NyYy91dGlscy9wcm9taXNlVXRpbHMudHM/ZGM5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcm9taXNlU3RhdGUgfSBmcm9tICcuLi90eXBlcydcblxuZXhwb3J0IGNvbnN0IGdldEVycm9yUHJvbWlzZVN0YXRlID0gPFQ+KGVycm9yOiBFcnJvcik6IFByb21pc2VTdGF0ZTxUPiA9PiAoe1xuICBlcnJvcixcbiAgaXNFcnJvcjogdHJ1ZSxcbiAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgaXNTdWNjZXNzOiBmYWxzZSxcbiAgc3RhdHVzOiAnZXJyb3InLFxufSlcblxuZXhwb3J0IGNvbnN0IGdldEluaXRpYWxQcm9taXNlU3RhdGUgPSA8VD4oZGF0YT86IFQpOiBQcm9taXNlU3RhdGU8VD4gPT4gKHtcbiAgZGF0YSxcbiAgaXNFcnJvcjogZmFsc2UsXG4gIGlzTG9hZGluZzogdHJ1ZSxcbiAgaXNTdWNjZXNzOiBmYWxzZSxcbiAgc3RhdHVzOiAnbG9hZGluZycgYXMgY29uc3QsXG59KVxuXG5leHBvcnQgY29uc3QgZ2V0U3VjY2Vzc1Byb21pc2VTdGF0ZSA9IDxUPihkYXRhOiBUKTogUHJvbWlzZVN0YXRlPFQ+ID0+ICh7XG4gIGRhdGEsXG4gIGlzRXJyb3I6IGZhbHNlLFxuICBpc0xvYWRpbmc6IGZhbHNlLFxuICBpc1N1Y2Nlc3M6IHRydWUsXG4gIHN0YXR1czogJ3N1Y2Nlc3MnLFxufSlcbiJdLCJuYW1lcyI6WyJnZXRFcnJvclByb21pc2VTdGF0ZSIsImVycm9yIiwiaXNFcnJvciIsImlzTG9hZGluZyIsImlzU3VjY2VzcyIsInN0YXR1cyIsImdldEluaXRpYWxQcm9taXNlU3RhdGUiLCJkYXRhIiwiZ2V0U3VjY2Vzc1Byb21pc2VTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1881\n")},6907:function(module){"use strict";eval("\n\nmodule.exports = direction\n\nvar RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC'\nvar LTR =\n  'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' +\n  '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' +\n  '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF'\n\nvar rtl = new RegExp('^[^' + LTR + ']*[' + RTL + ']')\nvar ltr = new RegExp('^[^' + RTL + ']*[' + LTR + ']')\n\nfunction direction(value) {\n  value = String(value || '')\n\n  if (rtl.test(value)) {\n    return 'rtl'\n  }\n\n  if (ltr.test(value)) {\n    return 'ltr'\n  }\n\n  return 'neutral'\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjkwNy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL2RpcmVjdGlvbi9pbmRleC5qcz9mNTJmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpcmVjdGlvblxuXG52YXIgUlRMID0gJ1xcdTA1OTEtXFx1MDdGRlxcdUZCMUQtXFx1RkRGRFxcdUZFNzAtXFx1RkVGQydcbnZhciBMVFIgPVxuICAnQS1aYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2JyArXG4gICdcXHUwMEY4LVxcdTAyQjhcXHUwMzAwLVxcdTA1OTBcXHUwODAwLVxcdTFGRkZcXHUyMDBFXFx1MkMwMC1cXHVGQjFDJyArXG4gICdcXHVGRTAwLVxcdUZFNkZcXHVGRUZELVxcdUZGRkYnXG5cbnZhciBydGwgPSBuZXcgUmVnRXhwKCdeW14nICsgTFRSICsgJ10qWycgKyBSVEwgKyAnXScpXG52YXIgbHRyID0gbmV3IFJlZ0V4cCgnXlteJyArIFJUTCArICddKlsnICsgTFRSICsgJ10nKVxuXG5mdW5jdGlvbiBkaXJlY3Rpb24odmFsdWUpIHtcbiAgdmFsdWUgPSBTdHJpbmcodmFsdWUgfHwgJycpXG5cbiAgaWYgKHJ0bC50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiAncnRsJ1xuICB9XG5cbiAgaWYgKGx0ci50ZXN0KHZhbHVlKSkge1xuICAgIHJldHVybiAnbHRyJ1xuICB9XG5cbiAgcmV0dXJuICduZXV0cmFsJ1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6907\n")},8156:function(__unused_webpack_module,exports){"use strict";eval("var __webpack_unused_export__;\n\n\n__webpack_unused_export__ = ({\n  value: true\n});\n\n/**\n * Constants.\n */\n\nvar IS_MAC = typeof window != 'undefined' && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);\n\nvar MODIFIERS = {\n  alt: 'altKey',\n  control: 'ctrlKey',\n  meta: 'metaKey',\n  shift: 'shiftKey'\n};\n\nvar ALIASES = {\n  add: '+',\n  break: 'pause',\n  cmd: 'meta',\n  command: 'meta',\n  ctl: 'control',\n  ctrl: 'control',\n  del: 'delete',\n  down: 'arrowdown',\n  esc: 'escape',\n  ins: 'insert',\n  left: 'arrowleft',\n  mod: IS_MAC ? 'meta' : 'control',\n  opt: 'alt',\n  option: 'alt',\n  return: 'enter',\n  right: 'arrowright',\n  space: ' ',\n  spacebar: ' ',\n  up: 'arrowup',\n  win: 'meta',\n  windows: 'meta'\n};\n\nvar CODES = {\n  backspace: 8,\n  tab: 9,\n  enter: 13,\n  shift: 16,\n  control: 17,\n  alt: 18,\n  pause: 19,\n  capslock: 20,\n  escape: 27,\n  ' ': 32,\n  pageup: 33,\n  pagedown: 34,\n  end: 35,\n  home: 36,\n  arrowleft: 37,\n  arrowup: 38,\n  arrowright: 39,\n  arrowdown: 40,\n  insert: 45,\n  delete: 46,\n  meta: 91,\n  numlock: 144,\n  scrolllock: 145,\n  ';': 186,\n  '=': 187,\n  ',': 188,\n  '-': 189,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '[': 219,\n  '\\\\': 220,\n  ']': 221,\n  '\\'': 222\n};\n\nfor (var f = 1; f < 20; f++) {\n  CODES['f' + f] = 111 + f;\n}\n\n/**\n * Is hotkey?\n */\n\nfunction isHotkey(hotkey, options, event) {\n  if (options && !('byKey' in options)) {\n    event = options;\n    options = null;\n  }\n\n  if (!Array.isArray(hotkey)) {\n    hotkey = [hotkey];\n  }\n\n  var array = hotkey.map(function (string) {\n    return parseHotkey(string, options);\n  });\n  var check = function check(e) {\n    return array.some(function (object) {\n      return compareHotkey(object, e);\n    });\n  };\n  var ret = event == null ? check : check(event);\n  return ret;\n}\n\nfunction isCodeHotkey(hotkey, event) {\n  return isHotkey(hotkey, event);\n}\n\nfunction isKeyHotkey(hotkey, event) {\n  return isHotkey(hotkey, { byKey: true }, event);\n}\n\n/**\n * Parse.\n */\n\nfunction parseHotkey(hotkey, options) {\n  var byKey = options && options.byKey;\n  var ret = {};\n\n  // Special case to handle the `+` key since we use it as a separator.\n  hotkey = hotkey.replace('++', '+add');\n  var values = hotkey.split('+');\n  var length = values.length;\n\n  // Ensure that all the modifiers are set to false unless the hotkey has them.\n\n  for (var k in MODIFIERS) {\n    ret[MODIFIERS[k]] = false;\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var value = _step.value;\n\n      var optional = value.endsWith('?') && value.length > 1;\n\n      if (optional) {\n        value = value.slice(0, -1);\n      }\n\n      var name = toKeyName(value);\n      var modifier = MODIFIERS[name];\n\n      if (length === 1 || !modifier) {\n        if (byKey) {\n          ret.key = name;\n        } else {\n          ret.which = toKeyCode(value);\n        }\n      }\n\n      if (modifier) {\n        ret[modifier] = optional ? null : true;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return ret;\n}\n\n/**\n * Compare.\n */\n\nfunction compareHotkey(object, event) {\n  for (var key in object) {\n    var expected = object[key];\n    var actual = void 0;\n\n    if (expected == null) {\n      continue;\n    }\n\n    if (key === 'key' && event.key != null) {\n      actual = event.key.toLowerCase();\n    } else if (key === 'which') {\n      actual = expected === 91 && event.which === 93 ? 91 : event.which;\n    } else {\n      actual = event[key];\n    }\n\n    if (actual == null && expected === false) {\n      continue;\n    }\n\n    if (actual !== expected) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Utils.\n */\n\nfunction toKeyCode(name) {\n  name = toKeyName(name);\n  var code = CODES[name] || name.toUpperCase().charCodeAt(0);\n  return code;\n}\n\nfunction toKeyName(name) {\n  name = name.toLowerCase();\n  name = ALIASES[name] || name;\n  return name;\n}\n\n/**\n * Export.\n */\n\n__webpack_unused_export__ = isHotkey;\n__webpack_unused_export__ = isHotkey;\n__webpack_unused_export__ = isCodeHotkey;\nexports.TB = isKeyHotkey;\n__webpack_unused_export__ = parseHotkey;\n__webpack_unused_export__ = compareHotkey;\n__webpack_unused_export__ = toKeyCode;\n__webpack_unused_export__ = toKeyName;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODE1Ni5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7O0FBRWIsNkJBQTZDO0FBQzdDO0FBQ0EsQ0FBQyxDQUFDOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsYUFBYTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsZ0VBQWdFO0FBQzNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQWU7QUFDZix5QkFBZ0I7QUFDaEIseUJBQW9CO0FBQ3BCLFVBQW1CO0FBQ25CLHlCQUFtQjtBQUNuQix5QkFBcUI7QUFDckIseUJBQWlCO0FBQ2pCLHlCQUFpQiIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvaXMtaG90a2V5L2xpYi9pbmRleC5qcz9lYzM0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxuLyoqXG4gKiBDb25zdGFudHMuXG4gKi9cblxudmFyIElTX01BQyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgL01hY3xpUG9kfGlQaG9uZXxpUGFkLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pO1xuXG52YXIgTU9ESUZJRVJTID0ge1xuICBhbHQ6ICdhbHRLZXknLFxuICBjb250cm9sOiAnY3RybEtleScsXG4gIG1ldGE6ICdtZXRhS2V5JyxcbiAgc2hpZnQ6ICdzaGlmdEtleSdcbn07XG5cbnZhciBBTElBU0VTID0ge1xuICBhZGQ6ICcrJyxcbiAgYnJlYWs6ICdwYXVzZScsXG4gIGNtZDogJ21ldGEnLFxuICBjb21tYW5kOiAnbWV0YScsXG4gIGN0bDogJ2NvbnRyb2wnLFxuICBjdHJsOiAnY29udHJvbCcsXG4gIGRlbDogJ2RlbGV0ZScsXG4gIGRvd246ICdhcnJvd2Rvd24nLFxuICBlc2M6ICdlc2NhcGUnLFxuICBpbnM6ICdpbnNlcnQnLFxuICBsZWZ0OiAnYXJyb3dsZWZ0JyxcbiAgbW9kOiBJU19NQUMgPyAnbWV0YScgOiAnY29udHJvbCcsXG4gIG9wdDogJ2FsdCcsXG4gIG9wdGlvbjogJ2FsdCcsXG4gIHJldHVybjogJ2VudGVyJyxcbiAgcmlnaHQ6ICdhcnJvd3JpZ2h0JyxcbiAgc3BhY2U6ICcgJyxcbiAgc3BhY2ViYXI6ICcgJyxcbiAgdXA6ICdhcnJvd3VwJyxcbiAgd2luOiAnbWV0YScsXG4gIHdpbmRvd3M6ICdtZXRhJ1xufTtcblxudmFyIENPREVTID0ge1xuICBiYWNrc3BhY2U6IDgsXG4gIHRhYjogOSxcbiAgZW50ZXI6IDEzLFxuICBzaGlmdDogMTYsXG4gIGNvbnRyb2w6IDE3LFxuICBhbHQ6IDE4LFxuICBwYXVzZTogMTksXG4gIGNhcHNsb2NrOiAyMCxcbiAgZXNjYXBlOiAyNyxcbiAgJyAnOiAzMixcbiAgcGFnZXVwOiAzMyxcbiAgcGFnZWRvd246IDM0LFxuICBlbmQ6IDM1LFxuICBob21lOiAzNixcbiAgYXJyb3dsZWZ0OiAzNyxcbiAgYXJyb3d1cDogMzgsXG4gIGFycm93cmlnaHQ6IDM5LFxuICBhcnJvd2Rvd246IDQwLFxuICBpbnNlcnQ6IDQ1LFxuICBkZWxldGU6IDQ2LFxuICBtZXRhOiA5MSxcbiAgbnVtbG9jazogMTQ0LFxuICBzY3JvbGxsb2NrOiAxNDUsXG4gICc7JzogMTg2LFxuICAnPSc6IDE4NyxcbiAgJywnOiAxODgsXG4gICctJzogMTg5LFxuICAnLic6IDE5MCxcbiAgJy8nOiAxOTEsXG4gICdgJzogMTkyLFxuICAnWyc6IDIxOSxcbiAgJ1xcXFwnOiAyMjAsXG4gICddJzogMjIxLFxuICAnXFwnJzogMjIyXG59O1xuXG5mb3IgKHZhciBmID0gMTsgZiA8IDIwOyBmKyspIHtcbiAgQ09ERVNbJ2YnICsgZl0gPSAxMTEgKyBmO1xufVxuXG4vKipcbiAqIElzIGhvdGtleT9cbiAqL1xuXG5mdW5jdGlvbiBpc0hvdGtleShob3RrZXksIG9wdGlvbnMsIGV2ZW50KSB7XG4gIGlmIChvcHRpb25zICYmICEoJ2J5S2V5JyBpbiBvcHRpb25zKSkge1xuICAgIGV2ZW50ID0gb3B0aW9ucztcbiAgICBvcHRpb25zID0gbnVsbDtcbiAgfVxuXG4gIGlmICghQXJyYXkuaXNBcnJheShob3RrZXkpKSB7XG4gICAgaG90a2V5ID0gW2hvdGtleV07XG4gIH1cblxuICB2YXIgYXJyYXkgPSBob3RrZXkubWFwKGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICByZXR1cm4gcGFyc2VIb3RrZXkoc3RyaW5nLCBvcHRpb25zKTtcbiAgfSk7XG4gIHZhciBjaGVjayA9IGZ1bmN0aW9uIGNoZWNrKGUpIHtcbiAgICByZXR1cm4gYXJyYXkuc29tZShmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgICByZXR1cm4gY29tcGFyZUhvdGtleShvYmplY3QsIGUpO1xuICAgIH0pO1xuICB9O1xuICB2YXIgcmV0ID0gZXZlbnQgPT0gbnVsbCA/IGNoZWNrIDogY2hlY2soZXZlbnQpO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpc0NvZGVIb3RrZXkoaG90a2V5LCBldmVudCkge1xuICByZXR1cm4gaXNIb3RrZXkoaG90a2V5LCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIGlzS2V5SG90a2V5KGhvdGtleSwgZXZlbnQpIHtcbiAgcmV0dXJuIGlzSG90a2V5KGhvdGtleSwgeyBieUtleTogdHJ1ZSB9LCBldmVudCk7XG59XG5cbi8qKlxuICogUGFyc2UuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VIb3RrZXkoaG90a2V5LCBvcHRpb25zKSB7XG4gIHZhciBieUtleSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5ieUtleTtcbiAgdmFyIHJldCA9IHt9O1xuXG4gIC8vIFNwZWNpYWwgY2FzZSB0byBoYW5kbGUgdGhlIGArYCBrZXkgc2luY2Ugd2UgdXNlIGl0IGFzIGEgc2VwYXJhdG9yLlxuICBob3RrZXkgPSBob3RrZXkucmVwbGFjZSgnKysnLCAnK2FkZCcpO1xuICB2YXIgdmFsdWVzID0gaG90a2V5LnNwbGl0KCcrJyk7XG4gIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIC8vIEVuc3VyZSB0aGF0IGFsbCB0aGUgbW9kaWZpZXJzIGFyZSBzZXQgdG8gZmFsc2UgdW5sZXNzIHRoZSBob3RrZXkgaGFzIHRoZW0uXG5cbiAgZm9yICh2YXIgayBpbiBNT0RJRklFUlMpIHtcbiAgICByZXRbTU9ESUZJRVJTW2tdXSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gdmFsdWVzW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIHZhbHVlID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIHZhciBvcHRpb25hbCA9IHZhbHVlLmVuZHNXaXRoKCc/JykgJiYgdmFsdWUubGVuZ3RoID4gMTtcblxuICAgICAgaWYgKG9wdGlvbmFsKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IHRvS2V5TmFtZSh2YWx1ZSk7XG4gICAgICB2YXIgbW9kaWZpZXIgPSBNT0RJRklFUlNbbmFtZV07XG5cbiAgICAgIGlmIChsZW5ndGggPT09IDEgfHwgIW1vZGlmaWVyKSB7XG4gICAgICAgIGlmIChieUtleSkge1xuICAgICAgICAgIHJldC5rZXkgPSBuYW1lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldC53aGljaCA9IHRvS2V5Q29kZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGlmaWVyKSB7XG4gICAgICAgIHJldFttb2RpZmllcl0gPSBvcHRpb25hbCA/IG51bGwgOiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybikge1xuICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENvbXBhcmUuXG4gKi9cblxuZnVuY3Rpb24gY29tcGFyZUhvdGtleShvYmplY3QsIGV2ZW50KSB7XG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICB2YXIgZXhwZWN0ZWQgPSBvYmplY3Rba2V5XTtcbiAgICB2YXIgYWN0dWFsID0gdm9pZCAwO1xuXG4gICAgaWYgKGV4cGVjdGVkID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdrZXknICYmIGV2ZW50LmtleSAhPSBudWxsKSB7XG4gICAgICBhY3R1YWwgPSBldmVudC5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3doaWNoJykge1xuICAgICAgYWN0dWFsID0gZXhwZWN0ZWQgPT09IDkxICYmIGV2ZW50LndoaWNoID09PSA5MyA/IDkxIDogZXZlbnQud2hpY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjdHVhbCA9IGV2ZW50W2tleV07XG4gICAgfVxuXG4gICAgaWYgKGFjdHVhbCA9PSBudWxsICYmIGV4cGVjdGVkID09PSBmYWxzZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVdGlscy5cbiAqL1xuXG5mdW5jdGlvbiB0b0tleUNvZGUobmFtZSkge1xuICBuYW1lID0gdG9LZXlOYW1lKG5hbWUpO1xuICB2YXIgY29kZSA9IENPREVTW25hbWVdIHx8IG5hbWUudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApO1xuICByZXR1cm4gY29kZTtcbn1cblxuZnVuY3Rpb24gdG9LZXlOYW1lKG5hbWUpIHtcbiAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbmFtZSA9IEFMSUFTRVNbbmFtZV0gfHwgbmFtZTtcbiAgcmV0dXJuIG5hbWU7XG59XG5cbi8qKlxuICogRXhwb3J0LlxuICovXG5cbmV4cG9ydHMuZGVmYXVsdCA9IGlzSG90a2V5O1xuZXhwb3J0cy5pc0hvdGtleSA9IGlzSG90a2V5O1xuZXhwb3J0cy5pc0NvZGVIb3RrZXkgPSBpc0NvZGVIb3RrZXk7XG5leHBvcnRzLmlzS2V5SG90a2V5ID0gaXNLZXlIb3RrZXk7XG5leHBvcnRzLnBhcnNlSG90a2V5ID0gcGFyc2VIb3RrZXk7XG5leHBvcnRzLmNvbXBhcmVIb3RrZXkgPSBjb21wYXJlSG90a2V5O1xuZXhwb3J0cy50b0tleUNvZGUgPSB0b0tleUNvZGU7XG5leHBvcnRzLnRvS2V5TmFtZSA9IHRvS2V5TmFtZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8156\n")},2705:function(module,__unused_webpack_exports,__webpack_require__){eval("var root = __webpack_require__(5639);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcwNS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsSUFBUzs7QUFFNUI7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TeW1ib2wuanM/Njg0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2705\n")},4239:function(module,__unused_webpack_exports,__webpack_require__){eval("var Symbol = __webpack_require__(2705),\n    getRawTag = __webpack_require__(9607),\n    objectToString = __webpack_require__(2333);\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIzOS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBVztBQUNoQyxnQkFBZ0IsbUJBQU8sQ0FBQyxJQUFjO0FBQ3RDLHFCQUFxQixtQkFBTyxDQUFDLElBQW1COztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldFRhZy5qcz9mNGVkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBnZXRSYXdUYWcgPSByZXF1aXJlKCcuL19nZXRSYXdUYWcnKSxcbiAgICBvYmplY3RUb1N0cmluZyA9IHJlcXVpcmUoJy4vX29iamVjdFRvU3RyaW5nJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRUYWc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4239\n")},7561:function(module,__unused_webpack_exports,__webpack_require__){eval("var trimmedEndIndex = __webpack_require__(7990);\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nmodule.exports = baseTrim;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU2MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQkFBc0IsbUJBQU8sQ0FBQyxJQUFvQjs7QUFFbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUcmltLmpzPzk0NWUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHRyaW1tZWRFbmRJbmRleCA9IHJlcXVpcmUoJy4vX3RyaW1tZWRFbmRJbmRleCcpO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltU3RhcnQgPSAvXlxccysvO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRyaW1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZ1xuICAgID8gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpICsgMSkucmVwbGFjZShyZVRyaW1TdGFydCwgJycpXG4gICAgOiBzdHJpbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVRyaW07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7561\n")},1957:function(module,__unused_webpack_exports,__webpack_require__){eval("/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;\n\nmodule.exports = freeGlobal;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1Ny5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLHdCQUF3QixxQkFBTSxnQkFBZ0IscUJBQU0sSUFBSSxxQkFBTSxzQkFBc0IscUJBQU07O0FBRTFGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanM/MDVmOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1957\n")},9607:function(module,__unused_webpack_exports,__webpack_require__){eval("var Symbol = __webpack_require__(2705);\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYwNy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsSUFBVzs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRSYXdUYWcuanM/ZmM4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRSYXdUYWc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9607\n")},2333:function(module){eval("/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMzMy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcz9kZmRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9iamVjdFRvU3RyaW5nO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2333\n")},5639:function(module,__unused_webpack_exports,__webpack_require__){eval("var freeGlobal = __webpack_require__(1957);\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYzOS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFlOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fcm9vdC5qcz9lZGJmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5639\n")},7990:function(module){eval("/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nmodule.exports = trimmedEndIndex;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzk5MC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdHJpbW1lZEVuZEluZGV4LmpzP2MzYTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFVzZWQgdG8gbWF0Y2ggYSBzaW5nbGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuICovXG52YXIgcmVXaGl0ZXNwYWNlID0gL1xccy87XG5cbi8qKlxuICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZVxuICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAqL1xuZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykge1xuICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkge31cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyaW1tZWRFbmRJbmRleDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7990\n")},3279:function(module,__unused_webpack_exports,__webpack_require__){eval("var isObject = __webpack_require__(3218),\n    now = __webpack_require__(7771),\n    toNumber = __webpack_require__(4841);\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nmodule.exports = debounce;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzI3OS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBWTtBQUNuQyxVQUFVLG1CQUFPLENBQUMsSUFBTztBQUN6QixlQUFlLG1CQUFPLENBQUMsSUFBWTs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUSxXQUFXO0FBQzlCLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlYm91bmNlLmpzP2VhZTQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIG5vdyA9IHJlcXVpcmUoJy4vbm93JyksXG4gICAgdG9OdW1iZXIgPSByZXF1aXJlKCcuL3RvTnVtYmVyJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cbmZ1bmN0aW9uIGRlYm91bmNlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgdmFyIGxhc3RBcmdzLFxuICAgICAgbGFzdFRoaXMsXG4gICAgICBtYXhXYWl0LFxuICAgICAgcmVzdWx0LFxuICAgICAgdGltZXJJZCxcbiAgICAgIGxhc3RDYWxsVGltZSxcbiAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgIGxlYWRpbmcgPSBmYWxzZSxcbiAgICAgIG1heGluZyA9IGZhbHNlLFxuICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgbWF4aW5nID0gJ21heFdhaXQnIGluIG9wdGlvbnM7XG4gICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgdGhpc0FyZyA9IGxhc3RUaGlzO1xuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIC8vIFN0YXJ0IHRoZSB0aW1lciBmb3IgdGhlIHRyYWlsaW5nIGVkZ2UuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgIHJldHVybiBtYXhpbmdcbiAgICAgID8gbmF0aXZlTWluKHRpbWVXYWl0aW5nLCBtYXhXYWl0IC0gdGltZVNpbmNlTGFzdEludm9rZSlcbiAgICAgIDogdGltZVdhaXRpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBzaG91bGRJbnZva2UodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWU7XG5cbiAgICAvLyBFaXRoZXIgdGhpcyBpcyB0aGUgZmlyc3QgY2FsbCwgYWN0aXZpdHkgaGFzIHN0b3BwZWQgYW5kIHdlJ3JlIGF0IHRoZVxuICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgLy8gaXQgYXMgdGhlIHRyYWlsaW5nIGVkZ2UsIG9yIHdlJ3ZlIGhpdCB0aGUgYG1heFdhaXRgIGxpbWl0LlxuICAgIHJldHVybiAobGFzdENhbGxUaW1lID09PSB1bmRlZmluZWQgfHwgKHRpbWVTaW5jZUxhc3RDYWxsID49IHdhaXQpIHx8XG4gICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgcmV0dXJuIHRyYWlsaW5nRWRnZSh0aW1lKTtcbiAgICB9XG4gICAgLy8gUmVzdGFydCB0aGUgdGltZXIuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYWlsaW5nRWRnZSh0aW1lKSB7XG4gICAgdGltZXJJZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cbiAgICBpZiAodHJhaWxpbmcgJiYgbGFzdEFyZ3MpIHtcbiAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgIH1cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBjYW5jZWwoKSB7XG4gICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgIH1cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuXG4gICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG5cbiAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbGVhZGluZ0VkZ2UobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gIGRlYm91bmNlZC5mbHVzaCA9IGZsdXNoO1xuICByZXR1cm4gZGVib3VuY2VkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYm91bmNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3279\n")},3218:function(module){eval("/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nmodule.exports = isObject;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIxOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcz8xNjQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3218\n")},7005:function(module){eval("/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAwNS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzT2JqZWN0TGlrZS5qcz9jYmVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7005\n")},3448:function(module,__unused_webpack_exports,__webpack_require__){eval("var baseGetTag = __webpack_require__(4239),\n    isObjectLike = __webpack_require__(7005);\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nmodule.exports = isSymbol;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ0OC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxJQUFlO0FBQ3hDLG1CQUFtQixtQkFBTyxDQUFDLElBQWdCOztBQUUzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzPzAyODQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3448\n")},7771:function(module,__unused_webpack_exports,__webpack_require__){eval("var root = __webpack_require__(5639);\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nmodule.exports = now;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzc3MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsSUFBUzs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbm93LmpzPzEzNGUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbm93O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7771\n")},3493:function(module,__unused_webpack_exports,__webpack_require__){eval("var debounce = __webpack_require__(3279),\n    isObject = __webpack_require__(3218);\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/**\n * Creates a throttled function that only invokes `func` at most once per\n * every `wait` milliseconds. The throttled function comes with a `cancel`\n * method to cancel delayed `func` invocations and a `flush` method to\n * immediately invoke them. Provide `options` to indicate whether `func`\n * should be invoked on the leading and/or trailing edge of the `wait`\n * timeout. The `func` is invoked with the last arguments provided to the\n * throttled function. Subsequent calls to the throttled function return the\n * result of the last `func` invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the throttled function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.throttle` and `_.debounce`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to throttle.\n * @param {number} [wait=0] The number of milliseconds to throttle invocations to.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=true]\n *  Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new throttled function.\n * @example\n *\n * // Avoid excessively updating the position while scrolling.\n * jQuery(window).on('scroll', _.throttle(updatePosition, 100));\n *\n * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.\n * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });\n * jQuery(element).on('click', throttled);\n *\n * // Cancel the trailing throttled invocation.\n * jQuery(window).on('popstate', throttled.cancel);\n */\nfunction throttle(func, wait, options) {\n  var leading = true,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  if (isObject(options)) {\n    leading = 'leading' in options ? !!options.leading : leading;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n  return debounce(func, wait, {\n    'leading': leading,\n    'maxWait': wait,\n    'trailing': trailing\n  });\n}\n\nmodule.exports = throttle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQ5My5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBWTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsSUFBWTs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUSxXQUFXO0FBQzlCLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsbUJBQW1CO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3Rocm90dGxlLmpzPzE0MGEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGRlYm91bmNlID0gcmVxdWlyZSgnLi9kZWJvdW5jZScpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3493\n")},4841:function(module,__unused_webpack_exports,__webpack_require__){eval("var baseTrim = __webpack_require__(7561),\n    isObject = __webpack_require__(3218),\n    isSymbol = __webpack_require__(3448);\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = toNumber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDg0MS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsSUFBYTtBQUNwQyxlQUFlLG1CQUFPLENBQUMsSUFBWTtBQUNuQyxlQUFlLG1CQUFPLENBQUMsSUFBWTs7QUFFbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vemVkdXgtZG9jcy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9OdW1iZXIuanM/NWQ4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFzZVRyaW0gPSByZXF1aXJlKCcuL19iYXNlVHJpbScpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gYmFzZVRyaW0odmFsdWUpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4841\n")},7594:function(module,exports){eval('/**\n * @param {string} string    The string to parse\n * @returns {Array<number>}  Returns an energetic array.\n */\nfunction parsePart(string) {\n  let res = [];\n  let m;\n\n  for (let str of string.split(",").map((str) => str.trim())) {\n    // just a number\n    if (/^-?\\d+$/.test(str)) {\n      res.push(parseInt(str, 10));\n    } else if (\n      (m = str.match(/^(-?\\d+)(-|\\.\\.\\.?|\\u2025|\\u2026|\\u22EF)(-?\\d+)$/))\n    ) {\n      // 1-5 or 1..5 (equivalent) or 1...5 (doesn\'t include 5)\n      let [_, lhs, sep, rhs] = m;\n\n      if (lhs && rhs) {\n        lhs = parseInt(lhs);\n        rhs = parseInt(rhs);\n        const incr = lhs < rhs ? 1 : -1;\n\n        // Make it inclusive by moving the right \'stop-point\' away by one.\n        if (sep === "-" || sep === ".." || sep === "\\u2025") rhs += incr;\n\n        for (let i = lhs; i !== rhs; i += incr) res.push(i);\n      }\n    }\n  }\n\n  return res;\n}\n\nexports["default"] = parsePart;\nmodule.exports = parsePart;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzU5NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLGdCQUFnQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL3BhcnNlLW51bWVyaWMtcmFuZ2UvaW5kZXguanM/MDc1NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgICAgVGhlIHN0cmluZyB0byBwYXJzZVxuICogQHJldHVybnMge0FycmF5PG51bWJlcj59ICBSZXR1cm5zIGFuIGVuZXJnZXRpYyBhcnJheS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VQYXJ0KHN0cmluZykge1xuICBsZXQgcmVzID0gW107XG4gIGxldCBtO1xuXG4gIGZvciAobGV0IHN0ciBvZiBzdHJpbmcuc3BsaXQoXCIsXCIpLm1hcCgoc3RyKSA9PiBzdHIudHJpbSgpKSkge1xuICAgIC8vIGp1c3QgYSBudW1iZXJcbiAgICBpZiAoL14tP1xcZCskLy50ZXN0KHN0cikpIHtcbiAgICAgIHJlcy5wdXNoKHBhcnNlSW50KHN0ciwgMTApKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgKG0gPSBzdHIubWF0Y2goL14oLT9cXGQrKSgtfFxcLlxcLlxcLj98XFx1MjAyNXxcXHUyMDI2fFxcdTIyRUYpKC0/XFxkKykkLykpXG4gICAgKSB7XG4gICAgICAvLyAxLTUgb3IgMS4uNSAoZXF1aXZhbGVudCkgb3IgMS4uLjUgKGRvZXNuJ3QgaW5jbHVkZSA1KVxuICAgICAgbGV0IFtfLCBsaHMsIHNlcCwgcmhzXSA9IG07XG5cbiAgICAgIGlmIChsaHMgJiYgcmhzKSB7XG4gICAgICAgIGxocyA9IHBhcnNlSW50KGxocyk7XG4gICAgICAgIHJocyA9IHBhcnNlSW50KHJocyk7XG4gICAgICAgIGNvbnN0IGluY3IgPSBsaHMgPCByaHMgPyAxIDogLTE7XG5cbiAgICAgICAgLy8gTWFrZSBpdCBpbmNsdXNpdmUgYnkgbW92aW5nIHRoZSByaWdodCAnc3RvcC1wb2ludCcgYXdheSBieSBvbmUuXG4gICAgICAgIGlmIChzZXAgPT09IFwiLVwiIHx8IHNlcCA9PT0gXCIuLlwiIHx8IHNlcCA9PT0gXCJcXHUyMDI1XCIpIHJocyArPSBpbmNyO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSBsaHM7IGkgIT09IHJoczsgaSArPSBpbmNyKSByZXMucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBwYXJzZVBhcnQ7XG5tb2R1bGUuZXhwb3J0cyA9IHBhcnNlUGFydDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7594\n')},7874:function(){eval("(function (Prism) {\n\t// $ set | grep '^[A-Z][^[:space:]]*=' | cut -d= -f1 | tr '\\n' '|'\n\t// + LC_ALL, RANDOM, REPLY, SECONDS.\n\t// + make sure PS1..4 are here as they are not always set,\n\t// - some useless things.\n\tvar envVars = '\\\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\\\b';\n\n\tvar commandAfterHeredoc = {\n\t\tpattern: /(^([\"']?)\\w+\\2)[ \\t]+\\S.*/,\n\t\tlookbehind: true,\n\t\talias: 'punctuation', // this looks reasonably well in all themes\n\t\tinside: null // see below\n\t};\n\n\tvar insideString = {\n\t\t'bash': commandAfterHeredoc,\n\t\t'environment': {\n\t\t\tpattern: RegExp('\\\\$' + envVars),\n\t\t\talias: 'constant'\n\t\t},\n\t\t'variable': [\n\t\t\t// [0]: Arithmetic Environment\n\t\t\t{\n\t\t\t\tpattern: /\\$?\\(\\([\\s\\S]+?\\)\\)/,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t// If there is a $ sign at the beginning highlight $(( and )) as variable\n\t\t\t\t\t'variable': [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /(^\\$\\(\\([\\s\\S]+)\\)\\)/,\n\t\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t\t},\n\t\t\t\t\t\t/^\\$\\(\\(/\n\t\t\t\t\t],\n\t\t\t\t\t'number': /\\b0x[\\dA-Fa-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee]-?\\d+)?/,\n\t\t\t\t\t// Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic\n\t\t\t\t\t'operator': /--|\\+\\+|\\*\\*=?|<<=?|>>=?|&&|\\|\\||[=!+\\-*/%<>^&|]=?|[?~:]/,\n\t\t\t\t\t// If there is no $ sign at the beginning highlight (( and )) as punctuation\n\t\t\t\t\t'punctuation': /\\(\\(?|\\)\\)?|,|;/\n\t\t\t\t}\n\t\t\t},\n\t\t\t// [1]: Command Substitution\n\t\t\t{\n\t\t\t\tpattern: /\\$\\((?:\\([^)]+\\)|[^()])+\\)|`[^`]+`/,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'variable': /^\\$\\(|^`|\\)$|`$/\n\t\t\t\t}\n\t\t\t},\n\t\t\t// [2]: Brace expansion\n\t\t\t{\n\t\t\t\tpattern: /\\$\\{[^}]+\\}/,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'operator': /:[-=?+]?|[!\\/]|##?|%%?|\\^\\^?|,,?/,\n\t\t\t\t\t'punctuation': /[\\[\\]]/,\n\t\t\t\t\t'environment': {\n\t\t\t\t\t\tpattern: RegExp('(\\\\{)' + envVars),\n\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\talias: 'constant'\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\t/\\$(?:\\w+|[#?*!@$])/\n\t\t],\n\t\t// Escape sequences from echo and printf's manuals, and escaped quotes.\n\t\t'entity': /\\\\(?:[abceEfnrtv\\\\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/\n\t};\n\n\tPrism.languages.bash = {\n\t\t'shebang': {\n\t\t\tpattern: /^#!\\s*\\/.*/,\n\t\t\talias: 'important'\n\t\t},\n\t\t'comment': {\n\t\t\tpattern: /(^|[^\"{\\\\$])#.*/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'function-name': [\n\t\t\t// a) function foo {\n\t\t\t// b) foo() {\n\t\t\t// c) function foo() {\n\t\t\t// but not \u201cfoo {\u201d\n\t\t\t{\n\t\t\t\t// a) and c)\n\t\t\t\tpattern: /(\\bfunction\\s+)[\\w-]+(?=(?:\\s*\\(?:\\s*\\))?\\s*\\{)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'function'\n\t\t\t},\n\t\t\t{\n\t\t\t\t// b)\n\t\t\t\tpattern: /\\b[\\w-]+(?=\\s*\\(\\s*\\)\\s*\\{)/,\n\t\t\t\talias: 'function'\n\t\t\t}\n\t\t],\n\t\t// Highlight variable names as variables in for and select beginnings.\n\t\t'for-or-select': {\n\t\t\tpattern: /(\\b(?:for|select)\\s+)\\w+(?=\\s+in\\s)/,\n\t\t\talias: 'variable',\n\t\t\tlookbehind: true\n\t\t},\n\t\t// Highlight variable names as variables in the left-hand part\n\t\t// of assignments (\u201c=\u201d and \u201c+=\u201d).\n\t\t'assign-left': {\n\t\t\tpattern: /(^|[\\s;|&]|[<>]\\()\\w+(?:\\.\\w+)*(?=\\+?=)/,\n\t\t\tinside: {\n\t\t\t\t'environment': {\n\t\t\t\t\tpattern: RegExp('(^|[\\\\s;|&]|[<>]\\\\()' + envVars),\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'constant'\n\t\t\t\t}\n\t\t\t},\n\t\t\talias: 'variable',\n\t\t\tlookbehind: true\n\t\t},\n\t\t// Highlight parameter names as variables\n\t\t'parameter': {\n\t\t\tpattern: /(^|\\s)-{1,2}(?:\\w+:[+-]?)?\\w+(?:\\.\\w+)*(?=[=\\s]|$)/,\n\t\t\talias: 'variable',\n\t\t\tlookbehind: true\n\t\t},\n\t\t'string': [\n\t\t\t// Support for Here-documents https://en.wikipedia.org/wiki/Here_document\n\t\t\t{\n\t\t\t\tpattern: /((?:^|[^<])<<-?\\s*)(\\w+)\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\2/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: insideString\n\t\t\t},\n\t\t\t// Here-document with quotes around the tag\n\t\t\t// \u2192 No expansion (so no \u201cinside\u201d).\n\t\t\t{\n\t\t\t\tpattern: /((?:^|[^<])<<-?\\s*)([\"'])(\\w+)\\2\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\3/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'bash': commandAfterHeredoc\n\t\t\t\t}\n\t\t\t},\n\t\t\t// \u201cNormal\u201d string\n\t\t\t{\n\t\t\t\t// https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html\n\t\t\t\tpattern: /(^|[^\\\\](?:\\\\\\\\)*)\"(?:\\\\[\\s\\S]|\\$\\([^)]+\\)|\\$(?!\\()|`[^`]+`|[^\"\\\\`$])*\"/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: insideString\n\t\t\t},\n\t\t\t{\n\t\t\t\t// https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html\n\t\t\t\tpattern: /(^|[^$\\\\])'[^']*'/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t{\n\t\t\t\t// https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html\n\t\t\t\tpattern: /\\$'(?:[^'\\\\]|\\\\[\\s\\S])*'/,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'entity': insideString.entity\n\t\t\t\t}\n\t\t\t}\n\t\t],\n\t\t'environment': {\n\t\t\tpattern: RegExp('\\\\$?' + envVars),\n\t\t\talias: 'constant'\n\t\t},\n\t\t'variable': insideString.variable,\n\t\t'function': {\n\t\t\tpattern: /(^|[\\s;|&]|[<>]\\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\\s;|&])/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'keyword': {\n\t\t\tpattern: /(^|[\\s;|&]|[<>]\\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\\s;|&])/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t// https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html\n\t\t'builtin': {\n\t\t\tpattern: /(^|[\\s;|&]|[<>]\\()(?:\\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\\s;|&])/,\n\t\t\tlookbehind: true,\n\t\t\t// Alias added to make those easier to distinguish from strings.\n\t\t\talias: 'class-name'\n\t\t},\n\t\t'boolean': {\n\t\t\tpattern: /(^|[\\s;|&]|[<>]\\()(?:false|true)(?=$|[)\\s;|&])/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'file-descriptor': {\n\t\t\tpattern: /\\B&\\d\\b/,\n\t\t\talias: 'important'\n\t\t},\n\t\t'operator': {\n\t\t\t// Lots of redirections here, but not just that.\n\t\t\tpattern: /\\d?<>|>\\||\\+=|=[=~]?|!=?|<<[<-]?|[&\\d]?>>|\\d[<>]&?|[<>][&=]?|&[>&]?|\\|[&|]?/,\n\t\t\tinside: {\n\t\t\t\t'file-descriptor': {\n\t\t\t\t\tpattern: /^\\d/,\n\t\t\t\t\talias: 'important'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'punctuation': /\\$?\\(\\(?|\\)\\)?|\\.\\.|[{}[\\];\\\\]/,\n\t\t'number': {\n\t\t\tpattern: /(^|\\s)(?:[1-9]\\d*|0)(?:[.,]\\d+)?\\b/,\n\t\t\tlookbehind: true\n\t\t}\n\t};\n\n\tcommandAfterHeredoc.inside = Prism.languages.bash;\n\n\t/* Patterns in command substitution. */\n\tvar toBeCopied = [\n\t\t'comment',\n\t\t'function-name',\n\t\t'for-or-select',\n\t\t'assign-left',\n\t\t'parameter',\n\t\t'string',\n\t\t'environment',\n\t\t'function',\n\t\t'keyword',\n\t\t'builtin',\n\t\t'boolean',\n\t\t'file-descriptor',\n\t\t'operator',\n\t\t'punctuation',\n\t\t'number'\n\t];\n\tvar inside = insideString.variable[1].inside;\n\tfor (var i = 0; i < toBeCopied.length; i++) {\n\t\tinside[toBeCopied[i]] = Prism.languages.bash[toBeCopied[i]];\n\t}\n\n\tPrism.languages.sh = Prism.languages.bash;\n\tPrism.languages.shell = Prism.languages.bash;\n}(Prism));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzg3NC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGtCQUFrQixHQUFHLElBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSSxjQUFjLEVBQUUsY0FBYyxFQUFFLGNBQWMsSUFBSTtBQUNoRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSTtBQUN6QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLCtqREFBK2pEO0FBQ25sRDtBQUNBLEdBQUc7QUFDSDtBQUNBLG9CQUFvQixrR0FBa0c7QUFDdEg7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG9CQUFvQiwrUkFBK1I7QUFDblQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esb0JBQW9CLG1DQUFtQztBQUN2RDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS1iYXNoLmpzPzlhZDIiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChQcmlzbSkge1xuXHQvLyAkIHNldCB8IGdyZXAgJ15bQS1aXVteWzpzcGFjZTpdXSo9JyB8IGN1dCAtZD0gLWYxIHwgdHIgJ1xcbicgJ3wnXG5cdC8vICsgTENfQUxMLCBSQU5ET00sIFJFUExZLCBTRUNPTkRTLlxuXHQvLyArIG1ha2Ugc3VyZSBQUzEuLjQgYXJlIGhlcmUgYXMgdGhleSBhcmUgbm90IGFsd2F5cyBzZXQsXG5cdC8vIC0gc29tZSB1c2VsZXNzIHRoaW5ncy5cblx0dmFyIGVudlZhcnMgPSAnXFxcXGIoPzpCQVNIfEJBU0hPUFRTfEJBU0hfQUxJQVNFU3xCQVNIX0FSR0N8QkFTSF9BUkdWfEJBU0hfQ01EU3xCQVNIX0NPTVBMRVRJT05fQ09NUEFUX0RJUnxCQVNIX0xJTkVOT3xCQVNIX1JFTUFUQ0h8QkFTSF9TT1VSQ0V8QkFTSF9WRVJTSU5GT3xCQVNIX1ZFUlNJT058Q09MT1JURVJNfENPTFVNTlN8Q09NUF9XT1JEQlJFQUtTfERCVVNfU0VTU0lPTl9CVVNfQUREUkVTU3xERUZBVUxUU19QQVRIfERFU0tUT1BfU0VTU0lPTnxESVJTVEFDS3xESVNQTEFZfEVVSUR8R0RNU0VTU0lPTnxHRE1fTEFOR3xHTk9NRV9LRVlSSU5HX0NPTlRST0x8R05PTUVfS0VZUklOR19QSUR8R1BHX0FHRU5UX0lORk98R1JPVVBTfEhJU1RDT05UUk9MfEhJU1RGSUxFfEhJU1RGSUxFU0laRXxISVNUU0laRXxIT01FfEhPU1ROQU1FfEhPU1RUWVBFfElGU3xJTlNUQU5DRXxKT0J8TEFOR3xMQU5HVUFHRXxMQ19BRERSRVNTfExDX0FMTHxMQ19JREVOVElGSUNBVElPTnxMQ19NRUFTVVJFTUVOVHxMQ19NT05FVEFSWXxMQ19OQU1FfExDX05VTUVSSUN8TENfUEFQRVJ8TENfVEVMRVBIT05FfExDX1RJTUV8TEVTU0NMT1NFfExFU1NPUEVOfExJTkVTfExPR05BTUV8TFNfQ09MT1JTfE1BQ0hUWVBFfE1BSUxDSEVDS3xNQU5EQVRPUllfUEFUSHxOT19BVF9CUklER0V8T0xEUFdEfE9QVEVSUnxPUFRJTkR8T1JCSVRfU09DS0VURElSfE9TVFlQRXxQQVBFUlNJWkV8UEFUSHxQSVBFU1RBVFVTfFBQSUR8UFMxfFBTMnxQUzN8UFM0fFBXRHxSQU5ET018UkVQTFl8U0VDT05EU3xTRUxJTlVYX0lOSVR8U0VTU0lPTnxTRVNTSU9OVFlQRXxTRVNTSU9OX01BTkFHRVJ8U0hFTEx8U0hFTExPUFRTfFNITFZMfFNTSF9BVVRIX1NPQ0t8VEVSTXxVSUR8VVBTVEFSVF9FVkVOVFN8VVBTVEFSVF9JTlNUQU5DRXxVUFNUQVJUX0pPQnxVUFNUQVJUX1NFU1NJT058VVNFUnxXSU5ET1dJRHxYQVVUSE9SSVRZfFhER19DT05GSUdfRElSU3xYREdfQ1VSUkVOVF9ERVNLVE9QfFhER19EQVRBX0RJUlN8WERHX0dSRUVURVJfREFUQV9ESVJ8WERHX01FTlVfUFJFRklYfFhER19SVU5USU1FX0RJUnxYREdfU0VBVHxYREdfU0VBVF9QQVRIfFhER19TRVNTSU9OX0RFU0tUT1B8WERHX1NFU1NJT05fSUR8WERHX1NFU1NJT05fUEFUSHxYREdfU0VTU0lPTl9UWVBFfFhER19WVE5SfFhNT0RJRklFUlMpXFxcXGInO1xuXG5cdHZhciBjb21tYW5kQWZ0ZXJIZXJlZG9jID0ge1xuXHRcdHBhdHRlcm46IC8oXihbXCInXT8pXFx3K1xcMilbIFxcdF0rXFxTLiovLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0YWxpYXM6ICdwdW5jdHVhdGlvbicsIC8vIHRoaXMgbG9va3MgcmVhc29uYWJseSB3ZWxsIGluIGFsbCB0aGVtZXNcblx0XHRpbnNpZGU6IG51bGwgLy8gc2VlIGJlbG93XG5cdH07XG5cblx0dmFyIGluc2lkZVN0cmluZyA9IHtcblx0XHQnYmFzaCc6IGNvbW1hbmRBZnRlckhlcmVkb2MsXG5cdFx0J2Vudmlyb25tZW50Jzoge1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKCdcXFxcJCcgKyBlbnZWYXJzKSxcblx0XHRcdGFsaWFzOiAnY29uc3RhbnQnXG5cdFx0fSxcblx0XHQndmFyaWFibGUnOiBbXG5cdFx0XHQvLyBbMF06IEFyaXRobWV0aWMgRW52aXJvbm1lbnRcblx0XHRcdHtcblx0XHRcdFx0cGF0dGVybjogL1xcJD9cXChcXChbXFxzXFxTXSs/XFwpXFwpLyxcblx0XHRcdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhICQgc2lnbiBhdCB0aGUgYmVnaW5uaW5nIGhpZ2hsaWdodCAkKCggYW5kICkpIGFzIHZhcmlhYmxlXG5cdFx0XHRcdFx0J3ZhcmlhYmxlJzogW1xuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRwYXR0ZXJuOiAvKF5cXCRcXChcXChbXFxzXFxTXSspXFwpXFwpLyxcblx0XHRcdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdC9eXFwkXFwoXFwoL1xuXHRcdFx0XHRcdF0sXG5cdFx0XHRcdFx0J251bWJlcic6IC9cXGIweFtcXGRBLUZhLWZdK1xcYnwoPzpcXGJcXGQrKD86XFwuXFxkKik/fFxcQlxcLlxcZCspKD86W0VlXS0/XFxkKyk/Lyxcblx0XHRcdFx0XHQvLyBPcGVyYXRvcnMgYWNjb3JkaW5nIHRvIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvYmFzaHJlZi5odG1sI1NoZWxsLUFyaXRobWV0aWNcblx0XHRcdFx0XHQnb3BlcmF0b3InOiAvLS18XFwrXFwrfFxcKlxcKj0/fDw8PT98Pj49P3wmJnxcXHxcXHx8Wz0hK1xcLSovJTw+XiZ8XT0/fFs/fjpdLyxcblx0XHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBubyAkIHNpZ24gYXQgdGhlIGJlZ2lubmluZyBoaWdobGlnaHQgKCggYW5kICkpIGFzIHB1bmN0dWF0aW9uXG5cdFx0XHRcdFx0J3B1bmN0dWF0aW9uJzogL1xcKFxcKD98XFwpXFwpP3wsfDsvXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvLyBbMV06IENvbW1hbmQgU3Vic3RpdHV0aW9uXG5cdFx0XHR7XG5cdFx0XHRcdHBhdHRlcm46IC9cXCRcXCgoPzpcXChbXildK1xcKXxbXigpXSkrXFwpfGBbXmBdK2AvLFxuXHRcdFx0XHRncmVlZHk6IHRydWUsXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCd2YXJpYWJsZSc6IC9eXFwkXFwofF5gfFxcKSR8YCQvXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvLyBbMl06IEJyYWNlIGV4cGFuc2lvblxuXHRcdFx0e1xuXHRcdFx0XHRwYXR0ZXJuOiAvXFwkXFx7W159XStcXH0vLFxuXHRcdFx0XHRncmVlZHk6IHRydWUsXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdvcGVyYXRvcic6IC86Wy09PytdP3xbIVxcL118IyM/fCUlP3xcXF5cXF4/fCwsPy8sXG5cdFx0XHRcdFx0J3B1bmN0dWF0aW9uJzogL1tcXFtcXF1dLyxcblx0XHRcdFx0XHQnZW52aXJvbm1lbnQnOiB7XG5cdFx0XHRcdFx0XHRwYXR0ZXJuOiBSZWdFeHAoJyhcXFxceyknICsgZW52VmFycyksXG5cdFx0XHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRcdFx0YWxpYXM6ICdjb25zdGFudCdcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvXFwkKD86XFx3K3xbIz8qIUAkXSkvXG5cdFx0XSxcblx0XHQvLyBFc2NhcGUgc2VxdWVuY2VzIGZyb20gZWNobyBhbmQgcHJpbnRmJ3MgbWFudWFscywgYW5kIGVzY2FwZWQgcXVvdGVzLlxuXHRcdCdlbnRpdHknOiAvXFxcXCg/OlthYmNlRWZucnR2XFxcXFwiXXxPP1swLTddezEsM318VVswLTlhLWZBLUZdezh9fHVbMC05YS1mQS1GXXs0fXx4WzAtOWEtZkEtRl17MSwyfSkvXG5cdH07XG5cblx0UHJpc20ubGFuZ3VhZ2VzLmJhc2ggPSB7XG5cdFx0J3NoZWJhbmcnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvXiMhXFxzKlxcLy4qLyxcblx0XHRcdGFsaWFzOiAnaW1wb3J0YW50J1xuXHRcdH0sXG5cdFx0J2NvbW1lbnQnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W15cIntcXFxcJF0pIy4qLyxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRcdCdmdW5jdGlvbi1uYW1lJzogW1xuXHRcdFx0Ly8gYSkgZnVuY3Rpb24gZm9vIHtcblx0XHRcdC8vIGIpIGZvbygpIHtcblx0XHRcdC8vIGMpIGZ1bmN0aW9uIGZvbygpIHtcblx0XHRcdC8vIGJ1dCBub3Qg4oCcZm9vIHvigJ1cblx0XHRcdHtcblx0XHRcdFx0Ly8gYSkgYW5kIGMpXG5cdFx0XHRcdHBhdHRlcm46IC8oXFxiZnVuY3Rpb25cXHMrKVtcXHctXSsoPz0oPzpcXHMqXFwoPzpcXHMqXFwpKT9cXHMqXFx7KS8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGFsaWFzOiAnZnVuY3Rpb24nXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHQvLyBiKVxuXHRcdFx0XHRwYXR0ZXJuOiAvXFxiW1xcdy1dKyg/PVxccypcXChcXHMqXFwpXFxzKlxceykvLFxuXHRcdFx0XHRhbGlhczogJ2Z1bmN0aW9uJ1xuXHRcdFx0fVxuXHRcdF0sXG5cdFx0Ly8gSGlnaGxpZ2h0IHZhcmlhYmxlIG5hbWVzIGFzIHZhcmlhYmxlcyBpbiBmb3IgYW5kIHNlbGVjdCBiZWdpbm5pbmdzLlxuXHRcdCdmb3Itb3Itc2VsZWN0Jzoge1xuXHRcdFx0cGF0dGVybjogLyhcXGIoPzpmb3J8c2VsZWN0KVxccyspXFx3Kyg/PVxccytpblxccykvLFxuXHRcdFx0YWxpYXM6ICd2YXJpYWJsZScsXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHQvLyBIaWdobGlnaHQgdmFyaWFibGUgbmFtZXMgYXMgdmFyaWFibGVzIGluIHRoZSBsZWZ0LWhhbmQgcGFydFxuXHRcdC8vIG9mIGFzc2lnbm1lbnRzICjigJw94oCdIGFuZCDigJwrPeKAnSkuXG5cdFx0J2Fzc2lnbi1sZWZ0Jzoge1xuXHRcdFx0cGF0dGVybjogLyhefFtcXHM7fCZdfFs8Pl1cXCgpXFx3Kyg/OlxcLlxcdyspKig/PVxcKz89KS8sXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J2Vudmlyb25tZW50Jzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IFJlZ0V4cCgnKF58W1xcXFxzO3wmXXxbPD5dXFxcXCgpJyArIGVudlZhcnMpLFxuXHRcdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdFx0YWxpYXM6ICdjb25zdGFudCdcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGFsaWFzOiAndmFyaWFibGUnLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0Ly8gSGlnaGxpZ2h0IHBhcmFtZXRlciBuYW1lcyBhcyB2YXJpYWJsZXNcblx0XHQncGFyYW1ldGVyJzoge1xuXHRcdFx0cGF0dGVybjogLyhefFxccyktezEsMn0oPzpcXHcrOlsrLV0/KT9cXHcrKD86XFwuXFx3KykqKD89Wz1cXHNdfCQpLyxcblx0XHRcdGFsaWFzOiAndmFyaWFibGUnLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0J3N0cmluZyc6IFtcblx0XHRcdC8vIFN1cHBvcnQgZm9yIEhlcmUtZG9jdW1lbnRzIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hlcmVfZG9jdW1lbnRcblx0XHRcdHtcblx0XHRcdFx0cGF0dGVybjogLygoPzpefFtePF0pPDwtP1xccyopKFxcdyspXFxzW1xcc1xcU10qPyg/Olxccj9cXG58XFxyKVxcMi8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdFx0aW5zaWRlOiBpbnNpZGVTdHJpbmdcblx0XHRcdH0sXG5cdFx0XHQvLyBIZXJlLWRvY3VtZW50IHdpdGggcXVvdGVzIGFyb3VuZCB0aGUgdGFnXG5cdFx0XHQvLyDihpIgTm8gZXhwYW5zaW9uIChzbyBubyDigJxpbnNpZGXigJ0pLlxuXHRcdFx0e1xuXHRcdFx0XHRwYXR0ZXJuOiAvKCg/Ol58W148XSk8PC0/XFxzKikoW1wiJ10pKFxcdyspXFwyXFxzW1xcc1xcU10qPyg/Olxccj9cXG58XFxyKVxcMy8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0J2Jhc2gnOiBjb21tYW5kQWZ0ZXJIZXJlZG9jXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQvLyDigJxOb3JtYWzigJ0gc3RyaW5nXG5cdFx0XHR7XG5cdFx0XHRcdC8vIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvaHRtbF9ub2RlL0RvdWJsZS1RdW90ZXMuaHRtbFxuXHRcdFx0XHRwYXR0ZXJuOiAvKF58W15cXFxcXSg/OlxcXFxcXFxcKSopXCIoPzpcXFxcW1xcc1xcU118XFwkXFwoW14pXStcXCl8XFwkKD8hXFwoKXxgW15gXStgfFteXCJcXFxcYCRdKSpcIi8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdFx0aW5zaWRlOiBpbnNpZGVTdHJpbmdcblx0XHRcdH0sXG5cdFx0XHR7XG5cdFx0XHRcdC8vIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvaHRtbF9ub2RlL1NpbmdsZS1RdW90ZXMuaHRtbFxuXHRcdFx0XHRwYXR0ZXJuOiAvKF58W14kXFxcXF0pJ1teJ10qJy8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGdyZWVkeTogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0Ly8gaHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9odG1sX25vZGUvQU5TSV8wMDJkQy1RdW90aW5nLmh0bWxcblx0XHRcdFx0cGF0dGVybjogL1xcJCcoPzpbXidcXFxcXXxcXFxcW1xcc1xcU10pKicvLFxuXHRcdFx0XHRncmVlZHk6IHRydWUsXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdlbnRpdHknOiBpbnNpZGVTdHJpbmcuZW50aXR5XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRdLFxuXHRcdCdlbnZpcm9ubWVudCc6IHtcblx0XHRcdHBhdHRlcm46IFJlZ0V4cCgnXFxcXCQ/JyArIGVudlZhcnMpLFxuXHRcdFx0YWxpYXM6ICdjb25zdGFudCdcblx0XHR9LFxuXHRcdCd2YXJpYWJsZSc6IGluc2lkZVN0cmluZy52YXJpYWJsZSxcblx0XHQnZnVuY3Rpb24nOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzphZGR8YXByb3Bvc3xhcHR8YXB0LWNhY2hlfGFwdC1nZXR8YXB0aXR1ZGV8YXNwZWxsfGF1dG9teXNxbGJhY2t1cHxhd2t8YmFzZW5hbWV8YmFzaHxiY3xiY29uc29sZXxiZ3xiemlwMnxjYWx8Y2FyZ298Y2F0fGNmZGlza3xjaGdycHxjaGtjb25maWd8Y2htb2R8Y2hvd258Y2hyb290fGNrc3VtfGNsZWFyfGNtcHxjb2x1bW58Y29tbXxjb21wb3NlcnxjcHxjcm9ufGNyb250YWJ8Y3NwbGl0fGN1cmx8Y3V0fGRhdGV8ZGN8ZGR8ZGRyZXNjdWV8ZGVib290c3RyYXB8ZGZ8ZGlmZnxkaWZmM3xkaWd8ZGlyfGRpcmNvbG9yc3xkaXJuYW1lfGRpcnN8ZG1lc2d8ZG9ja2VyfGRvY2tlci1jb21wb3NlfGR1fGVncmVwfGVqZWN0fGVudnxldGh0b29sfGV4cGFuZHxleHBlY3R8ZXhwcnxmZGZvcm1hdHxmZGlza3xmZ3xmZ3JlcHxmaWxlfGZpbmR8Zm10fGZvbGR8Zm9ybWF0fGZyZWV8ZnNja3xmdHB8ZnVzZXJ8Z2F3a3xnaXR8Z3BhcnRlZHxncmVwfGdyb3VwYWRkfGdyb3VwZGVsfGdyb3VwbW9kfGdyb3Vwc3xncnViLW1rY29uZmlnfGd6aXB8aGFsdHxoZWFkfGhnfGhpc3Rvcnl8aG9zdHxob3N0bmFtZXxodG9wfGljb252fGlkfGlmY29uZmlnfGlmZG93bnxpZnVwfGltcG9ydHxpbnN0YWxsfGlwfGphdmF8am9ic3xqb2lufGtpbGx8a2lsbGFsbHxsZXNzfGxpbmt8bG58bG9jYXRlfGxvZ25hbWV8bG9ncm90YXRlfGxvb2t8bHBjfGxwcnxscHJpbnR8bHByaW50ZHxscHJpbnRxfGxwcm18bHN8bHNvZnxseW54fG1ha2V8bWFufG1jfG1kYWRtfG1rY29uZmlnfG1rZGlyfG1rZTJmc3xta2ZpZm98bWtmc3xta2lzb2ZzfG1rbm9kfG1rc3dhcHxtbXZ8bW9yZXxtb3N0fG1vdW50fG10b29sc3xtdHJ8bXV0dHxtdnxuYW5vfG5jfG5ldHN0YXR8bmljZXxubHxub2RlfG5vaHVwfG5vdGlmeS1zZW5kfG5wbXxuc2xvb2t1cHxvcHxvcGVufHBhcnRlZHxwYXNzd2R8cGFzdGV8cGF0aGNoa3xwaW5nfHBraWxsfHBucG18cG9kbWFufHBvZG1hbi1jb21wb3NlfHBvcGR8cHJ8cHJpbnRjYXB8cHJpbnRlbnZ8cHN8cHVzaGR8cHZ8cXVvdGF8cXVvdGFjaGVja3xxdW90YWN0bHxyYW18cmFyfHJjcHxyZWJvb3R8cmVtc3luY3xyZW5hbWV8cmVuaWNlfHJldnxybXxybWRpcnxycG18cnN5bmN8c2NwfHNjcmVlbnxzZGlmZnxzZWR8c2VuZG1haWx8c2VxfHNlcnZpY2V8c2Z0cHxzaHxzaGVsbGNoZWNrfHNodWZ8c2h1dGRvd258c2xlZXB8c2xvY2F0ZXxzb3J0fHNwbGl0fHNzaHxzdGF0fHN0cmFjZXxzdXxzdWRvfHN1bXxzdXNwZW5kfHN3YXBvbnxzeW5jfHN5c2N0bHx0YWN8dGFpbHx0YXJ8dGVlfHRpbWV8dGltZW91dHx0b3B8dG91Y2h8dHJ8dHJhY2Vyb3V0ZXx0c29ydHx0dHl8dW1vdW50fHVuYW1lfHVuZXhwYW5kfHVuaXF8dW5pdHN8dW5yYXJ8dW5zaGFyfHVuemlwfHVwZGF0ZS1ncnVifHVwdGltZXx1c2VyYWRkfHVzZXJkZWx8dXNlcm1vZHx1c2Vyc3x1dWRlY29kZXx1dWVuY29kZXx2fHZjcGtnfHZkaXJ8dml8dmltfHZpcnNofHZtc3RhdHx3YWl0fHdhdGNofHdjfHdnZXR8d2hlcmVpc3x3aGljaHx3aG98d2hvYW1pfHdyaXRlfHhhcmdzfHhkZy1vcGVufHlhcm58eWVzfHplbml0eXx6aXB8enNofHp5cHBlcikoPz0kfFspXFxzO3wmXSkvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0J2tleXdvcmQnOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzpjYXNlfGRvfGRvbmV8ZWxpZnxlbHNlfGVzYWN8Zml8Zm9yfGZ1bmN0aW9ufGlmfGlufHNlbGVjdHx0aGVufHVudGlsfHdoaWxlKSg/PSR8WylcXHM7fCZdKS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHQvLyBodHRwczovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2h0bWxfbm9kZS9TaGVsbC1CdWlsdGluLUNvbW1hbmRzLmh0bWxcblx0XHQnYnVpbHRpbic6IHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXFxzO3wmXXxbPD5dXFwoKSg/OlxcLnw6fGFsaWFzfGJpbmR8YnJlYWt8YnVpbHRpbnxjYWxsZXJ8Y2R8Y29tbWFuZHxjb250aW51ZXxkZWNsYXJlfGVjaG98ZW5hYmxlfGV2YWx8ZXhlY3xleGl0fGV4cG9ydHxnZXRvcHRzfGhhc2h8aGVscHxsZXR8bG9jYWx8bG9nb3V0fG1hcGZpbGV8cHJpbnRmfHB3ZHxyZWFkfHJlYWRhcnJheXxyZWFkb25seXxyZXR1cm58c2V0fHNoaWZ0fHNob3B0fHNvdXJjZXx0ZXN0fHRpbWVzfHRyYXB8dHlwZXx0eXBlc2V0fHVsaW1pdHx1bWFza3x1bmFsaWFzfHVuc2V0KSg/PSR8WylcXHM7fCZdKS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0Ly8gQWxpYXMgYWRkZWQgdG8gbWFrZSB0aG9zZSBlYXNpZXIgdG8gZGlzdGluZ3Vpc2ggZnJvbSBzdHJpbmdzLlxuXHRcdFx0YWxpYXM6ICdjbGFzcy1uYW1lJ1xuXHRcdH0sXG5cdFx0J2Jvb2xlYW4nOiB7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKCkoPzpmYWxzZXx0cnVlKSg/PSR8WylcXHM7fCZdKS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHQnZmlsZS1kZXNjcmlwdG9yJzoge1xuXHRcdFx0cGF0dGVybjogL1xcQiZcXGRcXGIvLFxuXHRcdFx0YWxpYXM6ICdpbXBvcnRhbnQnXG5cdFx0fSxcblx0XHQnb3BlcmF0b3InOiB7XG5cdFx0XHQvLyBMb3RzIG9mIHJlZGlyZWN0aW9ucyBoZXJlLCBidXQgbm90IGp1c3QgdGhhdC5cblx0XHRcdHBhdHRlcm46IC9cXGQ/PD58PlxcfHxcXCs9fD1bPX5dP3whPT98PDxbPC1dP3xbJlxcZF0/Pj58XFxkWzw+XSY/fFs8Pl1bJj1dP3wmWz4mXT98XFx8WyZ8XT8vLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdmaWxlLWRlc2NyaXB0b3InOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogL15cXGQvLFxuXHRcdFx0XHRcdGFsaWFzOiAnaW1wb3J0YW50J1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQncHVuY3R1YXRpb24nOiAvXFwkP1xcKFxcKD98XFwpXFwpP3xcXC5cXC58W3t9W1xcXTtcXFxcXS8sXG5cdFx0J251bWJlcic6IHtcblx0XHRcdHBhdHRlcm46IC8oXnxcXHMpKD86WzEtOV1cXGQqfDApKD86Wy4sXVxcZCspP1xcYi8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fVxuXHR9O1xuXG5cdGNvbW1hbmRBZnRlckhlcmVkb2MuaW5zaWRlID0gUHJpc20ubGFuZ3VhZ2VzLmJhc2g7XG5cblx0LyogUGF0dGVybnMgaW4gY29tbWFuZCBzdWJzdGl0dXRpb24uICovXG5cdHZhciB0b0JlQ29waWVkID0gW1xuXHRcdCdjb21tZW50Jyxcblx0XHQnZnVuY3Rpb24tbmFtZScsXG5cdFx0J2Zvci1vci1zZWxlY3QnLFxuXHRcdCdhc3NpZ24tbGVmdCcsXG5cdFx0J3BhcmFtZXRlcicsXG5cdFx0J3N0cmluZycsXG5cdFx0J2Vudmlyb25tZW50Jyxcblx0XHQnZnVuY3Rpb24nLFxuXHRcdCdrZXl3b3JkJyxcblx0XHQnYnVpbHRpbicsXG5cdFx0J2Jvb2xlYW4nLFxuXHRcdCdmaWxlLWRlc2NyaXB0b3InLFxuXHRcdCdvcGVyYXRvcicsXG5cdFx0J3B1bmN0dWF0aW9uJyxcblx0XHQnbnVtYmVyJ1xuXHRdO1xuXHR2YXIgaW5zaWRlID0gaW5zaWRlU3RyaW5nLnZhcmlhYmxlWzFdLmluc2lkZTtcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b0JlQ29waWVkLmxlbmd0aDsgaSsrKSB7XG5cdFx0aW5zaWRlW3RvQmVDb3BpZWRbaV1dID0gUHJpc20ubGFuZ3VhZ2VzLmJhc2hbdG9CZUNvcGllZFtpXV07XG5cdH1cblxuXHRQcmlzbS5sYW5ndWFnZXMuc2ggPSBQcmlzbS5sYW5ndWFnZXMuYmFzaDtcblx0UHJpc20ubGFuZ3VhZ2VzLnNoZWxsID0gUHJpc20ubGFuZ3VhZ2VzLmJhc2g7XG59KFByaXNtKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7874\n")},2356:function(){eval("(function (Prism) {\n\n\tvar javascript = Prism.util.clone(Prism.languages.javascript);\n\n\tvar space = /(?:\\s|\\/\\/.*(?!.)|\\/\\*(?:[^*]|\\*(?!\\/))\\*\\/)/.source;\n\tvar braces = /(?:\\{(?:\\{(?:\\{[^{}]*\\}|[^{}])*\\}|[^{}])*\\})/.source;\n\tvar spread = /(?:\\{<S>*\\.{3}(?:[^{}]|<BRACES>)*\\})/.source;\n\n\t/**\n\t * @param {string} source\n\t * @param {string} [flags]\n\t */\n\tfunction re(source, flags) {\n\t\tsource = source\n\t\t\t.replace(/<S>/g, function () { return space; })\n\t\t\t.replace(/<BRACES>/g, function () { return braces; })\n\t\t\t.replace(/<SPREAD>/g, function () { return spread; });\n\t\treturn RegExp(source, flags);\n\t}\n\n\tspread = re(spread).source;\n\n\n\tPrism.languages.jsx = Prism.languages.extend('markup', javascript);\n\tPrism.languages.jsx.tag.pattern = re(\n\t\t/<\\/?(?:[\\w.:-]+(?:<S>+(?:[\\w.:$-]+(?:=(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s{'\"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\\/?)?>/.source\n\t);\n\n\tPrism.languages.jsx.tag.inside['tag'].pattern = /^<\\/?[^\\s>\\/]*/;\n\tPrism.languages.jsx.tag.inside['attr-value'].pattern = /=(?!\\{)(?:\"(?:\\\\[\\s\\S]|[^\\\\\"])*\"|'(?:\\\\[\\s\\S]|[^\\\\'])*'|[^\\s'\">]+)/;\n\tPrism.languages.jsx.tag.inside['tag'].inside['class-name'] = /^[A-Z]\\w*(?:\\.[A-Z]\\w*)*$/;\n\tPrism.languages.jsx.tag.inside['comment'] = javascript['comment'];\n\n\tPrism.languages.insertBefore('inside', 'attr-name', {\n\t\t'spread': {\n\t\t\tpattern: re(/<SPREAD>/.source),\n\t\t\tinside: Prism.languages.jsx\n\t\t}\n\t}, Prism.languages.jsx.tag);\n\n\tPrism.languages.insertBefore('inside', 'special-attr', {\n\t\t'script': {\n\t\t\t// Allow for two levels of nesting\n\t\t\tpattern: re(/=<BRACES>/.source),\n\t\t\talias: 'language-javascript',\n\t\t\tinside: {\n\t\t\t\t'script-punctuation': {\n\t\t\t\t\tpattern: /^=(?=\\{)/,\n\t\t\t\t\talias: 'punctuation'\n\t\t\t\t},\n\t\t\t\trest: Prism.languages.jsx\n\t\t\t},\n\t\t}\n\t}, Prism.languages.jsx.tag);\n\n\t// The following will handle plain text inside tags\n\tvar stringifyToken = function (token) {\n\t\tif (!token) {\n\t\t\treturn '';\n\t\t}\n\t\tif (typeof token === 'string') {\n\t\t\treturn token;\n\t\t}\n\t\tif (typeof token.content === 'string') {\n\t\t\treturn token.content;\n\t\t}\n\t\treturn token.content.map(stringifyToken).join('');\n\t};\n\n\tvar walkTokens = function (tokens) {\n\t\tvar openedTags = [];\n\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\tvar token = tokens[i];\n\t\t\tvar notTagNorBrace = false;\n\n\t\t\tif (typeof token !== 'string') {\n\t\t\t\tif (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {\n\t\t\t\t\t// We found a tag, now find its kind\n\n\t\t\t\t\tif (token.content[0].content[0].content === '</') {\n\t\t\t\t\t\t// Closing tag\n\t\t\t\t\t\tif (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token.content[0].content[1])) {\n\t\t\t\t\t\t\t// Pop matching opening tag\n\t\t\t\t\t\t\topenedTags.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (token.content[token.content.length - 1].content === '/>') {\n\t\t\t\t\t\t\t// Autoclosed tag, ignore\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Opening tag\n\t\t\t\t\t\t\topenedTags.push({\n\t\t\t\t\t\t\t\ttagName: stringifyToken(token.content[0].content[1]),\n\t\t\t\t\t\t\t\topenedBraces: 0\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (openedTags.length > 0 && token.type === 'punctuation' && token.content === '{') {\n\n\t\t\t\t\t// Here we might have entered a JSX context inside a tag\n\t\t\t\t\topenedTags[openedTags.length - 1].openedBraces++;\n\n\t\t\t\t} else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token.type === 'punctuation' && token.content === '}') {\n\n\t\t\t\t\t// Here we might have left a JSX context inside a tag\n\t\t\t\t\topenedTags[openedTags.length - 1].openedBraces--;\n\n\t\t\t\t} else {\n\t\t\t\t\tnotTagNorBrace = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (notTagNorBrace || typeof token === 'string') {\n\t\t\t\tif (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {\n\t\t\t\t\t// Here we are inside a tag, and not inside a JSX context.\n\t\t\t\t\t// That's plain text: drop any tokens matched.\n\t\t\t\t\tvar plainText = stringifyToken(token);\n\n\t\t\t\t\t// And merge text with adjacent text\n\t\t\t\t\tif (i < tokens.length - 1 && (typeof tokens[i + 1] === 'string' || tokens[i + 1].type === 'plain-text')) {\n\t\t\t\t\t\tplainText += stringifyToken(tokens[i + 1]);\n\t\t\t\t\t\ttokens.splice(i + 1, 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (i > 0 && (typeof tokens[i - 1] === 'string' || tokens[i - 1].type === 'plain-text')) {\n\t\t\t\t\t\tplainText = stringifyToken(tokens[i - 1]) + plainText;\n\t\t\t\t\t\ttokens.splice(i - 1, 1);\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\n\t\t\t\t\ttokens[i] = new Prism.Token('plain-text', plainText, null, plainText);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (token.content && typeof token.content !== 'string') {\n\t\t\t\twalkTokens(token.content);\n\t\t\t}\n\t\t}\n\t};\n\n\tPrism.hooks.add('after-tokenize', function (env) {\n\t\tif (env.language !== 'jsx' && env.language !== 'tsx') {\n\t\t\treturn;\n\t\t}\n\t\twalkTokens(env.tokens);\n\t});\n\n}(Prism));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjM1Ni5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQixLQUFLLEtBQUssSUFBSSxJQUFJLEtBQUssS0FBSyxLQUFLLEtBQUs7QUFDMUQsb0JBQW9CLE9BQU8sRUFBRSxPQUFPLGNBQWM7O0FBRWxEO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZTtBQUNqRCx1Q0FBdUMsZ0JBQWdCO0FBQ3ZELHVDQUF1QyxnQkFBZ0I7QUFDdkQ7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjs7QUFFQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTSxzRkFBc0Y7O0FBRTVGO0FBQ0E7O0FBRUEsTUFBTSw0SUFBNEk7O0FBRWxKO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUYsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvcHJpc21qcy9jb21wb25lbnRzL3ByaXNtLWpzeC5qcz9mOTY5Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoUHJpc20pIHtcblxuXHR2YXIgamF2YXNjcmlwdCA9IFByaXNtLnV0aWwuY2xvbmUoUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQpO1xuXG5cdHZhciBzcGFjZSA9IC8oPzpcXHN8XFwvXFwvLiooPyEuKXxcXC9cXCooPzpbXipdfFxcKig/IVxcLykpXFwqXFwvKS8uc291cmNlO1xuXHR2YXIgYnJhY2VzID0gLyg/Olxceyg/Olxceyg/Olxce1tee31dKlxcfXxbXnt9XSkqXFx9fFtee31dKSpcXH0pLy5zb3VyY2U7XG5cdHZhciBzcHJlYWQgPSAvKD86XFx7PFM+KlxcLnszfSg/Oltee31dfDxCUkFDRVM+KSpcXH0pLy5zb3VyY2U7XG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2Vcblx0ICogQHBhcmFtIHtzdHJpbmd9IFtmbGFnc11cblx0ICovXG5cdGZ1bmN0aW9uIHJlKHNvdXJjZSwgZmxhZ3MpIHtcblx0XHRzb3VyY2UgPSBzb3VyY2Vcblx0XHRcdC5yZXBsYWNlKC88Uz4vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gc3BhY2U7IH0pXG5cdFx0XHQucmVwbGFjZSgvPEJSQUNFUz4vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gYnJhY2VzOyB9KVxuXHRcdFx0LnJlcGxhY2UoLzxTUFJFQUQ+L2csIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNwcmVhZDsgfSk7XG5cdFx0cmV0dXJuIFJlZ0V4cChzb3VyY2UsIGZsYWdzKTtcblx0fVxuXG5cdHNwcmVhZCA9IHJlKHNwcmVhZCkuc291cmNlO1xuXG5cblx0UHJpc20ubGFuZ3VhZ2VzLmpzeCA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ21hcmt1cCcsIGphdmFzY3JpcHQpO1xuXHRQcmlzbS5sYW5ndWFnZXMuanN4LnRhZy5wYXR0ZXJuID0gcmUoXG5cdFx0LzxcXC8/KD86W1xcdy46LV0rKD86PFM+Kyg/OltcXHcuOiQtXSsoPzo9KD86XCIoPzpcXFxcW1xcc1xcU118W15cXFxcXCJdKSpcInwnKD86XFxcXFtcXHNcXFNdfFteXFxcXCddKSonfFteXFxzeydcIi8+PV0rfDxCUkFDRVM+KSk/fDxTUFJFQUQ+KSkqPFM+KlxcLz8pPz4vLnNvdXJjZVxuXHQpO1xuXG5cdFByaXNtLmxhbmd1YWdlcy5qc3gudGFnLmluc2lkZVsndGFnJ10ucGF0dGVybiA9IC9ePFxcLz9bXlxccz5cXC9dKi87XG5cdFByaXNtLmxhbmd1YWdlcy5qc3gudGFnLmluc2lkZVsnYXR0ci12YWx1ZSddLnBhdHRlcm4gPSAvPSg/IVxceykoPzpcIig/OlxcXFxbXFxzXFxTXXxbXlxcXFxcIl0pKlwifCcoPzpcXFxcW1xcc1xcU118W15cXFxcJ10pKid8W15cXHMnXCI+XSspLztcblx0UHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcuaW5zaWRlWyd0YWcnXS5pbnNpZGVbJ2NsYXNzLW5hbWUnXSA9IC9eW0EtWl1cXHcqKD86XFwuW0EtWl1cXHcqKSokLztcblx0UHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcuaW5zaWRlWydjb21tZW50J10gPSBqYXZhc2NyaXB0Wydjb21tZW50J107XG5cblx0UHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnaW5zaWRlJywgJ2F0dHItbmFtZScsIHtcblx0XHQnc3ByZWFkJzoge1xuXHRcdFx0cGF0dGVybjogcmUoLzxTUFJFQUQ+Ly5zb3VyY2UpLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuanN4XG5cdFx0fVxuXHR9LCBQcmlzbS5sYW5ndWFnZXMuanN4LnRhZyk7XG5cblx0UHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnaW5zaWRlJywgJ3NwZWNpYWwtYXR0cicsIHtcblx0XHQnc2NyaXB0Jzoge1xuXHRcdFx0Ly8gQWxsb3cgZm9yIHR3byBsZXZlbHMgb2YgbmVzdGluZ1xuXHRcdFx0cGF0dGVybjogcmUoLz08QlJBQ0VTPi8uc291cmNlKSxcblx0XHRcdGFsaWFzOiAnbGFuZ3VhZ2UtamF2YXNjcmlwdCcsXG5cdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0J3NjcmlwdC1wdW5jdHVhdGlvbic6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvXj0oPz1cXHspLyxcblx0XHRcdFx0XHRhbGlhczogJ3B1bmN0dWF0aW9uJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZXN0OiBQcmlzbS5sYW5ndWFnZXMuanN4XG5cdFx0XHR9LFxuXHRcdH1cblx0fSwgUHJpc20ubGFuZ3VhZ2VzLmpzeC50YWcpO1xuXG5cdC8vIFRoZSBmb2xsb3dpbmcgd2lsbCBoYW5kbGUgcGxhaW4gdGV4dCBpbnNpZGUgdGFnc1xuXHR2YXIgc3RyaW5naWZ5VG9rZW4gPSBmdW5jdGlvbiAodG9rZW4pIHtcblx0XHRpZiAoIXRva2VuKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gdG9rZW47XG5cdFx0fVxuXHRcdGlmICh0eXBlb2YgdG9rZW4uY29udGVudCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiB0b2tlbi5jb250ZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gdG9rZW4uY29udGVudC5tYXAoc3RyaW5naWZ5VG9rZW4pLmpvaW4oJycpO1xuXHR9O1xuXG5cdHZhciB3YWxrVG9rZW5zID0gZnVuY3Rpb24gKHRva2Vucykge1xuXHRcdHZhciBvcGVuZWRUYWdzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblx0XHRcdHZhciBub3RUYWdOb3JCcmFjZSA9IGZhbHNlO1xuXG5cdFx0XHRpZiAodHlwZW9mIHRva2VuICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRpZiAodG9rZW4udHlwZSA9PT0gJ3RhZycgJiYgdG9rZW4uY29udGVudFswXSAmJiB0b2tlbi5jb250ZW50WzBdLnR5cGUgPT09ICd0YWcnKSB7XG5cdFx0XHRcdFx0Ly8gV2UgZm91bmQgYSB0YWcsIG5vdyBmaW5kIGl0cyBraW5kXG5cblx0XHRcdFx0XHRpZiAodG9rZW4uY29udGVudFswXS5jb250ZW50WzBdLmNvbnRlbnQgPT09ICc8LycpIHtcblx0XHRcdFx0XHRcdC8vIENsb3NpbmcgdGFnXG5cdFx0XHRcdFx0XHRpZiAob3BlbmVkVGFncy5sZW5ndGggPiAwICYmIG9wZW5lZFRhZ3Nbb3BlbmVkVGFncy5sZW5ndGggLSAxXS50YWdOYW1lID09PSBzdHJpbmdpZnlUb2tlbih0b2tlbi5jb250ZW50WzBdLmNvbnRlbnRbMV0pKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFBvcCBtYXRjaGluZyBvcGVuaW5nIHRhZ1xuXHRcdFx0XHRcdFx0XHRvcGVuZWRUYWdzLnBvcCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAodG9rZW4uY29udGVudFt0b2tlbi5jb250ZW50Lmxlbmd0aCAtIDFdLmNvbnRlbnQgPT09ICcvPicpIHtcblx0XHRcdFx0XHRcdFx0Ly8gQXV0b2Nsb3NlZCB0YWcsIGlnbm9yZVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gT3BlbmluZyB0YWdcblx0XHRcdFx0XHRcdFx0b3BlbmVkVGFncy5wdXNoKHtcblx0XHRcdFx0XHRcdFx0XHR0YWdOYW1lOiBzdHJpbmdpZnlUb2tlbih0b2tlbi5jb250ZW50WzBdLmNvbnRlbnRbMV0pLFxuXHRcdFx0XHRcdFx0XHRcdG9wZW5lZEJyYWNlczogMFxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAob3BlbmVkVGFncy5sZW5ndGggPiAwICYmIHRva2VuLnR5cGUgPT09ICdwdW5jdHVhdGlvbicgJiYgdG9rZW4uY29udGVudCA9PT0gJ3snKSB7XG5cblx0XHRcdFx0XHQvLyBIZXJlIHdlIG1pZ2h0IGhhdmUgZW50ZXJlZCBhIEpTWCBjb250ZXh0IGluc2lkZSBhIHRhZ1xuXHRcdFx0XHRcdG9wZW5lZFRhZ3Nbb3BlbmVkVGFncy5sZW5ndGggLSAxXS5vcGVuZWRCcmFjZXMrKztcblxuXHRcdFx0XHR9IGVsc2UgaWYgKG9wZW5lZFRhZ3MubGVuZ3RoID4gMCAmJiBvcGVuZWRUYWdzW29wZW5lZFRhZ3MubGVuZ3RoIC0gMV0ub3BlbmVkQnJhY2VzID4gMCAmJiB0b2tlbi50eXBlID09PSAncHVuY3R1YXRpb24nICYmIHRva2VuLmNvbnRlbnQgPT09ICd9Jykge1xuXG5cdFx0XHRcdFx0Ly8gSGVyZSB3ZSBtaWdodCBoYXZlIGxlZnQgYSBKU1ggY29udGV4dCBpbnNpZGUgYSB0YWdcblx0XHRcdFx0XHRvcGVuZWRUYWdzW29wZW5lZFRhZ3MubGVuZ3RoIC0gMV0ub3BlbmVkQnJhY2VzLS07XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub3RUYWdOb3JCcmFjZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChub3RUYWdOb3JCcmFjZSB8fCB0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGlmIChvcGVuZWRUYWdzLmxlbmd0aCA+IDAgJiYgb3BlbmVkVGFnc1tvcGVuZWRUYWdzLmxlbmd0aCAtIDFdLm9wZW5lZEJyYWNlcyA9PT0gMCkge1xuXHRcdFx0XHRcdC8vIEhlcmUgd2UgYXJlIGluc2lkZSBhIHRhZywgYW5kIG5vdCBpbnNpZGUgYSBKU1ggY29udGV4dC5cblx0XHRcdFx0XHQvLyBUaGF0J3MgcGxhaW4gdGV4dDogZHJvcCBhbnkgdG9rZW5zIG1hdGNoZWQuXG5cdFx0XHRcdFx0dmFyIHBsYWluVGV4dCA9IHN0cmluZ2lmeVRva2VuKHRva2VuKTtcblxuXHRcdFx0XHRcdC8vIEFuZCBtZXJnZSB0ZXh0IHdpdGggYWRqYWNlbnQgdGV4dFxuXHRcdFx0XHRcdGlmIChpIDwgdG9rZW5zLmxlbmd0aCAtIDEgJiYgKHR5cGVvZiB0b2tlbnNbaSArIDFdID09PSAnc3RyaW5nJyB8fCB0b2tlbnNbaSArIDFdLnR5cGUgPT09ICdwbGFpbi10ZXh0JykpIHtcblx0XHRcdFx0XHRcdHBsYWluVGV4dCArPSBzdHJpbmdpZnlUb2tlbih0b2tlbnNbaSArIDFdKTtcblx0XHRcdFx0XHRcdHRva2Vucy5zcGxpY2UoaSArIDEsIDEpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoaSA+IDAgJiYgKHR5cGVvZiB0b2tlbnNbaSAtIDFdID09PSAnc3RyaW5nJyB8fCB0b2tlbnNbaSAtIDFdLnR5cGUgPT09ICdwbGFpbi10ZXh0JykpIHtcblx0XHRcdFx0XHRcdHBsYWluVGV4dCA9IHN0cmluZ2lmeVRva2VuKHRva2Vuc1tpIC0gMV0pICsgcGxhaW5UZXh0O1xuXHRcdFx0XHRcdFx0dG9rZW5zLnNwbGljZShpIC0gMSwgMSk7XG5cdFx0XHRcdFx0XHRpLS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dG9rZW5zW2ldID0gbmV3IFByaXNtLlRva2VuKCdwbGFpbi10ZXh0JywgcGxhaW5UZXh0LCBudWxsLCBwbGFpblRleHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0b2tlbi5jb250ZW50ICYmIHR5cGVvZiB0b2tlbi5jb250ZW50ICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHR3YWxrVG9rZW5zKHRva2VuLmNvbnRlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRQcmlzbS5ob29rcy5hZGQoJ2FmdGVyLXRva2VuaXplJywgZnVuY3Rpb24gKGVudikge1xuXHRcdGlmIChlbnYubGFuZ3VhZ2UgIT09ICdqc3gnICYmIGVudi5sYW5ndWFnZSAhPT0gJ3RzeCcpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0d2Fsa1Rva2VucyhlbnYudG9rZW5zKTtcblx0fSk7XG5cbn0oUHJpc20pKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///2356\n")},1029:function(){eval("(function (Prism) {\n\tvar typescript = Prism.util.clone(Prism.languages.typescript);\n\tPrism.languages.tsx = Prism.languages.extend('jsx', typescript);\n\n\t// doesn't work with TS because TS is too complex\n\tdelete Prism.languages.tsx['parameter'];\n\tdelete Prism.languages.tsx['literal-property'];\n\n\t// This will prevent collisions between TSX tags and TS generic types.\n\t// Idea by https://github.com/karlhorky\n\t// Discussion: https://github.com/PrismJS/prism/issues/2594#issuecomment-710666928\n\tvar tag = Prism.languages.tsx.tag;\n\ttag.pattern = RegExp(/(^|[^\\w$]|(?=<\\/))/.source + '(?:' + tag.pattern.source + ')', tag.pattern.flags);\n\ttag.lookbehind = true;\n}(Prism));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAyOS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS10c3guanM/YmU1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKFByaXNtKSB7XG5cdHZhciB0eXBlc2NyaXB0ID0gUHJpc20udXRpbC5jbG9uZShQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdCk7XG5cdFByaXNtLmxhbmd1YWdlcy50c3ggPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdqc3gnLCB0eXBlc2NyaXB0KTtcblxuXHQvLyBkb2Vzbid0IHdvcmsgd2l0aCBUUyBiZWNhdXNlIFRTIGlzIHRvbyBjb21wbGV4XG5cdGRlbGV0ZSBQcmlzbS5sYW5ndWFnZXMudHN4WydwYXJhbWV0ZXInXTtcblx0ZGVsZXRlIFByaXNtLmxhbmd1YWdlcy50c3hbJ2xpdGVyYWwtcHJvcGVydHknXTtcblxuXHQvLyBUaGlzIHdpbGwgcHJldmVudCBjb2xsaXNpb25zIGJldHdlZW4gVFNYIHRhZ3MgYW5kIFRTIGdlbmVyaWMgdHlwZXMuXG5cdC8vIElkZWEgYnkgaHR0cHM6Ly9naXRodWIuY29tL2thcmxob3JreVxuXHQvLyBEaXNjdXNzaW9uOiBodHRwczovL2dpdGh1Yi5jb20vUHJpc21KUy9wcmlzbS9pc3N1ZXMvMjU5NCNpc3N1ZWNvbW1lbnQtNzEwNjY2OTI4XG5cdHZhciB0YWcgPSBQcmlzbS5sYW5ndWFnZXMudHN4LnRhZztcblx0dGFnLnBhdHRlcm4gPSBSZWdFeHAoLyhefFteXFx3JF18KD89PFxcLykpLy5zb3VyY2UgKyAnKD86JyArIHRhZy5wYXR0ZXJuLnNvdXJjZSArICcpJywgdGFnLnBhdHRlcm4uZmxhZ3MpO1xuXHR0YWcubG9va2JlaGluZCA9IHRydWU7XG59KFByaXNtKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1029\n")},6836:function(){eval("(function (Prism) {\n\n\tPrism.languages.typescript = Prism.languages.extend('javascript', {\n\t\t'class-name': {\n\t\t\tpattern: /(\\b(?:class|extends|implements|instanceof|interface|new|type)\\s+)(?!keyof\\b)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?:\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: null // see below\n\t\t},\n\t\t'builtin': /\\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\\b/,\n\t});\n\n\t// The keywords TypeScript adds to JavaScript\n\tPrism.languages.typescript.keyword.push(\n\t\t/\\b(?:abstract|declare|is|keyof|readonly|require)\\b/,\n\t\t// keywords that have to be followed by an identifier\n\t\t/\\b(?:asserts|infer|interface|module|namespace|type)\\b(?=\\s*(?:[{_$a-zA-Z\\xA0-\\uFFFF]|$))/,\n\t\t// This is for `import type *, {}`\n\t\t/\\btype\\b(?=\\s*(?:[\\{*]|$))/\n\t);\n\n\t// doesn't work with TS because TS is too complex\n\tdelete Prism.languages.typescript['parameter'];\n\tdelete Prism.languages.typescript['literal-property'];\n\n\t// a version of typescript specifically for highlighting types\n\tvar typeInside = Prism.languages.extend('typescript', {});\n\tdelete typeInside['class-name'];\n\n\tPrism.languages.typescript['class-name'].inside = typeInside;\n\n\tPrism.languages.insertBefore('typescript', 'function', {\n\t\t'decorator': {\n\t\t\tpattern: /@[$\\w\\xA0-\\uFFFF]+/,\n\t\t\tinside: {\n\t\t\t\t'at': {\n\t\t\t\t\tpattern: /^@/,\n\t\t\t\t\talias: 'operator'\n\t\t\t\t},\n\t\t\t\t'function': /^[\\s\\S]+/\n\t\t\t}\n\t\t},\n\t\t'generic-function': {\n\t\t\t// e.g. foo<T extends \"bar\" | \"baz\">( ...\n\t\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\\s*\\()/,\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'function': /^#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*/,\n\t\t\t\t'generic': {\n\t\t\t\t\tpattern: /<[\\s\\S]+/, // everything after the first <\n\t\t\t\t\talias: 'class-name',\n\t\t\t\t\tinside: typeInside\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\tPrism.languages.ts = Prism.languages.typescript;\n\n}(Prism));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjgzNi5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FLG1DQUFtQztBQUNuQyx1QkFBdUI7QUFDdkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseURBQXlEO0FBQ3pEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL3ByaXNtanMvY29tcG9uZW50cy9wcmlzbS10eXBlc2NyaXB0LmpzPzhlNDkiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChQcmlzbSkge1xuXG5cdFByaXNtLmxhbmd1YWdlcy50eXBlc2NyaXB0ID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnamF2YXNjcmlwdCcsIHtcblx0XHQnY2xhc3MtbmFtZSc6IHtcblx0XHRcdHBhdHRlcm46IC8oXFxiKD86Y2xhc3N8ZXh0ZW5kc3xpbXBsZW1lbnRzfGluc3RhbmNlb2Z8aW50ZXJmYWNlfG5ld3x0eXBlKVxccyspKD8ha2V5b2ZcXGIpKD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/Olxccyo8KD86W148Pl18PCg/OltePD5dfDxbXjw+XSo+KSo+KSo+KT8vLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZTogbnVsbCAvLyBzZWUgYmVsb3dcblx0XHR9LFxuXHRcdCdidWlsdGluJzogL1xcYig/OkFycmF5fEZ1bmN0aW9ufFByb21pc2V8YW55fGJvb2xlYW58Y29uc29sZXxuZXZlcnxudW1iZXJ8c3RyaW5nfHN5bWJvbHx1bmtub3duKVxcYi8sXG5cdH0pO1xuXG5cdC8vIFRoZSBrZXl3b3JkcyBUeXBlU2NyaXB0IGFkZHMgdG8gSmF2YVNjcmlwdFxuXHRQcmlzbS5sYW5ndWFnZXMudHlwZXNjcmlwdC5rZXl3b3JkLnB1c2goXG5cdFx0L1xcYig/OmFic3RyYWN0fGRlY2xhcmV8aXN8a2V5b2Z8cmVhZG9ubHl8cmVxdWlyZSlcXGIvLFxuXHRcdC8vIGtleXdvcmRzIHRoYXQgaGF2ZSB0byBiZSBmb2xsb3dlZCBieSBhbiBpZGVudGlmaWVyXG5cdFx0L1xcYig/OmFzc2VydHN8aW5mZXJ8aW50ZXJmYWNlfG1vZHVsZXxuYW1lc3BhY2V8dHlwZSlcXGIoPz1cXHMqKD86W3tfJGEtekEtWlxceEEwLVxcdUZGRkZdfCQpKS8sXG5cdFx0Ly8gVGhpcyBpcyBmb3IgYGltcG9ydCB0eXBlICosIHt9YFxuXHRcdC9cXGJ0eXBlXFxiKD89XFxzKig/OltcXHsqXXwkKSkvXG5cdCk7XG5cblx0Ly8gZG9lc24ndCB3b3JrIHdpdGggVFMgYmVjYXVzZSBUUyBpcyB0b28gY29tcGxleFxuXHRkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHRbJ3BhcmFtZXRlciddO1xuXHRkZWxldGUgUHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHRbJ2xpdGVyYWwtcHJvcGVydHknXTtcblxuXHQvLyBhIHZlcnNpb24gb2YgdHlwZXNjcmlwdCBzcGVjaWZpY2FsbHkgZm9yIGhpZ2hsaWdodGluZyB0eXBlc1xuXHR2YXIgdHlwZUluc2lkZSA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ3R5cGVzY3JpcHQnLCB7fSk7XG5cdGRlbGV0ZSB0eXBlSW5zaWRlWydjbGFzcy1uYW1lJ107XG5cblx0UHJpc20ubGFuZ3VhZ2VzLnR5cGVzY3JpcHRbJ2NsYXNzLW5hbWUnXS5pbnNpZGUgPSB0eXBlSW5zaWRlO1xuXG5cdFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ3R5cGVzY3JpcHQnLCAnZnVuY3Rpb24nLCB7XG5cdFx0J2RlY29yYXRvcic6IHtcblx0XHRcdHBhdHRlcm46IC9AWyRcXHdcXHhBMC1cXHVGRkZGXSsvLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdhdCc6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvXkAvLFxuXHRcdFx0XHRcdGFsaWFzOiAnb3BlcmF0b3InXG5cdFx0XHRcdH0sXG5cdFx0XHRcdCdmdW5jdGlvbic6IC9eW1xcc1xcU10rL1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0J2dlbmVyaWMtZnVuY3Rpb24nOiB7XG5cdFx0XHQvLyBlLmcuIGZvbzxUIGV4dGVuZHMgXCJiYXJcIiB8IFwiYmF6XCI+KCAuLi5cblx0XHRcdHBhdHRlcm46IC8jPyg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSpcXHMqPCg/OltePD5dfDwoPzpbXjw+XXw8W148Pl0qPikqPikqPig/PVxccypcXCgpLyxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQnZnVuY3Rpb24nOiAvXiM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKi8sXG5cdFx0XHRcdCdnZW5lcmljJzoge1xuXHRcdFx0XHRcdHBhdHRlcm46IC88W1xcc1xcU10rLywgLy8gZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgPFxuXHRcdFx0XHRcdGFsaWFzOiAnY2xhc3MtbmFtZScsXG5cdFx0XHRcdFx0aW5zaWRlOiB0eXBlSW5zaWRlXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdFByaXNtLmxhbmd1YWdlcy50cyA9IFByaXNtLmxhbmd1YWdlcy50eXBlc2NyaXB0O1xuXG59KFByaXNtKSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6836\n")},5660:function(module,__unused_webpack_exports,__webpack_require__){eval("\n/* **********************************************\n     Begin prism-core.js\n********************************************** */\n\n/// <reference lib=\"WebWorker\"/>\n\nvar _self = (typeof window !== 'undefined')\n\t? window   // if in browser\n\t: (\n\t\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\n\t\t\t? self // if in worker\n\t\t\t: {}   // if in node js\n\t);\n\n/**\n * Prism: Lightweight, robust, elegant syntax highlighting\n *\n * @license MIT <https://opensource.org/licenses/MIT>\n * @author Lea Verou <https://lea.verou.me>\n * @namespace\n * @public\n */\nvar Prism = (function (_self) {\n\n\t// Private helper vars\n\tvar lang = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i;\n\tvar uniqueId = 0;\n\n\t// The grammar object for plaintext\n\tvar plainTextGrammar = {};\n\n\n\tvar _ = {\n\t\t/**\n\t\t * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the\n\t\t * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load\n\t\t * additional languages or plugins yourself.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.\n\t\t *\n\t\t * You obviously have to change this value before the automatic highlighting started. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.manual = true;\n\t\t * // add a new <script> to load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tmanual: _self.Prism && _self.Prism.manual,\n\t\t/**\n\t\t * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses\n\t\t * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your\n\t\t * own worker, you don't want it to do this.\n\t\t *\n\t\t * By setting this value to `true`, Prism will not add its own listeners to the worker.\n\t\t *\n\t\t * You obviously have to change this value before Prism executes. To do this, you can add an\n\t\t * empty Prism object into the global scope before loading the Prism script like this:\n\t\t *\n\t\t * ```js\n\t\t * window.Prism = window.Prism || {};\n\t\t * Prism.disableWorkerMessageHandler = true;\n\t\t * // Load Prism's script\n\t\t * ```\n\t\t *\n\t\t * @default false\n\t\t * @type {boolean}\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tdisableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,\n\n\t\t/**\n\t\t * A namespace for utility methods.\n\t\t *\n\t\t * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n\t\t * change or disappear at any time.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t */\n\t\tutil: {\n\t\t\tencode: function encode(tokens) {\n\t\t\t\tif (tokens instanceof Token) {\n\t\t\t\t\treturn new Token(tokens.type, encode(tokens.content), tokens.alias);\n\t\t\t\t} else if (Array.isArray(tokens)) {\n\t\t\t\t\treturn tokens.map(encode);\n\t\t\t\t} else {\n\t\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the name of the type of the given value.\n\t\t\t *\n\t\t\t * @param {any} o\n\t\t\t * @returns {string}\n\t\t\t * @example\n\t\t\t * type(null)      === 'Null'\n\t\t\t * type(undefined) === 'Undefined'\n\t\t\t * type(123)       === 'Number'\n\t\t\t * type('foo')     === 'String'\n\t\t\t * type(true)      === 'Boolean'\n\t\t\t * type([1, 2])    === 'Array'\n\t\t\t * type({})        === 'Object'\n\t\t\t * type(String)    === 'Function'\n\t\t\t * type(/abc+/)    === 'RegExp'\n\t\t\t */\n\t\t\ttype: function (o) {\n\t\t\t\treturn Object.prototype.toString.call(o).slice(8, -1);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns a unique number for the given object. Later calls will still return the same number.\n\t\t\t *\n\t\t\t * @param {Object} obj\n\t\t\t * @returns {number}\n\t\t\t */\n\t\t\tobjId: function (obj) {\n\t\t\t\tif (!obj['__id']) {\n\t\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\n\t\t\t\t}\n\t\t\t\treturn obj['__id'];\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Creates a deep clone of the given object.\n\t\t\t *\n\t\t\t * The main intended use of this function is to clone language definitions.\n\t\t\t *\n\t\t\t * @param {T} o\n\t\t\t * @param {Record<number, any>} [visited]\n\t\t\t * @returns {T}\n\t\t\t * @template T\n\t\t\t */\n\t\t\tclone: function deepClone(o, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar clone; var id;\n\t\t\t\tswitch (_.util.type(o)) {\n\t\t\t\t\tcase 'Object':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = /** @type {Record<string, any>} */ ({});\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\tfor (var key in o) {\n\t\t\t\t\t\t\tif (o.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tclone[key] = deepClone(o[key], visited);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tcase 'Array':\n\t\t\t\t\t\tid = _.util.objId(o);\n\t\t\t\t\t\tif (visited[id]) {\n\t\t\t\t\t\t\treturn visited[id];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tclone = [];\n\t\t\t\t\t\tvisited[id] = clone;\n\n\t\t\t\t\t\t(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {\n\t\t\t\t\t\t\tclone[i] = deepClone(v, visited);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn /** @type {any} */ (clone);\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn o;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n\t\t\t *\n\t\t\t * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @returns {string}\n\t\t\t */\n\t\t\tgetLanguage: function (element) {\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar m = lang.exec(element.className);\n\t\t\t\t\tif (m) {\n\t\t\t\t\t\treturn m[1].toLowerCase();\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn 'none';\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Sets the Prism `language-xxxx` class of the given element.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} language\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\tsetLanguage: function (element, language) {\n\t\t\t\t// remove all `language-xxxx` classes\n\t\t\t\t// (this might leave behind a leading space)\n\t\t\t\telement.className = element.className.replace(RegExp(lang, 'gi'), '');\n\n\t\t\t\t// add the new `language-xxxx` class\n\t\t\t\t// (using `classList` will automatically clean up spaces for us)\n\t\t\t\telement.classList.add('language-' + language);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns the script element that is currently executing.\n\t\t\t *\n\t\t\t * This does __not__ work for line script element.\n\t\t\t *\n\t\t\t * @returns {HTMLScriptElement | null}\n\t\t\t */\n\t\t\tcurrentScript: function () {\n\t\t\t\tif (typeof document === 'undefined') {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tif ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {\n\t\t\t\t\treturn /** @type {any} */ (document.currentScript);\n\t\t\t\t}\n\n\t\t\t\t// IE11 workaround\n\t\t\t\t// we'll get the src of the current script by parsing IE11's error stack trace\n\t\t\t\t// this will not work for inline scripts\n\n\t\t\t\ttry {\n\t\t\t\t\tthrow new Error();\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// Get file src url from stack. Specifically works with the format of stack traces in IE.\n\t\t\t\t\t// A stack will look like this:\n\t\t\t\t\t//\n\t\t\t\t\t// Error\n\t\t\t\t\t//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)\n\t\t\t\t\t//    at Global code (http://localhost/components/prism-core.js:606:1)\n\n\t\t\t\t\tvar src = (/at [^(\\r\\n]*\\((.*):[^:]+:[^:]+\\)$/i.exec(err.stack) || [])[1];\n\t\t\t\t\tif (src) {\n\t\t\t\t\t\tvar scripts = document.getElementsByTagName('script');\n\t\t\t\t\t\tfor (var i in scripts) {\n\t\t\t\t\t\t\tif (scripts[i].src == src) {\n\t\t\t\t\t\t\t\treturn scripts[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Returns whether a given class is active for `element`.\n\t\t\t *\n\t\t\t * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n\t\t\t * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n\t\t\t * given class is just the given class with a `no-` prefix.\n\t\t\t *\n\t\t\t * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n\t\t\t * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n\t\t\t * ancestors have the given class or the negated version of it, then the default activation will be returned.\n\t\t\t *\n\t\t\t * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n\t\t\t * version of it, the class is considered active.\n\t\t\t *\n\t\t\t * @param {Element} element\n\t\t\t * @param {string} className\n\t\t\t * @param {boolean} [defaultActivation=false]\n\t\t\t * @returns {boolean}\n\t\t\t */\n\t\t\tisActive: function (element, className, defaultActivation) {\n\t\t\t\tvar no = 'no-' + className;\n\n\t\t\t\twhile (element) {\n\t\t\t\t\tvar classList = element.classList;\n\t\t\t\t\tif (classList.contains(className)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tif (classList.contains(no)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telement = element.parentElement;\n\t\t\t\t}\n\t\t\t\treturn !!defaultActivation;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n\t\t *\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\tlanguages: {\n\t\t\t/**\n\t\t\t * The grammar for plain, unformatted text.\n\t\t\t */\n\t\t\tplain: plainTextGrammar,\n\t\t\tplaintext: plainTextGrammar,\n\t\t\ttext: plainTextGrammar,\n\t\t\ttxt: plainTextGrammar,\n\n\t\t\t/**\n\t\t\t * Creates a deep copy of the language with the given id and appends the given tokens.\n\t\t\t *\n\t\t\t * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n\t\t\t * will be overwritten at its original position.\n\t\t\t *\n\t\t\t * ## Best practices\n\t\t\t *\n\t\t\t * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n\t\t\t * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n\t\t\t * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n\t\t\t *\n\t\t\t * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n\t\t\t * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n\t\t\t *\n\t\t\t * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n\t\t\t * @param {Grammar} redef The new tokens to append.\n\t\t\t * @returns {Grammar} The new language created.\n\t\t\t * @public\n\t\t\t * @example\n\t\t\t * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n\t\t\t *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n\t\t\t *     // at its original position\n\t\t\t *     'comment': { ... },\n\t\t\t *     // CSS doesn't have a 'color' token, so this token will be appended\n\t\t\t *     'color': /\\b(?:red|green|blue)\\b/\n\t\t\t * });\n\t\t\t */\n\t\t\textend: function (id, redef) {\n\t\t\t\tvar lang = _.util.clone(_.languages[id]);\n\n\t\t\t\tfor (var key in redef) {\n\t\t\t\t\tlang[key] = redef[key];\n\t\t\t\t}\n\n\t\t\t\treturn lang;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Inserts tokens _before_ another token in a language definition or any other grammar.\n\t\t\t *\n\t\t\t * ## Usage\n\t\t\t *\n\t\t\t * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n\t\t\t * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n\t\t\t * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n\t\t\t * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n\t\t\t * this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.markup.style = {\n\t\t\t *     // token\n\t\t\t * };\n\t\t\t * ```\n\t\t\t *\n\t\t\t * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n\t\t\t * before existing tokens. For the CSS example above, you would use it like this:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'cdata', {\n\t\t\t *     'style': {\n\t\t\t *         // token\n\t\t\t *     }\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Special cases\n\t\t\t *\n\t\t\t * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n\t\t\t * will be ignored.\n\t\t\t *\n\t\t\t * This behavior can be used to insert tokens after `before`:\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * Prism.languages.insertBefore('markup', 'comment', {\n\t\t\t *     'comment': Prism.languages.markup.comment,\n\t\t\t *     // tokens after 'comment'\n\t\t\t * });\n\t\t\t * ```\n\t\t\t *\n\t\t\t * ## Limitations\n\t\t\t *\n\t\t\t * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n\t\t\t * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n\t\t\t * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n\t\t\t * deleting properties which is necessary to insert at arbitrary positions.\n\t\t\t *\n\t\t\t * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n\t\t\t * Instead, it will create a new object and replace all references to the target object with the new one. This\n\t\t\t * can be done without temporarily deleting properties, so the iteration order is well-defined.\n\t\t\t *\n\t\t\t * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n\t\t\t * you hold the target object in a variable, then the value of the variable will not change.\n\t\t\t *\n\t\t\t * ```js\n\t\t\t * var oldMarkup = Prism.languages.markup;\n\t\t\t * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n\t\t\t *\n\t\t\t * assert(oldMarkup !== Prism.languages.markup);\n\t\t\t * assert(newMarkup === Prism.languages.markup);\n\t\t\t * ```\n\t\t\t *\n\t\t\t * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n\t\t\t * object to be modified.\n\t\t\t * @param {string} before The key to insert before.\n\t\t\t * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n\t\t\t * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n\t\t\t * object to be modified.\n\t\t\t *\n\t\t\t * Defaults to `Prism.languages`.\n\t\t\t * @returns {Grammar} The new grammar object.\n\t\t\t * @public\n\t\t\t */\n\t\t\tinsertBefore: function (inside, before, insert, root) {\n\t\t\t\troot = root || /** @type {any} */ (_.languages);\n\t\t\t\tvar grammar = root[inside];\n\t\t\t\t/** @type {Grammar} */\n\t\t\t\tvar ret = {};\n\n\t\t\t\tfor (var token in grammar) {\n\t\t\t\t\tif (grammar.hasOwnProperty(token)) {\n\n\t\t\t\t\t\tif (token == before) {\n\t\t\t\t\t\t\tfor (var newToken in insert) {\n\t\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {\n\t\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Do not insert token which also occur in insert. See #1525\n\t\t\t\t\t\tif (!insert.hasOwnProperty(token)) {\n\t\t\t\t\t\t\tret[token] = grammar[token];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar old = root[inside];\n\t\t\t\troot[inside] = ret;\n\n\t\t\t\t// Update references in other language definitions\n\t\t\t\t_.languages.DFS(_.languages, function (key, value) {\n\t\t\t\t\tif (value === old && key != inside) {\n\t\t\t\t\t\tthis[key] = ret;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn ret;\n\t\t\t},\n\n\t\t\t// Traverse a language definition with Depth First Search\n\t\t\tDFS: function DFS(o, callback, type, visited) {\n\t\t\t\tvisited = visited || {};\n\n\t\t\t\tvar objId = _.util.objId;\n\n\t\t\t\tfor (var i in o) {\n\t\t\t\t\tif (o.hasOwnProperty(i)) {\n\t\t\t\t\t\tcallback.call(o, i, o[i], type || i);\n\n\t\t\t\t\t\tvar property = o[i];\n\t\t\t\t\t\tvar propertyType = _.util.type(property);\n\n\t\t\t\t\t\tif (propertyType === 'Object' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, null, visited);\n\t\t\t\t\t\t} else if (propertyType === 'Array' && !visited[objId(property)]) {\n\t\t\t\t\t\t\tvisited[objId(property)] = true;\n\t\t\t\t\t\t\tDFS(property, callback, i, visited);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tplugins: {},\n\n\t\t/**\n\t\t * This is the most high-level function in Prism\u2019s API.\n\t\t * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on\n\t\t * each one of them.\n\t\t *\n\t\t * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.\n\t\t *\n\t\t * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightAll: function (async, callback) {\n\t\t\t_.highlightAllUnder(document, async, callback);\n\t\t},\n\n\t\t/**\n\t\t * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls\n\t\t * {@link Prism.highlightElement} on each one of them.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-highlightall`\n\t\t * 2. `before-all-elements-highlight`\n\t\t * 3. All hooks of {@link Prism.highlightElement} for each element.\n\t\t *\n\t\t * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.\n\t\t * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightAllUnder: function (container, async, callback) {\n\t\t\tvar env = {\n\t\t\t\tcallback: callback,\n\t\t\t\tcontainer: container,\n\t\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n\t\t\t};\n\n\t\t\t_.hooks.run('before-highlightall', env);\n\n\t\t\tenv.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));\n\n\t\t\t_.hooks.run('before-all-elements-highlight', env);\n\n\t\t\tfor (var i = 0, element; (element = env.elements[i++]);) {\n\t\t\t\t_.highlightElement(element, async === true, env.callback);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Highlights the code inside a single element.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-sanity-check`\n\t\t * 2. `before-highlight`\n\t\t * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.\n\t\t * 4. `before-insert`\n\t\t * 5. `after-highlight`\n\t\t * 6. `complete`\n\t\t *\n\t\t * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for\n\t\t * the element's language.\n\t\t *\n\t\t * @param {Element} element The element containing the code.\n\t\t * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.\n\t\t * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers\n\t\t * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is\n\t\t * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).\n\t\t *\n\t\t * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for\n\t\t * asynchronous highlighting to work. You can build your own bundle on the\n\t\t * [Download page](https://prismjs.com/download.html).\n\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.\n\t\t * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thighlightElement: function (element, async, callback) {\n\t\t\t// Find language\n\t\t\tvar language = _.util.getLanguage(element);\n\t\t\tvar grammar = _.languages[language];\n\n\t\t\t// Set language on the element, if not present\n\t\t\t_.util.setLanguage(element, language);\n\n\t\t\t// Set language on the parent, for styling\n\t\t\tvar parent = element.parentElement;\n\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre') {\n\t\t\t\t_.util.setLanguage(parent, language);\n\t\t\t}\n\n\t\t\tvar code = element.textContent;\n\n\t\t\tvar env = {\n\t\t\t\telement: element,\n\t\t\t\tlanguage: language,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tcode: code\n\t\t\t};\n\n\t\t\tfunction insertHighlightedCode(highlightedCode) {\n\t\t\t\tenv.highlightedCode = highlightedCode;\n\n\t\t\t\t_.hooks.run('before-insert', env);\n\n\t\t\t\tenv.element.innerHTML = env.highlightedCode;\n\n\t\t\t\t_.hooks.run('after-highlight', env);\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t}\n\n\t\t\t_.hooks.run('before-sanity-check', env);\n\n\t\t\t// plugins may change/add the parent/element\n\t\t\tparent = env.element.parentElement;\n\t\t\tif (parent && parent.nodeName.toLowerCase() === 'pre' && !parent.hasAttribute('tabindex')) {\n\t\t\t\tparent.setAttribute('tabindex', '0');\n\t\t\t}\n\n\t\t\tif (!env.code) {\n\t\t\t\t_.hooks.run('complete', env);\n\t\t\t\tcallback && callback.call(env.element);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t_.hooks.run('before-highlight', env);\n\n\t\t\tif (!env.grammar) {\n\t\t\t\tinsertHighlightedCode(_.util.encode(env.code));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (async && _self.Worker) {\n\t\t\t\tvar worker = new Worker(_.filename);\n\n\t\t\t\tworker.onmessage = function (evt) {\n\t\t\t\t\tinsertHighlightedCode(evt.data);\n\t\t\t\t};\n\n\t\t\t\tworker.postMessage(JSON.stringify({\n\t\t\t\t\tlanguage: env.language,\n\t\t\t\t\tcode: env.code,\n\t\t\t\t\timmediateClose: true\n\t\t\t\t}));\n\t\t\t} else {\n\t\t\t\tinsertHighlightedCode(_.highlight(env.code, env.grammar, env.language));\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Low-level function, only use if you know what you\u2019re doing. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns a string with the HTML produced.\n\t\t *\n\t\t * The following hooks will be run:\n\t\t * 1. `before-tokenize`\n\t\t * 2. `after-tokenize`\n\t\t * 3. `wrap`: On each {@link Token}.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @param {string} language The name of the language definition passed to `grammar`.\n\t\t * @returns {string} The highlighted HTML.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n\t\t */\n\t\thighlight: function (text, grammar, language) {\n\t\t\tvar env = {\n\t\t\t\tcode: text,\n\t\t\t\tgrammar: grammar,\n\t\t\t\tlanguage: language\n\t\t\t};\n\t\t\t_.hooks.run('before-tokenize', env);\n\t\t\tif (!env.grammar) {\n\t\t\t\tthrow new Error('The language \"' + env.language + '\" has no grammar.');\n\t\t\t}\n\t\t\tenv.tokens = _.tokenize(env.code, env.grammar);\n\t\t\t_.hooks.run('after-tokenize', env);\n\t\t\treturn Token.stringify(_.util.encode(env.tokens), env.language);\n\t\t},\n\n\t\t/**\n\t\t * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n\t\t * and the language definitions to use, and returns an array with the tokenized code.\n\t\t *\n\t\t * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n\t\t *\n\t\t * This method could be useful in other contexts as well, as a very crude parser.\n\t\t *\n\t\t * @param {string} text A string with the code to be highlighted.\n\t\t * @param {Grammar} grammar An object containing the tokens to use.\n\t\t *\n\t\t * Usually a language definition like `Prism.languages.markup`.\n\t\t * @returns {TokenStream} An array of strings and tokens, a token stream.\n\t\t * @memberof Prism\n\t\t * @public\n\t\t * @example\n\t\t * let code = `var foo = 0;`;\n\t\t * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n\t\t * tokens.forEach(token => {\n\t\t *     if (token instanceof Prism.Token && token.type === 'number') {\n\t\t *         console.log(`Found numeric literal: ${token.content}`);\n\t\t *     }\n\t\t * });\n\t\t */\n\t\ttokenize: function (text, grammar) {\n\t\t\tvar rest = grammar.rest;\n\t\t\tif (rest) {\n\t\t\t\tfor (var token in rest) {\n\t\t\t\t\tgrammar[token] = rest[token];\n\t\t\t\t}\n\n\t\t\t\tdelete grammar.rest;\n\t\t\t}\n\n\t\t\tvar tokenList = new LinkedList();\n\t\t\taddAfter(tokenList, tokenList.head, text);\n\n\t\t\tmatchGrammar(text, tokenList, grammar, tokenList.head, 0);\n\n\t\t\treturn toArray(tokenList);\n\t\t},\n\n\t\t/**\n\t\t * @namespace\n\t\t * @memberof Prism\n\t\t * @public\n\t\t */\n\t\thooks: {\n\t\t\tall: {},\n\n\t\t\t/**\n\t\t\t * Adds the given callback to the list of callbacks for the given hook.\n\t\t\t *\n\t\t\t * The callback will be invoked when the hook it is registered for is run.\n\t\t\t * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n\t\t\t *\n\t\t\t * One callback function can be registered to multiple hooks and the same hook multiple times.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {HookCallback} callback The callback function which is given environment variables.\n\t\t\t * @public\n\t\t\t */\n\t\t\tadd: function (name, callback) {\n\t\t\t\tvar hooks = _.hooks.all;\n\n\t\t\t\thooks[name] = hooks[name] || [];\n\n\t\t\t\thooks[name].push(callback);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Runs a hook invoking all registered callbacks with the given environment variables.\n\t\t\t *\n\t\t\t * Callbacks will be invoked synchronously and in the order in which they were registered.\n\t\t\t *\n\t\t\t * @param {string} name The name of the hook.\n\t\t\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n\t\t\t * @public\n\t\t\t */\n\t\t\trun: function (name, env) {\n\t\t\t\tvar callbacks = _.hooks.all[name];\n\n\t\t\t\tif (!callbacks || !callbacks.length) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = 0, callback; (callback = callbacks[i++]);) {\n\t\t\t\t\tcallback(env);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tToken: Token\n\t};\n\t_self.Prism = _;\n\n\n\t// Typescript note:\n\t// The following can be used to import the Token type in JSDoc:\n\t//\n\t//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\n\n\t/**\n\t * Creates a new token.\n\t *\n\t * @param {string} type See {@link Token#type type}\n\t * @param {string | TokenStream} content See {@link Token#content content}\n\t * @param {string|string[]} [alias] The alias(es) of the token.\n\t * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.\n\t * @class\n\t * @global\n\t * @public\n\t */\n\tfunction Token(type, content, alias, matchedStr) {\n\t\t/**\n\t\t * The type of the token.\n\t\t *\n\t\t * This is usually the key of a pattern in a {@link Grammar}.\n\t\t *\n\t\t * @type {string}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.type = type;\n\t\t/**\n\t\t * The strings or tokens contained by this token.\n\t\t *\n\t\t * This will be a token stream if the pattern matched also defined an `inside` grammar.\n\t\t *\n\t\t * @type {string | TokenStream}\n\t\t * @public\n\t\t */\n\t\tthis.content = content;\n\t\t/**\n\t\t * The alias(es) of the token.\n\t\t *\n\t\t * @type {string|string[]}\n\t\t * @see GrammarToken\n\t\t * @public\n\t\t */\n\t\tthis.alias = alias;\n\t\t// Copy of the full string this token was created from\n\t\tthis.length = (matchedStr || '').length | 0;\n\t}\n\n\t/**\n\t * A token stream is an array of strings and {@link Token Token} objects.\n\t *\n\t * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process\n\t * them.\n\t *\n\t * 1. No adjacent strings.\n\t * 2. No empty strings.\n\t *\n\t *    The only exception here is the token stream that only contains the empty string and nothing else.\n\t *\n\t * @typedef {Array<string | Token>} TokenStream\n\t * @global\n\t * @public\n\t */\n\n\t/**\n\t * Converts the given token or token stream to an HTML representation.\n\t *\n\t * The following hooks will be run:\n\t * 1. `wrap`: On each {@link Token}.\n\t *\n\t * @param {string | Token | TokenStream} o The token or token stream to be converted.\n\t * @param {string} language The name of current language.\n\t * @returns {string} The HTML representation of the token or token stream.\n\t * @memberof Token\n\t * @static\n\t */\n\tToken.stringify = function stringify(o, language) {\n\t\tif (typeof o == 'string') {\n\t\t\treturn o;\n\t\t}\n\t\tif (Array.isArray(o)) {\n\t\t\tvar s = '';\n\t\t\to.forEach(function (e) {\n\t\t\t\ts += stringify(e, language);\n\t\t\t});\n\t\t\treturn s;\n\t\t}\n\n\t\tvar env = {\n\t\t\ttype: o.type,\n\t\t\tcontent: stringify(o.content, language),\n\t\t\ttag: 'span',\n\t\t\tclasses: ['token', o.type],\n\t\t\tattributes: {},\n\t\t\tlanguage: language\n\t\t};\n\n\t\tvar aliases = o.alias;\n\t\tif (aliases) {\n\t\t\tif (Array.isArray(aliases)) {\n\t\t\t\tArray.prototype.push.apply(env.classes, aliases);\n\t\t\t} else {\n\t\t\t\tenv.classes.push(aliases);\n\t\t\t}\n\t\t}\n\n\t\t_.hooks.run('wrap', env);\n\n\t\tvar attributes = '';\n\t\tfor (var name in env.attributes) {\n\t\t\tattributes += ' ' + name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';\n\t\t}\n\n\t\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + attributes + '>' + env.content + '</' + env.tag + '>';\n\t};\n\n\t/**\n\t * @param {RegExp} pattern\n\t * @param {number} pos\n\t * @param {string} text\n\t * @param {boolean} lookbehind\n\t * @returns {RegExpExecArray | null}\n\t */\n\tfunction matchPattern(pattern, pos, text, lookbehind) {\n\t\tpattern.lastIndex = pos;\n\t\tvar match = pattern.exec(text);\n\t\tif (match && lookbehind && match[1]) {\n\t\t\t// change the match to remove the text matched by the Prism lookbehind group\n\t\t\tvar lookbehindLength = match[1].length;\n\t\t\tmatch.index += lookbehindLength;\n\t\t\tmatch[0] = match[0].slice(lookbehindLength);\n\t\t}\n\t\treturn match;\n\t}\n\n\t/**\n\t * @param {string} text\n\t * @param {LinkedList<string | Token>} tokenList\n\t * @param {any} grammar\n\t * @param {LinkedListNode<string | Token>} startNode\n\t * @param {number} startPos\n\t * @param {RematchOptions} [rematch]\n\t * @returns {void}\n\t * @private\n\t *\n\t * @typedef RematchOptions\n\t * @property {string} cause\n\t * @property {number} reach\n\t */\n\tfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {\n\t\tfor (var token in grammar) {\n\t\t\tif (!grammar.hasOwnProperty(token) || !grammar[token]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar patterns = grammar[token];\n\t\t\tpatterns = Array.isArray(patterns) ? patterns : [patterns];\n\n\t\t\tfor (var j = 0; j < patterns.length; ++j) {\n\t\t\t\tif (rematch && rematch.cause == token + ',' + j) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar patternObj = patterns[j];\n\t\t\t\tvar inside = patternObj.inside;\n\t\t\t\tvar lookbehind = !!patternObj.lookbehind;\n\t\t\t\tvar greedy = !!patternObj.greedy;\n\t\t\t\tvar alias = patternObj.alias;\n\n\t\t\t\tif (greedy && !patternObj.pattern.global) {\n\t\t\t\t\t// Without the global flag, lastIndex won't work\n\t\t\t\t\tvar flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];\n\t\t\t\t\tpatternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');\n\t\t\t\t}\n\n\t\t\t\t/** @type {RegExp} */\n\t\t\t\tvar pattern = patternObj.pattern || patternObj;\n\n\t\t\t\tfor ( // iterate the token list and keep track of the current token/string position\n\t\t\t\t\tvar currentNode = startNode.next, pos = startPos;\n\t\t\t\t\tcurrentNode !== tokenList.tail;\n\t\t\t\t\tpos += currentNode.value.length, currentNode = currentNode.next\n\t\t\t\t) {\n\n\t\t\t\t\tif (rematch && pos >= rematch.reach) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar str = currentNode.value;\n\n\t\t\t\t\tif (tokenList.length > text.length) {\n\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (str instanceof Token) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeCount = 1; // this is the to parameter of removeBetween\n\t\t\t\t\tvar match;\n\n\t\t\t\t\tif (greedy) {\n\t\t\t\t\t\tmatch = matchPattern(pattern, pos, text, lookbehind);\n\t\t\t\t\t\tif (!match || match.index >= text.length) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar from = match.index;\n\t\t\t\t\t\tvar to = match.index + match[0].length;\n\t\t\t\t\t\tvar p = pos;\n\n\t\t\t\t\t\t// find the node that contains the match\n\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\twhile (from >= p) {\n\t\t\t\t\t\t\tcurrentNode = currentNode.next;\n\t\t\t\t\t\t\tp += currentNode.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// adjust pos (and p)\n\t\t\t\t\t\tp -= currentNode.value.length;\n\t\t\t\t\t\tpos = p;\n\n\t\t\t\t\t\t// the current node is a Token, then the match starts inside another Token, which is invalid\n\t\t\t\t\t\tif (currentNode.value instanceof Token) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// find the last node which is affected by this match\n\t\t\t\t\t\tfor (\n\t\t\t\t\t\t\tvar k = currentNode;\n\t\t\t\t\t\t\tk !== tokenList.tail && (p < to || typeof k.value === 'string');\n\t\t\t\t\t\t\tk = k.next\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tremoveCount++;\n\t\t\t\t\t\t\tp += k.value.length;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tremoveCount--;\n\n\t\t\t\t\t\t// replace with the new match\n\t\t\t\t\t\tstr = text.slice(pos, p);\n\t\t\t\t\t\tmatch.index -= pos;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatch = matchPattern(pattern, 0, str, lookbehind);\n\t\t\t\t\t\tif (!match) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// eslint-disable-next-line no-redeclare\n\t\t\t\t\tvar from = match.index;\n\t\t\t\t\tvar matchStr = match[0];\n\t\t\t\t\tvar before = str.slice(0, from);\n\t\t\t\t\tvar after = str.slice(from + matchStr.length);\n\n\t\t\t\t\tvar reach = pos + str.length;\n\t\t\t\t\tif (rematch && reach > rematch.reach) {\n\t\t\t\t\t\trematch.reach = reach;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar removeFrom = currentNode.prev;\n\n\t\t\t\t\tif (before) {\n\t\t\t\t\t\tremoveFrom = addAfter(tokenList, removeFrom, before);\n\t\t\t\t\t\tpos += before.length;\n\t\t\t\t\t}\n\n\t\t\t\t\tremoveRange(tokenList, removeFrom, removeCount);\n\n\t\t\t\t\tvar wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);\n\t\t\t\t\tcurrentNode = addAfter(tokenList, removeFrom, wrapped);\n\n\t\t\t\t\tif (after) {\n\t\t\t\t\t\taddAfter(tokenList, currentNode, after);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (removeCount > 1) {\n\t\t\t\t\t\t// at least one Token object was removed, so we have to do some rematching\n\t\t\t\t\t\t// this can only happen if the current pattern is greedy\n\n\t\t\t\t\t\t/** @type {RematchOptions} */\n\t\t\t\t\t\tvar nestedRematch = {\n\t\t\t\t\t\t\tcause: token + ',' + j,\n\t\t\t\t\t\t\treach: reach\n\t\t\t\t\t\t};\n\t\t\t\t\t\tmatchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);\n\n\t\t\t\t\t\t// the reach might have been extended because of the rematching\n\t\t\t\t\t\tif (rematch && nestedRematch.reach > rematch.reach) {\n\t\t\t\t\t\t\trematch.reach = nestedRematch.reach;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @typedef LinkedListNode\n\t * @property {T} value\n\t * @property {LinkedListNode<T> | null} prev The previous node.\n\t * @property {LinkedListNode<T> | null} next The next node.\n\t * @template T\n\t * @private\n\t */\n\n\t/**\n\t * @template T\n\t * @private\n\t */\n\tfunction LinkedList() {\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar head = { value: null, prev: null, next: null };\n\t\t/** @type {LinkedListNode<T>} */\n\t\tvar tail = { value: null, prev: head, next: null };\n\t\thead.next = tail;\n\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.head = head;\n\t\t/** @type {LinkedListNode<T>} */\n\t\tthis.tail = tail;\n\t\tthis.length = 0;\n\t}\n\n\t/**\n\t * Adds a new node with the given value to the list.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {T} value\n\t * @returns {LinkedListNode<T>} The added node.\n\t * @template T\n\t */\n\tfunction addAfter(list, node, value) {\n\t\t// assumes that node != list.tail && values.length >= 0\n\t\tvar next = node.next;\n\n\t\tvar newNode = { value: value, prev: node, next: next };\n\t\tnode.next = newNode;\n\t\tnext.prev = newNode;\n\t\tlist.length++;\n\n\t\treturn newNode;\n\t}\n\t/**\n\t * Removes `count` nodes after the given node. The given node will not be removed.\n\t *\n\t * @param {LinkedList<T>} list\n\t * @param {LinkedListNode<T>} node\n\t * @param {number} count\n\t * @template T\n\t */\n\tfunction removeRange(list, node, count) {\n\t\tvar next = node.next;\n\t\tfor (var i = 0; i < count && next !== list.tail; i++) {\n\t\t\tnext = next.next;\n\t\t}\n\t\tnode.next = next;\n\t\tnext.prev = node;\n\t\tlist.length -= i;\n\t}\n\t/**\n\t * @param {LinkedList<T>} list\n\t * @returns {T[]}\n\t * @template T\n\t */\n\tfunction toArray(list) {\n\t\tvar array = [];\n\t\tvar node = list.head.next;\n\t\twhile (node !== list.tail) {\n\t\t\tarray.push(node.value);\n\t\t\tnode = node.next;\n\t\t}\n\t\treturn array;\n\t}\n\n\n\tif (!_self.document) {\n\t\tif (!_self.addEventListener) {\n\t\t\t// in Node.js\n\t\t\treturn _;\n\t\t}\n\n\t\tif (!_.disableWorkerMessageHandler) {\n\t\t\t// In worker\n\t\t\t_self.addEventListener('message', function (evt) {\n\t\t\t\tvar message = JSON.parse(evt.data);\n\t\t\t\tvar lang = message.language;\n\t\t\t\tvar code = message.code;\n\t\t\t\tvar immediateClose = message.immediateClose;\n\n\t\t\t\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\n\t\t\t\tif (immediateClose) {\n\t\t\t\t\t_self.close();\n\t\t\t\t}\n\t\t\t}, false);\n\t\t}\n\n\t\treturn _;\n\t}\n\n\t// Get current script and highlight\n\tvar script = _.util.currentScript();\n\n\tif (script) {\n\t\t_.filename = script.src;\n\n\t\tif (script.hasAttribute('data-manual')) {\n\t\t\t_.manual = true;\n\t\t}\n\t}\n\n\tfunction highlightAutomaticallyCallback() {\n\t\tif (!_.manual) {\n\t\t\t_.highlightAll();\n\t\t}\n\t}\n\n\tif (!_.manual) {\n\t\t// If the document state is \"loading\", then we'll use DOMContentLoaded.\n\t\t// If the document state is \"interactive\" and the prism.js script is deferred, then we'll also use the\n\t\t// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they\n\t\t// might take longer one animation frame to execute which can create a race condition where only some plugins have\n\t\t// been loaded when Prism.highlightAll() is executed, depending on how fast resources are loaded.\n\t\t// See https://github.com/PrismJS/prism/issues/2102\n\t\tvar readyState = document.readyState;\n\t\tif (readyState === 'loading' || readyState === 'interactive' && script && script.defer) {\n\t\t\tdocument.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);\n\t\t} else {\n\t\t\tif (window.requestAnimationFrame) {\n\t\t\t\twindow.requestAnimationFrame(highlightAutomaticallyCallback);\n\t\t\t} else {\n\t\t\t\twindow.setTimeout(highlightAutomaticallyCallback, 16);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn _;\n\n}(_self));\n\nif ( true && module.exports) {\n\tmodule.exports = Prism;\n}\n\n// hack for components to work correctly in node.js\nif (typeof __webpack_require__.g !== 'undefined') {\n\t__webpack_require__.g.Prism = Prism;\n}\n\n// some additional documentation/types\n\n/**\n * The expansion of a simple `RegExp` literal to support additional properties.\n *\n * @typedef GrammarToken\n * @property {RegExp} pattern The regular expression of the token.\n * @property {boolean} [lookbehind=false] If `true`, then the first capturing group of `pattern` will (effectively)\n * behave as a lookbehind group meaning that the captured text will not be part of the matched text of the new token.\n * @property {boolean} [greedy=false] Whether the token is greedy.\n * @property {string|string[]} [alias] An optional alias or list of aliases.\n * @property {Grammar} [inside] The nested grammar of this token.\n *\n * The `inside` grammar will be used to tokenize the text value of each token of this kind.\n *\n * This can be used to make nested and even recursive language definitions.\n *\n * Note: This can cause infinite recursion. Be careful when you embed different languages or even the same language into\n * each another.\n * @global\n * @public\n */\n\n/**\n * @typedef Grammar\n * @type {Object<string, RegExp | GrammarToken | Array<RegExp | GrammarToken>>}\n * @property {Grammar} [rest] An optional grammar object that will be appended to this grammar.\n * @global\n * @public\n */\n\n/**\n * A function which will invoked after an element was successfully highlighted.\n *\n * @callback HighlightCallback\n * @param {Element} element The element successfully highlighted.\n * @returns {void}\n * @global\n * @public\n */\n\n/**\n * @callback HookCallback\n * @param {Object<string, any>} env The environment variables of the hook.\n * @returns {void}\n * @global\n * @public\n */\n\n\n/* **********************************************\n     Begin prism-markup.js\n********************************************** */\n\nPrism.languages.markup = {\n\t'comment': {\n\t\tpattern: /\x3c!--(?:(?!\x3c!--)[\\s\\S])*?--\x3e/,\n\t\tgreedy: true\n\t},\n\t'prolog': {\n\t\tpattern: /<\\?[\\s\\S]+?\\?>/,\n\t\tgreedy: true\n\t},\n\t'doctype': {\n\t\t// https://www.w3.org/TR/xml/#NT-doctypedecl\n\t\tpattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|\x3c!--(?:[^-]|-(?!->))*--\x3e)*\\]\\s*)?>/i,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'internal-subset': {\n\t\t\t\tpattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tgreedy: true,\n\t\t\t\tinside: null // see below\n\t\t\t},\n\t\t\t'string': {\n\t\t\t\tpattern: /\"[^\"]*\"|'[^']*'/,\n\t\t\t\tgreedy: true\n\t\t\t},\n\t\t\t'punctuation': /^<!|>$|[[\\]]/,\n\t\t\t'doctype-tag': /^DOCTYPE/i,\n\t\t\t'name': /[^\\s<>'\"]+/\n\t\t}\n\t},\n\t'cdata': {\n\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\tgreedy: true\n\t},\n\t'tag': {\n\t\tpattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'tag': {\n\t\t\t\tpattern: /^<\\/?[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': /^<\\/?/,\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t},\n\t\t\t'special-attr': [],\n\t\t\t'attr-value': {\n\t\t\t\tpattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n\t\t\t\tinside: {\n\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern: /^(\\s*)[\"']|[\"']$/,\n\t\t\t\t\t\t\tlookbehind: true\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t},\n\t\t\t'punctuation': /\\/?>/,\n\t\t\t'attr-name': {\n\t\t\t\tpattern: /[^\\s>\\/]+/,\n\t\t\t\tinside: {\n\t\t\t\t\t'namespace': /^[^\\s>\\/:]+:/\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t},\n\t'entity': [\n\t\t{\n\t\t\tpattern: /&[\\da-z]{1,8};/i,\n\t\t\talias: 'named-entity'\n\t\t},\n\t\t/&#x?[\\da-f]{1,8};/i\n\t]\n};\n\nPrism.languages.markup['tag'].inside['attr-value'].inside['entity'] =\n\tPrism.languages.markup['entity'];\nPrism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;\n\n// Plugin to make entity title show the real entity, idea by Roman Komarov\nPrism.hooks.add('wrap', function (env) {\n\n\tif (env.type === 'entity') {\n\t\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\n\t}\n});\n\nObject.defineProperty(Prism.languages.markup.tag, 'addInlined', {\n\t/**\n\t * Adds an inlined language to markup.\n\t *\n\t * An example of an inlined language is CSS with `<style>` tags.\n\t *\n\t * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addInlined('style', 'css');\n\t */\n\tvalue: function addInlined(tagName, lang) {\n\t\tvar includedCdataInside = {};\n\t\tincludedCdataInside['language-' + lang] = {\n\t\t\tpattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\t\tincludedCdataInside['cdata'] = /^<!\\[CDATA\\[|\\]\\]>$/i;\n\n\t\tvar inside = {\n\t\t\t'included-cdata': {\n\t\t\t\tpattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n\t\t\t\tinside: includedCdataInside\n\t\t\t}\n\t\t};\n\t\tinside['language-' + lang] = {\n\t\t\tpattern: /[\\s\\S]+/,\n\t\t\tinside: Prism.languages[lang]\n\t\t};\n\n\t\tvar def = {};\n\t\tdef[tagName] = {\n\t\t\tpattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function () { return tagName; }), 'i'),\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true,\n\t\t\tinside: inside\n\t\t};\n\n\t\tPrism.languages.insertBefore('markup', 'cdata', def);\n\t}\n});\nObject.defineProperty(Prism.languages.markup.tag, 'addAttribute', {\n\t/**\n\t * Adds an pattern to highlight languages embedded in HTML attributes.\n\t *\n\t * An example of an inlined language is CSS with `style` attributes.\n\t *\n\t * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n\t * case insensitive.\n\t * @param {string} lang The language key.\n\t * @example\n\t * addAttribute('style', 'css');\n\t */\n\tvalue: function (attrName, lang) {\n\t\tPrism.languages.markup.tag.inside['special-attr'].push({\n\t\t\tpattern: RegExp(\n\t\t\t\t/(^|[\"'\\s])/.source + '(?:' + attrName + ')' + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n\t\t\t\t'i'\n\t\t\t),\n\t\t\tlookbehind: true,\n\t\t\tinside: {\n\t\t\t\t'attr-name': /^[^\\s=]+/,\n\t\t\t\t'attr-value': {\n\t\t\t\t\tpattern: /=[\\s\\S]+/,\n\t\t\t\t\tinside: {\n\t\t\t\t\t\t'value': {\n\t\t\t\t\t\t\tpattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n\t\t\t\t\t\t\tlookbehind: true,\n\t\t\t\t\t\t\talias: [lang, 'language-' + lang],\n\t\t\t\t\t\t\tinside: Prism.languages[lang]\n\t\t\t\t\t\t},\n\t\t\t\t\t\t'punctuation': [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpattern: /^=/,\n\t\t\t\t\t\t\t\talias: 'attr-equals'\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t/\"|'/\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n});\n\nPrism.languages.html = Prism.languages.markup;\nPrism.languages.mathml = Prism.languages.markup;\nPrism.languages.svg = Prism.languages.markup;\n\nPrism.languages.xml = Prism.languages.extend('markup', {});\nPrism.languages.ssml = Prism.languages.xml;\nPrism.languages.atom = Prism.languages.xml;\nPrism.languages.rss = Prism.languages.xml;\n\n\n/* **********************************************\n     Begin prism-css.js\n********************************************** */\n\n(function (Prism) {\n\n\tvar string = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n\n\tPrism.languages.css = {\n\t\t'comment': /\\/\\*[\\s\\S]*?\\*\\//,\n\t\t'atrule': {\n\t\t\tpattern: RegExp('@[\\\\w-](?:' + /[^;{\\s\"']|\\s+(?!\\s)/.source + '|' + string.source + ')*?' + /(?:;|(?=\\s*\\{))/.source),\n\t\t\tinside: {\n\t\t\t\t'rule': /^@[\\w-]+/,\n\t\t\t\t'selector-function-argument': {\n\t\t\t\t\tpattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n\t\t\t\t\tlookbehind: true,\n\t\t\t\t\talias: 'selector'\n\t\t\t\t},\n\t\t\t\t'keyword': {\n\t\t\t\t\tpattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n\t\t\t\t\tlookbehind: true\n\t\t\t\t}\n\t\t\t\t// See rest below\n\t\t\t}\n\t\t},\n\t\t'url': {\n\t\t\t// https://drafts.csswg.org/css-values-3/#urls\n\t\t\tpattern: RegExp('\\\\burl\\\\((?:' + string.source + '|' + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + ')\\\\)', 'i'),\n\t\t\tgreedy: true,\n\t\t\tinside: {\n\t\t\t\t'function': /^url/i,\n\t\t\t\t'punctuation': /^\\(|\\)$/,\n\t\t\t\t'string': {\n\t\t\t\t\tpattern: RegExp('^' + string.source + '$'),\n\t\t\t\t\talias: 'url'\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t'selector': {\n\t\t\tpattern: RegExp('(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"\\'\\\\s]|\\\\s+(?![\\\\s{])|' + string.source + ')*(?=\\\\s*\\\\{)'),\n\t\t\tlookbehind: true\n\t\t},\n\t\t'string': {\n\t\t\tpattern: string,\n\t\t\tgreedy: true\n\t\t},\n\t\t'property': {\n\t\t\tpattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'important': /!important\\b/i,\n\t\t'function': {\n\t\t\tpattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n\t\t\tlookbehind: true\n\t\t},\n\t\t'punctuation': /[(){};:,]/\n\t};\n\n\tPrism.languages.css['atrule'].inside.rest = Prism.languages.css;\n\n\tvar markup = Prism.languages.markup;\n\tif (markup) {\n\t\tmarkup.tag.addInlined('style', 'css');\n\t\tmarkup.tag.addAttribute('style', 'css');\n\t}\n\n}(Prism));\n\n\n/* **********************************************\n     Begin prism-clike.js\n********************************************** */\n\nPrism.languages.clike = {\n\t'comment': [\n\t\t{\n\t\t\tpattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^\\\\:])\\/\\/.*/,\n\t\t\tlookbehind: true,\n\t\t\tgreedy: true\n\t\t}\n\t],\n\t'string': {\n\t\tpattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n\t\tgreedy: true\n\t},\n\t'class-name': {\n\t\tpattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n\t\tlookbehind: true,\n\t\tinside: {\n\t\t\t'punctuation': /[.\\\\]/\n\t\t}\n\t},\n\t'keyword': /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n\t'boolean': /\\b(?:false|true)\\b/,\n\t'function': /\\b\\w+(?=\\()/,\n\t'number': /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n\t'operator': /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n\t'punctuation': /[{}[\\];(),.:]/\n};\n\n\n/* **********************************************\n     Begin prism-javascript.js\n********************************************** */\n\nPrism.languages.javascript = Prism.languages.extend('clike', {\n\t'class-name': [\n\t\tPrism.languages.clike['class-name'],\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n\t\t\tlookbehind: true\n\t\t}\n\t],\n\t'keyword': [\n\t\t{\n\t\t\tpattern: /((?:^|\\})\\s*)catch\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n\t\t\tlookbehind: true\n\t\t},\n\t],\n\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n\t'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n\t'number': {\n\t\tpattern: RegExp(\n\t\t\t/(^|[^\\w$])/.source +\n\t\t\t'(?:' +\n\t\t\t(\n\t\t\t\t// constant\n\t\t\t\t/NaN|Infinity/.source +\n\t\t\t\t'|' +\n\t\t\t\t// binary integer\n\t\t\t\t/0[bB][01]+(?:_[01]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// octal integer\n\t\t\t\t/0[oO][0-7]+(?:_[0-7]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// hexadecimal integer\n\t\t\t\t/0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal bigint\n\t\t\t\t/\\d+(?:_\\d+)*n/.source +\n\t\t\t\t'|' +\n\t\t\t\t// decimal number (integer or float) but no bigint\n\t\t\t\t/(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source\n\t\t\t) +\n\t\t\t')' +\n\t\t\t/(?![\\w$])/.source\n\t\t),\n\t\tlookbehind: true\n\t},\n\t'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n});\n\nPrism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/;\n\nPrism.languages.insertBefore('javascript', 'keyword', {\n\t'regex': {\n\t\tpattern: RegExp(\n\t\t\t// lookbehind\n\t\t\t// eslint-disable-next-line regexp/no-dupe-characters-character-class\n\t\t\t/((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source +\n\t\t\t// Regex pattern:\n\t\t\t// There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n\t\t\t// classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n\t\t\t// with the only syntax, so we have to define 2 different regex patterns.\n\t\t\t/\\//.source +\n\t\t\t'(?:' +\n\t\t\t/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source +\n\t\t\t'|' +\n\t\t\t// `v` flag syntax. This supports 3 levels of nested character classes.\n\t\t\t/(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source +\n\t\t\t')' +\n\t\t\t// lookahead\n\t\t\t/(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source\n\t\t),\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'regex-source': {\n\t\t\t\tpattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n\t\t\t\tlookbehind: true,\n\t\t\t\talias: 'language-regex',\n\t\t\t\tinside: Prism.languages.regex\n\t\t\t},\n\t\t\t'regex-delimiter': /^\\/|\\/$/,\n\t\t\t'regex-flags': /^[a-z]+$/,\n\t\t}\n\t},\n\t// This must be declared before keyword because we use \"function\" inside the look-forward\n\t'function-variable': {\n\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n\t\talias: 'function'\n\t},\n\t'parameter': [\n\t\t{\n\t\t\tpattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t},\n\t\t{\n\t\t\tpattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n\t\t\tlookbehind: true,\n\t\t\tinside: Prism.languages.javascript\n\t\t}\n\t],\n\t'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n});\n\nPrism.languages.insertBefore('javascript', 'string', {\n\t'hashbang': {\n\t\tpattern: /^#!.*/,\n\t\tgreedy: true,\n\t\talias: 'comment'\n\t},\n\t'template-string': {\n\t\tpattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n\t\tgreedy: true,\n\t\tinside: {\n\t\t\t'template-punctuation': {\n\t\t\t\tpattern: /^`|`$/,\n\t\t\t\talias: 'string'\n\t\t\t},\n\t\t\t'interpolation': {\n\t\t\t\tpattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n\t\t\t\tlookbehind: true,\n\t\t\t\tinside: {\n\t\t\t\t\t'interpolation-punctuation': {\n\t\t\t\t\t\tpattern: /^\\$\\{|\\}$/,\n\t\t\t\t\t\talias: 'punctuation'\n\t\t\t\t\t},\n\t\t\t\t\trest: Prism.languages.javascript\n\t\t\t\t}\n\t\t\t},\n\t\t\t'string': /[\\s\\S]+/\n\t\t}\n\t},\n\t'string-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\tgreedy: true,\n\t\talias: 'property'\n\t}\n});\n\nPrism.languages.insertBefore('javascript', 'operator', {\n\t'literal-property': {\n\t\tpattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n\t\tlookbehind: true,\n\t\talias: 'property'\n\t},\n});\n\nif (Prism.languages.markup) {\n\tPrism.languages.markup.tag.addInlined('script', 'javascript');\n\n\t// add attribute support for all DOM events.\n\t// https://developer.mozilla.org/en-US/docs/Web/Events#Standard_events\n\tPrism.languages.markup.tag.addAttribute(\n\t\t/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,\n\t\t'javascript'\n\t);\n}\n\nPrism.languages.js = Prism.languages.javascript;\n\n\n/* **********************************************\n     Begin prism-file-highlight.js\n********************************************** */\n\n(function () {\n\n\tif (typeof Prism === 'undefined' || typeof document === 'undefined') {\n\t\treturn;\n\t}\n\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\n\tif (!Element.prototype.matches) {\n\t\tElement.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\n\t}\n\n\tvar LOADING_MESSAGE = 'Loading\u2026';\n\tvar FAILURE_MESSAGE = function (status, message) {\n\t\treturn '\u2716 Error ' + status + ' while fetching file: ' + message;\n\t};\n\tvar FAILURE_EMPTY_MESSAGE = '\u2716 Error: File does not exist or is empty';\n\n\tvar EXTENSIONS = {\n\t\t'js': 'javascript',\n\t\t'py': 'python',\n\t\t'rb': 'ruby',\n\t\t'ps1': 'powershell',\n\t\t'psm1': 'powershell',\n\t\t'sh': 'bash',\n\t\t'bat': 'batch',\n\t\t'h': 'c',\n\t\t'tex': 'latex'\n\t};\n\n\tvar STATUS_ATTR = 'data-src-status';\n\tvar STATUS_LOADING = 'loading';\n\tvar STATUS_LOADED = 'loaded';\n\tvar STATUS_FAILED = 'failed';\n\n\tvar SELECTOR = 'pre[data-src]:not([' + STATUS_ATTR + '=\"' + STATUS_LOADED + '\"])'\n\t\t+ ':not([' + STATUS_ATTR + '=\"' + STATUS_LOADING + '\"])';\n\n\t/**\n\t * Loads the given file.\n\t *\n\t * @param {string} src The URL or path of the source file to load.\n\t * @param {(result: string) => void} success\n\t * @param {(reason: string) => void} error\n\t */\n\tfunction loadFile(src, success, error) {\n\t\tvar xhr = new XMLHttpRequest();\n\t\txhr.open('GET', src, true);\n\t\txhr.onreadystatechange = function () {\n\t\t\tif (xhr.readyState == 4) {\n\t\t\t\tif (xhr.status < 400 && xhr.responseText) {\n\t\t\t\t\tsuccess(xhr.responseText);\n\t\t\t\t} else {\n\t\t\t\t\tif (xhr.status >= 400) {\n\t\t\t\t\t\terror(FAILURE_MESSAGE(xhr.status, xhr.statusText));\n\t\t\t\t\t} else {\n\t\t\t\t\t\terror(FAILURE_EMPTY_MESSAGE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\txhr.send(null);\n\t}\n\n\t/**\n\t * Parses the given range.\n\t *\n\t * This returns a range with inclusive ends.\n\t *\n\t * @param {string | null | undefined} range\n\t * @returns {[number, number | undefined] | undefined}\n\t */\n\tfunction parseRange(range) {\n\t\tvar m = /^\\s*(\\d+)\\s*(?:(,)\\s*(?:(\\d+)\\s*)?)?$/.exec(range || '');\n\t\tif (m) {\n\t\t\tvar start = Number(m[1]);\n\t\t\tvar comma = m[2];\n\t\t\tvar end = m[3];\n\n\t\t\tif (!comma) {\n\t\t\t\treturn [start, start];\n\t\t\t}\n\t\t\tif (!end) {\n\t\t\t\treturn [start, undefined];\n\t\t\t}\n\t\t\treturn [start, Number(end)];\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tPrism.hooks.add('before-highlightall', function (env) {\n\t\tenv.selector += ', ' + SELECTOR;\n\t});\n\n\tPrism.hooks.add('before-sanity-check', function (env) {\n\t\tvar pre = /** @type {HTMLPreElement} */ (env.element);\n\t\tif (pre.matches(SELECTOR)) {\n\t\t\tenv.code = ''; // fast-path the whole thing and go to complete\n\n\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_LOADING); // mark as loading\n\n\t\t\t// add code element with loading message\n\t\t\tvar code = pre.appendChild(document.createElement('CODE'));\n\t\t\tcode.textContent = LOADING_MESSAGE;\n\n\t\t\tvar src = pre.getAttribute('data-src');\n\n\t\t\tvar language = env.language;\n\t\t\tif (language === 'none') {\n\t\t\t\t// the language might be 'none' because there is no language set;\n\t\t\t\t// in this case, we want to use the extension as the language\n\t\t\t\tvar extension = (/\\.(\\w+)$/.exec(src) || [, 'none'])[1];\n\t\t\t\tlanguage = EXTENSIONS[extension] || extension;\n\t\t\t}\n\n\t\t\t// set language classes\n\t\t\tPrism.util.setLanguage(code, language);\n\t\t\tPrism.util.setLanguage(pre, language);\n\n\t\t\t// preload the language\n\t\t\tvar autoloader = Prism.plugins.autoloader;\n\t\t\tif (autoloader) {\n\t\t\t\tautoloader.loadLanguages(language);\n\t\t\t}\n\n\t\t\t// load file\n\t\t\tloadFile(\n\t\t\t\tsrc,\n\t\t\t\tfunction (text) {\n\t\t\t\t\t// mark as loaded\n\t\t\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_LOADED);\n\n\t\t\t\t\t// handle data-range\n\t\t\t\t\tvar range = parseRange(pre.getAttribute('data-range'));\n\t\t\t\t\tif (range) {\n\t\t\t\t\t\tvar lines = text.split(/\\r\\n?|\\n/g);\n\n\t\t\t\t\t\t// the range is one-based and inclusive on both ends\n\t\t\t\t\t\tvar start = range[0];\n\t\t\t\t\t\tvar end = range[1] == null ? lines.length : range[1];\n\n\t\t\t\t\t\tif (start < 0) { start += lines.length; }\n\t\t\t\t\t\tstart = Math.max(0, Math.min(start - 1, lines.length));\n\t\t\t\t\t\tif (end < 0) { end += lines.length; }\n\t\t\t\t\t\tend = Math.max(0, Math.min(end, lines.length));\n\n\t\t\t\t\t\ttext = lines.slice(start, end).join('\\n');\n\n\t\t\t\t\t\t// add data-start for line numbers\n\t\t\t\t\t\tif (!pre.hasAttribute('data-start')) {\n\t\t\t\t\t\t\tpre.setAttribute('data-start', String(start + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// highlight code\n\t\t\t\t\tcode.textContent = text;\n\t\t\t\t\tPrism.highlightElement(code);\n\t\t\t\t},\n\t\t\t\tfunction (error) {\n\t\t\t\t\t// mark as failed\n\t\t\t\t\tpre.setAttribute(STATUS_ATTR, STATUS_FAILED);\n\n\t\t\t\t\tcode.textContent = error;\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t});\n\n\tPrism.plugins.fileHighlight = {\n\t\t/**\n\t\t * Executes the File Highlight plugin for all matching `pre` elements under the given container.\n\t\t *\n\t\t * Note: Elements which are already loaded or currently loading will not be touched by this method.\n\t\t *\n\t\t * @param {ParentNode} [container=document]\n\t\t */\n\t\thighlight: function highlight(container) {\n\t\t\tvar elements = (container || document).querySelectorAll(SELECTOR);\n\n\t\t\tfor (var i = 0, element; (element = elements[i++]);) {\n\t\t\t\tPrism.highlightElement(element);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar logged = false;\n\t/** @deprecated Use `Prism.plugins.fileHighlight.highlight` instead. */\n\tPrism.fileHighlight = function () {\n\t\tif (!logged) {\n\t\t\tconsole.warn('Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.');\n\t\t\tlogged = true;\n\t\t}\n\t\tPrism.plugins.fileHighlight.highlight.apply(this, arguments);\n\t};\n\n}());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBLGtCQUFrQjs7QUFFbEIsa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBOztBQUVBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly96ZWR1eC1kb2NzLy4vbm9kZV9tb2R1bGVzL3ByaXNtanMvcHJpc20uanM/MDMxYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgQmVnaW4gcHJpc20tY29yZS5qc1xuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vLy8gPHJlZmVyZW5jZSBsaWI9XCJXZWJXb3JrZXJcIi8+XG5cbnZhciBfc2VsZiA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcblx0PyB3aW5kb3cgICAvLyBpZiBpbiBicm93c2VyXG5cdDogKFxuXHRcdCh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSlcblx0XHRcdD8gc2VsZiAvLyBpZiBpbiB3b3JrZXJcblx0XHRcdDoge30gICAvLyBpZiBpbiBub2RlIGpzXG5cdCk7XG5cbi8qKlxuICogUHJpc206IExpZ2h0d2VpZ2h0LCByb2J1c3QsIGVsZWdhbnQgc3ludGF4IGhpZ2hsaWdodGluZ1xuICpcbiAqIEBsaWNlbnNlIE1JVCA8aHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQ+XG4gKiBAYXV0aG9yIExlYSBWZXJvdSA8aHR0cHM6Ly9sZWEudmVyb3UubWU+XG4gKiBAbmFtZXNwYWNlXG4gKiBAcHVibGljXG4gKi9cbnZhciBQcmlzbSA9IChmdW5jdGlvbiAoX3NlbGYpIHtcblxuXHQvLyBQcml2YXRlIGhlbHBlciB2YXJzXG5cdHZhciBsYW5nID0gLyg/Ol58XFxzKWxhbmcoPzp1YWdlKT8tKFtcXHctXSspKD89XFxzfCQpL2k7XG5cdHZhciB1bmlxdWVJZCA9IDA7XG5cblx0Ly8gVGhlIGdyYW1tYXIgb2JqZWN0IGZvciBwbGFpbnRleHRcblx0dmFyIHBsYWluVGV4dEdyYW1tYXIgPSB7fTtcblxuXG5cdHZhciBfID0ge1xuXHRcdC8qKlxuXHRcdCAqIEJ5IGRlZmF1bHQsIFByaXNtIHdpbGwgYXR0ZW1wdCB0byBoaWdobGlnaHQgYWxsIGNvZGUgZWxlbWVudHMgKGJ5IGNhbGxpbmcge0BsaW5rIFByaXNtLmhpZ2hsaWdodEFsbH0pIG9uIHRoZVxuXHRcdCAqIGN1cnJlbnQgcGFnZSBhZnRlciB0aGUgcGFnZSBmaW5pc2hlZCBsb2FkaW5nLiBUaGlzIG1pZ2h0IGJlIGEgcHJvYmxlbSBpZiBlLmcuIHlvdSB3YW50ZWQgdG8gYXN5bmNocm9ub3VzbHkgbG9hZFxuXHRcdCAqIGFkZGl0aW9uYWwgbGFuZ3VhZ2VzIG9yIHBsdWdpbnMgeW91cnNlbGYuXG5cdFx0ICpcblx0XHQgKiBCeSBzZXR0aW5nIHRoaXMgdmFsdWUgdG8gYHRydWVgLCBQcmlzbSB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IGhpZ2hsaWdodCBhbGwgY29kZSBlbGVtZW50cyBvbiB0aGUgcGFnZS5cblx0XHQgKlxuXHRcdCAqIFlvdSBvYnZpb3VzbHkgaGF2ZSB0byBjaGFuZ2UgdGhpcyB2YWx1ZSBiZWZvcmUgdGhlIGF1dG9tYXRpYyBoaWdobGlnaHRpbmcgc3RhcnRlZC4gVG8gZG8gdGhpcywgeW91IGNhbiBhZGQgYW5cblx0XHQgKiBlbXB0eSBQcmlzbSBvYmplY3QgaW50byB0aGUgZ2xvYmFsIHNjb3BlIGJlZm9yZSBsb2FkaW5nIHRoZSBQcmlzbSBzY3JpcHQgbGlrZSB0aGlzOlxuXHRcdCAqXG5cdFx0ICogYGBganNcblx0XHQgKiB3aW5kb3cuUHJpc20gPSB3aW5kb3cuUHJpc20gfHwge307XG5cdFx0ICogUHJpc20ubWFudWFsID0gdHJ1ZTtcblx0XHQgKiAvLyBhZGQgYSBuZXcgPHNjcmlwdD4gdG8gbG9hZCBQcmlzbSdzIHNjcmlwdFxuXHRcdCAqIGBgYFxuXHRcdCAqXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0bWFudWFsOiBfc2VsZi5QcmlzbSAmJiBfc2VsZi5QcmlzbS5tYW51YWwsXG5cdFx0LyoqXG5cdFx0ICogQnkgZGVmYXVsdCwgaWYgUHJpc20gaXMgaW4gYSB3ZWIgd29ya2VyLCBpdCBhc3N1bWVzIHRoYXQgaXQgaXMgaW4gYSB3b3JrZXIgaXQgY3JlYXRlZCBpdHNlbGYsIHNvIGl0IHVzZXNcblx0XHQgKiBgYWRkRXZlbnRMaXN0ZW5lcmAgdG8gY29tbXVuaWNhdGUgd2l0aCBpdHMgcGFyZW50IGluc3RhbmNlLiBIb3dldmVyLCBpZiB5b3UncmUgdXNpbmcgUHJpc20gbWFudWFsbHkgaW4geW91clxuXHRcdCAqIG93biB3b3JrZXIsIHlvdSBkb24ndCB3YW50IGl0IHRvIGRvIHRoaXMuXG5cdFx0ICpcblx0XHQgKiBCeSBzZXR0aW5nIHRoaXMgdmFsdWUgdG8gYHRydWVgLCBQcmlzbSB3aWxsIG5vdCBhZGQgaXRzIG93biBsaXN0ZW5lcnMgdG8gdGhlIHdvcmtlci5cblx0XHQgKlxuXHRcdCAqIFlvdSBvYnZpb3VzbHkgaGF2ZSB0byBjaGFuZ2UgdGhpcyB2YWx1ZSBiZWZvcmUgUHJpc20gZXhlY3V0ZXMuIFRvIGRvIHRoaXMsIHlvdSBjYW4gYWRkIGFuXG5cdFx0ICogZW1wdHkgUHJpc20gb2JqZWN0IGludG8gdGhlIGdsb2JhbCBzY29wZSBiZWZvcmUgbG9hZGluZyB0aGUgUHJpc20gc2NyaXB0IGxpa2UgdGhpczpcblx0XHQgKlxuXHRcdCAqIGBgYGpzXG5cdFx0ICogd2luZG93LlByaXNtID0gd2luZG93LlByaXNtIHx8IHt9O1xuXHRcdCAqIFByaXNtLmRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlciA9IHRydWU7XG5cdFx0ICogLy8gTG9hZCBQcmlzbSdzIHNjcmlwdFxuXHRcdCAqIGBgYFxuXHRcdCAqXG5cdFx0ICogQGRlZmF1bHQgZmFsc2Vcblx0XHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0ZGlzYWJsZVdvcmtlck1lc3NhZ2VIYW5kbGVyOiBfc2VsZi5QcmlzbSAmJiBfc2VsZi5QcmlzbS5kaXNhYmxlV29ya2VyTWVzc2FnZUhhbmRsZXIsXG5cblx0XHQvKipcblx0XHQgKiBBIG5hbWVzcGFjZSBmb3IgdXRpbGl0eSBtZXRob2RzLlxuXHRcdCAqXG5cdFx0ICogQWxsIGZ1bmN0aW9uIGluIHRoaXMgbmFtZXNwYWNlIHRoYXQgYXJlIG5vdCBleHBsaWNpdGx5IG1hcmtlZCBhcyBfcHVibGljXyBhcmUgZm9yIF9faW50ZXJuYWwgdXNlIG9ubHlfXyBhbmQgbWF5XG5cdFx0ICogY2hhbmdlIG9yIGRpc2FwcGVhciBhdCBhbnkgdGltZS5cblx0XHQgKlxuXHRcdCAqIEBuYW1lc3BhY2Vcblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKi9cblx0XHR1dGlsOiB7XG5cdFx0XHRlbmNvZGU6IGZ1bmN0aW9uIGVuY29kZSh0b2tlbnMpIHtcblx0XHRcdFx0aWYgKHRva2VucyBpbnN0YW5jZW9mIFRva2VuKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBUb2tlbih0b2tlbnMudHlwZSwgZW5jb2RlKHRva2Vucy5jb250ZW50KSwgdG9rZW5zLmFsaWFzKTtcblx0XHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRva2VucykpIHtcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5zLm1hcChlbmNvZGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiB0b2tlbnMucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvXFx1MDBhMC9nLCAnICcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHR5cGUgb2YgdGhlIGdpdmVuIHZhbHVlLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7YW55fSBvXG5cdFx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHRcdFx0ICogQGV4YW1wbGVcblx0XHRcdCAqIHR5cGUobnVsbCkgICAgICA9PT0gJ051bGwnXG5cdFx0XHQgKiB0eXBlKHVuZGVmaW5lZCkgPT09ICdVbmRlZmluZWQnXG5cdFx0XHQgKiB0eXBlKDEyMykgICAgICAgPT09ICdOdW1iZXInXG5cdFx0XHQgKiB0eXBlKCdmb28nKSAgICAgPT09ICdTdHJpbmcnXG5cdFx0XHQgKiB0eXBlKHRydWUpICAgICAgPT09ICdCb29sZWFuJ1xuXHRcdFx0ICogdHlwZShbMSwgMl0pICAgID09PSAnQXJyYXknXG5cdFx0XHQgKiB0eXBlKHt9KSAgICAgICAgPT09ICdPYmplY3QnXG5cdFx0XHQgKiB0eXBlKFN0cmluZykgICAgPT09ICdGdW5jdGlvbidcblx0XHRcdCAqIHR5cGUoL2FiYysvKSAgICA9PT0gJ1JlZ0V4cCdcblx0XHRcdCAqL1xuXHRcdFx0dHlwZTogZnVuY3Rpb24gKG8pIHtcblx0XHRcdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIFJldHVybnMgYSB1bmlxdWUgbnVtYmVyIGZvciB0aGUgZ2l2ZW4gb2JqZWN0LiBMYXRlciBjYWxscyB3aWxsIHN0aWxsIHJldHVybiB0aGUgc2FtZSBudW1iZXIuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3R9IG9ialxuXHRcdFx0ICogQHJldHVybnMge251bWJlcn1cblx0XHRcdCAqL1xuXHRcdFx0b2JqSWQ6IGZ1bmN0aW9uIChvYmopIHtcblx0XHRcdFx0aWYgKCFvYmpbJ19faWQnXSkge1xuXHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosICdfX2lkJywgeyB2YWx1ZTogKyt1bmlxdWVJZCB9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gb2JqWydfX2lkJ107XG5cdFx0XHR9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIENyZWF0ZXMgYSBkZWVwIGNsb25lIG9mIHRoZSBnaXZlbiBvYmplY3QuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIG1haW4gaW50ZW5kZWQgdXNlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdG8gY2xvbmUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtUfSBvXG5cdFx0XHQgKiBAcGFyYW0ge1JlY29yZDxudW1iZXIsIGFueT59IFt2aXNpdGVkXVxuXHRcdFx0ICogQHJldHVybnMge1R9XG5cdFx0XHQgKiBAdGVtcGxhdGUgVFxuXHRcdFx0ICovXG5cdFx0XHRjbG9uZTogZnVuY3Rpb24gZGVlcENsb25lKG8sIHZpc2l0ZWQpIHtcblx0XHRcdFx0dmlzaXRlZCA9IHZpc2l0ZWQgfHwge307XG5cblx0XHRcdFx0dmFyIGNsb25lOyB2YXIgaWQ7XG5cdFx0XHRcdHN3aXRjaCAoXy51dGlsLnR5cGUobykpIHtcblx0XHRcdFx0XHRjYXNlICdPYmplY3QnOlxuXHRcdFx0XHRcdFx0aWQgPSBfLnV0aWwub2JqSWQobyk7XG5cdFx0XHRcdFx0XHRpZiAodmlzaXRlZFtpZF0pIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHZpc2l0ZWRbaWRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2xvbmUgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICovICh7fSk7XG5cdFx0XHRcdFx0XHR2aXNpdGVkW2lkXSA9IGNsb25lO1xuXG5cdFx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbykge1xuXHRcdFx0XHRcdFx0XHRpZiAoby5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xvbmVba2V5XSA9IGRlZXBDbG9uZShvW2tleV0sIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKGNsb25lKTtcblxuXHRcdFx0XHRcdGNhc2UgJ0FycmF5Jzpcblx0XHRcdFx0XHRcdGlkID0gXy51dGlsLm9iaklkKG8pO1xuXHRcdFx0XHRcdFx0aWYgKHZpc2l0ZWRbaWRdKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2aXNpdGVkW2lkXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNsb25lID0gW107XG5cdFx0XHRcdFx0XHR2aXNpdGVkW2lkXSA9IGNsb25lO1xuXG5cdFx0XHRcdFx0XHQoLyoqIEB0eXBlIHtBcnJheX0gKi8oLyoqIEB0eXBlIHthbnl9ICovKG8pKSkuZm9yRWFjaChmdW5jdGlvbiAodiwgaSkge1xuXHRcdFx0XHRcdFx0XHRjbG9uZVtpXSA9IGRlZXBDbG9uZSh2LCB2aXNpdGVkKTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovIChjbG9uZSk7XG5cblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0cmV0dXJuIG87XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyB0aGUgUHJpc20gbGFuZ3VhZ2Ugb2YgdGhlIGdpdmVuIGVsZW1lbnQgc2V0IGJ5IGEgYGxhbmd1YWdlLXh4eHhgIG9yIGBsYW5nLXh4eHhgIGNsYXNzLlxuXHRcdFx0ICpcblx0XHRcdCAqIElmIG5vIGxhbmd1YWdlIGlzIHNldCBmb3IgdGhlIGVsZW1lbnQgb3IgdGhlIGVsZW1lbnQgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCBgbm9uZWAgd2lsbCBiZSByZXR1cm5lZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcblx0XHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdFx0XHQgKi9cblx0XHRcdGdldExhbmd1YWdlOiBmdW5jdGlvbiAoZWxlbWVudCkge1xuXHRcdFx0XHR3aGlsZSAoZWxlbWVudCkge1xuXHRcdFx0XHRcdHZhciBtID0gbGFuZy5leGVjKGVsZW1lbnQuY2xhc3NOYW1lKTtcblx0XHRcdFx0XHRpZiAobSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG1bMV0udG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gJ25vbmUnO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBTZXRzIHRoZSBQcmlzbSBgbGFuZ3VhZ2UteHh4eGAgY2xhc3Mgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2Vcblx0XHRcdCAqIEByZXR1cm5zIHt2b2lkfVxuXHRcdFx0ICovXG5cdFx0XHRzZXRMYW5ndWFnZTogZnVuY3Rpb24gKGVsZW1lbnQsIGxhbmd1YWdlKSB7XG5cdFx0XHRcdC8vIHJlbW92ZSBhbGwgYGxhbmd1YWdlLXh4eHhgIGNsYXNzZXNcblx0XHRcdFx0Ly8gKHRoaXMgbWlnaHQgbGVhdmUgYmVoaW5kIGEgbGVhZGluZyBzcGFjZSlcblx0XHRcdFx0ZWxlbWVudC5jbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTmFtZS5yZXBsYWNlKFJlZ0V4cChsYW5nLCAnZ2knKSwgJycpO1xuXG5cdFx0XHRcdC8vIGFkZCB0aGUgbmV3IGBsYW5ndWFnZS14eHh4YCBjbGFzc1xuXHRcdFx0XHQvLyAodXNpbmcgYGNsYXNzTGlzdGAgd2lsbCBhdXRvbWF0aWNhbGx5IGNsZWFuIHVwIHNwYWNlcyBmb3IgdXMpXG5cdFx0XHRcdGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnbGFuZ3VhZ2UtJyArIGxhbmd1YWdlKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUmV0dXJucyB0aGUgc2NyaXB0IGVsZW1lbnQgdGhhdCBpcyBjdXJyZW50bHkgZXhlY3V0aW5nLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoaXMgZG9lcyBfX25vdF9fIHdvcmsgZm9yIGxpbmUgc2NyaXB0IGVsZW1lbnQuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHJldHVybnMge0hUTUxTY3JpcHRFbGVtZW50IHwgbnVsbH1cblx0XHRcdCAqL1xuXHRcdFx0Y3VycmVudFNjcmlwdDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICgnY3VycmVudFNjcmlwdCcgaW4gZG9jdW1lbnQgJiYgMSA8IDIgLyogaGFjayB0byB0cmlwIFRTJyBmbG93IGFuYWx5c2lzICovKSB7XG5cdFx0XHRcdFx0cmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJRTExIHdvcmthcm91bmRcblx0XHRcdFx0Ly8gd2UnbGwgZ2V0IHRoZSBzcmMgb2YgdGhlIGN1cnJlbnQgc2NyaXB0IGJ5IHBhcnNpbmcgSUUxMSdzIGVycm9yIHN0YWNrIHRyYWNlXG5cdFx0XHRcdC8vIHRoaXMgd2lsbCBub3Qgd29yayBmb3IgaW5saW5lIHNjcmlwdHNcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcigpO1xuXHRcdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0XHQvLyBHZXQgZmlsZSBzcmMgdXJsIGZyb20gc3RhY2suIFNwZWNpZmljYWxseSB3b3JrcyB3aXRoIHRoZSBmb3JtYXQgb2Ygc3RhY2sgdHJhY2VzIGluIElFLlxuXHRcdFx0XHRcdC8vIEEgc3RhY2sgd2lsbCBsb29rIGxpa2UgdGhpczpcblx0XHRcdFx0XHQvL1xuXHRcdFx0XHRcdC8vIEVycm9yXG5cdFx0XHRcdFx0Ly8gICAgYXQgXy51dGlsLmN1cnJlbnRTY3JpcHQgKGh0dHA6Ly9sb2NhbGhvc3QvY29tcG9uZW50cy9wcmlzbS1jb3JlLmpzOjExOTo1KVxuXHRcdFx0XHRcdC8vICAgIGF0IEdsb2JhbCBjb2RlIChodHRwOi8vbG9jYWxob3N0L2NvbXBvbmVudHMvcHJpc20tY29yZS5qczo2MDY6MSlcblxuXHRcdFx0XHRcdHZhciBzcmMgPSAoL2F0IFteKFxcclxcbl0qXFwoKC4qKTpbXjpdKzpbXjpdK1xcKSQvaS5leGVjKGVyci5zdGFjaykgfHwgW10pWzFdO1xuXHRcdFx0XHRcdGlmIChzcmMpIHtcblx0XHRcdFx0XHRcdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSBpbiBzY3JpcHRzKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChzY3JpcHRzW2ldLnNyYyA9PSBzcmMpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gc2NyaXB0c1tpXTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBSZXR1cm5zIHdoZXRoZXIgYSBnaXZlbiBjbGFzcyBpcyBhY3RpdmUgZm9yIGBlbGVtZW50YC5cblx0XHRcdCAqXG5cdFx0XHQgKiBUaGUgY2xhc3MgY2FuIGJlIGFjdGl2YXRlZCBpZiBgZWxlbWVudGAgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIHRoZSBnaXZlbiBjbGFzcyBhbmQgaXQgY2FuIGJlIGRlYWN0aXZhdGVkXG5cdFx0XHQgKiBpZiBgZWxlbWVudGAgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIHRoZSBuZWdhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIGNsYXNzLiBUaGUgX25lZ2F0ZWQgdmVyc2lvbl8gb2YgdGhlXG5cdFx0XHQgKiBnaXZlbiBjbGFzcyBpcyBqdXN0IHRoZSBnaXZlbiBjbGFzcyB3aXRoIGEgYG5vLWAgcHJlZml4LlxuXHRcdFx0ICpcblx0XHRcdCAqIFdoZXRoZXIgdGhlIGNsYXNzIGlzIGFjdGl2ZSBpcyBkZXRlcm1pbmVkIGJ5IHRoZSBjbG9zZXN0IGFuY2VzdG9yIG9mIGBlbGVtZW50YCAod2hlcmUgYGVsZW1lbnRgIGl0c2VsZiBpc1xuXHRcdFx0ICogY2xvc2VzdCBhbmNlc3RvcikgdGhhdCBoYXMgdGhlIGdpdmVuIGNsYXNzIG9yIHRoZSBuZWdhdGVkIHZlcnNpb24gb2YgaXQuIElmIG5laXRoZXIgYGVsZW1lbnRgIG5vciBhbnkgb2YgaXRzXG5cdFx0XHQgKiBhbmNlc3RvcnMgaGF2ZSB0aGUgZ2l2ZW4gY2xhc3Mgb3IgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiBpdCwgdGhlbiB0aGUgZGVmYXVsdCBhY3RpdmF0aW9uIHdpbGwgYmUgcmV0dXJuZWQuXG5cdFx0XHQgKlxuXHRcdFx0ICogSW4gdGhlIHBhcmFkb3hpY2FsIHNpdHVhdGlvbiB3aGVyZSB0aGUgY2xvc2VzdCBhbmNlc3RvciBjb250YWlucyBfX2JvdGhfXyB0aGUgZ2l2ZW4gY2xhc3MgYW5kIHRoZSBuZWdhdGVkXG5cdFx0XHQgKiB2ZXJzaW9uIG9mIGl0LCB0aGUgY2xhc3MgaXMgY29uc2lkZXJlZCBhY3RpdmUuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG5cdFx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtkZWZhdWx0QWN0aXZhdGlvbj1mYWxzZV1cblx0XHRcdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHRcdFx0ICovXG5cdFx0XHRpc0FjdGl2ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNsYXNzTmFtZSwgZGVmYXVsdEFjdGl2YXRpb24pIHtcblx0XHRcdFx0dmFyIG5vID0gJ25vLScgKyBjbGFzc05hbWU7XG5cblx0XHRcdFx0d2hpbGUgKGVsZW1lbnQpIHtcblx0XHRcdFx0XHR2YXIgY2xhc3NMaXN0ID0gZWxlbWVudC5jbGFzc0xpc3Q7XG5cdFx0XHRcdFx0aWYgKGNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKGNsYXNzTGlzdC5jb250YWlucyhubykpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gISFkZWZhdWx0QWN0aXZhdGlvbjtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVGhpcyBuYW1lc3BhY2UgY29udGFpbnMgYWxsIGN1cnJlbnRseSBsb2FkZWQgbGFuZ3VhZ2VzIGFuZCB0aGUgc29tZSBoZWxwZXIgZnVuY3Rpb25zIHRvIGNyZWF0ZSBhbmQgbW9kaWZ5IGxhbmd1YWdlcy5cblx0XHQgKlxuXHRcdCAqIEBuYW1lc3BhY2Vcblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0bGFuZ3VhZ2VzOiB7XG5cdFx0XHQvKipcblx0XHRcdCAqIFRoZSBncmFtbWFyIGZvciBwbGFpbiwgdW5mb3JtYXR0ZWQgdGV4dC5cblx0XHRcdCAqL1xuXHRcdFx0cGxhaW46IHBsYWluVGV4dEdyYW1tYXIsXG5cdFx0XHRwbGFpbnRleHQ6IHBsYWluVGV4dEdyYW1tYXIsXG5cdFx0XHR0ZXh0OiBwbGFpblRleHRHcmFtbWFyLFxuXHRcdFx0dHh0OiBwbGFpblRleHRHcmFtbWFyLFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIENyZWF0ZXMgYSBkZWVwIGNvcHkgb2YgdGhlIGxhbmd1YWdlIHdpdGggdGhlIGdpdmVuIGlkIGFuZCBhcHBlbmRzIHRoZSBnaXZlbiB0b2tlbnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogSWYgYSB0b2tlbiBpbiBgcmVkZWZgIGFsc28gYXBwZWFycyBpbiB0aGUgY29waWVkIGxhbmd1YWdlLCB0aGVuIHRoZSBleGlzdGluZyB0b2tlbiBpbiB0aGUgY29waWVkIGxhbmd1YWdlXG5cdFx0XHQgKiB3aWxsIGJlIG92ZXJ3cml0dGVuIGF0IGl0cyBvcmlnaW5hbCBwb3NpdGlvbi5cblx0XHRcdCAqXG5cdFx0XHQgKiAjIyBCZXN0IHByYWN0aWNlc1xuXHRcdFx0ICpcblx0XHRcdCAqIFNpbmNlIHRoZSBwb3NpdGlvbiBvZiBvdmVyd3JpdGluZyB0b2tlbnMgKHRva2VuIGluIGByZWRlZmAgdGhhdCBvdmVyd3JpdGUgdG9rZW5zIGluIHRoZSBjb3BpZWQgbGFuZ3VhZ2UpXG5cdFx0XHQgKiBkb2Vzbid0IG1hdHRlciwgdGhleSBjYW4gdGVjaG5pY2FsbHkgYmUgaW4gYW55IG9yZGVyLiBIb3dldmVyLCB0aGlzIGNhbiBiZSBjb25mdXNpbmcgdG8gb3RoZXJzIHRoYXQgdHJ5aW5nIHRvXG5cdFx0XHQgKiB1bmRlcnN0YW5kIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9uIGJlY2F1c2UsIG5vcm1hbGx5LCB0aGUgb3JkZXIgb2YgdG9rZW5zIG1hdHRlcnMgaW4gUHJpc20gZ3JhbW1hcnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlcmVmb3JlLCBpdCBpcyBlbmNvdXJhZ2VkIHRvIG9yZGVyIG92ZXJ3cml0aW5nIHRva2VucyBhY2NvcmRpbmcgdG8gdGhlIHBvc2l0aW9ucyBvZiB0aGUgb3ZlcndyaXR0ZW4gdG9rZW5zLlxuXHRcdFx0ICogRnVydGhlcm1vcmUsIGFsbCBub24tb3ZlcndyaXRpbmcgdG9rZW5zIHNob3VsZCBiZSBwbGFjZWQgYWZ0ZXIgdGhlIG92ZXJ3cml0aW5nIG9uZXMuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgbGFuZ3VhZ2UgdG8gZXh0ZW5kLiBUaGlzIGhhcyB0byBiZSBhIGtleSBpbiBgUHJpc20ubGFuZ3VhZ2VzYC5cblx0XHRcdCAqIEBwYXJhbSB7R3JhbW1hcn0gcmVkZWYgVGhlIG5ldyB0b2tlbnMgdG8gYXBwZW5kLlxuXHRcdFx0ICogQHJldHVybnMge0dyYW1tYXJ9IFRoZSBuZXcgbGFuZ3VhZ2UgY3JlYXRlZC5cblx0XHRcdCAqIEBwdWJsaWNcblx0XHRcdCAqIEBleGFtcGxlXG5cdFx0XHQgKiBQcmlzbS5sYW5ndWFnZXNbJ2Nzcy13aXRoLWNvbG9ycyddID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnY3NzJywge1xuXHRcdFx0ICogICAgIC8vIFByaXNtLmxhbmd1YWdlcy5jc3MgYWxyZWFkeSBoYXMgYSAnY29tbWVudCcgdG9rZW4sIHNvIHRoaXMgdG9rZW4gd2lsbCBvdmVyd3JpdGUgQ1NTJyAnY29tbWVudCcgdG9rZW5cblx0XHRcdCAqICAgICAvLyBhdCBpdHMgb3JpZ2luYWwgcG9zaXRpb25cblx0XHRcdCAqICAgICAnY29tbWVudCc6IHsgLi4uIH0sXG5cdFx0XHQgKiAgICAgLy8gQ1NTIGRvZXNuJ3QgaGF2ZSBhICdjb2xvcicgdG9rZW4sIHNvIHRoaXMgdG9rZW4gd2lsbCBiZSBhcHBlbmRlZFxuXHRcdFx0ICogICAgICdjb2xvcic6IC9cXGIoPzpyZWR8Z3JlZW58Ymx1ZSlcXGIvXG5cdFx0XHQgKiB9KTtcblx0XHRcdCAqL1xuXHRcdFx0ZXh0ZW5kOiBmdW5jdGlvbiAoaWQsIHJlZGVmKSB7XG5cdFx0XHRcdHZhciBsYW5nID0gXy51dGlsLmNsb25lKF8ubGFuZ3VhZ2VzW2lkXSk7XG5cblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIHJlZGVmKSB7XG5cdFx0XHRcdFx0bGFuZ1trZXldID0gcmVkZWZba2V5XTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBsYW5nO1xuXHRcdFx0fSxcblxuXHRcdFx0LyoqXG5cdFx0XHQgKiBJbnNlcnRzIHRva2VucyBfYmVmb3JlXyBhbm90aGVyIHRva2VuIGluIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBvciBhbnkgb3RoZXIgZ3JhbW1hci5cblx0XHRcdCAqXG5cdFx0XHQgKiAjIyBVc2FnZVxuXHRcdFx0ICpcblx0XHRcdCAqIFRoaXMgaGVscGVyIG1ldGhvZCBtYWtlcyBpdCBlYXN5IHRvIG1vZGlmeSBleGlzdGluZyBsYW5ndWFnZXMuIEZvciBleGFtcGxlLCB0aGUgQ1NTIGxhbmd1YWdlIGRlZmluaXRpb25cblx0XHRcdCAqIG5vdCBvbmx5IGRlZmluZXMgQ1NTIGhpZ2hsaWdodGluZyBmb3IgQ1NTIGRvY3VtZW50cywgYnV0IGFsc28gbmVlZHMgdG8gZGVmaW5lIGhpZ2hsaWdodGluZyBmb3IgQ1NTIGVtYmVkZGVkXG5cdFx0XHQgKiBpbiBIVE1MIHRocm91Z2ggYDxzdHlsZT5gIGVsZW1lbnRzLiBUbyBkbyB0aGlzLCBpdCBuZWVkcyB0byBtb2RpZnkgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgIGFuZCBhZGQgdGhlXG5cdFx0XHQgKiBhcHByb3ByaWF0ZSB0b2tlbnMuIEhvd2V2ZXIsIGBQcmlzbS5sYW5ndWFnZXMubWFya3VwYCBpcyBhIHJlZ3VsYXIgSmF2YVNjcmlwdCBvYmplY3QgbGl0ZXJhbCwgc28gaWYgeW91IGRvXG5cdFx0XHQgKiB0aGlzOlxuXHRcdFx0ICpcblx0XHRcdCAqIGBgYGpzXG5cdFx0XHQgKiBQcmlzbS5sYW5ndWFnZXMubWFya3VwLnN0eWxlID0ge1xuXHRcdFx0ICogICAgIC8vIHRva2VuXG5cdFx0XHQgKiB9O1xuXHRcdFx0ICogYGBgXG5cdFx0XHQgKlxuXHRcdFx0ICogdGhlbiB0aGUgYHN0eWxlYCB0b2tlbiB3aWxsIGJlIGFkZGVkIChhbmQgcHJvY2Vzc2VkKSBhdCB0aGUgZW5kLiBgaW5zZXJ0QmVmb3JlYCBhbGxvd3MgeW91IHRvIGluc2VydCB0b2tlbnNcblx0XHRcdCAqIGJlZm9yZSBleGlzdGluZyB0b2tlbnMuIEZvciB0aGUgQ1NTIGV4YW1wbGUgYWJvdmUsIHlvdSB3b3VsZCB1c2UgaXQgbGlrZSB0aGlzOlxuXHRcdFx0ICpcblx0XHRcdCAqIGBgYGpzXG5cdFx0XHQgKiBQcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdtYXJrdXAnLCAnY2RhdGEnLCB7XG5cdFx0XHQgKiAgICAgJ3N0eWxlJzoge1xuXHRcdFx0ICogICAgICAgICAvLyB0b2tlblxuXHRcdFx0ICogICAgIH1cblx0XHRcdCAqIH0pO1xuXHRcdFx0ICogYGBgXG5cdFx0XHQgKlxuXHRcdFx0ICogIyMgU3BlY2lhbCBjYXNlc1xuXHRcdFx0ICpcblx0XHRcdCAqIElmIHRoZSBncmFtbWFycyBvZiBgaW5zaWRlYCBhbmQgYGluc2VydGAgaGF2ZSB0b2tlbnMgd2l0aCB0aGUgc2FtZSBuYW1lLCB0aGUgdG9rZW5zIGluIGBpbnNpZGVgJ3MgZ3JhbW1hclxuXHRcdFx0ICogd2lsbCBiZSBpZ25vcmVkLlxuXHRcdFx0ICpcblx0XHRcdCAqIFRoaXMgYmVoYXZpb3IgY2FuIGJlIHVzZWQgdG8gaW5zZXJ0IHRva2VucyBhZnRlciBgYmVmb3JlYDpcblx0XHRcdCAqXG5cdFx0XHQgKiBgYGBqc1xuXHRcdFx0ICogUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NvbW1lbnQnLCB7XG5cdFx0XHQgKiAgICAgJ2NvbW1lbnQnOiBQcmlzbS5sYW5ndWFnZXMubWFya3VwLmNvbW1lbnQsXG5cdFx0XHQgKiAgICAgLy8gdG9rZW5zIGFmdGVyICdjb21tZW50J1xuXHRcdFx0ICogfSk7XG5cdFx0XHQgKiBgYGBcblx0XHRcdCAqXG5cdFx0XHQgKiAjIyBMaW1pdGF0aW9uc1xuXHRcdFx0ICpcblx0XHRcdCAqIFRoZSBtYWluIHByb2JsZW0gYGluc2VydEJlZm9yZWAgaGFzIHRvIHNvbHZlIGlzIGl0ZXJhdGlvbiBvcmRlci4gU2luY2UgRVMyMDE1LCB0aGUgaXRlcmF0aW9uIG9yZGVyIGZvciBvYmplY3Rcblx0XHRcdCAqIHByb3BlcnRpZXMgaXMgZ3VhcmFudGVlZCB0byBiZSB0aGUgaW5zZXJ0aW9uIG9yZGVyIChleGNlcHQgZm9yIGludGVnZXIga2V5cykgYnV0IHNvbWUgYnJvd3NlcnMgYmVoYXZlXG5cdFx0XHQgKiBkaWZmZXJlbnRseSB3aGVuIGtleXMgYXJlIGRlbGV0ZWQgYW5kIHJlLWluc2VydGVkLiBTbyBgaW5zZXJ0QmVmb3JlYCBjYW4ndCBiZSBpbXBsZW1lbnRlZCBieSB0ZW1wb3JhcmlseVxuXHRcdFx0ICogZGVsZXRpbmcgcHJvcGVydGllcyB3aGljaCBpcyBuZWNlc3NhcnkgdG8gaW5zZXJ0IGF0IGFyYml0cmFyeSBwb3NpdGlvbnMuXG5cdFx0XHQgKlxuXHRcdFx0ICogVG8gc29sdmUgdGhpcyBwcm9ibGVtLCBgaW5zZXJ0QmVmb3JlYCBkb2Vzbid0IGFjdHVhbGx5IGluc2VydCB0aGUgZ2l2ZW4gdG9rZW5zIGludG8gdGhlIHRhcmdldCBvYmplY3QuXG5cdFx0XHQgKiBJbnN0ZWFkLCBpdCB3aWxsIGNyZWF0ZSBhIG5ldyBvYmplY3QgYW5kIHJlcGxhY2UgYWxsIHJlZmVyZW5jZXMgdG8gdGhlIHRhcmdldCBvYmplY3Qgd2l0aCB0aGUgbmV3IG9uZS4gVGhpc1xuXHRcdFx0ICogY2FuIGJlIGRvbmUgd2l0aG91dCB0ZW1wb3JhcmlseSBkZWxldGluZyBwcm9wZXJ0aWVzLCBzbyB0aGUgaXRlcmF0aW9uIG9yZGVyIGlzIHdlbGwtZGVmaW5lZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBIb3dldmVyLCBvbmx5IHJlZmVyZW5jZXMgdGhhdCBjYW4gYmUgcmVhY2hlZCBmcm9tIGBQcmlzbS5sYW5ndWFnZXNgIG9yIGBpbnNlcnRgIHdpbGwgYmUgcmVwbGFjZWQuIEkuZS4gaWZcblx0XHRcdCAqIHlvdSBob2xkIHRoZSB0YXJnZXQgb2JqZWN0IGluIGEgdmFyaWFibGUsIHRoZW4gdGhlIHZhbHVlIG9mIHRoZSB2YXJpYWJsZSB3aWxsIG5vdCBjaGFuZ2UuXG5cdFx0XHQgKlxuXHRcdFx0ICogYGBganNcblx0XHRcdCAqIHZhciBvbGRNYXJrdXAgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuXHRcdFx0ICogdmFyIG5ld01hcmt1cCA9IFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjb21tZW50JywgeyAuLi4gfSk7XG5cdFx0XHQgKlxuXHRcdFx0ICogYXNzZXJ0KG9sZE1hcmt1cCAhPT0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCk7XG5cdFx0XHQgKiBhc3NlcnQobmV3TWFya3VwID09PSBQcmlzbS5sYW5ndWFnZXMubWFya3VwKTtcblx0XHRcdCAqIGBgYFxuXHRcdFx0ICpcblx0XHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBpbnNpZGUgVGhlIHByb3BlcnR5IG9mIGByb290YCAoZS5nLiBhIGxhbmd1YWdlIGlkIGluIGBQcmlzbS5sYW5ndWFnZXNgKSB0aGF0IGNvbnRhaW5zIHRoZVxuXHRcdFx0ICogb2JqZWN0IHRvIGJlIG1vZGlmaWVkLlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IGJlZm9yZSBUaGUga2V5IHRvIGluc2VydCBiZWZvcmUuXG5cdFx0XHQgKiBAcGFyYW0ge0dyYW1tYXJ9IGluc2VydCBBbiBvYmplY3QgY29udGFpbmluZyB0aGUga2V5LXZhbHVlIHBhaXJzIHRvIGJlIGluc2VydGVkLlxuXHRcdFx0ICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBbcm9vdF0gVGhlIG9iamVjdCBjb250YWluaW5nIGBpbnNpZGVgLCBpLmUuIHRoZSBvYmplY3QgdGhhdCBjb250YWlucyB0aGVcblx0XHRcdCAqIG9iamVjdCB0byBiZSBtb2RpZmllZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBEZWZhdWx0cyB0byBgUHJpc20ubGFuZ3VhZ2VzYC5cblx0XHRcdCAqIEByZXR1cm5zIHtHcmFtbWFyfSBUaGUgbmV3IGdyYW1tYXIgb2JqZWN0LlxuXHRcdFx0ICogQHB1YmxpY1xuXHRcdFx0ICovXG5cdFx0XHRpbnNlcnRCZWZvcmU6IGZ1bmN0aW9uIChpbnNpZGUsIGJlZm9yZSwgaW5zZXJ0LCByb290KSB7XG5cdFx0XHRcdHJvb3QgPSByb290IHx8IC8qKiBAdHlwZSB7YW55fSAqLyAoXy5sYW5ndWFnZXMpO1xuXHRcdFx0XHR2YXIgZ3JhbW1hciA9IHJvb3RbaW5zaWRlXTtcblx0XHRcdFx0LyoqIEB0eXBlIHtHcmFtbWFyfSAqL1xuXHRcdFx0XHR2YXIgcmV0ID0ge307XG5cblx0XHRcdFx0Zm9yICh2YXIgdG9rZW4gaW4gZ3JhbW1hcikge1xuXHRcdFx0XHRcdGlmIChncmFtbWFyLmhhc093blByb3BlcnR5KHRva2VuKSkge1xuXG5cdFx0XHRcdFx0XHRpZiAodG9rZW4gPT0gYmVmb3JlKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIG5ld1Rva2VuIGluIGluc2VydCkge1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpbnNlcnQuaGFzT3duUHJvcGVydHkobmV3VG9rZW4pKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXRbbmV3VG9rZW5dID0gaW5zZXJ0W25ld1Rva2VuXTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gRG8gbm90IGluc2VydCB0b2tlbiB3aGljaCBhbHNvIG9jY3VyIGluIGluc2VydC4gU2VlICMxNTI1XG5cdFx0XHRcdFx0XHRpZiAoIWluc2VydC5oYXNPd25Qcm9wZXJ0eSh0b2tlbikpIHtcblx0XHRcdFx0XHRcdFx0cmV0W3Rva2VuXSA9IGdyYW1tYXJbdG9rZW5dO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBvbGQgPSByb290W2luc2lkZV07XG5cdFx0XHRcdHJvb3RbaW5zaWRlXSA9IHJldDtcblxuXHRcdFx0XHQvLyBVcGRhdGUgcmVmZXJlbmNlcyBpbiBvdGhlciBsYW5ndWFnZSBkZWZpbml0aW9uc1xuXHRcdFx0XHRfLmxhbmd1YWdlcy5ERlMoXy5sYW5ndWFnZXMsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKHZhbHVlID09PSBvbGQgJiYga2V5ICE9IGluc2lkZSkge1xuXHRcdFx0XHRcdFx0dGhpc1trZXldID0gcmV0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRyYXZlcnNlIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiB3aXRoIERlcHRoIEZpcnN0IFNlYXJjaFxuXHRcdFx0REZTOiBmdW5jdGlvbiBERlMobywgY2FsbGJhY2ssIHR5cGUsIHZpc2l0ZWQpIHtcblx0XHRcdFx0dmlzaXRlZCA9IHZpc2l0ZWQgfHwge307XG5cblx0XHRcdFx0dmFyIG9iaklkID0gXy51dGlsLm9iaklkO1xuXG5cdFx0XHRcdGZvciAodmFyIGkgaW4gbykge1xuXHRcdFx0XHRcdGlmIChvLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKG8sIGksIG9baV0sIHR5cGUgfHwgaSk7XG5cblx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0eSA9IG9baV07XG5cdFx0XHRcdFx0XHR2YXIgcHJvcGVydHlUeXBlID0gXy51dGlsLnR5cGUocHJvcGVydHkpO1xuXG5cdFx0XHRcdFx0XHRpZiAocHJvcGVydHlUeXBlID09PSAnT2JqZWN0JyAmJiAhdmlzaXRlZFtvYmpJZChwcm9wZXJ0eSldKSB7XG5cdFx0XHRcdFx0XHRcdHZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdERGUyhwcm9wZXJ0eSwgY2FsbGJhY2ssIG51bGwsIHZpc2l0ZWQpO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmIChwcm9wZXJ0eVR5cGUgPT09ICdBcnJheScgJiYgIXZpc2l0ZWRbb2JqSWQocHJvcGVydHkpXSkge1xuXHRcdFx0XHRcdFx0XHR2aXNpdGVkW29iaklkKHByb3BlcnR5KV0gPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRERlMocHJvcGVydHksIGNhbGxiYWNrLCBpLCB2aXNpdGVkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0cGx1Z2luczoge30sXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGlzIHRoZSBtb3N0IGhpZ2gtbGV2ZWwgZnVuY3Rpb24gaW4gUHJpc23igJlzIEFQSS5cblx0XHQgKiBJdCBmZXRjaGVzIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBoYXZlIGEgYC5sYW5ndWFnZS14eHh4YCBjbGFzcyBhbmQgdGhlbiBjYWxscyB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0RWxlbWVudH0gb25cblx0XHQgKiBlYWNoIG9uZSBvZiB0aGVtLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIGBQcmlzbS5oaWdobGlnaHRBbGxVbmRlcihkb2N1bWVudCwgYXN5bmMsIGNhbGxiYWNrKWAuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFthc3luYz1mYWxzZV0gU2FtZSBhcyBpbiB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0QWxsVW5kZXJ9LlxuXHRcdCAqIEBwYXJhbSB7SGlnaGxpZ2h0Q2FsbGJhY2t9IFtjYWxsYmFja10gU2FtZSBhcyBpbiB7QGxpbmsgUHJpc20uaGlnaGxpZ2h0QWxsVW5kZXJ9LlxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRoaWdobGlnaHRBbGw6IGZ1bmN0aW9uIChhc3luYywgY2FsbGJhY2spIHtcblx0XHRcdF8uaGlnaGxpZ2h0QWxsVW5kZXIoZG9jdW1lbnQsIGFzeW5jLCBjYWxsYmFjayk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEZldGNoZXMgYWxsIHRoZSBkZXNjZW5kYW50cyBvZiBgY29udGFpbmVyYCB0aGF0IGhhdmUgYSBgLmxhbmd1YWdlLXh4eHhgIGNsYXNzIGFuZCB0aGVuIGNhbGxzXG5cdFx0ICoge0BsaW5rIFByaXNtLmhpZ2hsaWdodEVsZW1lbnR9IG9uIGVhY2ggb25lIG9mIHRoZW0uXG5cdFx0ICpcblx0XHQgKiBUaGUgZm9sbG93aW5nIGhvb2tzIHdpbGwgYmUgcnVuOlxuXHRcdCAqIDEuIGBiZWZvcmUtaGlnaGxpZ2h0YWxsYFxuXHRcdCAqIDIuIGBiZWZvcmUtYWxsLWVsZW1lbnRzLWhpZ2hsaWdodGBcblx0XHQgKiAzLiBBbGwgaG9va3Mgb2Yge0BsaW5rIFByaXNtLmhpZ2hsaWdodEVsZW1lbnR9IGZvciBlYWNoIGVsZW1lbnQuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1BhcmVudE5vZGV9IGNvbnRhaW5lciBUaGUgcm9vdCBlbGVtZW50LCB3aG9zZSBkZXNjZW5kYW50cyB0aGF0IGhhdmUgYSBgLmxhbmd1YWdlLXh4eHhgIGNsYXNzIHdpbGwgYmUgaGlnaGxpZ2h0ZWQuXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbYXN5bmM9ZmFsc2VdIFdoZXRoZXIgZWFjaCBlbGVtZW50IGlzIHRvIGJlIGhpZ2hsaWdodGVkIGFzeW5jaHJvbm91c2x5IHVzaW5nIFdlYiBXb3JrZXJzLlxuXHRcdCAqIEBwYXJhbSB7SGlnaGxpZ2h0Q2FsbGJhY2t9IFtjYWxsYmFja10gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbiBlYWNoIGVsZW1lbnQgYWZ0ZXIgaXRzIGhpZ2hsaWdodGluZyBpcyBkb25lLlxuXHRcdCAqIEBtZW1iZXJvZiBQcmlzbVxuXHRcdCAqIEBwdWJsaWNcblx0XHQgKi9cblx0XHRoaWdobGlnaHRBbGxVbmRlcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgYXN5bmMsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgZW52ID0ge1xuXHRcdFx0XHRjYWxsYmFjazogY2FsbGJhY2ssXG5cdFx0XHRcdGNvbnRhaW5lcjogY29udGFpbmVyLFxuXHRcdFx0XHRzZWxlY3RvcjogJ2NvZGVbY2xhc3MqPVwibGFuZ3VhZ2UtXCJdLCBbY2xhc3MqPVwibGFuZ3VhZ2UtXCJdIGNvZGUsIGNvZGVbY2xhc3MqPVwibGFuZy1cIl0sIFtjbGFzcyo9XCJsYW5nLVwiXSBjb2RlJ1xuXHRcdFx0fTtcblxuXHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1oaWdobGlnaHRhbGwnLCBlbnYpO1xuXG5cdFx0XHRlbnYuZWxlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoZW52LmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKGVudi5zZWxlY3RvcikpO1xuXG5cdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLWFsbC1lbGVtZW50cy1oaWdobGlnaHQnLCBlbnYpO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMCwgZWxlbWVudDsgKGVsZW1lbnQgPSBlbnYuZWxlbWVudHNbaSsrXSk7KSB7XG5cdFx0XHRcdF8uaGlnaGxpZ2h0RWxlbWVudChlbGVtZW50LCBhc3luYyA9PT0gdHJ1ZSwgZW52LmNhbGxiYWNrKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGlnaGxpZ2h0cyB0aGUgY29kZSBpbnNpZGUgYSBzaW5nbGUgZWxlbWVudC5cblx0XHQgKlxuXHRcdCAqIFRoZSBmb2xsb3dpbmcgaG9va3Mgd2lsbCBiZSBydW46XG5cdFx0ICogMS4gYGJlZm9yZS1zYW5pdHktY2hlY2tgXG5cdFx0ICogMi4gYGJlZm9yZS1oaWdobGlnaHRgXG5cdFx0ICogMy4gQWxsIGhvb2tzIG9mIHtAbGluayBQcmlzbS5oaWdobGlnaHR9LiBUaGVzZSBob29rcyB3aWxsIGJlIHJ1biBieSBhbiBhc3luY2hyb25vdXMgd29ya2VyIGlmIGBhc3luY2AgaXMgYHRydWVgLlxuXHRcdCAqIDQuIGBiZWZvcmUtaW5zZXJ0YFxuXHRcdCAqIDUuIGBhZnRlci1oaWdobGlnaHRgXG5cdFx0ICogNi4gYGNvbXBsZXRlYFxuXHRcdCAqXG5cdFx0ICogU29tZSB0aGUgYWJvdmUgaG9va3Mgd2lsbCBiZSBza2lwcGVkIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgY29udGFpbiBhbnkgdGV4dCBvciB0aGVyZSBpcyBubyBncmFtbWFyIGxvYWRlZCBmb3Jcblx0XHQgKiB0aGUgZWxlbWVudCdzIGxhbmd1YWdlLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGNvZGUuXG5cdFx0ICogSXQgbXVzdCBoYXZlIGEgY2xhc3Mgb2YgYGxhbmd1YWdlLXh4eHhgIHRvIGJlIHByb2Nlc3NlZCwgd2hlcmUgYHh4eHhgIGlzIGEgdmFsaWQgbGFuZ3VhZ2UgaWRlbnRpZmllci5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFthc3luYz1mYWxzZV0gV2hldGhlciB0aGUgZWxlbWVudCBpcyB0byBiZSBoaWdobGlnaHRlZCBhc3luY2hyb25vdXNseSB1c2luZyBXZWIgV29ya2Vyc1xuXHRcdCAqIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UgYW5kIGF2b2lkIGJsb2NraW5nIHRoZSBVSSB3aGVuIGhpZ2hsaWdodGluZyB2ZXJ5IGxhcmdlIGNodW5rcyBvZiBjb2RlLiBUaGlzIG9wdGlvbiBpc1xuXHRcdCAqIFtkaXNhYmxlZCBieSBkZWZhdWx0XShodHRwczovL3ByaXNtanMuY29tL2ZhcS5odG1sI3doeS1pcy1hc3luY2hyb25vdXMtaGlnaGxpZ2h0aW5nLWRpc2FibGVkLWJ5LWRlZmF1bHQpLlxuXHRcdCAqXG5cdFx0ICogTm90ZTogQWxsIGxhbmd1YWdlIGRlZmluaXRpb25zIHJlcXVpcmVkIHRvIGhpZ2hsaWdodCB0aGUgY29kZSBtdXN0IGJlIGluY2x1ZGVkIGluIHRoZSBtYWluIGBwcmlzbS5qc2AgZmlsZSBmb3Jcblx0XHQgKiBhc3luY2hyb25vdXMgaGlnaGxpZ2h0aW5nIHRvIHdvcmsuIFlvdSBjYW4gYnVpbGQgeW91ciBvd24gYnVuZGxlIG9uIHRoZVxuXHRcdCAqIFtEb3dubG9hZCBwYWdlXShodHRwczovL3ByaXNtanMuY29tL2Rvd25sb2FkLmh0bWwpLlxuXHRcdCAqIEBwYXJhbSB7SGlnaGxpZ2h0Q2FsbGJhY2t9IFtjYWxsYmFja10gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgaGlnaGxpZ2h0aW5nIGlzIGRvbmUuXG5cdFx0ICogTW9zdGx5IHVzZWZ1bCB3aGVuIGBhc3luY2AgaXMgYHRydWVgLCBzaW5jZSBpbiB0aGF0IGNhc2UsIHRoZSBoaWdobGlnaHRpbmcgaXMgZG9uZSBhc3luY2hyb25vdXNseS5cblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0aGlnaGxpZ2h0RWxlbWVudDogZnVuY3Rpb24gKGVsZW1lbnQsIGFzeW5jLCBjYWxsYmFjaykge1xuXHRcdFx0Ly8gRmluZCBsYW5ndWFnZVxuXHRcdFx0dmFyIGxhbmd1YWdlID0gXy51dGlsLmdldExhbmd1YWdlKGVsZW1lbnQpO1xuXHRcdFx0dmFyIGdyYW1tYXIgPSBfLmxhbmd1YWdlc1tsYW5ndWFnZV07XG5cblx0XHRcdC8vIFNldCBsYW5ndWFnZSBvbiB0aGUgZWxlbWVudCwgaWYgbm90IHByZXNlbnRcblx0XHRcdF8udXRpbC5zZXRMYW5ndWFnZShlbGVtZW50LCBsYW5ndWFnZSk7XG5cblx0XHRcdC8vIFNldCBsYW5ndWFnZSBvbiB0aGUgcGFyZW50LCBmb3Igc3R5bGluZ1xuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcblx0XHRcdGlmIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdwcmUnKSB7XG5cdFx0XHRcdF8udXRpbC5zZXRMYW5ndWFnZShwYXJlbnQsIGxhbmd1YWdlKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGNvZGUgPSBlbGVtZW50LnRleHRDb250ZW50O1xuXG5cdFx0XHR2YXIgZW52ID0ge1xuXHRcdFx0XHRlbGVtZW50OiBlbGVtZW50LFxuXHRcdFx0XHRsYW5ndWFnZTogbGFuZ3VhZ2UsXG5cdFx0XHRcdGdyYW1tYXI6IGdyYW1tYXIsXG5cdFx0XHRcdGNvZGU6IGNvZGVcblx0XHRcdH07XG5cblx0XHRcdGZ1bmN0aW9uIGluc2VydEhpZ2hsaWdodGVkQ29kZShoaWdobGlnaHRlZENvZGUpIHtcblx0XHRcdFx0ZW52LmhpZ2hsaWdodGVkQ29kZSA9IGhpZ2hsaWdodGVkQ29kZTtcblxuXHRcdFx0XHRfLmhvb2tzLnJ1bignYmVmb3JlLWluc2VydCcsIGVudik7XG5cblx0XHRcdFx0ZW52LmVsZW1lbnQuaW5uZXJIVE1MID0gZW52LmhpZ2hsaWdodGVkQ29kZTtcblxuXHRcdFx0XHRfLmhvb2tzLnJ1bignYWZ0ZXItaGlnaGxpZ2h0JywgZW52KTtcblx0XHRcdFx0Xy5ob29rcy5ydW4oJ2NvbXBsZXRlJywgZW52KTtcblx0XHRcdFx0Y2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChlbnYuZWxlbWVudCk7XG5cdFx0XHR9XG5cblx0XHRcdF8uaG9va3MucnVuKCdiZWZvcmUtc2FuaXR5LWNoZWNrJywgZW52KTtcblxuXHRcdFx0Ly8gcGx1Z2lucyBtYXkgY2hhbmdlL2FkZCB0aGUgcGFyZW50L2VsZW1lbnRcblx0XHRcdHBhcmVudCA9IGVudi5lbGVtZW50LnBhcmVudEVsZW1lbnQ7XG5cdFx0XHRpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAncHJlJyAmJiAhcGFyZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuXHRcdFx0XHRwYXJlbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICcwJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZW52LmNvZGUpIHtcblx0XHRcdFx0Xy5ob29rcy5ydW4oJ2NvbXBsZXRlJywgZW52KTtcblx0XHRcdFx0Y2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbChlbnYuZWxlbWVudCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS1oaWdobGlnaHQnLCBlbnYpO1xuXG5cdFx0XHRpZiAoIWVudi5ncmFtbWFyKSB7XG5cdFx0XHRcdGluc2VydEhpZ2hsaWdodGVkQ29kZShfLnV0aWwuZW5jb2RlKGVudi5jb2RlKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGFzeW5jICYmIF9zZWxmLldvcmtlcikge1xuXHRcdFx0XHR2YXIgd29ya2VyID0gbmV3IFdvcmtlcihfLmZpbGVuYW1lKTtcblxuXHRcdFx0XHR3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2dCkge1xuXHRcdFx0XHRcdGluc2VydEhpZ2hsaWdodGVkQ29kZShldnQuZGF0YSk7XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0d29ya2VyLnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHtcblx0XHRcdFx0XHRsYW5ndWFnZTogZW52Lmxhbmd1YWdlLFxuXHRcdFx0XHRcdGNvZGU6IGVudi5jb2RlLFxuXHRcdFx0XHRcdGltbWVkaWF0ZUNsb3NlOiB0cnVlXG5cdFx0XHRcdH0pKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluc2VydEhpZ2hsaWdodGVkQ29kZShfLmhpZ2hsaWdodChlbnYuY29kZSwgZW52LmdyYW1tYXIsIGVudi5sYW5ndWFnZSkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBMb3ctbGV2ZWwgZnVuY3Rpb24sIG9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW914oCZcmUgZG9pbmcuIEl0IGFjY2VwdHMgYSBzdHJpbmcgb2YgdGV4dCBhcyBpbnB1dFxuXHRcdCAqIGFuZCB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgdG8gdXNlLCBhbmQgcmV0dXJucyBhIHN0cmluZyB3aXRoIHRoZSBIVE1MIHByb2R1Y2VkLlxuXHRcdCAqXG5cdFx0ICogVGhlIGZvbGxvd2luZyBob29rcyB3aWxsIGJlIHJ1bjpcblx0XHQgKiAxLiBgYmVmb3JlLXRva2VuaXplYFxuXHRcdCAqIDIuIGBhZnRlci10b2tlbml6ZWBcblx0XHQgKiAzLiBgd3JhcGA6IE9uIGVhY2gge0BsaW5rIFRva2VufS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IEEgc3RyaW5nIHdpdGggdGhlIGNvZGUgdG8gYmUgaGlnaGxpZ2h0ZWQuXG5cdFx0ICogQHBhcmFtIHtHcmFtbWFyfSBncmFtbWFyIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0b2tlbnMgdG8gdXNlLlxuXHRcdCAqXG5cdFx0ICogVXN1YWxseSBhIGxhbmd1YWdlIGRlZmluaXRpb24gbGlrZSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIFRoZSBuYW1lIG9mIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9uIHBhc3NlZCB0byBgZ3JhbW1hcmAuXG5cdFx0ICogQHJldHVybnMge3N0cmluZ30gVGhlIGhpZ2hsaWdodGVkIEhUTUwuXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogUHJpc20uaGlnaGxpZ2h0KCd2YXIgZm9vID0gdHJ1ZTsnLCBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCwgJ2phdmFzY3JpcHQnKTtcblx0XHQgKi9cblx0XHRoaWdobGlnaHQ6IGZ1bmN0aW9uICh0ZXh0LCBncmFtbWFyLCBsYW5ndWFnZSkge1xuXHRcdFx0dmFyIGVudiA9IHtcblx0XHRcdFx0Y29kZTogdGV4dCxcblx0XHRcdFx0Z3JhbW1hcjogZ3JhbW1hcixcblx0XHRcdFx0bGFuZ3VhZ2U6IGxhbmd1YWdlXG5cdFx0XHR9O1xuXHRcdFx0Xy5ob29rcy5ydW4oJ2JlZm9yZS10b2tlbml6ZScsIGVudik7XG5cdFx0XHRpZiAoIWVudi5ncmFtbWFyKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVGhlIGxhbmd1YWdlIFwiJyArIGVudi5sYW5ndWFnZSArICdcIiBoYXMgbm8gZ3JhbW1hci4nKTtcblx0XHRcdH1cblx0XHRcdGVudi50b2tlbnMgPSBfLnRva2VuaXplKGVudi5jb2RlLCBlbnYuZ3JhbW1hcik7XG5cdFx0XHRfLmhvb2tzLnJ1bignYWZ0ZXItdG9rZW5pemUnLCBlbnYpO1xuXHRcdFx0cmV0dXJuIFRva2VuLnN0cmluZ2lmeShfLnV0aWwuZW5jb2RlKGVudi50b2tlbnMpLCBlbnYubGFuZ3VhZ2UpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBUaGlzIGlzIHRoZSBoZWFydCBvZiBQcmlzbSwgYW5kIHRoZSBtb3N0IGxvdy1sZXZlbCBmdW5jdGlvbiB5b3UgY2FuIHVzZS4gSXQgYWNjZXB0cyBhIHN0cmluZyBvZiB0ZXh0IGFzIGlucHV0XG5cdFx0ICogYW5kIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9ucyB0byB1c2UsIGFuZCByZXR1cm5zIGFuIGFycmF5IHdpdGggdGhlIHRva2VuaXplZCBjb2RlLlxuXHRcdCAqXG5cdFx0ICogV2hlbiB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBpbmNsdWRlcyBuZXN0ZWQgdG9rZW5zLCB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIHJlY3Vyc2l2ZWx5IG9uIGVhY2ggb2YgdGhlc2UgdG9rZW5zLlxuXHRcdCAqXG5cdFx0ICogVGhpcyBtZXRob2QgY291bGQgYmUgdXNlZnVsIGluIG90aGVyIGNvbnRleHRzIGFzIHdlbGwsIGFzIGEgdmVyeSBjcnVkZSBwYXJzZXIuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBBIHN0cmluZyB3aXRoIHRoZSBjb2RlIHRvIGJlIGhpZ2hsaWdodGVkLlxuXHRcdCAqIEBwYXJhbSB7R3JhbW1hcn0gZ3JhbW1hciBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdG9rZW5zIHRvIHVzZS5cblx0XHQgKlxuXHRcdCAqIFVzdWFsbHkgYSBsYW5ndWFnZSBkZWZpbml0aW9uIGxpa2UgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgLlxuXHRcdCAqIEByZXR1cm5zIHtUb2tlblN0cmVhbX0gQW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgdG9rZW5zLCBhIHRva2VuIHN0cmVhbS5cblx0XHQgKiBAbWVtYmVyb2YgUHJpc21cblx0XHQgKiBAcHVibGljXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiBsZXQgY29kZSA9IGB2YXIgZm9vID0gMDtgO1xuXHRcdCAqIGxldCB0b2tlbnMgPSBQcmlzbS50b2tlbml6ZShjb2RlLCBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCk7XG5cdFx0ICogdG9rZW5zLmZvckVhY2godG9rZW4gPT4ge1xuXHRcdCAqICAgICBpZiAodG9rZW4gaW5zdGFuY2VvZiBQcmlzbS5Ub2tlbiAmJiB0b2tlbi50eXBlID09PSAnbnVtYmVyJykge1xuXHRcdCAqICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIG51bWVyaWMgbGl0ZXJhbDogJHt0b2tlbi5jb250ZW50fWApO1xuXHRcdCAqICAgICB9XG5cdFx0ICogfSk7XG5cdFx0ICovXG5cdFx0dG9rZW5pemU6IGZ1bmN0aW9uICh0ZXh0LCBncmFtbWFyKSB7XG5cdFx0XHR2YXIgcmVzdCA9IGdyYW1tYXIucmVzdDtcblx0XHRcdGlmIChyZXN0KSB7XG5cdFx0XHRcdGZvciAodmFyIHRva2VuIGluIHJlc3QpIHtcblx0XHRcdFx0XHRncmFtbWFyW3Rva2VuXSA9IHJlc3RbdG9rZW5dO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGVsZXRlIGdyYW1tYXIucmVzdDtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHRva2VuTGlzdCA9IG5ldyBMaW5rZWRMaXN0KCk7XG5cdFx0XHRhZGRBZnRlcih0b2tlbkxpc3QsIHRva2VuTGlzdC5oZWFkLCB0ZXh0KTtcblxuXHRcdFx0bWF0Y2hHcmFtbWFyKHRleHQsIHRva2VuTGlzdCwgZ3JhbW1hciwgdG9rZW5MaXN0LmhlYWQsIDApO1xuXG5cdFx0XHRyZXR1cm4gdG9BcnJheSh0b2tlbkxpc3QpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBAbmFtZXNwYWNlXG5cdFx0ICogQG1lbWJlcm9mIFByaXNtXG5cdFx0ICogQHB1YmxpY1xuXHRcdCAqL1xuXHRcdGhvb2tzOiB7XG5cdFx0XHRhbGw6IHt9LFxuXG5cdFx0XHQvKipcblx0XHRcdCAqIEFkZHMgdGhlIGdpdmVuIGNhbGxiYWNrIHRvIHRoZSBsaXN0IG9mIGNhbGxiYWNrcyBmb3IgdGhlIGdpdmVuIGhvb2suXG5cdFx0XHQgKlxuXHRcdFx0ICogVGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSBob29rIGl0IGlzIHJlZ2lzdGVyZWQgZm9yIGlzIHJ1bi5cblx0XHRcdCAqIEhvb2tzIGFyZSB1c3VhbGx5IGRpcmVjdGx5IHJ1biBieSBhIGhpZ2hsaWdodCBmdW5jdGlvbiBidXQgeW91IGNhbiBhbHNvIHJ1biBob29rcyB5b3Vyc2VsZi5cblx0XHRcdCAqXG5cdFx0XHQgKiBPbmUgY2FsbGJhY2sgZnVuY3Rpb24gY2FuIGJlIHJlZ2lzdGVyZWQgdG8gbXVsdGlwbGUgaG9va3MgYW5kIHRoZSBzYW1lIGhvb2sgbXVsdGlwbGUgdGltZXMuXG5cdFx0XHQgKlxuXHRcdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIGhvb2suXG5cdFx0XHQgKiBAcGFyYW0ge0hvb2tDYWxsYmFja30gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGlzIGdpdmVuIGVudmlyb25tZW50IHZhcmlhYmxlcy5cblx0XHRcdCAqIEBwdWJsaWNcblx0XHRcdCAqL1xuXHRcdFx0YWRkOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcblx0XHRcdFx0dmFyIGhvb2tzID0gXy5ob29rcy5hbGw7XG5cblx0XHRcdFx0aG9va3NbbmFtZV0gPSBob29rc1tuYW1lXSB8fCBbXTtcblxuXHRcdFx0XHRob29rc1tuYW1lXS5wdXNoKGNhbGxiYWNrKTtcblx0XHRcdH0sXG5cblx0XHRcdC8qKlxuXHRcdFx0ICogUnVucyBhIGhvb2sgaW52b2tpbmcgYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGVudmlyb25tZW50IHZhcmlhYmxlcy5cblx0XHRcdCAqXG5cdFx0XHQgKiBDYWxsYmFja3Mgd2lsbCBiZSBpbnZva2VkIHN5bmNocm9ub3VzbHkgYW5kIGluIHRoZSBvcmRlciBpbiB3aGljaCB0aGV5IHdlcmUgcmVnaXN0ZXJlZC5cblx0XHRcdCAqXG5cdFx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgaG9vay5cblx0XHRcdCAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZywgYW55Pn0gZW52IFRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgb2YgdGhlIGhvb2sgcGFzc2VkIHRvIGFsbCBjYWxsYmFja3MgcmVnaXN0ZXJlZC5cblx0XHRcdCAqIEBwdWJsaWNcblx0XHRcdCAqL1xuXHRcdFx0cnVuOiBmdW5jdGlvbiAobmFtZSwgZW52KSB7XG5cdFx0XHRcdHZhciBjYWxsYmFja3MgPSBfLmhvb2tzLmFsbFtuYW1lXTtcblxuXHRcdFx0XHRpZiAoIWNhbGxiYWNrcyB8fCAhY2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBjYWxsYmFjazsgKGNhbGxiYWNrID0gY2FsbGJhY2tzW2krK10pOykge1xuXHRcdFx0XHRcdGNhbGxiYWNrKGVudik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0VG9rZW46IFRva2VuXG5cdH07XG5cdF9zZWxmLlByaXNtID0gXztcblxuXG5cdC8vIFR5cGVzY3JpcHQgbm90ZTpcblx0Ly8gVGhlIGZvbGxvd2luZyBjYW4gYmUgdXNlZCB0byBpbXBvcnQgdGhlIFRva2VuIHR5cGUgaW4gSlNEb2M6XG5cdC8vXG5cdC8vICAgQHR5cGVkZWYge0luc3RhbmNlVHlwZTxpbXBvcnQoXCIuL3ByaXNtLWNvcmVcIilbXCJUb2tlblwiXT59IFRva2VuXG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBuZXcgdG9rZW4uXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFNlZSB7QGxpbmsgVG9rZW4jdHlwZSB0eXBlfVxuXHQgKiBAcGFyYW0ge3N0cmluZyB8IFRva2VuU3RyZWFtfSBjb250ZW50IFNlZSB7QGxpbmsgVG9rZW4jY29udGVudCBjb250ZW50fVxuXHQgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW2FsaWFzXSBUaGUgYWxpYXMoZXMpIG9mIHRoZSB0b2tlbi5cblx0ICogQHBhcmFtIHtzdHJpbmd9IFttYXRjaGVkU3RyPVwiXCJdIEEgY29weSBvZiB0aGUgZnVsbCBzdHJpbmcgdGhpcyB0b2tlbiB3YXMgY3JlYXRlZCBmcm9tLlxuXHQgKiBAY2xhc3Ncblx0ICogQGdsb2JhbFxuXHQgKiBAcHVibGljXG5cdCAqL1xuXHRmdW5jdGlvbiBUb2tlbih0eXBlLCBjb250ZW50LCBhbGlhcywgbWF0Y2hlZFN0cikge1xuXHRcdC8qKlxuXHRcdCAqIFRoZSB0eXBlIG9mIHRoZSB0b2tlbi5cblx0XHQgKlxuXHRcdCAqIFRoaXMgaXMgdXN1YWxseSB0aGUga2V5IG9mIGEgcGF0dGVybiBpbiBhIHtAbGluayBHcmFtbWFyfS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQHNlZSBHcmFtbWFyVG9rZW5cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHQvKipcblx0XHQgKiBUaGUgc3RyaW5ncyBvciB0b2tlbnMgY29udGFpbmVkIGJ5IHRoaXMgdG9rZW4uXG5cdFx0ICpcblx0XHQgKiBUaGlzIHdpbGwgYmUgYSB0b2tlbiBzdHJlYW0gaWYgdGhlIHBhdHRlcm4gbWF0Y2hlZCBhbHNvIGRlZmluZWQgYW4gYGluc2lkZWAgZ3JhbW1hci5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmcgfCBUb2tlblN0cmVhbX1cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0dGhpcy5jb250ZW50ID0gY29udGVudDtcblx0XHQvKipcblx0XHQgKiBUaGUgYWxpYXMoZXMpIG9mIHRoZSB0b2tlbi5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtzdHJpbmd8c3RyaW5nW119XG5cdFx0ICogQHNlZSBHcmFtbWFyVG9rZW5cblx0XHQgKiBAcHVibGljXG5cdFx0ICovXG5cdFx0dGhpcy5hbGlhcyA9IGFsaWFzO1xuXHRcdC8vIENvcHkgb2YgdGhlIGZ1bGwgc3RyaW5nIHRoaXMgdG9rZW4gd2FzIGNyZWF0ZWQgZnJvbVxuXHRcdHRoaXMubGVuZ3RoID0gKG1hdGNoZWRTdHIgfHwgJycpLmxlbmd0aCB8IDA7XG5cdH1cblxuXHQvKipcblx0ICogQSB0b2tlbiBzdHJlYW0gaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQge0BsaW5rIFRva2VuIFRva2VufSBvYmplY3RzLlxuXHQgKlxuXHQgKiBUb2tlbiBzdHJlYW1zIGhhdmUgdG8gZnVsZmlsbCBhIGZldyBwcm9wZXJ0aWVzIHRoYXQgYXJlIGFzc3VtZWQgYnkgbW9zdCBmdW5jdGlvbnMgKG1vc3RseSBpbnRlcm5hbCBvbmVzKSB0aGF0IHByb2Nlc3Ncblx0ICogdGhlbS5cblx0ICpcblx0ICogMS4gTm8gYWRqYWNlbnQgc3RyaW5ncy5cblx0ICogMi4gTm8gZW1wdHkgc3RyaW5ncy5cblx0ICpcblx0ICogICAgVGhlIG9ubHkgZXhjZXB0aW9uIGhlcmUgaXMgdGhlIHRva2VuIHN0cmVhbSB0aGF0IG9ubHkgY29udGFpbnMgdGhlIGVtcHR5IHN0cmluZyBhbmQgbm90aGluZyBlbHNlLlxuXHQgKlxuXHQgKiBAdHlwZWRlZiB7QXJyYXk8c3RyaW5nIHwgVG9rZW4+fSBUb2tlblN0cmVhbVxuXHQgKiBAZ2xvYmFsXG5cdCAqIEBwdWJsaWNcblx0ICovXG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBnaXZlbiB0b2tlbiBvciB0b2tlbiBzdHJlYW0gdG8gYW4gSFRNTCByZXByZXNlbnRhdGlvbi5cblx0ICpcblx0ICogVGhlIGZvbGxvd2luZyBob29rcyB3aWxsIGJlIHJ1bjpcblx0ICogMS4gYHdyYXBgOiBPbiBlYWNoIHtAbGluayBUb2tlbn0uXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nIHwgVG9rZW4gfCBUb2tlblN0cmVhbX0gbyBUaGUgdG9rZW4gb3IgdG9rZW4gc3RyZWFtIHRvIGJlIGNvbnZlcnRlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlIFRoZSBuYW1lIG9mIGN1cnJlbnQgbGFuZ3VhZ2UuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBIVE1MIHJlcHJlc2VudGF0aW9uIG9mIHRoZSB0b2tlbiBvciB0b2tlbiBzdHJlYW0uXG5cdCAqIEBtZW1iZXJvZiBUb2tlblxuXHQgKiBAc3RhdGljXG5cdCAqL1xuXHRUb2tlbi5zdHJpbmdpZnkgPSBmdW5jdGlvbiBzdHJpbmdpZnkobywgbGFuZ3VhZ2UpIHtcblx0XHRpZiAodHlwZW9mIG8gPT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBvO1xuXHRcdH1cblx0XHRpZiAoQXJyYXkuaXNBcnJheShvKSkge1xuXHRcdFx0dmFyIHMgPSAnJztcblx0XHRcdG8uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuXHRcdFx0XHRzICs9IHN0cmluZ2lmeShlLCBsYW5ndWFnZSk7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBzO1xuXHRcdH1cblxuXHRcdHZhciBlbnYgPSB7XG5cdFx0XHR0eXBlOiBvLnR5cGUsXG5cdFx0XHRjb250ZW50OiBzdHJpbmdpZnkoby5jb250ZW50LCBsYW5ndWFnZSksXG5cdFx0XHR0YWc6ICdzcGFuJyxcblx0XHRcdGNsYXNzZXM6IFsndG9rZW4nLCBvLnR5cGVdLFxuXHRcdFx0YXR0cmlidXRlczoge30sXG5cdFx0XHRsYW5ndWFnZTogbGFuZ3VhZ2Vcblx0XHR9O1xuXG5cdFx0dmFyIGFsaWFzZXMgPSBvLmFsaWFzO1xuXHRcdGlmIChhbGlhc2VzKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhbGlhc2VzKSkge1xuXHRcdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShlbnYuY2xhc3NlcywgYWxpYXNlcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbnYuY2xhc3Nlcy5wdXNoKGFsaWFzZXMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdF8uaG9va3MucnVuKCd3cmFwJywgZW52KTtcblxuXHRcdHZhciBhdHRyaWJ1dGVzID0gJyc7XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBlbnYuYXR0cmlidXRlcykge1xuXHRcdFx0YXR0cmlidXRlcyArPSAnICcgKyBuYW1lICsgJz1cIicgKyAoZW52LmF0dHJpYnV0ZXNbbmFtZV0gfHwgJycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKSArICdcIic7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICc8JyArIGVudi50YWcgKyAnIGNsYXNzPVwiJyArIGVudi5jbGFzc2VzLmpvaW4oJyAnKSArICdcIicgKyBhdHRyaWJ1dGVzICsgJz4nICsgZW52LmNvbnRlbnQgKyAnPC8nICsgZW52LnRhZyArICc+Jztcblx0fTtcblxuXHQvKipcblx0ICogQHBhcmFtIHtSZWdFeHB9IHBhdHRlcm5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGxvb2tiZWhpbmRcblx0ICogQHJldHVybnMge1JlZ0V4cEV4ZWNBcnJheSB8IG51bGx9XG5cdCAqL1xuXHRmdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcG9zLCB0ZXh0LCBsb29rYmVoaW5kKSB7XG5cdFx0cGF0dGVybi5sYXN0SW5kZXggPSBwb3M7XG5cdFx0dmFyIG1hdGNoID0gcGF0dGVybi5leGVjKHRleHQpO1xuXHRcdGlmIChtYXRjaCAmJiBsb29rYmVoaW5kICYmIG1hdGNoWzFdKSB7XG5cdFx0XHQvLyBjaGFuZ2UgdGhlIG1hdGNoIHRvIHJlbW92ZSB0aGUgdGV4dCBtYXRjaGVkIGJ5IHRoZSBQcmlzbSBsb29rYmVoaW5kIGdyb3VwXG5cdFx0XHR2YXIgbG9va2JlaGluZExlbmd0aCA9IG1hdGNoWzFdLmxlbmd0aDtcblx0XHRcdG1hdGNoLmluZGV4ICs9IGxvb2tiZWhpbmRMZW5ndGg7XG5cdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKGxvb2tiZWhpbmRMZW5ndGgpO1xuXHRcdH1cblx0XHRyZXR1cm4gbWF0Y2g7XG5cdH1cblxuXHQvKipcblx0ICogQHBhcmFtIHtzdHJpbmd9IHRleHRcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0PHN0cmluZyB8IFRva2VuPn0gdG9rZW5MaXN0XG5cdCAqIEBwYXJhbSB7YW55fSBncmFtbWFyXG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdE5vZGU8c3RyaW5nIHwgVG9rZW4+fSBzdGFydE5vZGVcblx0ICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0UG9zXG5cdCAqIEBwYXJhbSB7UmVtYXRjaE9wdGlvbnN9IFtyZW1hdGNoXVxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICogQHByaXZhdGVcblx0ICpcblx0ICogQHR5cGVkZWYgUmVtYXRjaE9wdGlvbnNcblx0ICogQHByb3BlcnR5IHtzdHJpbmd9IGNhdXNlXG5cdCAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZWFjaFxuXHQgKi9cblx0ZnVuY3Rpb24gbWF0Y2hHcmFtbWFyKHRleHQsIHRva2VuTGlzdCwgZ3JhbW1hciwgc3RhcnROb2RlLCBzdGFydFBvcywgcmVtYXRjaCkge1xuXHRcdGZvciAodmFyIHRva2VuIGluIGdyYW1tYXIpIHtcblx0XHRcdGlmICghZ3JhbW1hci5oYXNPd25Qcm9wZXJ0eSh0b2tlbikgfHwgIWdyYW1tYXJbdG9rZW5dKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcGF0dGVybnMgPSBncmFtbWFyW3Rva2VuXTtcblx0XHRcdHBhdHRlcm5zID0gQXJyYXkuaXNBcnJheShwYXR0ZXJucykgPyBwYXR0ZXJucyA6IFtwYXR0ZXJuc107XG5cblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgcGF0dGVybnMubGVuZ3RoOyArK2opIHtcblx0XHRcdFx0aWYgKHJlbWF0Y2ggJiYgcmVtYXRjaC5jYXVzZSA9PSB0b2tlbiArICcsJyArIGopIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcGF0dGVybk9iaiA9IHBhdHRlcm5zW2pdO1xuXHRcdFx0XHR2YXIgaW5zaWRlID0gcGF0dGVybk9iai5pbnNpZGU7XG5cdFx0XHRcdHZhciBsb29rYmVoaW5kID0gISFwYXR0ZXJuT2JqLmxvb2tiZWhpbmQ7XG5cdFx0XHRcdHZhciBncmVlZHkgPSAhIXBhdHRlcm5PYmouZ3JlZWR5O1xuXHRcdFx0XHR2YXIgYWxpYXMgPSBwYXR0ZXJuT2JqLmFsaWFzO1xuXG5cdFx0XHRcdGlmIChncmVlZHkgJiYgIXBhdHRlcm5PYmoucGF0dGVybi5nbG9iYWwpIHtcblx0XHRcdFx0XHQvLyBXaXRob3V0IHRoZSBnbG9iYWwgZmxhZywgbGFzdEluZGV4IHdvbid0IHdvcmtcblx0XHRcdFx0XHR2YXIgZmxhZ3MgPSBwYXR0ZXJuT2JqLnBhdHRlcm4udG9TdHJpbmcoKS5tYXRjaCgvW2ltc3V5XSokLylbMF07XG5cdFx0XHRcdFx0cGF0dGVybk9iai5wYXR0ZXJuID0gUmVnRXhwKHBhdHRlcm5PYmoucGF0dGVybi5zb3VyY2UsIGZsYWdzICsgJ2cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qKiBAdHlwZSB7UmVnRXhwfSAqL1xuXHRcdFx0XHR2YXIgcGF0dGVybiA9IHBhdHRlcm5PYmoucGF0dGVybiB8fCBwYXR0ZXJuT2JqO1xuXG5cdFx0XHRcdGZvciAoIC8vIGl0ZXJhdGUgdGhlIHRva2VuIGxpc3QgYW5kIGtlZXAgdHJhY2sgb2YgdGhlIGN1cnJlbnQgdG9rZW4vc3RyaW5nIHBvc2l0aW9uXG5cdFx0XHRcdFx0dmFyIGN1cnJlbnROb2RlID0gc3RhcnROb2RlLm5leHQsIHBvcyA9IHN0YXJ0UG9zO1xuXHRcdFx0XHRcdGN1cnJlbnROb2RlICE9PSB0b2tlbkxpc3QudGFpbDtcblx0XHRcdFx0XHRwb3MgKz0gY3VycmVudE5vZGUudmFsdWUubGVuZ3RoLCBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLm5leHRcblx0XHRcdFx0KSB7XG5cblx0XHRcdFx0XHRpZiAocmVtYXRjaCAmJiBwb3MgPj0gcmVtYXRjaC5yZWFjaCkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHN0ciA9IGN1cnJlbnROb2RlLnZhbHVlO1xuXG5cdFx0XHRcdFx0aWYgKHRva2VuTGlzdC5sZW5ndGggPiB0ZXh0Lmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Ly8gU29tZXRoaW5nIHdlbnQgdGVycmlibHkgd3JvbmcsIEFCT1JULCBBQk9SVCFcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoc3RyIGluc3RhbmNlb2YgVG9rZW4pIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciByZW1vdmVDb3VudCA9IDE7IC8vIHRoaXMgaXMgdGhlIHRvIHBhcmFtZXRlciBvZiByZW1vdmVCZXR3ZWVuXG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXG5cdFx0XHRcdFx0aWYgKGdyZWVkeSkge1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcG9zLCB0ZXh0LCBsb29rYmVoaW5kKTtcblx0XHRcdFx0XHRcdGlmICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggPj0gdGV4dC5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHZhciBmcm9tID0gbWF0Y2guaW5kZXg7XG5cdFx0XHRcdFx0XHR2YXIgdG8gPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcblx0XHRcdFx0XHRcdHZhciBwID0gcG9zO1xuXG5cdFx0XHRcdFx0XHQvLyBmaW5kIHRoZSBub2RlIHRoYXQgY29udGFpbnMgdGhlIG1hdGNoXG5cdFx0XHRcdFx0XHRwICs9IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlIChmcm9tID49IHApIHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5uZXh0O1xuXHRcdFx0XHRcdFx0XHRwICs9IGN1cnJlbnROb2RlLnZhbHVlLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGFkanVzdCBwb3MgKGFuZCBwKVxuXHRcdFx0XHRcdFx0cCAtPSBjdXJyZW50Tm9kZS52YWx1ZS5sZW5ndGg7XG5cdFx0XHRcdFx0XHRwb3MgPSBwO1xuXG5cdFx0XHRcdFx0XHQvLyB0aGUgY3VycmVudCBub2RlIGlzIGEgVG9rZW4sIHRoZW4gdGhlIG1hdGNoIHN0YXJ0cyBpbnNpZGUgYW5vdGhlciBUb2tlbiwgd2hpY2ggaXMgaW52YWxpZFxuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnROb2RlLnZhbHVlIGluc3RhbmNlb2YgVG9rZW4pIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIGZpbmQgdGhlIGxhc3Qgbm9kZSB3aGljaCBpcyBhZmZlY3RlZCBieSB0aGlzIG1hdGNoXG5cdFx0XHRcdFx0XHRmb3IgKFxuXHRcdFx0XHRcdFx0XHR2YXIgayA9IGN1cnJlbnROb2RlO1xuXHRcdFx0XHRcdFx0XHRrICE9PSB0b2tlbkxpc3QudGFpbCAmJiAocCA8IHRvIHx8IHR5cGVvZiBrLnZhbHVlID09PSAnc3RyaW5nJyk7XG5cdFx0XHRcdFx0XHRcdGsgPSBrLm5leHRcblx0XHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVDb3VudCsrO1xuXHRcdFx0XHRcdFx0XHRwICs9IGsudmFsdWUubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVtb3ZlQ291bnQtLTtcblxuXHRcdFx0XHRcdFx0Ly8gcmVwbGFjZSB3aXRoIHRoZSBuZXcgbWF0Y2hcblx0XHRcdFx0XHRcdHN0ciA9IHRleHQuc2xpY2UocG9zLCBwKTtcblx0XHRcdFx0XHRcdG1hdGNoLmluZGV4IC09IHBvcztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWF0Y2ggPSBtYXRjaFBhdHRlcm4ocGF0dGVybiwgMCwgc3RyLCBsb29rYmVoaW5kKTtcblx0XHRcdFx0XHRcdGlmICghbWF0Y2gpIHtcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXHRcdFx0XHRcdHZhciBmcm9tID0gbWF0Y2guaW5kZXg7XG5cdFx0XHRcdFx0dmFyIG1hdGNoU3RyID0gbWF0Y2hbMF07XG5cdFx0XHRcdFx0dmFyIGJlZm9yZSA9IHN0ci5zbGljZSgwLCBmcm9tKTtcblx0XHRcdFx0XHR2YXIgYWZ0ZXIgPSBzdHIuc2xpY2UoZnJvbSArIG1hdGNoU3RyLmxlbmd0aCk7XG5cblx0XHRcdFx0XHR2YXIgcmVhY2ggPSBwb3MgKyBzdHIubGVuZ3RoO1xuXHRcdFx0XHRcdGlmIChyZW1hdGNoICYmIHJlYWNoID4gcmVtYXRjaC5yZWFjaCkge1xuXHRcdFx0XHRcdFx0cmVtYXRjaC5yZWFjaCA9IHJlYWNoO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciByZW1vdmVGcm9tID0gY3VycmVudE5vZGUucHJldjtcblxuXHRcdFx0XHRcdGlmIChiZWZvcmUpIHtcblx0XHRcdFx0XHRcdHJlbW92ZUZyb20gPSBhZGRBZnRlcih0b2tlbkxpc3QsIHJlbW92ZUZyb20sIGJlZm9yZSk7XG5cdFx0XHRcdFx0XHRwb3MgKz0gYmVmb3JlLmxlbmd0aDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZW1vdmVSYW5nZSh0b2tlbkxpc3QsIHJlbW92ZUZyb20sIHJlbW92ZUNvdW50KTtcblxuXHRcdFx0XHRcdHZhciB3cmFwcGVkID0gbmV3IFRva2VuKHRva2VuLCBpbnNpZGUgPyBfLnRva2VuaXplKG1hdGNoU3RyLCBpbnNpZGUpIDogbWF0Y2hTdHIsIGFsaWFzLCBtYXRjaFN0cik7XG5cdFx0XHRcdFx0Y3VycmVudE5vZGUgPSBhZGRBZnRlcih0b2tlbkxpc3QsIHJlbW92ZUZyb20sIHdyYXBwZWQpO1xuXG5cdFx0XHRcdFx0aWYgKGFmdGVyKSB7XG5cdFx0XHRcdFx0XHRhZGRBZnRlcih0b2tlbkxpc3QsIGN1cnJlbnROb2RlLCBhZnRlcik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKHJlbW92ZUNvdW50ID4gMSkge1xuXHRcdFx0XHRcdFx0Ly8gYXQgbGVhc3Qgb25lIFRva2VuIG9iamVjdCB3YXMgcmVtb3ZlZCwgc28gd2UgaGF2ZSB0byBkbyBzb21lIHJlbWF0Y2hpbmdcblx0XHRcdFx0XHRcdC8vIHRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHRoZSBjdXJyZW50IHBhdHRlcm4gaXMgZ3JlZWR5XG5cblx0XHRcdFx0XHRcdC8qKiBAdHlwZSB7UmVtYXRjaE9wdGlvbnN9ICovXG5cdFx0XHRcdFx0XHR2YXIgbmVzdGVkUmVtYXRjaCA9IHtcblx0XHRcdFx0XHRcdFx0Y2F1c2U6IHRva2VuICsgJywnICsgaixcblx0XHRcdFx0XHRcdFx0cmVhY2g6IHJlYWNoXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0bWF0Y2hHcmFtbWFyKHRleHQsIHRva2VuTGlzdCwgZ3JhbW1hciwgY3VycmVudE5vZGUucHJldiwgcG9zLCBuZXN0ZWRSZW1hdGNoKTtcblxuXHRcdFx0XHRcdFx0Ly8gdGhlIHJlYWNoIG1pZ2h0IGhhdmUgYmVlbiBleHRlbmRlZCBiZWNhdXNlIG9mIHRoZSByZW1hdGNoaW5nXG5cdFx0XHRcdFx0XHRpZiAocmVtYXRjaCAmJiBuZXN0ZWRSZW1hdGNoLnJlYWNoID4gcmVtYXRjaC5yZWFjaCkge1xuXHRcdFx0XHRcdFx0XHRyZW1hdGNoLnJlYWNoID0gbmVzdGVkUmVtYXRjaC5yZWFjaDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogQHR5cGVkZWYgTGlua2VkTGlzdE5vZGVcblx0ICogQHByb3BlcnR5IHtUfSB2YWx1ZVxuXHQgKiBAcHJvcGVydHkge0xpbmtlZExpc3ROb2RlPFQ+IHwgbnVsbH0gcHJldiBUaGUgcHJldmlvdXMgbm9kZS5cblx0ICogQHByb3BlcnR5IHtMaW5rZWRMaXN0Tm9kZTxUPiB8IG51bGx9IG5leHQgVGhlIG5leHQgbm9kZS5cblx0ICogQHRlbXBsYXRlIFRcblx0ICogQHByaXZhdGVcblx0ICovXG5cblx0LyoqXG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBMaW5rZWRMaXN0KCkge1xuXHRcdC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG5cdFx0dmFyIGhlYWQgPSB7IHZhbHVlOiBudWxsLCBwcmV2OiBudWxsLCBuZXh0OiBudWxsIH07XG5cdFx0LyoqIEB0eXBlIHtMaW5rZWRMaXN0Tm9kZTxUPn0gKi9cblx0XHR2YXIgdGFpbCA9IHsgdmFsdWU6IG51bGwsIHByZXY6IGhlYWQsIG5leHQ6IG51bGwgfTtcblx0XHRoZWFkLm5leHQgPSB0YWlsO1xuXG5cdFx0LyoqIEB0eXBlIHtMaW5rZWRMaXN0Tm9kZTxUPn0gKi9cblx0XHR0aGlzLmhlYWQgPSBoZWFkO1xuXHRcdC8qKiBAdHlwZSB7TGlua2VkTGlzdE5vZGU8VD59ICovXG5cdFx0dGhpcy50YWlsID0gdGFpbDtcblx0XHR0aGlzLmxlbmd0aCA9IDA7XG5cdH1cblxuXHQvKipcblx0ICogQWRkcyBhIG5ldyBub2RlIHdpdGggdGhlIGdpdmVuIHZhbHVlIHRvIHRoZSBsaXN0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3Q8VD59IGxpc3Rcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0Tm9kZTxUPn0gbm9kZVxuXHQgKiBAcGFyYW0ge1R9IHZhbHVlXG5cdCAqIEByZXR1cm5zIHtMaW5rZWRMaXN0Tm9kZTxUPn0gVGhlIGFkZGVkIG5vZGUuXG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGRBZnRlcihsaXN0LCBub2RlLCB2YWx1ZSkge1xuXHRcdC8vIGFzc3VtZXMgdGhhdCBub2RlICE9IGxpc3QudGFpbCAmJiB2YWx1ZXMubGVuZ3RoID49IDBcblx0XHR2YXIgbmV4dCA9IG5vZGUubmV4dDtcblxuXHRcdHZhciBuZXdOb2RlID0geyB2YWx1ZTogdmFsdWUsIHByZXY6IG5vZGUsIG5leHQ6IG5leHQgfTtcblx0XHRub2RlLm5leHQgPSBuZXdOb2RlO1xuXHRcdG5leHQucHJldiA9IG5ld05vZGU7XG5cdFx0bGlzdC5sZW5ndGgrKztcblxuXHRcdHJldHVybiBuZXdOb2RlO1xuXHR9XG5cdC8qKlxuXHQgKiBSZW1vdmVzIGBjb3VudGAgbm9kZXMgYWZ0ZXIgdGhlIGdpdmVuIG5vZGUuIFRoZSBnaXZlbiBub2RlIHdpbGwgbm90IGJlIHJlbW92ZWQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7TGlua2VkTGlzdDxUPn0gbGlzdFxuXHQgKiBAcGFyYW0ge0xpbmtlZExpc3ROb2RlPFQ+fSBub2RlXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuXHQgKiBAdGVtcGxhdGUgVFxuXHQgKi9cblx0ZnVuY3Rpb24gcmVtb3ZlUmFuZ2UobGlzdCwgbm9kZSwgY291bnQpIHtcblx0XHR2YXIgbmV4dCA9IG5vZGUubmV4dDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50ICYmIG5leHQgIT09IGxpc3QudGFpbDsgaSsrKSB7XG5cdFx0XHRuZXh0ID0gbmV4dC5uZXh0O1xuXHRcdH1cblx0XHRub2RlLm5leHQgPSBuZXh0O1xuXHRcdG5leHQucHJldiA9IG5vZGU7XG5cdFx0bGlzdC5sZW5ndGggLT0gaTtcblx0fVxuXHQvKipcblx0ICogQHBhcmFtIHtMaW5rZWRMaXN0PFQ+fSBsaXN0XG5cdCAqIEByZXR1cm5zIHtUW119XG5cdCAqIEB0ZW1wbGF0ZSBUXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FycmF5KGxpc3QpIHtcblx0XHR2YXIgYXJyYXkgPSBbXTtcblx0XHR2YXIgbm9kZSA9IGxpc3QuaGVhZC5uZXh0O1xuXHRcdHdoaWxlIChub2RlICE9PSBsaXN0LnRhaWwpIHtcblx0XHRcdGFycmF5LnB1c2gobm9kZS52YWx1ZSk7XG5cdFx0XHRub2RlID0gbm9kZS5uZXh0O1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyYXk7XG5cdH1cblxuXG5cdGlmICghX3NlbGYuZG9jdW1lbnQpIHtcblx0XHRpZiAoIV9zZWxmLmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdC8vIGluIE5vZGUuanNcblx0XHRcdHJldHVybiBfO1xuXHRcdH1cblxuXHRcdGlmICghXy5kaXNhYmxlV29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcblx0XHRcdC8vIEluIHdvcmtlclxuXHRcdFx0X3NlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldnQpIHtcblx0XHRcdFx0dmFyIG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2dC5kYXRhKTtcblx0XHRcdFx0dmFyIGxhbmcgPSBtZXNzYWdlLmxhbmd1YWdlO1xuXHRcdFx0XHR2YXIgY29kZSA9IG1lc3NhZ2UuY29kZTtcblx0XHRcdFx0dmFyIGltbWVkaWF0ZUNsb3NlID0gbWVzc2FnZS5pbW1lZGlhdGVDbG9zZTtcblxuXHRcdFx0XHRfc2VsZi5wb3N0TWVzc2FnZShfLmhpZ2hsaWdodChjb2RlLCBfLmxhbmd1YWdlc1tsYW5nXSwgbGFuZykpO1xuXHRcdFx0XHRpZiAoaW1tZWRpYXRlQ2xvc2UpIHtcblx0XHRcdFx0XHRfc2VsZi5jbG9zZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBmYWxzZSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIF87XG5cdH1cblxuXHQvLyBHZXQgY3VycmVudCBzY3JpcHQgYW5kIGhpZ2hsaWdodFxuXHR2YXIgc2NyaXB0ID0gXy51dGlsLmN1cnJlbnRTY3JpcHQoKTtcblxuXHRpZiAoc2NyaXB0KSB7XG5cdFx0Xy5maWxlbmFtZSA9IHNjcmlwdC5zcmM7XG5cblx0XHRpZiAoc2NyaXB0Lmhhc0F0dHJpYnV0ZSgnZGF0YS1tYW51YWwnKSkge1xuXHRcdFx0Xy5tYW51YWwgPSB0cnVlO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGhpZ2hsaWdodEF1dG9tYXRpY2FsbHlDYWxsYmFjaygpIHtcblx0XHRpZiAoIV8ubWFudWFsKSB7XG5cdFx0XHRfLmhpZ2hsaWdodEFsbCgpO1xuXHRcdH1cblx0fVxuXG5cdGlmICghXy5tYW51YWwpIHtcblx0XHQvLyBJZiB0aGUgZG9jdW1lbnQgc3RhdGUgaXMgXCJsb2FkaW5nXCIsIHRoZW4gd2UnbGwgdXNlIERPTUNvbnRlbnRMb2FkZWQuXG5cdFx0Ly8gSWYgdGhlIGRvY3VtZW50IHN0YXRlIGlzIFwiaW50ZXJhY3RpdmVcIiBhbmQgdGhlIHByaXNtLmpzIHNjcmlwdCBpcyBkZWZlcnJlZCwgdGhlbiB3ZSdsbCBhbHNvIHVzZSB0aGVcblx0XHQvLyBET01Db250ZW50TG9hZGVkIGV2ZW50IGJlY2F1c2UgdGhlcmUgbWlnaHQgYmUgc29tZSBwbHVnaW5zIG9yIGxhbmd1YWdlcyB3aGljaCBoYXZlIGFsc28gYmVlbiBkZWZlcnJlZCBhbmQgdGhleVxuXHRcdC8vIG1pZ2h0IHRha2UgbG9uZ2VyIG9uZSBhbmltYXRpb24gZnJhbWUgdG8gZXhlY3V0ZSB3aGljaCBjYW4gY3JlYXRlIGEgcmFjZSBjb25kaXRpb24gd2hlcmUgb25seSBzb21lIHBsdWdpbnMgaGF2ZVxuXHRcdC8vIGJlZW4gbG9hZGVkIHdoZW4gUHJpc20uaGlnaGxpZ2h0QWxsKCkgaXMgZXhlY3V0ZWQsIGRlcGVuZGluZyBvbiBob3cgZmFzdCByZXNvdXJjZXMgYXJlIGxvYWRlZC5cblx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1ByaXNtSlMvcHJpc20vaXNzdWVzLzIxMDJcblx0XHR2YXIgcmVhZHlTdGF0ZSA9IGRvY3VtZW50LnJlYWR5U3RhdGU7XG5cdFx0aWYgKHJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJyB8fCByZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnICYmIHNjcmlwdCAmJiBzY3JpcHQuZGVmZXIpIHtcblx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBoaWdobGlnaHRBdXRvbWF0aWNhbGx5Q2FsbGJhY2spO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHRcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGhpZ2hsaWdodEF1dG9tYXRpY2FsbHlDYWxsYmFjayk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dChoaWdobGlnaHRBdXRvbWF0aWNhbGx5Q2FsbGJhY2ssIDE2KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gXztcblxufShfc2VsZikpO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBQcmlzbTtcbn1cblxuLy8gaGFjayBmb3IgY29tcG9uZW50cyB0byB3b3JrIGNvcnJlY3RseSBpbiBub2RlLmpzXG5pZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0Z2xvYmFsLlByaXNtID0gUHJpc207XG59XG5cbi8vIHNvbWUgYWRkaXRpb25hbCBkb2N1bWVudGF0aW9uL3R5cGVzXG5cbi8qKlxuICogVGhlIGV4cGFuc2lvbiBvZiBhIHNpbXBsZSBgUmVnRXhwYCBsaXRlcmFsIHRvIHN1cHBvcnQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzLlxuICpcbiAqIEB0eXBlZGVmIEdyYW1tYXJUb2tlblxuICogQHByb3BlcnR5IHtSZWdFeHB9IHBhdHRlcm4gVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBvZiB0aGUgdG9rZW4uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtsb29rYmVoaW5kPWZhbHNlXSBJZiBgdHJ1ZWAsIHRoZW4gdGhlIGZpcnN0IGNhcHR1cmluZyBncm91cCBvZiBgcGF0dGVybmAgd2lsbCAoZWZmZWN0aXZlbHkpXG4gKiBiZWhhdmUgYXMgYSBsb29rYmVoaW5kIGdyb3VwIG1lYW5pbmcgdGhhdCB0aGUgY2FwdHVyZWQgdGV4dCB3aWxsIG5vdCBiZSBwYXJ0IG9mIHRoZSBtYXRjaGVkIHRleHQgb2YgdGhlIG5ldyB0b2tlbi5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2dyZWVkeT1mYWxzZV0gV2hldGhlciB0aGUgdG9rZW4gaXMgZ3JlZWR5LlxuICogQHByb3BlcnR5IHtzdHJpbmd8c3RyaW5nW119IFthbGlhc10gQW4gb3B0aW9uYWwgYWxpYXMgb3IgbGlzdCBvZiBhbGlhc2VzLlxuICogQHByb3BlcnR5IHtHcmFtbWFyfSBbaW5zaWRlXSBUaGUgbmVzdGVkIGdyYW1tYXIgb2YgdGhpcyB0b2tlbi5cbiAqXG4gKiBUaGUgYGluc2lkZWAgZ3JhbW1hciB3aWxsIGJlIHVzZWQgdG8gdG9rZW5pemUgdGhlIHRleHQgdmFsdWUgb2YgZWFjaCB0b2tlbiBvZiB0aGlzIGtpbmQuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBtYWtlIG5lc3RlZCBhbmQgZXZlbiByZWN1cnNpdmUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMuXG4gKlxuICogTm90ZTogVGhpcyBjYW4gY2F1c2UgaW5maW5pdGUgcmVjdXJzaW9uLiBCZSBjYXJlZnVsIHdoZW4geW91IGVtYmVkIGRpZmZlcmVudCBsYW5ndWFnZXMgb3IgZXZlbiB0aGUgc2FtZSBsYW5ndWFnZSBpbnRvXG4gKiBlYWNoIGFub3RoZXIuXG4gKiBAZ2xvYmFsXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiBHcmFtbWFyXG4gKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgUmVnRXhwIHwgR3JhbW1hclRva2VuIHwgQXJyYXk8UmVnRXhwIHwgR3JhbW1hclRva2VuPj59XG4gKiBAcHJvcGVydHkge0dyYW1tYXJ9IFtyZXN0XSBBbiBvcHRpb25hbCBncmFtbWFyIG9iamVjdCB0aGF0IHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhpcyBncmFtbWFyLlxuICogQGdsb2JhbFxuICogQHB1YmxpY1xuICovXG5cbi8qKlxuICogQSBmdW5jdGlvbiB3aGljaCB3aWxsIGludm9rZWQgYWZ0ZXIgYW4gZWxlbWVudCB3YXMgc3VjY2Vzc2Z1bGx5IGhpZ2hsaWdodGVkLlxuICpcbiAqIEBjYWxsYmFjayBIaWdobGlnaHRDYWxsYmFja1xuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IHN1Y2Nlc3NmdWxseSBoaWdobGlnaHRlZC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGdsb2JhbFxuICogQHB1YmxpY1xuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIEhvb2tDYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBlbnYgVGhlIGVudmlyb25tZW50IHZhcmlhYmxlcyBvZiB0aGUgaG9vay5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGdsb2JhbFxuICogQHB1YmxpY1xuICovXG5cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1tYXJrdXAuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cCA9IHtcblx0J2NvbW1lbnQnOiB7XG5cdFx0cGF0dGVybjogLzwhLS0oPzooPyE8IS0tKVtcXHNcXFNdKSo/LS0+Lyxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J3Byb2xvZyc6IHtcblx0XHRwYXR0ZXJuOiAvPFxcP1tcXHNcXFNdKz9cXD8+Lyxcblx0XHRncmVlZHk6IHRydWVcblx0fSxcblx0J2RvY3R5cGUnOiB7XG5cdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3htbC8jTlQtZG9jdHlwZWRlY2xcblx0XHRwYXR0ZXJuOiAvPCFET0NUWVBFKD86W14+XCInW1xcXV18XCJbXlwiXSpcInwnW14nXSonKSsoPzpcXFsoPzpbXjxcIidcXF1dfFwiW15cIl0qXCJ8J1teJ10qJ3w8KD8hIS0tKXw8IS0tKD86W14tXXwtKD8hLT4pKSotLT4pKlxcXVxccyopPz4vaSxcblx0XHRncmVlZHk6IHRydWUsXG5cdFx0aW5zaWRlOiB7XG5cdFx0XHQnaW50ZXJuYWwtc3Vic2V0Jzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvKF5bXlxcW10qXFxbKVtcXHNcXFNdKyg/PVxcXT4kKS8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdFx0aW5zaWRlOiBudWxsIC8vIHNlZSBiZWxvd1xuXHRcdFx0fSxcblx0XHRcdCdzdHJpbmcnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9cIlteXCJdKlwifCdbXiddKicvLFxuXHRcdFx0XHRncmVlZHk6IHRydWVcblx0XHRcdH0sXG5cdFx0XHQncHVuY3R1YXRpb24nOiAvXjwhfD4kfFtbXFxdXS8sXG5cdFx0XHQnZG9jdHlwZS10YWcnOiAvXkRPQ1RZUEUvaSxcblx0XHRcdCduYW1lJzogL1teXFxzPD4nXCJdKy9cblx0XHR9XG5cdH0sXG5cdCdjZGF0YSc6IHtcblx0XHRwYXR0ZXJuOiAvPCFcXFtDREFUQVxcW1tcXHNcXFNdKj9cXF1cXF0+L2ksXG5cdFx0Z3JlZWR5OiB0cnVlXG5cdH0sXG5cdCd0YWcnOiB7XG5cdFx0cGF0dGVybjogLzxcXC8/KD8hXFxkKVteXFxzPlxcLz0kPCVdKyg/Olxccyg/OlxccypbXlxccz5cXC89XSsoPzpcXHMqPVxccyooPzpcIlteXCJdKlwifCdbXiddKid8W15cXHMnXCI+PV0rKD89W1xccz5dKSl8KD89W1xccy8+XSkpKSspP1xccypcXC8/Pi8sXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J3RhZyc6IHtcblx0XHRcdFx0cGF0dGVybjogL148XFwvP1teXFxzPlxcL10rLyxcblx0XHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdFx0J3B1bmN0dWF0aW9uJzogL148XFwvPy8sXG5cdFx0XHRcdFx0J25hbWVzcGFjZSc6IC9eW15cXHM+XFwvOl0rOi9cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCdzcGVjaWFsLWF0dHInOiBbXSxcblx0XHRcdCdhdHRyLXZhbHVlJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvPVxccyooPzpcIlteXCJdKlwifCdbXiddKid8W15cXHMnXCI+PV0rKS8sXG5cdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdCdwdW5jdHVhdGlvbic6IFtcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0cGF0dGVybjogL149Lyxcblx0XHRcdFx0XHRcdFx0YWxpYXM6ICdhdHRyLWVxdWFscydcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdHBhdHRlcm46IC9eKFxccyopW1wiJ118W1wiJ10kLyxcblx0XHRcdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdF1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdCdwdW5jdHVhdGlvbic6IC9cXC8/Pi8sXG5cdFx0XHQnYXR0ci1uYW1lJzoge1xuXHRcdFx0XHRwYXR0ZXJuOiAvW15cXHM+XFwvXSsvLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQnbmFtZXNwYWNlJzogL15bXlxccz5cXC86XSs6L1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHR9XG5cdH0sXG5cdCdlbnRpdHknOiBbXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyZbXFxkYS16XXsxLDh9Oy9pLFxuXHRcdFx0YWxpYXM6ICduYW1lZC1lbnRpdHknXG5cdFx0fSxcblx0XHQvJiN4P1tcXGRhLWZdezEsOH07L2lcblx0XVxufTtcblxuUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cFsndGFnJ10uaW5zaWRlWydhdHRyLXZhbHVlJ10uaW5zaWRlWydlbnRpdHknXSA9XG5cdFByaXNtLmxhbmd1YWdlcy5tYXJrdXBbJ2VudGl0eSddO1xuUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cFsnZG9jdHlwZSddLmluc2lkZVsnaW50ZXJuYWwtc3Vic2V0J10uaW5zaWRlID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblxuLy8gUGx1Z2luIHRvIG1ha2UgZW50aXR5IHRpdGxlIHNob3cgdGhlIHJlYWwgZW50aXR5LCBpZGVhIGJ5IFJvbWFuIEtvbWFyb3ZcblByaXNtLmhvb2tzLmFkZCgnd3JhcCcsIGZ1bmN0aW9uIChlbnYpIHtcblxuXHRpZiAoZW52LnR5cGUgPT09ICdlbnRpdHknKSB7XG5cdFx0ZW52LmF0dHJpYnV0ZXNbJ3RpdGxlJ10gPSBlbnYuY29udGVudC5yZXBsYWNlKC8mYW1wOy8sICcmJyk7XG5cdH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcsICdhZGRJbmxpbmVkJywge1xuXHQvKipcblx0ICogQWRkcyBhbiBpbmxpbmVkIGxhbmd1YWdlIHRvIG1hcmt1cC5cblx0ICpcblx0ICogQW4gZXhhbXBsZSBvZiBhbiBpbmxpbmVkIGxhbmd1YWdlIGlzIENTUyB3aXRoIGA8c3R5bGU+YCB0YWdzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdGFnTmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFnIHRoYXQgY29udGFpbnMgdGhlIGlubGluZWQgbGFuZ3VhZ2UuIFRoaXMgbmFtZSB3aWxsIGJlIHRyZWF0ZWQgYXNcblx0ICogY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmcgVGhlIGxhbmd1YWdlIGtleS5cblx0ICogQGV4YW1wbGVcblx0ICogYWRkSW5saW5lZCgnc3R5bGUnLCAnY3NzJyk7XG5cdCAqL1xuXHR2YWx1ZTogZnVuY3Rpb24gYWRkSW5saW5lZCh0YWdOYW1lLCBsYW5nKSB7XG5cdFx0dmFyIGluY2x1ZGVkQ2RhdGFJbnNpZGUgPSB7fTtcblx0XHRpbmNsdWRlZENkYXRhSW5zaWRlWydsYW5ndWFnZS0nICsgbGFuZ10gPSB7XG5cdFx0XHRwYXR0ZXJuOiAvKF48IVxcW0NEQVRBXFxbKVtcXHNcXFNdKz8oPz1cXF1cXF0+JCkvaSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlc1tsYW5nXVxuXHRcdH07XG5cdFx0aW5jbHVkZWRDZGF0YUluc2lkZVsnY2RhdGEnXSA9IC9ePCFcXFtDREFUQVxcW3xcXF1cXF0+JC9pO1xuXG5cdFx0dmFyIGluc2lkZSA9IHtcblx0XHRcdCdpbmNsdWRlZC1jZGF0YSc6IHtcblx0XHRcdFx0cGF0dGVybjogLzwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdPi9pLFxuXHRcdFx0XHRpbnNpZGU6IGluY2x1ZGVkQ2RhdGFJbnNpZGVcblx0XHRcdH1cblx0XHR9O1xuXHRcdGluc2lkZVsnbGFuZ3VhZ2UtJyArIGxhbmddID0ge1xuXHRcdFx0cGF0dGVybjogL1tcXHNcXFNdKy8sXG5cdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlc1tsYW5nXVxuXHRcdH07XG5cblx0XHR2YXIgZGVmID0ge307XG5cdFx0ZGVmW3RhZ05hbWVdID0ge1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKC8oPF9fW14+XSo+KSg/OjwhXFxbQ0RBVEFcXFsoPzpbXlxcXV18XFxdKD8hXFxdPikpKlxcXVxcXT58KD8hPCFcXFtDREFUQVxcWylbXFxzXFxTXSkqPyg/PTxcXC9fXz4pLy5zb3VyY2UucmVwbGFjZSgvX18vZywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGFnTmFtZTsgfSksICdpJyksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBpbnNpZGVcblx0XHR9O1xuXG5cdFx0UHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NkYXRhJywgZGVmKTtcblx0fVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcsICdhZGRBdHRyaWJ1dGUnLCB7XG5cdC8qKlxuXHQgKiBBZGRzIGFuIHBhdHRlcm4gdG8gaGlnaGxpZ2h0IGxhbmd1YWdlcyBlbWJlZGRlZCBpbiBIVE1MIGF0dHJpYnV0ZXMuXG5cdCAqXG5cdCAqIEFuIGV4YW1wbGUgb2YgYW4gaW5saW5lZCBsYW5ndWFnZSBpcyBDU1Mgd2l0aCBgc3R5bGVgIGF0dHJpYnV0ZXMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyTmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFnIHRoYXQgY29udGFpbnMgdGhlIGlubGluZWQgbGFuZ3VhZ2UuIFRoaXMgbmFtZSB3aWxsIGJlIHRyZWF0ZWQgYXNcblx0ICogY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGxhbmcgVGhlIGxhbmd1YWdlIGtleS5cblx0ICogQGV4YW1wbGVcblx0ICogYWRkQXR0cmlidXRlKCdzdHlsZScsICdjc3MnKTtcblx0ICovXG5cdHZhbHVlOiBmdW5jdGlvbiAoYXR0ck5hbWUsIGxhbmcpIHtcblx0XHRQcmlzbS5sYW5ndWFnZXMubWFya3VwLnRhZy5pbnNpZGVbJ3NwZWNpYWwtYXR0ciddLnB1c2goe1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKFxuXHRcdFx0XHQvKF58W1wiJ1xcc10pLy5zb3VyY2UgKyAnKD86JyArIGF0dHJOYW1lICsgJyknICsgL1xccyo9XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSsoPz1bXFxzPl0pKS8uc291cmNlLFxuXHRcdFx0XHQnaSdcblx0XHRcdCksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdhdHRyLW5hbWUnOiAvXlteXFxzPV0rLyxcblx0XHRcdFx0J2F0dHItdmFsdWUnOiB7XG5cdFx0XHRcdFx0cGF0dGVybjogLz1bXFxzXFxTXSsvLFxuXHRcdFx0XHRcdGluc2lkZToge1xuXHRcdFx0XHRcdFx0J3ZhbHVlJzoge1xuXHRcdFx0XHRcdFx0XHRwYXR0ZXJuOiAvKF49XFxzKihbXCInXXwoPyFbXCInXSkpKVxcU1tcXHNcXFNdKig/PVxcMiQpLyxcblx0XHRcdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0YWxpYXM6IFtsYW5nLCAnbGFuZ3VhZ2UtJyArIGxhbmddLFxuXHRcdFx0XHRcdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlc1tsYW5nXVxuXHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdCdwdW5jdHVhdGlvbic6IFtcblx0XHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRcdHBhdHRlcm46IC9ePS8sXG5cdFx0XHRcdFx0XHRcdFx0YWxpYXM6ICdhdHRyLWVxdWFscydcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0L1wifCcvXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuaHRtbCA9IFByaXNtLmxhbmd1YWdlcy5tYXJrdXA7XG5QcmlzbS5sYW5ndWFnZXMubWF0aG1sID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblByaXNtLmxhbmd1YWdlcy5zdmcgPSBQcmlzbS5sYW5ndWFnZXMubWFya3VwO1xuXG5QcmlzbS5sYW5ndWFnZXMueG1sID0gUHJpc20ubGFuZ3VhZ2VzLmV4dGVuZCgnbWFya3VwJywge30pO1xuUHJpc20ubGFuZ3VhZ2VzLnNzbWwgPSBQcmlzbS5sYW5ndWFnZXMueG1sO1xuUHJpc20ubGFuZ3VhZ2VzLmF0b20gPSBQcmlzbS5sYW5ndWFnZXMueG1sO1xuUHJpc20ubGFuZ3VhZ2VzLnJzcyA9IFByaXNtLmxhbmd1YWdlcy54bWw7XG5cblxuLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICBCZWdpbiBwcmlzbS1jc3MuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuKGZ1bmN0aW9uIChQcmlzbSkge1xuXG5cdHZhciBzdHJpbmcgPSAvKD86XCIoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXlwiXFxcXFxcclxcbl0pKlwifCcoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXxbXidcXFxcXFxyXFxuXSkqJykvO1xuXG5cdFByaXNtLmxhbmd1YWdlcy5jc3MgPSB7XG5cdFx0J2NvbW1lbnQnOiAvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy8sXG5cdFx0J2F0cnVsZSc6IHtcblx0XHRcdHBhdHRlcm46IFJlZ0V4cCgnQFtcXFxcdy1dKD86JyArIC9bXjt7XFxzXCInXXxcXHMrKD8hXFxzKS8uc291cmNlICsgJ3wnICsgc3RyaW5nLnNvdXJjZSArICcpKj8nICsgLyg/Ojt8KD89XFxzKlxceykpLy5zb3VyY2UpLFxuXHRcdFx0aW5zaWRlOiB7XG5cdFx0XHRcdCdydWxlJzogL15AW1xcdy1dKy8sXG5cdFx0XHRcdCdzZWxlY3Rvci1mdW5jdGlvbi1hcmd1bWVudCc6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvKFxcYnNlbGVjdG9yXFxzKlxcKFxccyooPyFbXFxzKV0pKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKCg/OlteKCldfFxcKFteKCldKlxcKSkqXFwpKSsoPz1cXHMqXFwpKS8sXG5cdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdFx0XHRhbGlhczogJ3NlbGVjdG9yJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHQna2V5d29yZCc6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiAvKF58W15cXHctXSkoPzphbmR8bm90fG9ubHl8b3IpKD8hW1xcdy1dKS8sXG5cdFx0XHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFNlZSByZXN0IGJlbG93XG5cdFx0XHR9XG5cdFx0fSxcblx0XHQndXJsJzoge1xuXHRcdFx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy12YWx1ZXMtMy8jdXJsc1xuXHRcdFx0cGF0dGVybjogUmVnRXhwKCdcXFxcYnVybFxcXFwoKD86JyArIHN0cmluZy5zb3VyY2UgKyAnfCcgKyAvKD86W15cXFxcXFxyXFxuKClcIiddfFxcXFxbXFxzXFxTXSkqLy5zb3VyY2UgKyAnKVxcXFwpJywgJ2knKSxcblx0XHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRcdGluc2lkZToge1xuXHRcdFx0XHQnZnVuY3Rpb24nOiAvXnVybC9pLFxuXHRcdFx0XHQncHVuY3R1YXRpb24nOiAvXlxcKHxcXCkkLyxcblx0XHRcdFx0J3N0cmluZyc6IHtcblx0XHRcdFx0XHRwYXR0ZXJuOiBSZWdFeHAoJ14nICsgc3RyaW5nLnNvdXJjZSArICckJyksXG5cdFx0XHRcdFx0YWxpYXM6ICd1cmwnXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXHRcdCdzZWxlY3Rvcic6IHtcblx0XHRcdHBhdHRlcm46IFJlZ0V4cCgnKF58W3t9XFxcXHNdKVtee31cXFxcc10oPzpbXnt9O1wiXFwnXFxcXHNdfFxcXFxzKyg/IVtcXFxcc3tdKXwnICsgc3RyaW5nLnNvdXJjZSArICcpKig/PVxcXFxzKlxcXFx7KScpLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0J3N0cmluZyc6IHtcblx0XHRcdHBhdHRlcm46IHN0cmluZyxcblx0XHRcdGdyZWVkeTogdHJ1ZVxuXHRcdH0sXG5cdFx0J3Byb3BlcnR5Jzoge1xuXHRcdFx0cGF0dGVybjogLyhefFteLVxcd1xceEEwLVxcdUZGRkZdKSg/IVxccylbLV9hLXpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbLVxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqOikvaSxcblx0XHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0XHR9LFxuXHRcdCdpbXBvcnRhbnQnOiAvIWltcG9ydGFudFxcYi9pLFxuXHRcdCdmdW5jdGlvbic6IHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXi1hLXowLTldKVstYS16MC05XSsoPz1cXCgpL2ksXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fSxcblx0XHQncHVuY3R1YXRpb24nOiAvWygpe307OixdL1xuXHR9O1xuXG5cdFByaXNtLmxhbmd1YWdlcy5jc3NbJ2F0cnVsZSddLmluc2lkZS5yZXN0ID0gUHJpc20ubGFuZ3VhZ2VzLmNzcztcblxuXHR2YXIgbWFya3VwID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcblx0aWYgKG1hcmt1cCkge1xuXHRcdG1hcmt1cC50YWcuYWRkSW5saW5lZCgnc3R5bGUnLCAnY3NzJyk7XG5cdFx0bWFya3VwLnRhZy5hZGRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2NzcycpO1xuXHR9XG5cbn0oUHJpc20pKTtcblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWNsaWtlLmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cblByaXNtLmxhbmd1YWdlcy5jbGlrZSA9IHtcblx0J2NvbW1lbnQnOiBbXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhefFteXFxcXF0pXFwvXFwqW1xcc1xcU10qPyg/OlxcKlxcL3wkKS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0Z3JlZWR5OiB0cnVlXG5cdFx0fSxcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKF58W15cXFxcOl0pXFwvXFwvLiovLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGdyZWVkeTogdHJ1ZVxuXHRcdH1cblx0XSxcblx0J3N0cmluZyc6IHtcblx0XHRwYXR0ZXJuOiAvKFtcIiddKSg/OlxcXFwoPzpcXHJcXG58W1xcc1xcU10pfCg/IVxcMSlbXlxcXFxcXHJcXG5dKSpcXDEvLFxuXHRcdGdyZWVkeTogdHJ1ZVxuXHR9LFxuXHQnY2xhc3MtbmFtZSc6IHtcblx0XHRwYXR0ZXJuOiAvKFxcYig/OmNsYXNzfGV4dGVuZHN8aW1wbGVtZW50c3xpbnN0YW5jZW9mfGludGVyZmFjZXxuZXd8dHJhaXQpXFxzK3xcXGJjYXRjaFxccytcXCgpW1xcdy5cXFxcXSsvaSxcblx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdGluc2lkZToge1xuXHRcdFx0J3B1bmN0dWF0aW9uJzogL1suXFxcXF0vXG5cdFx0fVxuXHR9LFxuXHQna2V5d29yZCc6IC9cXGIoPzpicmVha3xjYXRjaHxjb250aW51ZXxkb3xlbHNlfGZpbmFsbHl8Zm9yfGZ1bmN0aW9ufGlmfGlufGluc3RhbmNlb2Z8bmV3fG51bGx8cmV0dXJufHRocm93fHRyeXx3aGlsZSlcXGIvLFxuXHQnYm9vbGVhbic6IC9cXGIoPzpmYWxzZXx0cnVlKVxcYi8sXG5cdCdmdW5jdGlvbic6IC9cXGJcXHcrKD89XFwoKS8sXG5cdCdudW1iZXInOiAvXFxiMHhbXFxkYS1mXStcXGJ8KD86XFxiXFxkKyg/OlxcLlxcZCopP3xcXEJcXC5cXGQrKSg/OmVbKy1dP1xcZCspPy9pLFxuXHQnb3BlcmF0b3InOiAvWzw+XT0/fFshPV09Pz0/fC0tP3xcXCtcXCs/fCYmP3xcXHxcXHw/fFs/Ki9+XiVdLyxcblx0J3B1bmN0dWF0aW9uJzogL1t7fVtcXF07KCksLjpdL1xufTtcblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWphdmFzY3JpcHQuanNcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxuUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQgPSBQcmlzbS5sYW5ndWFnZXMuZXh0ZW5kKCdjbGlrZScsIHtcblx0J2NsYXNzLW5hbWUnOiBbXG5cdFx0UHJpc20ubGFuZ3VhZ2VzLmNsaWtlWydjbGFzcy1uYW1lJ10sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhefFteJFxcd1xceEEwLVxcdUZGRkZdKSg/IVxccylbXyRBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXC4oPzpjb25zdHJ1Y3Rvcnxwcm90b3R5cGUpKS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlXG5cdFx0fVxuXHRdLFxuXHQna2V5d29yZCc6IFtcblx0XHR7XG5cdFx0XHRwYXR0ZXJuOiAvKCg/Ol58XFx9KVxccyopY2F0Y2hcXGIvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLyhefFteLl18XFwuXFwuXFwuXFxzKilcXGIoPzphc3xhc3NlcnQoPz1cXHMqXFx7KXxhc3luYyg/PVxccyooPzpmdW5jdGlvblxcYnxcXCh8WyRcXHdcXHhBMC1cXHVGRkZGXXwkKSl8YXdhaXR8YnJlYWt8Y2FzZXxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmluYWxseSg/PVxccyooPzpcXHt8JCkpfGZvcnxmcm9tKD89XFxzKig/OlsnXCJdfCQpKXxmdW5jdGlvbnwoPzpnZXR8c2V0KSg/PVxccyooPzpbI1xcWyRcXHdcXHhBMC1cXHVGRkZGXXwkKSl8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzdGF0aWN8c3VwZXJ8c3dpdGNofHRoaXN8dGhyb3d8dHJ5fHR5cGVvZnx1bmRlZmluZWR8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZClcXGIvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZVxuXHRcdH0sXG5cdF0sXG5cdC8vIEFsbG93IGZvciBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMgKFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMDA4NDQ0KVxuXHQnZnVuY3Rpb24nOiAvIz8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKig/OlxcLlxccyooPzphcHBseXxiaW5kfGNhbGwpXFxzKik/XFwoKS8sXG5cdCdudW1iZXInOiB7XG5cdFx0cGF0dGVybjogUmVnRXhwKFxuXHRcdFx0LyhefFteXFx3JF0pLy5zb3VyY2UgK1xuXHRcdFx0Jyg/OicgK1xuXHRcdFx0KFxuXHRcdFx0XHQvLyBjb25zdGFudFxuXHRcdFx0XHQvTmFOfEluZmluaXR5Ly5zb3VyY2UgK1xuXHRcdFx0XHQnfCcgK1xuXHRcdFx0XHQvLyBiaW5hcnkgaW50ZWdlclxuXHRcdFx0XHQvMFtiQl1bMDFdKyg/Ol9bMDFdKykqbj8vLnNvdXJjZSArXG5cdFx0XHRcdCd8JyArXG5cdFx0XHRcdC8vIG9jdGFsIGludGVnZXJcblx0XHRcdFx0LzBbb09dWzAtN10rKD86X1swLTddKykqbj8vLnNvdXJjZSArXG5cdFx0XHRcdCd8JyArXG5cdFx0XHRcdC8vIGhleGFkZWNpbWFsIGludGVnZXJcblx0XHRcdFx0LzBbeFhdW1xcZEEtRmEtZl0rKD86X1tcXGRBLUZhLWZdKykqbj8vLnNvdXJjZSArXG5cdFx0XHRcdCd8JyArXG5cdFx0XHRcdC8vIGRlY2ltYWwgYmlnaW50XG5cdFx0XHRcdC9cXGQrKD86X1xcZCspKm4vLnNvdXJjZSArXG5cdFx0XHRcdCd8JyArXG5cdFx0XHRcdC8vIGRlY2ltYWwgbnVtYmVyIChpbnRlZ2VyIG9yIGZsb2F0KSBidXQgbm8gYmlnaW50XG5cdFx0XHRcdC8oPzpcXGQrKD86X1xcZCspKig/OlxcLig/OlxcZCsoPzpfXFxkKykqKT8pP3xcXC5cXGQrKD86X1xcZCspKikoPzpbRWVdWystXT9cXGQrKD86X1xcZCspKik/Ly5zb3VyY2Vcblx0XHRcdCkgK1xuXHRcdFx0JyknICtcblx0XHRcdC8oPyFbXFx3JF0pLy5zb3VyY2Vcblx0XHQpLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWVcblx0fSxcblx0J29wZXJhdG9yJzogLy0tfFxcK1xcK3xcXCpcXCo9P3w9PnwmJj0/fFxcfFxcfD0/fFshPV09PXw8PD0/fD4+Pj89P3xbLSsqLyUmfF4hPTw+XT0/fFxcLnszfXxcXD9cXD89P3xcXD9cXC4/fFt+Ol0vXG59KTtcblxuUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRbJ2NsYXNzLW5hbWUnXVswXS5wYXR0ZXJuID0gLyhcXGIoPzpjbGFzc3xleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxpbnRlcmZhY2V8bmV3KVxccyspW1xcdy5cXFxcXSsvO1xuXG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ2tleXdvcmQnLCB7XG5cdCdyZWdleCc6IHtcblx0XHRwYXR0ZXJuOiBSZWdFeHAoXG5cdFx0XHQvLyBsb29rYmVoaW5kXG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLWR1cGUtY2hhcmFjdGVycy1jaGFyYWN0ZXItY2xhc3Ncblx0XHRcdC8oKD86XnxbXiRcXHdcXHhBMC1cXHVGRkZGLlwiJ1xcXSlcXHNdfFxcYig/OnJldHVybnx5aWVsZCkpXFxzKikvLnNvdXJjZSArXG5cdFx0XHQvLyBSZWdleCBwYXR0ZXJuOlxuXHRcdFx0Ly8gVGhlcmUgYXJlIDIgcmVnZXggcGF0dGVybnMgaGVyZS4gVGhlIFJlZ0V4cCBzZXQgbm90YXRpb24gcHJvcG9zYWwgYWRkZWQgc3VwcG9ydCBmb3IgbmVzdGVkIGNoYXJhY3RlclxuXHRcdFx0Ly8gY2xhc3NlcyBpZiB0aGUgYHZgIGZsYWcgaXMgcHJlc2VudC4gVW5mb3J0dW5hdGVseSwgbmVzdGVkIENDcyBhcmUgYm90aCBjb250ZXh0LWZyZWUgYW5kIGluY29tcGF0aWJsZVxuXHRcdFx0Ly8gd2l0aCB0aGUgb25seSBzeW50YXgsIHNvIHdlIGhhdmUgdG8gZGVmaW5lIDIgZGlmZmVyZW50IHJlZ2V4IHBhdHRlcm5zLlxuXHRcdFx0L1xcLy8uc291cmNlICtcblx0XHRcdCcoPzonICtcblx0XHRcdC8oPzpcXFsoPzpbXlxcXVxcXFxcXHJcXG5dfFxcXFwuKSpcXF18XFxcXC58W14vXFxcXFxcW1xcclxcbl0pK1xcL1tkZ2lteXVzXXswLDd9Ly5zb3VyY2UgK1xuXHRcdFx0J3wnICtcblx0XHRcdC8vIGB2YCBmbGFnIHN5bnRheC4gVGhpcyBzdXBwb3J0cyAzIGxldmVscyBvZiBuZXN0ZWQgY2hhcmFjdGVyIGNsYXNzZXMuXG5cdFx0XHQvKD86XFxbKD86W15bXFxdXFxcXFxcclxcbl18XFxcXC58XFxbKD86W15bXFxdXFxcXFxcclxcbl18XFxcXC58XFxbKD86W15bXFxdXFxcXFxcclxcbl18XFxcXC4pKlxcXSkqXFxdKSpcXF18XFxcXC58W14vXFxcXFxcW1xcclxcbl0pK1xcL1tkZ2lteXVzXXswLDd9dltkZ2lteXVzXXswLDd9Ly5zb3VyY2UgK1xuXHRcdFx0JyknICtcblx0XHRcdC8vIGxvb2thaGVhZFxuXHRcdFx0Lyg/PSg/Olxcc3xcXC9cXCooPzpbXipdfFxcKig/IVxcLykpKlxcKlxcLykqKD86JHxbXFxyXFxuLC47On0pXFxdXXxcXC9cXC8pKS8uc291cmNlXG5cdFx0KSxcblx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCdyZWdleC1zb3VyY2UnOiB7XG5cdFx0XHRcdHBhdHRlcm46IC9eKFxcLylbXFxzXFxTXSsoPz1cXC9bYS16XSokKS8sXG5cdFx0XHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0XHRcdGFsaWFzOiAnbGFuZ3VhZ2UtcmVnZXgnLFxuXHRcdFx0XHRpbnNpZGU6IFByaXNtLmxhbmd1YWdlcy5yZWdleFxuXHRcdFx0fSxcblx0XHRcdCdyZWdleC1kZWxpbWl0ZXInOiAvXlxcL3xcXC8kLyxcblx0XHRcdCdyZWdleC1mbGFncyc6IC9eW2Etel0rJC8sXG5cdFx0fVxuXHR9LFxuXHQvLyBUaGlzIG11c3QgYmUgZGVjbGFyZWQgYmVmb3JlIGtleXdvcmQgYmVjYXVzZSB3ZSB1c2UgXCJmdW5jdGlvblwiIGluc2lkZSB0aGUgbG9vay1mb3J3YXJkXG5cdCdmdW5jdGlvbi12YXJpYWJsZSc6IHtcblx0XHRwYXR0ZXJuOiAvIz8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKls9Ol1cXHMqKD86YXN5bmNcXHMqKT8oPzpcXGJmdW5jdGlvblxcYnwoPzpcXCgoPzpbXigpXXxcXChbXigpXSpcXCkpKlxcKXwoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKVxccyo9PikpLyxcblx0XHRhbGlhczogJ2Z1bmN0aW9uJ1xuXHR9LFxuXHQncGFyYW1ldGVyJzogW1xuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oZnVuY3Rpb24oPzpcXHMrKD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKik/XFxzKlxcKFxccyopKD8hXFxzKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKFteKCldKlxcKSkrKD89XFxzKlxcKSkvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcblx0XHR9LFxuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oXnxbXiRcXHdcXHhBMC1cXHVGRkZGXSkoPyFcXHMpW18kYS16XFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKj0+KS9pLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcblx0XHR9LFxuXHRcdHtcblx0XHRcdHBhdHRlcm46IC8oXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpXFxzKj0+KS8sXG5cdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0aW5zaWRlOiBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdFxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0cGF0dGVybjogLygoPzpcXGJ8XFxzfF4pKD8hKD86YXN8YXN5bmN8YXdhaXR8YnJlYWt8Y2FzZXxjYXRjaHxjbGFzc3xjb25zdHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGVudW18ZXhwb3J0fGV4dGVuZHN8ZmluYWxseXxmb3J8ZnJvbXxmdW5jdGlvbnxnZXR8aWZ8aW1wbGVtZW50c3xpbXBvcnR8aW58aW5zdGFuY2VvZnxpbnRlcmZhY2V8bGV0fG5ld3xudWxsfG9mfHBhY2thZ2V8cHJpdmF0ZXxwcm90ZWN0ZWR8cHVibGljfHJldHVybnxzZXR8c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlb2Z8dW5kZWZpbmVkfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpKD8hWyRcXHdcXHhBMC1cXHVGRkZGXSkpKD86KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKlxccyopXFwoXFxzKnxcXF1cXHMqXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpXFxzKlxceykvLFxuXHRcdFx0bG9va2JlaGluZDogdHJ1ZSxcblx0XHRcdGluc2lkZTogUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcblx0XHR9XG5cdF0sXG5cdCdjb25zdGFudCc6IC9cXGJbQS1aXSg/OltBLVpfXXxcXGR4PykqXFxiL1xufSk7XG5cblByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ2phdmFzY3JpcHQnLCAnc3RyaW5nJywge1xuXHQnaGFzaGJhbmcnOiB7XG5cdFx0cGF0dGVybjogL14jIS4qLyxcblx0XHRncmVlZHk6IHRydWUsXG5cdFx0YWxpYXM6ICdjb21tZW50J1xuXHR9LFxuXHQndGVtcGxhdGUtc3RyaW5nJzoge1xuXHRcdHBhdHRlcm46IC9gKD86XFxcXFtcXHNcXFNdfFxcJFxceyg/Oltee31dfFxceyg/Oltee31dfFxce1tefV0qXFx9KSpcXH0pK1xcfXwoPyFcXCRcXHspW15cXFxcYF0pKmAvLFxuXHRcdGdyZWVkeTogdHJ1ZSxcblx0XHRpbnNpZGU6IHtcblx0XHRcdCd0ZW1wbGF0ZS1wdW5jdHVhdGlvbic6IHtcblx0XHRcdFx0cGF0dGVybjogL15gfGAkLyxcblx0XHRcdFx0YWxpYXM6ICdzdHJpbmcnXG5cdFx0XHR9LFxuXHRcdFx0J2ludGVycG9sYXRpb24nOiB7XG5cdFx0XHRcdHBhdHRlcm46IC8oKD86XnxbXlxcXFxdKSg/OlxcXFx7Mn0pKilcXCRcXHsoPzpbXnt9XXxcXHsoPzpbXnt9XXxcXHtbXn1dKlxcfSkqXFx9KStcXH0vLFxuXHRcdFx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdFx0XHRpbnNpZGU6IHtcblx0XHRcdFx0XHQnaW50ZXJwb2xhdGlvbi1wdW5jdHVhdGlvbic6IHtcblx0XHRcdFx0XHRcdHBhdHRlcm46IC9eXFwkXFx7fFxcfSQvLFxuXHRcdFx0XHRcdFx0YWxpYXM6ICdwdW5jdHVhdGlvbidcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHJlc3Q6IFByaXNtLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHQnc3RyaW5nJzogL1tcXHNcXFNdKy9cblx0XHR9XG5cdH0sXG5cdCdzdHJpbmctcHJvcGVydHknOiB7XG5cdFx0cGF0dGVybjogLygoPzpefFsse10pWyBcXHRdKikoW1wiJ10pKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8KD8hXFwyKVteXFxcXFxcclxcbl0pKlxcMig/PVxccyo6KS9tLFxuXHRcdGxvb2tiZWhpbmQ6IHRydWUsXG5cdFx0Z3JlZWR5OiB0cnVlLFxuXHRcdGFsaWFzOiAncHJvcGVydHknXG5cdH1cbn0pO1xuXG5QcmlzbS5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKCdqYXZhc2NyaXB0JywgJ29wZXJhdG9yJywge1xuXHQnbGl0ZXJhbC1wcm9wZXJ0eSc6IHtcblx0XHRwYXR0ZXJuOiAvKCg/Ol58Wyx7XSlbIFxcdF0qKSg/IVxccylbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXSg/Oig/IVxccylbJFxcd1xceEEwLVxcdUZGRkZdKSooPz1cXHMqOikvbSxcblx0XHRsb29rYmVoaW5kOiB0cnVlLFxuXHRcdGFsaWFzOiAncHJvcGVydHknXG5cdH0sXG59KTtcblxuaWYgKFByaXNtLmxhbmd1YWdlcy5tYXJrdXApIHtcblx0UHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuYWRkSW5saW5lZCgnc2NyaXB0JywgJ2phdmFzY3JpcHQnKTtcblxuXHQvLyBhZGQgYXR0cmlidXRlIHN1cHBvcnQgZm9yIGFsbCBET00gZXZlbnRzLlxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMjU3RhbmRhcmRfZXZlbnRzXG5cdFByaXNtLmxhbmd1YWdlcy5tYXJrdXAudGFnLmFkZEF0dHJpYnV0ZShcblx0XHQvb24oPzphYm9ydHxibHVyfGNoYW5nZXxjbGlja3xjb21wb3NpdGlvbig/OmVuZHxzdGFydHx1cGRhdGUpfGRibGNsaWNrfGVycm9yfGZvY3VzKD86aW58b3V0KT98a2V5KD86ZG93bnx1cCl8bG9hZHxtb3VzZSg/OmRvd258ZW50ZXJ8bGVhdmV8bW92ZXxvdXR8b3Zlcnx1cCl8cmVzZXR8cmVzaXplfHNjcm9sbHxzZWxlY3R8c2xvdGNoYW5nZXxzdWJtaXR8dW5sb2FkfHdoZWVsKS8uc291cmNlLFxuXHRcdCdqYXZhc2NyaXB0J1xuXHQpO1xufVxuXG5QcmlzbS5sYW5ndWFnZXMuanMgPSBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdDtcblxuXG4vKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgIEJlZ2luIHByaXNtLWZpbGUtaGlnaGxpZ2h0LmpzXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXG5cbihmdW5jdGlvbiAoKSB7XG5cblx0aWYgKHR5cGVvZiBQcmlzbSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L21hdGNoZXMjUG9seWZpbGxcblx0aWYgKCFFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSB7XG5cdFx0RWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3Rvcjtcblx0fVxuXG5cdHZhciBMT0FESU5HX01FU1NBR0UgPSAnTG9hZGluZ+KApic7XG5cdHZhciBGQUlMVVJFX01FU1NBR0UgPSBmdW5jdGlvbiAoc3RhdHVzLCBtZXNzYWdlKSB7XG5cdFx0cmV0dXJuICfinJYgRXJyb3IgJyArIHN0YXR1cyArICcgd2hpbGUgZmV0Y2hpbmcgZmlsZTogJyArIG1lc3NhZ2U7XG5cdH07XG5cdHZhciBGQUlMVVJFX0VNUFRZX01FU1NBR0UgPSAn4pyWIEVycm9yOiBGaWxlIGRvZXMgbm90IGV4aXN0IG9yIGlzIGVtcHR5JztcblxuXHR2YXIgRVhURU5TSU9OUyA9IHtcblx0XHQnanMnOiAnamF2YXNjcmlwdCcsXG5cdFx0J3B5JzogJ3B5dGhvbicsXG5cdFx0J3JiJzogJ3J1YnknLFxuXHRcdCdwczEnOiAncG93ZXJzaGVsbCcsXG5cdFx0J3BzbTEnOiAncG93ZXJzaGVsbCcsXG5cdFx0J3NoJzogJ2Jhc2gnLFxuXHRcdCdiYXQnOiAnYmF0Y2gnLFxuXHRcdCdoJzogJ2MnLFxuXHRcdCd0ZXgnOiAnbGF0ZXgnXG5cdH07XG5cblx0dmFyIFNUQVRVU19BVFRSID0gJ2RhdGEtc3JjLXN0YXR1cyc7XG5cdHZhciBTVEFUVVNfTE9BRElORyA9ICdsb2FkaW5nJztcblx0dmFyIFNUQVRVU19MT0FERUQgPSAnbG9hZGVkJztcblx0dmFyIFNUQVRVU19GQUlMRUQgPSAnZmFpbGVkJztcblxuXHR2YXIgU0VMRUNUT1IgPSAncHJlW2RhdGEtc3JjXTpub3QoWycgKyBTVEFUVVNfQVRUUiArICc9XCInICsgU1RBVFVTX0xPQURFRCArICdcIl0pJ1xuXHRcdCsgJzpub3QoWycgKyBTVEFUVVNfQVRUUiArICc9XCInICsgU1RBVFVTX0xPQURJTkcgKyAnXCJdKSc7XG5cblx0LyoqXG5cdCAqIExvYWRzIHRoZSBnaXZlbiBmaWxlLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc3JjIFRoZSBVUkwgb3IgcGF0aCBvZiB0aGUgc291cmNlIGZpbGUgdG8gbG9hZC5cblx0ICogQHBhcmFtIHsocmVzdWx0OiBzdHJpbmcpID0+IHZvaWR9IHN1Y2Nlc3Ncblx0ICogQHBhcmFtIHsocmVhc29uOiBzdHJpbmcpID0+IHZvaWR9IGVycm9yXG5cdCAqL1xuXHRmdW5jdGlvbiBsb2FkRmlsZShzcmMsIHN1Y2Nlc3MsIGVycm9yKSB7XG5cdFx0dmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXHRcdHhoci5vcGVuKCdHRVQnLCBzcmMsIHRydWUpO1xuXHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1xuXHRcdFx0XHRpZiAoeGhyLnN0YXR1cyA8IDQwMCAmJiB4aHIucmVzcG9uc2VUZXh0KSB7XG5cdFx0XHRcdFx0c3VjY2Vzcyh4aHIucmVzcG9uc2VUZXh0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoeGhyLnN0YXR1cyA+PSA0MDApIHtcblx0XHRcdFx0XHRcdGVycm9yKEZBSUxVUkVfTUVTU0FHRSh4aHIuc3RhdHVzLCB4aHIuc3RhdHVzVGV4dCkpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRlcnJvcihGQUlMVVJFX0VNUFRZX01FU1NBR0UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0eGhyLnNlbmQobnVsbCk7XG5cdH1cblxuXHQvKipcblx0ICogUGFyc2VzIHRoZSBnaXZlbiByYW5nZS5cblx0ICpcblx0ICogVGhpcyByZXR1cm5zIGEgcmFuZ2Ugd2l0aCBpbmNsdXNpdmUgZW5kcy5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkfSByYW5nZVxuXHQgKiBAcmV0dXJucyB7W251bWJlciwgbnVtYmVyIHwgdW5kZWZpbmVkXSB8IHVuZGVmaW5lZH1cblx0ICovXG5cdGZ1bmN0aW9uIHBhcnNlUmFuZ2UocmFuZ2UpIHtcblx0XHR2YXIgbSA9IC9eXFxzKihcXGQrKVxccyooPzooLClcXHMqKD86KFxcZCspXFxzKik/KT8kLy5leGVjKHJhbmdlIHx8ICcnKTtcblx0XHRpZiAobSkge1xuXHRcdFx0dmFyIHN0YXJ0ID0gTnVtYmVyKG1bMV0pO1xuXHRcdFx0dmFyIGNvbW1hID0gbVsyXTtcblx0XHRcdHZhciBlbmQgPSBtWzNdO1xuXG5cdFx0XHRpZiAoIWNvbW1hKSB7XG5cdFx0XHRcdHJldHVybiBbc3RhcnQsIHN0YXJ0XTtcblx0XHRcdH1cblx0XHRcdGlmICghZW5kKSB7XG5cdFx0XHRcdHJldHVybiBbc3RhcnQsIHVuZGVmaW5lZF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gW3N0YXJ0LCBOdW1iZXIoZW5kKV07XG5cdFx0fVxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHRQcmlzbS5ob29rcy5hZGQoJ2JlZm9yZS1oaWdobGlnaHRhbGwnLCBmdW5jdGlvbiAoZW52KSB7XG5cdFx0ZW52LnNlbGVjdG9yICs9ICcsICcgKyBTRUxFQ1RPUjtcblx0fSk7XG5cblx0UHJpc20uaG9va3MuYWRkKCdiZWZvcmUtc2FuaXR5LWNoZWNrJywgZnVuY3Rpb24gKGVudikge1xuXHRcdHZhciBwcmUgPSAvKiogQHR5cGUge0hUTUxQcmVFbGVtZW50fSAqLyAoZW52LmVsZW1lbnQpO1xuXHRcdGlmIChwcmUubWF0Y2hlcyhTRUxFQ1RPUikpIHtcblx0XHRcdGVudi5jb2RlID0gJyc7IC8vIGZhc3QtcGF0aCB0aGUgd2hvbGUgdGhpbmcgYW5kIGdvIHRvIGNvbXBsZXRlXG5cblx0XHRcdHByZS5zZXRBdHRyaWJ1dGUoU1RBVFVTX0FUVFIsIFNUQVRVU19MT0FESU5HKTsgLy8gbWFyayBhcyBsb2FkaW5nXG5cblx0XHRcdC8vIGFkZCBjb2RlIGVsZW1lbnQgd2l0aCBsb2FkaW5nIG1lc3NhZ2Vcblx0XHRcdHZhciBjb2RlID0gcHJlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ0NPREUnKSk7XG5cdFx0XHRjb2RlLnRleHRDb250ZW50ID0gTE9BRElOR19NRVNTQUdFO1xuXG5cdFx0XHR2YXIgc3JjID0gcHJlLmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKTtcblxuXHRcdFx0dmFyIGxhbmd1YWdlID0gZW52Lmxhbmd1YWdlO1xuXHRcdFx0aWYgKGxhbmd1YWdlID09PSAnbm9uZScpIHtcblx0XHRcdFx0Ly8gdGhlIGxhbmd1YWdlIG1pZ2h0IGJlICdub25lJyBiZWNhdXNlIHRoZXJlIGlzIG5vIGxhbmd1YWdlIHNldDtcblx0XHRcdFx0Ly8gaW4gdGhpcyBjYXNlLCB3ZSB3YW50IHRvIHVzZSB0aGUgZXh0ZW5zaW9uIGFzIHRoZSBsYW5ndWFnZVxuXHRcdFx0XHR2YXIgZXh0ZW5zaW9uID0gKC9cXC4oXFx3KykkLy5leGVjKHNyYykgfHwgWywgJ25vbmUnXSlbMV07XG5cdFx0XHRcdGxhbmd1YWdlID0gRVhURU5TSU9OU1tleHRlbnNpb25dIHx8IGV4dGVuc2lvbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gc2V0IGxhbmd1YWdlIGNsYXNzZXNcblx0XHRcdFByaXNtLnV0aWwuc2V0TGFuZ3VhZ2UoY29kZSwgbGFuZ3VhZ2UpO1xuXHRcdFx0UHJpc20udXRpbC5zZXRMYW5ndWFnZShwcmUsIGxhbmd1YWdlKTtcblxuXHRcdFx0Ly8gcHJlbG9hZCB0aGUgbGFuZ3VhZ2Vcblx0XHRcdHZhciBhdXRvbG9hZGVyID0gUHJpc20ucGx1Z2lucy5hdXRvbG9hZGVyO1xuXHRcdFx0aWYgKGF1dG9sb2FkZXIpIHtcblx0XHRcdFx0YXV0b2xvYWRlci5sb2FkTGFuZ3VhZ2VzKGxhbmd1YWdlKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbG9hZCBmaWxlXG5cdFx0XHRsb2FkRmlsZShcblx0XHRcdFx0c3JjLFxuXHRcdFx0XHRmdW5jdGlvbiAodGV4dCkge1xuXHRcdFx0XHRcdC8vIG1hcmsgYXMgbG9hZGVkXG5cdFx0XHRcdFx0cHJlLnNldEF0dHJpYnV0ZShTVEFUVVNfQVRUUiwgU1RBVFVTX0xPQURFRCk7XG5cblx0XHRcdFx0XHQvLyBoYW5kbGUgZGF0YS1yYW5nZVxuXHRcdFx0XHRcdHZhciByYW5nZSA9IHBhcnNlUmFuZ2UocHJlLmdldEF0dHJpYnV0ZSgnZGF0YS1yYW5nZScpKTtcblx0XHRcdFx0XHRpZiAocmFuZ2UpIHtcblx0XHRcdFx0XHRcdHZhciBsaW5lcyA9IHRleHQuc3BsaXQoL1xcclxcbj98XFxuL2cpO1xuXG5cdFx0XHRcdFx0XHQvLyB0aGUgcmFuZ2UgaXMgb25lLWJhc2VkIGFuZCBpbmNsdXNpdmUgb24gYm90aCBlbmRzXG5cdFx0XHRcdFx0XHR2YXIgc3RhcnQgPSByYW5nZVswXTtcblx0XHRcdFx0XHRcdHZhciBlbmQgPSByYW5nZVsxXSA9PSBudWxsID8gbGluZXMubGVuZ3RoIDogcmFuZ2VbMV07XG5cblx0XHRcdFx0XHRcdGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gbGluZXMubGVuZ3RoOyB9XG5cdFx0XHRcdFx0XHRzdGFydCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHN0YXJ0IC0gMSwgbGluZXMubGVuZ3RoKSk7XG5cdFx0XHRcdFx0XHRpZiAoZW5kIDwgMCkgeyBlbmQgKz0gbGluZXMubGVuZ3RoOyB9XG5cdFx0XHRcdFx0XHRlbmQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihlbmQsIGxpbmVzLmxlbmd0aCkpO1xuXG5cdFx0XHRcdFx0XHR0ZXh0ID0gbGluZXMuc2xpY2Uoc3RhcnQsIGVuZCkuam9pbignXFxuJyk7XG5cblx0XHRcdFx0XHRcdC8vIGFkZCBkYXRhLXN0YXJ0IGZvciBsaW5lIG51bWJlcnNcblx0XHRcdFx0XHRcdGlmICghcHJlLmhhc0F0dHJpYnV0ZSgnZGF0YS1zdGFydCcpKSB7XG5cdFx0XHRcdFx0XHRcdHByZS5zZXRBdHRyaWJ1dGUoJ2RhdGEtc3RhcnQnLCBTdHJpbmcoc3RhcnQgKyAxKSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gaGlnaGxpZ2h0IGNvZGVcblx0XHRcdFx0XHRjb2RlLnRleHRDb250ZW50ID0gdGV4dDtcblx0XHRcdFx0XHRQcmlzbS5oaWdobGlnaHRFbGVtZW50KGNvZGUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiAoZXJyb3IpIHtcblx0XHRcdFx0XHQvLyBtYXJrIGFzIGZhaWxlZFxuXHRcdFx0XHRcdHByZS5zZXRBdHRyaWJ1dGUoU1RBVFVTX0FUVFIsIFNUQVRVU19GQUlMRUQpO1xuXG5cdFx0XHRcdFx0Y29kZS50ZXh0Q29udGVudCA9IGVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH1cblx0fSk7XG5cblx0UHJpc20ucGx1Z2lucy5maWxlSGlnaGxpZ2h0ID0ge1xuXHRcdC8qKlxuXHRcdCAqIEV4ZWN1dGVzIHRoZSBGaWxlIEhpZ2hsaWdodCBwbHVnaW4gZm9yIGFsbCBtYXRjaGluZyBgcHJlYCBlbGVtZW50cyB1bmRlciB0aGUgZ2l2ZW4gY29udGFpbmVyLlxuXHRcdCAqXG5cdFx0ICogTm90ZTogRWxlbWVudHMgd2hpY2ggYXJlIGFscmVhZHkgbG9hZGVkIG9yIGN1cnJlbnRseSBsb2FkaW5nIHdpbGwgbm90IGJlIHRvdWNoZWQgYnkgdGhpcyBtZXRob2QuXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1BhcmVudE5vZGV9IFtjb250YWluZXI9ZG9jdW1lbnRdXG5cdFx0ICovXG5cdFx0aGlnaGxpZ2h0OiBmdW5jdGlvbiBoaWdobGlnaHQoY29udGFpbmVyKSB7XG5cdFx0XHR2YXIgZWxlbWVudHMgPSAoY29udGFpbmVyIHx8IGRvY3VtZW50KS5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SKTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGVsZW1lbnQ7IChlbGVtZW50ID0gZWxlbWVudHNbaSsrXSk7KSB7XG5cdFx0XHRcdFByaXNtLmhpZ2hsaWdodEVsZW1lbnQoZWxlbWVudCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBsb2dnZWQgPSBmYWxzZTtcblx0LyoqIEBkZXByZWNhdGVkIFVzZSBgUHJpc20ucGx1Z2lucy5maWxlSGlnaGxpZ2h0LmhpZ2hsaWdodGAgaW5zdGVhZC4gKi9cblx0UHJpc20uZmlsZUhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIWxvZ2dlZCkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdQcmlzbS5maWxlSGlnaGxpZ2h0IGlzIGRlcHJlY2F0ZWQuIFVzZSBgUHJpc20ucGx1Z2lucy5maWxlSGlnaGxpZ2h0LmhpZ2hsaWdodGAgaW5zdGVhZC4nKTtcblx0XHRcdGxvZ2dlZCA9IHRydWU7XG5cdFx0fVxuXHRcdFByaXNtLnBsdWdpbnMuZmlsZUhpZ2hsaWdodC5oaWdobGlnaHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fTtcblxufSgpKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5660\n")},1880:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "Z": function() { return /* binding */ _taggedTemplateLiteralLoose; }\n/* harmony export */ });\nfunction _taggedTemplateLiteralLoose(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n  strings.raw = raw;\n  return strings;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg4MC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3plZHV4LWRvY3MvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2UuanM/NDg1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdGFnZ2VkVGVtcGxhdGVMaXRlcmFsTG9vc2Uoc3RyaW5ncywgcmF3KSB7XG4gIGlmICghcmF3KSB7XG4gICAgcmF3ID0gc3RyaW5ncy5zbGljZSgwKTtcbiAgfVxuICBzdHJpbmdzLnJhdyA9IHJhdztcbiAgcmV0dXJuIHN0cmluZ3M7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1880\n')}}]);