"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[53],{1109:function(e){e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"react":[{"type":"category","label":"About","items":[{"type":"link","label":"Introducing Zedux","href":"/zedux/docs/about/introduction","docId":"about/introduction"},{"type":"link","label":"Overview","href":"/zedux/docs/about/overview","docId":"about/overview"},{"type":"link","label":"Recoil Comparison","href":"/zedux/docs/about/recoil-comparison","docId":"about/recoil-comparison"},{"type":"link","label":"Redux Comparison","href":"/zedux/docs/about/redux-comparison","docId":"about/redux-comparison"},{"type":"link","label":"React Query Comparison","href":"/zedux/docs/about/react-query-comparison","docId":"about/react-query-comparison"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Walkthrough","items":[{"type":"link","label":"Quick Start","href":"/zedux/docs/walkthrough/quick-start","docId":"walkthrough/quick-start"},{"type":"link","label":"Atom State","href":"/zedux/docs/walkthrough/atom-state","docId":"walkthrough/atom-state"},{"type":"link","label":"Atom Instances","href":"/zedux/docs/walkthrough/atom-instances","docId":"walkthrough/atom-instances"},{"type":"link","label":"Atom APIs","href":"/zedux/docs/walkthrough/atom-apis","docId":"walkthrough/atom-apis"},{"type":"link","label":"Ecosystems","href":"/zedux/docs/walkthrough/ecosystems","docId":"walkthrough/ecosystems"},{"type":"link","label":"The Graph","href":"/zedux/docs/walkthrough/the-graph","docId":"walkthrough/the-graph"},{"type":"link","label":"Overrides","href":"/zedux/docs/walkthrough/overrides","docId":"walkthrough/overrides"},{"type":"link","label":"Configuring Atoms","href":"/zedux/docs/walkthrough/configuring-atoms","docId":"walkthrough/configuring-atoms"},{"type":"link","label":"Atom Getters","href":"/zedux/docs/walkthrough/atom-getters","docId":"walkthrough/atom-getters"},{"type":"link","label":"Selectors","href":"/zedux/docs/walkthrough/selectors","docId":"walkthrough/selectors"},{"type":"link","label":"Destruction","href":"/zedux/docs/walkthrough/destruction","docId":"walkthrough/destruction"},{"type":"link","label":"React Context","href":"/zedux/docs/walkthrough/react-context","docId":"walkthrough/react-context"},{"type":"link","label":"Suspense","href":"/zedux/docs/walkthrough/suspense","docId":"walkthrough/suspense"},{"type":"link","label":"Query Atoms","href":"/zedux/docs/walkthrough/query-atoms","docId":"walkthrough/query-atoms"},{"type":"link","label":"Stores","href":"/zedux/docs/walkthrough/stores","docId":"walkthrough/stores"},{"type":"link","label":"Side Effects","href":"/zedux/docs/walkthrough/side-effects","docId":"walkthrough/side-effects"},{"type":"link","label":"Custom Injectors","href":"/zedux/docs/walkthrough/custom-injectors","docId":"walkthrough/custom-injectors"},{"type":"link","label":"Resets","href":"/zedux/docs/walkthrough/resets","docId":"walkthrough/resets"},{"type":"link","label":"State Machines","href":"/zedux/docs/walkthrough/state-machines","docId":"walkthrough/state-machines"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Advanced","items":[{"type":"link","label":"Complex Params","href":"/zedux/docs/advanced/complex-params","docId":"advanced/complex-params"},{"type":"link","label":"Persistence","href":"/zedux/docs/advanced/persistence","docId":"advanced/persistence"},{"type":"link","label":"SSR","href":"/zedux/docs/advanced/ssr","docId":"advanced/ssr"},{"type":"link","label":"Time Travel","href":"/zedux/docs/advanced/time-travel","docId":"advanced/time-travel"},{"type":"link","label":"Plugins","href":"/zedux/docs/advanced/plugins","docId":"advanced/plugins"},{"type":"link","label":"Store Composition","href":"/zedux/docs/advanced/store-composition","docId":"advanced/store-composition"},{"type":"link","label":"More Patterns","href":"/zedux/docs/advanced/more-patterns","docId":"advanced/more-patterns"}],"collapsed":true,"collapsible":true},{"type":"category","label":"API","items":[{"type":"category","label":"Classes","items":[{"type":"link","label":"Atom","href":"/zedux/docs/api/classes/Atom","docId":"api/classes/Atom"},{"type":"link","label":"AtomApi","href":"/zedux/docs/api/classes/AtomApi","docId":"api/classes/AtomApi"},{"type":"link","label":"AtomInstance","href":"/zedux/docs/api/classes/AtomInstance","docId":"api/classes/AtomInstance"},{"type":"link","label":"Ecosystem","href":"/zedux/docs/api/classes/Ecosystem","docId":"api/classes/Ecosystem"},{"type":"link","label":"Ion","href":"/zedux/docs/api/classes/Ion","docId":"api/classes/Ion"},{"type":"link","label":"MachineStore","href":"/zedux/docs/api/classes/MachineStore","docId":"api/classes/MachineStore"},{"type":"link","label":"SelectorCache","href":"/zedux/docs/api/classes/SelectorCache","docId":"api/classes/SelectorCache"},{"type":"link","label":"SelectorCacheItem","href":"/zedux/docs/api/classes/SelectorCacheItem","docId":"api/classes/SelectorCacheItem"},{"type":"link","label":"Store","href":"/zedux/docs/api/classes/Store","docId":"api/classes/Store"},{"type":"link","label":"ZeduxPlugin","href":"/zedux/docs/api/classes/ZeduxPlugin","docId":"api/classes/ZeduxPlugin"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Components","items":[{"type":"link","label":"AtomInstanceProvider","href":"/zedux/docs/api/components/AtomInstanceProvider","docId":"api/components/AtomInstanceProvider"},{"type":"link","label":"EcosystemProvider","href":"/zedux/docs/api/components/EcosystemProvider","docId":"api/components/EcosystemProvider"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Factories","items":[{"type":"link","label":"actionFactory","href":"/zedux/docs/api/factories/actionFactory","docId":"api/factories/actionFactory"},{"type":"link","label":"api","href":"/zedux/docs/api/factories/api","docId":"api/factories/api"},{"type":"link","label":"atom","href":"/zedux/docs/api/factories/atom","docId":"api/factories/atom"},{"type":"link","label":"createEcosystem","href":"/zedux/docs/api/factories/createEcosystem","docId":"api/factories/createEcosystem"},{"type":"link","label":"createInjector","href":"/zedux/docs/api/factories/createInjector","docId":"api/factories/createInjector"},{"type":"link","label":"createReducer","href":"/zedux/docs/api/factories/createReducer","docId":"api/factories/createReducer"},{"type":"link","label":"createStore","href":"/zedux/docs/api/factories/createStore","docId":"api/factories/createStore"},{"type":"link","label":"ion","href":"/zedux/docs/api/factories/ion","docId":"api/factories/ion"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Hooks","items":[{"type":"link","label":"useAtomConsumer","href":"/zedux/docs/api/hooks/useAtomConsumer","docId":"api/hooks/useAtomConsumer"},{"type":"link","label":"useAtomInstance","href":"/zedux/docs/api/hooks/useAtomInstance","docId":"api/hooks/useAtomInstance"},{"type":"link","label":"useAtomSelector","href":"/zedux/docs/api/hooks/useAtomSelector","docId":"api/hooks/useAtomSelector"},{"type":"link","label":"useAtomState","href":"/zedux/docs/api/hooks/useAtomState","docId":"api/hooks/useAtomState"},{"type":"link","label":"useAtomValue","href":"/zedux/docs/api/hooks/useAtomValue","docId":"api/hooks/useAtomValue"},{"type":"link","label":"useEcosystem","href":"/zedux/docs/api/hooks/useEcosystem","docId":"api/hooks/useEcosystem"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Injectors","items":[{"type":"link","label":"injectAtomGetters","href":"/zedux/docs/api/injectors/injectAtomGetters","docId":"api/injectors/injectAtomGetters"},{"type":"link","label":"injectAtomInstance","href":"/zedux/docs/api/injectors/injectAtomInstance","docId":"api/injectors/injectAtomInstance"},{"type":"link","label":"injectAtomSelector","href":"/zedux/docs/api/injectors/injectAtomSelector","docId":"api/injectors/injectAtomSelector"},{"type":"link","label":"injectAtomState","href":"/zedux/docs/api/injectors/injectAtomState","docId":"api/injectors/injectAtomState"},{"type":"link","label":"injectAtomValue","href":"/zedux/docs/api/injectors/injectAtomValue","docId":"api/injectors/injectAtomValue"},{"type":"link","label":"injectCallback","href":"/zedux/docs/api/injectors/injectCallback","docId":"api/injectors/injectCallback"},{"type":"link","label":"injectEffect","href":"/zedux/docs/api/injectors/injectEffect","docId":"api/injectors/injectEffect"},{"type":"link","label":"injectInvalidate","href":"/zedux/docs/api/injectors/injectInvalidate","docId":"api/injectors/injectInvalidate"},{"type":"link","label":"injectMachineStore","href":"/zedux/docs/api/injectors/injectMachineStore","docId":"api/injectors/injectMachineStore"},{"type":"link","label":"injectMemo","href":"/zedux/docs/api/injectors/injectMemo","docId":"api/injectors/injectMemo"},{"type":"link","label":"injectPromise","href":"/zedux/docs/api/injectors/injectPromise","docId":"api/injectors/injectPromise"},{"type":"link","label":"injectRef","href":"/zedux/docs/api/injectors/injectRef","docId":"api/injectors/injectRef"},{"type":"link","label":"injectStore","href":"/zedux/docs/api/injectors/injectStore","docId":"api/injectors/injectStore"},{"type":"link","label":"injectWhy","href":"/zedux/docs/api/injectors/injectWhy","docId":"api/injectors/injectWhy"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Types","items":[{"type":"link","label":"Action","href":"/zedux/docs/api/types/Action","docId":"api/types/Action"},{"type":"link","label":"ActionChain","href":"/zedux/docs/api/types/ActionChain","docId":"api/types/ActionChain"},{"type":"link","label":"ActionFactory","href":"/zedux/docs/api/types/ActionFactory","docId":"api/types/ActionFactory"},{"type":"link","label":"AtomConfig","href":"/zedux/docs/api/types/AtomConfig","docId":"api/types/AtomConfig"},{"type":"link","label":"AtomGetters","href":"/zedux/docs/api/types/AtomGetters","docId":"api/types/AtomGetters"},{"type":"link","label":"AtomInstanceTtl","href":"/zedux/docs/api/types/AtomInstanceTtl","docId":"api/types/AtomInstanceTtl"},{"type":"link","label":"AtomSelector","href":"/zedux/docs/api/types/AtomSelector","docId":"api/types/AtomSelector"},{"type":"link","label":"AtomSelectorConfig","href":"/zedux/docs/api/types/AtomSelectorConfig","docId":"api/types/AtomSelectorConfig"},{"type":"link","label":"DependentCallback","href":"/zedux/docs/api/types/DependentCallback","docId":"api/types/DependentCallback"},{"type":"link","label":"EcosystemConfig","href":"/zedux/docs/api/types/EcosystemConfig","docId":"api/types/EcosystemConfig"},{"type":"link","label":"EvaluationReason","href":"/zedux/docs/api/types/EvaluationReason","docId":"api/types/EvaluationReason"},{"type":"link","label":"HierarchyDescriptor","href":"/zedux/docs/api/types/HierarchyDescriptor","docId":"api/types/HierarchyDescriptor"},{"type":"link","label":"MachineState","href":"/zedux/docs/api/types/MachineState","docId":"api/types/MachineState"},{"type":"link","label":"PromiseState","href":"/zedux/docs/api/types/PromiseState","docId":"api/types/PromiseState"},{"type":"link","label":"Reducer","href":"/zedux/docs/api/types/Reducer","docId":"api/types/Reducer"},{"type":"link","label":"ReducerBuilder","href":"/zedux/docs/api/types/ReducerBuilder","docId":"api/types/ReducerBuilder"},{"type":"link","label":"Settable","href":"/zedux/docs/api/types/Settable","docId":"api/types/Settable"},{"type":"link","label":"StoreEffect","href":"/zedux/docs/api/types/StoreEffect","docId":"api/types/StoreEffect"},{"type":"link","label":"Subscriber","href":"/zedux/docs/api/types/Subscriber","docId":"api/types/Subscriber"},{"type":"link","label":"Subscription","href":"/zedux/docs/api/types/Subscription","docId":"api/types/Subscription"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Utils","items":[{"type":"link","label":"Action Chain Utils","href":"/zedux/docs/api/utils/action-chain-utils","docId":"api/utils/action-chain-utils"},{"type":"link","label":"Internal Store Utils","href":"/zedux/docs/api/utils/internal-store-utils","docId":"api/utils/internal-store-utils"},{"type":"link","label":"internalTypes","href":"/zedux/docs/api/utils/internalTypes","docId":"api/utils/internalTypes"},{"type":"link","label":"is","href":"/zedux/docs/api/utils/is","docId":"api/utils/is"}],"collapsed":true,"collapsible":true},{"type":"link","label":"Glossary","href":"/zedux/docs/api/glossary","docId":"api/glossary"}],"collapsed":true,"collapsible":true},{"type":"category","label":"Packages","items":[{"type":"link","label":"@zedux/immer","href":"/zedux/docs/packages/immer","docId":"packages/immer"}],"collapsed":true,"collapsible":true}]},"docs":{"about/faq":{"id":"about/faq","title":"FAQ","description":""},"about/introduction":{"id":"about/introduction","title":"Introducing Zedux","description":"Zedux is a flexible, multi-paradigm state management tool for React. It\'s packed with features covering all aspects of state management.","sidebar":"react"},"about/overview":{"id":"about/overview","title":"Overview","description":"Buckle in for a quick description and contrived example of every key feature of Zedux. The walkthrough will walk through this list in much more detail.","sidebar":"react"},"about/react-query-comparison":{"id":"about/react-query-comparison","title":"React Query Comparison","description":"While Zedux doesn\'t (yet!) provide helpers for query operations (infinite scrolling, pagination, etc), Zedux is currently patterned after React Query more than any other library (yes, more than Redux or Recoil). React Query\'s cache management is unparalleled. So Zedux\' atomic model borrows a lot of ideas from it.","sidebar":"react"},"about/recoil-comparison":{"id":"about/recoil-comparison","title":"Recoil Comparison","description":"Zedux\' atomic model was born in 2020 shortly after Recoil started gaining traction. We liked Recoil, but were turned away mostly by its complexity and (then-)unstable effects model. By borrowing ideas from React Query and React itself and by using Zedux\' existing composable store model, we were able to create an atomic model that we\'ve found more beginner-friendly and powerful.","sidebar":"react"},"about/redux-comparison":{"id":"about/redux-comparison","title":"Redux Comparison","description":"Zedux is more comparable to Redux Toolkit (RTK) than raw Redux, so that\'s what we\'ll compare against.","sidebar":"react"},"advanced/complex-params":{"id":"advanced/complex-params","title":"Complex Params","description":"Atom params and atom selector params must be serializable (with the exception of atom instances). Though it isn\'t recommended, you can disable this requirement.","sidebar":"react"},"advanced/dev-tools":{"id":"advanced/dev-tools","title":"Dev Tools","description":"\ud83d\udea7 This page is under construction"},"advanced/more-patterns":{"id":"advanced/more-patterns","title":"More Patterns","description":"Circular Dependencies","sidebar":"react"},"advanced/persistence":{"id":"advanced/persistence","title":"Persistence","description":"There are many ways to persist and restore state \\"snapshots\\" in Zedux. It can be done at the atom instance, ecosystem, or plugin level.","sidebar":"react"},"advanced/plugins":{"id":"advanced/plugins","title":"Plugins","description":"This API is very low-level. Library authors and advanced users may want to make use of it.","sidebar":"react"},"advanced/ssr":{"id":"advanced/ssr","title":"SSR","description":"In the persistence guide, we learned how to get an ecosystem\'s state snapshot and use it to rehydrate the entire ecosystem. There is only a little more to learn to get a full-fledged SSR setup going.","sidebar":"react"},"advanced/store-composition":{"id":"advanced/store-composition","title":"Store Composition","description":"ActionChains","sidebar":"react"},"advanced/time-travel":{"id":"advanced/time-travel","title":"Time Travel","description":"One of the great patterns that Redux popularized is the ability to undo and redo state updates in your app. Earlier flux models didn\'t have this capability because they split state up across multiple stores. Well Zedux reintroduces the concept of multiple stores, so does that mean it loses out on time travel?","sidebar":"react"},"api/classes/Atom":{"id":"api/classes/Atom","title":"Atom","description":"The standard, default atom type. Instances of this class are passed to most of Zedux\' hooks and injectors.","sidebar":"react"},"api/classes/AtomApi":{"id":"api/classes/AtomApi","title":"AtomApi","description":"Atom APIs dynamically define certain integral properties of an atom. These properties do not fit well in the injector paradigm, as they define key characteristics of the atom itself.","sidebar":"react"},"api/classes/AtomInstance":{"id":"api/classes/AtomInstance","title":"AtomInstance","description":"All standard \\"atom instances\\" are actually instances of this class. When Zedux instantiates Ions and Standard Atoms, it\'s just creating instances of this class.","sidebar":"react"},"api/classes/Ecosystem":{"id":"api/classes/Ecosystem","title":"Ecosystem","description":"The ecosystem is an isolated atom environment. Every ecosystem creates:","sidebar":"react"},"api/classes/Ion":{"id":"api/classes/Ion","title":"Ion","description":"Extends Atom.","sidebar":"react"},"api/classes/MachineStore":{"id":"api/classes/MachineStore","title":"MachineStore","description":"Extends Store. injectMachineStore() returns an instance of this class.","sidebar":"react"},"api/classes/SelectorCache":{"id":"api/classes/SelectorCache","title":"SelectorCache","description":"Since atom selectors are meant to feel lightweight, they don\'t have to be instances of a class - they\'ll often be standalone or even inline functions. This class handles all the logic that atom selectors would handle themselves if they were classes - instantiation, cache management, and destruction.","sidebar":"react"},"api/classes/SelectorCacheItem":{"id":"api/classes/SelectorCacheItem","title":"SelectorCacheItem","description":"Every time an ecosystem\'s .selectorCache caches an atom selector, the \\"cached selector\\" is really just an instance of this class. Thus, an instance of this class is what\'s returned from various SelectorCache methods like .getCache() and .inspectCacheItems().","sidebar":"react"},"api/classes/Store":{"id":"api/classes/Store","title":"Store","description":"The createStore() factory returns an instance of this class. The store is the basic unit of state management.","sidebar":"react"},"api/classes/ZeduxPlugin":{"id":"api/classes/ZeduxPlugin","title":"ZeduxPlugin","description":"The base class of Zedux ecosystem plugins.","sidebar":"react"},"api/components/AtomInstanceProvider":{"id":"api/components/AtomInstanceProvider","title":"AtomInstanceProvider","description":"A component that provides one or more atom instances over React context.","sidebar":"react"},"api/components/EcosystemProvider":{"id":"api/components/EcosystemProvider","title":"EcosystemProvider","description":"A component that provides an ecosystem over React context. The provided ecosystem will take command of all atom usages in any child components.","sidebar":"react"},"api/factories/actionFactory":{"id":"api/factories/actionFactory","title":"actionFactory","description":"A factory for creating action factories (yes, a \\"factory factory\\").","sidebar":"react"},"api/factories/api":{"id":"api/factories/api","title":"api","description":"A factory for creating AtomApis.","sidebar":"react"},"api/factories/atom":{"id":"api/factories/atom","title":"atom","description":"Where it all starts. atom() is a factory for creating normal, everyday atoms. These atoms are actually instances of the Atom class.","sidebar":"react"},"api/factories/createEcosystem":{"id":"api/factories/createEcosystem","title":"createEcosystem","description":"Creates an atom ecosystem.","sidebar":"react"},"api/factories/createInjector":{"id":"api/factories/createInjector","title":"createInjector","description":"This API is very low-level. Library authors and advanced users may want to make use of it. But:","sidebar":"react"},"api/factories/createReducer":{"id":"api/factories/createReducer","title":"createReducer","description":"A factory for creating Redux-style reducers. These reducers can then be passed to createStore() or used directly in React\'s useReducer() hooks.","sidebar":"react"},"api/factories/createStore":{"id":"api/factories/createStore","title":"createStore","description":"Creates a Zedux store. Prefer using injectStore() to create stores inside atoms.","sidebar":"react"},"api/factories/ion":{"id":"api/factories/ion","title":"ion","description":"A factory for creating Ions. Ions are a type of atom that specialize in selection and derivation operations.","sidebar":"react"},"api/glossary":{"id":"api/glossary","title":"Glossary","description":"Dynamic Graph Dependency","sidebar":"react"},"api/hooks/useAtomConsumer":{"id":"api/hooks/useAtomConsumer","title":"useAtomConsumer","description":"A React hook that accepts an atom and returns an instance of that atom that has been provided over React context via ``.","sidebar":"react"},"api/hooks/useAtomInstance":{"id":"api/hooks/useAtomInstance","title":"useAtomInstance","description":"A React hook that accepts an atom and its params and registers a static graph dependency on the resolved atom instance. Returns the resolved atom instance object.","sidebar":"react"},"api/hooks/useAtomSelector":{"id":"api/hooks/useAtomSelector","title":"useAtomSelector","description":"A React hook that accepts an AtomSelector and registers a dynamic graph dependency on the selector\'s cache.","sidebar":"react"},"api/hooks/useAtomState":{"id":"api/hooks/useAtomState","title":"useAtomState","description":"A React hook that accepts an atom and its params and registers a dynamic graph dependency on the resolved atom instance, returning a tuple of the current value and a state setter.","sidebar":"react"},"api/hooks/useAtomValue":{"id":"api/hooks/useAtomValue","title":"useAtomValue","description":"A React hook that accepts an atom and its params and registers a dynamic graph dependency on the resolved atom instance, returning the value.","sidebar":"react"},"api/hooks/useEcosystem":{"id":"api/hooks/useEcosystem","title":"useEcosystem","description":"A React hook that returns a reference to the nearest ecosystem that\'s been provided over React context via ``. If no ecosystem has been provided, Zedux will return the global ecosystem. If the global ecosystem hasn\'t been created yet, Zedux will create it.","sidebar":"react"},"api/injectors/injectAtomGetters":{"id":"api/injectors/injectAtomGetters","title":"injectAtomGetters","description":"An unrestricted injector that returns an AtomGetters object","sidebar":"react"},"api/injectors/injectAtomInstance":{"id":"api/injectors/injectAtomInstance","title":"injectAtomInstance","description":"An injector that accepts an atom and its params and registers a static graph dependency on the resolved atom instance. Returns the resolved atom instance object.","sidebar":"react"},"api/injectors/injectAtomSelector":{"id":"api/injectors/injectAtomSelector","title":"injectAtomSelector","description":"An injector that accepts an AtomSelector and registers a dynamic graph dependency on the selector\'s cache.","sidebar":"react"},"api/injectors/injectAtomState":{"id":"api/injectors/injectAtomState","title":"injectAtomState","description":"An injector that accepts an atom and its params and registers a dynamic graph dependency on the resolved atom instance. Returns a tuple of the instance\'s store\'s current value and an export-infused state setter function.","sidebar":"react"},"api/injectors/injectAtomValue":{"id":"api/injectors/injectAtomValue","title":"injectAtomValue","description":"An injector that accepts an atom and its params and registers a dynamic graph dependency on the resolved atom instance. Returns the current value of the injected atom instance\'s store.","sidebar":"react"},"api/injectors/injectCallback":{"id":"api/injectors/injectCallback","title":"injectCallback","description":"An injector that memoizes a function. Really just a shorthand for injectMemo() where the memoized value itself is a function. The returned function reference will only change when the passed dependencies change.","sidebar":"react"},"api/injectors/injectEffect":{"id":"api/injectors/injectEffect","title":"injectEffect","description":"An injector that attaches a side effect to an atom instance. Runs the effect on initial atom evaluation and again every time the passed dependencies change on subsequent evaluations.","sidebar":"react"},"api/injectors/injectInvalidate":{"id":"api/injectors/injectInvalidate","title":"injectInvalidate","description":"An unrestricted injector that returns an invalidate() function. This invalidate() function can be used to force a reevaluation of the current atom instance.","sidebar":"react"},"api/injectors/injectMachineStore":{"id":"api/injectors/injectMachineStore","title":"injectMachineStore","description":"An injector that creates and configures a MachineStore.","sidebar":"react"},"api/injectors/injectMemo":{"id":"api/injectors/injectMemo","title":"injectMemo","description":"An injector that memoizes a value. This is the injector equivalent of React\'s useMemo() hook. Like useMemo(), injectMemo() will return the same value on subsequent evaluations unless any items in the dependency array change.","sidebar":"react"},"api/injectors/injectPromise":{"id":"api/injectors/injectPromise","title":"injectPromise","description":"An injector that creates a memoized promise reference. Returns an AtomApi with a promise and store attached. This AtomApi\'s store tracks the promise\'s state.","sidebar":"react"},"api/injectors/injectRef":{"id":"api/injectors/injectRef","title":"injectRef","description":"An injector that returns a stable, mutable Ref object. The injector equivalent of React\'s useRef hook.","sidebar":"react"},"api/injectors/injectStore":{"id":"api/injectors/injectStore","title":"injectStore","description":"An injector that creates and returns a stable Zedux store. This reference will not change on subsequent evaluations of this atom instance.","sidebar":"react"},"api/injectors/injectWhy":{"id":"api/injectors/injectWhy","title":"injectWhy","description":"An unrestricted injector that returns a list of reasons explaining why the current atom instance is reevaluating. This injector returns an empty array on the first evaluation. On subsequent evaluations, it returns the full list of EvaluationReasons detailing why this atom reevaluated.","sidebar":"react"},"api/types/Action":{"id":"api/types/Action","title":"Action","description":"The objects ultimately dispatched to Zedux stores.","sidebar":"react"},"api/types/ActionChain":{"id":"api/types/ActionChain","title":"ActionChain","description":"The object accepted by store.dispatch(), thus also the object passed to instance.dispatch().","sidebar":"react"},"api/types/ActionFactory":{"id":"api/types/ActionFactory","title":"ActionFactory","description":"The function returned from the actionFactory() factory.","sidebar":"react"},"api/types/AtomConfig":{"id":"api/types/AtomConfig","title":"AtomConfig","description":"An AtomConfig object is the 3rd argument passed to the atom() factory.","sidebar":"react"},"api/types/AtomGetters":{"id":"api/types/AtomGetters","title":"AtomGetters","description":"An object that provides several functions for working with atoms.","sidebar":"react"},"api/types/AtomInstanceTtl":{"id":"api/types/AtomInstanceTtl","title":"AtomInstanceTtl","description":"Ttl (Time To Live) can be set at the ecosystem, atom, or atom instance levels. Setting a ttl at the atom instance level is the most flexible. You can do so using an AtomApi.","sidebar":"react"},"api/types/AtomSelector":{"id":"api/types/AtomSelector","title":"AtomSelector","description":"A function that receives an AtomGetters object as its first parameter. It can take any number of other parameters and can return anything. It can use the AtomGetters to get atom values and run other AtomSelectors.","sidebar":"react"},"api/types/AtomSelectorConfig":{"id":"api/types/AtomSelectorConfig","title":"AtomSelectorConfig","description":"Everywhere Zedux accepts an AtomSelector, it also accepts an AtomSelectorConfig object. This object has a required selector field and a few optional fields used to configure the selector.","sidebar":"react"},"api/types/DependentCallback":{"id":"api/types/DependentCallback","title":"DependentCallback","description":"A low-level function used when manually graphing e.g. with ecosystem.selectorCache.addDependent() or atomInstance.addDependent(). This function is called with special \\"GraphEdgeSignals\\" when Zedux needs to push some new information about the dependency to the dependent.","sidebar":"react"},"api/types/EcosystemConfig":{"id":"api/types/EcosystemConfig","title":"EcosystemConfig","description":"The config object passed to the createEcosystem() factory.","sidebar":"react"},"api/types/EvaluationReason":{"id":"api/types/EvaluationReason","title":"EvaluationReason","description":"Every update that causes an atom instance to reevaluate produces an EvaluationReason. You can get the list of reasons that caused an atom instance to reevaluate using injectWhy().","sidebar":"react"},"api/types/HierarchyDescriptor":{"id":"api/types/HierarchyDescriptor","title":"HierarchyDescriptor","description":"The type passed to createStore() and to Store#use().","sidebar":"react"},"api/types/MachineState":{"id":"api/types/MachineState","title":"MachineState","description":"The object returned from injectMachineStore()\'s createState factory. The MachineState\'s API is used to define the state machine\'s transitions, listeners, and guards.","sidebar":"react"},"api/types/PromiseState":{"id":"api/types/PromiseState","title":"PromiseState","description":"The state shape that query atoms and injectPromise use. This shape is based off React Query\'s queries.","sidebar":"react"},"api/types/Reducer":{"id":"api/types/Reducer","title":"Reducer","description":"In Zedux, reducers are exactly the same as in Redux and React. A reducer is just a function that receives the current state and an action and returns the new state.","sidebar":"react"},"api/types/ReducerBuilder":{"id":"api/types/ReducerBuilder","title":"ReducerBuilder","description":"The function returned from createReducer.","sidebar":"react"},"api/types/Settable":{"id":"api/types/Settable","title":"Settable","description":"The value passed to store.setState() and store.setStateDeep(), thus also the value passed to instance.setState() and instance.setStateDeep().","sidebar":"react"},"api/types/StoreEffect":{"id":"api/types/StoreEffect","title":"StoreEffect","description":"An object that describes a state change in a store. Zedux creates one of these every time a store\'s state changes. This is the object passed to effects subscribers and state machine listeners.","sidebar":"react"},"api/types/Subscriber":{"id":"api/types/Subscriber","title":"Subscriber","description":"A function passed to store.subscribe(). Zedux will call the function when certain events happen.","sidebar":"react"},"api/types/Subscription":{"id":"api/types/Subscription","title":"Subscription","description":"The object returned from Store#subscribe().","sidebar":"react"},"api/utils/action-chain-utils":{"id":"api/utils/action-chain-utils","title":"Action Chain Utils","description":"Zedux exports a few functions that it uses internally when working with ActionChain objects. The only one you should probably ever use is removeAllMeta().","sidebar":"react"},"api/utils/internal-store-utils":{"id":"api/utils/internal-store-utils","title":"Internal Store Utils","description":"Zedux exports an internalStore and a few utility functions for working with it. You should almost never use these in a real app. They\'re mostly for testing and odd situations like supporting multiple windows.","sidebar":"react"},"api/utils/internalTypes":{"id":"api/utils/internalTypes","title":"internalTypes","description":"An object containing action type and meta type strings that Zedux uses internally in its ActionChain objects. You may encounter these in actions and action chains passed to effects subscribers, especially in composed stores. Use this object to identify them.","sidebar":"react"},"api/utils/is":{"id":"api/utils/is","title":"is","description":"A utility function that Zedux uses internally to identify class instances.","sidebar":"react"},"packages/immer":{"id":"packages/immer","title":"@zedux/immer","description":"The official Immer bindings for Zedux. This package exports a new ImmerStore class and a few helpers for insantiating it.","sidebar":"react"},"walkthrough/atom-apis":{"id":"walkthrough/atom-apis","title":"Atom APIs","description":"In the quick start, we learned that injectors are like hooks for atoms. But some operations don\'t fit well into the injector paradigm. Injectors, like hooks, should be composable and usable multiple times throughout an atom state factory and other injectors.","sidebar":"react"},"walkthrough/atom-getters":{"id":"walkthrough/atom-getters","title":"Atom Getters","description":"We\'ve learned several hooks and injectors that we can use to get atoms and their values while updating the dependency graph. These are easy enough. But it gets even easier.","sidebar":"react"},"walkthrough/atom-instances":{"id":"walkthrough/atom-instances","title":"Atom Instances","description":"In the quick start, we learned that atoms are like classes. Whenever an atom is used, Zedux creates an \\"instance\\" of that atom and caches it.","sidebar":"react"},"walkthrough/atom-state":{"id":"walkthrough/atom-state","title":"Atom State","description":"In the quick start we learned how to use the useAtomState hook to get and update an atom instance\'s state from a React component. Calling the setState function returned from useAtomState triggers an \\"external update\\". But atoms can also update themselves.","sidebar":"react"},"walkthrough/configuring-atoms":{"id":"walkthrough/configuring-atoms","title":"Configuring Atoms","description":"We\'ve learned how to use Atom APIs to configure an atom instance\'s promise and exports. But there are a few more configuration options we haven\'t covered.","sidebar":"react"},"walkthrough/custom-injectors":{"id":"walkthrough/custom-injectors","title":"Custom Injectors","description":"If you use React, you\'ve probably written custom hooks. These are functions whose names start with use and that compose other hooks.","sidebar":"react"},"walkthrough/destruction":{"id":"walkthrough/destruction","title":"Destruction","description":"In the atom instances walkthrough, we learned that every atom instance has an activeState \\"lifecycle\\":","sidebar":"react"},"walkthrough/ecosystems":{"id":"walkthrough/ecosystems","title":"Ecosystems","description":"All atoms live in an atom ecosystem. An ecosystem is like an isolated group of atoms. Atoms in an ecosystem can interact with each other, but are unaware of atoms in other ecosystems.","sidebar":"react"},"walkthrough/overrides":{"id":"walkthrough/overrides","title":"Overrides","description":"Zedux\' Dependency Injection (DI) model is extremely dynamic. This walkthrough has taught several ways to inject atoms and create the DI graph so far. But Zedux has another DI superpower: Overrides.","sidebar":"react"},"walkthrough/query-atoms":{"id":"walkthrough/query-atoms","title":"Query Atoms","description":"The Atom APIs and Suspense walkthroughs taught how to set an atom instance\'s promise. But promises themselves innately carry state like:","sidebar":"react"},"walkthrough/quick-start":{"id":"walkthrough/quick-start","title":"Quick Start","description":"Zedux is a powerful state management tool for React.","sidebar":"react"},"walkthrough/react-context":{"id":"walkthrough/react-context","title":"React Context","description":"The atomic model naturally fixes all the problems with React context. In Zedux, we can use React context with all of its benefits and none of its downsides.","sidebar":"react"},"walkthrough/resets":{"id":"walkthrough/resets","title":"Resets","description":"There are many situations where you may want to reset the state of one or more atoms. While Zedux doesn\'t have any built-in atom reset helpers like Recoil or Jotai, there are many ways to go about resetting state.","sidebar":"react"},"walkthrough/selectors":{"id":"walkthrough/selectors","title":"Selectors","description":"A crucial tool in state management is the ability to \\"derive\\" or transform data. In the React world, we call such state transformers \\"selectors\\". Zedux has a few different flavors of selectors.","sidebar":"react"},"walkthrough/side-effects":{"id":"walkthrough/side-effects","title":"Side Effects","description":"Zedux doesn\'t place any restrictions on how you manage asynchronous code. You can use promises, observables, sockets, generators, or any third-party library.","sidebar":"react"},"walkthrough/state-machines":{"id":"walkthrough/state-machines","title":"State Machines","description":"The state machine is one of the most important tools a statesmith can have in his belt. XState is the current king of the JavaScript state machine world. Zedux is not out to change that, in fact we may build an official XState Zedux integration soon.","sidebar":"react"},"walkthrough/stores":{"id":"walkthrough/stores","title":"Stores","description":"The store is the heart of Zedux. Zedux uses a unique and unprecedented composable store model. These stores are light-weight, powerful, and fast.","sidebar":"react"},"walkthrough/suspense":{"id":"walkthrough/suspense","title":"Suspense","description":"Atoms are extremely flexible when working with React suspense. We\'ve learned how to use Atom APIs to set an atom instance\'s promise. It\'s time we learned how this works with suspense.","sidebar":"react"},"walkthrough/the-graph":{"id":"walkthrough/the-graph","title":"The Graph","description":"As you use atoms inside an ecosystem, Zedux tracks dependencies and forms a graph that it uses to efficiently propagate state updates.","sidebar":"react"}}}')}}]);