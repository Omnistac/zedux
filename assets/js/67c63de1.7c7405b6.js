"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[3972],{1637:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return m},toc:function(){return d},default:function(){return u}});var a=n(3117),o=n(102),s=(n(7294),n(3905)),i=n(3052),r=["components"],l={id:"selectors",title:"Selectors"},c=void 0,m={unversionedId:"walkthrough/selectors",id:"walkthrough/selectors",isDocsHomePage:!1,title:"Selectors",description:'A crucial tool in state management is the ability to "derive" or transform data. In the React world, we call such state transformers "selectors". Zedux has a few different flavors of selectors.',source:"@site/docs/walkthrough/selectors.mdx",sourceDirName:"walkthrough",slug:"/walkthrough/selectors",permalink:"/zedux/docs/walkthrough/selectors",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/walkthrough/selectors.mdx",tags:[],version:"current",frontMatter:{id:"selectors",title:"Selectors"},sidebar:"react",previous:{title:"Dependency Injection",permalink:"/zedux/docs/walkthrough/dependency-injection"},next:{title:"Stores",permalink:"/zedux/docs/walkthrough/stores"}},d=[{value:"The Contenders",id:"the-contenders",children:[{value:"Hooks/Injectors",id:"hooksinjectors",children:[],level:3},{value:"Basic Selectors",id:"basic-selectors",children:[],level:3},{value:"AtomSelectors",id:"atomselectors",children:[],level:3},{value:"Ions",id:"ions",children:[],level:3}],level:2},{value:"Controlling Renders",id:"controlling-renders",children:[],level:2},{value:"Memoization",id:"memoization",children:[],level:2},{value:"Transforming Data",id:"transforming-data",children:[{value:"Choosing an Approach",id:"choosing-an-approach",children:[],level:3}],level:2},{value:"Dynamic Subscriptions",id:"dynamic-subscriptions",children:[],level:2},{value:"Using AtomSelectors",id:"using-atomselectors",children:[{value:"Limiting Runs",id:"limiting-runs",children:[],level:3},{value:"Configuring",id:"configuring",children:[],level:3},{value:"Passing Arguments",id:"passing-arguments",children:[],level:3},{value:"Configuring AtomSelectors",id:"configuring-atomselectors",children:[],level:3}],level:2},{value:"<code>select</code>",id:"select",children:[{value:"Dynamic Injection",id:"dynamic-injection",children:[],level:3},{value:"AtomSelector Composition",id:"atomselector-composition",children:[],level:3}],level:2},{value:"Static Selection",id:"static-selection",children:[],level:2},{value:"Recap",id:"recap",children:[],level:2},{value:"Next Steps",id:"next-steps",children:[],level:2}],p={toc:d};function u(e){var t=e.components,n=(0,o.Z)(e,r);return(0,s.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,'A crucial tool in state management is the ability to "derive" or transform data. In the React world, we call such state transformers "selectors". Zedux has a few different flavors of selectors.'),(0,s.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"you will learn")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"To use selectors to:"),(0,s.kt)("ul",{parentName:"div"},(0,s.kt)("li",{parentName:"ul"},"Only rerender a component when a certain field changes."),(0,s.kt)("li",{parentName:"ul"},"Avoid performing heavy calculations every render."),(0,s.kt)("li",{parentName:"ul"},"Transform data that isn't shaped well for a UI view."),(0,s.kt)("li",{parentName:"ul"},"Dynamically add and remove atom subscriptions")))),(0,s.kt)("h2",{id:"the-contenders"},"The Contenders"),(0,s.kt)("p",null,"We'll use these tools for different selection tasks:"),(0,s.kt)("h3",{id:"hooksinjectors"},"Hooks/",(0,s.kt)("a",{parentName:"h3",href:"../api/glossary#injector"},"Injectors")),(0,s.kt)("p",null,"Sometimes reusable selection logic can be extracted into a custom hook or injector."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { atom, injectAtomValue } from '@zedux/react'\n\nconst injectUserId = () => {\n  const user = injectAtomValue(userAtom)\n\n  return user.id\n}\n\nconst exampleAtom = atom('example', () => {\n  const userId = injectUserId()\n})\n")),(0,s.kt)("h3",{id:"basic-selectors"},"Basic Selectors"),(0,s.kt)("p",null,"These selectors take the state of a single atom instance and return some derivation of it."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import { atom, useAtomSelector } from '@zedux/react'\n\nconst helloAtom = atom('hello', { boring: 'world', exciting: 'World!' })\n\nfunction Greeting() {\n  // this component will only rerender when helloAtom's `exciting` field changes\n  const val = useAtomSelector(helloAtom, state => state.exciting)\n\n  return <div>Hello, {val}</div>\n}\n")),(0,s.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"We may remove basic selectors in a future release since AtomSelectors cover all their use cases without adding any complexity or overhead. A lot of Zedux code can be simplified too if we just stick to AtomSelectors. Try to use AtomSelectors wherever possible."))),(0,s.kt)("h3",{id:"atomselectors"},(0,s.kt)("a",{parentName:"h3",href:"../api/types/AtomSelector"},"AtomSelectors")),(0,s.kt)("p",null,"AtomSelectors are an extremely flexible selection tool. They're useful to encapsulate and share logic for basic, inexpensive state derivations."),(0,s.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"Use an AtomSelector instead of a basic selector when you:"),(0,s.kt)("ul",{parentName:"div"},(0,s.kt)("li",{parentName:"ul"},"Need state from multiple atoms"),(0,s.kt)("li",{parentName:"ul"},"Want to compose other selectors"),(0,s.kt)("li",{parentName:"ul"},"Want to reuse logic")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { AtomGetters } from '@zedux/react' // for TS users\n\nconst getUserId = ({ get }: AtomGetters) => get(userAtom).id\n\nfunction MyComponent() {\n  const userId = useAtomSelector(getUserId)\n}\n")),(0,s.kt)("h3",{id:"ions"},(0,s.kt)("a",{parentName:"h3",href:"../api/classes/Ion"},"Ions")),(0,s.kt)("p",null,"Ions handle everything else. They're a special type of atom designed for selection operations. Since they're atoms, they have all the power of injectors at their disposal. They can do all the heavy lifting AtomSelectors can't."),(0,s.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"Use an ion instead of an AtomSelector when you:"),(0,s.kt)("ul",{parentName:"div"},(0,s.kt)("li",{parentName:"ul"},"Need to memoize a value, e.g. to prevent an expensive calculation from running multiple times unnecessarily"),(0,s.kt)("li",{parentName:"ul"},"Need to run a side effect on state change"),(0,s.kt)("li",{parentName:"ul"},"Need to trigger React suspense while some state isn't ready")))),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { injectMemo, ion } from '@zedux/react'\n\nconst userIdIon = ion('userId', ({ get }) => get(userAtom).id)\n\nfunction MyComponent() {\n  const userId = useAtomValue(userIdIon)\n}\n")),(0,s.kt)("h2",{id:"controlling-renders"},"Controlling Renders"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"useAtomValue")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"useAtomState")," make the component rerender every time the resolved atom instance updates."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { atom, useAtomValue } from '@zedux/react'\n\nconst objectAtom = atom('object', { a: 1, b: 2 })\n\nfunction MyComponent() {\n  // this component will rerender every time a or b change\n  // but we only care about a! :(\n  const { a } = useAtomValue(objectAtom)\n}\n")),(0,s.kt)("p",null,"This is usually fine, but sometimes this can cause lots of unnecessary renders."),(0,s.kt)("p",null,"A basic selector is perfect here:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// highlight-next-line\nimport { atom, useAtomSelector } from '@zedux/react'\n\nconst objectAtom = atom('object', { a: 1, b: 2 })\n\nfunction MyComponent() {\n  // now this component only rerenders when `a` changes :)\n  // highlight-next-line\n  const a = useAtomSelector(objectAtom, state => state.a)\n}\n")),(0,s.kt)("p",null,"We could also use an AtomSelector:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { atom, useAtomSelector } from '@zedux/react'\n\nconst objectAtom = atom('object', { a: 1, b: 2 })\n\nfunction MyComponent() {\n  // now this component only rerenders when `a` changes :)\n  // highlight-next-line\n  const a = useAtomSelector(({ get }) => get(objectAtom).a)\n}\n")),(0,s.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"All of this applies in atoms too! Use ",(0,s.kt)("inlineCode",{parentName:"p"},"injectAtomSelector")," with a basic selector or AtomSelector to prevent an atom from reevaluating unnecessarily."))),(0,s.kt)("h2",{id:"memoization"},"Memoization"),(0,s.kt)("p",null,"Say we have a piece of data that is expensive to calculate"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const expensiveState = threadHogger(someState)\n")),(0,s.kt)("p",null,"We know that throwing this line in a React component would cause the expensive ",(0,s.kt)("inlineCode",{parentName:"p"},"threadHogger")," function to run every time that component renders. ",(0,s.kt)("inlineCode",{parentName:"p"},"useMemo")," only gets us so far:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"function MyComponent() {\n  const someState = useAtomValue(someAtom)\n  const expensiveState = useMemo(() => threadHogger(someState), [someState])\n}\n")),(0,s.kt)("p",null,"Now ",(0,s.kt)("inlineCode",{parentName:"p"},"threadHogger")," could still run many times if we render several ",(0,s.kt)("inlineCode",{parentName:"p"},"MyComponent"),"s on the page. Basic selectors and AtomSelectors don't help us here - their memoization capabilites are limited to the current component. We need a way to globally memoize this value."),(0,s.kt)("p",null,'This is where atoms excel, since atom instances are cached "globally" in their ecosystem. Using ',(0,s.kt)("a",{parentName:"p",href:"../api/injectors/injectMemo"},(0,s.kt)("inlineCode",{parentName:"a"},"injectMemo"))," in an ion gives us maximum selection and caching powers here:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { injectMemo, ion, useAtomValue } from '@zedux/react'\n\nconst expensiveAtom = ion('expensive', ({ get }) => {\n  const someState = get(someAtom)\n\n  return injectMemo(() => threadHogger(someState), [someState])\n})\n\nfunction MyComponent() {\n  const expensiveState = useAtomValue(expensiveAtom)\n}\n")),(0,s.kt)("p",null,"An ",(0,s.kt)("inlineCode",{parentName:"p"},"expensiveAtom")," instance is created the first time it's used, then cached forever in the current ecosystem."),(0,s.kt)("p",null,"You may have noticed that the ",(0,s.kt)("inlineCode",{parentName:"p"},"injectMemo")," in the above example is redundant. Since ",(0,s.kt)("inlineCode",{parentName:"p"},"expensiveAtom")," has only one dependency, it will only reevaluate when ",(0,s.kt)("inlineCode",{parentName:"p"},"someAtom"),"'s value changes. And since we pass that value straight to ",(0,s.kt)("inlineCode",{parentName:"p"},"injectMemo"),"'s deps array, we're effectively running ",(0,s.kt)("inlineCode",{parentName:"p"},"threadHogger")," every single time this atom evaluates anyway. Let's do away with it:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// highlight-next-line\nimport { ion, useAtomValue } from '@zedux/react'\n\n// highlight-next-line\nconst expensiveAtom = ion('expensive', ({ get }) => threadHogger(get(someAtom)))\n\nfunction MyComponent() {\n  const expensiveState = useAtomValue(expensiveAtom)\n}\n")),(0,s.kt)("p",null,"Ain't that succinct \ud83e\udd2f"),(0,s.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"You have much more control over Zedux atom reevaluations than you do over React component rerenders. Use this power to simplify things!"))),(0,s.kt)("h2",{id:"transforming-data"},"Transforming Data"),(0,s.kt)("p",null,"We have some pretty little normalized data:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const usersAtom = atom('users', {\n  1234: { name: 'Joe', status: 'online' },\n  2341: { name: 'Sally', status: 'online' },\n  3412: { name: 'Terrence', status: 'offline' },\n  4123: { name: 'Casey', status: 'online' },\n})\n")),(0,s.kt)("p",null,"But we need to show this list in a table sorted by name. With what we've covered so far, we know the sort could happen:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"In a React component (possibly with useMemo and/or via a custom hook)"),(0,s.kt)("li",{parentName:"ul"},"In a basic selector or AtomSelector"),(0,s.kt)("li",{parentName:"ul"},"In an ion")),(0,s.kt)("p",null,"There's no clear-cut answer here! Doing the logic in a component may be good enough. It depends."),(0,s.kt)("h3",{id:"choosing-an-approach"},"Choosing an Approach"),(0,s.kt)("p",null,'Sometimes there isn\'t a perfect "right" answer. But asking yourself these questions can help determine which selection style to use:'),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"How big can the state get?"),(0,s.kt)("li",{parentName:"ul"},"How many components will use this derived state?"),(0,s.kt)("li",{parentName:"ul"},"How frequently will this calculation happen?")),(0,s.kt)("p",null,"If the state is big, calculations are otherwise heavy, or the need is ubiquitous, consider using an ion (or any atom). If the state is small, calculations are light, and it's only needed in one place, logic in a React component is fine. If it's somewhere in the middle, consider AtomSelectors."),(0,s.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"Don't worry too much about this. All selection patterns are okay for most situations. And if you do pick a \"wrong\" one, it's usually easy to refactor later if needed."))),(0,s.kt)("h2",{id:"dynamic-subscriptions"},"Dynamic Subscriptions"),(0,s.kt)("p",null,"The main reason AtomSelectors were added to Zedux is to provide an easy way to dynamically add and remove graph edges in React components. We already have this capability in atoms thanks to ",(0,s.kt)("a",{parentName:"p",href:"../api/types/AtomGetters#get"},(0,s.kt)("inlineCode",{parentName:"a"},"get")),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const dynamicIon = ion('dynamic', ({ get }) => {\n  const shouldUse1 = get(someAtom)\n  const val = shouldUse1 ? get(atom1) : get(atom2)\n})\n")),(0,s.kt)("p",null,"The above ion will register a graph edge on ",(0,s.kt)("inlineCode",{parentName:"p"},"atom1")," as long as ",(0,s.kt)("inlineCode",{parentName:"p"},"shouldUse1")," is truthy. If the ion reevaluates and ",(0,s.kt)("inlineCode",{parentName:"p"},"shouldUse1")," is falsy, Zedux will unregister the graph dependency on ",(0,s.kt)("inlineCode",{parentName:"p"},"atom1")," and create a new one on ",(0,s.kt)("inlineCode",{parentName:"p"},"atom2"),"."),(0,s.kt)("p",null,"React components don't have this capability! This is where AtomSelectors come in:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"function MyComponent() {\n  const [shouldUse1, setShouldUse1] = useState(true)\n\n  const val = useAtomSelector(({ get }) => {\n    return shouldUse1 ? get(atom1) : get(atom2)\n  })\n}\n")),(0,s.kt)("p",null,"Thanks to some ",(0,s.kt)("a",{parentName:"p",href:"../api/hooks/useAtomSelector"},(0,s.kt)("inlineCode",{parentName:"a"},"useAtomSelector()"))," magic, AtomSelectors give components the same dynamic capabilities as atoms!"),(0,s.kt)("h2",{id:"using-atomselectors"},"Using AtomSelectors"),(0,s.kt)("p",null,"AtomSelectors have some special superpowers that let you control how often they run and whether they trigger rerenders"),(0,s.kt)("h3",{id:"limiting-runs"},"Limiting Runs"),(0,s.kt)("p",null,"Zedux runs AtomSelectors every time its reference changes on a subsequent render or evaluation. Consider this code:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"function MyComponent() {\n  const [shouldUse1, setShouldUse1] = useState(true)\n\n  const val = useAtomSelector(({ get }) => {\n    return shouldUse1 ? get(atom1) : get(atom2)\n  })\n}\n")),(0,s.kt)("p",null,"Here we declared an AtomSelector inline. The function gets recreated every time ",(0,s.kt)("inlineCode",{parentName:"p"},"MyComponent")," renders. Since the reference changes, Zedux thinks the new AtomSelector is different. ",(0,s.kt)("strong",{parentName:"p"},"Zedux will run this AtomSelector every time ",(0,s.kt)("inlineCode",{parentName:"strong"},"MyComponent")," renders.")),(0,s.kt)("p",null,"This is usually fine. But we can optimize this. To make Zedux only run the AtomSelector once, we could move it outside the component:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// highlight-start\nconst getOneOrTwo = ({ get }) => {\n  return shouldUse1 ? get(atom1) : get(atom2)\n}\n// highlight-end\n\nfunction MyComponent() {\n  const [shouldUse1, setShouldUse1] = useState(true)\n\n  // highlight-next-line\n  const val = useAtomSelector(getOneOrTwo)\n}\n")),(0,s.kt)("p",null,"Sometimes this works beautifully, but in this case, our selector needs access to the ",(0,s.kt)("inlineCode",{parentName:"p"},"shouldUse1")," state. We therefore ",(0,s.kt)("em",{parentName:"p"},"do")," want the AtomSelector to re-run sometimes, but only when ",(0,s.kt)("inlineCode",{parentName:"p"},"shouldUse1")," changes."),(0,s.kt)("p",null,"We can memoize the AtomSelector in this component with ",(0,s.kt)("inlineCode",{parentName:"p"},"useCallback"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"function MyComponent() {\n  const [shouldUse1, setShouldUse1] = useState(true)\n\n  // highlight-start\n  const getOneOrTwo = useCallback(\n    ({ get }) => {\n      return shouldUse1 ? get(atom1) : get(atom2)\n    },\n    [shouldUse1]\n  )\n  // highlight-end\n\n  // highlight-next-line\n  const val = useAtomSelector(getOneOrTwo)\n}\n")),(0,s.kt)("p",null,"Now our AtomSelector will only run exactly as often as it needs to."),(0,s.kt)("h3",{id:"configuring"},"Configuring"),(0,s.kt)("p",null,"We can also use special ",(0,s.kt)("a",{parentName:"p",href:"../api/types/AtomSelector#atomselectorconfig"},"AtomSelectorConfig"),' objects to control when Zedux reruns an AtomSelector and whether the new result has "changed" and should cause a rerender.'),(0,s.kt)("p",null,"Everywhere Zedux accepts an AtomSelector, it also accepts an AtomSelectorConfig object."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// this selector will only rerun when the `userId` we pass it changes - even\n// though the selector reference changes. And it will only cause this component\n// to rerender when the returned user's `name` is different.\nconst { name } = useAtomSelector(\n  {\n    argsAreEqual: ([newId], [oldId]) => newId === oldId,\n    resultsAreEqual: (newUser, oldUser) => newUser.name === oldUser.name,\n    selector: ({ get }, id: string) => get(usersAtom)[id],\n  },\n  userId\n)\n")),(0,s.kt)("h3",{id:"passing-arguments"},"Passing Arguments"),(0,s.kt)("p",null,"AtomSelectors take the AtomGetters object as their first argument, but they can also take any number of additional arguments. These can be passed as the rest params of ",(0,s.kt)("inlineCode",{parentName:"p"},"useAtomSelector"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"injectAtomSelector"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"ecosystem.select"),", and ",(0,s.kt)("inlineCode",{parentName:"p"},"select"),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// with this AtomSelector:\nconst getUser = ({ select }: AtomGetters, id: string) =>\n  select(getUsersById)[id]\n\n// we can pass the `id` param via:\nuseAtomSelector(getUser, id) // in components\ninjectAtomSelector(getUser, id) // in atoms\necosystem.select(getUser, id) // anywhere\nselect(getUser, id) // in ions or other AtomSelectors\n")),(0,s.kt)("h3",{id:"configuring-atomselectors"},"Configuring AtomSelectors"),(0,s.kt)("h2",{id:"select"},(0,s.kt)("inlineCode",{parentName:"h2"},"select")),(0,s.kt)("p",null,"The special ",(0,s.kt)("inlineCode",{parentName:"p"},"select")," function is one of the ",(0,s.kt)("a",{parentName:"p",href:"../api/types/AtomGetters"},"AtomGetters")," passed to AtomSelectors and ions. This function is the most dynamic way to run AtomSelectors."),(0,s.kt)("h3",{id:"dynamic-injection"},"Dynamic Injection"),(0,s.kt)("p",null,"Like the other AtomGetters, ",(0,s.kt)("inlineCode",{parentName:"p"},"select")," dynamically registers dependencies synchronously during atom evaluation."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const myAtom = ion('my', ({ select }) => {\n  // registers a dependency on atom1 that only reevaluates this ion when\n  // `someField` changes:\n  const dynamicVal = select(({ get }) => get(atom1).someField)\n\n  injectEffect(() => {\n    // doesn't register any dependencies:\n    const staticVal = select(({ get }) => get(atom2))\n  }, [])\n})\n")),(0,s.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},"As an AtomGetter, ",(0,s.kt)("inlineCode",{parentName:"p"},"select")," can be used in if statements and loops to conditionally register dependencies."))),(0,s.kt)("h3",{id:"atomselector-composition"},"AtomSelector Composition"),(0,s.kt)("p",null,(0,s.kt)("inlineCode",{parentName:"p"},"select")," is the key to composing AtomSelectors."),(0,s.kt)(i.u,{resultVar:"Username",mdxType:"LiveEditor"},"\nconst usersAtom = atom('users', [\n  { id: 1, name: 'Joe' },\n  { id: 2, name: 'Jill' },\n  { id: 3, name: 'Jim' },\n])\n\nconst currentUserIdAtom = atom('currentUserId', 2)\n\nconst getUsersById = ({ get }: AtomGetters) =>\n  get(usersAtom).reduce((map, user) => ({ ...map, [user.id]: user }), {})\n\nconst getUser = ({ select }: AtomGetters, id: string) =>\n  select(getUsersById)[id]\n\n// Hi! just commenting here to break up the monotony. Have a great day!\nconst getCurrentUser = ({ get, select }: AtomGetters) =>\n  select(getUser, get(currentUserIdAtom))\n\nconst getCurrentUserName = ({ select }: AtomGetters) =>\n  select(getCurrentUser)?.name\n\nfunction Username() {\n  const currentUserName = useAtomSelector(getCurrentUserName)\n\n  return <div>Hello, {currentUserName}</div>\n}\n"),(0,s.kt)("h2",{id:"static-selection"},"Static Selection"),(0,s.kt)("p",null,"AtomSelectors have a special superpower: They can be analyzed statically outside React (i.e. anywhere). Simply pass an AtomSelector to ",(0,s.kt)("a",{parentName:"p",href:"../api/classes/Ecosystem#select"},(0,s.kt)("inlineCode",{parentName:"a"},"ecosystem.select()")),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// run myAtomSelector outside React or atoms or anything:\nconst val = ecosystem.select(myAtomSelector)\n")),(0,s.kt)("p",null,"You can use this to purposefully prevent dependencies from being registered:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"// toggling this atom's value changes maybeDynamicAtom's dynamicity\nconst shouldSubscribeAtom = atom('shouldSubscribe', true)\n\nconst maybeDynamicAtom = ion('maybeDynamic', ({ ecosystem, get, select }) => {\n  const shouldSubscribe = get(shouldSubscribeAtom)\n\n  const val = shouldSubscribe\n    ? select(myAtomSelector) // dynamic\n    : ecosystem.select(myAtomSelector) // static\n})\n")),(0,s.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,s.kt)("div",{parentName:"div",className:"admonition-heading"},(0,s.kt)("h5",{parentName:"div"},(0,s.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,s.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,s.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,s.kt)("div",{parentName:"div",className:"admonition-content"},(0,s.kt)("p",{parentName:"div"},(0,s.kt)("inlineCode",{parentName:"p"},"ecosystem.select()")," makes it easy to test AtomSelectors!"))),(0,s.kt)("h2",{id:"recap"},"Recap"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Put simple one-off logic in React components"),(0,s.kt)("li",{parentName:"ul"},"Use AtomSelectors to share and compose basic selection logic"),(0,s.kt)("li",{parentName:"ul"},"Use ions to memoize selection results"),(0,s.kt)("li",{parentName:"ul"},"Use ",(0,s.kt)("inlineCode",{parentName:"li"},"useAtomSelector")," with an AtomSelector to dynamically register atom subscriptions in React"),(0,s.kt)("li",{parentName:"ul"},"Memoize AtomSelectors themselves to control how often they run"),(0,s.kt)("li",{parentName:"ul"},"Compose AtomSelectors together using ",(0,s.kt)("inlineCode",{parentName:"li"},"select")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"ecosystem.select()")," is your static analysis and testing friend")),(0,s.kt)("h2",{id:"next-steps"},"Next Steps"),(0,s.kt)("p",null,"Now that we've mastered the art of the atom, it's time to step into the low-levels and learn about ",(0,s.kt)("a",{parentName:"p",href:"stores"},"stores"),"."))}u.isMDXComponent=!0}}]);