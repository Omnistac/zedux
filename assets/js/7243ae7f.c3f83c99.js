"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[8055],{4021:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return c},contentTitle:function(){return l},metadata:function(){return m},toc:function(){return p},default:function(){return d}});var a=t(3117),s=t(102),o=(t(7294),t(3905)),i=t(3052),r=["components"],c={id:"injectGetInstance",title:"injectGetInstance"},l=void 0,m={unversionedId:"api/injectors/injectGetInstance",id:"api/injectors/injectGetInstance",isDocsHomePage:!1,title:"injectGetInstance",description:"An injector that returns a getInstance function. This getInstance function returns other atom instances. It's similar to the .getInstance() method on ecosystems but it has one extra superpower:",source:"@site/docs/api/injectors/injectGetInstance.mdx",sourceDirName:"api/injectors",slug:"/api/injectors/injectGetInstance",permalink:"/zedux/docs/api/injectors/injectGetInstance",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/injectors/injectGetInstance.mdx",tags:[],version:"current",frontMatter:{id:"injectGetInstance",title:"injectGetInstance"},sidebar:"react",previous:{title:"injectGet",permalink:"/zedux/docs/api/injectors/injectGet"},next:{title:"injectInvalidate",permalink:"/zedux/docs/api/injectors/injectInvalidate"}},p=[{value:"Examples",id:"examples",children:[],level:2},{value:"Signature",id:"signature",children:[{value:"Overloads",id:"overloads",children:[],level:3},{value:"<code>atom</code>",id:"atom",children:[],level:3},{value:"<code>params</code>",id:"params",children:[],level:3},{value:"<code>instance</code>",id:"instance",children:[],level:3}],level:2}],u={toc:p};function d(e){var n=e.components,t=(0,s.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { injectGetInstance } from '@zedux/react'\n")),(0,o.kt)("p",null,"An ",(0,o.kt)("a",{parentName:"p",href:"../glossary#injector"},"injector")," that returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"getInstance")," function. This ",(0,o.kt)("inlineCode",{parentName:"p"},"getInstance")," function returns other atom instances. It's similar to ",(0,o.kt)("a",{parentName:"p",href:"../classes/Ecosystem#getinstance"},"the ",(0,o.kt)("inlineCode",{parentName:"a"},".getInstance()")," method on ecosystems")," but it has one extra superpower:"),(0,o.kt)("p",null,"When called synchronously during atom evaluation, this function will register a ",(0,o.kt)("a",{parentName:"p",href:"../glossary#static-graph-dependency"},"static graph dependency")," on the resolved atom instance. In this way, ",(0,o.kt)("inlineCode",{parentName:"p"},"getInstance")," is like ",(0,o.kt)("a",{parentName:"p",href:"injectAtomInstance"},(0,o.kt)("inlineCode",{parentName:"a"},"injectAtomInstance()")),". However, unlike ",(0,o.kt)("inlineCode",{parentName:"p"},"injectAtomInstance"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"getInstance")," is not an injector. This means it can be called in loops or if statements or even asynchronously."),(0,o.kt)("p",null,"When called asynchronously, ",(0,o.kt)("inlineCode",{parentName:"p"},"getInstance")," is really just an alias for ",(0,o.kt)("inlineCode",{parentName:"p"},"ecosystem.getInstance()"),". It doesn't register any graph dependencies; it simply returns the resolved atom instance."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"../classes/Ion"},"Ions")," use this injector internally to provide the ",(0,o.kt)("inlineCode",{parentName:"p"},"getInstance")," function as part of their ",(0,o.kt)("a",{parentName:"p",href:"../types/AtomGetters"},"AtomGetters")," and ",(0,o.kt)("a",{parentName:"p",href:"../types/AtomSetters"},"AtomSetters")," objects."),(0,o.kt)("h2",{id:"examples"},"Examples"),(0,o.kt)(i.u,{resultVar:"Seconds",mdxType:"LiveEditor"},"\nconst secondsAtom = atom('seconds', (startingNumber: number) => {\n  const store = injectStore(startingNumber)\n\n  injectEffect(() => {\n    const intervalId = setInterval(\n      () => store.setState(val => val + 1),\n      1000\n    )\n\n    return () => clearInterval(intervalId)\n  }, [])\n\n  return store\n})\n\nconst sumAtom = atom('sum', (...nums: number[]) => {\n  const getInstance = injectGetInstance()\n\n  // loops are fine!\n  return nums.reduce((sum, num) => {\n    // this is a static dependency: (won't cause reevaluations)\n    return sum + getInstance(secondsAtom, [num]).store.getState()\n  }, 0)\n})\n\nfunction Seconds() {\n  const sumInstance = useAtomInstance(sumAtom, [1, 10, 100])\n  const sum = useAtomValue(sumInstance)\n\n  return (\n    <>\n      <div>Sum of 3 counters, starting at 1, 10, and 100: {sum}</div>\n      <button onClick={sumInstance.invalidate}>Refresh</button>\n    </>\n  )\n}\n"),(0,o.kt)("p",null,"Miscellaneous:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const getInstance = injectGetInstance()\n\nconst staticInstance = getInstance(myAtom)\nconst withParams = getInstance(myAtom, ['param 1', 'param 2'])\n\n// in a loop\nfor (const id of ids) {\n  const instance = getInstance(myAtom, [id])\n}\n\n// .. any kind of loop\nconst instances = ids.map(id => getInstance(myAtom, [id]))\n\n// in control flow statements\nconst instance = useAtomA ? getInstance(atomA) : defaultInstance\n\n// asynchronously: (`getInstance` isn't technically a stable reference. But it\n// doesn't reference anything unstable, so not passing it as a dep is fine)\ninjectEffect(() => {\n  const instance = getInstance(myAtom)\n}, []) // don't have to pass `getInstance`\n\n// passing an instance (also registers a static dependency during evaluation):\nconst fromInstance = getInstance(instance)\n\n// passing an atom to `injectGetInstance()`:\nconst getMyAtomInstance = injectGetInstance(myAtom)\nconst instance = getMyAtomInstance()\nconst withParams = getMyAtomInstance(['param 1', 'param 2'])\n")),(0,o.kt)("h2",{id:"signature"},"Signature"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"injectGetInstance() => getInstance\n")),(0,o.kt)("p",null,"The returned ",(0,o.kt)("inlineCode",{parentName:"p"},"getInstance")," function's signature is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"getInstance(atom, params?) => instance\n")),(0,o.kt)("p",null,"There is an overload for passing instances:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"getInstance(instance) => instance\n")),(0,o.kt)("p",null,"This overload is mostly just for interop in cases where you have a value that may be either an atom or instance (Zedux does this internally). However, it can be useful for purposefully registering a static dependency on an instance when the instance was ",(0,o.kt)("a",{parentName:"p",href:"../classes/AtomInstance#params"},"passed via params"),"."),(0,o.kt)("h3",{id:"overloads"},"Overloads"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"injectGetInstance(atom) => getAtomInstance\n")),(0,o.kt)("p",null,"In this overload, the returned ",(0,o.kt)("inlineCode",{parentName:"p"},"getAtomInstance")," function will be scoped to the passed atom and will only return instances of that atom. Its signature is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"getAtomInstance(params?) => AtomInstance\n")),(0,o.kt)("h3",{id:"atom"},(0,o.kt)("inlineCode",{parentName:"h3"},"atom")),(0,o.kt)("p",null,"Required. An ",(0,o.kt)("a",{parentName:"p",href:"../classes/Atom"},"atom"),"."),(0,o.kt)("h3",{id:"params"},(0,o.kt)("inlineCode",{parentName:"h3"},"params")),(0,o.kt)("p",null,"Optional. An array of parameters that identify this atom instance. These params will be passed to the atom's ",(0,o.kt)("a",{parentName:"p",href:"../glossary#evaluator"},"evaluator function"),"."),(0,o.kt)("p",null,"TS users will be required to pass this for atoms that take params. If you don't use TS ... just don't forget to pass them."),(0,o.kt)("h3",{id:"instance"},(0,o.kt)("inlineCode",{parentName:"h3"},"instance")),(0,o.kt)("p",null,"Required (in this overload). An ",(0,o.kt)("a",{parentName:"p",href:"../classes/AtomInstance"},"atom instance"),". The same atom instance will be returned. When called synchronously during evaluation, this will register a static dependency on the passed atom instance (usually not necessary)."))}d.isMDXComponent=!0}}]);