"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[1483],{3975:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return u},buttonStyle:function(){return h},getStyle:function(){return m},default:function(){return k}});var a=n(3117),i=n(102),o=(n(7294),n(3905)),c=n(3052),r=["components"],s={id:"state-machines",title:"State Machines"},l=void 0,d={unversionedId:"walkthrough/state-machines",id:"walkthrough/state-machines",isDocsHomePage:!1,title:"State Machines",description:"The state machine is one of the most important tools a statesmith can have in his belt. XState is the current king of the JavaScript state machine world. Zedux is not out to change that, in fact we may build an official XState Zedux integration soon.",source:"@site/docs/walkthrough/state-machines.mdx",sourceDirName:"walkthrough",slug:"/walkthrough/state-machines",permalink:"/zedux/docs/walkthrough/state-machines",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/walkthrough/state-machines.mdx",tags:[],version:"current",frontMatter:{id:"state-machines",title:"State Machines"},sidebar:"react",previous:{title:"Side Effects",permalink:"/zedux/docs/walkthrough/side-effects"},next:{title:"Context",permalink:"/zedux/docs/walkthrough/context"}},u=[{value:"Creating a machine",id:"creating-a-machine",children:[],level:2},{value:"Using Actors",id:"using-actors",children:[],level:2},{value:"Lots of States",id:"lots-of-states",children:[],level:2},{value:"Side Effects",id:"side-effects",children:[],level:2},{value:"Contrived Example",id:"contrived-example",children:[],level:2},{value:"<code>useReducer</code>",id:"usereducer",children:[],level:2},{value:"Recap",id:"recap",children:[],level:2},{value:"Next Steps",id:"next-steps",children:[],level:2}],h={appearance:"none",border:"1px solid #ccc",cursor:"pointer",fontSize:"20px",padding:"12px"},m=function(e){switch(e){case"light":return Object.assign({},h,{background:"#f7f7f7"});case"dark":return Object.assign({},h,{background:"#333542",color:"#fff"});case"classic":return Object.assign({},h,{background:"#fed",borderRadius:"20px",fontStyle:"italic"})}},p={toc:u,buttonStyle:h,getStyle:m};function k(e){var t=e.components,n=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The state machine is one of the most important tools a statesmith can have in his belt. ",(0,o.kt)("a",{parentName:"p",href:"https://xstate.js.org/"},"XState")," is the current king of the JavaScript state machine world. Zedux is not out to change that, in fact we may build an official XState Zedux integration soon."),(0,o.kt)("p",null,"However, Zedux does provide a minimal state machine implementation out of the box. Machines are just reducers and interpreters are just stores. Zedux state machines do not cover every use case of state machines. But they should be enough for most situations."),(0,o.kt)("h2",{id:"creating-a-machine"},"Creating a machine"),(0,o.kt)("p",null,"To create a state machine, we create any number of states, tie them together in a machine, and rig up a store with that machine."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { createMachine, createState, createStore } from '@zedux/react'\n\nconst red = createState('red')\nconst yellow = createState('yellow')\nconst green = createState('green')\n\nconst lightMachine = createMachine(\n  green.on('timer', yellow),\n  yellow.on('timer', red),\n  red.on('timer', green)\n)\n\nconst store = createStore(lightMachine) // the machine is just a reducer!\n\nstore.getState() // 'green'\nstore.dispatch({ type: 'timer' }) // 'yellow'\nstore.dispatch({ type: 'timer' }) // 'red'\n")),(0,o.kt)("p",null,"The first state passed to ",(0,o.kt)("inlineCode",{parentName:"p"},"createMachine")," is the initial state of the machine."),(0,o.kt)("h2",{id:"using-actors"},"Using Actors"),(0,o.kt)("p",null,"Actors can be used directly, instead of strings. And strings can be used instead of passing state objects to ",(0,o.kt)("inlineCode",{parentName:"p"},"state.on()"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { createActor, createState, createMachine } from '@zedux/react'\n\nconst resolve = createActor('resolve')\nconst reject = createActor('reject')\n\nconst pending = createState('pending')\n\nconst promiseMachine = createMachine(\n  pending.on(resolve, 'resolved').on(reject, 'rejected')\n)\n")),(0,o.kt)("h2",{id:"lots-of-states"},"Lots of States"),(0,o.kt)("p",null,"Zedux exports a special ",(0,o.kt)("inlineCode",{parentName:"p"},"states()")," factory that can be used to create several states at once."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { createMachine, states } from '@zedux/react'\n\nconst [a, b, c, d] = states('a', 'b', 'c', 'd')\n\nconst machine = createMachine(\n  a.on('next', b),\n  b.on('next', c),\n  c.on('next', d),\n  d.on('next', a)\n)\n")),(0,o.kt)("h2",{id:"side-effects"},"Side Effects"),(0,o.kt)("p",null,"One of ",(0,o.kt)("a",{parentName:"p",href:"/not-done"},(0,o.kt)("inlineCode",{parentName:"a"},"when()")),"'s main features is registering ",(0,o.kt)("inlineCode",{parentName:"p"},"enter")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"leave")," hooks for state machines:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"when(myStore)\n  .machine(({ activeState }) => activeState) // locate state machine\n  .enters(ActiveState.Inactive, scheduleCleanup) // register onEnter hook\n  .leaves(ActiveState.Inactive, destroy) // register onLeave hook\n  .enters([stateA, stateB], doSomething) // multiple states\n")),(0,o.kt)("p",null,"If the store contains only a state machine reducer, pass nothing to ",(0,o.kt)("inlineCode",{parentName:"p"},".machine()"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const myStore = createStore(machine)\n\nwhen(myStore).machine().enters(state, invoke)\n")),(0,o.kt)("h2",{id:"contrived-example"},"Contrived Example"),(0,o.kt)(c.u,{resultVar:"Machine",mdxType:"LiveEditor"},"\nconst click = createActor('click')\nconst timerStart = createActor<ReturnType<typeof setTimeout>>('timerStart')\nconst timerEnd = createActor('timerEnd')\n\nconst [open, opening, closed, closing] = states(\n  'open',\n  'opening',\n  'closed',\n  'closing'\n)\n\nconst doorMachine = createMachine(\n  open.on(click, closing),\n  closing.on(click, opening).on(timerEnd, closed),\n  opening.on(click, closing).on(timerEnd, open),\n  closed.on(click, opening)\n)\n\nconst timeoutIdReducer = createReducer(null)\n  .reduce(timerStart, (_, timeoutId) => timeoutId)\n  .reduce(timerEnd, () => null)\n\nconst doorMachineAtom = atom('doorMachine', () => {\n  const store = injectStore(() => createStore({\n    machine: doorMachine,\n    timeoutId: timeoutIdReducer\n  }))\n\n  injectEffect(() => {\n    const { subscription } = when(store)\n      .machine(({ machine }) => machine)\n      .enters([closing, opening], ({ store }) => {\n        const timeoutId = setTimeout(() => {\n          store.dispatch(timerEnd())\n        }, 1000)\n\n        store.dispatch(timerStart(timeoutId))\n      })\n      .leaves([open, opening, closed, closing], ({ oldState }) => {\n        if (oldState.timeoutId) {\n          clearTimeout(oldState.timeoutId)\n        }\n      })\n\n    return () => subscription.unsubscribe()\n  }, [])\n\n  return store\n})\n\nfunction Machine() {\n  const state = useAtomValue(doorMachineAtom)\n  const { dispatch } = useAtomInstance(doorMachineAtom)\n\n  return (\n    <>\n      <div>State: {state.machine}</div>\n      <button onClick={() => dispatch(click())}>Fire Click</button>\n    </>\n  )\n}\n"),(0,o.kt)("h2",{id:"usereducer"},(0,o.kt)("inlineCode",{parentName:"h2"},"useReducer")),(0,o.kt)("p",null,"Since state machines are just reducers, they can be used directly in ",(0,o.kt)("inlineCode",{parentName:"p"},"useReducer()")),(0,o.kt)(c.u,{extraScope:{getStyle:m},resultVar:"Theme",mdxType:"LiveEditor"},"\nconst cycle = createActor('cycle')\nconst [light, dark, classic] = states('light', 'dark', 'classic')\n\nconst machine = createMachine(\n  light.on(cycle, dark),\n  dark.on(cycle, classic),\n  classic.on(cycle, light)\n)\n\nfunction Theme() {\n  const [theme, dispatch] = useReducer(machine, light.type)\n\n  return (\n    <button\n      onClick={() => dispatch(cycle())}\n      style={getStyle(theme)}\n    >Cycle Theme</button>\n  )\n}\n"),(0,o.kt)("h2",{id:"recap"},"Recap"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"createState()")," creates a state for a state machine."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"states()")," creates many states at once."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"createMachine()")," creates a reducer."),(0,o.kt)("li",{parentName:"ul"},"A machine reducer can be used in stores or in ",(0,o.kt)("inlineCode",{parentName:"li"},"useReducer"),"."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"when(store).machine().enters(...)")," registers an onEnter hook."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"when(store).machine().leaves(...)")," registers an onLeave hook.")),(0,o.kt)("h2",{id:"next-steps"},"Next Steps"),(0,o.kt)("p",null,"We have a solid grip on atoms and stores at this point. It's time to look at some more advanced React usage. We'll start with ",(0,o.kt)("a",{parentName:"p",href:"context"},"React context patterns"),"."))}k.isMDXComponent=!0}}]);