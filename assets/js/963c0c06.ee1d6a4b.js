"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[8839],{9674:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return m},toc:function(){return p},default:function(){return d}});var a=t(3117),o=t(102),s=(t(7294),t(3905)),r=t(3052),i=["components"],l={id:"suspense",title:"Suspense"},c=void 0,m={unversionedId:"walkthrough/suspense",id:"walkthrough/suspense",isDocsHomePage:!1,title:"Suspense",description:"Atoms are extremely flexible when working with React suspense. Suspense works by throwing a promise during render that React can catch and await.",source:"@site/docs/walkthrough/suspense.mdx",sourceDirName:"walkthrough",slug:"/walkthrough/suspense",permalink:"/zedux/docs/walkthrough/suspense",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/walkthrough/suspense.mdx",tags:[],version:"current",frontMatter:{id:"suspense",title:"Suspense"},sidebar:"react",previous:{title:"Context",permalink:"/zedux/docs/walkthrough/context"},next:{title:"Atom",permalink:"/zedux/docs/api/classes/Atom"}},p=[{value:"Setting a Promise",id:"setting-a-promise",children:[],level:2},{value:"Deferring Side Effects",id:"deferring-side-effects",children:[{value:"<code>injectAsyncEffect</code>",id:"injectasynceffect",children:[],level:3},{value:"AsyncStore",id:"asyncstore",children:[],level:3},{value:"Composing State",id:"composing-state",children:[],level:3}],level:2},{value:"Configuring Suspense",id:"configuring-suspense",children:[{value:"Forwarding Promises",id:"forwarding-promises",children:[],level:3},{value:"<code>forwardPromises</code>",id:"forwardpromises",children:[],level:3},{value:"<code>defaultForwardPromises</code>",id:"defaultforwardpromises",children:[],level:3},{value:"More Control",id:"more-control",children:[],level:3}],level:2}],u={toc:p};function d(e){var n=e.components,t=(0,o.Z)(e,i);return(0,s.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"Atoms are extremely flexible when working with React suspense. Suspense works by throwing a promise during render that React can catch and await."),(0,s.kt)("h2",{id:"setting-a-promise"},"Setting a Promise"),(0,s.kt)("p",null,"Atoms can be given a promise via an ",(0,s.kt)("a",{parentName:"p",href:"../api/classes/AtomApi"},"AtomApi"),". Simply pass the promise to ",(0,s.kt)("a",{parentName:"p",href:"../api/classes/AtomApi#setpromise"},"AtomApi's ",(0,s.kt)("inlineCode",{parentName:"a"},".setPromise()"))," and return the api from the atom evaluator function:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { api, atom } from '@zedux/react'\n\nconst fetchAtom = atom('fetch', (url: string) => {\n  const promise = fetch(url).then(result => result.json())\n\n  return api().setPromise(promise)\n})\n")),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"fetchAtom")," is used in a component, Zedux will throw the promise, allowing React to suspend. When the promise completes, React will recreate the component and Zedux will no longer throw the now-completed promise."),(0,s.kt)("p",null,"Currently promises are a one-off per atom instance. You can't set a new promise on a subsequent atom evaluation. If you do, Zedux will ignore the new promise. This is because the promise's job is really just to indicate initial loading state. To indicate more states, add state to the atom."),(0,s.kt)("p",null,"The promise can also be useful in general for indicating the loading status of the atom."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const fetchUsersInstance = myEcosystem.getInstance(fetchAtom, ['/users'])\nfetchUsersInstance.promise.then(() => {\n  // users are loaded!\n})\n")),(0,s.kt)("h2",{id:"deferring-side-effects"},"Deferring Side Effects"),(0,s.kt)("p",null,"You may have noticed in the above example we kicked off a fetch directly in the body of ",(0,s.kt)("inlineCode",{parentName:"p"},"fetchAtom"),"'s evaluator function. While this can be fine if you know what you're doing, it typically isn't good practice."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"A side effect is running immediately when the atom instance is initialized. Since atoms are often initialized during a React render, this means we're kicking off side effects during render \ud83d\ude2e. Especially when using SSR, this can be a problem.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The fetch will run every time this ",(0,s.kt)("inlineCode",{parentName:"p"},"fetchAtom")," instance is reevaluated. In Zedux, we typically do have more control over when evaluations happen than we do over rerenders in React components. But relying on this pattern still makes code more brittle. For example, it's easy for someone to add code later that causes this atom to reevaluate in new cases and voila we have a bug."))),(0,s.kt)("p",null,"We could use ",(0,s.kt)("inlineCode",{parentName:"p"},"injectMemo")," to at least prevent the fetch from running unnecessarily on reevaluations."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const promise = injectMemo(() => fetch(url), [url])\n")),(0,s.kt)("p",null,"But we still have the first problem of the side effect running immediately."),(0,s.kt)("h3",{id:"injectasynceffect"},(0,s.kt)("inlineCode",{parentName:"h3"},"injectAsyncEffect")),(0,s.kt)("p",null,"Fortunately Zedux ships with a high-level injector for creating promises whose evaluation is deferred. It works rather like ",(0,s.kt)("a",{parentName:"p",href:"../api/injectors/injectEffect"},(0,s.kt)("inlineCode",{parentName:"a"},"injectEffect()")),", but with a few differences:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"You can pass an async function (or any function that returns a promise)."),(0,s.kt)("li",{parentName:"ul"},"Rather than returning a cleanup function, cleanup functions can be passed to a received ",(0,s.kt)("inlineCode",{parentName:"li"},"cleanup")," param."),(0,s.kt)("li",{parentName:"ul"},"It returns a tuple consisting of a promise and a special ",(0,s.kt)("a",{parentName:"li",href:"../api/types/AsyncStore"},"async store"),".")),(0,s.kt)(r.u,{resultVar:"App",mdxType:"LiveEditor"},"\nconst asyncAtom = atom('async', () => {\n  const [promise, store] = injectAsyncEffect(cleanup => {\n    return new Promise(resolve => {\n      const timeoutId = setTimeout(() => {\n        resolve('\ud83c\udf89')\n      }, 2000)\n\n      cleanup(() => clearTimeout(timeoutId))\n    })\n  }, [])\n\n  return api(store).setPromise(promise)\n})\n\nfunction Child() {\n  const { data } = useAtomValue(asyncAtom)\n\n  return <div>The long-awaited value: {data}</div>\n}\n\nfunction App() {\n  const [isRunning, setIsRunning] = useState(false)\n\n  return (\n    <Suspense fallback={<div>Falling Back (stuff is loading)</div>}>\n      {isRunning ? (\n        <Child />\n      ) : (\n        <button onClick={() => setIsRunning(true)}>Run</button>\n      )}\n    </Suspense>\n  )\n}\n"),(0,s.kt)("p",null,"The promise returned from ",(0,s.kt)("inlineCode",{parentName:"p"},"injectAsyncEffect")," can be passed directly to ",(0,s.kt)("inlineCode",{parentName:"p"},"api.setPromise()"),"."),(0,s.kt)("h3",{id:"asyncstore"},"AsyncStore"),(0,s.kt)("p",null,"The ",(0,s.kt)("a",{parentName:"p",href:"../api/types/AsyncStore"},"async store")," is a special store that holds a state machine representing an async flow and the resulting ",(0,s.kt)("inlineCode",{parentName:"p"},"data")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"error"),". It's patterned after the object returned from ",(0,s.kt)("a",{parentName:"p",href:"https://react-query.tanstack.com/reference/useQuery"},"React Query's ",(0,s.kt)("inlineCode",{parentName:"a"},"useQuery")),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const [promise, store] = injectAsyncEffect(...)\n\nconst {\n  data,\n  error,\n  isError,\n  isIdle,\n  isLoading,\n  isSuccess,\n  status\n} = store.getState()\n")),(0,s.kt)("p",null,"In components that you don't want to suspend, these flags can be used to implement old-school loading flows:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"function UserList() {\n  const { data, isLoading, isSuccess } = useAtomValue(fetchUsersAtom)\n\n  if (isLoading) return <div>Loading...</div>\n\n  if (isSuccess) return data.map(user => <User id={user.id} />)\n}\n")),(0,s.kt)("h3",{id:"composing-state"},"Composing State"),(0,s.kt)("p",null,"The async store returned from ",(0,s.kt)("inlineCode",{parentName:"p"},"injectAsyncEffect")," can be composed with any other state in a parent store."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const composedAtom = atom('composed', () => {\n  const otherStore = injectStore('some state')\n  const [, asyncStore] = injectAsyncEffect(myEffect, [])\n\n  return injectStore(() =>\n    createStore({ other: otherStore, request: asyncStore })\n  )\n})\n\n// then in SomeComponent:\nconst {\n  other,\n  request: { isLoading },\n} = useAtomValue(composedAtom)\n")),(0,s.kt)("h2",{id:"configuring-suspense"},"Configuring Suspense"),(0,s.kt)("p",null,"There aren't currently any flags to turn suspense on or off. It's always on by default. To turn it off, just don't ",(0,s.kt)("inlineCode",{parentName:"p"},"setPromise")," \ud83d\ude43. We may add ecosystem- and hook/injector-level options to configure this in the future. Feel free to open an issue if you need this functionality (or PR it!)."),(0,s.kt)("h3",{id:"forwarding-promises"},"Forwarding Promises"),(0,s.kt)("p",null,"The atom dependency graph can get very big. Say we have a setup where atom ",(0,s.kt)("inlineCode",{parentName:"p"},"a")," injects atom ",(0,s.kt)("inlineCode",{parentName:"p"},"b")," which injects atom ",(0,s.kt)("inlineCode",{parentName:"p"},"c"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"a -> b -> c\n")),(0,s.kt)("p",null,"Atoms ",(0,s.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"b")," don't set promises, but atom ",(0,s.kt)("inlineCode",{parentName:"p"},"c")," does. Now say we use atom ",(0,s.kt)("inlineCode",{parentName:"p"},"a")," in a component. Since we didn't set a promise in atom ",(0,s.kt)("inlineCode",{parentName:"p"},"a")," itself, React won't suspend. Atom ",(0,s.kt)("inlineCode",{parentName:"p"},"c"),"'s promise will be ignored!"),(0,s.kt)("p",null,"Zedux is designed to be flexible in handling this situation. We can forward the promise manually:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const atomC = atom('c', () => {\n  return api().setPromise(myPromise)\n})\n\nconst atomB = atom('b', () => {\n  const c = injectAtomInstance(atomC)\n\n  return api().setPromise(c.promise)\n})\n\nconst atomA = atom('a', () => {\n  const b = injectAtomInstance(atomB)\n\n  return api().setPromise(b.promise)\n})\n")),(0,s.kt)("p",null,"But this is obviously very tedious and error-prone. Fortunately, atoms can be given an option to automatically forward their dependencies' promises."),(0,s.kt)("h3",{id:"forwardpromises"},(0,s.kt)("inlineCode",{parentName:"h3"},"forwardPromises")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const atomB = atom(\n  'b',\n  () => {\n    injectAtomInstance(atomC) // just create a dependency\n  },\n  {\n    forwardPromises: true,\n  }\n)\n\nconst atomA = atom(\n  'a',\n  () => {\n    injectAtomInstance(atomB) // just create a dependency\n  },\n  {\n    forwardPromises: true,\n  }\n)\n")),(0,s.kt)("p",null,"When ",(0,s.kt)("inlineCode",{parentName:"p"},"forwardPromises")," is true, Zedux will automatically find all the promises of all initial dependencies, ",(0,s.kt)("inlineCode",{parentName:"p"},"Promise.all()")," them, and set that as the atom instance's ",(0,s.kt)("a",{parentName:"p",href:"../api/classes/AtomInstance#promise"},(0,s.kt)("inlineCode",{parentName:"a"},"promise")),"."),(0,s.kt)("p",null,"Setting a promise in the atom will override this option:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const atomA = atom(\n  'a',\n  (doTheThing: boolean) => {\n    injectAtomInstance(atomB)\n\n    return doTheThing ? api(myValue).setPromise(myPromise) : myValue\n  },\n  {\n    forwardPromises: true, // ignored when `doTheThing` param is true\n  }\n)\n")),(0,s.kt)("h3",{id:"defaultforwardpromises"},(0,s.kt)("inlineCode",{parentName:"h3"},"defaultForwardPromises")),(0,s.kt)("p",null,"Setting the ",(0,s.kt)("inlineCode",{parentName:"p"},"forwardPromises")," option manually on lots of atoms can also be tedious. Sometimes that's fine. But this option can also be configured at the ",(0,s.kt)("a",{parentName:"p",href:"../api/classes/Ecosystem#defaultforwardpromises"},"ecosystem level"),"."),(0,s.kt)("p",null,"We do this by setting ",(0,s.kt)("inlineCode",{parentName:"p"},"defaultForwardPromises"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-tsx"},"import { EcosystemProvider } from '@zedux/react'\n\nfunction App() {\n  return (\n    <EcosystemProvider defaultForwardPromises id=\"root\">\n      <Routes />\n    </EcosystemProvider>\n  )\n}\n")),(0,s.kt)("p",null,"With this set, our ",(0,s.kt)("inlineCode",{parentName:"p"},"a")," atom will cause React to suspend by default, with no manual forwarding or nuthin'."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"const atomC = atom('c', () => {\n  return api().setPromise(myPromise)\n})\n\nconst atomB = atom('b', () => {\n  injectAtomInstance(atomC) // just create the dependency\n})\n\nconst atomA = atom('a', () => {\n  injectAtomInstance(atomB) // just create the dependency\n})\n\nfunction SuspendingComponent() {\n  const a = useAtomValue(atomA)\n}\n")),(0,s.kt)("h3",{id:"more-control"},"More Control"),(0,s.kt)("p",null,"Sometimes manually forwarding promises is okay! It gives you full flexibility over the async flow. You can use ",(0,s.kt)("inlineCode",{parentName:"p"},"Promise.all()")," yourself. Or use a ",(0,s.kt)("inlineCode",{parentName:"p"},"Promise.race()")," or any helper or library for handling parallelization or serialization of promises - you can even use RxJS."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ts"},"import { from } from 'rxjs'\n\nconst rxAtom = atom('rx', () => {\n  const asyncInstance = injectAtomInstance(myAsyncAtom)\n\n  const [promise, store] = injectAsyncEffect(\n    cleanup => {\n      const subscription = from(asyncInstance.promise)\n        .pipe(doCrazyRxStuff)\n        .subscribe(val => console.log('val:', val))\n\n      cleanup(() => subscription.unsubscribe())\n    },\n    [asyncInstance]\n  )\n\n  return api(store).setPromise(promise)\n})\n")))}d.isMDXComponent=!0}}]);