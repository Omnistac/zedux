"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[7001],{705:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return d},default:function(){return u}});var a=n(3117),s=n(102),o=(n(7294),n(3905)),i=["components"],r={id:"metaTypes",title:"metaTypes"},c=void 0,l={unversionedId:"api/constants/metaTypes",id:"api/constants/metaTypes",isDocsHomePage:!1,title:"metaTypes",description:'An object of the "metaType" values Zedux uses internally in its ActionChain objects. You may encounter these meta nodes in action chains passed to effects subscribers in composed stores. Use this object to identify them.',source:"@site/docs/api/constants/metaTypes.mdx",sourceDirName:"api/constants",slug:"/api/constants/metaTypes",permalink:"/zedux/docs/api/constants/metaTypes",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/constants/metaTypes.mdx",tags:[],version:"current",frontMatter:{id:"metaTypes",title:"metaTypes"},sidebar:"react",previous:{title:"AtomInstanceProvider",permalink:"/zedux/docs/api/components/AtomInstanceProvider"},next:{title:"zeduxGlobalStore",permalink:"/zedux/docs/api/constants/zeduxGlobalStore"}},d=[{value:"Definition",id:"definition",children:[{value:"<code>DELEGATE</code>",id:"delegate",children:[],level:3},{value:"<code>INHERIT</code>",id:"inherit",children:[],level:3},{value:"<code>SKIP_EVALUATION</code>",id:"skip_evaluation",children:[],level:3}],level:2},{value:"Removing Meta Nodes",id:"removing-meta-nodes",children:[],level:2}],p={toc:d};function u(e){var t=e.components,n=(0,s.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { metaTypes } from '@zedux/react'\n")),(0,o.kt)("p",null,'An object of the "metaType" values Zedux uses internally in its ',(0,o.kt)("a",{parentName:"p",href:"../types/ActionChain"},"ActionChain objects"),". You may encounter these meta nodes in action chains passed to ",(0,o.kt)("a",{parentName:"p",href:"../classes/Store#subscribe"},"effects subscribers")," in composed stores. Use this object to identify them."),(0,o.kt)("h2",{id:"definition"},"Definition"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const metaTypes = {\n  DELEGATE: '@@zedux/delegate',\n  INHERIT: '@@zedux/inherit',\n  SKIP_EVALUATION: '@@zedux/skipEvaluation',\n}\n")),(0,o.kt)("h3",{id:"delegate"},(0,o.kt)("inlineCode",{parentName:"h3"},"DELEGATE")),(0,o.kt)("p",null,"Zedux attaches this meta node to actions when a child store informs a parent store of a state change."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const childStore = createStore(null, 'initial state')\nconst parentStore = createStore({ child: childStore })\n\nparentStore.subscribe({\n  effects: ({ action }) => {\n    console.log('action:', action)\n  }\n})\n\nchildStore.setState('new state')\n// action: {\n//   metaType: '@@zedux/delegate',\n//   metaData: ['child'],\n//   payload: {\n//     type: '@@zedux/hydrate',\n//     payload: 'new state'\n//   }\n// }\n\nchildStore.getState() // 'new state'\nparentStore.getState() // { child: 'new state' }\n")),(0,o.kt)("p",null,"Dispatching an action wrapped in ",(0,o.kt)("inlineCode",{parentName:"p"},"DELEGATE"),' to a parent store tells Zedux to "delegate" the action to the child store. This is the key to time travel! By tracking all actions dispatched to child stores, a parent store can effectively reverse engineer all of its state changes.'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"// this action mimics a `.setState('different state')` call in the child store:\nconst action = {\n  metaType: '@@zedux/delegate',\n  metaData: ['child'],\n  payload: {\n    type: '@@zedux/hydrate',\n    payload: 'different state'\n  }\n}\n\nparentStore.dispatch(action)\n\nchildStore.getState() // 'different state'\nparentStore.getState() // { child: 'different state' }\n")),(0,o.kt)("h3",{id:"inherit"},(0,o.kt)("inlineCode",{parentName:"h3"},"INHERIT")),(0,o.kt)("p",null,"Zedux wraps actions in this meta node when passing an action dispatched in a parent store down to its children."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const childStore = createStore(null, 'initial state')\nconst parentStore = createStore({ child: childStore })\n\nchildStore.subscribe({\n  effects: ({ action }) => {\n    console.log('action:', action)\n  }\n})\n\nparentStore.dispatch({ type: 'test' })\n// action: {\n//   metaType: '@@zedux/inherit',\n//   payload: {\n//     type: 'test'\n//   }\n// }\n")),(0,o.kt)("h3",{id:"skip_evaluation"},(0,o.kt)("inlineCode",{parentName:"h3"},"SKIP_EVALUATION")),(0,o.kt)("p",null,"For use with stores that belong to atom instances. Set this string to an action's ",(0,o.kt)("inlineCode",{parentName:"p"},"meta")," property to tell Zedux not to reevaluate the atom instance:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"store.dispatch({ type: 'my-action-type', meta: metaTypes.SKIP_EVALUATION })\n")),(0,o.kt)("p",null,"This meta property can also be set when calling ",(0,o.kt)("a",{parentName:"p",href:"../classes/AtomInstance#setstate"},(0,o.kt)("inlineCode",{parentName:"a"},"instance.setState()"))," or ",(0,o.kt)("a",{parentName:"p",href:"../classes/Store#setstate"},(0,o.kt)("inlineCode",{parentName:"a"},"store.setState()"))," by passing it as the second parameter:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"store.setState(newState, metaTypes.SKIP_EVALUATION)\n")),(0,o.kt)("p",null,"It is not necessary to use this when updating an injected store's state synchronously during atom evaluation. Zedux always prevents these cases from causing a reevaluation, as that would lead to an evaluation loop."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const testAtom = atom('test', () => {\n  const store = injectStore(initialState, true) // true to subscribe\n\n  store.setState(newState) // won't cause an evaluation loop\n})\n")),(0,o.kt)("h2",{id:"removing-meta-nodes"},"Removing Meta Nodes"),(0,o.kt)("p",null,"Sometimes we don't care about this metadata. Zedux exports a ",(0,o.kt)("inlineCode",{parentName:"p"},"removeAllMeta")," function that unwraps all meta nodes around an action object."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"import { removeAllMeta } from '@zedux/react'\n\nconst unwrappedAction = removeAllMeta(inheritedAction) // { type: 'test' }\n")))}u.isMDXComponent=!0}}]);