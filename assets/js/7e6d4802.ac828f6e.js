"use strict";(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[9259],{8164:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return n},contentTitle:function(){return p},metadata:function(){return l},toc:function(){return c},default:function(){return d}});var r=a(3117),o=a(102),i=(a(7294),a(3905)),s=["components"],n={id:"api",title:"api"},p=void 0,l={unversionedId:"api/factories/api",id:"api/factories/api",isDocsHomePage:!1,title:"api",description:"A factory for creating AtomApis.",source:"@site/docs/api/factories/api.mdx",sourceDirName:"api/factories",slug:"/api/factories/api",permalink:"/zedux/docs/api/factories/api",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/factories/api.mdx",tags:[],version:"current",frontMatter:{id:"api",title:"api"},sidebar:"react",previous:{title:"zeduxGlobalStore",permalink:"/zedux/docs/api/constants/zeduxGlobalStore"},next:{title:"atom",permalink:"/zedux/docs/api/factories/atom"}},c=[{value:"Examples",id:"examples",children:[],level:2},{value:"Signature",id:"signature",children:[{value:"Overloads",id:"overloads",children:[],level:3},{value:"<code>value</code>",id:"value",children:[],level:3},{value:"<code>store</code>",id:"store",children:[],level:3}],level:2},{value:"Notes",id:"notes",children:[],level:2}],u={toc:c};function d(e){var t=e.components,a=(0,o.Z)(e,s);return(0,i.kt)("wrapper",(0,r.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { api } from '@zedux/react'\n")),(0,i.kt)("p",null,"A factory for creating ",(0,i.kt)("a",{parentName:"p",href:"../classes/AtomApi"},"AtomApis"),"."),(0,i.kt)("h2",{id:"examples"},"Examples"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { api } from '@zedux/react'\n\nconst myApi = api()\nconst withValue = api('some value')\nconst withStore = api(createStore())\nconst withExports = api(val).setExports({ ...myExports })\nconst withPromise = api(val).setPromise(myPromise)\nconst fromApi = api(myApi)\nconst addingExports = api(withExports).addExports({ ...moreExports })\nconst overwritingExports = api(withExports).setExports({ ...newExports })\n")),(0,i.kt)("h2",{id:"signature"},"Signature"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"api(value?) => AtomApi\n")),(0,i.kt)("h3",{id:"overloads"},"Overloads"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"atom(store?) => AtomApi\n")),(0,i.kt)("h3",{id:"value"},(0,i.kt)("inlineCode",{parentName:"h3"},"value")),(0,i.kt)("p",null,"Any raw value. If this AtomApi is returned from an ",(0,i.kt)("a",{parentName:"p",href:"../glossary#evaluator"},"evaluator function"),", this value will be set as the atom instance's state."),(0,i.kt)("h3",{id:"store"},(0,i.kt)("inlineCode",{parentName:"h3"},"store")),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"../classes/Store"},"Zedux store"),". If this AtomApi is returned from an evaluator function, this store will be set as the ",(0,i.kt)("a",{parentName:"p",href:"../classes/AtomInstance#store"},"atom instance's store"),". It should therefore be a stable reference that won't change across reevaluations, e.g. by using ",(0,i.kt)("a",{parentName:"p",href:"../injectors/injectStore"},"injectStore"),"."),(0,i.kt)("h2",{id:"notes"},"Notes"),(0,i.kt)("p",null,"See ",(0,i.kt)("a",{parentName:"p",href:"../classes/AtomApi"},"the AtomApi class")," for more info."))}d.isMDXComponent=!0}}]);