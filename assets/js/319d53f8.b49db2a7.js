(self.webpackChunkzedux_docs=self.webpackChunkzedux_docs||[]).push([[579],{233:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return r},metadata:function(){return c},toc:function(){return m},default:function(){return d}});var a,s=n(4034),o=n(9973),i=(n(7294),n(3905)),r={id:"AtomInstance",title:"AtomInstance"},c={unversionedId:"api/classes/AtomInstance",id:"api/classes/AtomInstance",isDocsHomePage:!1,title:"AtomInstance",description:'All standard "atom instances" are actually instances of this class. Ions, Standard Atoms, and Local Atoms all create instances of this class.',source:"@site/docs/api/classes/AtomInstance.mdx",sourceDirName:"api/classes",slug:"/api/classes/AtomInstance",permalink:"/zedux/docs/api/classes/AtomInstance",editUrl:"https://github.com/Omnistac/zedux/tree/master/docs/api/classes/AtomInstance.mdx",version:"current",frontMatter:{id:"AtomInstance",title:"AtomInstance"},sidebar:"react",previous:{title:"AtomApi",permalink:"/zedux/docs/api/classes/AtomApi"},next:{title:"Ecosystem",permalink:"/zedux/docs/api/classes/Ecosystem"}},m=[{value:"Creation",id:"creation",children:[]},{value:"Providing",id:"providing",children:[]},{value:"Properties",id:"properties",children:[{value:"<code>.atom</code>",id:"atom",children:[]},{value:"<code>.ecosystem</code>",id:"ecosystem",children:[]},{value:"<code>.exports</code>",id:"exports",children:[]},{value:"<code>.keyHash</code>",id:"keyhash",children:[]},{value:"<code>.params</code>",id:"params",children:[]},{value:"<code>.promise</code>",id:"promise",children:[]},{value:"<code>.store</code>",id:"store",children:[]}]},{value:"Methods",id:"methods",children:[{value:"<code>.dispatch</code>",id:"dispatch",children:[]},{value:"<code>.invalidate</code>",id:"invalidate",children:[]},{value:"<code>.setState</code>",id:"setstate",children:[]}]},{value:"Extending",id:"extending",children:[]}],p=(a="LiveEditor",function(e){return console.warn("Component "+a+" was not imported, exported, or provided by MDXProvider as global scope"),(0,i.kt)("div",e)}),l={toc:m};function d(e){var t=e.components,n=(0,o.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,s.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,'All standard "atom instances" are actually instances of this class. ',(0,i.kt)("a",{parentName:"p",href:"Ion"},"Ions"),", ",(0,i.kt)("a",{parentName:"p",href:"Atom"},"Standard Atoms"),", and ",(0,i.kt)("a",{parentName:"p",href:"LocalAtom"},"Local Atoms")," all create instances of this class."),(0,i.kt)("h2",{id:"creation"},"Creation"),(0,i.kt)("p",null,"You should never instantiate this class yourself. Zedux does it for you. An instance is created the first time a given atom + params combo is used."),(0,i.kt)("p",null,"Many hooks and injectors return instances of this class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { useAtomInstance } from '@zedux/react'\n\nfunction MyComponent() {\n  // creates the instance if it doesn't exist yet\n  const instance = useAtomInstance(myAtom)\n  ...\n}\n")),(0,i.kt)("h2",{id:"providing"},"Providing"),(0,i.kt)("p",null,"An atom instance can be provided over React context via ",(0,i.kt)("a",{parentName:"p",href:"../components/AtomInstanceProvider"},(0,i.kt)("inlineCode",{parentName:"a"},"<AtomInstanceProvider>")),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-tsx"},"import { AtomInstanceProvider, useAtomInstance } from '@zedux/react'\n\nfunction App() {\n  const instance = useAtomInstance(myAtom)\n\n  return (\n    <AtomInstanceProvider instance={instance}>\n      <Routes />\n    </AtomInstanceProvider>\n  )\n}\n")),(0,i.kt)("p",null,"Consume provided instances with ",(0,i.kt)("a",{parentName:"p",href:"../hooks/useAtomConsumer"},(0,i.kt)("inlineCode",{parentName:"a"},"useAtomConsumer"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { useAtomConsumer } from '@zedux/react'\n\nfunction Child() {\n  const instance = useAtomConsumer(myAtom)\n}\n")),(0,i.kt)("h2",{id:"properties"},"Properties"),(0,i.kt)("p",null,"Atom instances have the following ",(0,i.kt)("strong",{parentName:"p"},"readonly")," properties:"),(0,i.kt)("h3",{id:"atom"},(0,i.kt)("inlineCode",{parentName:"h3"},".atom")),(0,i.kt)("p",null,"A reference to the ",(0,i.kt)("a",{parentName:"p",href:"Atom"},"atom")," that this atom instance was created from."),(0,i.kt)("h3",{id:"ecosystem"},(0,i.kt)("inlineCode",{parentName:"h3"},".ecosystem")),(0,i.kt)("p",null,"A reference to the ",(0,i.kt)("a",{parentName:"p",href:"Ecosystem"},"ecosystem")," that created and controls this atom instance."),(0,i.kt)("h3",{id:"exports"},(0,i.kt)("inlineCode",{parentName:"h3"},".exports")),(0,i.kt)("p",null,"An object. May be undefined, if nothing was exported."),(0,i.kt)("p",null,"The exports of the atom instance, as defined by the instance's ",(0,i.kt)("a",{parentName:"p",href:"AtomApi"},"AtomApi"),"."),(0,i.kt)("p",null,"This object is stable. It is set the first time an atom instance is created and will not change on subsequent evaluations."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { api, atom } from '@zedux/react'\n\nconst exportsAtom = atom('exports', api().setExports({ hello: 'world' }))\n\nconst importAtom = atom('import', () => {\n  const { hello } = injectAtomInstance(exportsAtom).exports\n})\n")),(0,i.kt)("h3",{id:"keyhash"},(0,i.kt)("inlineCode",{parentName:"h3"},".keyHash")),(0,i.kt)("p",null,"A string representing the stable, unique key of this atom instance in the ecosystem. This keyHash is the combination of the ",(0,i.kt)("a",{parentName:"p",href:"Atom#key"},"atom's ",(0,i.kt)("inlineCode",{parentName:"a"},"key"))," and a stable stringification of the ",(0,i.kt)("a",{parentName:"p",href:"#params"},(0,i.kt)("inlineCode",{parentName:"a"},"params"))," of this atom instance. Zedux uses this internally for like ... everything."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"useAtomInstance(atom('a', null)).keyHash // 'a'\nuseAtomInstance(atom('b', (param: string) => param), ['c']).keyHash // 'b-[\"c\"]'\n")),(0,i.kt)("h3",{id:"params"},(0,i.kt)("inlineCode",{parentName:"h3"},".params")),(0,i.kt)("p",null,"A reference to the raw, unserialized params that were used to create this atom instance. If the atom doesn't take params, this will be an empty array."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const instanceA = useAtomInstance(myAtom, ['param 1', 'param 2'])\nconst instanceB = useAtomInstance(myAtom, ['a', 'b'])\ninstanceA.params // ['param 1', 'param 2']\ninstanceB.params // ['a', 'b']\n")),(0,i.kt)("p",null,'All params must be serializable (no functions or symbols)! This is because Zedux converts the params to a stable string representation in order to efficiently check for an existing atom instance with the "same" params.'),(0,i.kt)("p",null,"Sameness is determined by deep value comparison, not reference equality. Order matters!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// These params are the \"same\" in Zedux' eyes:\nuseAtomInstance(myAtom, ['a', { b: 'b', c: 'c' }])\nuseAtomInstance(myAtom, ['a', { c: 'c', b: 'b' }])\n\n// But these are different:\nuseAtomInstance(myAtom, ['a', 'b'])\nuseAtomInstance(myAtom, ['b', 'a'])\n")),(0,i.kt)("p",null,"The only exception to the serializable rule is other atom instances. That's right! You can pass an atom instance to another atom instance. You can then use ",(0,i.kt)("a",{parentName:"p",href:"../injectors/injectGet"},(0,i.kt)("inlineCode",{parentName:"a"},"get"))," or any dynamic injector to register a ",(0,i.kt)("a",{parentName:"p",href:"../glossary#dynamic-graph-dependency"},"dynamic graph dependency")," on the passed atom instance."),(0,i.kt)(p,{resultVar:"Shout",mdxType:"LiveEditor"},"\nconst normalAtom = atom('normal', \"I'm just a little, black rain cloud\")\n\nconst shoutingAtom = atom(\n  'shouting',\n  (instance: AtomInstance<string>) => {\n    const val = injectAtomValue(instance) // subscribe to updates\n\n    return val.toUpperCase()\n  }\n)\n\nfunction Shout() {\n  const instance = useAtomInstance(normalAtom)\n  const shout = useAtomValue(shoutingAtom, [instance]) // just pass the instance\n\n  return <div>(In a Singing sort of voice): {shout}</div>\n}\n"),(0,i.kt)("h3",{id:"promise"},(0,i.kt)("inlineCode",{parentName:"h3"},".promise")),(0,i.kt)("p",null,"A promise. May be undefined, if no promise was set on a returned ",(0,i.kt)("a",{parentName:"p",href:"AtomApi"},"AtomApi"),"."),(0,i.kt)("p",null,"This promise will be used to cause React to suspend whenever this atom instance is used in a component until the promise completes. This promise reference will not change on subsequent evaluations."),(0,i.kt)("p",null,"Setting this promise overrides any ",(0,i.kt)("inlineCode",{parentName:"p"},".forwardPromises")," config options set on this instance's ",(0,i.kt)("a",{parentName:"p",href:"Atom#forwardpromises"},"atom")," or ",(0,i.kt)("a",{parentName:"p",href:"Ecosystem#forwardpromises"},"ecosystem"),"."),(0,i.kt)("h3",{id:"store"},(0,i.kt)("inlineCode",{parentName:"h3"},".store")),(0,i.kt)("p",null,"A Zedux ",(0,i.kt)("a",{parentName:"p",href:"Store"},"store"),". A reference to this atom instance's store. All atom instances have a store."),(0,i.kt)("h2",{id:"methods"},"Methods"),(0,i.kt)("p",null,"Atom instances have the following methods:"),(0,i.kt)("h3",{id:"dispatch"},(0,i.kt)("inlineCode",{parentName:"h3"},".dispatch")),(0,i.kt)("p",null,"A bound function property. Dispatches an action to this atom instance's store."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const instance = useAtomInstance(myAtom)\nconst newState = instance.dispatch(myActor())\n\n// since this function is bound, dereferencing is fine:\nconst { dispatch } = instance\n")),(0,i.kt)("p",null,"This function differs from ",(0,i.kt)("inlineCode",{parentName:"p"},"instance.store.dispatch")," in that it allows any ",(0,i.kt)("a",{parentName:"p",href:"AtomApi#adddispatchinterceptor"},"AtomApi dispatch interceptors")," to run. Always prefer calling ",(0,i.kt)("inlineCode",{parentName:"p"},"instance.dispatch")," to calling ",(0,i.kt)("inlineCode",{parentName:"p"},"instance.store.dispatch"),"."),(0,i.kt)("p",null,"To prevent this atom instance from reevaluating, set ",(0,i.kt)("a",{parentName:"p",href:"../constants/metaTypes#skip_evaluation"},(0,i.kt)("inlineCode",{parentName:"a"},"metaTypes.SKIP_EVALUATION"))," as the ",(0,i.kt)("inlineCode",{parentName:"p"},"meta")," property of the dispatched action:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { metaTypes } from '@zedux/react'\n\ninstance.dispatch({ type: 'action-type', meta: metaTypes.SKIP_EVALUATION })\n")),(0,i.kt)("h4",{id:"signature"},"Signature"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},".dispatch(action) => newState\n")),(0,i.kt)("p",null,"Returns the new state."),(0,i.kt)("h4",{id:"action"},(0,i.kt)("inlineCode",{parentName:"h4"},"action")),(0,i.kt)("p",null,"Required. An ",(0,i.kt)("a",{parentName:"p",href:"../types/Action"},"action")," or ",(0,i.kt)("a",{parentName:"p",href:"../types/ActionChain"},"action chain")," object."),(0,i.kt)("h3",{id:"invalidate"},(0,i.kt)("inlineCode",{parentName:"h3"},".invalidate")),(0,i.kt)("p",null,"A bound function property. Forces a reevaluation of the atom instance."),(0,i.kt)(p,{resultVar:"Coin",mdxType:"LiveEditor"},"\nconst coinTossAtom = atom('coinToss', () => Math.random() < 0.5)\n\nfunction Coin() {\n  const isHeads = useAtomValue(coinTossAtom)\n  const { invalidate } = useAtomInstance(coinTossAtom)\n\n  return <button onClick={invalidate}>{isHeads ? 'Heads' : 'Tails'}</button>\n}\n"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// since this function is bound, dereferencing is fine:\nconst { invalidate } = instance\n\n// an exact reference to this function is returned from injectInvalidate()\nconst invalidate = injectInvalidate()\n")),(0,i.kt)("h4",{id:"signature-1"},"Signature"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},".invalidate() => void\n")),(0,i.kt)("h3",{id:"setstate"},(0,i.kt)("inlineCode",{parentName:"h3"},".setState")),(0,i.kt)("p",null,"A bound function property. Sets the state of this atom instance's store."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const instance = useAtomInstance(myAtom)\nconst newState = instance.setState('new state')\n\n// since this function is bound, dereferencing is fine:\nconst { setState } = instance\n")),(0,i.kt)("p",null,"This function differs from ",(0,i.kt)("inlineCode",{parentName:"p"},"instance.store.setState")," in that it allows any ",(0,i.kt)("a",{parentName:"p",href:"AtomApi#addsetstateinterceptor"},"AtomApi setState interceptors")," to run. Typically, you should prefer calling ",(0,i.kt)("inlineCode",{parentName:"p"},"instance.setState")," to calling ",(0,i.kt)("inlineCode",{parentName:"p"},"instance.store.setState"),"."),(0,i.kt)("p",null,"To prevent this atom instance from reevaluating, pass ",(0,i.kt)("a",{parentName:"p",href:"../constants/metaTypes#skip_evaluation"},(0,i.kt)("inlineCode",{parentName:"a"},"metaTypes.SKIP_EVALUATION"))," as the ",(0,i.kt)("inlineCode",{parentName:"p"},"meta")," property:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { metaTypes } from '@zedux/react'\n\ninstance.setState(newState, metaTypes.SKIP_EVALUATION)\n")),(0,i.kt)("h4",{id:"signature-2"},"Signature"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},".setState(settable, meta?) => newState\n")),(0,i.kt)("p",null,"Returns the new state."),(0,i.kt)("h4",{id:"settable"},(0,i.kt)("inlineCode",{parentName:"h4"},"settable")),(0,i.kt)("p",null,"Required. A ",(0,i.kt)("a",{parentName:"p",href:"../types/Settable"},"Settable")," - either the new state or a function that receives the current state and returns the new state."),(0,i.kt)("h4",{id:"meta"},(0,i.kt)("inlineCode",{parentName:"h4"},"meta")),(0,i.kt)("p",null,"Optional. Can be anything. Certain built-in meta strings can be used to communicate with Zedux. See ",(0,i.kt)("a",{parentName:"p",href:"../constants/metaTypes#skip_evaluation"},(0,i.kt)("inlineCode",{parentName:"a"},"metaTypes.SKIP_EVALUATION")),"."),(0,i.kt)("h2",{id:"extending"},"Extending"),(0,i.kt)("p",null,"There are many aspects of an atom instance's behavior you can overwrite when extending this class. This is an extremely advanced feature. We're not documenting it yet as the internals of this class may change. Someday there will probably be a nice, complex, over-detailed explanation sitting right here on this page. Or maybe not."))}d.isMDXComponent=!0}}]);