---
id: overview
title: Overview
---

Buckle in for a quick description and contrived example of every key feature of Zedux. The [walkthrough](../walkthrough/quick-start) will walk through this list in much more detail.

## Atoms

Atoms are the basic state management unit in Zedux.

```tsx
import { atom } from '@zedux/react'

const myFirstAtom = atom('myFirst', 'Hello, world!')
```

See [the quick start](../walkthrough/quick-start#meet-the-atoms) and [the `atom()` factory](../api/factories/atom).

### Hooks

Zedux exports various hooks for accessing and updating atom values.

```tsx
import { useAtomInstance, useAtomState } from '@zedux/react'

function MyComponent() {
  const [state] = useAtomState(myFirstAtom)

  return <div>A message from the universe: {state}</div>
}
```

See [the quick start](../walkthrough/quick-start).

### Injectors

Injectors are like hooks for atoms.

```tsx live ecosystemId=overview/injectors resultVar=Seconds
const secondsAtom = atom('seconds', () => {
  const store = injectStore(0)

  injectEffect(() => {
    const intervalId = setInterval(() => store.setState(val => val + 1), 1000)

    return () => clearInterval(intervalId)
  }, [])

  return store
})

function Seconds() {
  const state = useAtomValue(secondsAtom)

  return <div>{state}</div>
}
```

See [the quick start](../walkthrough/quick-start).

### EcosystemProvider

An optional `<EcosystemProvider />` can be rendered at the top level of your app. All atom instances created in any children will be scoped to the EcosystemProvider.

```tsx
import { EcosystemProvider } from '@zedux/react'

function App() {
  return (
    <EcosystemProvider>
      <Routes />
    </EcosystemProvider>
  )
}
```

An ecosystem can also be created and used completely outside of React.

```ts
import { createEcosystem } from '@zedux/react'

const rootEcosystem = createEcosystem({ id: 'root' })

const myAtomInstance = rootEcosystem.getInstance(myAtom, ['a param'])
```

See [the Ecosystems walkthrough](../walkthrough/ecosystems), [`<EcosystemProvider />`](../api/components/EcosystemProvider), and [the `Ecosystem` class](../api/classes/Ecosystem).

### Ions

Selector-type operations can be done with special atoms called [ions](../api/classes/Ion).

```tsx
import { atom, ion } from '@zedux/react'

const bigListAtom = atom('bigList', Array(1000).fill('bigness'))

// highlight-next-line
const smallListAtom = ion('smallList', ({ get }) => {
  const bigList = get(bigListAtom)

  return bigList.slice(0, 10)
})
```

See [the Selectors walkthrough](../walkthrough/selectors) and [the `Ion` class](../api/classes/Ion).

### Flags

Atoms can be given flags. One major use case for these is to raise warnings if a flagged atom is used in invalid environments.

```tsx
const axiosAtom = atom('axios', axios, {
  flags: ['async'],
  readonly: true,
})

function SomeComponent() {
  const axios = axiosAtom.useValue()
  ...
}

function TestApp() {
  return (
    <EcosystemProvider flags={[/* no flags */]}>
      <SomeComponent />
    </EcosystemProvider>
  )
}
// logs warning: Unsafe atom "axios" encountered with flag "async"

function DevApp() {
  return (
    <EcosystemProvider flags={['async']}>
      <SomeComponent />
    </EcosystemProvider>
  )
}
// no warnings
```

See [the testing guide](/not-done) and [Ecosystem's `.flags` property](../api/classes/Ecosystem#flags).

### Exports

Atoms can expose variables to consumers.

```tsx live ecosystemId=overview/exports resultVar=Counter
const counterAtom = ion('counter', () => {
  const store = injectStore(0)

  return api(store).setExports({
    decrement: () => store.setState(state => state - 1),
    increment: () => store.setState(state => state + 1),
  })
})

function Counter() {
  const counter = useAtomValue(counterAtom)
  const { decrement, increment } = useAtomInstance(counterAtom).exports

  return (
    <>
      <div>Counter State: {counter}</div>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
    </>
  )
}
```

See [the Atom APIs walkthrough](../walkthrough/atom-apis) and [the `AtomApi` class](../api/classes/AtomApi).

## Dependency Injection

Zedux atoms create a perfect environment for Inversion of Control.

### Composition

Atoms can be composed of other atoms by "injecting" them.

```tsx
const bigListAtom = atom('bigList', Array(1000).fill('fluff'))

const smallListAtom = atom('smallList', () => {
  const [bigList] = injectAtomState(bigListAtom)

  return bigList.slice(0, 10)
})
```

See [the quick start](../walkthrough/quick-start#dependency-injection).

### Overrides

Injected atoms can be overridden.

```tsx
const fetchTodosAtom = atom('fetchTodos', () => {
  // a theoretical custom injector for simplicity:
  return injectFetch('/todos', [])
})

function Todos() {
  const [todos] = useAtomState(fetchTodosAtom)

  return <div>The todos: {todos.join(', ')}</div>
}

// In some test:
// highlight-next-line
const fetchTodosTestAtom = fetchTodosAtom.override(['Todo 1', 'Todo 2'])

function TestApp() {
  return (
    // highlight-next-line
    <EcosystemProvider overrides={[fetchTodosTestAtom]}>
      <Todos />
    </EcosystemProvider>
  )
}
```

See [the Overrides walkthrough](../walkthrough/overrides).

## Stores

An atom's value can be a store.

```tsx live ecosystemId=overview/stores resultVar=BigComponent
const goBig = actionFactory('goBig')

const bigAtom = atom('big', () => {
  const store = injectStore()

  injectEffect(() => {
    const subscription = store.subscribe({
      effects: ({ action }) => {
        if (action?.type === goBig.type) alert('go home')
      },
    })

    return () => subscription.unsubscribe()
  }, [])

  return store
})

function BigComponent() {
  const { dispatch } = useAtomInstance(bigAtom)

  return <button onClick={() => dispatch(goBig())}>Go Big</button>
}
```

See [the stores walkthrough](../walkthrough/stores) and [the `Store` class](../api/classes/Store).

### Redux-Style State

Stores can be configured with Redux-style reducers.

```tsx
import { actionFactory, createReducer, createStore } from '@zedux/react'

const addTodo = actionFactory<string>('addTodo')

const todosReducer = createReducer<string[]>([]).reduce(
  addTodo,
  (state, todo) => [...state, todo]
)

const todosStore = createStore({ todos: todosReducer })
```

See [the stores walkthrough](../walkthrough/stores), [`actionFactory()`](../api/factories/actionFactory), [`createReducer()`](../api/factories/createReducer), and [`createStore()`](../api/factories/createStore).

### State Machines

Stores can be configured with simple state machines.

```tsx
import { actionFactory, createMachine, createStore, states } from '@zedux/react'

const timer = actionFactory('timer')
const [green, yellow, red] = states('green', 'yellow', 'red')

const stopLightMachine = createMachine(
  green.on(timer, yellow), // "green" will be the initial state
  yellow.on(timer, red),
  red.on(timer, green)
)

// machines are just pure reducers
const stopLightStore = createStore(stopLightMachine)
```

See [the state machines walkthrough](../walkthrough/state-machines).

### Action Streams

One of the superpowers of Zedux stores is that they can be simultaneously consumed as streams of state _and_ streams of actions.

```tsx
const store = createStore(null, 'initial state')

store.subscribe(myCallback) // stream of state
store.actionStream().subscribe(myCallback) // stream of dispatched actions
```

See [the side effects walkthrough](../walkthrough/side-effects).

## Caching

When atoms are used, atom instances are created. These instances are like data caches. The cache can be controlled in many ways.

### Params

Atoms can take parameters. Different params cause new atom instances to be created.

```tsx
const totallyUsefulAtom = atom(
  'totallyUseful',
  (usefulness: number) => usefulness * 10
)

function MyComponent() {
  const [totallyUsefulNumber] = useAtomState(totallyUsefulAtom, [4.2])
  const [moreUsefulNumber] = useAtomState(totallyUsefulAtom, [0.314159])
  ...
}
```

See [the quick start](../walkthrough/quick-start#params) and [the atom instances walkthrough](../walkthrough/atom-instances).

### Destruction

Atom instances can be destroyed with `ttl`.

```tsx
const deathStarAtom = atom('deathStar', 'All the Sith', {
  // destroy deathStarAtom instances 10 seconds after their ref count reaches 0
  ttl: 10000,
})
```

See [the destruction walkthrough](/not-done)

### Atom Instances

Atom instances can be accessed directly.

```tsx
const randomNumAtom = atom('randomNum', (max: number) =>
  Math.floor(Math.random() * max)
)

function RandomNumber() {
  const instance = useAtomInstance(randomNumAtom, [100])
  const state = useAtomValue(instance) // don't have to re-pass params here

  return (
    {/* instances can be provided over React context */}
    <AtomInstanceProvider instance={instance}>
      <SomeChild />
    </AtomInstanceProvider>
  )
}

function SomeChild() {
  const instance = useAtomConsumer(randomNumAtom) // don't need to pass params
  ...
}
```

See the [atom instances](../walkthrough/atom-instances) and [React context](../walkthrough/react-context) walkthroughs.

### Invalidation

Atoms can invalidate their own state using `injectInvalidate()`:

```tsx
import { injectInvalidate } from '@zedux/react'

const asyncAtom = atom('async', () => {
  // can be called directly in a callback or effect to trigger a reevaluation
  const invalidate = injectInvalidate()

  // in some callback or effect:
  invalidate()
})
```

Consumers can invalidate an atom's state using `instance.invalidate()`:

```tsx
function App() {
  const myInstance = myAtom.useInstance()

  return <button onClick={() => myInstance.invalidate()}>Invalidate</button>
}
```

See [`injectInvalidate()`](../api/injectors/injectInvalidate) and [the resets walkthrough](/not-done)

## Side Effects

Atoms are designed for executing and sharing promises and observables

### `injectEffect`

An injector that works just like React's `useEffect`, but in atoms

```tsx
const currentUserDataAtom = ion('userData', ({ get }) => {
  const userId = get(currentUser).id
  const store = injectStore()

  injectEffect(() => {
    fetch(`/api/user/${userId}`)
      .then(data => data.json())
      .then(data => store.setState(data))
  }, [userId])

  return store
})
```

### Streams

Atoms work well with streams, e.g. websockets and RxJS observables.

```tsx
const socketAtom = atom('socket', () => io('ws://localhost:8080'))

const usersStreamAtom = ion('usersStream', ({ get }) => {
  const socket = get(socketAtom)

  const users$ = defer(() => of(socket.emit('start-users-stream'))).pipe(
    mergeMap(() => fromEvent(socket, 'user')),
    finalize(() => socket.emit('end-users-stream'))
  )

  return users$
})
```

See [the side effects walkthrough](../walkthrough/side-effects).

### Suspense

Atoms can be used as suspending resources in React concurrent mode.

```tsx
import { api, atom } from '@zedux/react'

const suspendingAtom = atom('suspending', () => {
  return api(someVal).setPromise(somePromise)
})
```

See [the suspense walkthrough](../walkthrough/suspense)

## Advanced

### Hydration

Hydrating atom state can be done with `ecosystem.hydrate()`.

```tsx
import { createEcosystem } from '@zedux/react'

const rootEcosystem = createEcosystem({
  id: 'root',
  onReady: ecosystem => {
    ecosystem.hydrate(serverSnapshot)
  },
})
```

See [the persistence walkthrough](../advanced/persistence).

### Preloading

Atoms can be preloaded to kickstart hydration, alleviate render waterfalls, and bootstrap data from outside Zedux.

```tsx
import { EcosystemProvider, useEcosystem } from '@zedux/react'

function App() {
  return (
    <EcosystemProvider
      onReady={ecosystem => {
        ecosystem.getInstance(authAtom)
        ecosystem.getInstance(initialDataAtom)

        const storage = ecosystem.get(localStorageAtom)
        ecosystem.hydrate(storage.persistedAtomState)
      }}
    >
      <Routes />
    </EcosystemProvider>
  )
}
```

See [the ecosystems walkthrough](../walkthrough/ecosystems).

## Dev Tools

Zedux ships with several Dev X features out of the box. And more can be installed.

### `injectWhy()`

Why Did This UpDaTe??!!

```tsx
import { injectStore, injectWhy, ion } from '@zedux/react'

const crazyAtom = ion('crazy', ({ get, select }) => {
  // say we have an atom that injects several state sources
  const store = injectStore()
  const other = get(otherAtom)
  const derivation = select(someSelector)

  // with such atoms it can be difficult to tell why state keeps updating
  // injectWhy FTW!
  // highlight-next-line
  const lameExcuse = injectWhy()
  console.log('why???', lameExcuse)
})
```

See [`injectWhy()`](../api/injectors/injectWhy).
