---
id: metaTypes
title: metaTypes
---

```ts
import { metaTypes } from '@zedux/react'
```

An object of the "metaType" values Zedux uses internally in its [ActionChain objects](../types/ActionChain). You may encounter these meta nodes in action chains passed to [effects subscribers](../classes/Store#subscribe) in composed stores. Use this object to identify them.

## Definition

```ts
const metaTypes = {
  DELEGATE: '@@zedux/delegate',
  INHERIT: '@@zedux/inherit',
  SKIP_EVALUATION: '@@zedux/skipEvaluation',
}
```

### `DELEGATE`

Zedux attaches this meta node to actions when a child store informs a parent store of a state change.

```ts
const childStore = createStore(null, 'initial state')
const parentStore = createStore({ child: childStore })

parentStore.subscribe({
  effects: ({ action }) => {
    console.log('action:', action)
  },
})

childStore.setState('new state')
// action: {
//   metaType: '@@zedux/delegate',
//   metaData: ['child'],
//   payload: {
//     type: '@@zedux/hydrate',
//     payload: 'new state'
//   }
// }

childStore.getState() // 'new state'
parentStore.getState() // { child: 'new state' }
```

Dispatching an action wrapped in `DELEGATE` to a parent store tells Zedux to "delegate" the action to the child store. This is the key to time travel! By tracking all actions dispatched to child stores, a parent store can effectively reverse engineer all of its state changes.

```ts
// this is exactly the same as calling `.setState('new state')` in the child store:
const action = {
  metaType: '@@zedux/delegate', // metaTypes.DELEGATE
  metaData: ['child'],
  payload: {
    type: '@@zedux/hydrate', // actionTypes.HYDRATE
    payload: 'new state',
  },
}

parentStore.dispatch(action)

childStore.getState() // 'new state'
parentStore.getState() // { child: 'new state' }
```

### `INHERIT`

Zedux wraps actions in this meta node when passing an action dispatched in a parent store down to its children.

```ts
const childStore = createStore(null, 'initial state')
const parentStore = createStore({ child: childStore })

childStore.subscribe({
  effects: ({ action }) => {
    console.log('action:', action)
  },
})

parentStore.dispatch({ type: 'test' })
// action: {
//   metaType: '@@zedux/inherit',
//   payload: {
//     type: 'test'
//   }
// }
```

### `SKIP_EVALUATION`

For use with stores that belong to atom instances. Set this string to an action's `meta` property to tell Zedux not to reevaluate the atom instance:

```ts
store.dispatch({ type: 'my-action-type', meta: metaTypes.SKIP_EVALUATION })
```

This meta property can also be set when calling [`instance.setState()`](../classes/AtomInstance#setstate) or [`store.setState()`](../classes/Store#setstate) by passing it as the second parameter:

```ts
store.setState(newState, metaTypes.SKIP_EVALUATION)
```

It is not necessary to use this when updating an injected store's state synchronously during atom evaluation. Zedux always prevents these cases from causing a reevaluation, as that would lead to an evaluation loop.

```ts
const testAtom = atom('test', () => {
  const store = injectStore(initialState)

  store.setState(newState) // won't cause an evaluation loop
})
```

## Removing Meta Nodes

Sometimes we don't care about this metadata. Zedux exports a `removeAllMeta` function that unwraps all meta nodes around an action object.

```ts
import { removeAllMeta } from '@zedux/react'

const unwrappedAction = removeAllMeta(inheritedAction) // { type: 'test' }
```
