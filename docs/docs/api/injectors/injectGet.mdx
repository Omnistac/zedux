---
id: injectGet
title: injectGet
---

import { LiveEditor } from '../../LiveEditor'

```ts
import { injectGet } from '@zedux/react'
```

An [injector](../glossary#injector) that returns a `get` function. This `get` function returns the values of other atom instances. It's similar to [the `.get()` method on ecosystems](../classes/Ecosystem#get) but it has one extra superpower:

When called synchronously during atom evaluation, this function will register a [dynamic graph dependency](../glossary#dynamic-graph-dependency) on the resolved atom instance. In this way, `get` is like [`injectAtomValue()`](injectAtomValue). However, unlike `injectAtomValue`, `get` is not an injector. This means it can be called in loops or if statements or even asynchronously.

When called asynchronously, `get` is really just an alias for `ecosystem.get()`. It doesn't register any graph dependencies; it simply returns the current value of the resolved atom instance.

[Ions](../classes/Ion) use this injector internally to provide the `get` function as part of their [AtomGetters](../types/AtomGetters) and [AtomSetters](../types/AtomSetters) objects.

## Examples

<LiveEditor ecosystemId="injectGet/example" resultVar="Seconds">{`
const secondsAtom = atom('seconds', (startingNumber: number) => {
  const store = injectStore(startingNumber)\n
  injectEffect(() => {
    const intervalId = setInterval(
      () => store.setState(val => val + 1),
      1000
    )\n
    return () => clearInterval(intervalId)
  }, [])\n
  return store
})\n
const sumAtom = atom('sum', (...nums: number[]) => {
  const get = injectGet()\n
  // loops are fine!
  return nums.reduce((sum, num) => sum + get(secondsAtom, [num]), 0)
})\n
function Seconds() {
  const sum = useAtomValue(sumAtom, [1, 10, 100])\n
  return <div>Sum of 3 counters, starting at 1, 10, and 100: {sum}</div>
}
`}</LiveEditor>

Miscellaneous:

```ts
const get = injectGet()

const dynamicVal = get(myAtom)
const withParams = get(myAtom, ['param 1', 'param 2'])

// in a loop
for (const id of ids) {
  const val = get(myAtom, [id])
}

// .. any kind of loop
ids.map(id => get(myAtom, [id]))

// in control flow statements
const val = useAtomA ? get(atomA) : defaultVal

// asynchronously: (`get` isn't technically a stable reference. But it doesn't
// reference anything unstable, so not passing it as a dependency is fine)
injectEffect(() => {
  const currentVal = get(myAtom)
}, []) // don't have to pass `get`

// passing an instance (also registers a dynamic dependency during evaluation):
const fromInstance = get(instance)
```

## Signature

```ts
injectGet() => get
```

The injector itself doesn't take any params. The returned `get` function's signature is:

```ts
get(atom, params?) => currentState
```

There is an overload for passing instances:

```ts
get(instance) => currentState
```

### `atom`

Required. An [atom](../classes/Atom).

### `params`

Optional. An array of parameters that identify this atom instance. These params will be passed to the atom's [evaluator function](../glossary#evaluator).

TS users will be required to pass this for atoms that take params. If you don't use TS ... just don't forget to pass them.

### `instance`

Required (in this overload). An [atom instance](../classes/AtomInstance).
