---
id: SetStateInterceptor
title: SetStateInterceptor
---

A function that intercepts [`instance.setState()`](../classes/AtomInstance#setstate) calls.

These interceptors function like middleware. They will be called every time `instance.setState()` is called and can cancel the state setting or reroute it.

## Definition

```ts
type SetStateInterceptor<State = any> = (
  settable: Settable<State>,
  next: (settable: Settable<State>) => State
) => State
```

Accepts a [Settable](Settable) and a `next` function. Must return the new state (or the current state if no change).

## Example

```ts
const store = injectStore()

const myApi = api(store).addSetStateInterceptor(
  (settable, next) => {
    const currentState = store.getState()
    
    // make sure you return the state!
    if (isBad(currentState)) return currentState // cancel the state setting

    // return the new state
    return next(settable) // proceed with the state setting
  }
)
```

See [AtomApi](../classes/AtomApi) for more info.

## A Note on Ion setters

[Ion setters](../factories/ion#set) are very much like setState interceptors. In fact, ions use setState interceptors under the hood. But they're a little different:

They are not like middleware - they don't need to be, as you'll only have one per ion. Thus they don't receive a `next` parameter.

They also don't need to return the new state (though they can). If `undefined` is returned from an ion setter, Zedux will assume no state change was made and return the current state to the `instance.setState()` caller.
