---
id: useGetInstance
title: useGetInstance
---

import { LiveEditor } from '../../LiveEditor'

```ts
import { useGetInstance } from '@zedux/react'
```

A React hook that returns a `getInstance` function. This `getInstance` function accepts an atom and its params and returns an atom instance. It's really an alias for [`ecosystem.getInstance()`](../classes/Ecosystem#getinstance).

Use this to lazy-load atom instances. Use `ecosystem.getInstance()` instead to preload atoms in an [EcosystemProvider's `preload` prop](../components/EcosystemProvider#preload).

Unlike the `getInstance` function returned from [`injectAtomGetters()`](../injectors/injectAtomGetters), this `getInstance` function never registers any graph dependencies.

## Examples

<LiveEditor ecosystemId="useGetInstance/example" resultVar="App">{`
const secondsAtom = atom('seconds', (startingNumber: number) => {
  const store = injectStore(startingNumber)\n
  injectEffect(() => {
    const intervalId = setInterval(
      () => store.setState(val => val + 1),
      1000
    )\n
    return () => clearInterval(intervalId)
  }, [])\n
  return store
})\n
function First() {
  const seconds = useAtomValue(secondsAtom, [0])\n
  return <div>First State: {seconds}</div>
}\n
function Second() {
  const seconds = useAtomValue(secondsAtom, [10])\n
  return <div>Second State: {seconds}</div>
}\n
function App() {
  const [isStarted, setIsStarted] = useState(false)
  const [isFirst, setIsFirst] = useState(true)
  const getInstance = useGetInstance()\n
  const start = () => {
    setIsStarted(true)\n
    // preload both counters, so they start at the same time:
    getInstance(secondsAtom, [0])
    getInstance(secondsAtom, [10])
  }\n
  return (
    <>
      {!isStarted ? (
        <button onClick={start}>Start Counting!</button>
      ) : (
        <>
          {isFirst ? <First /> : <Second />}
          <button onClick={() => setIsFirst(val => !val)}>Toggle View</button>
        </>
      )}
    </>
  )
}
`}</LiveEditor>

Miscellaneous:

```ts
const getInstance = useGetInstance()

const staticInstance = getInstance(myAtom)
const withParams = getInstance(myAtom, ['param 1', 'param 2'])

// passing an atom to `useGetInstance()`:
const getMyAtomInstance = useGetInstance(myAtom)

const instance = getMyAtomInstance()
const withParams = getMyAtomInstance(['param 1', 'param 2'])
```

## Signature

```ts
useGetInstance() => getInstance
```

The returned `getInstance` function's signature is:

```ts
getInstance(atom, params?) => instance
```

### Overloads

```ts
useGetInstance(atom) => getAtomInstance
```

In this overload, the returned `getAtomInstance` function will be scoped to the passed atom and will only return instances of that atom. Its signature is:

```ts
getAtomInstance(params?) => AtomInstance
```

### `atom`

Required. An [atom](../classes/Atom).

### `params`

Optional. An array of parameters that identify this atom instance. These params will be passed to the atom's [evaluator function](../glossary#evaluator).

TS users will be required to pass this for atoms that take params. If you don't use TS ... just don't forget to pass them.
