---
id: side-effects
title: Side Effects
---

Zedux doesn't place any restrictions on how you manage asynchronous code. You can use promises, observables, sockets, generators, or any third-party library.

Zedux stores do not have middleware. Read more on that in the [Redux comparison](../about/redux-comparison). There are many other ways to manage side effects that avoid hijacking control from the store like middleware does.

We've learned how to use `injectEffect` to run side effects on state changes that cause atom reevaluations. We also learned in [the stores walkthrough](stores) that stores can take effects subscribers. We'll learn all about those here.

:::tip you will learn

- That you may not need `injectEffect`
- How to use effects subscribers
- Some utilities for conditionally running side effects

:::

## Render As You Fetch

Many of the best practices for managing side effects in React still apply with Zedux. If you've been following the React community, you've probably heard that `useEffect` is not a great pattern for most side effects - it's prone to race conditions and some of its quirks are unintuitive. The same applies for `injectEffect`.

When React suspense came out, we learned about a new pattern called "render-as-you-fetch". This boils down to putting side effects in event handlers instead of `useEffect`. That is boiling it pretty heavily, but let's see an example:

```tsx
const userAtom = atom('user', () => {
  const idStore = injectStore(1)
  const promiseRef = injectRef()

  if (!promiseRef.current) {
    promiseRef.current = fetch(`/users/${idStore.getState()}`)
      .then(data => data.json())
  }

  const setId = (newId: number) => {
    idStore.setState(newId)
    promiseRef.current = fetch(`/users/${newId}`).then(data => data.json())
  }

  return api(idStore).setExports({ setId }).setPromise(promiseRef.current)
})

function User() {
  const userData = useAtomValue(userAtom)
  const { setId } = useAtomInstance(userAtom).exports
  ...
}
```

Rather than using `injectEffect` to listen to a state update on `idStore`, we kick off the request immediately, in the `setId` callback. The state update will cause the `User` component to rerender, and when it does it will suspend again.

We'll learn more about suspense in [the suspense walkthrough](suspense).

:::tip
In general, side effects should be colocated with the state they manipulate. This is exactly what we do in React thanks to hooks and props. In Zedux, we can use injectors and exports.
:::

## `Syncing State`

A key piece of managing side effects well is having as few of them as possible. Here's a common situation you might find yourself in:

Ions are often used as selectors with better memoization capabilities. As such, they often transform state from one shape to another. You might be tempted to use `injectEffect` for this:

```ts
const sortUsers = list => [...list].sort((a, b) => a.name.localeCompare(b.name))

const sortedUsersAtom = ion('sortedUsers', () => {
  const usersList = injectAtomValue(usersAtom)
  const store = injectStore(sortUsers(usersList))

  injectEffect(() => {
    store.setState(sortUsers(usersList))
  }, [usersList])

  return store
})
```

This works but has a few imperfections:

- We set the initial state twice! Once on initial evaluation and once the first time the effect runs.
- We had to define the `sort` logic outside the ion so we can reuse it when setting the initial state and inside the effect.
- `injectEffect` runs the callback one tick later than the atom evaluation. This can be annoying to account for in tests.
- We call `sortUsers` every time this ion evaluates and discard the result every time except on the first evaluation. This can be fixed by using the function overload of `injectStore`, but that's much more verbose since it requires creating the store manually.

The fix is simple: Remove `injectEffect`! Remember that you can call `.setState()` on local stores during atom evaluation without triggering another evaluation. Let's refactor:

```ts
const sortedUsersAtom = ion('sortedUsers', () => {
  const usersList = injectAtomValue(usersAtom)
  const store = injectStore()

  // highlight-next-line
  store.setState([...usersList].sort((a, b) => a.name.localeCompare(b.name)))

  return store
})
```

This fixes every single problem. Zedux is very specifically designed to work like this. Take advantage of it!

:::tip
While updating a locally injected store during evaluation is good, updating stores in other atom instances during evaluation is not recommended. This is because atom instances can be created during render, and React doesn't like it when components update while another component is rendering.
:::

But now. We did introduce a new potential problem: What if we had other dependencies in this atom? We'd be spreading and sorting the users list every single time this atom reevaluates as a result of any of those dependencies changing. Well. You won't believe this ... but Zedux actually has yet another superpower:

## `injectWhy()`

This little beast returns an array of [reasons](../api/types/EvaluationReason) that tell you why the current atom is evaluating ðŸ¤¯. Yes. ðŸ¤¯.

The list is empty on initial evaluation. After that, every reason in the list has a `sourceKey` field that gives the unique key, if any, of the dependency that caused the update. We can use this to determine if the current evaluation is the initial evaluation or was caused by a specific dependency updating:

```ts
const sortedUsersAtom = ion('sortedUsers', () => {
  // highlight-next-line
  const usersInstance = injectAtomInstance(usersAtom)
  const usersList = injectAtomValue(usersInstance)
  const store = injectStore()
  const reasons = injectWhy()

  // only set state if this is the initial evaluation or this evaluation was at
  // least partially caused by usersInstance:
  // highlight-next-line
  if (
    !reasons.length ||
    reasons.some(reason => reason.sourceKey === usersInstance.keyHash)
  ) {
    store.setState([...usersList].sort((a, b) => a.name.localeCompare(b.name)))
  }

  return store
})
```

We'll learn more about `injectWhy` in [the dev tools walkthrough](../advanced/dev-tools).

## Effects Subscribers

In [the stores walkthrough](stores), we learned that stores can be given an effects subscriber:

```ts
function App() {
  const { store } = useAtomInstance(myAtom)

  useEffect(() => {
    const subscription = store.subscribe({
      effects: ({ action, newState, oldState }) => {
        console.log('running effect', { action, newState, oldState })
      }
    })

    return () => subscription.unsubscribe()
  }, [store])
  ...
}
```

See the full effect subscriber definition [here](/not-done). Effects subscribers are simple and powerful. But you shouldn't need to rig them up manually. Zedux exposes a high-level API that does this for you:

## WhenBuilder

`when()` is a declarative and simple way to hook into stores. It has several methods for tying into certain events and status updates in stores.

### `.receivesAction()`

Calls an effect handler every time the store receives an action.

```ts
import { useAtomInstance, when } from '@zedux/react'

function App() {
  const { store } = useAtomInstance(myAtom)

  useEffect(() => {
    // highlight-next-line
    const { subscription } = when(store).receivesAction(
      ({ action, newState, oldState }) => {
        console.log('store received action', { action, newState, oldState })
      }
    )

    return () => subscription.unsubscribe()
  }, [store])
  ...
}
```

`.receivesAction()` can be given a specific [ActionFactory](../api/types/ActionFactory) or action type:

```ts
import { actionFactory, when } from '@zedux/react'

const login = actionFactory('login')
when(myStore).receivesAction(login, doStuffOnLogin)
```

In this way, stores can easily be consumed as streams of actions.

#### `.setState()`

When `store.setState()` is called, Zedux translates that into a dispatch of the special `HYDRATE` action. To listen to only this action, import the `actionTypes` object and use the `.HYDRATE` property:

```ts
import { actionTypes, when } from '@zedux/react'

when(store).receivesAction(actionTypes.HYDRATE, handleSetState)
```

### `.stateChanges()`

Calls an effect handler every time the store's state changes in response to an action (which includes every time `.setState()` is called).

```ts
when(myStore).stateChanges(({ action, newState, oldState }) => {
  console.log('store state changed', { action, newState, oldState })
})
```

### `.stateMatches()`

Calls an effect handler every time the store's state updates to match the passed predicate. Does not call the handler if the previous state also matched the predicate.

```ts
const counterStore = createStore(null, 0)

when(counterStore).stateMatches(
  num => num > 1,
  ({ newState, oldState }) => {
    console.log('triggered!', { newState, oldState })
  }
)

counterStore.setState(1)
counterStore.setState(2) // triggered! { newState: 2, oldState: 1 }
counterStore.setState(3)
counterStore.setState(0)
counterStore.setState(4) // triggered! { newState: 4, oldState: 0 }
```

To perform a side effect on every action or every state change while the predicate is matched, regardless of previous state, use `.receivesAction()` or `.stateChanges()` with a normal if statement:

```ts
when(counterStore).receivesAction(({ newState, oldState }) => {
  if (newState > 1) {
    console.log('triggered!', { newState, oldState })
  }
})

counterStore.setState(1)
counterStore.setState(2) // triggered! { newState: 2, oldState: 1 }
counterStore.setState(3) // triggered! { newState: 3, oldState: 2 }
counterStore.setState(0)
counterStore.setState(4) // triggered! { newState: 4, oldState: 0 }
```

### Chaining

Multiple handlers can be chained together.

```ts
when(myStore).receivesAction(logAction).stateChanges(persistStateChange)

// Or
const whenMyStore = when(myStore)

whenMyStore.receivesAction(logAction)
whenMyStore.stateChanges(persistStateChange)
```

### Cleanup

As with all subscriptions, it's important to clean up effects subscribers when their context is destroyed (e.g. the component is unmounted or the atom instance is destroyed).

`when()` builders have a `subscription` property, which is a reference to the store subscription created by the `when()` call. Remember to call `subscription.unsubscribe()` in `useEffect` and `injectEffect`:

```tsx live ecosystemId=side-effects/cleanup resultVar=Button
const triggerAlert = actionFactory('triggerAlert')

const buttonPressAtom = atom('buttonPress', () => {
  const store = injectStore()

  injectEffect(() => {
    const { subscription } = when(store).receivesAction(triggerAlert, () =>
      alert('consider it done')
    )

    return () => subscription.unsubscribe()
  }, [store]) // don't have to pass store since it's a stable reference

  return store
})

function Button() {
  const { dispatch } = useAtomInstance(buttonPressAtom)

  return <button onClick={() => dispatch(triggerAlert())}>Do It</button>
}
```

For the full API, see [`when()`](/not-done).

## Odd-Looking Actions

Zedux' store composition model works by making actions themselves composable objects called ActionChains. The ActionChain contains needed metadata for Zedux to perform its store composition magic. ActionChains consist of any number of "meta nodes" with the wrapped action being the last node in the chain.

We'll go over the specifics of Zedux' store composition model in [the time travel walkthrough](../advanced/time-travel). For now you just need to know that, depending on your store setup, you may see these ActionChain objects as the `action` property in your effects handlers. Zedux doesn't unwrap the action because sometimes you will need to observe the metadata the action is wrapped in.

If you don't care about the metadata, you can get the wrapped action with `removeAllMeta`

```ts
import { removeAllMeta, when } from '@zedux/react'

when(store).receivesAction(({ action }) => {
  const unwrappedAction = removeAllMeta(action)

  switch (unwrappedAction.type) { ... }
})

store.subscribe((newState, oldState, actionChain) => {
  const action = removeAllMeta(actionChain)
})
```

## Observables

Zedux stores are a type of observable. However, Zedux doesn't have any built-in helpers (currently) for integrating with observable libraries such as [RxJS](https://github.com/ReactiveX/rxjs). But Zedux' extreme flexibility makes working with observables easy.

For example, any atom's value can be an observable:

```ts
import { atom } from '@zedux/react'
import { of } from 'rxjs'

const observableValue = atom('observableValue', of('hello, world'))
```

This can be useful for taking advantage of Zedux' caching abilities to share observable references.

You can export an observable from any atom:

```ts
import { api, atom, injectMemo } from '@zedux/react'
import { from } from 'rxjs'

const usersStreamAtom = atom('usersStream', () => {
  const users$ = injectMemo(() => from(streamUsers()), [])

  return api().setExports({
    users$,
  })
})
```

Handling observable subscriptions is easy with `injectEffect()`:

```ts
import { atom, injectAtomValue, injectEffect, injectStore } from '@zedux/react'

const userAtom = atom('user', () => {
  const user$ = injectAtomValue(userStreamAtom)
  const store = injectStore(null)

  injectEffect(() => {
    const subscription = user$.subscribe(val => store.setState(val))

    return () => subscription.unsubscribe()
  }, [user$])

  return store
})
```

## Recap

- `injectEffect()` is a simple tool for running side effects on changes that trigger atom reevaluation. It's also good for managing cleanup.
- BUT you may not need `injectEffect()`.
- `when(store).receivesAction()` runs a side effect on every action.
- `when(store).stateChanges()` runs a side effect on every state change.
- `when(store).stateMatches()` runs a side effect when the store's new state passes the predicate function, but the old state did not.
- `when(store).subscription.unsubscribe()` cleans up the subscription.
- Zedux can handle every possible asynchronous flow, e.g. RxJS streams, generators, promises, sockets, etc

## Next Steps

Let's take a closer look at using [custom injectors](custom-injectors) to simplify managing side effects.
