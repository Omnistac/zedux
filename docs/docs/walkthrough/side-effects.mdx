---
id: side-effects
title: Side Effects
---

Zedux doesn't place any restrictions on how you manage asynchronous code. You can use promises, observables, sockets, generators, or any third-party library.

Zedux stores do not have middleware. Read more on that in the [Redux comparison](../about/redux-comparison). There are many other ways to manage side effects that avoid hijacking control from the store like middleware does.

We've learned how to use `injectEffect` to run side effects on state changes that cause atom reevaluations. We also learned in [the stores walkthrough](stores) that stores can take effects subscribers. We'll learn all about those here.

:::tip you will learn

- That you may not need `injectEffect`
- How to use effects subscribers
- Some utilities for conditionally running side effects

:::

## Render As You Fetch

Many of the best practices for managing side effects in React still apply with Zedux. If you've been following the React community, you've probably heard that `useEffect` is not a great pattern for most side effects - it's prone to race conditions and some of its quirks are unintuitive. The same applies for `injectEffect`.

When React suspense came out, we learned about a new pattern called "render-as-you-fetch". This boils down to putting side effects in event handlers instead of `useEffect`. That is boiling it pretty heavily, but let's see an example:

```tsx
const userAtom = atom('user', () => {
  const idStore = injectStore(1)
  const promiseRef = injectRef()

  if (!promiseRef.current) {
    promiseRef.current = fetch(`/users/${idStore.getState()}`)
      .then(data => data.json())
  }

  const setId = (newId: number) => {
    idStore.setState(newId)
    promiseRef.current = fetch(`/users/${newId}`).then(data => data.json())
  }

  return api(idStore).setExports({ setId }).setPromise(promiseRef.current)
})

function User() {
  const userData = useAtomValue(userAtom)
  const { setId } = useAtomInstance(userAtom).exports
  ...
}
```

Rather than using `injectEffect` to listen to a state update on `idStore`, we kick off the request immediately, in the `setId` callback. The state update will cause the `User` component to rerender, and when it does it will suspend again.

We'll learn more about suspense in [the suspense walkthrough](suspense).

:::tip
In general, side effects should be colocated with the state they manipulate. This is exactly what we do in React thanks to hooks and props. In Zedux, we can use injectors and exports.
:::

## `Syncing State`

A key piece of managing side effects well is having as few of them as possible. Here's a common situation you might find yourself in:

Ions are often used as selectors with better memoization capabilities. As such, they often transform state from one shape to another. You might be tempted to use `injectEffect` for this:

```ts
const sortUsers = list => [...list].sort((a, b) => a.name.localeCompare(b.name))

const sortedUsersAtom = ion('sortedUsers', () => {
  const usersList = injectAtomValue(usersAtom)
  const store = injectStore(sortUsers(usersList))

  injectEffect(() => {
    store.setState(sortUsers(usersList))
  }, [usersList])

  return store
})
```

This works but has a few imperfections:

- We set the initial state twice! Once on initial evaluation and once the first time the effect runs.
- We had to define the `sort` logic outside the ion so we can reuse it when setting the initial state and inside the effect.
- `injectEffect` runs the callback one tick later than the atom evaluation. This can be annoying to account for in tests.
- We call `sortUsers` every time this ion evaluates and discard the result every time except on the first evaluation. This can be fixed by using the function overload of `injectStore`, but that's much more verbose since it requires creating the store manually.

The fix is simple: Remove `injectEffect`! Remember that you can call `.setState()` on local stores during atom evaluation without triggering another evaluation. Let's refactor:

```ts
const sortedUsersAtom = ion('sortedUsers', () => {
  const usersList = injectAtomValue(usersAtom)
  const store = injectStore()

  // highlight-next-line
  store.setState([...usersList].sort((a, b) => a.name.localeCompare(b.name)))

  return store
})
```

This fixes every single problem. Zedux is very specifically designed to work like this. Take advantage of it!

:::tip
While updating a locally injected store during evaluation is good, updating stores in other atom instances during evaluation is not recommended. This is because atom instances can be created during render, and React doesn't like it when components update while another component is rendering.
:::

But now. We did introduce a new potential problem: What if we had other dependencies in this atom? We'd be spreading and sorting the users list every single time this atom reevaluates as a result of any of those dependencies changing. Well. You won't believe this ... but Zedux actually has yet another superpower:

## `injectWhy()`

This little beast returns an array of [reasons](../api/types/EvaluationReason) that tell you why the current atom is evaluating ðŸ¤¯. Yes. ðŸ¤¯.

The list is empty on initial evaluation. After that, every reason in the list has a `sourceKey` field that gives the unique key, if any, of the dependency that caused the update. We can use this to determine if the current evaluation is the initial evaluation or was caused by a specific dependency updating:

```ts
const sortedUsersAtom = ion('sortedUsers', () => {
  // highlight-next-line
  const usersInstance = injectAtomInstance(usersAtom)
  const usersList = injectAtomValue(usersInstance)
  const store = injectStore()
  const reasons = injectWhy()

  // only set state if this is the initial evaluation or this evaluation was at
  // least partially caused by usersInstance:
  // highlight-next-line
  if (
    !reasons.length ||
    reasons.some(reason => reason.sourceKey === usersInstance.id)
  ) {
    store.setState([...usersList].sort((a, b) => a.name.localeCompare(b.name)))
  }

  return store
})
```

We'll learn more about `injectWhy` in [the dev tools walkthrough](../advanced/dev-tools).

## Odd-Looking Actions

Zedux' store composition model works by making actions themselves composable objects called ActionChains. The ActionChain contains needed metadata for Zedux to perform its store composition magic. ActionChains consist of any number of "meta nodes" with the wrapped action being the last node in the chain.

We'll go over the specifics of Zedux' store composition model in [the store composition guide](../advanced/store-composition). For now you just need to know that, depending on your store setup, you may see these ActionChain objects as the `action` property in your effects handlers. Zedux doesn't unwrap the action because sometimes you will need to observe the metadata the action is wrapped in.

If you don't care about the metadata, you can get the wrapped action with [`removeAllMeta`](/not-done)

```ts
import { removeAllMeta, when } from '@zedux/react'

store.subscribe((newState, oldState, actionChain) => {
  const action = removeAllMeta(actionChain)
})
```

## Observables

Zedux stores are a type of observable. They can be passed directly to [RxJS](https://github.com/ReactiveX/rxjs)'s `from()` to create full-fledged streams of state:

```ts
const filterUsersAtom = atom('filterUsers', 'User Joe')

const instance = ecosystem.getInstance(filterUsersAtom)
const state$ = from(instance.store)

const subscription = state$
  .pipe(filter(state => state.length >= 3))
  .subscribe(currentState => {
    fetchUsers({ filter: currentState })
  })
```

You'll often want the first emission to be the current state. For that, the following pattern can be helpful:

```ts
import { defer, from, merge, of } from 'rxjs'

export const getState$ = <T>(store: Store<T>) =>
  defer(() => merge(of(store.getState()), from(store)))
```

There are many ways that the extreme flexibility of RxJS and Zedux work together beautifully. For example, any atom's value can be an observable:

```ts
import { atom } from '@zedux/react'
import { of } from 'rxjs'

const observableValue = atom('observableValue', of('hello, world'))
```

This can be useful for taking advantage of Zedux' caching abilities to share observable references.

You can also export an observable from any atom:

```ts
import { api, atom, injectMemo } from '@zedux/react'
import { from } from 'rxjs'

const usersStreamAtom = atom('usersStream', () => {
  const users$ = injectMemo(() => from(streamUsers()), [])

  return api().setExports({
    users$,
  })
})
```

Handling observable subscriptions is easy with `injectEffect()`:

```ts
import { atom, injectAtomValue, injectEffect, injectStore } from '@zedux/react'

const userAtom = atom('user', () => {
  const user$ = injectAtomValue(userStreamAtom)
  const store = injectStore(null)

  injectEffect(() => {
    const subscription = user$.subscribe(val => store.setState(val))

    return () => subscription.unsubscribe()
  }, [user$])

  return store
})
```

## Action Streams

One of the superpowers of Zedux stores is that they can be consumed as streams of actions. Call `store.actionStream()` to get an "observable"-like object that you can subscribe to to receive notifications for every action dispatched to the store.

This observable-like object is compatible with RxJS' `from()`:

```tsx
import { from } from 'rxjs'
import { filter } from 'rxjs/operators'
import { atom, actionFactory } from '@zedux/react'

const updateRow = actionFactory<RowUpdateEvent>('updateRow')
const messageBusAtom = atom('messageBus', null)

function BigGrid() {
  const busInstance = useAtomInstance(messageBusAtom)
  const gridRef = useRef()

  useEffect(() => {
    // highlight-next-line
    const subscription = from(busInstance.store.actionStream())
      .pipe(filter(action => action.type === updateRow.type))
      .subscribe(action =>
        gridRef.current.updateRow(action.payload.rowId, action.payload)
      )

    return () => subscription.unsubscribe()
  }, [])

  return <ThirdPartyGridComponent ref={gridRef} />
}
```

## Recap

- `injectEffect()` is a simple tool for running side effects on changes that trigger atom reevaluation. It's also good for managing cleanup.
- BUT you may not need `injectEffect()`.
- `injectWhy()` can help reduce side effects.
- Stores can be consumed directly as streams of state or as streams of actions via `store.actionStream()`.
- Zedux can handle every possible asynchronous flow, e.g. RxJS streams, generators, promises, sockets, etc.

## Next Steps

Let's take a closer look at using [custom injectors](custom-injectors) to simplify managing side effects.
