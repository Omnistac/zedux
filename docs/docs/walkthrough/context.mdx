---
id: context
title: Context
---

The atomic model naturally fixes all the problems with React context. In Zedux, we can use React context with all of its benefits and none of its downsides.

The important philosophy here is that Zedux uses [React context for Dependency Injection, not State Management](https://blog.testdouble.com/posts/2021-03-19-react-context-for-dependency-injection-not-state/). That article is an excellent breakdown of this technique.

## Simple Example

```tsx live ecosystemId=context/simple resultVar=Parent2
const providedAtom = atom('provided', 'the state!')

function Child() {
  const instance = useAtomConsumer(providedAtom)
  const [state, setState] = useAtomState(instance)

  return (
    <>
      <div>Child State (subscribed): {state}</div>
      <button onClick={() => setState('new state!')}>Change</button>
    </>
  )
}

function Parent() {
  const instance = useAtomInstance(providedAtom)

  return (
    <AtomInstanceProvider instance={instance}>
      <div>Parent State (not subscribed): {instance.store.getState()}</div>
      <Child />
    </AtomInstanceProvider>
  )
}

function Parent2() {
  return <Parent />
}
```

## Providing

An atom instance can be provided over React context via [`<AtomInstanceProvider>`](../api/components/AtomInstanceProvider).

```tsx
import { AtomInstanceProvider, useAtomInstance } from '@zedux/react'

function Parent() {
  const instance = useAtomInstance(myAtom)

  return (
    <AtomInstanceProvider instance={instance}>
      <Child />
    </AtomInstanceProvider>
  )
}
```

### Multiple Instances

To provide instances of multiple atoms from the same component, you could nest a bunch of `<AtomInstanceProvider>`s. But that isn't very aesthetically pleasing now, is it.

To this end, `AtomInstanceProvider` accepts an `instances` prop, whose value is an array of instances to provide. Only provide either an `instance` or an `instances` prop, not both.

```tsx
return (
  <AtomInstanceProvider instances={[instanceA, instanceB]}>
    {children}
  </AtomInstanceProvider>
)
```

## Consuming

Consume provided instances with [`useAtomConsumer`](../api/hooks/useAtomConsumer)

```ts
import { useAtomConsumer } from '@zedux/react'

function Child() {
  const instance = useAtomConsumer(myAtom)
  ...
}
```

### If an Instance Wasn't Provided

If a component uses `useAtomConsumer` but no instance was provided by any parent, an empty object will be returned.

```ts
const instance = useAtomConsumer()
instance.invalidate() // error! instance.invalidate is not a function
```

TypeScript users will be warned of this. But to get around it, you'd have to put checks before everything you try to do with that instance. This isn't very useful. In fact, it's downright annoying.

Fortunately (on purpose), `useAtomConsumer` has two overloads that help with this:

#### Case #1: I want a default atom instance to be created, if none was provided.

You can provide an array of params to `useAtomConsumer`. These params must match the params of the atom. If no atom instance was provided, Zedux will use the passed default params to locate an existing atom instance or create a new instance if it doesn't exist yet.

```ts
const instance = useAtomConsumer(myAtom, ['default instance params'])
instance.invalidate() // all good! Even TS is happy
```

If the atom doesn't take params, you must still pass an empty array for Zedux to find/create a default instance.

```ts
const paramlessInstance = useAtomConsumer(myAtom, [])
instance.invalidate() // ðŸ˜Š
```

#### Case #2: I don't ever want an instance to not be provided. Throw an error if I forget!

Instead of an array of default parameters, you can pass `true` as the second param to `useAtomConsumer`. This tells Zedux to throw an error if no atom instance was provided.

```ts
const instance = useAtomConsumer(myAtom, true)
instance.invalidate() // all good again! TS smiles upon you
```

#failfast

## Subscribing

The amazing thing about using atoms for React context is that neither the providing nor consuming component subscribes to the atom instance by default. This gives you full control over rerenders.

Any component can set the state of the atom without subscribing to the state itself. And, of course, any component can subscribe itself to the atom instance using [`useAtomValue`](../api/hooks/useAtomValue) or similar.

```tsx
function Parent() {
  const instance = useAtomInstance(myAtom) // doesn't subscribe
  const value = useAtomValue(instance) // subscribes
  ...
}

function Child() {
  const instance = useAtomConsumer(myAtom, []) // doesn't subscribe
  const value = useAtomValue(instance) // subscribes
  ...
}
```

## Using Selectors

A common pattern is to pass the provided atom instance to [`useAtomSelector`](../api/hooks/useAtomSelector) to limit component rerenders.

```tsx
function Child() {
  const instance = useAtomConsumer(myAtom, []) // doesn't subscribe

  // subscribes, but only causes a rerender when `someField` changes.
  const someField = useAtomSelector(instance, ({ someField }) => someField)
}
```

## Recap

- Atom instances can be provided over React context via [`<AtomInstanceProvider>`](../api/components/AtomInstanceProvider).
- Atom instances can be consumed from React context via [`useAtomConsumer`](../api/hooks/useAtomConsumer).
- `useAtomConsumer(myAtom, [...defaultParams])` creates an atom instance with `defaultParams` if no instance was provided.
- `useAtomConsumer(myAtom, true)` throws an error if no atom instance was provided.
- You can subscribe any component to an atom instance by using [`useAtomValue`](../api/hooks/useAtomValue) or any other hook that creates a [dynamic graph dependency](../api/glossary#dynamic-graph-dependency).
- `useAtomSelector` will only rerender the component when the selector result changes.

## Next Steps

Let's continue exploring advanced React usage by looking at [React suspense](suspense).
