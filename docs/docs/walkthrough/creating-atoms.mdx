---
id: creating-atoms
title: Creating Atoms
---

Atoms are extremely flexible and can be configured in many ways for many different situations.

:::tip you will learn
How to:

- Configure atoms
- Use stores to give an atom control over its own state
- Use injectors to fine-tune an atom's behavior
- Export values from an atom
- Make atoms trigger React suspense

:::

## Atom Config

Many aspects of an atom's behavior can be configured. The `atom()` factory can take a config object as the 3rd parameter.

```ts
import { atom } from '@zedux/react'

atom('foo', 'initial value', {
  flags: ['async', 'electron'],
  maxInstances: 10,
  ttl: 1000 * 60 * 60,
})
```

This config object has many useful properties. We'll look at some of these now. See [`atom()`](../api/factories/atom) for the full rundown.

### TTL

When an atom instance is no longer used, we sometimes want to destroy it - allowing its data to be garbage collected.

By default, standard atoms live forever. But they can be given a `ttl` to configure how long instances should stick around when they're no longer in use.

```ts
const zombieAtom = atom('zombie', null, {
  // keep stale zombieAtom instances in memory for 10 minutes:
  ttl: 1000 * 60 * 10,
})
// if anyone uses the instance within 10 minutes, cleanup is cancelled
```

`ttl` can be set to `0` to clean up instances immediately.

### Max Instances

Complementary to `ttl`, `maxInstances` specifies the largest ideal cache size. If more instances than this "maximum" are created, Zedux will start cleaning them up automatically when they go stale, ignoring `ttl`.

No instances will ever be cleaned up while still in use. For example, say `maxInstances` is 2 and `ttl` is 1 minute:

```ts
const fooAtom = atom('foo', (id: string) => id, {
  maxInstances: 2,
  ttl: 60000,
})
```

Now say I end up using 3 instances at once:

```ts
useAtomValue(fooAtom, ['a'])
useAtomValue(fooAtom, ['b'])
useAtomValue(fooAtom, ['c'])
```

All 3 of those instances can live forever, as long as they're still in use. But as soon as one instance becomes stale, it will be cleaned up immediately - `ttl` will be ignored.

Now there are only 2 instances, which is within the `maxInstances`. The next instance to be cleaned up will respect `ttl`, sticking around for a minute before being destroyed.

Remember that atoms live forever, if no `ttl` is specified. In this case, `maxInstances` can be used to only clean up excess instances, allowing all others to live forever.

## Stores

Every instance of every atom creates a light-weight [Zedux store](../api/classes/Store). Stores manage state and serve as a message bus for running side effects based on dispatched actions or state changes.

Atoms create most stores for you. But you can easily create them manually:

```ts
import { createStore } from '@zedux/react'

const myStore = createStore()
```

Stores have lots of cool features that we'll look at in [the stores walkthrough](stores). For now, just remember that every atom instance has an underlying store.

## Injectors

Most atoms will make use of injectors. Injectors allow us to safely manage an atom's side effects, memoization, dependency injection, and lots more. Some injectors return helpful utility functions or help with debugging.

Injectors are inspired by React hooks. Using them should feel similar to using hooks. Like hooks, injectors should only be used at the top level of atom evaluators - outside any if statements or loops.

We'll look at some of the most common injectors here.

### `injectStore`

Creates a store. The returned store is a stable reference; like a React ref, it will not change on subsequent evaluations. This means you can then return the store from the evaluator function

The first parameter can be either the initial state of the store or a function that returns a store.

```ts
import { atom, injectStore } from '@zedux/react'

const storeAtom = atom('store', () => {
  const store = injectStore('initial state!')

  return store // Store is a stable reference; we can return it here.
})
```

Notice that we returned the store. This is important! Zedux automatically creates a store for every atom instance **unless** you return a store from the evaluator function. This essentially tells Zedux, "Don't create a store for me; I created my own. Use this one."

:::important
When returning a store from an evaluator, ensure that the exact same store reference is returned every time the atom evaluates - e.g. by using `injectMemo` or `injectStore`.
:::

`injectStore`'s second parameter is a config object. It can currently take one property - `shouldSubscribe` - a boolean indicating whether this atom instance should subscribe to this store. Default is `true`, meaning state updates on the injected store will trigger a reevaluation of the current atom instance.

```ts
// every time this store's state changes, this evaluator will rerun:
const store = injectStore(initialState)

// this store will never cause this evaluator to rerun:
const nonSubscribingStore = injectStore(initialState, {
  shouldSubscribe: false,
})
```

:::tip
Zedux stores can be either zero-config or reducer-driven. Because of this,`injectStore` is the injector equivalent of both `useState` and `useReducer`. You'll probably use it a lot.
:::

### `injectEffect`

The injector equivalent of React's `useEffect`. Runs a deferred side effect every time its dependencies change.

```ts
const store = injectStore({ status: 'loading', data: null, error: null })

injectEffect(() => {
  fetch('/api/blog-posts')
    .then(async data => {
      store.setState({ status: 'success', data: await res.json() })
    })
    .catch(err => {
      store.setState({ status: 'error', error: err })
    })
}, []) // no dependencies; side effect will only run once

return store
```

Return a cleanup function to cancel side effect execution and destroy resources created during the side effect.

```ts
const rxjs$ = injectAtomValue(rxjsAtom)

injectEffect(() => {
  const subscription = rxjs$.subscribe(...)

  return () => subscription.unsubscribe()
}, [rxjs$])
```

Every time the `rxjs$` reference changes, the previous effect will be cleaned up and the effect will rerun with the new reference.

### `injectMemo`

The injector equivalent of React's [`useMemo`](https://reactjs.org/docs/hooks-reference.html#usememo). Used to maintain stable references across evaluations and to prevent expensive calculations from re-running unnecessarily.

```ts
const memoizedValue = injectMemo(() => computeExpensiveValue(a, b), [a, b])
```

### `injectAtomGetters`

Returns a special [AtomGetters](../api/types/AtomGetters) object with `ecosystem`, `get`, `getInstance`, and `select` properties. These can be used to get atom instances, atom instance values, and run [AtomSelectors](../api/types/AtomSelector). Unlike injectors, AtomGetters can be used in loops or even asynchronously:

```ts
const sumAtom = atom('sum', (a: number, b: number) => a + b)

const someAtom = atom('some', () => {
  const { get } = injectAtomGetters()
  const sum = get(sumAtom, [1, 2]) // 3
})
```

When used synchronously during atom evaluation (like we did here), `get`, `getInstance`, and `select` update the atom instance's dependency graph dynamically. When used asynchronously, AtomGetters will not update the dependency graph; they simply return the value. (We'll cover ways to asynchronously update an atom instance's dependency graph [later](/not-done))

## Atom Api

Some operations don't fit well into the injector paradigm. Injectors, like hooks, should be composable and usable multiple times throughout an atom evaluator and other injectors. But atoms have a few one-off operations - operations that should only be performed once. For these situations, we use an AtomApi.

To create an AtomApi, we simply wrap the atom instance's state in a call to `api()`:

```ts
import { api, atom } from '@zedux/react'

const myAtom = atom('my', () => 'initial state') // before
const myAtom = atom('my', () => api('initial state')) // after
```

This works with stores too:

```ts
const myAtom = atom('my', () => {
  const store = injectStore()

  return store // before
  return api(store) // after
})
```

So now then ... what can an AtomApi do?

### Exports

Zedux atoms can export anything via an AtomApi:

```tsx live ecosystemId=creating-atoms/exports resultVar=App
const counterAtom = atom('counter', () => {
  const store = injectStore(0)

  // Expose methods
  return api(store).setExports({
    decrement: () => store.setState(state => state - 1),
    increment: () => store.setState(state => state + 1),
  })
})

function App() {
  const { decrement, increment } = useAtomInstance(counterAtom).exports
  const value = useAtomValue(counterAtom)

  return (
    <>
      <div>Counter: {value}</div>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
    </>
  )
}
```

:::important
Exports are constant! This means exported variables should be stable references. Zedux won't update them on subsequent evaluations. In this example, `increment` and `decrement` are not stable references, but they don't reference anything except the store, which is stable.
:::

Exports are extremely powerful. Exposing an atom's "public API" like this is just one of their uses. Since you can export anything, refs can be used to great effect:

```tsx
const gridAtom = atom('grid', () => {
  const gridApiRef = injectRef()

  // this atom provides universal access to the grid api once it's been set:
  return api().setExports({ gridApiRef })
})

function Grid() {
  const { gridApi } = useAtomInstance(gridAtom).exports

  // expose this grid component's api to the atom universe!
  return <ThirdPartyGridLibrary onLoad={api => (gridApiRef.current = api)} />
}
```

Another use is to export callbacks for implementing render-as-you-fetch patterns:

```tsx live ecosystemId=creating-atoms/export-callbacks resultVar=Age
const mockFetch = data =>
  new Promise(resolve => {
    setTimeout(() => resolve(data), 1000)
  })

const userNameAtom = atom('userName', () => {
  const store = injectStore('Joe')

  return api(store).setExports({
    toggleUser: () => {
      const fetchBob = store.getState() === 'Joe'
      store.setState('loading...') // lol, yes this is contrived
      mockFetch(fetchBob ? 'Bob' : 'Joe').then(val => store.setState(val))
    },
  })
})

function Age() {
  const { toggleUser } = useAtomInstance(userNameAtom).exports
  const userName = useAtomValue(userNameAtom)

  return (
    <>
      <div>Current User's Name: {userName}</div>
      <button onClick={toggleUser}>Change User</button>
    </>
  )
}
```

### Suspense

Atoms can be used as suspending resources in React. To suspend, we simply pass a promise to a returned AtomApi's `.setPromise()` method:

```ts
return api(val).setPromise(suspensePromise)
```

An atom that returns such an api will cause React to suspend until the promise resolves.

```tsx live ecosystemId=creating-atoms/api-set-promise resultVar=App
const mockFetch = data =>
  new Promise(resolve => {
    setTimeout(() => resolve(data), 1000)
  })

const ageAtom = atom('age', () => {
  const store = injectStore(undefined, { shouldSubscribe: false })

  // An inline side effect?? We'll cover this in the side effects walkthrough
  const promise = mockFetch(Math.floor(Math.random() * 100))
  promise.then(val => store.setState(val))

  return api(store).setPromise(promise)
})

function Age() {
  const instance = useAtomInstance(ageAtom)
  const age = useAtomValue(ageAtom)

  return (
    <>
      <div>The Time Traveller's Age: {age}</div>
      <button onClick={() => instance.invalidate()}>Refresh</button>
    </>
  )
}

function App() {
  return (
    <Suspense fallback={<div>Fetching Age...</div>}>
      <Age />
    </Suspense>
  )
}
```

You can also pass a promise directly to `api()`. This tells Zedux to take control over the atom's state and update it based on the promise.

```tsx live ecosystemId=creating-atoms/api-promise resultVar=App
const mockFetch = data =>
  new Promise(resolve => {
    setTimeout(() => resolve(data), 1000)
  })

const ageAtom = atom('age', () => {
  const promise = mockFetch(Math.floor(Math.random() * 100))

  // just pass the promise!
  return api(promise)
})

function Age() {
  const instance = useAtomInstance(ageAtom)

  // the promise result will be set as the state's `data` property.
  // You should recognize this if you know React Query.
  const { data } = useAtomValue(ageAtom)

  return (
    <>
      <div>The Time Traveller's Age: {data}</div>
      <button onClick={() => instance.invalidate()}>Refresh</button>
    </>
  )
}

function App() {
  return (
    <Suspense fallback={<div>Fetching Age...</div>}>
      <Age />
    </Suspense>
  )
}
```

We'll cover much more about suspense in [the suspense walkthrough](../walkthrough/suspense).

AtomApis have many more features that we'll cover eventually. Or check out the [AtomApi reference](../api/classes/AtomApi) for all the power.

## Ions

Ions are just atoms, but with a slightly different API. Ions are better suited for selector-type operations. Create them with the `ion` factory:

```ts
import { ion } from '@zedux/react'

const filteredTodosAtom = ion('filteredTodos', ({ get }, isDone: boolean) =>
  get(todosAtom).filter(todo => todo.isDone === isDone)
)
```

Ions are only slightly different from normal atoms. They receive a special, Zedux-supplied [AtomGetters](../api/types/AtomGetters) object as their first parameter. Any parameters after that are the actual params of the atom. You can also get the AtomGetters object in normal (non-ion) atoms using [`injectAtomGetters()`](../api/injectors/injectAtomGetters):

```ts
import { atom, injectAtomGetters } from '@zedux/react'

const filteredTodosAtom = atom('filteredTodoos', (isDone: boolean) => {
  const { get } = injectAtomGetters()

  return get(todosAtom).filter(todo => todo.isDone === isDone)
})
```

Note that in either of these examples, we could have used `injectAtomValue` instead of `get`. But `get` and all the AtomGetters have some extra spice. See the [AtomGetters doc page](../api/types/AtomGetters) for spiciness.

See [the `ion()` API](../api/factories/ion) for more info.

:::tip
**When should I use an ion instead of an atom?** You can make your own rules, but here are two possible viewpoints:

- Ions are like AtomSelectors (which we'll cover in the [selectors walkthrough](selectors)) in atom form - use them when you want selector-type functionality, but need more control over the memoization details or need to run side effects.
- Ions are higher-level atoms. High-level is good, so only use ions and ditch raw atoms.

You decide! Ions are just a tool that you can use how you see fit.
:::

## Recap

- `atom()` can take a config object.
- Atoms can be destroyed using `ttl` and/or `maxInstances`.
- All atom instances have an underlying store. You can create this store yourself or let Zedux create it for you.
- Injectors give you control over an atom's behavior - e.g. they can run side effects or memoize values.
- Exports can be attached to an atom via `api(value).setExports({ ... })`
- Atoms can cause React to suspend by passing a stable promise to `api(value).setPromise(promise)`.
- Ions specialize in selector-type operations

Next up we'll cover more ways to [consume atoms](using-atoms).
