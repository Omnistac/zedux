---
id: using-atoms
title: Using Atoms
---

Atoms can be consumed and composed in many ways.

:::tip you will learn

- What an atom instance looks like
- The basics of Zedux' graph model and how to control it
- The difference between static and dynamic graph edges
- How to use hooks and injectors to create different types of graph edges.

:::

## Dynamic Hooks & Injectors

Some hooks create a [dynamic graph dependency](../api/glossary#dynamic-graph-dependency) on the atom. This means that when the atom instance's store's state changes, components that use these hooks will rerender.

All these hooks have equivalent injectors for use in atoms. When the injected atom instance's state changes, atoms that use these injectors will reevaluate.

### `useAtomValue`

The simplest way to consume an atom's state. Returns an atom instance's value. Creates a dynamic graph dependency on the resolved atom instance. This means that the component will rerender when the resolved atom instance's state changes.

```ts
function MyComponent() {
  // whenever these atom instances update, this component will rerender
  const currentState = useAtomValue(myAtom)
  const paramless = useAtomValue(withParams, ['param 1', 'param 2'])
  ...
}
```

#### `injectAtomValue`

The injector equivalent of `useAtomValue`. Returns an atom instance's value. Creates a dynamic graph dependency on the resolved atom instance. This means that the current atom instance will reevaluate when the resolved atom instance's state changes.

```ts
const dependentAtom = atom('dependent', () => {
  // whenever myAtom's state changes, this dependentAtom will reevaluate
  const currentState = injectAtomValue(myAtom)
  ...
})
```

This injector is your main tool for Dependency Injection.

### `useAtomState`

`useAtomState()` is similar to React's `useState()` hook.

```tsx
import { useAtomState } from '@zedux/react'

function App() {
  // whenever these atom instances update, this component will rerender
  const [state, setState] = useAtomState(myAtom)
  const [withParams, setWithParams] = useAtomState(anotherAtom, ['a param'])
  ...
}
```

`setState` is a reference to the `setState` function on the atom instance, which wraps the `setState` function of the instance's store. It functions like a React state setter.

To get a reference to `setState` without creating a dynamic dependency, use [`useAtomInstance()`](#useatominstance).

#### `injectAtomState`

The injector equivalent of `useAtomState` - for use in atoms.

```ts
const userAtom = atom('user', () => {
  const [auth, setAuth] = injectAtomState(authAtom)
  ...
})
```

### `useAtomSelector`

Runs an AtomSelector. Ensures that the component only reevaluates when the selector's result changes. Similar to Redux' [`useSelector()`](https://react-redux.js.org/api/hooks#useselector).

```tsx live ecosystemId=using-atoms/useAtomSelector resultVar=SelectorSerenity
const countersAtom = atom('counters', () => ({
  a: 0,
  b: 0,
}))

function SelectorSerenity() {
  // whenever countersAtom's state changes, this selector will run.
  // If the selector returns a new value, this component will rerender.
  const counterA = useAtomSelector(({ get }) => get(countersAtom).a)
  const instance = useAtomInstance(countersAtom)
  const { setState } = instance

  return (
    <>
      <div>Counter A: {counterA}</div>
      <button onClick={() => setState(val => ({ ...val, a: val.a + 1 }))}>
        Increment Counter A (triggers rerender)
      </button>
      <div>Counter B: {instance.getState().b}</div>
      <button onClick={() => setState(val => ({ ...val, b: val.b + 1 }))}>
        Increment Counter B (no rerender)
      </button>
    </>
  )
}
```

If the AtomSelector takes params, pass those after the selector itself:

```ts
const getUsersByRole = ({ get }: AtomGetters, role: string) =>
  get(usersAtom).filter(user => user.role === role)

function App() {
  const adminUsers = useAtomSelector(
    getUsersByRole,
    // highlight-next-line
    'admin',
  )

  const guestUsers = useAtomSelector(
    getUsersByRole,
    // highlight-next-line
    'guest',
  )
  ...
}
```

Selectors are so cool they get [their own walkthrough](selectors).

:::tip
Note that while you can use a selector memoizing library like [reselect](https://github.com/reduxjs/reselect), it isn't necessary in Zedux. If more sophisticated selector behavior is required, use [ions](../api/classes/Ion) (or any atom).

Ion's are composable, memoized by default, and the cache size and ttl are configurable too - all because they're atoms. The memoization details can even be handled more granularly using [`injectMemo()`](../api/injectors/injectMemo).
:::

#### `injectAtomSelector`

The injector equivalent of `useAtomSelector` - for use in atoms:

```ts
const userAtom = atom('user', () => {
  const token = injectAtomSelector(({ get }) => get(authAtom).token)
  ...
})
```

## Static Hooks & Injectors

The following hooks/injectors do not cause rerenders/reevaluations when the resolved atom instance's state changes. They do, however, register static graph dependencies on the resolved atom instance. This means that Zedux will prevent the instance from being cleaned up as long as the dependent depends on it.

### `useAtomConsumer`

Used in conjuction with `useAtomInstance` to consume atom instances provided over React context.

:::note
This hook does not have an injector equivalent! There is no such thing as `injectAtomConsumer`.
:::

### `useAtomInstance`

Returns a reference to an instance of the atom. Atom instances have many features.

```ts
import { useAtomInstance, useAtomValue } from '@zedux/react'

function MyComponent() {
  const instance = useAtomInstance(myAtom)
  const value = useAtomValue(instance) // useAtomValue accepts an instance
}
```

In this example, when we use `useAtomInstance()`, it creates a static dependency. This means MyComponent will not rerender when the instance's state changes. However, we then use another hook - `useAtomValue()` - to make the dependency dynamic.

`useAtomInstance()` can also be used in conjunction with `useAtomConsumer()` to provide an instance over React context, so deeply nested children don't need to know the params of a specific atom instance they want to reuse:

```tsx
import {
  AtomInstanceProvider,
  useAtomConsumer,
  useAtomInstance
} from '@zedux/react'

function Parent() {
  const instance = useAtomInstance(myAtom, ['some', 'params'])

  return (
    <AtomInstanceProvider instance={instance}>
      <Child />
    </AtomInstanceProvider>
  )
}

function Child() {
  const instance = useAtomConsumer(myAtom) // no need to pass params here
  const value = useAtomValue(instance) // subscribe to the instance
  ...
}
```

:::note
While `useAtomConsumer()` creates a static dependency, `useAtomValue()` makes it dynamic.
:::

Instances also expose lots of extra, low-level functionality. We'll cover more of that in the [instances walkthrough](/not-done).

#### `injectAtomInstance`

The injector equivalent of `useAtomInstance` - for use in atoms.

### `useEcosystem`

Returns an [ecosystem object](../api/classes/Ecosystem) that can be used to dynamically create/retrieve atom instances. We'll cover ecosystems in-depth [later](ecosystems) but for now: Ecosystems have a `getInstance` method. You can use this to preload atoms, e.g. for kicking off Render-as-You-Fetch React suspense flows.

```tsx
import { useEcosystem } from '@zedux/react'

function BlogPostThumbnail({ id }: { id: string }) {
  const ecosystem = useEcosystem()

  return (
    <button
      onClick={() => {
        // lazy load the blogPostAtom (Render-as-You-Fetch)
        ecosystem.getInstance(blogPostAtom, [id])
      }}
    >
      View Post
    </button>
  )
}
```

Calling the loader function instantiates the atom, if no instance has been created for the given params yet, and returns the instance.

#### `injectAtomGetters`

The injector equivalent of `useEcosystem` - for use in atoms. Returns an [AtomGetters](../api/types/AtomGetters) object which has an `ecosystem` property. Besides `ecosystem`, the other AtomGetters (`get`, `getInstance`, and `select`) can also be used to dynamically register graph dependencies when called during synchronous atom or [AtomSelector](../api/types/AtomSelector) evaluation.

## Instances

You'll often interact with [atom instances](../api/classes/AtomInstance) directly. Atom instances have many useful properties.

### `.store`

A reference to the underlying store of this atom instance. Don't use this directly if you can avoid it. That said, there are many cases where it can be useful. We'll cover some of these in the [side effects walkthrough](side-effects).

### `.setState()`

The most common way to set an atom instance's state. The tuple returned by `useAtomState` contains a reference to this function. `.setState()` accepts either the new state or a function that receives the current state and returns the new state.

```ts
const instance = getInstance(myAtom)
instance.setState(newState)
instance.setState(currentState => newState)
```

This `.setState()` function is **not** a reference to the instance's store's `.setState()` function. `instance.setState()` is a wrapper around `instance.store.setState()`. This is important because `instance.setState()` allows interceptors to run before calling `.store.setState()`.

:::important
Always prefer calling `instance.setState()` over `instance.store.setState()`
:::

### `.dispatch()`

The recommended way to dispatch actions to the instance's store.

```ts
const instance = getInstance(myAtom)
instance.dispatch({ type: 'some-type' })
```

Similar to `instance.setState()`, `instance.dispatch()` is a wrapper around `instance.store.dispatch()`. The difference is that `instance.dispatch()` allows dispatch interceptors to run before calling `.store.dispatch()`.

:::important
Always prefer calling `instance.dispatch()` over `instance.store.dispatch()`
:::

### `.exports`

A reference to the exports of the atom.

```ts
const instance = getInstance(myAtom)
const { someExport } = instance.exports
```

These exports are constant - they are set the first time an atom instance evaluates and they will not change on subsequent evaluations.

### `.invalidate()`

Call this to force the atom instance to reevaluate. Outside of testing, there shouldn't be a need for this. Unless you know what you're doing, avoid impure or mutation-oriented patterns that require you to manually invalidate atom instances.

```tsx live ecosystemId=using-atoms/invalidate resultVar=RandomNum
const randomNumAtom = atom('randomNum', () => Math.floor(Math.random() * 100))

function RandomNum() {
  const instance = useAtomInstance(randomNumAtom)
  const value = useAtomValue(randomNumAtom)

  return (
    <>
      <div>Random Number: {value}</div>
      <button onClick={() => instance.invalidate()}>Re-roll</button>
    </>
  )
}
```

### Hooks and Injectors

Most hooks and injectors that return an atom instance create a static graph dependency on that instance. To turn that into a dynamic dependency (one that'll cause rerenders/reevaluations when the instance's state updates), we need to pass the instance to another hook/injector.

It just so happens that instances can be passed directly to `useAtomSelector`, `useAtomState`, `useAtomValue`, and their corresponding injectors. Yep, we've already seen all of those ðŸ’ª.

```ts
function App() {
  const instance = useAtomInstance(myAtom) // static dep ðŸ˜¢
  const val = useAtomValue(instance) // dynamic dep ðŸŽ‰
  ...
}
```

## Recap

- Every atom instance has an underlying Zedux store.

- `useAtomSelector`, `useAtomState`, `useAtomValue`, and their corresponding injectors all create dynamic graph dependencies that trigger updates when the resolved atom instance's state changes.

- `useAtomInstance` and `useAtomConsumer` can be used together to provide and consume atom instances over React context.

- `useEcosystem` returns an ecosystem object whose `getInstance` method can preload or lazy-load atoms.

- Atom instances have `.store`, `.setState`, `.dispatch`, `.exports`, and `.invalidate` properties that can be used directly.

- `useAtomSelector`, `useAtomState`, `useAtomValue`, and their corresponding injectors all accept atom instances too.

## Next Steps

Now we know how to create and consume atoms. Next we'll learn how to create and configure isolated atom environments using [ecosystems](ecosystems).
