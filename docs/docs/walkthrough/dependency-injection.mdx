---
id: dependency-injection
title: Dependency Injection
---

import { LiveEditor } from '../LiveEditor'

React creates a perfect environment for Inversion of Control. Yet this amazing technique is underused. Zedux aims to help bring Dependency Injection (DI) to the forefront of React workflows.

:::tip you will learn
How to:

- "Inject" atoms in other atoms to create a dependency graph
- Create an overridden version of an atom
- Swap out atoms and their overrides

:::

There are 2 parts to DI:

- Injection
- Overrides

## Injection

Any atom can be injected into any other atom.

```ts
import { atom, injectAtomValue } from '@zedux/react'

const atomA = atom('a', 'a')
const atomB = atom('b', () => {
  const a = injectAtomValue(atomA)

  return a + 'b' // 'ab'
})
```

### AtomGetters

The word "inject" helps you know that there is Dependency Injection going on. But we can also "inject" dependencies using [AtomGetters](../api/types/AtomGetters) like [ion's `get`](../api/types/AtomGetters#get):

```ts
import { atom, ion } from '@zedux/react'

const usersAtom = atom('users', ['Joe', 'Sally', 'Jim', 'Ruth'])

const sortedUsersAtom = ion('sortedUsers', ({ get }) => {
  return [...get(usersAtom)].sort()
})
```

`get` here is doing the exact same thing as `injectAtomValue`. All AtomGetters have injector equivalents, but AtomGetters are more dynamic.

:::tip
Since `get` and the other AtomGetters aren't injectors, they can be used in if statements, loops, and even asynchronously. When used asynchronously, they don't create dependencies.
:::

```ts
const myIon = ion('my', ({ get }) => {
  // this `get` creates a dependency - this ion will update when atom1 changes
  const dynamicValue = get(atom1)

  injectEffect(() => {
    // this `get` doesn't create any dependency
    const staticValue = get(atom2)
  }, [])
})
```

The AtomGetters are:

- `get` - returns the value of an atom instance. Registers a [dynamic dependency](../api/glossary#dynamic-graph-dependency) when called synchronously during atom evaluation. Injector equivalent: `injectAtomValue`.

- `getInstance` - returns an atom instance. Registers a [static dependency](../api/glossary#static-graph-dependency) when called synchronously during atom evaluation. Injector equivalent: `injectAtomInstance`.

- `select` - returns the selection result. Can register both kinds of dependencies. We'll cover these next in the [selectors walkthrough](selectors). Injector equivalent: `injectAtomSelector`

- `ecosystem` - a reference to the current [ecosystem](../api/classes/Ecosystem). Ecosystems have `get`, `getInstance`, and `select` methods. These never register dependencies.

Use `ecosystem`'s methods to get static values without creating dependencies during atom evaluation.

```ts
const myIon = ion('my', ({ ecosystem, get }) => {
  // creates a dependency
  const dynamicValue = get(atom1, ['some', 'params'])

  // gets a static snapshot of atom2's current state
  const staticValue = ecosystem.get(atom2, ['param'])
})
```

### Instances as Params

As a general rule, all [atom params](../api/classes/AtomInstance#params) must be serializable. There is one exception: You can pass an atom instance to another atom instance. This is another form of "Dependency Injection".

<LiveEditor ecosystemId="dependency-injection/shout" resultVar="Shout">{`
const normalAtom = atom('normal', "I'm just a little, black rain cloud")\n
const shoutingAtom = atom(
  'shouting',
  (instance: AtomInstance<string>) => {
    const val = injectAtomValue(instance) // subscribe to updates\n
    return val.toUpperCase()
  }
)\n
function Shout() {
  const instance = useAtomInstance(normalAtom)
  const shout = useAtomValue(shoutingAtom, [instance]) // just pass the instance\n
  return <div>(In a Singing sort of voice): {shout}</div>
}
`}</LiveEditor>

When an atom instance receives another atom instance via params, it doesn't create any kind of dependency on that instance. This is usually fine: Whoever passed the instance is probably already registering their own dependency on the instance they're passing.

In this example, we passed the instance to `injectAtomValue` to create a dynamic dependency on the instance.

See [AtomInstance#params](../api/classes/AtomInstance#params) for more info.

### The Graph

Detour! You can [skip this section](#overrides). Proceed if ye dare:

As you use atoms, Zedux creates and updates a graph of atom dependencies. The nodes of the graph are atom instances and consumers of atom instances. The edges of the graph are relationships between atom instances and their consumers.

Zedux provides several methods to inspect and manipulate this graph.

When we "inject an atom", what we're really doing is instructing Zedux to create an edge on the graph. There are 8 different types of edges, based on these 3 edge flags:

- isExternal - whether the graph edge is between two atom instances or between an atom instance and something outside of Zedux - usually a React component.
- isExplicit - explicit edges are edges created and cleaned up manually, usually in a useEffect hook or injectEffect injector. There currently aren't any APIs to create these edges. We're working on it.
- isStatic - whether the dependent should be notified of updates to the dependency's state (causing a dependent atom instance to reevaluate or a dependent component to rerender).

Ignoring `isExplicit`, since there are no ways to create those edges currently, the 4 edge types you'll encounter are `external-static`, `external-dynamic`, `internal-static`, and `internal-dynamic`. There are many hooks and injectors for creating these 4 edge types:

- `injectAtomValue` - creates an `internal-dynamic` edge.
- `injectAtomState` - creates an `internal-dynamic` edge.
- `injectAtomSelector` - creates an `internal-dynamic` edge that will only cause reevaluations when the selector's returned value changes.
- `injectAtomInstance` - creates an `internal-static` edge.
- `useAtomValue` - creates an `external-dynamic` edge.
- `useAtomState` - creates an `external-dynamic` edge.
- `useAtomSelector` - creates an `external-dynamic` edge that will only cause rerenders when the selector's returned value changes.
- `useAtomInstance` - creates an `external-static` edge.

#### What's the point of a static edge?

Static edges don't trigger reevaluations or rerenders, so what's the point? There are 2 main reasons why static edges are important:

- They inform Zedux that someone is using the injected atom instance. As long as an atom instance has any graph edges, Zedux won't try to clean it up.
- If an atom instance is force-destroyed while it has static dependents, those dependents will be informed of the destruction and actually will schedule a reevaluation or rerender to create a new instance.

## Overrides

Now that we've got dependencies injected, we need a way to swap them out.

### Creating

Atoms have a [`.override()` method](../api/classes/Atom#override) which will create an exact clone of the atom, but with a different value.

```ts
const axiosAtom = atom('axios', axios)

const testAxiosAtom = axiosAtom.override({ post: jest.fn() })
```

You don't have to use `.override()`. You can create a clone manually. The only requirement is that the override has the same `key`:

```ts
const testAtom = atom('test', 'some state')
const testAtomOverride = atom('test', 'overridden state!', { ttl: 0 })
```

The nice thing about `.override()` for TS users is that it will tell you if the override doesn't match the overridden atom's type.

### Using

These overridden atoms can then be supplied to an `ecosystem` via the `overrides` field:

```tsx
function TestApp() {
  return (
    <EcosystemProvider id="test" overrides={[testAxiosAtom]}>
      <Routes />
    </EcosystemProvider>
  )
}
```

Now this test ecosystem will use `testAxiosAtom` everywhere `axiosAtom` is used:

```tsx
function Routes {
  const axios = useAtomValue(axiosAtom) // testAxiosAtom is used instead
  ...
}

const userAtom = ion('user', ({ get }) => {
  const axios = get(axiosAtom) // testAxiosAtom is injected instead
})
```

### Updating

Atom implementations can be swapped out dynamically using [`ecosystem.setOverrides()`](../api/classes/Ecosystem#setoverrides). This is an extremely powerful feature of Zedux' DI model.

<LiveEditor
  ecosystemId="dependency-injection/setOverrides"
  resultVar="Swapper"
>{`
const one = atom('common-key', () => 'Numero Uno')
const two = atom('common-key', () => 'I am the best')
const three = atom('common-key', () => 'Two is not the best')\n
function Swapper() {
  const ecosystem = useEcosystem()
  const state = useAtomValue(one)\n
  return (
    <>
      <div>Current State: {state}</div>
      <button onClick={() => ecosystem.setOverrides([one])}>Use One</button>
      <button onClick={() => ecosystem.setOverrides([two])}>Use Two</button>
      <button onClick={() => ecosystem.setOverrides([three])}>Use Three</button>
    </>
  )
}
`}</LiveEditor>

Use [`ecosystem.addOverrides()`](../api/classes/Ecosystem#addoverrides) and [`ecosystem.removeOverrides()`](../api/classes/Ecosystem#removeoverrides) to selectively update only certain overrides.

<LiveEditor
  ecosystemId="dependency-injection/addOverrides"
  resultVar="Overrider"
>{`
const original = atom('common-key', () => 'Pick Me')
const override = atom('common-key', () => 'No, Me')\n
function Overrider() {
  const ecosystem = useEcosystem()
  const state = useAtomValue(original)\n
  return (
    <>
      <div>Current State: {state}</div>
      <button onClick={() => ecosystem.addOverrides([override])}>Override</button>
      <button onClick={() => ecosystem.removeOverrides([override])}>
        Remove Override
      </button>
    </>
  )
}
`}</LiveEditor>

## Simple Example

<LiveEditor ecosystemId="dependency-injection/simple" resultVar="App">{`
const textAtom = atom('text', 'the text!')
const betterTextAtom = textAtom.override('better text!')\n
function Child() {
  const text = useAtomValue(textAtom)\n
  return <div>{text}</div>
}\n
function App() {
  return (
    <>
      <EcosystemProvider id="a">
        <Child />
      </EcosystemProvider>
      <EcosystemProvider id="b" overrides={[betterTextAtom]}>
        <Child />
      </EcosystemProvider>
    </>
  )
}
`}</LiveEditor>

## Recap

- Atoms can be "injected" into other atoms with various injectors and the AtomGetters.
- Instances can be passed as params to other atoms.
- Atom overrides can be created with `myAtom.override(newVal)`.
- Atoms can be overridden by setting the ecosystem's overrides.

## Next Steps

Let's kick Dependency Injection into high gear with [selectors](selectors).
