---
id: dependency-injection
title: Dependency Injection
---

import { LiveEditor } from '../LiveEditor'

React creates a perfect environment for Inversion of Control. Yet this amazing principle is often massively underused. Zedux aims to help bring Dependency Injection (DI) to the forefront of React workflows.

There are 2 parts to DI:

- Injection
- Overrides

## Injection

Any atom can be injected into any other atom.

```ts
const configAtom = atom('config', { apiUrl: 'example.com/api' })

const localStorageAtom = atom('localStorage', { ...localStorage })

const authAtom = ion('auth', ({ get }) => {
  const { apiUrl } = get(configAtom)
  const storage = get(localStorageAtom)

  return injectFetch(`${apiUrl}/auth`, storage.jwt)
})

const axiosAtom = ion('axios', ({ get }) => {
  const apiUrl = injectAtomSelector(configAtom, config => config.apiUrl)
  const { data } = get(authAtom)

  if (!data?.token) return null

  return axios.create({
    baseURL: apiUrl,
    headers: {
      Authorization: `Bearer ${data.token}`,
    },
  })
})

const userAtom = ion('user', ({ get }) => {
  const axios = get(axiosAtom)
  const store = injectStore()

  injectEffect(() => {
    if (!axios) return

    axios.get(`/user`).then(({ data }) => store.setState(data))
  }, [axios])

  return store
})
```

Here we used [ion's `get`](../api/types/IonGetUtils#get) to dynamically inject dependencies. We can also use any number of injectors, such as [`injectAtomValue()`](../api/injectors/injectAtomValue) or [`injectAtomInstance()`](../api/injectors/injectAtomInstance).

```ts
const authAtom = atom('auth', () => {
  const { apiUrl } = injectAtomValue(configAtom)
  const storage = injectAtomValue(localStorageAtom)

  return injectFetch(`${apiUrl}/auth`, storage.jwt)
})
```

But these have the caveats of being injectors - they can only be used at the top level of the atom evaluator function.

### Instances as Params

As a general rule, all [atom params](../api/classes/AtomInstance#params) must be serializable. There is one exception: You can pass an atom instance to another atom instance. This is another form of "Dependency Injection".

This is possible because all atom instances already have a unique, serialized [`keyHash`](../api/classes/AtomInstance#keyhash) that will simply be appended to the receiving atom's `keyHash`.

<LiveEditor resultVar="Shout">{`
const normalAtom = atom('normal', "I'm just a little, black rain cloud")\n
const shoutingAtom = atom(
  'shouting',
  (instance: AtomInstance<string>) => {
    const val = injectAtomValue(instance) // subscribe to updates\n
    return val.toUpperCase()
  }
)\n
function Shout() {
  const instance = useAtomInstance(normalAtom)
  const shout = useAtomValue(shoutingAtom, [instance]) // just pass the instance\n
  return <div>(In a Singing sort of voice): {shout}</div>
}
`}</LiveEditor>

When an atom instance receives another atom instance via params, it doesn't create any kind of dependency on that instance. This is usually fine: Whoever passed the instance is probably already registering their own dependency on the instance they're passing.

See [AtomInstance#params](../api/classes/AtomInstance#params) for more info.

### The Graph

Detour! You can [skip this section](#overrides). Proceed if ye dare:

As you use atoms, Zedux creates and updates a graph of atom dependencies. The nodes of the graph are atom instances and consumers of atom instances. The edges of the graph are relationships between atom instances and their consumers.

Zedux provides several methods to inspect and manipulate this graph.

When we "inject an atom", what we're really doing is instructing Zedux to create an edge on the graph. There are 8 different types of edges, based on these 3 edge flags:

- isExternal - whether the graph edge is between two atom instances or between an atom instance and something outside of Zedux - usually a React component.
- isAsync - async edges are edges created and cleaned up manually, usually in a useEffect hook or injectEffect injector. There currently aren't any APIs to create these edges. We're working on it.
- isStatic - whether the dependent should be notified of updates to the dependency's state (causing a dependent atom instance to reevaluate or a dependent component to rerender).

Ignoring `isAsync`, since there are no ways to create those edges currently, the 4 edge types you'll encounter are `external-static`, `external-dynamic`, `internal-static`, and `internal-dynamic`. There are many hooks and injectors for creating these 4 edge types:

- `injectAtomValue` - creates an `internal-dynamic` edge.
- `injectAtomState` - creates an `internal-dynamic` edge.
- `injectAtomSelector` - creates an `internal-dynamic` edge that will only cause reevaluations when the selector's returned value changes.
- `injectAtomInstance` - creates an `internal-static` edge.
- `useAtomValue` - creates an `external-dynamic` edge.
- `useAtomState` - creates an `external-dynamic` edge.
- `useAtomSelector` - creates an `external-dynamic` edge that will only cause rerenders when the selector's returned value changes.
- `useAtomInstance` - creates an `external-static` edge.

#### What's the point of a static edge?

Static edges don't trigger reevaluations or rerenders, so what's the point? There are 2 main reasons why static edges are important:

- They inform Zedux that someone is using the injected atom instance. As long as an atom instance has any graph edges, Zedux won't try to clean it up.
- If an atom instance is force-destroyed while it has static dependents, those dependents will be informed of the destruction and actually will schedule a reevaluation or rerender to create a new instance.

## Overrides

Now that we've got dependencies injected, we need a way to swap them out.

### Creating

Atoms have a [`.override()` method](../api/classes/Atom#override) which will create an exact clone of the atom, but with a different value.

```ts
const axiosAtom = atom('axios', axios)

const testAxiosAtom = axiosAtom.override({ post: jest.fn() })
```

You don't have to use `.override()`. You can create a clone manually. The only requirement is that the override has the same `key`:

```ts
const testAtom = atom('test', 'some state')
const testAtomOverride = atom('test', 'overridden state!', { ttl: 0 })
```

The nice thing about `.override()` for TS users is that it will tell you if the override doesn't match the overridden atom's type in any way.

### Using

These overridden atoms can then be supplied to an `ecosystem` via the `overrides` field:

```tsx
function TestApp() {
  return (
    <EcosystemProvider id="test" overrides={[testAxiosAtom]}>
      <Routes />
    </EcosystemProvider>
  )
}
```

Now this test ecosystem will use `testAxiosAtom` everywhere `axiosAtom` is used:

```tsx
function Routes {
  const axios = useAtomValue(axiosAtom) // testAxiosAtom is used instead
  ...
}

const userAtom = ion('user', ({ get }) => {
  const axios = get(axiosAtom) // testAxiosAtom is injected instead
})
```

### Updating

Atom implementations can be swapped out dynamically using [`ecosystem.setOverrides()`](../api/classes/Ecosystem#setoverrides). This is an extremely powerful feature of Zedux' DI model.

<LiveEditor resultVar="Swapper">{`
const one = atom('common-key', () => 'Numero Uno')
const two = atom('common-key', () => 'I am the best')
const three = atom('common-key', () => 'Two is not the best')\n
function Swapper() {
  const ecosystem = useEcosystem()
  const state = useAtomValue(one)\n
  return (
    <>
      <div>Current State: {state}</div>
      <button onClick={() => ecosystem.setOverrides([one])}>Use One</button>
      <button onClick={() => ecosystem.setOverrides([two])}>Use Two</button>
      <button onClick={() => ecosystem.setOverrides([three])}>Use Three</button>
    </>
  )
}
`}</LiveEditor>

Use [`ecosystem.addOverrides()`](../api/classes/Ecosystem#addoverrides) and [`ecosystem.removeOverrides()`](../api/classes/Ecosystem#removeoverrides) to selectively update only certain overrides.

<LiveEditor resultVar="Overrider">{`
const original = atom('common-key', () => 'Pick Me')
const override = atom('common-key', () => 'No, Me')\n
function Overrider() {
  const ecosystem = useEcosystem()
  const state = useAtomValue(original)\n
  return (
    <>
      <div>Current State: {state}</div>
      <button onClick={() => ecosystem.addOverrides([override])}>Override</button>
      <button onClick={() => ecosystem.removeOverrides([override])}>
        Remove Override
      </button>
    </>
  )
}
`}</LiveEditor>

## Simple Example

<LiveEditor resultVar="App">{`
const textAtom = atom('text', 'the text!')
const betterTextAtom = textAtom.override('better text!')\n
const betterEcosystem = ecosystem({ overrides: [betterTextAtom] })\n
function Child() {
  const text = useAtomValue(textAtom)\n
  return <div>{text}</div>
}\n
function App() {
  return (
    <>
      <EcosystemProvider>
        <Child />
      </EcosystemProvider>
      <EcosystemProvider ecosystem={betterEcosystem}>
        <Child />
      </EcosystemProvider>
    </>
  )
}
`}</LiveEditor>

## Recap

## Next Steps

Now that we've mastered the art of the atom, it's time to step into the low-levels and learn about [stores](stores).
