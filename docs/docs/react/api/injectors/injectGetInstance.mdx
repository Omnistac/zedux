---
id: injectGetInstance
title: injectGetInstance
---

import { LiveEditor } from '../../../LiveEditor'

```ts
import { injectGetInstance } from '@zedux/react'
```

An [injector](../glossary#injector) that returns a `getInstance` function. This `getInstance` function returns other atom instances. It's similar to [the `.getInstance()` method on ecosystems](../classes/Ecosystem#getinstance) but it has one extra superpower:

When called synchronously during atom evaluation, this function will register a [static graph dependency](../glossary#static-graph-dependency) on the resolved atom instance. In this way, `getInstance` is like [`injectAtomInstance()`](injectAtomInstance). However, unlike `injectAtomInstance`, `getInstance` is not an injector. This means it can be called in loops or if statements or even asynchronously.

When called asynchronously, `getInstance` is really just an alias for `ecosystem.getInstance()`. It doesn't register any graph dependencies; it simply returns the resolved atom instance.

[Ions](../classes/Ion) use this injector internally to provide the `getInstance` function as part of their [IonGetUtils](../types/IonGetUtils) and [IonSetUtils](../types/IonSetUtils) objects.

## Examples

<LiveEditor resultVar="Seconds">{`
const secondsAtom = atom('seconds', (startingNumber: number) => {
  const store = injectStore(startingNumber)\n
  injectEffect(() => {
    const intervalId = setInterval(
      () => store.setState(val => val + 1),
      1000
    )\n
    return () => clearInterval(intervalId)
  }, [])\n
  return store
})\n
const sumAtom = atom('sum', (...nums: number[]) => {
  const getInstance = injectGetInstance()\n
  // loops are fine!
  return nums.reduce((sum, num) => {
    // this is a static dependency: (won't cause reevaluations)
    return sum + getInstance(secondsAtom, [num]).store.getState()
  }, 0)
})\n
function Seconds() {
  const sumInstance = useAtomInstance(sumAtom, [1, 10, 100])
  const sum = useAtomValue(sumInstance)\n
  return (
    <>
      <div>Sum of 3 counters, starting at 1, 10, and 100: {sum}</div>
      <button onClick={sumInstance.invalidate}>Refresh</button>
    </>
  )
}
`}</LiveEditor>

Miscellaneous:

```ts
const getInstance = injectGetInstance()

const staticInstance = getInstance(myAtom)
const withParams = getInstance(myAtom, ['param 1', 'param 2'])

// in a loop
for (const id of ids) {
  const instance = getInstance(myAtom, [id])
}

// .. any kind of loop
const instances = ids.map(id => getInstance(myAtom, [id]))

// in control flow statements
const instance = useAtomA ? getInstance(atomA) : defaultInstance

// asynchronously: (`getInstance` isn't technically a stable reference. But it
// doesn't reference anything unstable, so not passing it as a dep is fine)
injectEffect(() => {
  const instance = getInstance(myAtom)
}, []) // don't have to pass `getInstance`

// passing an instance (also registers a static dependency during evaluation):
const fromInstance = getInstance(instance)

// passing an atom to `injectGetInstance()`:
const getMyAtomInstance = injectGetInstance(myAtom)
const instance = getMyAtomInstance()
const withParams = getMyAtomInstance(['param 1', 'param 2'])
```

## Signature

```ts
injectGetInstance() => getInstance
```

The returned `getInstance` function's signature is:

```ts
getInstance(atom, params?) => instance
```

There is an overload for passing instances:

```ts
getInstance(instance) => instance
```

This overload is mostly just for interop in cases where you have a value that may be either an atom or instance (Zedux does this internally). However, it can be useful for purposefully registering a static dependency on an instance when the instance was [passed via params](../classes/AtomInstance#params).

### Overloads

```ts
injectGetInstance(atom) => getAtomInstance
```

In this overload, the returned `getAtomInstance` function will be scoped to the passed atom and will only return instances of that atom. Its signature is:

```ts
getAtomInstance(params?) => AtomInstance
```

### `atom`

Required. An [atom](../classes/Atom).

### `params`

Optional. An array of parameters that identify this atom instance. These params will be passed to the atom's [evaluator function](../glossary#evaluator).

TS users will be required to pass this for atoms that take params. If you don't use TS ... just don't forget to pass them.

### `instance`

Required (in this overload). An [atom instance](../classes/AtomInstance). The same atom instance will be returned. When called synchronously during evaluation, this will register a static dependency on the passed atom instance (usually not necessary).
