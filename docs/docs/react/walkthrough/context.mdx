---
id: context
title: Context
---

import { LiveEditor } from '../../LiveEditor'

The atomic model naturally fixes all the problems with React context. In Zedux, we can use React context with all of its benefits and none of its downsides.

The important philosophy here is that Zedux uses [React context for Dependency Injection, not State Management](https://blog.testdouble.com/posts/2021-03-19-react-context-for-dependency-injection-not-state/). That article is an excellent breakdown of this technique.

## Simple Example

<LiveEditor resultVar="Parent">{`
const providedAtom = atom('provided', 'the state!')\n
function Child() {
  const instance = useAtomConsumer(providedAtom)
  const [state, setState] = useAtomState(instance)\n
  return (
    <>
      <div>Child State (subscribed): {state}</div>
      <button onClick={() => setState('new state!')}>Change</button>
    </>
  )
}\n
function Parent() {
  const instance = useAtomInstance(providedAtom)\n
  return (
    <AtomInstanceProvider instance={instance}>
      <div>Parent State (not subscribed): {instance.store.getState()}</div>
      <Child />
    </AtomInstanceProvider>
  )
}
`}</LiveEditor>

## Providing

An atom instance can be provided over React context via [`<AtomInstanceProvider>`](../api/components/AtomInstanceProvider).

```tsx
import { AtomInstanceProvider, useAtomInstance } from '@zedux/react'

function Parent() {
  const instance = useAtomInstance(myAtom)

  return (
    <AtomInstanceProvider instance={instance}>
      <Child />
    </AtomInstanceProvider>
  )
}
```

### Multiple Instances

To provide instances of multiple atoms from the same component, you could nest a bunch of `<AtomInstanceProvider>`s. But that isn't very aesthetically pleasing now, is it.

To this end, `AtomInstanceProvider` accepts an `instances` prop, whose value is an array of instances to provide. Only provide either an `instance` or an `instances` prop, not both.


```tsx
return (
  <AtomInstanceProvider instances={[instanceA, instanceB]}>
    {children}
  </AtomInstanceProvider>
)
```

## Consuming

Consume provided instances with [`useAtomConsumer`](../api/hooks/useAtomConsumer)

```ts
import { useAtomConsumer } from '@zedux/react'

function Child() {
  const instance = useAtomConsumer(myAtom)
  ...
}
```

### If an Instance Wasn't Provided

If a component uses `useAtomConsumer` but no instance was provided by any parent, an empty object will be returned.

```ts
const instance = useAtomConsumer()
instance.invalidate() // error! instance.invalidate is not a function
```

TypeScript users will be warned of this. But to get around it, you'd have to put checks before everything you try to do with that instance. This isn't very useful. In fact, it's downright annoying.

Fortunately (on purpose), `useAtomConsumer` has two overloads that help with this:

#### Case #1: I want a default atom instance to be created, if none was provided.

You can provide an array of params to `useAtomConsumer`. These params must match the params of the atom. If no atom instance was provided, Zedux will use the passed default params to locate an existing atom instance or create a new instance if it doesn't exist yet.

```ts
const instance = useAtomConsumer(myAtom, ['default instance params'])
instance.invalidate() // all good! Even TS is happy
```

If the atom doesn't take params, you must still pass an empty array for Zedux to find/create a default instance.

```ts
const paramlessInstance = useAtomConsumer(myAtom, [])
instance.invalidate() // ðŸ˜Š
```

#### Case #2: I don't ever want an instance to not be provided. Throw an error if I forget!

Instead of an array of default parameters, you can pass `true` as the second param to `useAtomConsumer`. This tells Zedux to throw an error if no atom instance was provided.

```ts
const instance = useAtomConsumer(myAtom, true)
instance.invalidate() // all good again! TS smiles upon you
```

## Subscribing

The amazing thing about using atoms for React context is that neither the providing nor consuming component subscribe to the atom instance by default. This gives you full control over rerenders.

Any component can set the state of the atom without subscribing to the state itself. And, of course, any component can subscribe itself to the atom instance using [`useAtomValue`](../api/hooks/useAtomValue) or similar.

```tsx
function Parent() {
  const instance = useAtomInstance(myAtom) // doesn't subscribe
  const value = useAtomValue(instance) // subscribes
  ...
}

function Child() {
  const instance = useAtomInstance(myAtom, []) // doesn't subscribe
  const value = useAtomValue(instance) // subscribes
}
```

## Using Selectors

A common pattern is to pass the provided atom instance to [`useAtomSelector`](../api/hooks/useAtomSelector) to limit component rerenders.

```tsx
function Child() {
  const instance = useAtomInstance(myAtom, []) // doesn't subscribe

  // subscribes, but only causes a rerender when `someField` changes.
  const someField = useAtomSelector(instance, ({ someField }) => someField)
}
```

## Local Atoms

[Local atoms](../api/classes/LocalAtom) are a type of atom that specializes in React Context.

```ts
import { localAtom } from '@zedux/react'

const myContextAtom = localAtom('myContext')
```

The first param of all local atoms is an optional string id. You can pass this string yourself to id local atoms manually. This can be useful e.g. when persisting/rehydrating them, or just so you know what's what when debugging. Manually-id'd local atoms can also be reused anywhere by passing the same id, just like any other normal atom.

If you don't pass an id, Zedux will auto-generate one every time you use the local atom in any hook or injector.

```ts
injectAtomValue(myContextAtom) // creates a new instance
injectAtomInstance(myContextAtom) // creates another new instance

useAtomInstance(myContextAtom) // creates another new instance
useAtomState(myContextAtom) // creates another new instance
useAtomState(myContextAtom, []) // creates another new instance

useAtomInstance(myContextAtom, ['manual-id']) // creates another new instance
useAtomInstance(myContextAtom, ['manual-id']) // reuses the 'manual-id' instance
```

Local atoms also always set [`ttl`](../api/StandardAtomBase#ttl) to `0`, which will clean up atom instances immediately when all components using the atom instance unmount.

### Example

Local atoms are useful when you just want to provide different atom instances to different component trees.

export const popupStyle = {
  background: 'rgba(255, 255, 255, 0.4)',
  boxShadow: '2px 2px 5px 1px rgba(0, 0, 0, 0.2)',
  padding: '12px',
  position: 'absolute',
  top: '8px',
  right: '20px'
}

<LiveEditor
  extraScope={popupStyle}
  resultVar="Popups"
>{`
const popupAtom = localAtom('popup', () => ({ isOpen: false }))\n
function Popup() {
  const [{ isOpen }, setVal] = useAtomState(useAtomConsumer(popupAtom, []))
  const toggle = () => setVal(val => ({ ...val, isOpen: !val.isOpen }))\n
  return (
    <div>
      <button onClick={toggle}>
        {isOpen ? 'Close' : 'Open'}
      </button>
      {isOpen && (
        <div style={popupStyle} onClick={toggle}>
          I Am Open!!
        </div>
      )}
    </div>
  )
}\n
function Popups() {
  const instanceA = useAtomInstance(popupAtom)
  const instanceB = useAtomInstance(popupAtom)\n
  return (
    <>
      <AtomInstanceProvider instance={instanceA}>
        <Popup />
      </AtomInstanceProvider>
      <AtomInstanceProvider instance={instanceB}>
        <Popup />
      </AtomInstanceProvider>
    </>
  )
}
`}</LiveEditor>

## Recap

- Atom instances can be provided over React context via [`<AtomInstanceProvider>`](../api/components/AtomInstanceProvider).
- Atom instances can be consumed from React context via [`useAtomConsumer`](../api/hooks/useAtomConsumer).
- `useAtomConsumer(myAtom, [...defaultParams])` creates an atom instance with `defaultParams` if no instance was provided.
- `useAtomConsumer(myAtom, true)` throws an error if no atom instance was provided.
- You can subscribe any component to an atom instance by using [`useAtomValue`](../api/hooks/useAtomValue) or any other hook that creates a [dynamic graph dependency](../api/glossary#dynamic-graph-dependency).
- `useAtomSelector` will only rerender the component when the selector result changes.
- Local atoms set their first param to an optional string, which can be used to create multiple atom instances without specifying unique ids.

## Next Steps

Let's continue exploring advanced React usage by looking at [React suspense](suspense).
