---
id: local-atoms
title: Local Atoms
---

import { LiveEditor } from '../../LiveEditor'

Local atoms are a very unique concept. Their primary use is very similar to React context's.

```tsx
import { localAtom } from '@zedux/react'

const myLocalAtom = localAtom('myLocal', 'I am like React context but with Zedux superpowers')
```

Local atoms are a completely different atom type from standard atoms. Their API is different, though it tries to appear similar to the standard atom API.

## Comparison to Standard Atoms

### Instantiation

Unlike standard atoms, Local atoms are instantiated every time you call `.useInstance()`. 

```tsx
function App() {
  const instanceOne = myLocalAtom.useInstance()
  const instanceTwo = myLocalAtom.useInstance() // a different instance!
  ...
}
```

### Parameters

With local atoms, `.useInstance()` is the only hook that accepts parameters - because it's the only hook that triggers atom instantiation. Unlike standard atoms, passing the same parameters will always create a new instance.

No other local atom hooks accept parameters.

### Hooks

Local atoms have many of the same hooks as standard atoms. But all hooks are all slightly different from their standard atom counterparts.

All other local atom hooks are aliases for `.useConsumer().use<hook name here>()`. They expect an instance to be provided over React. They do not accept parameters.

```tsx
const loginFormAtom = atom('loginForm', () => ({
  email: '',
  password: ''
}))

function LoginForm() {
  const loginForm = loginFormAtom.useInstance()

  return (
    // highlight-next-line
    <loginForm.Provider>
      <Email />
      <Password />
    </loginForm.Provider>
  )
}

function Email() {
  // A shorthand for `loginForm.useConsumer().useState()`:
  // highlight-next-line
  const [{ email }, setState] = loginFormAtom.useState()
  ...
}

function Password() {
  // (same as above)
  // highlight-next-line
  const [{ password }, setPassword] = loginFormAtom.useState()
  ...
}
```

Local atoms only have one injector - `.injectInstance()`. The instance returned has all the normal instance injectors. While this works and it's fine to use, local atoms aren't really intended for use in other atoms.

### Destruction

Local atoms are always cleaned up when they're no longer in use. This can't be configured (local atoms don't take a `ttl`).

In most cases, this means that when the component or atom that created the local atom instance is unmounted or destroyed, the local atom instance will also be destroyed. Since this is similar to how React context providers work, this is usually what you want.

## Comparison to React Context

Local atoms use React context under the hood. But they don't use it for state management, they use it for dependency injection.

### DI

Remember that atoms use observable/subscription-model stores internally. React context's role is merely to pass the stores themselves down through the component tree. It doesn't pass state directly.

Local atoms don't trigger unnecessary rerenders, unlike raw React context.

### Example

Each local atom instance is essentially bound to a React component. The instance will be automatically cleaned up when the component that called `.useInstance()` unmounts.

This mimics the typical flow of React context, where you manage state in a parent component and provide that to children via a context Provider's `value` prop:

```tsx
const myContext = createContext({ setState: noop, state: 'default value' })

function Parent() {
  // this state will die when this component unmounts
  const [state, setState] = useState('some state')

  return (
    <myContext.Provider value={{ setState, state }}>
      <Child />
    </myContext.Provider>
  )
}

function Child() {
  const { state } = useContext(myContext)
}
```

If you know much about React context, the above code snippet should have triggered several alarms for you. Plenty has already been written about the caveats of React context and circumventing them, so we won't go into that here.

But let's look at an equivalent example using local atoms:

```tsx
const myLocalAtom = localAtom('myLocal', 'default value')

function Parent() {
  // this atom will die when this component unmounts
  const instance = myLocalAtom.useInstance()

  return (
    <instance.Provider>
      <Child />
    </instance.Provider>
  )
}

function Child() {
  const state = myLocalAtom.useValue()
}
```
