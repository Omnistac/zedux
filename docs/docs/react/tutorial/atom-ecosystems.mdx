---
id: atom-ecosystems
title: Atom Ecosystems
---

import { LiveEditor } from '../../LiveEditor'

## Ecosystems

All atoms live in atom ecosystems. An ecosystem is like an isolated group of atoms. Atoms in an ecosystem can interact with each other, but are usually unaware of atoms in other ecosystems.

There are 2 types of ecosystems:

- Global
- App

### Global

There is exactly one global atom ecosystem. You don't need to create it; it already exists. All atoms in the global ecosystem live outside of React.

Zedux is designed to allow an app to use nothing but the global ecosystem. And for small apps and simple examples, that's fine. However, this approach can only get you so far. The global ecosystem is not very configurable or conducive to some advanced features like [dependency injection](TODO:link) and [atom context](TODO:link). Global atoms can also be unruly in tests, since they require specific cleanup.

### App

App ecosystems are created by rendering an [AppProvider](TODO:link):

```tsx
import { AppProvider } from '@zedux/react'

function App() {
  return (
    <AppProvider>
      <Routes />
    </AppProvider>
  )
}
```

This is similar to Recoil's [`RecoilRoot`](https://recoiljs.org/docs/api-reference/core/RecoilRoot) or Redux' [`Provider`](https://react-redux.js.org/api/provider) or React Query's [`QueryClientProvider`](https://react-query.tanstack.com/reference/QueryClientProvider). In fact, it's basically a combination of all of those. And more.

Every AppProvider creates a new app ecosystem. Most apps will only need one, though more can be created to purposefully create isolated groups of atoms. Tests will typically each create their own AppProvider to take advantage of DI and the automatic cleanup on unmount.

When an AppProvider is unmounted, all atom instances in that app ecosystem are destroyed.

:::note
Nesting AppProviders currently has no special functionality. Rendering an AppProvider inside another AppProvider will create a new, completely isolated app ecosystem.
:::

`<AppProvider />` takes several props to configure DI, atom context, preloading data, and more. **Most apps will want to use app ecosystems for pretty much everything.**

## Ecosystem Design Patterns

There are 3 main design patterns around atom ecosystems. Choose the most appropriate for your app.

### Single App

![](/img/diagrams/atom-ecosystems-app-only.png)

The most common. In the single app approach, you render one AppProvider - creating a single app ecosystem. The global ecosystem is not used.

Most apps will want to make use of the powerful features of AppProviders. This approach is recommended in most situations.

### Global Only

![](/img/diagrams/atom-ecosystems-global-only.png)

In the global only approach, all atoms, regardless of scope, live in the global ecosystem. This is done by never rendering an AppProvider. If no AppProvider is rendered, all atoms are added to the global ecosystem by default.

Note that again there is probably no real need for global atoms in this approach, since app atoms are essentially "global".

The global ecosystem can be nice for simplicity. Some apps don't need any of the features AppProviders offer. And that's fine!

### Mixed

![](/img/diagrams/atom-ecosystems-mixed.png)

In this approach, you create one or more app ecosystems (by rendering AppProviders). You might also use some atoms outside any AppProvider - utilizing the global ecosystem.

Use cases for this approach are very niche. Outside of testing, you probably won't find yourself using multiple AppProviders.

## A Note On Params

In the quick start, we learned that atom instances can be reused by passing the same params to certain hooks/injectors. Since atom instances live in an ecosystem, reuse can only happen inside that ecosystem.

In the following example, the `counterAtom` doesn't take any params. But since it's used in two different app ecosystems, two different instances are created.

<LiveEditor resultVar="Apps">{`
const counterAtom = atom('counter', 0)\n
function Counter() {
  const [state, setState] = counterAtom.useState()\n
  return (
    <>
      <div>Value: {state}</div>
      <button onClick={() => setState(state => state + 1)}>Increment</button>
    </>
  )
}\n
function Apps() {
  return (
    <>
      <AppProvider>
        <h3>Counter 1:</h3>
        <Counter />
      </AppProvider>
      <AppProvider>
        <h3>Counter 2:</h3>
        <Counter />
      </AppProvider>
    </>
  )
}
`}</LiveEditor>

## Recap

- All atoms live in atom ecosystems.
- Atom instances can only be reused in the ecosystem they were created in.
- There are global and app ecosystems.
- Most apps will use the "Single App Approach" - rendering a single `<AppProvider>`.

## Next Steps

The AppProvider is capable of some pretty cool stuff. With that equipped, it's time to look at one of the coolest features of Zedux: [Dependency Injection](dependency-injection).
