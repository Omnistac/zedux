---
id: using-atoms
title: Using Atoms
---

import { LiveEditor } from '../../LiveEditor'

In the quick start, we learned a few basic ways to instantiate and consume atoms. In this page, we'll learn about stores - the secret sauce behind atoms. We'll also cover more hooks and injectors for atom instantiation and consumption.

## Stores

Every instance of every atom creates a light-weight Zedux store. Stores manage lots of the heavy lifting for atoms, such as storing and updating state, telling consumer atoms to reevaluate, telling React components to rerender, and running side effects based on dispatched actions or resulting state changes.

Atoms create most stores for you. But you can easily create them manually:

```ts
import { createStore } from '@zedux/react'

const myStore = createStore()
```

Stores have lots of cool features that we'll look at in [the stores tutorial](stores). For now, just remember that every atom instance has an underlying store.

## Subscribing Hooks/Injectors

Some hooks/injectors automatically subscribe to the atom instance's underlying store. That means that when the atom instance's store's state changes, components that use these hooks will rerender and atoms that use these injectors will reevaluate.

### `.useSelector()`/`.injectSelector()` TODO: these

Returns a portion or derivation of the state of the store. Also ensures that the component or atom only reevaluates when the selector's result changes. Similar to Redux' [`useSelector()`](https://react-redux.js.org/api/hooks#useselector).

```tsx
function App() {
  // whenever userAtom's state changes, this selector will run.
  // If the selector returns a new value, this component will rerender.
  const userId = userAtom.useSelector(({ id }) => id)
  ...
}
```

If the atom takes params, pass those as the last param to `.useSelector()`/`.injectSelector()`:

```ts
const usersByRoleAtom = selector('usersByRole', (role: string) => {
  const users = usersAtom.injectValue()

  return users.filter(user => user.role === role)
})

function App() {
  const userIds = usersByRoleAtom.useSelector(
    users => users.map(({ id }) => id),
    // highlight-next-line
    ['admin']
  )
  ...
}
```

Note that while you can use a selector memoizing library like [reselect](https://github.com/reduxjs/reselect), it isn't necessary in Zedux. If more sophisticated selector behavior is required, use [selector atoms](creating-atoms#selector-atoms) like we did with `usersByRoleAtom` in the above example.

Atom selectors are composable, memoized by default (since they live in an atom ecosystem), and the cache size and ttl are configurable too - all because they're atoms. The memoization details can even be handled more granularly using [`injectMemo()`](TODO:link). That's a lot of power for such a simple API.

### `.useState()`/`.injectState()` TODO: these

`.useState()` works kind of like React's `useState()` hook.

```tsx
function App() {
  // whenever myAtom's state changes, this component will rerender
  const [state, setState] = myAtom.useState()
  ...
}
```

`setState` is a reference to the `setState` function on the instance's store - the only difference to React's state setters being that it will recursively merge nested objects.

`.useState()`/`.injectState()` differ from React's `useState()` in that you don't pass the initial state - we defined that when we created the atom. Instead, you pass the params of the atom (if any):

```ts
const [darkTheme, setDarkTheme] = themeAtom.injectState('dark')
const [lightTheme, setLightTheme] = themeAtom.injectState('light')
```

### `.useValue()`/`.injectValue()`

The simplest way to consume an atom's state.

```ts
function App() {
  // whenever myAtom's state changes, this component will rerender
  const currentState = myAtom.useValue()
  ...
}

const dependentAtom = atom('dependent', () => {
  // whenever myAtom's state changes, this atom will reevaluate
  const currentState = myAtom.injectValue()
  ...
})
```

## Non-Subscribing Hooks/Injectors

The following hooks/injectors do not subscribe to the atom instance's underlying store.

### `.useConsumer()`

Used in conjuction with `.useInstance()` to consume atom instances provided over React context. Note that there is no such thing as `.injectConsumer()`.

See [`.useInstance()`](#useinstanceinjectinstance) below for an example.

### `.useDispatch()`/`.injectDispatch()` TODO: these

Returns a reference to the instance's store's `dispatch` function.

```tsx
function App() {
  const dispatch = todosAtom.useDispatch()
  
  return (
    <button onClick={() => dispatch(addTodo('Procrastinate'))}>
      Do Good Things
    </button>
  )
}
```

### `.useInstance()`/`.injectInstance()`

Returns a reference to an instance of the atom. This can be used to avoid needing to re-specify params on parameterized atoms when using multiple hooks/injectors:

```tsx
function App() {
  // Before:
  const params = [{ some: ['complex', 'params'] }, 'here']
  const value = myAtom.useValue(...params)
  const dispatch = myAtom.useDispatch(...params)

  // After:
  // highlight-next-line
  const instance = myAtom.useInstance({ some: ['complex', 'params'] }, 'here')
  const value = instance.useValue() // no need to pass params here
  const dispatch = instance.useDispatch() // nor here
  ...
}
```

:::note
While `myAtom.useInstance()` does not subscribe to the instance's store, `instance.useValue()` does.
:::

`.useInstance()` can also be used in conjunction with `.useConsumer()` to provide an instance over React context, so deeply nested children don't need to know the params of a specific atom instance they want to reuse:

```tsx
function Parent() {
  const instance = myAtom.useInstance('some', 'params')

  return (
    <instance.Provider>
      <Child />
    </instance.Provider>
  )
}

function Child() {
  const instance = myAtom.useConsumer() // no need to pass params here
  const value = instance.useValue() // subscribe to the instance's store
  ...
}
```

### `.useInvalidate()`/`.injectInvalidate()`

Returns a function that can be used to force a reevaluation of an atom.

<LiveEditor resultVar="Coin">{`
const coinTossAtom = atom('coinToss', () => Math.random() < 0.5)\n
function Coin() {
  const isHeads = coinTossAtom.useValue()
  const invalidate = coinTossAtom.useInvalidate()\n
  return <button onClick={invalidate}>{isHeads ? 'Heads' : 'Tails'}</button>
}
`}</LiveEditor>

### `.useLazy()`/`.injectLazy()`

Returns a function that can be used to dynamically create atom instances. Often used in conjunction with AppProvider's `preload` prop.

```tsx
function App() {
  const loadSocketConnection = socketConnectionAtom.useLazy()

  return (
    <AppProvider preload={() => {
      const configSocketStore = loadSocketConnection('/config')
      const userSocketStore = loadSocketConnection('/user')
    }}>
      <Routes />
    </AppProvider>
  )
}
```

Calling the loader function instantiates the atom, if no instance has been created for the given params yet, and returns the instance's store.

### `.useMethods()`/`.injectMethods()`

Atoms can expose functions to consumers using the top-level `injectMethods()` injector. These functions can then be consumed using `.useMethods()` and `.injectMethods()`.

```ts
import { atom, createStore, injectMemo, injectMethods } from '@zedux/react'

const counterAtom = atom('counter', () => {
  const store = injectMemo(() => createStore(), [])

  // Expose methods
  injectMethods(() => ({
    decrement: () => store.setState(state => state - 1),
    increment: () => store.setState(state => state + 1)
  }), [store])

  return store
})

function App() {
  const { decrement, increment } = counterAtom.useMethods()
  ...
}
```

Live playground for fun:

<LiveEditor resultVar="App">{`
const counterAtom = atom('counter', () => {
  const store = injectMemo(() => createStore(null, 0), [])\n
  // Expose methods
  injectMethods(() => ({
    decrement: () => store.setState(state => state - 1),
    increment: () => store.setState(state => state + 1)
  }), [store])\n
  return store
})\n
function App() {
  const { decrement, increment } = counterAtom.useMethods()
  const value = counterAtom.useValue()\n
  return (
    <>
      <div>Counter: {value}</div>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decremenet</button>
    </>
  )
}
`}</LiveEditor>

For TypeScript users, an atom's methods type is the 3rd generic that the `atom()` factory accepts:

```ts
const counterAtom = atom<
  number, // the state type
  [], // the params tuple - this atom doesn't have any
  { increment(): void; decrement(): void } // the methods
>('counter', ...)
```

### `.useSetState()`/`.injectSetState()` TODO: these

Returns a reference to the atom instance's store's `setState` function. Useful when you don't need to read from state, so don't want to register a subscription using `.useState()`/`.injectState()`, but do need to update state of a zero-config store.

```ts
function App() {
  const [state, setState] = myAtom.useState()

  // the above is a shorthand for:
  const state = myAtom.useValue()
  // highlight-next-line
  const setState = myAtom.useSetState()
}
```

### `.useStore()`/`.injectStore()` TODO: these

Returns a reference to the atom instance's store. Regard this as an escape hatch. Avoid using it if possible.

One of the main reasons you may need this hook/injector is to perform side effects:

```ts
import { when } from '@zedux/react'

function App() {
  const store = myAtom.useStore()

  injectEffect(() => {
    const { subscription } = when(store).stateChanges((newState, oldState) => {
      console.log({ newState, oldState })
    })

    return () => subscription.unsubscribe()
  }, [store])
  ...
}
```

## Recap

- Every atom instance has an underlying Zedux store.

- `.useSelector()`, `.useState()`, `.useValue()`, and their corresponding injectors all subscribe to the store. All other hooks/injectors do not.

- `.useInstance()` and `.useConsumer()` can be used together to provide and consume atom instances over React context.

- `.useDispatch()`, `.useSetState()`, `.useStore()`, and their corresponding injectors expose parts or all of the instance's store.

- `.useInvalidate()` and `.injectInvalidate()` can be used to manually trigger atom reevaluation.

- `.useLazy()` and `.injectLazy()` can be used to preload atoms.

- `useMethods()` can be used to expose methods from an atom and `.useMethods()` and `.injectMethods()` can be used to consume an atom's methods.

## Next Steps

Now we know how to consume atoms in general. Next we'll learn about the different types of atoms and their lifecycles by covering [atom ecosystems](atom-ecosystems) and then [atom scopes](atom-scopes).
