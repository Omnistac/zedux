---
id: using-atoms
title: Using Atoms
---

import { LiveEditor } from '../../LiveEditor'

In the quick start, we learned a few basic ways to instantiate and consume atoms. In this page, we'll discover stores - the secret sauce behind atoms. We'll also cover more hooks and injectors for atom instantiation and consumption.

## Stores

Every instance of every atom creates a light-weight store. Stores manage state and serve as a message bus for running side effects based on dispatched actions or state changes.

Atoms create most stores for you. But you can easily create them manually:

```ts
import { createStore } from '@zedux/react'

const myStore = createStore()
```

Stores have lots of cool features that we'll look at in [the stores tutorial](stores). For now, just remember that every atom instance has an underlying store.

## Dynamic Hooks/Injectors

Some hooks/injectors create a dynamic dependency on the atom. This means that when the atom instance's store's state changes, components/atoms that use these hooks/injectors will rerender/reevaluate (ðŸ˜…).

### `.useSelector()`

Returns a portion or derivation of the state of the store. Also ensures that the component only reevaluates when the selector's result changes. Similar to Redux' [`useSelector()`](https://react-redux.js.org/api/hooks#useselector).

<LiveEditor resultVar="App">{`
const userAtom = atom('user', () => ({
  name: 'Joe',
  lastUpdated: new Date()
}))\n
function Child() {
  const [state, setState] = userAtom.useState()\n
  return (
    <>
      <input
        onChange={({ target }) => setState(val => ({
          lastUpdated: new Date(),
          name: target.value
        })}
        value={state.name}
      />
      <div>Last Updated: {state.lastUpdated.toLocaleString()}</div>
      <button onClick={() => setState(val => ({
        ...val,
        lastUpdated: new Date()
      })}>
        Update Date
      </button>
    </>
  )
}\n
function App() {
  // whenever userAtom's state changes, this selector will run.
  // If the selector returns a new value, this component will rerender.
  const renders = useRef(0)
  const userName = userAtom.useSelector(({ name }) => name)
  renders.current += 1\n
  return (
    <>
      <div>renders: {renders.current}, name: {userName}</div>
      <Child />
    </>
  )
}
`}</LiveEditor>

If the atom takes params, pass those as the first param to `.useSelector()`:

```ts
const usersByRoleAtom = selector('usersByRole', (role: string) => {
  const users = usersAtom.injectValue()

  return users.filter(user => user.role === role)
})

function App() {
  const userIds = usersByRoleAtom.useSelector(
    // highlight-next-line
    ['admin'],
    users => users.map(({ id }) => id)
  )
  ...
}
```

Note that while you can use a selector memoizing library like [reselect](https://github.com/reduxjs/reselect), it isn't necessary in Zedux. If more sophisticated selector behavior is required, use [selector atoms](creating-atoms#selector-atoms) like we did with `usersByRoleAtom` in the above example.

Atom selectors are composable, memoized by default (since they live in an atom ecosystem), and the cache size and ttl are configurable too - all because they're atoms. The memoization details can even be handled more granularly using [`injectMemo()`](TODO:link). That's a lot of power for such a simple API.

#### `.injectSelector()`

The injector equivalent of `.useSelector()` - for use in atoms:

```ts
const userAtom = atom('user', () => {
  const token = authAtom.injectSelector(authData => authData.token)
  ...
})
```

### `.useState()`

`.useState()` is similar to React's `useState()` hook.

```tsx
function App() {
  // whenever myAtom's state changes, this component will rerender
  const [state, setState] = myAtom.useState()
  ...
}
```

`setState` is a reference to the `setState` function on the instance's store, which functions like a React state setter.

`.useState()` differs from React's `useState()` in that you don't pass the initial state - we defined that when we created the atom. Instead, you pass the params of the atom (if any):

```ts
const [darkTheme, setDarkTheme] = themeAtom.useState('dark')
const [lightTheme, setLightTheme] = themeAtom.useState('light')
```

#### `.injectState()`

The injector equivalent of `.useState()` - for use in atoms.

```ts
const userAtom = atom('user', () => {
  const [state, setState] = authAtom.injectState()
})
```

### `.useValue()`

The simplest way to consume an atom's state.

```ts
function App() {
  // whenever myAtom's state changes, this component will rerender
  const currentState = myAtom.useValue()
  ...
}
```

#### `.injectValue()`

The injector equvalent of `.useValue()`:

```ts
const dependentAtom = atom('dependent', () => {
  // whenever myAtom's state changes, this atom will reevaluate
  const currentState = myAtom.injectValue()
  ...
})
```

## Static Hooks/Injectors

The following hooks/injectors do not cause rerenders/reevaluations when their atom's state changes.

### `.useConsumer()`

Used in conjuction with `.useInstance()` to consume atom instances provided over React context. Note that there is no such thing as `.injectConsumer()`.

See [`.useInstance()`](#useinstance) below for an example.

### `.useDispatch()`

Returns a reference to the instance's store's `dispatch` function.

```tsx
function App() {
  const dispatch = todosAtom.useDispatch()
  
  return (
    <button onClick={() => dispatch(addTodo('Procrastinate'))}>
      Do Good Things
    </button>
  )
}
```

As you should be able to guess by this point, there's an injector equivalent - `.injectDispatch()`:

```ts
const userAtom = atom('user', () => {
  const dispatch = entitiesAtom.useDispatch()
  // ... in an injectEffect() or callback:
  dispatch(userLoaded(userData))
})
```

### `.useInstance()`

Returns a reference to an instance of the atom. This can be used to avoid needing to re-specify params on parameterized atoms when using multiple hooks/injectors:

```tsx
function App() {
  // Before:
  const params = [{ some: ['complex', 'params'] }, 'here']
  const value = myAtom.useValue(...params)
  const dispatch = myAtom.useDispatch(...params)

  // After:
  // highlight-next-line
  const instance = myAtom.useInstance({ some: ['complex', 'params'] }, 'here')
  const value = instance.useValue() // no need to pass params here
  const dispatch = instance.useDispatch() // nor here
  ...
}
```

:::note
While `myAtom.useInstance()` does not subscribe to the instance's store, `instance.useValue()` does.
:::

`.useInstance()` can also be used in conjunction with `.useConsumer()` to provide an instance over React context, so deeply nested children don't need to know the params of a specific atom instance they want to reuse:

```tsx
function Parent() {
  const instance = myAtom.useInstance('some', 'params')

  return (
    <instance.Provider>
      <Child />
    </instance.Provider>
  )
}

function Child() {
  const instance = myAtom.useConsumer() // no need to pass params here
  const value = instance.useValue() // subscribe to the instance's store
  ...
}
```

Instances also expose lots of extra, low-level functionality. We'll cover more of that in the [instances tutorial](TODO:link).

There is also an injector equivalent - `.injectInstance()`.

### `.useLazy()`

Returns a function that can be used to dynamically create atom instances. Often used in conjunction with EcosystemProvider's [`preload`](TODO:link) prop:

```tsx
function App() {
  const loadSocketConnection = socketConnectionAtom.useLazy()

  return (
    <EcosystemProvider preload={() => {
      const configSocketInstance = loadSocketConnection('/config')
      const userSocketInstance = loadSocketConnection('/user')
    }}>
      <Routes />
    </EcosystemProvider>
  )
}
```

Calling the loader function instantiates the atom, if no instance has been created for the given params yet, and returns the instance.

There is an injector equivalent - `.injectLazy()`.

### `.useExports()`

Atoms can expose functions to consumers using the top-level `injectExports()` injector. These functions can then be consumed using `.useExports()` and `.injectExports()`.

The exports can only be exposed once - any other usages of `injectExports()` will be ignored. The object passed to `injectExports()` should contain only stable references - the exports will not be updated on subsequent evaluations.

In the following example, `store` is a stable reference thanks to the `injectStore()` injector. We therefore don't need to memoize the `decrement` and `increment` functions - they don't reference any variables that could become stale:

```ts
import { atom, createStore, injectMemo, injectExports } from '@zedux/react'

const counterAtom = atom('counter', () => {
  const store = injectStore(0)

  // Expose methods
  injectExports({
    decrement: () => store.setState(state => state - 1),
    increment: () => store.setState(state => state + 1)
  })

  return store
})

function App() {
  const { decrement, increment } = counterAtom.useExports()
  ...
}
```

Live playground for fun:

<LiveEditor resultVar="App">{`
const counterAtom = atom('counter', () => {
  const store = injectStore(0)\n
  // Expose methods
  injectExports({
    decrement: () => store.setState(state => state - 1),
    increment: () => store.setState(state => state + 1)
  })\n
  return store
})\n
function App() {
  const { decrement, increment } = counterAtom.useExports()
  const value = counterAtom.useValue()\n
  return (
    <>
      <div>Counter: {value}</div>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decremenet</button>
    </>
  )
}
`}</LiveEditor>

For TypeScript users, an atom's exports type is the 3rd generic that the `atom()` factory accepts:

```ts
const counterAtom = atom<
  number, // the state type
  [], // the params tuple - this atom doesn't have any
  { increment(): void; decrement(): void } // the exports
>('counter', ...)
```

And yes, there is an injector equivalent - `.injectExports()`.

### `.useSetState()`

Returns a reference to the atom instance's store's `setState` function. Useful when you don't need to read from state, so you don't want to register a subscription using `.useState()`, but you do need to update state of a zero-config store.

```ts
function App() {
  const [state, setState] = myAtom.useState()

  // the above is a shorthand for:
  const state = myAtom.useValue()
  // highlight-next-line
  const setState = myAtom.useSetState()
}
```

There is an injector equivalent - `.injectSetState()`.

### `.useStore()`

Returns a reference to the atom instance's store. Regard this as an escape hatch. Avoid using it if possible.

One of the main reasons you may need this hook/injector is to perform side effects:

```ts
import { when } from '@zedux/react'

function App() {
  const store = myAtom.useStore()

  useEffect(() => {
    const { subscription } = when(store).stateChanges((newState, oldState) => {
      console.log({ newState, oldState })
    })

    return () => subscription.unsubscribe()
  }, [store])
  ...
}
```

## Recap

- Every atom instance has an underlying Zedux store.

- `.useSelector()`, `.useState()`, `.useValue()`, and their corresponding injectors all subscribe to the store. All other hooks/injectors do not.

- `.useInstance()` and `.useConsumer()` can be used together to provide and consume atom instances over React context.

- `.useDispatch()`, `.useSetState()`, `.useStore()`, and their corresponding injectors expose parts or all of the instance's store.

- `.useLazy()` and `.injectLazy()` can be used to preload or lazy-load atoms.

- `injectExports()` can be used to expose variables from an atom and `.useExports()` and `.injectExports()` can be used to consume an atom's exports.

## Next Steps

Now we know how to create and consume atoms. Let's zoom out a bit and look at the architecture of [atom ecosystems](atom-ecosystems).
