---
id: creating-atoms
title: Creating Atoms
---
<!-- 
import { ApisPlayground } from '@zedux/react/../ApisPlayground'

Through the rest of this tutorial we'll implement parts of this playground with Zedux:

<ApisPlayground /> -->

In the quick start, we learned a few basic ways to create atoms. In this page, we'll cover more advanced atom creation using config objects.

## Atom Config

Many aspects of an atom's behavior can be configured. The `atom()` factory can take a config object.

```ts
import { atom } from '@zedux/react'

atom('foo', 'initial value', {
  flags: ['async', 'electron'],
  maxInstances: 10,
  readonly: true,
  ttl: 1000 * 60 * 60,
})
```

This config object has many useful properties. We'll look at some of these now. See [`atom()`](TODO:link) for the full rundown.

### Readonly

Atoms can be made readonly with `readonly: true`. This modifies the API of the atom to avoid exposing any methods for modifying the atom's state to consumers.

```tsx
const readonlyAtom = atom({
  key: 'readonly',
  readonly: true,
  value: 0
})

function App() {
  const [state, setState] = readonlyAtom.useState() // Error!
  const dispatch = readonlyAtom.useDispatch() // Error!
  const value = readonlyAtom.useValue() // Good
  ...
}
```

See [`selector()`](TODO:link) for full details of readonly atoms.

### TTL

When an atom instance is no longer used, we sometimes want to destroy it - allowing its data to be garbage collected.

By default, standard atoms live forever. But they can be given a `ttl` to configure how long instances should stick around when they're no longer in use.

```ts
const zombieAtom = atom({
  key: 'zombie',
  // keep stale zombieAtom instances in memory for 10 minutes:
  ttl: 1000 * 60 * 10
})
// if anyone uses the instance within 10 minutes, cleanup is cancelled
```

`ttl` can be set to `0` to clean up instances immediately.

### Max Instances

:::note
ðŸš§ `maxInstances` is under construction
:::

Complementary to `ttl`, `maxInstances` specifies the largest ideal cache size. If more than this max number of instances are created, Zedux will start cleaning them up automatically when they go stale, regardless of `ttl`.

No instances will ever be cleaned up while still in use. For example, say `maxInstances` is 2 and `ttl` is 1 minute:

```ts
const fooAtom = atom('foo', (id: string) => id, {
  maxInstances: 2,
  ttl: 60000
})
```

Now say I end up using 3 instances simultaneously:

```ts
fooAtom.useValue('a')
fooAtom.useValue('b')
fooAtom.useValue('c')
```

All 3 of those instances can live forever, as long as they're still in use. But as soon as one instance becomes stale, it will be cleaned up immediately - `ttl` will be ignored.

Now there are only 2 instances, which is within the `maxInstances`. The next instance to be cleaned up will respect `ttl`, sticking around for a minute before being destroyed.

Remember that atoms live forever, if no `ttl` is specified. In this case, `maxInstances` can be used to only clean up excess instances, allowing all others to live forever.

## Ions

```ts
import { ion } from '@zedux/react'

const filteredTodosAtom = ion('filteredTodos', ({ get }) => {
  const todos = get(todosAtom), isDone: boolean

  injectEffect(() => {

  }, [])

  return todos.filter(todo => todo.isDone === isDone)
})

function Todos() {
  const finishedTodos = filteredTodosAtom.useValue(true)
  const unfinishedTodos = filteredTodosAtom.useValue(false)

  ...
}
```




























One atom configuration is particularly common in Zedux:

```ts
const mySelectorAtom = atom('mySelector', 'a constant value', {
  readonly: true,
  ttl: 0,
})
```

Zedux exports a shorthand for creating these:

```ts
import { selector } from '@zedux/react'

const mySelectorAtom = selector('mySelector', 'a constant value')
```

The state of all instances of this atom will be `"a constant value"` forever.

These "selector atoms" automatically set `readonly: true` and `ttl: 0` for instant cleanup. These selectors are probably different from the selectors you're used to. They are often impure.

A primary use of selectors is to hold references to class instances or expensive resources such as socket connections or fetched data that the UI shouldn't modify:

```ts
import { io } from 'socket.io-client'

// We use a factory so we don't create the connection until this atom is used
// Lazy initialization FTW
const socketAtom = selector('socket', () => io('ws://example.com/my-namespace'))
```

As you'd expect, another primary use of selector atoms is to derive data from other atoms:

```ts
const todosAtom = atom<Todo[]>('todos', [])

const filteredTodosAtom = selector('filteredTodos', (isDone: boolean) => {
  const todos = todsAtom.injectValue()

  return todos.filter(todo => todo.isDone === isDone)
})
```

## Stores

Every instance of every atom creates a light-weight store. Stores manage state and serve as a message bus for running side effects based on dispatched actions or state changes.

Atoms create most stores for you. But you can easily create them manually:

```ts
import { createStore } from '@zedux/react'

const myStore = createStore()
```

Stores have lots of cool features that we'll look at in [the stores tutorial](stores). For now, just remember that every atom instance has an underlying store.

## Recap

- `atom()` can take a config object.
- Atoms can be destroyed using `ttl` and/or `maxInstances`.
- 
- Ions are a special type of atom. They provide a convenient shorthand for state derivations. Use `ion()` to create them.

Next up we'll cover more ways to [consume atoms](using-atoms).
