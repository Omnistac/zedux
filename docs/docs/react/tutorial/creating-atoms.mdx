---
id: creating-atoms
title: Creating Atoms
---
<!-- 
import { ApisPlayground } from '@zedux/react/../ApisPlayground'

Through the rest of this tutorial we'll implement parts of this playground with Zedux:

<ApisPlayground /> -->

In the quick start, we learned a few basic ways to create atoms. In this page, we'll cover more advanced atom creation using config objects.

## Atom Config

Many aspects of an atom's behavior can be configured. The `atom()` factory can take a config object.

```ts
import { atom } from '@zedux/react'

// these 2 signatures are equivalent:
atom('foo', 'initial value')
atom({
  key: 'foo',
  value: 'initial value'
})
```

This config object has many useful properties:

```ts
import { atom, Scope } from '@zedux/react'

const fooAtom = atom({
  flags: ['async', 'electron'],
  key: 'foo',
  readonly: true,
  scope: Scope.Global,
  ttl: 1000 * 60 * 60,
  value: 'initial value'
})
```

We'll look at some of these now. See [`atom()`](TODO:link) for the full rundown.

### Readonly

Atoms can be made readonly with `readonly: true`. This modifies the API of the atom to avoid exposing any methods for modifying the atom's state to consumers.

```tsx
const readonlyAtom = atom({
  key: 'readonly',
  readonly: true,
  value: 0
})

function App() {
  const [state, setState] = readonlyAtom.useState() // Error!
  const dispatch = readonlyAtom.useDispatch() // Error!
  const value = readonlyAtom.useValue() // Good
  ...
}
```

See [`selector()`](TODO:link) for full details of readonly atoms.

### Scope

Atoms can be given a scope. Scope determines a lot about an atom's behavior, such as how instances are created and destroyed. There are 3 scopes:

- Global
- App
- Local

All atoms are app-scoped by default.

Atom scopes are important enough to get [their own tutorial](atom-scopes).

### TTL

When an atom instance is no longer used, we sometimes want to destroy it - allowing its data to be garbage collected. By default, all global-scoped and app-scoped atoms live forever. Global and app atoms can be given a `ttl` to configure how long atom instances should stick around when they're no longer in use.

```ts
const zombieAtom = atom({
  key: 'zombie',
  // keep stale zombieAtom instances in memory for 10 minutes:
  ttl: 1000 * 60 * 10
})
// if anyone uses the instance within 10 minutes, cleanup is cancelled
```

`ttl` can be set to `0` to clean up instances immediately.

## Selector Atoms

One atom configuration is particularly common in Zedux:

```ts
const aVeryCommonAtom = atom({
  key: 'aVeryCommon',
  readonly: true,
  ttl: 0,
  value: 'whatever'
})
```

Zedux exports a special factory for creating these:

```ts
import { selector } from '@zedux/react'

const mySelectorAtom = selector('mySelector', 'initial state')
```

The state of all instances of this atom will be `initial state` forever.

These "selector atoms" automatically set `readonly: true` and `ttl: 0` for instant cleanup. These selectors are probably different from the selectors you're used to. They are often impure. One of their primary uses is to hold references to class instances or expensive resources such as socket connections or fetched data that the UI shouldn't modify:

```ts
import { io } from 'socket.io-client'

// We use a factory so we don't create the connection until this atom is used
const socketAtom = selector('socket', () => io('ws://example.com/my-namespace'))
```

As you'd expect, another primary use of selector atoms is to derive data from other atoms:

```ts
const todosAtom = atom<Todo[]>('todos', [])

const filteredTodosAtom = selector('filteredTodos', (isDone: boolean) => {
  const todos = todsAtom.injectValue()

  return todos.filter(todo => todo.isDone === isDone)
})
```


## Recap

- `atom()` can take a config object.
- Readonly atoms can be created using `readonly: true`
- Atoms can be given a global or local scope with the `scope` property. All atoms are app-scoped by default.
- Atoms can be destroyed using `ttl`.
- Selector atoms are atoms with `readonly: true, ttl: 0`. They can be created with the `selector()` shorthand.

Next up we'll cover more ways to [consume atoms](using-atoms).
