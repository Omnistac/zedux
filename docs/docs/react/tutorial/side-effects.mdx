---
id: side-effects
title: Side Effects
---

import { LiveEditor } from '../../LiveEditor'

Zedux stores do not have middleware. Read more on that in the [Redux comparison](TODO:link). Basic side effects like logging and state persistence can be done by hooking into a store's side effects layer.

## `injectEffect()`

Your primary weapon for running side effects in atoms. This works just like React's [`useEffect()`](https://reactjs.org/docs/hooks-reference.html#useeffect).

<LiveEditor resultVar="App">{`
const alertAtom = atom('alert', () => {
  const initialRef = injectRef(true)\n
  // Passing true as the second param subscribes this atom to the store.
  // This means this atom will reevaluate when this store's state changes:
  const store = injectStore(0, true)\n
  injectEffect(() => {
    if (initialRef.current) {
      initialRef.current = false
      return
    }\n
    alert('Hey! You changed the state to ' + store.getState())
  }, [store.getState()])\n
  return store // remember to return the store
})\n
function App() {
  const [, setState] = alertAtom.useState()\n
  return <button onClick={() => setState(state => state + 1)}>Click Me</button>
}
`}</LiveEditor>

## Effects Subscribers

Stores can be given an effects subscriber:

```ts
function App() {
  const store = myAtom.useStore()

  useEffect(() => {
    const subscription = store.subscribe({
      effects: ({ action, newState, oldState }) => {
        console.log('store received action', { action, newState, oldState })
      }
    })

    return () => subscription.unsubscribe()
  }, [store])
  ...
}
```

See the full effect subscriber definition [here](TODO:link). Effects subscribers are simple and powerful. But you shouldn't need to rig them up manually. Zedux exposes a high-level API that does this for you:

## WhenBuilder

`when()` is a declarative and simple way to hook into stores. It has several methods for tying into certain events and status updates in stores.

### `.receivesAction()`

Calls an effect handler every time the store receives an action.

```ts
import { when } from '@zedux/react'

function App() {
  const store = myAtom.useStore()

  useEffect(() => {
    // highlight-next-line
    const { subscription } = when(store).receivesAction(
      ({ action, newState, oldState }) => {
        console.log('store received action', { action, newState, oldState })
      }
    )

    return () => subscription.unsubscribe()
  }, [store])
  ...
}
```

`.receivesAction()` can be given a specific actor or action type:

```ts
import { createActor, when } from '@zedux/react'

const login = createActor('login')
...
when(myStore).receivesAction(login, doStuffOnLogin)
```

In this way, stores can easily be consumed as streams of actions.

### `.stateChanges()`

Calls an effect handler every time the store's state changes in response to an action (which includes every time `.setState()` and `.hydrate()` are called).

```ts
when(myStore).stateChanges(({ action, newState, oldState }) => {
  console.log('store state changed', { action, newState, oldState })
})
```

### `.stateMatches()`

Calls an effect handler every time the store's state updates to match the passed predicate. Does not call the handler if the previous state also matched the predicate.

```ts
const counterStore = createStore(null, 0)

when(counterStore).stateMatches(
  num => num > 1,
  ({ newState, oldState }) => {
    console.log('triggered!', { newState, oldState })
  }
)

counterStore.setState(1)
counterStore.setState(2) // triggered! { newState: 2, oldState: 1 }
counterStore.setState(3)
counterStore.setState(0)
counterStore.setState(4) // triggered! { newState: 4, oldState: 0 }
```

To perform a side effect on every action or every state change while the predicate is matched, regardless of previous state, use `.receivesAction()` or `.stateChanges()` with a normal if statement:

```ts
when(counterStore).receivesAction(({ newState, oldState }) => {
  if (newState > 1) {
    console.log('triggered!', { newState, oldState })
  }
})

counterStore.setState(1)
counterStore.setState(2) // triggered! { newState: 2, oldState: 1 }
counterStore.setState(3) // triggered! { newState: 3, oldState: 2 }
counterStore.setState(0)
counterStore.setState(4) // triggered! { newState: 4, oldState: 0 }
```

### Machine Hooks

One of `when()`'s main features is registering `enter` and `leave` hooks for state machines:

```ts
when(myStore)
  .machine(({ activeState }) => activeState) // locate state machine
  .enters(ActiveState.Inactive, scheduleCleanup) // register onEnter hook
  .leaves(ActiveState.Inactive, destroy) // register onLeave hook
```

### Chaining

Multiple handlers can be chained together.

```ts
when(myStore)
  .receivesAction(logAction)
  .stateChanges(persistStateChange)

// Or
const whenMyStore = when(myStore)

whenMyStore.receivesAction(logAction)
whenMyStore.stateChanges(persistStateChange)
```

### Cleanup

As with all subscriptions, it's important to clean up effects subscribers when their context is destroyed (e.g. the component is unmounted or the atom instance is destroyed).

`when()` builders have a `subscription` property, which is a reference to the store subscription created by the `when()` call. Remember to call `subscription.unsubscribe()` in `useEffect` and `injectEffect`:

<LiveEditor resultVar="Button">{`
const triggerAlert = createActor('triggerAlert')\n
const buttonPressAtom = atom('buttonPress', () => {
  const store = injectStore()\n
  injectEffect(() => {
    const { subscription } = when(store).receivesAction(
      triggerAlert,
      () => alert('consider it done')
    )\n
    return () => subscription.unsubscribe()
  }, [store])\n
  return store
})\n
function Button() {
  const dispatch = buttonPressAtom.useDispatch()\n
  return (
    <button onClick={() => dispatch(triggerAlert())}>Do It</button>
  )
}
`}</LiveEditor>

For the full API, see [`when()`](TODO:link).

## A Note On Store Actions



## Observables



## Recap



## Next Steps
