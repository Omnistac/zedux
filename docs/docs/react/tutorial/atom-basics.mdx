---
id: atom-basics
title: Atom Basics
---
<!-- 
import { ApisPlayground } from '@zedux/react/../ApisPlayground'

Through the rest of this tutorial we'll implement parts of this playground with Zedux:

<ApisPlayground /> -->

So we know that atoms

## Atom Config

Many aspects of an atom's behavior can be configured. The `atom()` factory can take a config object:

```ts
import { atom } from '@zedux/react'

// these 2 signatures are equivalent:
atom('foo', 'initial value')
atom({
  key: 'foo',
  value: 'initial value'
})
```

This config object has many useful properties:

```ts
import { atom, Scope } from '@zedux/react'

const fooAtom = atom({
  flags: ['async', 'electron'],
  key: 'foo',
  readonly: true,
  scope: Scope.Global,
  ttl: 1000 * 60 * 60,
  value: 'initial value'
})
```

We'll look at some of these now. See [`atom()`](TODO:link) for the full rundown.

### Readonly

Atoms can be made readonly with `readonly: true`. This modifies the API of the atom to avoid exposing any methods for modifying the atom's state to consumers.

```tsx
const readonlyAtom = atom({
  key: 'readonly',
  readonly: true,
  value: 0
})

function App() {
  const [state, setState] = readonlyAtom.useState() // Error!
  const dispatch = readonlyAtom.useDispatch() // Error!
  const value = readonlyAtom.useValue() // Good
  ...
}
```

Since readonly atoms are so common, Zedux exports a special factory for creating them:

```ts
import { selector } from '@zedux/react'

const readonlyAtom = selector('readonly', 0)
```

The state of all instances of this atom will be `0` forever.

In Zedux, "selector" is just another term for "readonly atom". Zedux selectors are probably different from the selectors you're used to. They are often impure. One of their primary uses is to hold references to class instances or expensive resources such as socket connections or fetched data:

```ts
import { io } from 'socket.io-client'

// We use a factory so we don't create the connection until this atom is used
const socketAtom = selector('socket', () => io('ws://example.com/my-namespace'))
```

But they can also be used to derive data from other atoms:

```ts
const todosAtom = atom<Todo[]>('todos', [])

const filteredTodosSelector = selector('filteredTodos', (isDone: boolean) => {
  const todos = todsAtom.injectValue()

  return todos.filter(todo => todo.isDone === isDone)
})
```

### TTL

When an atom instance is no longer used, we sometimes want to destroy it - allowing its data to be garbage collected. By default, all global-scoped and app-scoped atoms live forever. Global and app atoms can be given a `ttl` to configure how long atom instances should stick around when they're no longer in use.

```ts
const zombieAtom = atom({
  key: 'zombie',
  // keep stale zombieAtom instances in memory for 10 minutes:
  ttl: 1000 * 60 * 10
})
// if anyone uses the instance within 10 minutes, cleanup is cancelled
```

`ttl` can be set to `0` to clean up instances immediately.

## Stores

Every instance of every atom creates a light-weight Zedux store. Stores manage lots of the heavy lifting for atoms, such as storing and updating state, telling consumer atoms to reevaluate, telling React components to rerender, and running side effects based on dispatched actions or resulting state changes.

Atoms create most stores for you. But you can easily create them manually:

```ts
import { createStore } from '@zedux/react'

const myStore = createStore()
```

Stores have lots of cool features that we'll look at soon. For now, just remember that every atom instance has an underlying store. Some hooks and injectors subscribe to the store, and others do not.

## Subscribing Hooks/Injectors

The following hooks/injectors subscribe to the atom instance's underlying store:

- `.useSelector()`/`.injectSelector()` TODO: these
- `.useState()`/`.injectState()` TODO: these
- `.useValue()`/`.injectValue()`

That means that when the atom instance's store's state changes, components that use these hooks will rerender and atoms that use these injectors will reevaluate.

```tsx
function App() {
  // whenever myAtom's state changes, this component will rerender
  const value = myAtom.useValue()
  ...
}

const dependentAtom = atom('dependent', () => {
  // whenever myAtom's state changes, this atom will reevaluate
  const [state, setState] = myAtom.injectState()
  ...
})
```

## Non-Subscribing Hooks/Injectors

The following hooks/injectors do not subscribe to the atom instance's underlying store:

- `.useConsumer()`
- `.useDispatch()`/`.injectDispatch()` TODO: these
- `.useInstance()`/`.injectInstance()`
- `.useInvalidate()`/`.injectInvalidate()`
- `.useLazy()`/`.injectLazy()`
- `.useMethods()`/`.injectMethods()`
- `.useSetState()`/`.injectSetState()` TODO: these
- `.useStore()`/`.injectStore()` TODO: these

## Instances

Atoms expose a `.useInstance()` hook and `.injectInstance()` injector. These can be used to get a reference to an instance of the atom. This does not subscribe to the atom's store. This hook/injector can be used to avoid needing to re-specify params on parameterized atoms:

```tsx
function App() {
  // Before:
  const params = [{ some: ['complex', 'params'] }, 'here']
  const value = myAtom.useValue(...params)
  const dispatch = myAtom.useDispatch(...params)

  // After:
  // highlight-next-line
  const instance = myAtom.useInstance({ some: ['complex', 'params'] }, 'here')
  const value = instance.useValue() // no need to pass params here
  const dispatch = instance.useDispatch() // nor here
  ...
}
```

In this example, note that while `myAtom.useInstance()` does not subscribe to the instance's store, `instance.useValue()` does.

`.useInstance()` can also be used in conjunction with `.useConsumer()` to provide an instance over React context, so deeply nested children don't need to know the params of a specific atom instance they want to reuse:

```tsx
function Parent() {
  const instance = myAtom.useInstance('some', 'params')

  return (
    <instance.Provider>
      <Child />
    </instance.Provider>
  )
}

function Child() {
  const instance = myAtom.useConsumer() // no need to pass params here
  const value = instance.useValue() // subscribe to the instance's store
}
```

## Recap

Atoms 