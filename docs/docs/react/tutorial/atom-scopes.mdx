---
id: atom-scopes
title: Atom Scopes
---

## Scopes

Atoms can be given scopes. An atom's scope determines a lot about its behavior:

- Which atom ecosystem it lives in
- When and how instances are created
- When and whether instances die
- How it interacts with other atoms

The available scopes are:

- Global
- App
- Local

### Global

As you can guess, global atoms usually live in the global ecosystem.

```tsx
import { atom, Scope } from '@zedux/react'

const myGlobalAtom = atom({
  key: 'myGlobal',
  scope: Scope.Global,
  value: 'I will never die. I live as long as the stars. I am inevitable. Incredible. Invincible. In...decisive? (y r u reading this...)'
})
```

We say they "*usually* live in the global ecosystem" because there is an exception - when an AppProvider overrides a global atom (see the [DI tutorial](TODO:link)). In that case, an essentially "app-scoped" version of the global atom is created and used only within that app.

### App

All atoms are app-scoped by default. App atoms usually live in an app ecosystem.

```tsx
import { atom } from '@zedux/react'

// no need to specify scope here. App is the default.
const myAppAtom = atom('myApp', 'I die when my app dies (by default)')
```

Again, there is an exception. When no AppProvider is rendered, app atoms will actually be added to the global ecosystem (see the [Global Only approach](atom-ecosystems#global-only-approach)).

### Local

Local atoms are a very unique concept. Their primary use is very similar to React context's.

```tsx
import { atom, Scope } from '@zedux/react'

const myLocalAtom = atom({
  key: 'myLocal',
  scope: Scope.Local,
  value: 'I am like React context but with Zedux superpowers'
})
```

Ecosystem-wise, local atoms behave just like app atoms - usually living in an app ecosystem but deferring to global when no AppProvider exists. But their use cases are very different from app and global atoms. They also have a slightly different API. We'll cover some of the API differences in the next section.

## Scopes Comparison

### Ecosystem

It can be difficult to remember which atom types get added to which ecosystems. This chart breaks down all possible scenarios:

| Atom Scope | Outside `<AppProvider>` | Inside `<AppProvider>` | Overridden in `<AppProvider>` |
| --- | --- | --- | --- |
| Global | Global ecosystem | Global ecosystem | Overriding app ecosystem |
| App | Global ecosystem | Nearest app ecosystem | Nearest app ecosystem |
| Local | Global ecosystem | Nearest app ecosystem | Nearest app ecosystem |

Note that app and local atoms are exactly the same.

### Instantiation

#### Global and App Atoms

Global and app atoms are instantiated the first time they're used in their ecosystem. All hooks/injectors except `.useConsumer()` accept atom params. They will attempt to reuse an existing instance, or create one if none exists in their ecosystem.

```tsx
function App() {
  const myGlobal = myGlobalAtom.useValue()
  const myApp = myAppAtom.useValue('some', 'params') // create new instance
  const myAppAgain = myAppAtom.useValue('some', 'params') // reuse instance
  ...
}
```

#### Local Atoms

Local atoms are different. They're instantiated every time their `useInstance()` hook or `injectInstance()` injector is called.

```tsx
function App() {
  const instanceOne = myLocalAtom.useInstance()
  const instanceTwo = myLocalAtom.useInstance() // a different instance!
  ...
}
```

All other hooks are aliases for `.useConsumer().use<hook name here>()`. They expect an instance to be provided over React. They do not accept atom params.

```tsx
const loginFormAtom = atom({
  key: 'loginForm',
  scope: Scope.Local,
  value: () => ({
    email: '',
    password: ''
  })
})

function LoginForm() {
  const loginForm = loginFormAtom.useInstance()

  return (
    <loginForm.Provider>
      <Email />
      <Password />
    </loginForm.Provider>
  )
}

function Email() {
  // A shorthand for `loginForm.useConsumer().useState()`:
  const [{ email }, setState] = loginFormAtom.useState()
  ...
}

function Password() {
  // (see above comment)
  const [{ password }, setPassword] = loginFormAtom.useState()
  ...
}
```

Local atoms only have one injector - `.injectInstance()`. The instance returned has all the normal instance injectors.
