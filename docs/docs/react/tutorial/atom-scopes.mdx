---
id: atom-scopes
title: Atom Scopes
---

## Scopes

Atoms can be given scopes. An atom's scope determines a lot about its behavior:

- Which atom ecosystem it lives in
- When and how instances are created
- When and whether instances die
- How it interacts with other atoms

The available scopes are:

- Global
- App
- Local

### Global

As you can guess, global atoms usually live in the global ecosystem.

```tsx
import { atom, Scope } from '@zedux/react'

const myGlobalAtom = atom({
  key: 'myGlobal',
  scope: Scope.Global,
  value: 'I will never die. I live as long as the stars. I am inevitable. Incredible. Invincible. In...decisive? (y r u reading this...)'
})
```

We say they "*usually* live in the global ecosystem" because there is an exception - when an AppProvider overrides a global atom (see the [DI tutorial](TODO:link)). In that case, an essentially "app-scoped" version of the global atom is created and used only within that app.

### App

All atoms are app-scoped by default. App atoms usually live in an app ecosystem.

```tsx
import { atom } from '@zedux/react'

// no need to specify scope here. App is the default.
const myAppAtom = atom('myApp', 'I die when my app dies (by default)')
```

Again, there is an exception. When no AppProvider is rendered, app atoms will actually be added to the global ecosystem (see the [Global Only approach](atom-ecosystems#global-only-approach)).

### Local

Local atoms are a very unique concept. Their primary use is very similar to React context's.

```tsx
import { atom, Scope } from '@zedux/react'

const myLocalAtom = atom({
  key: 'myLocal',
  scope: Scope.Local,
  value: 'I am like React context but with Zedux superpowers'
})
```

Ecosystem-wise, local atoms behave just like app atoms - usually living in an app ecosystem but deferring to global when no AppProvider exists. But their use cases are very different from app and global atoms. They also have a slightly different API. We'll cover some of the API differences in the next section.

## Scopes Comparison

### Ecosystem

It can be difficult to remember which atom types get added to which ecosystems. This chart breaks down all possible scenarios:

| Atom Scope | Outside `<AppProvider>` | Inside `<AppProvider>` | Overridden in `<AppProvider>` |
| --- | --- | --- | --- |
| Global | Global ecosystem | Global ecosystem | Overriding app ecosystem |
| App | Global ecosystem | Nearest app ecosystem | Nearest app ecosystem |
| Local | Global ecosystem | Nearest app ecosystem | Nearest app ecosystem |

Note that app and local atoms work exactly the same here.

### Instantiation

#### Global and App Atoms

Global and app atoms are instantiated the first time they're used in their ecosystem. All hooks/injectors except `.useConsumer()` accept atom params. They will attempt to reuse an existing instance, or create one if none exists in their ecosystem.

```tsx
function App() {
  const myGlobal = myGlobalAtom.useValue()
  const myApp = myAppAtom.useValue('some', 'params') // create new instance
  const myAppAgain = myAppAtom.useValue('some', 'params') // reuse instance
  ...
}
```

#### Local Atoms

Local atoms are different. They're instantiated every time their `useInstance()` hook or `injectInstance()` injector is called.

```tsx
function App() {
  const instanceOne = myLocalAtom.useInstance()
  const instanceTwo = myLocalAtom.useInstance() // a different instance!
  ...
}
```

All other local atom hooks are aliases for `.useConsumer().use<hook name here>()`. They expect an instance to be provided over React. They do not accept atom params.

```tsx
const loginFormAtom = atom({
  key: 'loginForm',
  scope: Scope.Local,
  value: () => ({
    email: '',
    password: ''
  })
})

function LoginForm() {
  const loginForm = loginFormAtom.useInstance()

  return (
    // highlight-next-line
    <loginForm.Provider>
      <Email />
      <Password />
    </loginForm.Provider>
  )
}

function Email() {
  // A shorthand for `loginForm.useConsumer().useState()`:
  // highlight-next-line
  const [{ email }, setState] = loginFormAtom.useState()
  ...
}

function Password() {
  // (same as above)
  // highlight-next-line
  const [{ password }, setPassword] = loginFormAtom.useState()
  ...
}
```

Local atoms only have one injector - `.injectInstance()`. The instance returned has all the normal instance injectors. While this works and it's fine to use, local atoms aren't really intended for use in other atoms.

### Destruction

An atom's scope affects when cleanup happens.

#### Global

Global atoms in a global ecosystem live forever by default. Global atoms overridden in an AppProvider live as long as that AppProvider by default. This default can be changed with `ttl`:

```ts
const globalConfigAtom = atom({
  key: 'globalConfig',
  scope: Scope.Global,
  ttl: 1000 * 60 * 15, // clean up if unused for 15 minutes
  value: {
    environment: process.env.NODE_ENV
  }
})
```

If no `ttl` is specified, global atoms can only be cleaned up by calling `wipe()`. This is needed in tests:

```ts
import { wipe } from '@zedux/react'

afterEach(() => {
  wipe()
})
```

#### App

App atoms in a global ecosystem live forever by default. App atoms in an app ecosystem live as long as their AppProvider stays mounted by default. This default can be changed with `ttl`:

```ts
const appConfigAtom = atom({
  key: 'appConfig',
  ttl: 1000 * 60 * 15, // clean up if unused for 15 minutes
  value: {
    version: process.env.VERSION
  }
})
```

#### Local

Local atoms are always cleaned up when they're no longer in use. This can't be configured (local atoms don't take a `ttl`).

In most cases, this means that when the component or atom that created the local atom instance is unmounted or destroyed, the local atom instance will also be destroyed. Since this is similar to how React context providers work, this is usually what you want.

```tsx
const loginFormAtom = atom({
  key: 'loginForm',
  scope: Scope.Local,
  value: () => ({
    email: '',
    password: ''
  })
})

function LoginForm() {
  // When LoginForm is unmounted, this new instance will be destroyed:
  const loginFormInstance = loginFormAtom.useInstance()

  return (
    <loginFormInstance.Provider>
      <Child />
    </loginFormInstance.Provider>
  )
}
```

## Recap

- Global atoms typically live in a global ecosystem and don't die.
- App atoms typically live in an app ecosystem and die when their AppProvider dies.
- Local atoms typically live in an app ecosystem and die when no longer in use.
- Global and app atom instances are created when they're first used (regardless of the hook or injector used).
- Local atom instances are created every time `.useInstance()` or `.injectInstance()` are used.

## Next Steps

We've got a pretty firm grasp on high-level atom creation, instantiation, and usage. It's time to step into the low-levels and learn about [stores](stores).
