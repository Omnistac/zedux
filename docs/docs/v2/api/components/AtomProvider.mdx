---
id: AtomProvider
title: AtomProvider
---

import { Legend, Item, Link, Tabs, Ts, tab1, tab2 } from '@site/src/all'

```ts
import { AtomProvider } from '@zedux/react'
```

A component that provides one or more [atom instances](../classes/AtomInstance) over React context.

Use [`useAtomContext()`](../hooks/useAtomContext.mdx) to consume the provided instance(s).

## Example

```tsx live ecosystemId=AtomProvider/example resultVar=Parent version=2
const secondsAtom = atom('seconds', (start: number) => {
  const signal = injectSignal(start)

  injectEffect(() => {
    const intervalId = setInterval(() => signal.set(val => val + 1), 1000)

    return () => clearInterval(intervalId)
  }, [])

  return signal
})

function Child() {
  const instance = useAtomContext(secondsAtom) // no need to pass params
  const state = useAtomValue(instance) // subscribe to updates

  return <div>Child's Seconds: {state}</div>
}

function Parent() {
  const instance = useAtomInstance(secondsAtom, [100])

  return (
    <AtomProvider instance={instance}>
      <Child />
    </AtomProvider>
  )
}
```

Providing multiple instances:

```tsx
<AtomProvider instances={[instanceA, instanceB]}>
  <Child />
</AtomProvider>
```

## Dynamic Providers

Sometimes you need to provide an atom instance without creating a dependency on the provided instance in the providing component. This can be necessary when the provided atom instance triggers suspense but the providing component is the one defining the suspense boundary.

For this case, `AtomProvider`'s `instance` and `instances` props accept a function. The function will be called with the current ecosystem and should return the atom instance(s) to provide.

```tsx
// since this atom triggers suspense, it needs to be used under a suspense
// boundary
const exampleAtom = atom('example', () => {
  return api(
    new Promise(resolve => {
      setTimeout(() => {
        resolve('Hello, world!')
      }, 1000)
    })
  )
})

function Child() {
  const value = useAtomValue(useAtomContext(exampleAtom, true))

  return <div>{value}</div>
}

function Parent() {
  // we don't want to `useAtomInstance(exampleAtom)` here since the suspense
  // boundary isn't defined yet.

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <AtomProvider instance={ecosystem => ecosystem.getNode(exampleAtom)}>
        <Child />
      </AtomProvider>
    </Suspense>
  )
}
```

This function overload is also useful for providing multiple instances at once:

```tsx
<AtomProvider
  instances={ecosystem => ecosystem.findAll('my/providers/namespace')}
>
  <Child />
</AtomProvider>
```

This is extremely flexible.

## Signature

<Tabs>
  {tab1(
    `<AtomProvider instance={instance}>
    {children}
  </AtomProvider>
  // or
  <AtomProvider instances={[instanceA, instanceB]}>
    {children}
  </AtomProvider>`,
    true
  )}
  {tab2(`declare const AtomProvider: (
    props:
      | {
          children?: ReactNode
          instance: AnyAtomInstance | ((ecosystem: Ecosystem) => AnyAtomInstance)
          instances?: undefined
        }
      | {
          children?: ReactNode
          instance?: undefined
          instances:
            | AnyAtomInstance[]
            | ((ecosystem: Ecosystem) => AnyAtomInstance[])
        }
  ) => ReactElement`)}
</Tabs>

## Props

AtomProvider accepts **either** an `instance` prop to provide a single atom instance OR an `instances` prop to provide multiple instances. You must pass one or the other but not both.

<Legend>
  <Item name="instance">
    A single [atom instance](../classes/AtomInstance) or a function that receives the ecosystem and returns an atom instance. This instance will be provided over React context.

    See the above section on [dynamic providers](#dynamic-providers) for examples of when the function overload is useful.

  </Item>
  <Item name="instances">
    An array of atom instances or a function that receives the ecosystem and returns an array of atom instances. Each instance will be provided via a separate React context provider.

    Be careful reordering this list and adding/removing items since this will make React destroy/recreate the entire component subtree inside `<AtomProvider>`.

    See the above section on [dynamic providers](#dynamic-providers) for examples of when the function overload is useful.

  </Item>
</Legend>

## See Also

- [The React Context walkthrough](../../../walkthrough/react-context.mdx)
- [The `useAtomContext` hook](../hooks/useAtomContext.mdx)
- [The `useAtomInstance` hook](/not-done?path=../hooks/useAtomInstance)
