---
id: glossary
title: Glossary
---

### Dynamic Graph Dependency

When one [graph node](#graph-node) depends on another, Zedux draws an edge between those two nodes in its internal graph.

A "dynamic" dependency is a dependency that will trigger updates in the dependent node when the dependency node's state updates. Contrast this to [static dependencies](#static-graph-dependency), which do not trigger updates.

If the dependent is a React component, it will rerender when the dependency atom instance's state changes.

If the dependent is another atom instance, it will reevaluate when the dependency atom instance's state changes.

### Graph Edge

The edges between [graph nodes](#graph-node). These edges can have several properties, depending on how the edge was created and how it should behave.

Edges can be static or dynamic, internal or external, and async or synchronous. They can be identified by an "operation" string that helps when debugging.

These can be created manually with [manual graphing](../../walkthrough/destruction#manual-graphing).

### Graph Node

Zedux builds an internal graph to manage atom dependencies and propagate updates in an optimal way. There are many types of nodes in this graph:

- [Atom instances](./classes/AtomInstance)
- [Selector instances](./classes/SelectorInstance.mdx)
- [Signals](./classes/Signal)
- [`injectMemo`](/not-done?path=./injectors/injectMemo) calls with no deps array (enabling automatic dependency tracking)
- "External" nodes created for React components and event listeners.

Every node extends [the `ZeduxNode` class](./classes/ZeduxNode).

### Injector

Injectors are the "hooks" of Atoms. Zedux exports several injectors.

There are 3 basic types of injectors:

- React-hook equivalents, like [`injectEffect`](/not-done?path=./injectors/injectEffect), [`injectMemo`](/not-done?path=./injectors/injectMemo), and [`injectRef`](/not-done?path=./injectors/injectRef).
- Dependency injectors, like [`injectAtomValue`](/not-done?path=./injectors/injectAtomValue) and [`injectAtomInstance`](/not-done?path=./injectors/injectAtomInstance).
- Utility or dev X injectors, such as [`injectEcosystem`](/not-done?path=./injectors/injectEcosystem) and [`injectWhy`](/not-done?path=./injectors/injectWhy).

Injectors should only be used at the top level of [atom state factories](#state-factory). Don't use them in loops or conditional statements.

Injectors can be used any number of times throughout an atom state factory. For certain one-off operations like setting an atom instance's exports or setting a suspense promise, use an [AtomApi](./classes/AtomApi).

Like hooks, you can create custom injectors that compose other injectors. The convention is to start all injectors with the word "inject", similar to the word "use" with React hooks.

### Reactive Context

A function execution context in which Zedux automatically tracks dependencies. Atom state factories, selectors, and auto-tracked [`injectMemo`](/not-done?path=./injectors/injectMemo#auto-tracking) calls create reactive contexts.

In a reactive context, any [`node.get()`](./classes/ZeduxNode#get) or [`ecosystem.get()`](./classes/Ecosystem#get) calls will register [dynamic graph dependencies](#dynamic-graph-dependency) on the retrieved node, and any [`ecosystem.getNode()`](./classes/Ecosystem#getnode) calls will register [static graph dependencies](#static-graph-dependency). This automatic dependency tracking is a staple in reactive libraries like Zedux.

### Scope

A group of contextual values. In Zedux, this is always represented with a JS Map mapping "context" objects (e.g. React context objects or Zedux [atom instances](./classes/AtomInstance)) to their values. E.g.:

```tsx live ecosystemId=scope-example resultVar=val version=2
const ecosystem = createEcosystem()
const exampleReactContext = React.createContext<undefined | string>(undefined)
const contextAtom = atom('example', () => 'atom state')

const exampleScope = new Map([
  // react contexts get mapped to their provided values
  [exampleReactContext, 'react state'],

  // atom templates get mapped to their atom instances
  [contextAtom, ecosystem.getNode(contextAtom)],
])

const scopedAtom = atom(
  'scoped',
  () => inject(contextAtom).get() + ' ' + inject(exampleReactContext)
)

const val = ecosystem.withScope(exampleScope, () => ecosystem.get(scopedAtom))
```

### Scoped Atom

An atom that contains one or more [`inject`](/not-done?path=./injectors/inject) calls. Such atoms must be called with ["scope"](#scope) - e.g. by providing contextual values via Provider components in React or by calling [`ecosystem.withScope`](/not-done?path=./classes/Ecoysstem#withscope)

### State Factory

A function passed to [`atom()`](./factories/atom) (or other atom factory functions like [`ion()`](/not-done?path=./factories/ion)). This function is called to produce the initial value of the atom instance. It also runs every time an atom instance reevaluates.

These are similar to render functions in React. Except of course they return state instead of UI.

### Static Graph Dependency

When one [graph node](#graph-node) depends on another, Zedux draws an edge between those two nodes in its internal graph algorithm.

A "static" dependency is a dependency that does not trigger updates in the dependent node when the dependency node's state updates. Contrast this to [dynamic dependencies](#dynamic-graph-dependency), which do trigger updates.

While they don't trigger updates, static dependencies are still useful for informing Zedux that an atom instance is in use. Zedux won't try to clean up atom instances that still have dependents.

### Unrestricted Injector

An [injector](#injector) whose use isn't restricted like normal injectors. An unrestricted injector still must be used inside an atom state factory (called synchronously during evaluation). However, unlike normal injectors, unrestricted injectors can be used in control flow statements (`if`, `for`, `while`) or after early returns.

You usually won't need to worry about this distinction. Just use them like normal injectors and you'll be fine.

Examples of unrestricted injectors include [`injectEcosystem()`](/not-done?path=./injectors/injectEcosystem), [`injectSelf()`](/not-done?path=./injectors/injectSelf), and [`injectWhy()`](/not-done?path=./injectors/injectWhy).
